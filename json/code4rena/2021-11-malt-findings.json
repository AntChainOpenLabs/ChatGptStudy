[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Timelock\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Fairly basic timelock contract\ncontract Timelock is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  // The amount of delay after which a delay can a queued can be executed.\n  uint256 public delay = 2 days;\n  // The the period within which an queued proposal can be executed.\n  uint256 public gracePeriod = 7 days;\n\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  event NewDelay(uint256 indexed newDelay_);\n  event NewGracePeriod(uint256 indexed newGracePerios_);\n  event NewGovernor(address newGovernor);\n  event CancelTransaction(\n    bytes32 indexed txHash_,\n    address indexed target_,\n    uint256 value_,\n    string signature_,\n    bytes data_,\n    uint256 eta_\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash_,\n    address indexed target_,\n    uint256 value_,\n    string signature_,\n    bytes data_,\n    uint256 eta_\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash_,\n    address indexed target_,\n    uint256 value_,\n    string signature_,\n    bytes data_,\n    uint256 eta_\n  );\n\n  address public governor;\n\n  function initialize(address _admin, address _governor) external initializer {\n    _adminSetup(_admin);\n    _setupRole(GOVERNOR_ROLE, address(this));\n    _setupRole(GOVERNOR_ROLE, _governor);\n    _setRoleAdmin(GOVERNOR_ROLE, TIMELOCK_ROLE);\n\n    governor = _governor;\n  }\n\n  receive() external payable {}\n\n  /**\n   * @notice Sets the amount of time after which a proposal that has been queued can be executed.\n   */\n  function setDelay(uint256 _delay)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    require(\n      _delay >= 0 && _delay < gracePeriod,\n      \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"\n    );\n    delay = _delay;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @notice Sets the amount of time within which a queued proposal can be executed.\n   */\n  function setGracePeriod(uint256 _gracePeriod)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    require(\n      _gracePeriod > delay,\n      \"Timelock::gracePeriod: Grace period must be greater than delay\"\n    );\n    gracePeriod = _gracePeriod;\n\n    emit NewGracePeriod(gracePeriod);\n  }\n\n  /**\n   * @notice Sets the governor address that is allowed to make proposals\n   */\n  function setGovernor(address _governor)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    _swapRole(_governor, governor, GOVERNOR_ROLE);\n    governor = _governor;\n    emit NewGovernor(_governor);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  )\n    public\n    onlyRole(GOVERNOR_ROLE, \"Timelock::queueTransaction: Call must come from governor.\")\n    returns (bytes32)\n  {\n    require(\n      eta >= block.timestamp.add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(\n      abi.encode(target, value, signature, data, eta)\n    );\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  )\n    public\n    onlyRole(GOVERNOR_ROLE, \"Timelock::cancelTransaction: Call must come from governor.\")\n  {\n    bytes32 txHash = keccak256(\n      abi.encode(target, value, signature, data, eta)\n    );\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  )\n    public\n    payable\n    onlyRole(GOVERNOR_ROLE, \"Timelock::executeTransaction: Call must come from governor.\")\n    returns (bytes memory)\n  {\n    bytes32 txHash = keccak256(\n      abi.encode(target, value, signature, data, eta)\n    );\n    require(\n      queuedTransactions[txHash],\n      \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      block.timestamp >= eta,\n      \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      block.timestamp <= eta.add(gracePeriod),\n      \"Timelock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(\n        bytes4(keccak256(bytes(signature))),\n        data\n      );\n    }\n\n    (bool success, bytes memory returnData) = target.call{value: value}(\n      callData\n    );\n\n    require(\n      success,\n      \"Timelock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n}\n\n\n",
        "CodeNames": [
            "Timelock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n  function setGovernor(address _governor)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    _swapRole(_governor, governor, GOVERNOR_ROLE);\n    governor = _governor;\n    emit NewGovernor(_governor);\n  }\n",
                    "//solidity\n  function setDelay(uint256 _delay)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    require(\n      _delay = 0 && _delay < gracePeriod,\n      \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"\n    );\n    delay = _delay;\n\n    emit NewDelay(delay);\n  }\n"
                ],
                "Type": " Timelock can be bypassed",
                "Description": "\nThe purpose of a Timelock contract is to put a limit on the privileges of the governor, by forcing a two step process with a preset delay time.\n\nHowever, we found that the current implementation actually won't serve that purpose as it allows the governor to execute any transactions without any constraints.\n\nTo do that, the current governor can call Timelock#setGovernor(address _governor) and set a new governor effective immediately.\n\nAnd the new governor can then call Timelock#setDelay() and change the delay to 0, also effective immediately.\n\nThe new governor can now use all the privileges without a delay, including granting minter role to any address and mint unlimited amount of MALT.\n\nIn conclusion, a Timelock contract is supposed to guard the protocol from lost private key or malicious actions. The current implementation won't fulfill that mission.\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L98-L105\n\nsolidity\n  function setGovernor(address _governor)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    _swapRole(_governor, governor, GOVERNOR_ROLE);\n    governor = _governor;\n    emit NewGovernor(_governor);\n  }\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77\n\nsolidity\n  function setDelay(uint256 _delay)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    require(\n      _delay = 0 && _delay < gracePeriod,\n      \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"\n    );\n    delay = _delay;\n\n    emit NewDelay(delay);\n  }\n\n\n",
                "Repair": "\nConsider making setGovernor and setDelay only callable from the Timelock contract itself.\n\nSpecificaly, changing from onlyRole(GOVERNOR_ROLE, \"Must have timelock role\") to require(msg.sender == address(this), \"...\").\n\nAlso, consider changing _adminSetup(_admin) in Timelock#initialize() to _adminSetup(address(this)), so that all roles are managed by the timelock itself as well.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/263)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/263#issuecomment-1008067115):\n  The warden has identified an exploit that allows to sidestep the delay for the timelock, effectively bypassing all of the timelock's security guarantees. Because of the gravity of this, I agree with the high risk severity.\n \n Mitigation can be achieved by ensuring that all operations run under a time delay\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Auction.sol\";\n\n\nstruct EarlyExitData {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n}\n\nstruct AuctionExits {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n  mapping(address => EarlyExitData) accountExits;\n}\n\n\n/// @title Auction Escape Hatch\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Functionality to reduce risk profile of holding arbitrage tokens by allowing early exit\ncontract AuctionEscapeHatch is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  uint256 public maxEarlyExitBps = 200; // 20%\n  uint256 public cooloffPeriod = 60 * 60 * 24; // 24 hours\n\n  mapping(uint256 => AuctionExits) internal auctionEarlyExits;\n\n  event EarlyExit(address account, uint256 amount, uint256 received);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    address _auction,\n    address _handler\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function exitEarly(uint256 _auctionId, uint256 amount, uint256 minOut) external notSameBlock {\n    uint256 maltQuantity = _calculateMaltRequiredForExit(_auctionId, amount);\n\n    // TODO ensure this contract is added as a mint requester Sat 06 Nov 2021 20:13:49 GMT\n    malt.mint(address(dexHandler), maltQuantity);\n    uint256 amountOut = dexHandler.sellMalt();\n\n    require(amountOut > minOut, \"EarlyExit: Insufficient output\");\n\n    AuctionExits storage auctionExits = auctionEarlyExits[_auctionId];\n\n    auctionExits.exitedEarly = auctionExits.exitedEarly + amount;\n    auctionExits.earlyExitReturn = auctionExits.earlyExitReturn + amountOut;\n    auctionExits.maltUsed = auctionExits.maltUsed + maltQuantity;\n    auctionExits.accountExits[msg.sender].exitedEarly = auctionExits.accountExits[msg.sender].exitedEarly + amount; \n    auctionExits.accountExits[msg.sender].earlyExitReturn = auctionExits.accountExits[msg.sender].earlyExitReturn + amountOut; \n    auctionExits.accountExits[msg.sender].maltUsed = auctionExits.accountExits[msg.sender].maltUsed + maltQuantity; \n\n    auction.amendAccountParticipation(\n      msg.sender,\n      _auctionId,\n      amount,\n      maltQuantity\n    );\n\n    collateralToken.safeTransfer(msg.sender, amountOut);\n    emit EarlyExit(msg.sender, amount, amountOut);\n  }\n\n  function earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    if(active || block.timestamp < auctionEndTime) {\n      return 0;\n    }\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(account, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    uint256 userOutstanding = userCommitment - userRedeemed;\n\n    if (amount > userOutstanding) {\n      amount = userOutstanding;\n    }\n\n    if (amount == 0) {\n      return 0;\n    }\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      return amount + maxProfit;\n    } \n\n    return fullReturn;\n  }\n\n  function accountAuctionExits(address account, uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    EarlyExitData storage accountExits = auctionEarlyExits[auctionId].accountExits[account];\n\n    return (accountExits.exitedEarly, accountExits.earlyExitReturn, accountExits.maltUsed);\n  }\n\n  function globalAuctionExits(uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    AuctionExits storage auctionExits = auctionEarlyExits[auctionId];\n\n    return (auctionExits.exitedEarly, auctionExits.earlyExitReturn, auctionExits.maltUsed);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    require(!active, \"Cannot exit early on an active auction\");\n    require(block.timestamp > auctionEndTime, \"Auction not over\");\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(msg.sender, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    if (amount > (userCommitment - userRedeemed)) {\n      amount = userCommitment - userRedeemed;\n    }\n\n    require(amount > 0, \"Nothing to claim\");\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      uint256 desiredReturn = amount + maxProfit;\n      maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;\n    } \n\n    return maltQuantity;\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setEarlyExitBps(uint256 _earlyExitBps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, \"Must be between 0-100%\");\n    maxEarlyExitBps = _earlyExitBps;\n  }\n\n  function setCooloffPeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_period > 0, \"Cannot have 0 lookback period\");\n    cooloffPeriod = _period;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol",
            "AuctionEscapeHatch.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "earlyExitReturn()",
                    "getAuctionCore()",
                    "_calculateMaltRequiredForExit"
                ],
                "Type": " getAuctionCore function returns wrong values out of order",
                "Description": "\n\n\n\nIn the AuctionEscapeHatch.sol file both earlyExitReturn() and _calculateMaltRequiredForExit call the getAuctionCore() function which has 10 possible return values most of which are not used.  It gets the wrong value back for the \"active\"  variable since it's the 10th argument but both functions have it as the 9th return value where \"preAuctionReserveRatio\" should be because of one missing comma.  This is serious because these both are functions which deal with allowing a user to exit their arbitrage token position early.  This can result in a loss of user funds.\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L100\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L174\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L527\n\n\nManual code review\n\n",
                "Repair": "\nIn AuctionEscapeHatch.sol change the following in _calculateMaltRequiredForExit() and earlyExitReturn() functions:\n\nFrom:\n\n(,,,,,\nuint256 pegPrice,\n,\nuint256 auctionEndTime,\nbool active\n) = auction.getAuctionCore(_auctionId);\n\nTo:\n\n(,,,,,\nuint256 pegPrice,\n,\nuint256 auctionEndTime,\n,\nbool active\n) = auction.getAuctionCore(_auctionId);\n\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/63)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/63#issuecomment-1019278807):\n  The warden identified a mistake in programming where the code would use the wrong returned value.\n Because of this, the entire protocol functionality can be compromised.\n As such I agree with High Severity\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/IStabilizerNode.sol\";\nimport \"./Auction.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Auction Burn Reserve Skew\n/// @author 0xScotch <scotch@malt.money>\n/// @notice This contract makes decisions about what do to with excess Liquidity Extension balance at the end of an auction. Burn additional Malt or retain capital in LE\ncontract AuctionBurnReserveSkew is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  // An array of 0s or 1s that track if active stabilization was \n  // needed above or below peg.\n  // 0 = below peg\n  // 1 = above peg\n  //\n  // By doing this we can average the array to get a value that\n  // indicates if we are more frequently over or under peg.\n  uint256[] public pegObservations;\n  uint256 public auctionAverageLookback = 10;\n\n  IStabilizerNode public stabilizerNode;\n  IAuction public auction;\n\n  // This is the total number of stabilization observation we have seen\n  uint256 public count;\n\n  event SetAuctionAverageLookback(uint256 lookback);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetAuction(address auction);\n  event AbovePegObservation(uint256 amount);\n  event BelowPegObservation(uint256 amount);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _stabilizerNode,\n    address _auction,\n    uint256 _period\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    stabilizerNode = IStabilizerNode(_stabilizerNode);\n    auction = IAuction(_auction);\n    auctionAverageLookback = _period;\n\n    for (uint i = 0; i < _period; i++) {\n      pegObservations.push(0);\n    }\n  }\n\n  function consult(uint256 excess) public view returns (uint256) {\n    uint256 frequency = getPegDeltaFrequency();\n    uint256 participation = getAverageParticipation();\n\n    // Weight participation higher than frequency\n    uint256 skew = (frequency + (participation * 2)) / 3;\n\n    return excess.mul(skew).div(10000);\n  }\n\n  function getRealBurnBudget(\n    uint256 maxBurnSpend,\n    uint256 premiumExcess\n  ) public view returns(uint256) {\n    // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement\n    // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn\n\n    if (premiumExcess > maxBurnSpend) {\n      return premiumExcess;\n    }\n\n    uint256 usableExcess = maxBurnSpend.sub(premiumExcess);\n\n    if (usableExcess == 0) {\n      return premiumExcess;\n    }\n\n    uint256 burnable = consult(usableExcess);\n\n    return premiumExcess + burnable;\n  }\n\n  function getAverageParticipation() public view returns (uint256) {\n    uint256 initialAuction = 0;\n    uint256 currentAuctionId = auction.currentAuctionId();\n\n    if (currentAuctionId > auctionAverageLookback) {\n      initialAuction = currentAuctionId - auctionAverageLookback;\n    }\n\n    // Use the existing struct to avoid filling the stack with temp vars\n    AuctionData memory aggregate;\n\n    for (uint256 i = initialAuction; i < currentAuctionId; ++i) {\n      (uint256 commitments, uint256 maxCommitments) = auction.getAuctionCommitments(i);\n      aggregate.maxCommitments = aggregate.maxCommitments + maxCommitments;\n      aggregate.commitments = aggregate.commitments + commitments;\n    }\n\n    uint256 participation = 0;\n    if (aggregate.maxCommitments > 0) {\n      participation = aggregate.commitments.mul(10000).div(aggregate.maxCommitments);\n    }\n\n    return participation;\n  }\n\n  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count > auctionAverageLookback) {\n      initialIndex = count - auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }\n\n  function _getIndexOfObservation(uint _index) internal view returns (uint index) {\n    return _index % auctionAverageLookback;\n  }\n\n  /*\n   * The arguments passed into these observation functions are not currently used but they are added\n   * incase future versions to this contract want to use them. In that case the stabilizernode\n   * won't have to be changed as it is already passing in this argument.\n   */\n  function addAbovePegObservation(uint256 amount)\n    public\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be a stabilizer node to call this method\")\n  {\n    uint256 index = _getIndexOfObservation(count);\n    // above peg\n    pegObservations[index] = 1;\n\n    count = count + 1;\n    emit AbovePegObservation(amount);\n  }\n\n  function addBelowPegObservation(uint256 amount)\n    public\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be a stabilizer node to call this method\")\n  {\n    uint256 index = _getIndexOfObservation(count);\n    // below peg\n    pegObservations[index] = 0;\n\n    count = count + 1;\n    emit BelowPegObservation(amount);\n  }\n\n  function setNewStabilizerNode(address _node)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_node != address(0), \"Cannot set 0 address\");\n    _swapRole(_node, address(stabilizerNode), STABILIZER_NODE_ROLE);\n    stabilizerNode = IStabilizerNode(_node);\n    emit SetStabilizerNode(_node);\n  }\n\n  function setNewAuction(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auction != address(0), \"Cannot set 0 address\");\n    auction = IAuction(_auction);\n    emit SetAuction(_auction);\n  }\n\n  function setAuctionAverageLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have zero lookback period\");\n\n    if (_lookback > auctionAverageLookback) {\n      for (uint i = auctionAverageLookback; i < _lookback; i++) {\n        pegObservations.push(0);\n      }\n    }\n\n    auctionAverageLookback = _lookback;\n    emit SetAuctionAverageLookback(_lookback);\n  }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol",
            "AuctionBurnReserveSkew.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count  auctionAverageLookback) {\n      initialIndex = count auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }\n"
                ],
                "Type": "  AuctionBurnReserveSkew.getPegDeltaFrequency()  Wrong implementation can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction ",
                "Description": "\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132\n\nsolidity\n  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count  auctionAverageLookback) {\n      initialIndex = count auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }\n\n\nWhen count < auctionAverageLookback, at L131, it should be return total * 10000 / count;. The current implementation will return a smaller value than expected.\n\nThe result of getPegDeltaFrequency() will be used for calculating realBurnBudget for auctions. With the result of getPegDeltaFrequency() being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.\n\n0xScotch (sponsor) confirmed and disagreed with severity(https://github.com/code-423n4/2021-11-malt-findings/issues/294):\n  I actually think this should be higher severity. This bug could manifest in liquidity extension being depleted to zero which could have catastrophic consequences downstream.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/294#issuecomment-1019392232):\n  Agree with the finding, this is an incorrect logic in the protocol, which can limit it's functionality and as the sponsor says: could have catastrophic consequences downstream as such I'll increase the severity to high.\n \n Mitigation seems to be straightforward\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Auction.sol\";\n\n\nstruct EarlyExitData {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n}\n\nstruct AuctionExits {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n  mapping(address => EarlyExitData) accountExits;\n}\n\n\n/// @title Auction Escape Hatch\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Functionality to reduce risk profile of holding arbitrage tokens by allowing early exit\ncontract AuctionEscapeHatch is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  uint256 public maxEarlyExitBps = 200; // 20%\n  uint256 public cooloffPeriod = 60 * 60 * 24; // 24 hours\n\n  mapping(uint256 => AuctionExits) internal auctionEarlyExits;\n\n  event EarlyExit(address account, uint256 amount, uint256 received);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    address _auction,\n    address _handler\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function exitEarly(uint256 _auctionId, uint256 amount, uint256 minOut) external notSameBlock {\n    uint256 maltQuantity = _calculateMaltRequiredForExit(_auctionId, amount);\n\n    // TODO ensure this contract is added as a mint requester Sat 06 Nov 2021 20:13:49 GMT\n    malt.mint(address(dexHandler), maltQuantity);\n    uint256 amountOut = dexHandler.sellMalt();\n\n    require(amountOut > minOut, \"EarlyExit: Insufficient output\");\n\n    AuctionExits storage auctionExits = auctionEarlyExits[_auctionId];\n\n    auctionExits.exitedEarly = auctionExits.exitedEarly + amount;\n    auctionExits.earlyExitReturn = auctionExits.earlyExitReturn + amountOut;\n    auctionExits.maltUsed = auctionExits.maltUsed + maltQuantity;\n    auctionExits.accountExits[msg.sender].exitedEarly = auctionExits.accountExits[msg.sender].exitedEarly + amount; \n    auctionExits.accountExits[msg.sender].earlyExitReturn = auctionExits.accountExits[msg.sender].earlyExitReturn + amountOut; \n    auctionExits.accountExits[msg.sender].maltUsed = auctionExits.accountExits[msg.sender].maltUsed + maltQuantity; \n\n    auction.amendAccountParticipation(\n      msg.sender,\n      _auctionId,\n      amount,\n      maltQuantity\n    );\n\n    collateralToken.safeTransfer(msg.sender, amountOut);\n    emit EarlyExit(msg.sender, amount, amountOut);\n  }\n\n  function earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    if(active || block.timestamp < auctionEndTime) {\n      return 0;\n    }\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(account, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    uint256 userOutstanding = userCommitment - userRedeemed;\n\n    if (amount > userOutstanding) {\n      amount = userOutstanding;\n    }\n\n    if (amount == 0) {\n      return 0;\n    }\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      return amount + maxProfit;\n    } \n\n    return fullReturn;\n  }\n\n  function accountAuctionExits(address account, uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    EarlyExitData storage accountExits = auctionEarlyExits[auctionId].accountExits[account];\n\n    return (accountExits.exitedEarly, accountExits.earlyExitReturn, accountExits.maltUsed);\n  }\n\n  function globalAuctionExits(uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    AuctionExits storage auctionExits = auctionEarlyExits[auctionId];\n\n    return (auctionExits.exitedEarly, auctionExits.earlyExitReturn, auctionExits.maltUsed);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    require(!active, \"Cannot exit early on an active auction\");\n    require(block.timestamp > auctionEndTime, \"Auction not over\");\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(msg.sender, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    if (amount > (userCommitment - userRedeemed)) {\n      amount = userCommitment - userRedeemed;\n    }\n\n    require(amount > 0, \"Nothing to claim\");\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      uint256 desiredReturn = amount + maxProfit;\n      maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;\n    } \n\n    return maltQuantity;\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setEarlyExitBps(uint256 _earlyExitBps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, \"Must be between 0-100%\");\n    maxEarlyExitBps = _earlyExitBps;\n  }\n\n  function setCooloffPeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_period > 0, \"Cannot have 0 lookback period\");\n    cooloffPeriod = _period;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n}\n\n\n",
        "CodeNames": [
            "AbstractRewardMine.sol",
            "Auction.sol",
            "AuctionEscapeHatch.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "claimArbitrage",
                    "maltQuantity",
                    "_calculateMaltRequiredForExit",
                    "userMaltPurchased",
                    "uint",
                    "amount",
                    "userCommitment",
                    "exitEarly"
                ],
                "Type": " AuctionEschapeHatch.sol#exitEarly updates state of the auction wrongly",
                "Description": "\nAuctionEschapeHatch.sol#exitEarly takes as input amount to represent how much of the\n\nWhen the user exits an auction with profit, to apply the profit penalty less maltQuantity is liquidated compared to how much malt token the liquidated amount corresponds to. The problem is auction.amendAccountParticipation() simply subtracts the malt quantity with penalty and full amount from users auction stats. This causes a major problem, since in _calculateMaltRequiredForExit those values are used for calculation by calculating maltQuantity as follow:\n\nuint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\nThe ratio of userMaltPurchased / userCommitment gets higher after each profit taking (since penalty is applied to substracted maltQuantity from userMaltPurchased), by doing so a user can earn more than it should. Since after each profit taking users commitment corresponds to proportionally more malt, the user can even reduce profit penalties by dividing exitEarly calls in several calls.\n\nIn other words, the ratio of userMaltPurchased / userCommitment gets higher after each profit taking and user can claim more malt with less commitment. Furthermore after all userMaltPurchased is claimed the user can have userCommitment left over, which can be used to claimArbitrage, when possible.\n\n\nMake sure which values are used for what and update values which doesn't create problems like this. Rethink about how to track values of an auction correctly.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/268) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/268#issuecomment-1020736987):\n  The warden has identified an exploit that allows early withdrawers to gain more rewards than expected.\n Anytime \"points\" and rewards need to be earned over time, it's ideal to accrue points in order to distribute them (see how Compound or AAVE tokens work)\n Because the warden showed a flow in the accounting logic for the protocol, I agree with high severity.\n\n\n\n \n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\n/// @title Permissions\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Inherited by almost all Malt contracts to provide access control\ncontract Permissions is AccessControl {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n  // Can mint/burn Malt\n  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(\"MONETARY_BURNER_ROLE\");\n  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(\"MONETARY_MINTER_ROLE\");\n\n  // Contract types\n  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(\"STABILIZER_NODE_ROLE\");\n  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(\"LIQUIDITY_MINE_ROLE\");\n  bytes32 public constant AUCTION_ROLE = keccak256(\"AUCTION_ROLE\");\n  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(\"REWARD_THROTTLE_ROLE\");\n\n  address internal globalAdmin;\n\n  mapping(address => uint256) public lastBlock; // protect against reentrancy\n\n  function _adminSetup(address _timelock) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(GOVERNOR_ROLE, _timelock);\n    _roleSetup(MONETARY_BURNER_ROLE, _timelock);\n    _roleSetup(MONETARY_MINTER_ROLE, _timelock);\n    _roleSetup(STABILIZER_NODE_ROLE, _timelock);\n    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);\n    _roleSetup(AUCTION_ROLE, _timelock);\n    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);\n\n    globalAdmin = _timelock;\n  }\n\n  function assignRole(bytes32 role, address _assignee)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _setupRole(role, _assignee);\n  }\n\n  function removeRole(bytes32 role, address _entity)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can revoke roles\")\n  {\n    revokeRole(role, _entity);\n  }\n\n  function reassignGlobalAdmin(address _admin)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);\n    _swapRole(_admin, globalAdmin, ADMIN_ROLE);\n    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);\n    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);\n    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);\n    _swapRole(_admin, globalAdmin, AUCTION_ROLE);\n    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);\n\n    globalAdmin = _admin;\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    // Transfers the entire balance of the Gas token to destination\n    destination.call{value: address(this).balance}('');\n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    destination.call{value: amount}('');\n  }\n\n  function partialWithdraw(address _token, address destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {\n    revokeRole(role, oldAccount);\n    _setupRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _setupRole(role, account);\n    _setRoleAdmin(role, ADMIN_ROLE);\n  }\n\n  function _onlyRole(bytes32 role, string memory reason) internal view {\n    require(\n      hasRole(\n        role,\n        _msgSender()\n      ),\n      reason\n    );\n  }\n\n  function _notSameBlock() internal {\n    require(\n      block.number > lastBlock[_msgSender()],\n      \"Can't carry out actions in the same block\"\n    );\n    lastBlock[_msgSender()] = block.number;\n  }\n\n  // Using internal function calls here reduces compiled bytecode size\n  modifier onlyRole(bytes32 role, string memory reason) {\n    _onlyRole(role, reason);\n    _;\n  }\n\n  modifier notSameBlock() {\n    _notSameBlock();\n    _;\n  }\n}\n\n\npragma solidity >=0.6.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Malt DAO\n/// @author 0xScotch <scotch@malt.money>\n/// @notice In essence a contract that is the oracle for the current epoch\ncontract MaltDAO is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  IBurnMintableERC20 public malt;\n  uint256 public epoch = 0;\n  uint256 public epochLength;\n  uint256 public genesisTime;\n  uint256 public advanceIncentive = 100; // 100 Malt\n\n  event Advance(uint256 indexed epoch, uint256 block, uint256 timestamp);\n  event Mint(address recipient, uint256 amount);\n  event SetMaltToken(address maltToken);\n  event SetEpochLength(uint256 length);\n  event SetAdvanceIncentive(uint256 incentive);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    uint256 _epochLength,\n    uint256 _genesisTime,\n    address offering,\n    uint256 offeringMint\n  ) external initializer {\n    _setMaltToken(_malt);\n    _setEpochLength(_epochLength);\n\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    genesisTime = _genesisTime;\n\n    if (offeringMint > 0) {\n      // Tokens minted to Community Whitelist contract\n      malt.mint(offering, offeringMint);\n    }\n  }\n\n  receive() external payable {}\n\n  function advance() external {\n    require(block.timestamp >= getEpochStartTime(epoch + 1), \"Cannot advance epoch until start of new epoch\");\n\n    incrementEpoch();\n\n    malt.mint(msg.sender, advanceIncentive * 1e18);\n\n    emit Advance(epoch, block.number, block.timestamp);\n  }\n\n  function getEpochStartTime(uint256 _epoch) public view returns (uint256) {\n    return genesisTime.add(epochLength.mul(_epoch));\n  }\n\n  function epochsPerYear() public view returns (uint256) {\n    // 31557600 = seconds in a year\n    return 31557600 / epochLength;\n  }\n\n  function mint(address to, uint256 amount)\n    public\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    require(amount > 0, \"Cannot have zero amount\");\n    malt.mint(to, amount);\n    emit Mint(to, amount);\n  }\n\n  function setMaltToken(address _malt)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    _setMaltToken(_malt);\n  }\n\n  function setEpochLength(uint256 _length)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_length > 0, \"Cannot have zero length epochs\");\n    _setEpochLength(_length);\n  }\n\n  function setAdvanceIncentive(uint256 incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    advanceIncentive = incentive;\n    emit SetAdvanceIncentive(incentive);\n  }\n\n  /* Internal methods */\n  function incrementEpoch() internal {\n    epoch = epoch.add(1);\n  }\n  \n  function _setEpochLength(uint256 length) internal {\n    epochLength = length;\n    emit SetEpochLength(length);\n  }\n\n  function _setMaltToken(address _malt) internal {\n    malt = IBurnMintableERC20(_malt);\n    emit SetMaltToken(_malt);\n  }\n}\n\n\n",
        "CodeNames": [
            "Permissions.sol",
            "DAO.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "emergencyWithdrawGAS(), emergencyWithdraw(), partialWithdrawGAS(), partialWithdraw()",
                    "TIMELOCK_ROLE"
                ],
                "Type": " TIMELOCK_ROLE Has Absolute Power to Withdraw All FUND May Raise Red Flags for Investors",
                "Description": "\n\nTIMELOCK_ROLE Can Withdraw All FUND from the Contracts via emergencyWithdrawGAS(), emergencyWithdraw(), partialWithdrawGAS(), partialWithdraw().\n\nWhile I believe developer have good intention to use these functions. It often associate with Rug Pull by developer in the eyes of investors because Rug Pull is not uncommon in Defi. Investors lose all their hard earn money.\n\nRead More: $10.8M Stolen, Developers Implicated in Alleged Smart Contract 'Rug Pull'\n<https://www.coindesk.com/tech/2020/12/02/108m-stolen-developers-implicated-in-alleged-smart-contract-rug-pull/\n\nRead More: The Rise of Cryptocurrency Exit Scams and DeFi Rug Pulls\n<https://www.cylynx.io/blog/the-rise-of-cryptocurrency-exit-scams-and-defi-rug-pulls/\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L80-L109\n\n",
                "Repair": "\n1.  Pause the Contract and Disable All Functions when Bad Thing Happen rather than Withdraw All Fund to a random address.\n2.  If Withdraw Fund can't avoid, a Multi Sig ETH Address should be hardcoded into the contract to ensure the fund move to a safe wallet.\n\n\n0xScotch (sponsor) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/125#issuecomment-988785042):\n  Duplicate of #263\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/125#issuecomment-1008068213):\n  This is not a duplicate of #263, where 263 talks about sidestepping the delay of the timelock, this finding talks about the high degree of power that the TIMELOCK_ROLE has.\n \n This is a typical \"admin privilege\" finding, it's very important to disclose admin privileges to users so that they can make informed decisions\n \n In this case the TIMELOCK_ROLE can effectively rug the protocol, however this is contingent on the account that has the role to pull the rug.\n \n Because of its reliance on external factors, am downgrading the finding to medium severity\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\n\n\n/// @title Liquidity Extension\n/// @author 0xScotch <scotch@malt.money>\n/// @notice In charge of facilitating a premium with net supply contraction during auctions\ncontract LiquidityExtension is Initializable, Permissions {\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  IMaltDataLab public maltDataLab;\n  address public uniswapV2Factory;\n\n  uint256 public minReserveRatio = 40;\n\n  event SetAuction(address auction);\n  event SetDexHandler(address dexHandler);\n  event SetMaltDataLab(address dataLab);\n  event SetMinReserveRatio(uint256 ratio);\n  event BurnMalt(uint256 purchased);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _auction,\n    address _collateralToken,\n    address _malt,\n    address _dexHandler,\n    address _maltDataLab,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(AUCTION_ROLE, _auction);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW METHODS\n   */\n  function hasMinimumReserves() public view returns (bool) {\n    (uint256 rRatio, uint256 decimals) = reserveRatio();\n    return rRatio >= minReserveRatio.mul(10**decimals).div(100);\n  }\n\n  function collateralDeficit() public view returns (uint256 deficit, uint256 decimals) {\n    // Returns the amount of collateral token required to reach minimum reserves\n    // Returns 0 if liquidity extension contains minimum reserves.\n    uint256 balance = collateralToken.balanceOf(address(this));\n    uint256 collateralDecimals = collateralToken.decimals();\n\n    // TODO use data lab Mon 11 Oct 2021 16:48:08 BST\n    (uint256 maltSupply, uint256 collateralSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(collateralToken)\n    );\n\n    uint256 k = maltSupply.mul(collateralSupply);\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    uint256 fullCollateral = Babylonian.sqrt(k.mul(10**collateralDecimals).div(priceTarget));\n\n    uint256 minReserves = fullCollateral.mul(minReserveRatio).div(100);\n\n    if (minReserves > balance) {\n      return (minReserves - balance, collateralDecimals);\n    }\n\n    return (0, collateralDecimals);\n  }\n\n  function reserveRatio() public view returns (uint256, uint256) {\n    uint256 balance = collateralToken.balanceOf(address(this));\n    uint256 collateralDecimals = collateralToken.decimals();\n\n    // TODO use data lab Mon 11 Oct 2021 16:48:08 BST\n    (uint256 maltSupply, uint256 collateralSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(collateralToken)\n    );\n\n    uint256 k = maltSupply.mul(collateralSupply);\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    uint256 fullCollateral = Babylonian.sqrt(k.mul(10**collateralDecimals).div(priceTarget));\n\n    uint256 rRatio = balance.mul(10**collateralDecimals).div(fullCollateral);\n    return (rRatio, collateralDecimals);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function purchaseAndBurn(uint256 amount)\n    external\n    onlyRole(AUCTION_ROLE, \"Must have auction privs\")\n    returns (uint256 purchased)\n  {\n    require(collateralToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");\n    collateralToken.safeTransfer(address(dexHandler), amount);\n    purchased = dexHandler.buyMalt();\n    malt.burn(address(this), purchased);\n\n    emit BurnMalt(purchased);\n  }\n\n  function setAuction(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auction != address(0), \"Not address 0\");\n    auction = IAuction(_auction);\n    emit SetAuction(_auction);\n  }\n\n  function setDexHandler(address _dexHandler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dexHandler != address(0), \"Not address 0\");\n    dexHandler = IDexHandler(_dexHandler);\n    emit SetDexHandler(_dexHandler);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dataLab != address(0), \"Not address 0\");\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setMinReserveRatio(uint256 _ratio)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_ratio > 0 && _ratio <= 100, \"Must be between 0 and 100\");\n    minReserveRatio = _ratio;\n    emit SetMinReserveRatio(_ratio);\n  }\n}\n\n\n",
        "CodeNames": [
            "LiquidityExtension.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "buyMalt"
                ],
                "Type": " Frontrunning in UniswapHandler calls to UniswapV2Router",
                "Description": "\n\nUniswapHandler utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. In order to utilize these functionalities, UniswapHandler must call various UniswapV2Router methods.\n\n*   addLiquidity\n*   removeLiquidity\n*   swapExactTokensForTokens (swaps for both DAI and Malt)\n\nIn all three methods, UniswapV2Router requires the callee to provide input arguments that define how much the amount out minimum UniswapHandler will allow for a trade. This argument is designed to prevent slippage and more importantly, sandwich attacks.\n\nUniswapHandler correctly handles price slippage when calling addLiquidity(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L201). However, that is not the case for removeLiquidity(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L230) and swapExactTokensForTokens here(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) and here(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L173). For both methods, 0 is passed in as the amount out minimum allowed for a trade. This allows for anyone watching the mempool to sandwich attack UniswapHandler (or any contract that calls UniswapHandler) in such a way that allows the hacker to profit off of a guaranteed trade.\n\nHow does this work? Let's assume UniswapHandler makes a call to UniswapV2Router#swapExactTokensForTokens(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) to trade DAI for Malt. Any hacker who watches the mempool and sees this transaction can immediately buy as much Malt as they want. This raises the price of Malt. Since UniswapHandler is willing to accept any amount out minimum (the number is set to zero(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L150)), then the UniswapHandler will always trade DAI for Malt. This second transaction raises the price of Malt even further. Finally, the hacker trades their Malt for DAI, receiving a profit due to the artificially inflated price of Malt from the sandwich attack.\n\nIt's important to note that anyone has access to the UniswapV2Router contract. There are no known ACL controls on UniswapV2Router. This sandwich attack can impact even the buyMalt function.\n\nThe following functions when called are vulnerable to frontrunning attacks:\n\n*   UniswapHandler#buyMalt(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L131)\n*   UniswapHandler#sellMalt(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L160)\n*   UniswapHandler#removeLiquidity(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221)\n\nAnd by extension the following contract functions since they also call the UniswapHandler function calls:\n\n*   Bonding#unbondAndBreak(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L114)\n*   LiquidityExtension#purchaseAndBurn(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117)\n*   RewardReinvestor#splitReinvest(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L78)\n*   StabilizerNode#stabilize(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145)\n*   SwingTrader#buyMalt(https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L50)\n\n\nRefer to the impact section for affected code and links to the appropriate LoC.\n\n",
                "Repair": "\nThe UniswapV2Router and UniswapV2Pair contract should allow only the UniswapHandler contract to call either contract. In addition, price slippage checks should be implemented whenever removing liquidity or swapping tokens. This ensures that a frontrunning attack can't occur.\n\n#### Anything Else We Should Know\n\nI wish I had more time to work on this bug but unfortunately I have several current clients who require significant time from me. I'm happy to pursue this beyond the initial submission, in particular building a concrete PoC. I think the most important takeaway from this bug find is that anyone can purchase Malt at any time and anyone can manipulate the Malt reserve. This in turn impacts other functionalities that rely on the Malt reserve to make price/token calculations such as exiting an auction early or reinvesting rewards.\n\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/219)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/219#issuecomment-1008433912):\n  Because transactions sit on the mempool (which is public, hence accessible by anyone), they can be frontrun, because of this swapping protocols (uniswap in this case) offer slippage checks.\n Setting the slippage checks allows a frontrunner to squeeze the maximum amount of value possible (sometimes the whole amount).\n \n Because this applies to a leak of value, I believe medium severity to be correct\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\n",
        "CodeNames": [
            "AbstractRewardMine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "_globalStakePadding",
                    "_userStakePadding",
                    "totalDeclaredReward"
                ],
                "Type": " AbstractRewardMine.sol#setRewardToken is dangerous",
                "Description": "\n\nIn case the reward token is changed, totalDeclaredReward will be changed and likely equal to 0.  Since _userStakePadding and _globalStakePadding are accumulated, changing the reward token will not reset those values. Thus, it will create problems.\n\n",
                "Repair": "\nI think it would be the best to remove this function.\n\nIf you want to keep it, then it must have an event and it should be used by a timelock contract. Furthermore, it has to be used carefully and the new token should be distributed such that padding variables still make sense.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/285)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/285#issuecomment-1008437864):\n  Agree with highlighting the Admin Privilege, however because this is contingent on a malicious Admin, I'll downgrade the finding to Medium Severity.\n \n Mitigation could be done by ensuring old rewards are sent out, still claimable, or by making the rewardToken immutable\n\n\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "_userWithdrawn",
                    "withdraw()",
                    "earned",
                    "_withdraw"
                ],
                "Type": " AbstractRewardMine - Re-entrancy attack during withdrawal",
                "Description": "\n\nThe internal _withdraw method does not follow the checks-effects-interactions pattern. A malicious token, or one that implemented transfer hooks, could re-enter the public calling function (such as withdraw()) before proper internal accounting was completed. Because the earned function looks up the _userWithdrawn mapping, which is not yet updated when the transfer occurs, it would be possible for a malicious contract to re-enter _withdraw repeatedly and drain the pool.\n\n",
                "Repair": "\nThe internal accounting should be done before the transfer occurs:\n\nsolidity\nfunction _withdraw(address account, uint256 amountReward, address to) internal {\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;f\n\n   rewardToken.safeTransfer(to, amountReward);\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/333) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/333#issuecomment-1008447954):\n  The warden identified a re-entrancy vulnerability that, given the right token would allow to drain the entirety of the contract.\n \n Tokens with hooks (ERC777 and ERC677) would allow to exploit the contract and drain it in it's entirety.\n \n This is a very serious vulnerability.\n However it can happen exclusively on a malicious or a token with hooks, as such (while I recommend the sponsor to mitigate by following recommendation by the warden), the attack can be completely prevented by using a token without hooks.\n \n For that reason I'll rate the finding of medium severity (as it requires external conditions)\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "JS\ncontract attack1 {\n   function attack(address account, uint256 amount) {\n         call attack2.forward(account, amount);\n         call any other function of malt\n  }\n}\n\ncontract attack2 {\n   function forward(address account, uint256 amount) {\n       call bonding.bondToAccount(account, amount); // uses msg.sender of attack2\n   }\n}\n",
                    "JS\nfunction bondToAccount(address account, uint256 amount) public {\n    if (msg.sender != offering) {\n         _notSameBlock();\n    }\n    ...\n",
                    "JS\nfunction _notSameBlock() internal {\n    require( block.number  lastBlock[_msgSender()],\"Can't carry out actions in the same block\" );\n    lastBlock[_msgSender()] = block.number;\n  }\n"
                ],
                "Type": " _notSameBlock() can be circumvented in bondToAccount() ",
                "Description": "\n\nThe function bondToAccount() of Bonding.sol has a check based on _notSameBlock()\n_notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block.\n\nHowever this can be circumvented in this case:\nSuppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract.\nFor a pseudo code proof of concept see below.\n\nI'm not sure what the deeper reason is for the _notSameBlock() in bondToAccount().\nBut if it is important then circumventing this check it will pose a risk.\n\n\ncall function attack1.attack()\n\nJS\ncontract attack1 {\n   function attack(address account, uint256 amount) {\n         call attack2.forward(account, amount);\n         call any other function of malt\n  }\n}\n\ncontract attack2 {\n   function forward(address account, uint256 amount) {\n       call bonding.bondToAccount(account, amount); // uses msg.sender of attack2\n   }\n}\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Bonding.sol#L81-L92\n\nJS\nfunction bondToAccount(address account, uint256 amount) public {\n    if (msg.sender != offering) {\n         _notSameBlock();\n    }\n    ...\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Permissions.sol#L135-L141\n\nJS\nfunction _notSameBlock() internal {\n    require( block.number  lastBlock[_msgSender()],\"Can't carry out actions in the same block\" );\n    lastBlock[_msgSender()] = block.number;\n  }\n\n\n",
                "Repair": "\nAdd access controls to the function bondToAccount()\nAn end-user could still call bond()\n\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/195) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/195#issuecomment-1008447039):\n  notSameBlock is effectively being used as the nonReentrant modifier, without the same security guarantees, as such, in spite of not having a specific attack vector, because the warden showed how to side step this security feature of the protocol, am going to raise the severity to Medium\n\n\n\n\n"
            },
            {
                "Name": "M-11",
                "Location": [
                    "js\nfunction setAdvanceIncentive(uint256 incentive)  externalonlyRole(ADMIN_ROLE, \"Must have admin role\") {\n  ...\n  advanceIncentive = incentive;\n",
                    "js\nfunction advance() external {\n...\n  malt.mint(msg.sender, advanceIncentive * 1e18);\n\n"
                ],
                "Type": " No max for advanceIncentive",
                "Description": "\n\nThe function setAdvanceIncentive of DAO.sol doesn't check for a maximum value of incentive.\nIf incentivewould be very large, then advanceIncentive would be very large and the function advance() would mint a large amount of malt.\n\nThe function setAdvanceIncentive() can only be called by an admin, but a mistake could be made.\nAlso if an admin would want to do a rug pull, this would be an ideal place to do it.\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L98-L104\n\njs\nfunction setAdvanceIncentive(uint256 incentive)  externalonlyRole(ADMIN_ROLE, \"Must have admin role\") {\n  ...\n  advanceIncentive = incentive;\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63\n\njs\nfunction advance() external {\n...\n  malt.mint(msg.sender, advanceIncentive * 1e18);\n\n\n\n",
                "Repair": "\nCheck for a reasonable maximum value in advance()\n\n0xScotch (sponsor) confirmed and disagreed with severity(https://github.com/code-423n4/2021-11-malt-findings/issues/190): \n  Definitely need to guard against arbitrarily large incentives. Disagree the risk is medium though.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/190#issuecomment-1019288176):\n  Agree with the finding, this is an example of admin privilege, where the admin can set a variable which can be used to dilute the token and rug the protocol.\n \n Because this is contingent on the admin's action, I believe medium severity to be proper\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/190#issuecomment-1025181758):\n  The simple rationale on the medium severity is that the owner could set the incentive to an exorbitant amount with the goal of minting a lot of tokens for an exit scam\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nimport \"./interfaces/IStabilizerNode.sol\";\nimport \"./interfaces/IMovingAverage.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\n\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./libraries/SafeBurnMintableERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Malt Data Lab\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The central source of all of Malt protocol's internal data needs\n/// @dev Over time usage of MovingAverage will likely be replaced with more reliable oracles\ncontract MaltDataLab is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeBurnMintableERC20 for IBurnMintableERC20;\n\n  bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n  IBurnMintableERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  ILiquidityExtension public liquidityExtension;\n  IUniswapV2Pair public stakeToken;\n\n  IMovingAverage public reserveRatioMA;\n  IMovingAverage public maltPriceMA;\n  IMovingAverage public poolMaltReserveMA;\n\n  uint256 public priceTarget = 10**18; // $1\n  uint256 public reserveRatioLookback = 10 minutes;\n  uint256 public maltPriceLookback = 10 minutes;\n  uint256 public reserveLookback = 10 minutes;\n\n  event TrackMaltPrice(uint256 price);\n  event TrackPoolReserves(uint256 maltReserves, uint256 rewardReserves);\n  event TrackReserveRatio(uint256 rRatio, uint256 decimals);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    uint256 _priceTarget,\n    address _liquidityExtension,\n    address _reserveRatioMA,\n    address _maltPriceMA,\n    address _poolMaltReserveMA,\n    address _updater\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _roleSetup(UPDATER_ROLE, _updater);\n    _roleSetup(UPDATER_ROLE, initialAdmin);\n\n    stakeToken = IUniswapV2Pair(_stakeToken);\n    malt = IBurnMintableERC20(_malt);\n    rewardToken = IBurnMintableERC20(_rewardToken);\n    priceTarget = _priceTarget;\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    reserveRatioMA = IMovingAverage(_reserveRatioMA);\n    maltPriceMA = IMovingAverage(_maltPriceMA);\n    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);\n  }\n\n  function smoothedReserveRatio() public view returns (uint256) {\n    return reserveRatioMA.getValueWithLookback(reserveRatioLookback);\n  }\n\n  function smoothedMaltPrice() public view returns (uint256) {\n    return maltPriceMA.getValueWithLookback(maltPriceLookback);\n  }\n\n  function smoothedMaltInPool() public view returns (uint256) {\n    return poolMaltReserveMA.getValueWithLookback(reserveLookback);\n  }\n\n  function smoothedReserves() public view returns (uint256 maltReserves, uint256 collateralReserves) {\n    maltReserves = poolMaltReserveMA.getValueWithLookback(reserveLookback);\n    uint256 price = smoothedMaltPrice();\n    return (maltReserves, maltReserves.mul(price).div(priceTarget));\n  }\n\n  function reserveRatioAverage(uint256 _lookback) public view returns (uint256) {\n    return reserveRatioMA.getValueWithLookback(_lookback);\n  }\n\n  function maltPriceAverage(uint256 _lookback) public view returns (uint256) {\n    return maltPriceMA.getValueWithLookback(_lookback);\n  }\n\n  function maltInPoolAverage(uint256 _lookback) public view returns (uint256) {\n    return poolMaltReserveMA.getValueWithLookback(_lookback);\n  }\n\n  function realValueOfLPToken(uint256 amount) external view returns (uint256) {\n    uint256 maltPrice = smoothedMaltPrice();\n    (uint256 maltReserves, uint256 rewardReserves) = smoothedReserves();\n\n    if (maltReserves == 0) {\n      return 0;\n    }\n\n    uint256 totalLPSupply = stakeToken.totalSupply();\n\n    uint256 maltValue = amount.mul(maltReserves).div(totalLPSupply);\n    uint256 rewardValue = amount.mul(rewardReserves).div(totalLPSupply);\n\n    return rewardValue.add(maltValue.mul(maltPrice).div(priceTarget));\n  }\n\n  /*\n   * Public mutation methods\n   */\n  function trackReserveRatio() public {\n    (uint256 reserveRatio, uint256 decimals) = liquidityExtension.reserveRatio();\n\n    reserveRatioMA.update(reserveRatio);\n\n    emit TrackReserveRatio(reserveRatio, decimals);\n  }\n\n  function trackMaltPrice()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);\n      maltPriceMA.update(price);\n      emit TrackMaltPrice(price);\n    } else {\n      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);\n      maltPriceMA.update(price);\n\n      emit TrackMaltPrice(price);\n    }\n  }\n\n  function trackPoolReserves()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve1);\n      emit TrackPoolReserves(reserve1, reserve0);\n    } else {\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve0);\n      emit TrackPoolReserves(reserve0, reserve1);\n    }\n  }\n\n  function trackPool()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);\n      maltPriceMA.update(price);\n\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve1);\n      emit TrackMaltPrice(price);\n      emit TrackPoolReserves(reserve1, reserve0);\n    } else {\n      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);\n      maltPriceMA.update(price);\n\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve0);\n      emit TrackMaltPrice(price);\n      emit TrackPoolReserves(reserve0, reserve1);\n    }\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _normalizedPrice(\n    uint256 numerator,\n    uint256 denominator,\n    uint256 decimals\n  ) internal view returns(uint256 price) {\n    // Malt is 18 decimals\n    if (decimals > 18) {\n      uint256 diff = decimals - 18;\n      price = numerator.mul(10**decimals).div(denominator.mul(10**diff));\n    } else if (decimals < 18) {\n      uint256 diff = 18 - decimals;\n      price = (numerator.mul(10**diff)).mul(10**decimals).div(denominator);\n    } else {\n      price = numerator.mul(10**decimals).div(denominator);\n    }\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setLiquidityExtension(address _liquidityExtension) \n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Must be a valid address\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setPriceTarget(uint256 _price)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_price > 0, \"Cannot have 0 price\");\n    priceTarget = _price;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setMaltPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    maltPriceLookback = _lookback;\n  }\n\n  function setReserveLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    reserveLookback = _lookback;\n  }\n\n  function setReserveAverageContract(address _reserveRatioMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_reserveRatioMA != address(0), \"Cannot use 0 address\");\n    reserveRatioMA = IMovingAverage(_reserveRatioMA);\n  }\n\n  function setMaltPriceAverageContract(address _maltPriceMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maltPriceMA != address(0), \"Cannot use 0 address\");\n    maltPriceMA = IMovingAverage(_maltPriceMA);\n  }\n\n  function setMaltReservesAverageContract(address _poolMaltReserveMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_poolMaltReserveMA != address(0), \"Cannot use 0 address\");\n    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Moving Average\n/// @author 0xScotch <scotch@malt.money>\n/// @notice For tracking the average of a data stream over time\n/// @dev Based on the cumulativeValue mechanism for TWAP in uniswapV2\ncontract MovingAverage is Initializable, Permissions {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n\n  struct Sample {\n    uint64 timestamp;\n    uint256 value;\n    uint256 cumulativeValue;\n    uint256 lastValue;\n  }\n\n  bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n  uint256 public sampleLength;\n  uint256 public cumulativeValue;\n  uint256 public sampleMemory;\n  uint256 public defaultValue;\n\n  uint64 public blockTimestampLast;\n\n  uint256 private counter;\n  uint256 private activeSamples;\n\n  Sample[] private samples;\n\n  event Update(uint256 value, uint256 cumulativeValue);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    uint256 _sampleLength, // eg 5min represented as seconds\n    uint256 _sampleMemory,\n    address _updater,\n    uint256 _defaultValue\n  ) external initializer {\n    require(_sampleMemory > 1, 'MA: SampleMemory > 1');\n\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _roleSetup(UPDATER_ROLE, _updater);\n    _roleSetup(UPDATER_ROLE, initialAdmin);\n\n    sampleLength = _sampleLength;\n    sampleMemory = _sampleMemory;\n    defaultValue = _defaultValue;\n\n    for (uint i = 0; i < sampleMemory; i++) {\n      samples.push();\n    }\n  }\n\n  /*\n   * PUBLIC VIEW METHODS\n   */\n  function getValue() public view returns (uint256) {\n    if (activeSamples < 2) {\n      return defaultValue;\n    } else if (activeSamples == 2) {\n      Sample storage currentSample = _getCurrentSample();\n      return currentSample.value;\n    } else if (activeSamples < sampleMemory) {\n      // Subtract 2 because this is a lookback from the current sample.\n      // activeSamples - 1 is the in progress sample. - 2 is the active sample\n      // IE if there are 2 samples, we are on one and want to lookback 1.\n      // If there are 3 samples, we are on one and want to lookback 2 etc\n      uint256 lookback = (activeSamples - 2) * sampleLength;\n      return getValueWithLookback(lookback);\n    }\n    Sample storage currentSample = _getCurrentSample();\n    Sample storage firstSample = _getFirstSample();\n\n    uint256 timeElapsed = currentSample.timestamp - firstSample.timestamp;\n    uint256 sampleDiff = currentSample.cumulativeValue - firstSample.cumulativeValue;\n\n    if (timeElapsed == 0) {\n      return currentSample.value;\n    } \n\n    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);\n\n    return sampleAverage.decode();\n  }\n\n  function getValueWithLookback(uint256 _lookbackTime) public view returns (uint256) {\n    // _lookbackTime in is seconds\n    uint256 lookbackSamples;\n    if (_lookbackTime % sampleLength == 0) {\n      // If it divides equally just divide down\n      lookbackSamples = _lookbackTime / sampleLength;\n\n      if (lookbackSamples == 0) {\n        lookbackSamples = 1;\n      }\n    } else {\n      // If it doesn't divide equally, divide and add 1.\n      // Creates a Math.ceil() situation\n      lookbackSamples = (_lookbackTime / sampleLength) + 1;\n    }\n\n    if (activeSamples < 2) {\n      return defaultValue;\n    } else if (activeSamples == 2) {\n      Sample storage currentSample = _getCurrentSample();\n      return currentSample.value;\n    } else if (lookbackSamples >= activeSamples - 1) {\n      // Looking for longer lookback than sampleMemory allows.\n      // Just return the full memory average\n      return getValue();\n    }\n\n    Sample storage currentSample = _getCurrentSample();\n    Sample storage nthSample = _getNthSample(lookbackSamples);\n\n    uint256 timeElapsed = currentSample.timestamp - nthSample.timestamp;\n    uint256 sampleDiff = currentSample.cumulativeValue - nthSample.cumulativeValue;\n\n    if (timeElapsed == 0) {\n      return currentSample.value;\n    } \n\n    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);\n\n    return sampleAverage.decode();\n  }\n\n  /*\n   * MUTATION METHODS\n   */\n  function update(uint256 newValue)\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater privs\")\n  {\n    /* \n     * This function only creates a sample at the end of the sample period.\n     * The current sample period just updates the cumulativeValue but doesn't\n     * Actually create a sample until the end of the period.\n     * This is to protect against flashloan attacks that could try manipulate\n     * the samples.\n     */\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    uint64 blockTimestamp = uint64(block.timestamp % 2**64); \n\n    // Deal with first ever sample\n    if (liveSample.timestamp == 0) {\n      liveSample.timestamp = uint64(block.timestamp);\n      liveSample.value = newValue;\n      liveSample.lastValue = newValue;\n      liveSample.cumulativeValue = newValue;\n\n      cumulativeValue = newValue;\n      blockTimestampLast = blockTimestamp;\n\n      activeSamples = activeSamples + 1;\n      return;\n    }\n\n    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;\n\n    if (timeElapsed < sampleLength) {\n      cumulativeValue += liveSample.lastValue.mul(blockTimestamp - blockTimestampLast);\n      liveSample.cumulativeValue = cumulativeValue;\n      liveSample.lastValue = newValue;\n\n      blockTimestampLast = blockTimestamp;\n      return;\n    } else if (timeElapsed >= (sampleLength - 1) * sampleMemory) {\n      // More than total sample memory has elapsed. Reset with new values\n      uint256 addition = liveSample.lastValue.mul(sampleLength);\n\n      uint256 currentCumulative = cumulativeValue;\n      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * sampleMemory);\n\n      uint256 tempCount = counter;\n      for (uint256 i = 0; i < sampleMemory; i++ ) {\n        tempCount += 1;\n        liveSample = samples[_getIndexOfSample(tempCount)];\n        liveSample.timestamp = currentTimestamp;\n        liveSample.cumulativeValue = currentCumulative;\n\n        currentCumulative += addition;\n        currentTimestamp += uint64(sampleLength);\n      }\n\n      // Reset the adding of 'addition' in the final loop\n      currentCumulative = liveSample.cumulativeValue;\n\n      tempCount += 1;\n      liveSample = samples[_getIndexOfSample(tempCount)];\n      liveSample.timestamp = blockTimestamp;\n      // Only the most recent values really matter here\n      liveSample.value = newValue;\n      liveSample.lastValue = newValue;\n      liveSample.cumulativeValue = currentCumulative;\n\n      counter = tempCount;\n      cumulativeValue = currentCumulative;\n      blockTimestampLast = blockTimestamp;\n      activeSamples = sampleMemory;\n      return;\n    }\n\n    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);\n\n    // Finish out the current sample\n    cumulativeValue += liveSample.lastValue.mul(nextSampleTime - blockTimestampLast);\n    liveSample.cumulativeValue = cumulativeValue;\n\n    liveSample = _createNewSample(nextSampleTime, cumulativeValue);\n    timeElapsed = timeElapsed - uint64(sampleLength);\n\n    uint256 elapsedSamples = timeElapsed / sampleLength;\n\n    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {\n      // update\n      cumulativeValue += liveSample.lastValue.mul(sampleLength);\n      liveSample.cumulativeValue = cumulativeValue;\n\n      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);\n\n      liveSample = _createNewSample(sampleTime, cumulativeValue);\n    }\n\n    cumulativeValue += liveSample.lastValue.mul(timeElapsed % sampleLength);\n\n    // Now set the value of the current sample to the new value\n    liveSample.value = newValue;\n    liveSample.lastValue = newValue;\n    liveSample.cumulativeValue = cumulativeValue;\n\n    blockTimestampLast = blockTimestamp;\n\n    emit Update(newValue, cumulativeValue);\n  }\n\n  function updateCumulative(uint256 _cumulative)\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater privs\")\n  {\n    require(_cumulative >= cumulativeValue, \"Cumulative value can only go up\");\n\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    uint64 blockTimestamp = uint64(block.timestamp % 2**64); \n\n    if (liveSample.timestamp == 0) {\n      cumulativeValue = _cumulative;\n      blockTimestampLast = blockTimestamp;\n\n      liveSample.timestamp = blockTimestamp;\n      liveSample.cumulativeValue = _cumulative;\n      liveSample.value = _cumulative;\n      liveSample.lastValue = _cumulative;\n\n      activeSamples = activeSamples + 1;\n      return;\n    }\n\n    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;\n    uint64 timeElapsedSinceUpdate = blockTimestamp - blockTimestampLast;\n    uint256 newLastValue = (_cumulative - cumulativeValue).div(timeElapsedSinceUpdate);\n\n    if (timeElapsed < sampleLength) {\n      // The current sample isn't over. Just update\n      liveSample.cumulativeValue = _cumulative;\n      liveSample.value = newLastValue;\n      liveSample.lastValue = newLastValue;\n\n      blockTimestampLast = blockTimestamp;\n      cumulativeValue = _cumulative;\n      return;\n    } else if (timeElapsed >= sampleLength * (sampleMemory - 1)) {\n      // More than total sample memory has elapsed. Reset with new values\n\n      uint256 addition = newLastValue.mul(sampleLength);\n\n      uint256 currentCumulative = _cumulative.sub(addition * (sampleMemory - 1));\n      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * (sampleMemory));\n\n      uint256 tempCount = counter;\n      for (uint256 i = 0; i < sampleMemory; i++ ) {\n        tempCount += 1;\n        liveSample = samples[_getIndexOfSample(tempCount)];\n        liveSample.timestamp = currentTimestamp;\n        liveSample.cumulativeValue = currentCumulative;\n\n        currentCumulative += addition;\n        currentTimestamp += uint64(sampleLength);\n      }\n\n      tempCount += 1;\n      liveSample = samples[_getIndexOfSample(tempCount)];\n      liveSample.timestamp = blockTimestamp;\n      // Only the most recent values really matter here\n      liveSample.value = newLastValue;\n      liveSample.lastValue = newLastValue;\n      liveSample.cumulativeValue = _cumulative;\n\n      counter = tempCount;\n      cumulativeValue = _cumulative;\n      blockTimestampLast = blockTimestamp;\n      activeSamples = sampleMemory;\n      return;\n    }\n\n    // One or more sample boundaries have been crossed.\n    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);\n    // Finish out the current sample\n    cumulativeValue += newLastValue.mul(nextSampleTime - blockTimestampLast);\n    liveSample.cumulativeValue = cumulativeValue;\n    liveSample.lastValue = newLastValue;\n\n    liveSample = _createNewSample(nextSampleTime, cumulativeValue);\n    timeElapsed = timeElapsed - uint64(sampleLength);\n\n    uint256 elapsedSamples = timeElapsed / sampleLength;\n\n    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {\n      // update\n      cumulativeValue += newLastValue.mul(sampleLength);\n      liveSample.cumulativeValue = cumulativeValue;\n\n      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);\n\n      liveSample = _createNewSample(sampleTime, cumulativeValue);\n    }\n\n    liveSample.value = newLastValue;\n    liveSample.lastValue = newLastValue;\n    liveSample.cumulativeValue = _cumulative;\n\n    cumulativeValue = _cumulative;\n    blockTimestampLast = blockTimestamp;\n\n    emit Update(newLastValue, cumulativeValue);\n  }\n\n  /*\n   * INTERNAL VIEW METHODS\n   */\n  function _getIndexOfSample(uint _count) internal view returns (uint32 index) {\n    return uint32(_count % sampleMemory);\n  }\n\n  function _getCurrentSample() private view returns (Sample storage currentSample) {\n    // Active sample is always counter - 1. Counter is the in progress sample\n    uint32 currentSampleIndex = _getIndexOfSample(counter - 1);\n    currentSample = samples[currentSampleIndex];\n  }\n\n  function _getFirstSample() private view returns (Sample storage firstSample) {\n    uint32 sampleIndex = _getIndexOfSample(counter);\n    // no overflow issue. if sampleIndex + 1 overflows, result is still zero.\n    uint32 firstSampleIndex = uint32((sampleIndex + 1) % sampleMemory);\n    firstSample = samples[firstSampleIndex];\n  }\n\n  function _getNthSample(uint256 n) private view returns (Sample storage sample) {\n    require(n < activeSamples - 1, \"Not enough samples\");\n    uint32 sampleIndex = _getIndexOfSample(counter - 1 - n);\n    sample = samples[sampleIndex];\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _createNewSample(uint64 sampleTime, uint256 cumulativeValue)\n    internal\n    returns(Sample storage liveSample)\n  {\n    Sample storage oldSample = samples[_getIndexOfSample(counter - 1)];\n    Sample storage previousSample = samples[_getIndexOfSample(counter)];\n\n    if (oldSample.timestamp > 0 && activeSamples > 1) {\n      previousSample.value = (previousSample.cumulativeValue - oldSample.cumulativeValue).div(sampleLength);\n    }\n\n    counter += 1;\n    liveSample = samples[_getIndexOfSample(counter)];\n    liveSample.timestamp = sampleTime;\n    liveSample.cumulativeValue = cumulativeValue;\n    liveSample.value = previousSample.value;\n    liveSample.lastValue = previousSample.lastValue;\n\n    if (activeSamples < sampleMemory) {\n      // Active samples is how we keep track of how many real samples we have vs default 0 values\n      // This is useful for providing data even when full sample set isn't populated yet\n      activeSamples = activeSamples + 1;\n    }\n\n    blockTimestampLast = sampleTime;\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setSampleLength(uint256 _sampleLength)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_sampleLength > 0, \"Cannot have 0 second sample length\");\n    sampleLength = _sampleLength;\n  }\n\n  function resetLiveSampleTime()\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    liveSample.timestamp = uint64(block.timestamp % 2**64); \n  }\n\n  function setSampleMemory(uint256 _sampleMemory)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_sampleMemory > 0, \"Cannot have sample memroy of 0\");\n\n    if (_sampleMemory > sampleMemory) {\n      for (uint i = sampleMemory; i < _sampleMemory; i++) {\n        samples.push();\n      }\n      counter = counter % _sampleMemory;\n    } else {\n      activeSamples = _sampleMemory;\n\n      // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST\n    }\n\n    sampleMemory = _sampleMemory;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IRewardThrottle.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ISwingTrader.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ISupplyDistributionController.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThreshold = (10**18) / 100; // 1%\n  uint256 public lowerStabilityThreshold = (10**18) / 100;\n  uint256 public maxContributionBps = 70;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistance = 20; // 2%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100;\n\n  uint256 public daoRewardCut;\n  uint256 public lpRewardCut = 417;\n  uint256 public auctionPoolRewardCut = 113;\n  uint256 public swingTraderRewardCut = 417;\n  uint256 public treasuryRewardCut = 50;\n  uint256 public callerRewardCut = 3;\n\n  uint256 public lastStabilize;\n\n  ERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  IDAO public dao;\n  address public uniswapV2Factory;\n  ILiquidityExtension public liquidityExtension;\n  IMaltDataLab public maltDataLab;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n  IRewardThrottle public rewardThrottle;\n  ISwingTrader public swingTrader;\n  IImpliedCollateralService public impliedCollateralService;\n\n  address payable public treasuryMultisig;\n  address public auctionPool;\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event RewardDistribution(uint256 rewarded);\n  event SetAnnualYield(uint256 yield);\n  event SetStabilizeBackoff(uint256 period);\n  event SetAuctionBurnSkew(address auctionBurnReserveSkew);\n  event SetRewardCut(uint256 daoCut, uint256 lpCut, uint256 callerCut, uint256 treasuryCut, uint256 auctionPoolCut, uint256 swingTraderCut);\n  event SetTreasury(address newTreasury);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetNewMaltDataLab(address dataLab);\n  event SetAuctionContract(address auction);\n  event SetDexHandler(address dexHandler);\n  event SetDao(address dao);\n  event SetLiquidityExtension(address liquidityExtension);\n  event SetRewardThrottle(address rewardThrottle);\n  event SetSwingTrader(address swingTrader);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetAuctionPool(address auctionPool);\n  event SetMaxContribution(uint256 maxContribution);\n  event SetImpliedCollateralService(address impliedCollateralService);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _rewardToken,\n    address _malt,\n    address _auction,\n    address _uniswapV2Factory,\n    address payable _treasuryMultisig,\n    address _auctionPool\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(AUCTION_ROLE, _auction);\n\n    rewardToken = ERC20(_rewardToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n\n    uniswapV2Factory = _uniswapV2Factory;\n    treasuryMultisig = _treasuryMultisig;\n    auctionPool = _auctionPool;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _dexHandler,\n    address _maltDataLab,\n    address _auctionBurnReserveSkew,\n    address _rewardThrottle,\n    address _dao,\n    address _swingTrader,\n    address _liquidityExtension,\n    address _impliedCollateralService\n  ) external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    dao = IDAO(_dao);\n    swingTrader = ISwingTrader(_swingTrader);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function stabilize() external notSameBlock {\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    rewardThrottle.checkRewardUnderflow();\n\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n\n    if (!_shouldAdjustSupply(exchangeRate)) {\n      maltDataLab.trackReserveRatio();\n\n      lastStabilize = block.timestamp;\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    if (exchangeRate > maltDataLab.priceTarget()) {\n      _distributeSupply();\n    } else {\n      _startAuction();\n    }\n\n    lastStabilize = block.timestamp;\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    if (hasRole(ADMIN_ROLE, _msgSender())) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = priceTarget.mul(1000 + overrideDistance).div(1000);\n    uint256 lowerThreshold = priceTarget.mul(1000 - overrideDistance).div(1000);\n\n    return exchangeRate <= lowerThreshold || exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {\n    uint256 decimals = rewardToken.decimals();\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);\n    uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);\n\n    return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _distributeSupply() internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController).check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTrader.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    uint256 rewards = dexHandler.sellMalt();\n\n    auctionBurnReserveSkew.addAbovePegObservation(tradeSize);\n\n    uint256 remaining = _replenishLiquidityExtension(rewards);\n\n    _distributeRewards(remaining);\n\n    maltDataLab.trackReserveRatio();\n    impliedCollateralService.claim();\n  }\n\n  function _distributeRewards(uint256 rewarded) internal {\n    if (rewarded == 0) {\n      return;\n    }\n    rewardToken.approve(address(auction), rewarded);\n    rewarded = auction.allocateArbRewards(rewarded);\n\n    if (rewarded == 0) {\n      return;\n    }\n\n    uint256 callerCut = rewarded.mul(callerRewardCut).div(1000);\n    uint256 lpCut = rewarded.mul(lpRewardCut).div(1000);\n    uint256 daoCut = rewarded.mul(daoRewardCut).div(1000);\n    uint256 auctionPoolCut = rewarded.mul(auctionPoolRewardCut).div(1000);\n    uint256 swingTraderCut = rewarded.mul(swingTraderRewardCut).div(1000);\n\n    // Treasury gets paid after everyone else\n    uint256 treasuryCut = rewarded - daoCut - lpCut - callerCut - auctionPoolCut - swingTraderCut;\n\n    assert(treasuryCut <= rewarded);\n\n    if (callerCut > 0) {\n      rewardToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    if (auctionPoolCut > 0) {\n      rewardToken.safeTransfer(auctionPool, auctionPoolCut);\n    }\n\n    if (swingTraderCut > 0) {\n      rewardToken.safeTransfer(address(swingTrader), swingTraderCut);\n    }\n\n    if (treasuryCut > 0) {\n      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);\n    }\n\n    if (daoCut > 0) {\n      rewardToken.safeTransfer(address(dao), daoCut);\n    }\n\n    if (lpCut > 0) {\n      rewardToken.safeTransfer(address(rewardThrottle), lpCut);\n      rewardThrottle.handleReward();\n    }\n\n    emit RewardDistribution(rewarded);\n  }\n\n  function _replenishLiquidityExtension(uint256 rewards) internal returns (uint256 remaining) {\n    if (liquidityExtension.hasMinimumReserves() || rewards == 0) {\n      return rewards;\n    }\n\n    (uint256 deficit,) = liquidityExtension.collateralDeficit();\n\n    uint256 maxContrib = rewards.mul(maxContributionBps).div(100);\n\n    if (deficit >= maxContrib) {\n      rewardToken.safeTransfer(address(liquidityExtension), maxContrib);\n      return rewards - maxContrib;\n    }\n\n    rewardToken.safeTransfer(address(liquidityExtension), deficit);\n\n    return rewards - deficit;\n  }\n\n  function _startAuction() internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount == 0) {\n      return;\n    }\n\n    uint256 decimals = rewardToken.decimals();\n\n    uint256 amountUsed = swingTrader.buyMalt(purchaseAmount);\n\n    purchaseAmount = purchaseAmount - amountUsed;\n\n    if (purchaseAmount < 10**decimals) {\n      return;\n    }\n\n    auction.triggerAuction(priceTarget, purchaseAmount);\n\n    malt.mint(msg.sender, defaultIncentive*10**18);\n    emit MintMalt(defaultIncentive*10**18);\n\n    auctionBurnReserveSkew.addBelowPegObservation(purchaseAmount);\n\n    maltDataLab.trackReserveRatio();\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setAuctionBurnSkew(address _auctionBurnReserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    emit SetAuctionBurnSkew(_auctionBurnReserveSkew);\n  }\n\n  function setRewardCut(\n    uint256 _daoCut,\n    uint256 _lpCut,\n    uint256 _callerCut,\n    uint256 _auctionPoolCut,\n    uint256 _swingTraderCut\n  )\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    uint256 sum = _daoCut.add(_lpCut).add(_callerCut).add(_auctionPoolCut).add(_swingTraderCut);\n    require(sum <= 1000, \"Reward cut must be <= 100%\");\n    daoRewardCut = _daoCut;\n    lpRewardCut = _lpCut;\n    callerRewardCut = _callerCut;\n    auctionPoolRewardCut = _auctionPoolCut;\n    swingTraderRewardCut = _swingTraderCut;\n    treasuryRewardCut = 1000 - sum;\n\n    emit SetRewardCut(_daoCut, _lpCut, _callerCut, treasuryRewardCut, _auctionPoolCut, _swingTraderCut);\n  }\n\n  function setTreasury(address payable _newTreasury)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    treasuryMultisig = _newTreasury;\n    emit SetTreasury(_newTreasury);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive > 0, \"No negative incentive\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setNewDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetNewMaltDataLab(_dataLab);\n  }\n\n  function setAuctionContract(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n\n    if (address(auction) != address(0)) {\n      revokeRole(AUCTION_ROLE, address(auction));\n    }\n\n    auction = IAuction(_auction);\n    _setupRole(AUCTION_ROLE, _auction);\n    emit SetAuctionContract(_auction);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper > 0 && _lower > 0, \"Must be above 0\");\n\n    upperStabilityThreshold = _upper;\n    lowerStabilityThreshold = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setAuctionPool(address _auctionPool)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auctionPool != address(0), \"Not address 0\");\n\n    auctionPool = _auctionPool;\n    emit SetAuctionPool(_auctionPool);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setMaxContribution(uint256 _maxContribution)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maxContribution > 0 && _maxContribution <= 100, \"Must be between 0 and 100\");\n\n    maxContributionBps = _maxContribution;\n    emit SetMaxContribution(_maxContribution);\n  }\n\n  function setDexHandler(address _dexHandler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dexHandler != address(0), \"Not address 0\");\n    dexHandler = IDexHandler(_dexHandler);\n    emit SetDexHandler(_dexHandler);\n  }\n\n  function setDao(address _dao)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dao != address(0), \"Not address 0\");\n    dao = IDAO(_dao);\n    emit SetDao(_dao);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Not address 0\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    emit SetLiquidityExtension(_liquidityExtension);\n  }\n\n  function setRewardThrottle(address _rewardThrottle)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_rewardThrottle != address(0), \"Not address 0\");\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    emit SetRewardThrottle(_rewardThrottle);\n  }\n\n  function setSwingTrader(address _swingTrader)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_swingTrader != address(0), \"Not address 0\");\n    swingTrader = ISwingTrader(_swingTrader);\n    emit SetSwingTrader(_swingTrader);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_impliedCollateralService != address(0), \"Not address 0\");\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    emit SetImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\");\n    overrideDistance = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n}\n\n\n",
        "CodeNames": [
            "MaltDataLab.sol",
            "MovingAverage.sol",
            "StabilizerNode.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\nfunction setSampleMemory(uint256 _sampleMemory)\n  external\n  onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n{\n  require(_sampleMemory  0, \"Cannot have sample memroy of 0\");\n\n  if (_sampleMemory  sampleMemory) {\n    for (uint i = sampleMemory; i < _sampleMemory; i++) {\n      samples.push();\n    }\n    counter = counter % _sampleMemory;\n  } else {\n    activeSamples = _sampleMemory;\n\n    // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST\n  }\n\n  sampleMemory = _sampleMemory;\n}\n"
                ],
                "Type": "  MovingAverage.setSampleMemory()  may broke MovingAverage, making the value of  exchangeRate  in  StabilizerNode.stabilize()  being extremely wrong",
                "Description": "\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L424-L442\n\nsolidity\nfunction setSampleMemory(uint256 _sampleMemory)\n  external\n  onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n{\n  require(_sampleMemory  0, \"Cannot have sample memroy of 0\");\n\n  if (_sampleMemory  sampleMemory) {\n    for (uint i = sampleMemory; i < _sampleMemory; i++) {\n      samples.push();\n    }\n    counter = counter % _sampleMemory;\n  } else {\n    activeSamples = _sampleMemory;\n\n    // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST\n  }\n\n  sampleMemory = _sampleMemory;\n}\n\n\nIn the current implementation, when sampleMemory is updated, the samples index will be malposition, making getValueWithLookback() get the wrong samples, so that returns the wrong value.\n\n\n*   When initial sampleMemory is 10\n*   After movingAverage.update(1e18) being called for 120 times\n*   The admin calls movingAverage.setSampleMemory(118) and set sampleMemory to 118\n\nThe current movingAverage.getValueWithLookback(sampleLength * 10) returns 0.00000203312 e18, while it's expeceted to be 1e18\n\nAfter setSampleMemory(), getValueWithLookback() may also return 0or revert FullMath: FULLDIV_OVERFLOW at L134.\n\n",
                "Repair": "\nConsider removing setSampleMemory function.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/313)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/313#issuecomment-1008462965):\n  I agree that calling setSampleMemory will cause issues, and can cause opportunities to further extract value.\n However this can be triggered by an admin action.\n I'll think about the severity, but as of now, because it is contingent on admin privilege, will downgrade to Medium\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/313#issuecomment-1025181213):\n  I stand by my decision of Medium Severity. While the consequences can be troublesome, they are contingent on the admin breaking / griefing the system\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Moving Average\n/// @author 0xScotch <scotch@malt.money>\n/// @notice For tracking the average of a data stream over time\n/// @dev Based on the cumulativeValue mechanism for TWAP in uniswapV2\ncontract MovingAverage is Initializable, Permissions {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n\n  struct Sample {\n    uint64 timestamp;\n    uint256 value;\n    uint256 cumulativeValue;\n    uint256 lastValue;\n  }\n\n  bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n  uint256 public sampleLength;\n  uint256 public cumulativeValue;\n  uint256 public sampleMemory;\n  uint256 public defaultValue;\n\n  uint64 public blockTimestampLast;\n\n  uint256 private counter;\n  uint256 private activeSamples;\n\n  Sample[] private samples;\n\n  event Update(uint256 value, uint256 cumulativeValue);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    uint256 _sampleLength, // eg 5min represented as seconds\n    uint256 _sampleMemory,\n    address _updater,\n    uint256 _defaultValue\n  ) external initializer {\n    require(_sampleMemory > 1, 'MA: SampleMemory > 1');\n\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _roleSetup(UPDATER_ROLE, _updater);\n    _roleSetup(UPDATER_ROLE, initialAdmin);\n\n    sampleLength = _sampleLength;\n    sampleMemory = _sampleMemory;\n    defaultValue = _defaultValue;\n\n    for (uint i = 0; i < sampleMemory; i++) {\n      samples.push();\n    }\n  }\n\n  /*\n   * PUBLIC VIEW METHODS\n   */\n  function getValue() public view returns (uint256) {\n    if (activeSamples < 2) {\n      return defaultValue;\n    } else if (activeSamples == 2) {\n      Sample storage currentSample = _getCurrentSample();\n      return currentSample.value;\n    } else if (activeSamples < sampleMemory) {\n      // Subtract 2 because this is a lookback from the current sample.\n      // activeSamples - 1 is the in progress sample. - 2 is the active sample\n      // IE if there are 2 samples, we are on one and want to lookback 1.\n      // If there are 3 samples, we are on one and want to lookback 2 etc\n      uint256 lookback = (activeSamples - 2) * sampleLength;\n      return getValueWithLookback(lookback);\n    }\n    Sample storage currentSample = _getCurrentSample();\n    Sample storage firstSample = _getFirstSample();\n\n    uint256 timeElapsed = currentSample.timestamp - firstSample.timestamp;\n    uint256 sampleDiff = currentSample.cumulativeValue - firstSample.cumulativeValue;\n\n    if (timeElapsed == 0) {\n      return currentSample.value;\n    } \n\n    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);\n\n    return sampleAverage.decode();\n  }\n\n  function getValueWithLookback(uint256 _lookbackTime) public view returns (uint256) {\n    // _lookbackTime in is seconds\n    uint256 lookbackSamples;\n    if (_lookbackTime % sampleLength == 0) {\n      // If it divides equally just divide down\n      lookbackSamples = _lookbackTime / sampleLength;\n\n      if (lookbackSamples == 0) {\n        lookbackSamples = 1;\n      }\n    } else {\n      // If it doesn't divide equally, divide and add 1.\n      // Creates a Math.ceil() situation\n      lookbackSamples = (_lookbackTime / sampleLength) + 1;\n    }\n\n    if (activeSamples < 2) {\n      return defaultValue;\n    } else if (activeSamples == 2) {\n      Sample storage currentSample = _getCurrentSample();\n      return currentSample.value;\n    } else if (lookbackSamples >= activeSamples - 1) {\n      // Looking for longer lookback than sampleMemory allows.\n      // Just return the full memory average\n      return getValue();\n    }\n\n    Sample storage currentSample = _getCurrentSample();\n    Sample storage nthSample = _getNthSample(lookbackSamples);\n\n    uint256 timeElapsed = currentSample.timestamp - nthSample.timestamp;\n    uint256 sampleDiff = currentSample.cumulativeValue - nthSample.cumulativeValue;\n\n    if (timeElapsed == 0) {\n      return currentSample.value;\n    } \n\n    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);\n\n    return sampleAverage.decode();\n  }\n\n  /*\n   * MUTATION METHODS\n   */\n  function update(uint256 newValue)\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater privs\")\n  {\n    /* \n     * This function only creates a sample at the end of the sample period.\n     * The current sample period just updates the cumulativeValue but doesn't\n     * Actually create a sample until the end of the period.\n     * This is to protect against flashloan attacks that could try manipulate\n     * the samples.\n     */\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    uint64 blockTimestamp = uint64(block.timestamp % 2**64); \n\n    // Deal with first ever sample\n    if (liveSample.timestamp == 0) {\n      liveSample.timestamp = uint64(block.timestamp);\n      liveSample.value = newValue;\n      liveSample.lastValue = newValue;\n      liveSample.cumulativeValue = newValue;\n\n      cumulativeValue = newValue;\n      blockTimestampLast = blockTimestamp;\n\n      activeSamples = activeSamples + 1;\n      return;\n    }\n\n    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;\n\n    if (timeElapsed < sampleLength) {\n      cumulativeValue += liveSample.lastValue.mul(blockTimestamp - blockTimestampLast);\n      liveSample.cumulativeValue = cumulativeValue;\n      liveSample.lastValue = newValue;\n\n      blockTimestampLast = blockTimestamp;\n      return;\n    } else if (timeElapsed >= (sampleLength - 1) * sampleMemory) {\n      // More than total sample memory has elapsed. Reset with new values\n      uint256 addition = liveSample.lastValue.mul(sampleLength);\n\n      uint256 currentCumulative = cumulativeValue;\n      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * sampleMemory);\n\n      uint256 tempCount = counter;\n      for (uint256 i = 0; i < sampleMemory; i++ ) {\n        tempCount += 1;\n        liveSample = samples[_getIndexOfSample(tempCount)];\n        liveSample.timestamp = currentTimestamp;\n        liveSample.cumulativeValue = currentCumulative;\n\n        currentCumulative += addition;\n        currentTimestamp += uint64(sampleLength);\n      }\n\n      // Reset the adding of 'addition' in the final loop\n      currentCumulative = liveSample.cumulativeValue;\n\n      tempCount += 1;\n      liveSample = samples[_getIndexOfSample(tempCount)];\n      liveSample.timestamp = blockTimestamp;\n      // Only the most recent values really matter here\n      liveSample.value = newValue;\n      liveSample.lastValue = newValue;\n      liveSample.cumulativeValue = currentCumulative;\n\n      counter = tempCount;\n      cumulativeValue = currentCumulative;\n      blockTimestampLast = blockTimestamp;\n      activeSamples = sampleMemory;\n      return;\n    }\n\n    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);\n\n    // Finish out the current sample\n    cumulativeValue += liveSample.lastValue.mul(nextSampleTime - blockTimestampLast);\n    liveSample.cumulativeValue = cumulativeValue;\n\n    liveSample = _createNewSample(nextSampleTime, cumulativeValue);\n    timeElapsed = timeElapsed - uint64(sampleLength);\n\n    uint256 elapsedSamples = timeElapsed / sampleLength;\n\n    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {\n      // update\n      cumulativeValue += liveSample.lastValue.mul(sampleLength);\n      liveSample.cumulativeValue = cumulativeValue;\n\n      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);\n\n      liveSample = _createNewSample(sampleTime, cumulativeValue);\n    }\n\n    cumulativeValue += liveSample.lastValue.mul(timeElapsed % sampleLength);\n\n    // Now set the value of the current sample to the new value\n    liveSample.value = newValue;\n    liveSample.lastValue = newValue;\n    liveSample.cumulativeValue = cumulativeValue;\n\n    blockTimestampLast = blockTimestamp;\n\n    emit Update(newValue, cumulativeValue);\n  }\n\n  function updateCumulative(uint256 _cumulative)\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater privs\")\n  {\n    require(_cumulative >= cumulativeValue, \"Cumulative value can only go up\");\n\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    uint64 blockTimestamp = uint64(block.timestamp % 2**64); \n\n    if (liveSample.timestamp == 0) {\n      cumulativeValue = _cumulative;\n      blockTimestampLast = blockTimestamp;\n\n      liveSample.timestamp = blockTimestamp;\n      liveSample.cumulativeValue = _cumulative;\n      liveSample.value = _cumulative;\n      liveSample.lastValue = _cumulative;\n\n      activeSamples = activeSamples + 1;\n      return;\n    }\n\n    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;\n    uint64 timeElapsedSinceUpdate = blockTimestamp - blockTimestampLast;\n    uint256 newLastValue = (_cumulative - cumulativeValue).div(timeElapsedSinceUpdate);\n\n    if (timeElapsed < sampleLength) {\n      // The current sample isn't over. Just update\n      liveSample.cumulativeValue = _cumulative;\n      liveSample.value = newLastValue;\n      liveSample.lastValue = newLastValue;\n\n      blockTimestampLast = blockTimestamp;\n      cumulativeValue = _cumulative;\n      return;\n    } else if (timeElapsed >= sampleLength * (sampleMemory - 1)) {\n      // More than total sample memory has elapsed. Reset with new values\n\n      uint256 addition = newLastValue.mul(sampleLength);\n\n      uint256 currentCumulative = _cumulative.sub(addition * (sampleMemory - 1));\n      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * (sampleMemory));\n\n      uint256 tempCount = counter;\n      for (uint256 i = 0; i < sampleMemory; i++ ) {\n        tempCount += 1;\n        liveSample = samples[_getIndexOfSample(tempCount)];\n        liveSample.timestamp = currentTimestamp;\n        liveSample.cumulativeValue = currentCumulative;\n\n        currentCumulative += addition;\n        currentTimestamp += uint64(sampleLength);\n      }\n\n      tempCount += 1;\n      liveSample = samples[_getIndexOfSample(tempCount)];\n      liveSample.timestamp = blockTimestamp;\n      // Only the most recent values really matter here\n      liveSample.value = newLastValue;\n      liveSample.lastValue = newLastValue;\n      liveSample.cumulativeValue = _cumulative;\n\n      counter = tempCount;\n      cumulativeValue = _cumulative;\n      blockTimestampLast = blockTimestamp;\n      activeSamples = sampleMemory;\n      return;\n    }\n\n    // One or more sample boundaries have been crossed.\n    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);\n    // Finish out the current sample\n    cumulativeValue += newLastValue.mul(nextSampleTime - blockTimestampLast);\n    liveSample.cumulativeValue = cumulativeValue;\n    liveSample.lastValue = newLastValue;\n\n    liveSample = _createNewSample(nextSampleTime, cumulativeValue);\n    timeElapsed = timeElapsed - uint64(sampleLength);\n\n    uint256 elapsedSamples = timeElapsed / sampleLength;\n\n    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {\n      // update\n      cumulativeValue += newLastValue.mul(sampleLength);\n      liveSample.cumulativeValue = cumulativeValue;\n\n      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);\n\n      liveSample = _createNewSample(sampleTime, cumulativeValue);\n    }\n\n    liveSample.value = newLastValue;\n    liveSample.lastValue = newLastValue;\n    liveSample.cumulativeValue = _cumulative;\n\n    cumulativeValue = _cumulative;\n    blockTimestampLast = blockTimestamp;\n\n    emit Update(newLastValue, cumulativeValue);\n  }\n\n  /*\n   * INTERNAL VIEW METHODS\n   */\n  function _getIndexOfSample(uint _count) internal view returns (uint32 index) {\n    return uint32(_count % sampleMemory);\n  }\n\n  function _getCurrentSample() private view returns (Sample storage currentSample) {\n    // Active sample is always counter - 1. Counter is the in progress sample\n    uint32 currentSampleIndex = _getIndexOfSample(counter - 1);\n    currentSample = samples[currentSampleIndex];\n  }\n\n  function _getFirstSample() private view returns (Sample storage firstSample) {\n    uint32 sampleIndex = _getIndexOfSample(counter);\n    // no overflow issue. if sampleIndex + 1 overflows, result is still zero.\n    uint32 firstSampleIndex = uint32((sampleIndex + 1) % sampleMemory);\n    firstSample = samples[firstSampleIndex];\n  }\n\n  function _getNthSample(uint256 n) private view returns (Sample storage sample) {\n    require(n < activeSamples - 1, \"Not enough samples\");\n    uint32 sampleIndex = _getIndexOfSample(counter - 1 - n);\n    sample = samples[sampleIndex];\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _createNewSample(uint64 sampleTime, uint256 cumulativeValue)\n    internal\n    returns(Sample storage liveSample)\n  {\n    Sample storage oldSample = samples[_getIndexOfSample(counter - 1)];\n    Sample storage previousSample = samples[_getIndexOfSample(counter)];\n\n    if (oldSample.timestamp > 0 && activeSamples > 1) {\n      previousSample.value = (previousSample.cumulativeValue - oldSample.cumulativeValue).div(sampleLength);\n    }\n\n    counter += 1;\n    liveSample = samples[_getIndexOfSample(counter)];\n    liveSample.timestamp = sampleTime;\n    liveSample.cumulativeValue = cumulativeValue;\n    liveSample.value = previousSample.value;\n    liveSample.lastValue = previousSample.lastValue;\n\n    if (activeSamples < sampleMemory) {\n      // Active samples is how we keep track of how many real samples we have vs default 0 values\n      // This is useful for providing data even when full sample set isn't populated yet\n      activeSamples = activeSamples + 1;\n    }\n\n    blockTimestampLast = sampleTime;\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setSampleLength(uint256 _sampleLength)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_sampleLength > 0, \"Cannot have 0 second sample length\");\n    sampleLength = _sampleLength;\n  }\n\n  function resetLiveSampleTime()\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    liveSample.timestamp = uint64(block.timestamp % 2**64); \n  }\n\n  function setSampleMemory(uint256 _sampleMemory)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_sampleMemory > 0, \"Cannot have sample memroy of 0\");\n\n    if (_sampleMemory > sampleMemory) {\n      for (uint i = sampleMemory; i < _sampleMemory; i++) {\n        samples.push();\n      }\n      counter = counter % _sampleMemory;\n    } else {\n      activeSamples = _sampleMemory;\n\n      // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST\n    }\n\n    sampleMemory = _sampleMemory;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\n",
        "CodeNames": [
            "MovingAverage.sol",
            "AbstractRewardMine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "(counter +",
                    "samples",
                    "_getFirstSample",
                    "counter",
                    "sampleMemory"
                ],
                "Type": "  _getFirstSample  returns wrong sample if count < sampleMemory",
                "Description": "\nThe MovingAverage.sol contract defines several variables that in the end make the samples array act as a ring buffer:\n\n*   sampleMemory: The total length (buffer size) of the samples array. samples is initialized with sampleMemory zero observations.\n*   counter: The pending sample index (modulo sampleMemory)\n\nThe _getFirstSample function computes the first sample as (counter + 1) % sampleMemory which returns the correct index only *if the ring buffer is full*, i.e., it wraps around. (in the counter + 1 = sampleMemory).\n\nIf the samples array does not wrap around yet, the zero index should be returned instead.\n\n\nReturning counter + 1 if counter + 1 < sampleMemory returns a zero initialized samples observation index.\nThis then leads to a wrong computation of the TWAP.\n\n",
                "Repair": "\nAdd an additional check for if (counter + 1 < sampleMemory) return 0 in _getFirstSample.\n\n0xScotch (sponsor) confirmed and disagreed with severity(https://github.com/code-423n4/2021-11-malt-findings/issues/252):\n  Funds aren't directly at risk. I believe this is medium severity\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/252#issuecomment-1008466725):\n  Personally am not sure the first sample after wrapping would be counter + 1 (why not  counter % sampleMemory)\n \n That said, I do agree that before wrapping, the first item in the array is at the 0 index\n \n I agree that the protocol is not behaving properly so I can understand the high severity, that said I also agree with the Sponsor's statement, the worst case would be a leak of value, so Medium severity seems the most appropriate\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nimport \"./interfaces/IStabilizerNode.sol\";\nimport \"./interfaces/IMovingAverage.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\n\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./libraries/SafeBurnMintableERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Malt Data Lab\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The central source of all of Malt protocol's internal data needs\n/// @dev Over time usage of MovingAverage will likely be replaced with more reliable oracles\ncontract MaltDataLab is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeBurnMintableERC20 for IBurnMintableERC20;\n\n  bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n  IBurnMintableERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  ILiquidityExtension public liquidityExtension;\n  IUniswapV2Pair public stakeToken;\n\n  IMovingAverage public reserveRatioMA;\n  IMovingAverage public maltPriceMA;\n  IMovingAverage public poolMaltReserveMA;\n\n  uint256 public priceTarget = 10**18; // $1\n  uint256 public reserveRatioLookback = 10 minutes;\n  uint256 public maltPriceLookback = 10 minutes;\n  uint256 public reserveLookback = 10 minutes;\n\n  event TrackMaltPrice(uint256 price);\n  event TrackPoolReserves(uint256 maltReserves, uint256 rewardReserves);\n  event TrackReserveRatio(uint256 rRatio, uint256 decimals);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    uint256 _priceTarget,\n    address _liquidityExtension,\n    address _reserveRatioMA,\n    address _maltPriceMA,\n    address _poolMaltReserveMA,\n    address _updater\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _roleSetup(UPDATER_ROLE, _updater);\n    _roleSetup(UPDATER_ROLE, initialAdmin);\n\n    stakeToken = IUniswapV2Pair(_stakeToken);\n    malt = IBurnMintableERC20(_malt);\n    rewardToken = IBurnMintableERC20(_rewardToken);\n    priceTarget = _priceTarget;\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    reserveRatioMA = IMovingAverage(_reserveRatioMA);\n    maltPriceMA = IMovingAverage(_maltPriceMA);\n    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);\n  }\n\n  function smoothedReserveRatio() public view returns (uint256) {\n    return reserveRatioMA.getValueWithLookback(reserveRatioLookback);\n  }\n\n  function smoothedMaltPrice() public view returns (uint256) {\n    return maltPriceMA.getValueWithLookback(maltPriceLookback);\n  }\n\n  function smoothedMaltInPool() public view returns (uint256) {\n    return poolMaltReserveMA.getValueWithLookback(reserveLookback);\n  }\n\n  function smoothedReserves() public view returns (uint256 maltReserves, uint256 collateralReserves) {\n    maltReserves = poolMaltReserveMA.getValueWithLookback(reserveLookback);\n    uint256 price = smoothedMaltPrice();\n    return (maltReserves, maltReserves.mul(price).div(priceTarget));\n  }\n\n  function reserveRatioAverage(uint256 _lookback) public view returns (uint256) {\n    return reserveRatioMA.getValueWithLookback(_lookback);\n  }\n\n  function maltPriceAverage(uint256 _lookback) public view returns (uint256) {\n    return maltPriceMA.getValueWithLookback(_lookback);\n  }\n\n  function maltInPoolAverage(uint256 _lookback) public view returns (uint256) {\n    return poolMaltReserveMA.getValueWithLookback(_lookback);\n  }\n\n  function realValueOfLPToken(uint256 amount) external view returns (uint256) {\n    uint256 maltPrice = smoothedMaltPrice();\n    (uint256 maltReserves, uint256 rewardReserves) = smoothedReserves();\n\n    if (maltReserves == 0) {\n      return 0;\n    }\n\n    uint256 totalLPSupply = stakeToken.totalSupply();\n\n    uint256 maltValue = amount.mul(maltReserves).div(totalLPSupply);\n    uint256 rewardValue = amount.mul(rewardReserves).div(totalLPSupply);\n\n    return rewardValue.add(maltValue.mul(maltPrice).div(priceTarget));\n  }\n\n  /*\n   * Public mutation methods\n   */\n  function trackReserveRatio() public {\n    (uint256 reserveRatio, uint256 decimals) = liquidityExtension.reserveRatio();\n\n    reserveRatioMA.update(reserveRatio);\n\n    emit TrackReserveRatio(reserveRatio, decimals);\n  }\n\n  function trackMaltPrice()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);\n      maltPriceMA.update(price);\n      emit TrackMaltPrice(price);\n    } else {\n      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);\n      maltPriceMA.update(price);\n\n      emit TrackMaltPrice(price);\n    }\n  }\n\n  function trackPoolReserves()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve1);\n      emit TrackPoolReserves(reserve1, reserve0);\n    } else {\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve0);\n      emit TrackPoolReserves(reserve0, reserve1);\n    }\n  }\n\n  function trackPool()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);\n      maltPriceMA.update(price);\n\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve1);\n      emit TrackMaltPrice(price);\n      emit TrackPoolReserves(reserve1, reserve0);\n    } else {\n      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);\n      maltPriceMA.update(price);\n\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve0);\n      emit TrackMaltPrice(price);\n      emit TrackPoolReserves(reserve0, reserve1);\n    }\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _normalizedPrice(\n    uint256 numerator,\n    uint256 denominator,\n    uint256 decimals\n  ) internal view returns(uint256 price) {\n    // Malt is 18 decimals\n    if (decimals > 18) {\n      uint256 diff = decimals - 18;\n      price = numerator.mul(10**decimals).div(denominator.mul(10**diff));\n    } else if (decimals < 18) {\n      uint256 diff = 18 - decimals;\n      price = (numerator.mul(10**diff)).mul(10**decimals).div(denominator);\n    } else {\n      price = numerator.mul(10**decimals).div(denominator);\n    }\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setLiquidityExtension(address _liquidityExtension) \n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Must be a valid address\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setPriceTarget(uint256 _price)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_price > 0, \"Cannot have 0 price\");\n    priceTarget = _price;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setMaltPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    maltPriceLookback = _lookback;\n  }\n\n  function setReserveLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    reserveLookback = _lookback;\n  }\n\n  function setReserveAverageContract(address _reserveRatioMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_reserveRatioMA != address(0), \"Cannot use 0 address\");\n    reserveRatioMA = IMovingAverage(_reserveRatioMA);\n  }\n\n  function setMaltPriceAverageContract(address _maltPriceMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maltPriceMA != address(0), \"Cannot use 0 address\");\n    maltPriceMA = IMovingAverage(_maltPriceMA);\n  }\n\n  function setMaltReservesAverageContract(address _poolMaltReserveMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_poolMaltReserveMA != address(0), \"Cannot use 0 address\");\n    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/lib/contracts/libraries/FullMath.sol';\n\nimport \"../Permissions.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\n\n/// @title Uniswap Interaction Handler\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A simple contract to make interacting with UniswapV2 pools easier.\n/// @notice The buyMalt method is locked down to avoid circumventing recovery mode\n/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct\ncontract UniswapHandler is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant BUYER_ROLE = keccak256(\"BUYER_ROLE\");\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public lpToken;\n  IUniswapV2Router02 public router;\n  address public uniswapV2Factory;\n\n  address[] public buyers;\n  mapping(address => bool) public buyersActive;\n\n  event AddMaltBuyer(address buyer);\n  event RemoveMaltBuyer(address buyer);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _lpToken,\n    address _router,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    router = IUniswapV2Router02(_router);\n\n    lpToken = ERC20(_lpToken);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);\n  }\n\n  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);\n  }\n\n  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n  }\n\n  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n\n    if (maltReserves == 0 || rewardReserves == 0) {\n      price = 0;\n      decimals = 18;\n      return (price, decimals);\n    }\n\n    uint256 rewardDecimals = rewardToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));\n      decimals = rewardDecimals;\n    } else if (rewardDecimals < maltDecimals) {\n      uint256 diff = maltDecimals - rewardDecimals;\n      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n      decimals = maltDecimals;\n    } else {\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);\n      decimals = rewardDecimals;\n    }\n  }\n\n  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)\n    external view returns (uint256 liquidityA)\n  {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      tokenA,\n      tokenB\n    );\n\n    liquidityA = UniswapV2Library.quote(\n      liquidityB,\n      reservesB,\n      reservesA\n    );\n  }\n\n  /*\n   * MUTATION FUNCTIONS\n   */\n  function buyMalt()\n    external\n    onlyRole(BUYER_ROLE, \"Must have buyer privs\")\n    returns (uint256 purchased)\n  {\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (rewardBalance == 0) {\n      return 0;\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(rewardToken);\n    path[1] = address(malt);\n\n    router.swapExactTokensForTokens(\n      rewardBalance,\n      0, // amountOutMin\n      path,\n      address(this),\n      now\n    );\n\n    purchased = malt.balanceOf(address(this));\n    malt.safeTransfer(msg.sender, purchased);\n  }\n\n  function sellMalt() external returns (uint256 rewards) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (maltBalance == 0) {\n      return 0;\n    }\n\n    malt.approve(address(router), maltBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(malt);\n    path[1] = address(rewardToken);\n\n    router.swapExactTokensForTokens(\n      maltBalance,\n      0,\n      path,\n      address(this),\n      now\n    );\n\n    rewards = rewardToken.balanceOf(address(this));\n    rewardToken.safeTransfer(msg.sender, rewards);\n  }\n\n  function addLiquidity() external returns (\n    uint256 maltUsed,\n    uint256 rewardUsed,\n    uint256 liquidityCreated\n  ) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance == 0 || rewardBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n    malt.approve(address(router), maltBalance);\n\n    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT\n    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n      address(malt),\n      address(rewardToken),\n      maltBalance,\n      rewardBalance,\n      maltBalance.mul(95).div(100),\n      rewardBalance.mul(95).div(100),\n      msg.sender, // transfer LP tokens to sender\n      now\n    );\n\n    if (maltUsed < maltBalance) {\n      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));\n    }\n\n    if (rewardUsed < rewardBalance) {\n      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));\n    }\n  }\n\n  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {\n    uint256 liquidityBalance = lpToken.balanceOf(address(this));\n\n    if (liquidityBalance == 0) {\n      return (0, 0);\n    }\n\n    lpToken.approve(address(router), liquidityBalance);\n\n    (amountMalt, amountReward) = router.removeLiquidity(\n      address(malt),\n      address(rewardToken),\n      liquidityBalance,\n      0,\n      0,\n      msg.sender, // transfer broken LP tokens to sender\n      now\n    );\n\n    if (amountMalt == 0 || amountReward == 0) {\n      liquidityBalance = lpToken.balanceOf(address(this));\n      lpToken.safeTransfer(msg.sender, liquidityBalance);\n      return (amountMalt, amountReward);\n    }\n  }\n\n  /*\n   * PRIVATE METHODS\n   */\n  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {\n    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST\n    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      sellToken,\n      buyToken\n    );\n\n    uint256 invariant = sellReserves.mul(buyReserves);\n\n    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        priceTarget,\n        buyBase.div(priceTarget).mul(buyBase).mul(997)\n      )\n    );\n\n    uint256 rightSide = sellReserves.mul(1000).div(997);\n\n    if (leftSide < rightSide) return 0;\n\n    return leftSide.sub(rightSide);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function addNewBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    require(_buyer != address(0), \"Cannot use address 0\");\n\n    if (buyersActive[_buyer]) {\n      return;\n    }\n\n    buyersActive[_buyer] = true;\n    buyers.push(_buyer);\n\n    _setupRole(BUYER_ROLE, _buyer);\n\n    emit AddMaltBuyer(_buyer);\n  }\n\n  function removeBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    if (buyers.length == 0 || !buyersActive[_buyer]) {\n      return;\n    }\n\n    address buyer;\n    buyersActive[_buyer] = false;\n\n    emit RemoveMaltBuyer(_buyer);\n    revokeRole(BUYER_ROLE, _buyer);\n\n    // Loop until the second last element\n    for (uint i = 0; i < buyers.length - 1; i = i + 1) {\n      if (buyers[i] == _buyer) {\n        // Replace the current item with the last and pop the last away.\n        buyers[i] = buyers[buyers.length - 1];\n        buyers.pop();\n        return;\n      }\n    }\n\n    // If we made it here then the buyers being removed is the last item\n    buyers.pop();\n  }\n\n  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IRewardThrottle.sol\";\nimport \"./interfaces/IDexHandler.sol\";\n\n\n/// @title Swing Trader\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The sole aim of this contract is to defend peg and try to profit in the process.\n/// @dev It does so from a privileged internal position where it is allowed to purchase on the AMM even in recovery mode\ncontract SwingTrader is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  ERC20 public collateralToken;\n  ERC20 public malt;\n  IDexHandler public dexHandler;\n  IRewardThrottle public rewardThrottle;\n\n  uint256 internal deployedCapital;\n  uint256 public lpProfitCut = 500; // 50%\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    address _dexHandler,\n    address _stabilizerNode,\n    address _rewardThrottle\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = ERC20(_malt);\n    dexHandler = IDexHandler(_dexHandler);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n  }\n\n  function buyMalt(uint256 maxCapital)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must have stabilizer node privs\")\n    returns (uint256 capitalUsed)\n  {\n    if (maxCapital == 0) {\n      return 0;\n    }\n\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (balance == 0) {\n      return 0;\n    }\n\n    if (maxCapital < balance) {\n      balance = maxCapital;\n    }\n\n    collateralToken.safeTransfer(address(dexHandler), balance);\n    dexHandler.buyMalt();\n\n    deployedCapital = deployedCapital + balance;\n\n    return balance;\n  }\n\n  function sellMalt(uint256 maxAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must have stabilizer node privs\")\n    returns (uint256 amountSold)\n  {\n    if (maxAmount == 0) {\n      return 0;\n    }\n\n    uint256 totalMaltBalance = malt.balanceOf(address(this));\n    uint256 balance = totalMaltBalance;\n\n    if (balance == 0) {\n      return 0;\n    }\n\n    (uint256 basis,) = costBasis();\n\n    if (maxAmount < totalMaltBalance) {\n      balance = maxAmount;\n    }\n\n    malt.safeTransfer(address(dexHandler), balance);\n    uint256 rewards = dexHandler.sellMalt();\n\n    if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {\n      // If all malt is spent we want to reset deployed capital\n      deployedCapital = deployedCapital - rewards;\n    } else {\n      deployedCapital = 0;\n    }\n\n    uint256 maltDecimals = malt.decimals();\n    uint256 decimals = collateralToken.decimals();    \n\n    uint256 profit = 0;\n\n    if (maltDecimals == decimals) {\n      uint256 soldBasis = basis.mul(balance).div(10**decimals);\n\n      if (rewards > soldBasis) {\n        profit = rewards.sub(soldBasis);\n      }\n    } else if (maltDecimals > decimals) {\n      uint256 diff = maltDecimals - decimals;\n      uint256 soldBasis = basis.mul(balance.div(10**diff)).div(10**decimals);\n\n      if (rewards > soldBasis) {\n        profit = rewards.sub(soldBasis);\n      }\n    } else {\n      uint256 diff = decimals - maltDecimals;\n      uint256 soldBasis = basis.mul(balance.mul(10**diff)).div(10**decimals);\n\n      if (rewards > soldBasis) {\n        profit = rewards.sub(soldBasis);\n      }\n    }\n\n    if (profit > 0) {\n      uint256 lpCut = profit.mul(lpProfitCut).div(1000);\n\n      collateralToken.safeTransfer(address(rewardThrottle), lpCut);\n      rewardThrottle.handleReward();\n    }\n\n    return balance;\n  }\n\n  function costBasis() public view returns (uint256 cost, uint256 decimals) {\n    // Always returns using the decimals of the collateralToken as that is the \n    // currency costBasis is calculated in\n    decimals = collateralToken.decimals();    \n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (deployedCapital == 0 || maltBalance == 0) {\n      return (0, decimals);\n    }\n\n    uint256 maltDecimals = malt.decimals();    \n\n    if (maltDecimals == decimals) {\n      return (deployedCapital.mul(10**decimals).div(maltBalance), decimals);\n    } else if (maltDecimals > decimals) {\n      uint256 diff = maltDecimals - decimals;\n      return (deployedCapital.mul(10**decimals).div(maltBalance.div(10**diff)), decimals);\n    } else {\n      uint256 diff = decimals - maltDecimals;\n      return (deployedCapital.mul(10**decimals).div(maltBalance.mul(10**diff)), decimals);\n    }\n  }\n\n  function setLpProfitCut(uint256 _profitCut) public onlyRole(ADMIN_ROLE, \"Must have admin privs\") {\n    require(_profitCut >= 0 && _profitCut <= 1000, \"Must be between 0 and 100%\");\n    lpProfitCut = _profitCut;  \n  }\n}\n\n\n",
        "CodeNames": [
            "MaltDataLab.sol",
            "UniswapHandler.sol",
            "Auction.sol",
            "SwingTrader.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "//solidity\nelse if (rewardDecimals < maltDecimals) {\n  uint256 diff = maltDecimals rewardDecimals;\n  price = (rewardReserves.mul(10diff)).mul(10rewardDecimals).div(maltReserves);\n  decimals = maltDecimals;\n}\n"
                ],
                "Type": "  UniswapHandler.maltMarketPrice  returns wrong decimals",
                "Description": "\n\n\nThe UniswapHandler.maltMarketPrice function returns a tuple of the price and the decimals of the price.\nHowever, the returned decimals do not match the computed price for the else if (rewardDecimals < maltDecimals) branch:\n\nsolidity\nelse if (rewardDecimals < maltDecimals) {\n  uint256 diff = maltDecimals rewardDecimals;\n  price = (rewardReserves.mul(10diff)).mul(10rewardDecimals).div(maltReserves);\n  decimals = maltDecimals;\n}\n\n\nNote that rewardReserves are in reward token decimals, maltReserves is a malt balance amount (18 decimals).\nThen, the returned amount is in rewardDecimals + diffDecimals + rewardDecimals maltDecimals = maltDecimals + rewardDecimals maltDecimals = rewardDecimals.\nHowever decimals = maltDecimals is wrongly returned.\n\n\nCallers to this function will receive a price in unexpected decimals and might inflate or deflate the actual amount.\nLuckily, the AuctionEscapeHatch decides to completely ignore the returned decimals and as all prices are effectively in rewardDecimals, even if stated in maltDecimals, it currently does not seem to lead to an issue.\n\n",
                "Repair": "\nFix the function by returning rewardDecimals instead of maltDecimals in the rewardDecimals < maltDecimals branch.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/255) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/255#issuecomment-1010461081):\n  Finding is valid, because the returned value is unused, I agree with the medium severity\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\n\n\n/// @title Auction Participant\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Will generally be inherited to give another contract the ability to use its capital to buy arbitrage tokens\ncontract AuctionParticipant is Permissions {\n  bytes32 public constant IMPLIED_COLLATERAL_SERVICE_ROLE = keccak256(\"IMPLIED_COLLATERAL_SERVICE_ROLE\");\n\n  IAuction public auction;\n  ERC20 public auctionRewardToken;\n\n  uint256 public replenishingIndex;\n  uint256[] public auctionIds;\n  uint256 public claimableRewards;\n\n  bool internal setupCompleted;\n\n  function setupParticipant(\n    address _impliedCollateralService,\n    address _rewardToken,\n    address _auction\n  ) public {\n    require(!setupCompleted, \"Can only call setup once\");\n\n    _roleSetup(IMPLIED_COLLATERAL_SERVICE_ROLE, _impliedCollateralService);\n    auctionRewardToken = ERC20(_rewardToken);\n    auction = IAuction(_auction);\n\n    setupCompleted = true;\n  }\n\n  function purchaseArbitrageTokens(uint256 maxAmount)\n    external\n    onlyRole(IMPLIED_COLLATERAL_SERVICE_ROLE, \"Must have implied collateral service privs\")\n    returns (uint256 remaining)\n  {\n    uint256 balance = usableBalance();\n\n    if (maxAmount < balance) {\n      balance = maxAmount;\n    }\n\n    uint256 currentAuction = auction.currentAuctionId();\n    \n    if (!auction.auctionActive(currentAuction)) {\n      return maxAmount;\n    }\n\n    auctionIds.push(currentAuction);\n\n    auctionRewardToken.approve(address(auction), balance);\n    auction.purchaseArbitrageTokens(balance);\n    \n    return maxAmount - balance;\n  }\n\n  function claim() external {\n    if (auctionIds.length == 0 || replenishingIndex >= auctionIds.length) {\n      return;\n    }\n\n    uint256 auctionId = auctionIds[replenishingIndex];\n    uint256 replenishingId = auction.replenishingAuctionId();\n\n    if (auctionId > replenishingId) {\n      // Not yet replenishing this auction\n      return;\n    }\n    uint256 claimableTokens = auction.userClaimableArbTokens(address(this), auctionId);\n\n    if (claimableTokens == 0) {\n      // Nothing to claim yet\n      return;\n    }\n\n    uint256 balance = auctionRewardToken.balanceOf(address(this));\n\n    auction.claimArbitrage(auctionId);\n\n    uint256 finalBalance = auctionRewardToken.balanceOf(address(this));\n    uint256 rewardedAmount = finalBalance - balance;\n\n    claimableRewards = claimableRewards.add(rewardedAmount);\n\n    uint256 claimable = auction.userClaimableArbTokens(address(this), auctionId);\n\n    if (replenishingId > auctionId && claimable == 0) {\n      // Don't increment replenishingIndex if replenishingAuctionId == auctionId as\n      // claimable could be 0 due to the debt not being 100% replenished.\n      replenishingIndex = replenishingIndex + 1;\n    }\n\n    _handleRewardDistribution(rewardedAmount);\n  }\n\n  function outstandingArbTokens() public view returns (uint256 outstanding) {\n    outstanding = 0;\n\n    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) {\n      uint256 claimable = auction.balanceOfArbTokens(\n        auctionIds[i],\n        address(this)\n      );\n\n      outstanding = outstanding + claimable;\n    }\n\n    return outstanding;\n  }\n\n  function getAllAuctionIds() public view returns (uint256[] memory) {\n    return auctionIds;\n  }\n\n  function usableBalance() virtual public view returns(uint256) {\n    return auctionRewardToken.balanceOf(address(this));\n  }\n\n  function _handleRewardDistribution(uint256 rewarded) virtual internal {\n    // Do nothing\n    return;\n  }\n\n  function setReplenishingIndex(uint256 _index)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_index > replenishingIndex, \"Cannot replenishingIndex to old value\");\n    replenishingIndex = _index;\n  }\n}\n\n\n",
        "CodeNames": [
            "AuctionParticipant.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-10",
                "Location": [
                    "setReplenishingIndex",
                    "replenishingIndex"
                ],
                "Type": " AuctionParticipant.sol:  setReplenishingIndex  mistake could freeze unclaimed tokens",
                "Description": "\nIn AuctionParticipant.sol, the function setReplenishingIndex is an admin function that allows manually setting replenishingIndex. As I have shown in my two previous findings, I believe that this function could be called frequently. In my opinion (and Murphy's law would agree), this implies that eventually an admin will accidentally set replenishingIndex incorrectly with this function.\n\nRight now, setReplenishingIndex does not allow the admin to set replenishingIndex to a value smaller than it currently is. So, if an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value (the higher the value set, the worse this issue). All of the unclaimed tokens on auctions at smaller indices would be locked forever.\n\n\nSee code for setReplenishingIndex here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L132\n\n\n",
                "Repair": "\nRemove the require statement on line 136, so that an admin can set the index to a smaller value.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/88) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/88#issuecomment-1011612291):\n  Agree with the finding in that if the ADMIN were to increase the replenishingIndex then the unclaim tokens at auctions below the index wouldn't be claimable anymore.\n \n I believe the warden properly highlighted what an hypothetical abuse of admin privilege would look like.\n As such I'll rate the finding with medium severity.\n \n I don't necessarily agree with the warden recommended mitigation, it may actually be best to simply delete the setter, or force it to go up by one index at a time after checking that all tokens are claimed\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./interfaces/IERC20Permit.sol\";\n\n\ninterface ITransferReceiver {\n  function onTokenTransfer(address, uint, bytes calldata) external returns (bool);\n}\n\ninterface IApprovalReceiver {\n  function onTokenApproval(address, uint, bytes calldata) external returns (bool);\n}\n\ncontract ERC20Permit is ERC20, IERC20Permit {\n  bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public constant TRANSFER_TYPEHASH = keccak256(\"Transfer(address owner,address to,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public override immutable DOMAIN_SEPARATOR;\n\n  /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.\n  mapping (address => uint256) public override nonces;\n\n  constructor(string memory name, string memory ticker) public ERC20(name, ticker) {\n    uint256 chainId;\n    assembly {chainId := chainid()}\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n        keccak256(bytes(name)),\n        keccak256(bytes(\"1\")),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /// Requirements:\n  ///   - `deadline` must be timestamp in future.\n  ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\n  ///   - the signature must use `owner` account's current nonce (see {nonces}).\n  ///   - the signer cannot be zero address and must be `owner` account.\n  function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\n    require(block.timestamp <= deadline, \"ERC20Permit: Expired permit\");\n\n    bytes32 hashStruct = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        target,\n        spender,\n        value,\n        nonces[target]++,\n        deadline\n      )\n    );\n\n    require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\n\n    _approve(target, spender, value);\n    emit Approval(target, spender, value);\n  }\n\n  function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool) {\n    require(block.timestamp <= deadline, \"ERC20Permit: Expired permit\");\n\n    bytes32 hashStruct = keccak256(\n      abi.encode(\n        TRANSFER_TYPEHASH,\n        target,\n        to,\n        value,\n        nonces[target]++,\n        deadline\n      )\n    );\n\n    require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\n\n    require(to != address(0) || to != address(this));\n\n    uint256 balance = balanceOf(target);\n    require(balance >= value, \"ERC20Permit: transfer amount exceeds balance\");\n\n    _transfer(target, to, value);\n\n    return true;\n  }\n\n  function verifyEIP712(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {\n    bytes32 hash = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        DOMAIN_SEPARATOR,\n        hashStruct\n      )\n    );\n\n    address signer = ecrecover(hash, v, r, s);\n    return (signer != address(0) && signer == target);\n  }\n\n  function verifyPersonalSign(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {\n    bytes32 hash = prefixed(hashStruct);\n    address signer = ecrecover(hash, v, r, s);\n    return (signer != address(0) && signer == target);\n  }\n\n  // Builds a prefixed hash to mimic the behavior of eth_sign.\n  function prefixed(bytes32 hash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {\n    _approve(msg.sender, spender, value);\n\n    return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);\n  }\n\n  function transferAndCall(address to, uint value, bytes calldata data) external returns (bool) {\n    require(to != address(0) || to != address(this));\n\n    uint256 balance = balanceOf(msg.sender);\n    require(balance >= value, \"ERC20Permit: transfer amount exceeds balance\");\n\n    _transfer(msg.sender, to, value);\n\n    return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\n/// @title Permissions\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Inherited by almost all Malt contracts to provide access control\ncontract Permissions is AccessControl {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n  // Can mint/burn Malt\n  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(\"MONETARY_BURNER_ROLE\");\n  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(\"MONETARY_MINTER_ROLE\");\n\n  // Contract types\n  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(\"STABILIZER_NODE_ROLE\");\n  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(\"LIQUIDITY_MINE_ROLE\");\n  bytes32 public constant AUCTION_ROLE = keccak256(\"AUCTION_ROLE\");\n  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(\"REWARD_THROTTLE_ROLE\");\n\n  address internal globalAdmin;\n\n  mapping(address => uint256) public lastBlock; // protect against reentrancy\n\n  function _adminSetup(address _timelock) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(GOVERNOR_ROLE, _timelock);\n    _roleSetup(MONETARY_BURNER_ROLE, _timelock);\n    _roleSetup(MONETARY_MINTER_ROLE, _timelock);\n    _roleSetup(STABILIZER_NODE_ROLE, _timelock);\n    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);\n    _roleSetup(AUCTION_ROLE, _timelock);\n    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);\n\n    globalAdmin = _timelock;\n  }\n\n  function assignRole(bytes32 role, address _assignee)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _setupRole(role, _assignee);\n  }\n\n  function removeRole(bytes32 role, address _entity)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can revoke roles\")\n  {\n    revokeRole(role, _entity);\n  }\n\n  function reassignGlobalAdmin(address _admin)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);\n    _swapRole(_admin, globalAdmin, ADMIN_ROLE);\n    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);\n    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);\n    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);\n    _swapRole(_admin, globalAdmin, AUCTION_ROLE);\n    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);\n\n    globalAdmin = _admin;\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    // Transfers the entire balance of the Gas token to destination\n    destination.call{value: address(this).balance}('');\n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    destination.call{value: amount}('');\n  }\n\n  function partialWithdraw(address _token, address destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {\n    revokeRole(role, oldAccount);\n    _setupRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _setupRole(role, account);\n    _setRoleAdmin(role, ADMIN_ROLE);\n  }\n\n  function _onlyRole(bytes32 role, string memory reason) internal view {\n    require(\n      hasRole(\n        role,\n        _msgSender()\n      ),\n      reason\n    );\n  }\n\n  function _notSameBlock() internal {\n    require(\n      block.number > lastBlock[_msgSender()],\n      \"Can't carry out actions in the same block\"\n    );\n    lastBlock[_msgSender()] = block.number;\n  }\n\n  // Using internal function calls here reduces compiled bytecode size\n  modifier onlyRole(bytes32 role, string memory reason) {\n    _onlyRole(role, reason);\n    _;\n  }\n\n  modifier notSameBlock() {\n    _notSameBlock();\n    _;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\n",
        "CodeNames": [
            "ERC20Permit.sol",
            "Permissions.sol",
            "AbstractRewardMine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "//solidity\npragma //solidity ^0.8.0;\n\ncontract Receivier{}\n\ncontract Permissions {\n  constructor() payable {}\n\n  function emergencyWithdrawGAS(address payable destination) external {\n    (bool ok, ) = destination.call{value: address(this).balance}('');\n    require(ok, \"call failed\");\n  }\n}\n"
                ],
                "Type": " Permissions - return values not checked when sending ETH",
                "Description": "\nOn lines 85 and 101, ETH is transferred using a .call to an address provided as an input, but there is no verification that the call call succeeded. This can result in a call to emergencyWithdrawGAS or partialWithdrawGAS appearing successful but in reality it failed. This can happen when the provided destination address is a contract that cannot receive ETH, or if the amount provided is larger than the contract's balance\n\n\nEnter the following in remix, deploy the Receiver contract, and send 1 ETH when deploying the Permissions contract. Call emergencyWithdrawGAS with the receiver address and you'll see it reverts. This would not be caught in the current code\n\nsolidity\npragma solidity ^0.8.0;\n\ncontract Receivier{}\n\ncontract Permissions {\n  constructor() payable {}\n\n  function emergencyWithdrawGAS(address payable destination) external {\n    (bool ok, ) = destination.call{value: address(this).balance}('');\n    require(ok, \"call failed\");\n  }\n}\n\n\n\nRemix\n\n",
                "Repair": "\nIn emergencyWithdrawGAS:\n\ndiff\ndestination.call{value: address(this).balance}('');\n+ (bool ok, ) = destination.call{value: address(this).balance}('');\n+ require(ok, \"call failed\");\n\n\nAnd similar for partialWithdrawGAS\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/329) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/329#issuecomment-1019293046):\n  Agree with the finding, I believe if a developer were to not use safeTransfer we'd rate as medium, so while I believe the impact to be minimal (no composability), I'll keep the severity to medium\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Malt DAO\n/// @author 0xScotch <scotch@malt.money>\n/// @notice In essence a contract that is the oracle for the current epoch\ncontract MaltDAO is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  IBurnMintableERC20 public malt;\n  uint256 public epoch = 0;\n  uint256 public epochLength;\n  uint256 public genesisTime;\n  uint256 public advanceIncentive = 100; // 100 Malt\n\n  event Advance(uint256 indexed epoch, uint256 block, uint256 timestamp);\n  event Mint(address recipient, uint256 amount);\n  event SetMaltToken(address maltToken);\n  event SetEpochLength(uint256 length);\n  event SetAdvanceIncentive(uint256 incentive);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    uint256 _epochLength,\n    uint256 _genesisTime,\n    address offering,\n    uint256 offeringMint\n  ) external initializer {\n    _setMaltToken(_malt);\n    _setEpochLength(_epochLength);\n\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    genesisTime = _genesisTime;\n\n    if (offeringMint > 0) {\n      // Tokens minted to Community Whitelist contract\n      malt.mint(offering, offeringMint);\n    }\n  }\n\n  receive() external payable {}\n\n  function advance() external {\n    require(block.timestamp >= getEpochStartTime(epoch + 1), \"Cannot advance epoch until start of new epoch\");\n\n    incrementEpoch();\n\n    malt.mint(msg.sender, advanceIncentive * 1e18);\n\n    emit Advance(epoch, block.number, block.timestamp);\n  }\n\n  function getEpochStartTime(uint256 _epoch) public view returns (uint256) {\n    return genesisTime.add(epochLength.mul(_epoch));\n  }\n\n  function epochsPerYear() public view returns (uint256) {\n    // 31557600 = seconds in a year\n    return 31557600 / epochLength;\n  }\n\n  function mint(address to, uint256 amount)\n    public\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    require(amount > 0, \"Cannot have zero amount\");\n    malt.mint(to, amount);\n    emit Mint(to, amount);\n  }\n\n  function setMaltToken(address _malt)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    _setMaltToken(_malt);\n  }\n\n  function setEpochLength(uint256 _length)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_length > 0, \"Cannot have zero length epochs\");\n    _setEpochLength(_length);\n  }\n\n  function setAdvanceIncentive(uint256 incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    advanceIncentive = incentive;\n    emit SetAdvanceIncentive(incentive);\n  }\n\n  /* Internal methods */\n  function incrementEpoch() internal {\n    epoch = epoch.add(1);\n  }\n  \n  function _setEpochLength(uint256 length) internal {\n    epochLength = length;\n    emit SetEpochLength(length);\n  }\n\n  function _setMaltToken(address _malt) internal {\n    malt = IBurnMintableERC20(_malt);\n    emit SetMaltToken(_malt);\n  }\n}\n\n\n",
        "CodeNames": [
            "DAO.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-13",
                "Location": [
                    "advance",
                    "advanceIncentive"
                ],
                "Type": " Reducing the epoch length results in leaking value from advancement incentives",
                "Description": "\n\nUnintended advancement incentives being paid out to third party\n\n\nDAO.sol incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the advance function. This is limited by checking that the start timestamp of the next epoch has passed.\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63\n\nThis start timestamp is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp.\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L65-L67\n\nThis method makes no accommodation for the fact that previous epochs may have been set to be a different length to what they are currently.\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L111-L114\n\nIn the case where the epoch length is reduced, DAO will think that the epoch number can be incremented potentially many times. Provided the advanceIncentive is worth more than the gas necessary to advance the epoch will be rapidly advanced potentially many times paying out unnecessary incentives.\n\n",
                "Repair": "\nRather than calculating from the genesis timestamp, store the last time that the epoch length was modified and calculate from there.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/4) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/4#issuecomment-1019293929):\n  Given a specific epoch length, the system will be able to determine which incentives to pay out.\n Because the math for calculating the next epoch is based on the initial time, changing the epochLength can cause unintended consequences and allow for further calls to advance with the goal of receiving more caller incentives.\n \n The exploit can be triggered by admin privileges (changing epochLength), and because it's a leak of value, I agree with medium severity\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\n/// @title Permissions\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Inherited by almost all Malt contracts to provide access control\ncontract Permissions is AccessControl {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n  // Can mint/burn Malt\n  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(\"MONETARY_BURNER_ROLE\");\n  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(\"MONETARY_MINTER_ROLE\");\n\n  // Contract types\n  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(\"STABILIZER_NODE_ROLE\");\n  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(\"LIQUIDITY_MINE_ROLE\");\n  bytes32 public constant AUCTION_ROLE = keccak256(\"AUCTION_ROLE\");\n  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(\"REWARD_THROTTLE_ROLE\");\n\n  address internal globalAdmin;\n\n  mapping(address => uint256) public lastBlock; // protect against reentrancy\n\n  function _adminSetup(address _timelock) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(GOVERNOR_ROLE, _timelock);\n    _roleSetup(MONETARY_BURNER_ROLE, _timelock);\n    _roleSetup(MONETARY_MINTER_ROLE, _timelock);\n    _roleSetup(STABILIZER_NODE_ROLE, _timelock);\n    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);\n    _roleSetup(AUCTION_ROLE, _timelock);\n    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);\n\n    globalAdmin = _timelock;\n  }\n\n  function assignRole(bytes32 role, address _assignee)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _setupRole(role, _assignee);\n  }\n\n  function removeRole(bytes32 role, address _entity)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can revoke roles\")\n  {\n    revokeRole(role, _entity);\n  }\n\n  function reassignGlobalAdmin(address _admin)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);\n    _swapRole(_admin, globalAdmin, ADMIN_ROLE);\n    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);\n    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);\n    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);\n    _swapRole(_admin, globalAdmin, AUCTION_ROLE);\n    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);\n\n    globalAdmin = _admin;\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    // Transfers the entire balance of the Gas token to destination\n    destination.call{value: address(this).balance}('');\n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    destination.call{value: amount}('');\n  }\n\n  function partialWithdraw(address _token, address destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {\n    revokeRole(role, oldAccount);\n    _setupRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _setupRole(role, account);\n    _setRoleAdmin(role, ADMIN_ROLE);\n  }\n\n  function _onlyRole(bytes32 role, string memory reason) internal view {\n    require(\n      hasRole(\n        role,\n        _msgSender()\n      ),\n      reason\n    );\n  }\n\n  function _notSameBlock() internal {\n    require(\n      block.number > lastBlock[_msgSender()],\n      \"Can't carry out actions in the same block\"\n    );\n    lastBlock[_msgSender()] = block.number;\n  }\n\n  // Using internal function calls here reduces compiled bytecode size\n  modifier onlyRole(bytes32 role, string memory reason) {\n    _onlyRole(role, reason);\n    _;\n  }\n\n  modifier notSameBlock() {\n    _notSameBlock();\n    _;\n  }\n}\n\n\npragma solidity >=0.6.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Malt DAO\n/// @author 0xScotch <scotch@malt.money>\n/// @notice In essence a contract that is the oracle for the current epoch\ncontract MaltDAO is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  IBurnMintableERC20 public malt;\n  uint256 public epoch = 0;\n  uint256 public epochLength;\n  uint256 public genesisTime;\n  uint256 public advanceIncentive = 100; // 100 Malt\n\n  event Advance(uint256 indexed epoch, uint256 block, uint256 timestamp);\n  event Mint(address recipient, uint256 amount);\n  event SetMaltToken(address maltToken);\n  event SetEpochLength(uint256 length);\n  event SetAdvanceIncentive(uint256 incentive);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    uint256 _epochLength,\n    uint256 _genesisTime,\n    address offering,\n    uint256 offeringMint\n  ) external initializer {\n    _setMaltToken(_malt);\n    _setEpochLength(_epochLength);\n\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    genesisTime = _genesisTime;\n\n    if (offeringMint > 0) {\n      // Tokens minted to Community Whitelist contract\n      malt.mint(offering, offeringMint);\n    }\n  }\n\n  receive() external payable {}\n\n  function advance() external {\n    require(block.timestamp >= getEpochStartTime(epoch + 1), \"Cannot advance epoch until start of new epoch\");\n\n    incrementEpoch();\n\n    malt.mint(msg.sender, advanceIncentive * 1e18);\n\n    emit Advance(epoch, block.number, block.timestamp);\n  }\n\n  function getEpochStartTime(uint256 _epoch) public view returns (uint256) {\n    return genesisTime.add(epochLength.mul(_epoch));\n  }\n\n  function epochsPerYear() public view returns (uint256) {\n    // 31557600 = seconds in a year\n    return 31557600 / epochLength;\n  }\n\n  function mint(address to, uint256 amount)\n    public\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    require(amount > 0, \"Cannot have zero amount\");\n    malt.mint(to, amount);\n    emit Mint(to, amount);\n  }\n\n  function setMaltToken(address _malt)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    _setMaltToken(_malt);\n  }\n\n  function setEpochLength(uint256 _length)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_length > 0, \"Cannot have zero length epochs\");\n    _setEpochLength(_length);\n  }\n\n  function setAdvanceIncentive(uint256 incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    advanceIncentive = incentive;\n    emit SetAdvanceIncentive(incentive);\n  }\n\n  /* Internal methods */\n  function incrementEpoch() internal {\n    epoch = epoch.add(1);\n  }\n  \n  function _setEpochLength(uint256 length) internal {\n    epochLength = length;\n    emit SetEpochLength(length);\n  }\n\n  function _setMaltToken(address _malt) internal {\n    malt = IBurnMintableERC20(_malt);\n    emit SetMaltToken(_malt);\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\n",
        "CodeNames": [
            "Permissions.sol",
            "DAO.sol",
            "AbstractRewardMine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-14",
                "Location": [
                    "ADMIN_ROLE",
                    "reassignGlobalAdmin",
                    "onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")",
                    "revokeRole(role, oldAccount)",
                    "TIMELOCK_ROLE"
                ],
                "Type": " Wrong permissions on  reassignGlobalAdmin ",
                "Description": "\nThe Permissions.reassignGlobalAdmin function is supposed to only be run with the TIMELOCK_ROLE role, see onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\").\n\nHowever, the TIMELOCK_ROLE is not the admin of all the reassigned roles and the revokeRole(role, oldAccount) calls will fail as it requires the ADMIN_ROLE.\n\n",
                "Repair": "\nThe idea might have been that only the TIMELOCK should be able to call this function, and usually it is also an admin, but the function strictly does not work if the caller *only* has the TIMELOCK roll and will revert in this case.\nMaybe governance decided to remove the admin role from the Timelock, which makes it impossible to call reassignGlobalAdmin anymore as both the timelock and admin are locked out.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/250) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/250#issuecomment-1019393705):\n  The warden has identified a flaw in the roles implementation, while the system seems to work when the timelock has multiple roles, the name of the roles implies a different functionality than what can actually be done.\n The sponsor confirms.\n While I believe the impact in the demo setup to be fairly minor, because the finding shows a flow in the role setup, and the sponsor confirmed, I agree with medium severity\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"./Permissions.sol\";\n\n/// @title AbstractTransferVerification\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Implements a single method that can block a particular transfer\nabstract contract AbstractTransferVerification is Permissions {\n  function verifyTransfer(address from, address to, uint256 amount) public view virtual returns (bool, string memory) {\n    return (true, \"\");\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IBurnMintableERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function burn(address account, uint256 amount) external;\n    function mint(address account, uint256 amount) external;\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IMiningService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\n\nimport \"./Permissions.sol\";\n\n\nstruct UserState {\n  uint256 bonded;\n\n  // TODO calculate average bonded period for log calc Tue 03 Aug 2021 11:22:39 BST\n  uint256 bondedEpoch;\n}\n\nstruct EpochState {\n  uint256 lastTotalBonded;\n  uint256 lastUpdateTime;\n  uint256 cumulativeTotalBonded;\n}\n\n\n/// @title LP Bonding\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract which LP tokens are bonded to to make a user eligible for protocol rewards\ncontract Bonding is Initializable, Permissions {\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public stakeToken;\n  IDAO public dao;\n  IMiningService public miningService;\n  IDexHandler public dexHandler;\n  IMaltDataLab public maltDataLab;\n\n  uint256 internal _globalBonded;\n  uint256 internal _currentEpoch;\n  address internal offering;\n  mapping(address => UserState) internal userState;\n  mapping(uint256 => EpochState) internal epochState;\n\n  event Bond(address indexed account, uint256 value);\n  event Unbond(address indexed account, uint256 value);\n  event UnbondAndBreak(address indexed account, uint256 amountLPToken, uint256 amountMalt, uint256 amountReward);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    address _dao,\n    address _miningService,\n    address _offering,\n    address _dexHandler,\n    address _maltDataLab\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    dao = IDAO(_dao);\n    offering = _offering;\n    stakeToken = ERC20(_stakeToken);\n    miningService = IMiningService(_miningService);\n    dexHandler = IDexHandler(_dexHandler);\n    malt = ERC20(_malt);\n    rewardToken = ERC20(_rewardToken);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n  }\n\n  function bond(uint256 amount) external {\n    bondToAccount(msg.sender, amount);\n  }\n\n  function bondToAccount(address account, uint256 amount)\n    public\n  {\n    if (msg.sender != offering) {\n      _notSameBlock();\n    }\n    require(amount > 0, \"Cannot bond 0\");\n\n    miningService.onBond(account, amount);\n\n    _bond(account, amount);\n  }\n\n  function unbond(uint256 amount)\n    external\n  {\n    require(amount > 0, \"Cannot unbond 0\");\n\n    uint256 bondedBalance = balanceOfBonded(msg.sender);\n\n    require(bondedBalance > 0, \"< bonded balance\");\n    require(amount <= bondedBalance, \"< bonded balance\");\n\n    // Avoid leaving dust behind\n    if (amount.add(1e16) > bondedBalance) {\n      amount = bondedBalance;\n    }\n\n    miningService.onUnbond(msg.sender, amount);\n\n    _unbond(amount);\n  }\n\n  function unbondAndBreak(uint256 amount)\n    external\n  {\n    require(amount > 0, \"Cannot unbond 0\");\n\n    uint256 bondedBalance = balanceOfBonded(msg.sender);\n\n    require(bondedBalance > 0, \"< bonded balance\");\n    require(amount <= bondedBalance, \"< bonded balance\");\n\n    // Avoid leaving dust behind\n    if (amount.add(1e16) > bondedBalance) {\n      amount = bondedBalance;\n    }\n\n    miningService.onUnbond(msg.sender, amount);\n\n    _unbondAndBreak(amount);\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function averageBondedValue(uint256 epoch) public view returns (uint256) {\n    EpochState storage state = epochState[epoch];\n    uint256 epochLength = dao.epochLength();\n    uint256 timeElapsed = epochLength;\n    uint256 epochStartTime = dao.getEpochStartTime(epoch);\n    uint256 diff;\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lastTotalBonded = state.lastTotalBonded;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastTotalBonded == 0) {\n      lastTotalBonded = _globalBonded;\n    }\n\n    if (block.timestamp < epochStartTime) {\n      return 0;\n    }\n\n    if (epochStartTime + epochLength <= lastUpdateTime) {\n      return maltDataLab.realValueOfLPToken((state.cumulativeTotalBonded) / epochLength);\n    }\n\n    if (epochStartTime + epochLength < block.timestamp) {\n      // The desired epoch is in the past\n      diff = (epochStartTime + epochLength) - lastUpdateTime;\n    } else {\n      diff = block.timestamp - lastUpdateTime;\n      timeElapsed = block.timestamp - epochStartTime;\n    }\n\n    if (timeElapsed == 0) {\n      // Only way timeElapsed should == 0 is when block.timestamp == epochStartTime\n      // Therefore just return the lastTotalBonded value\n      return maltDataLab.realValueOfLPToken(lastTotalBonded);\n    }\n\n    uint256 endValue = state.cumulativeTotalBonded + (lastTotalBonded.mul(diff));\n    return maltDataLab.realValueOfLPToken((endValue) / timeElapsed);\n  }\n\n  function totalBonded() public view returns (uint256) {\n    return _globalBonded;\n  }\n\n  function balanceOfBonded(address account) public view returns (uint256) {\n    return userState[account].bonded;\n  }\n\n  function bondedEpoch(address account) public view returns (uint256) {\n    return userState[account].bondedEpoch;\n  }\n\n  function epochData(uint256 epoch) public view returns(uint256, uint256, uint256) {\n    return (epochState[epoch].lastTotalBonded, epochState[epoch].lastUpdateTime, epochState[epoch].cumulativeTotalBonded);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _balanceCheck() internal view {\n    require(stakeToken.balanceOf(address(this)) >= totalBonded(), \"Balance inconsistency\");\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _bond(address account, uint256 amount) internal {\n    stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n\n    _addToBonded(account, amount);\n\n    _balanceCheck();\n\n    emit Bond(account, amount);\n  }\n\n  function _unbond(uint256 amountLPToken) internal notSameBlock {\n    _removeFromBonded(msg.sender, amountLPToken, \"LP: Insufficient bonded balance\");\n\n    stakeToken.safeTransfer(msg.sender, amountLPToken);\n\n    _balanceCheck();\n\n    emit Unbond(msg.sender, amountLPToken);\n  }\n\n  function _unbondAndBreak(uint256 amountLPToken) internal notSameBlock {\n    _removeFromBonded(msg.sender, amountLPToken, \"LP: Insufficient bonded balance\");\n\n    stakeToken.safeTransfer(address(dexHandler), amountLPToken);\n\n    (uint256 amountMalt, uint256 amountReward) = dexHandler.removeLiquidity();\n\n    malt.safeTransfer(msg.sender, amountMalt);\n    rewardToken.safeTransfer(msg.sender, amountReward);\n\n    _balanceCheck();\n\n    emit UnbondAndBreak(msg.sender, amountLPToken, amountMalt, amountReward);\n  }\n\n  function _addToBonded(address account, uint256 amount) internal {\n    userState[account].bonded = userState[account].bonded.add(amount);\n\n    _updateEpochState(_globalBonded.add(amount));\n\n    if (userState[account].bondedEpoch == 0) {\n      userState[account].bondedEpoch = dao.epoch();\n    }\n  }\n\n  function _removeFromBonded(address account, uint256 amount, string memory reason) internal {\n    userState[account].bonded = userState[account].bonded.sub(amount, reason);\n\n    _updateEpochState(_globalBonded.sub(amount, reason));\n  }\n\n  function _updateEpochState(uint256 newTotalBonded) internal {\n    EpochState storage state = epochState[_currentEpoch];\n    uint256 epoch = dao.epoch();\n    uint256 epochStartTime = dao.getEpochStartTime(_currentEpoch);\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lengthOfEpoch = dao.epochLength();\n    uint256 epochEndTime = epochStartTime + lengthOfEpoch;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastUpdateTime > epochEndTime) {\n      lastUpdateTime = epochEndTime;\n    }\n\n    if (epoch == _currentEpoch) {\n      // We are still in the same epoch. Just update\n      uint256 finalTime = block.timestamp;\n      if (block.timestamp > epochEndTime) {\n        // We are past the end of the epoch so cap to end of epoch\n        finalTime = epochEndTime;\n      } \n\n      uint256 diff = finalTime - lastUpdateTime;\n\n      if (diff > 0) {\n        state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n\n        state.lastUpdateTime = finalTime;\n        state.lastTotalBonded = newTotalBonded;\n      }\n    } else {\n      // We have crossed at least 1 epoch boundary\n\n      // Won't underflow due to check on lastUpdateTime above\n      uint256 diff = epochEndTime - lastUpdateTime;\n\n      state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n      state.lastUpdateTime = epochEndTime;\n      state.lastTotalBonded = _globalBonded;\n\n      for (uint256 i = _currentEpoch + 1; i <= epoch; i += 1) {\n        state = epochState[i];\n        epochStartTime = dao.getEpochStartTime(i);\n        epochEndTime = epochStartTime + lengthOfEpoch;\n        state.lastTotalBonded = _globalBonded;\n\n        if (epochEndTime < block.timestamp) {\n          // The desired epoch is in the past\n          diff = lengthOfEpoch;\n          state.lastUpdateTime = epochEndTime;\n        } else {\n          diff = block.timestamp - epochStartTime;\n          state.lastUpdateTime = block.timestamp;\n        }\n\n        state.cumulativeTotalBonded = state.lastTotalBonded.mul(diff);\n      }\n\n      state.lastTotalBonded = newTotalBonded;\n      _currentEpoch = epoch;\n    } \n\n    _globalBonded = newTotalBonded;\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_miningService != address(0), \"Cannot set 0 address\");\n    miningService = IMiningService(_miningService);\n  }\n\n  function setDAO(address _dao)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_dao != address(0), \"Cannot set 0 address\");\n    dao = IDAO(_dao);\n  }\n\n  function setDexHandler(address _dexHandler)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_dexHandler != address(0), \"Cannot set 0 address\");\n    dexHandler = IDexHandler(_dexHandler);\n  }\n\n  function setCurrentEpoch(uint256 _epoch)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _currentEpoch = _epoch;\n  }\n}\n\n\n",
        "CodeNames": [
            "AbstractTransferVerification.sol",
            "AbstractRewardMine.sol",
            "IBurnMintableERC20.sol",
            "Bonding.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-15",
                "Location": [
                    "_balanceCheck",
                    "transfer()",
                    "balanceOf",
                    "transferFrom()",
                    "amount",
                    "_bond()",
                    "transfer"
                ],
                "Type": " Bonding doesn't work with fee-on transfer tokens",
                "Description": "\nCertain ERC20 tokens make modifications to their ERC20's transfer or balanceOf functions.\nOne type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom().\n\n\nThe Bonding._bond() function will revert in the _balanceCheck when transferring a fee-on-transfer token as it assumes the entire amount was received.\n\n",
                "Repair": "\nTo support fee-on-transfer tokens, measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/251)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/251#issuecomment-1019394195):\n  Agree with the finding, the check will revert on a token that takes fees as the system assumes that amount is the amount that will be received\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol",
            "AbstractRewardMine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-17",
                "Location": [
                    "require(collateralToken.balanceOf(address(this)) = amount, \"Insufficient balance\");",
                    "purchaseAndBurn(realCommitment)",
                    "collateralToken",
                    "purchaseAndBurn",
                    "purchaseAndBurn(amount)",
                    "purchaseArbitrageTokens",
                    "realCommitment"
                ],
                "Type": " Auction collateralToken won't work if token is fee-on-transfer token ",
                "Description": "\nThere are several ERC20 tokens that take a small fee on transfers/transferFroms (known as \"fee-on-transfer\" tokens). Most notably, USDT is an ERC20 token that has togglable transfer fees, but for now the fee is set to 0 (see the contract here: <https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7#code). For these tokens, it should not be assumed that if you transfer x tokens to an address, that the address actually receives x tokens. In the current test environment, DAI is the only collateralToken available, so there are no issues. However, it has been noted that more pools will be added in the future, so special care will need to be taken if fee-on-transfer tokens (like USDT) are planned to be used as collateralTokens.\n\nFor example, consider the function purchaseArbitrageTokens in Auction.sol. This function transfers realCommitment amount of collateralToken to the liquidityExtension, and then calls purchaseAndBurn(realCommitment) on the liquidityExtension. The very first line of purchaseAndBurn(amount) is require(collateralToken.balanceOf(address(this)) = amount, \"Insufficient balance\");. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken. This means that all calls to purchaseArbitrageTokens will fail, which would be very bad when the price goes below peg, since no one would be able to participate in this auction.\n\n\nSee purchaseArbitrageTokens here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177\n\nSee purchaseAndBurn here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L117\n\n\n",
                "Repair": "\nAdd logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with purchaseArbitrageTokens, instead of calling purchaseAndBurn with realCommitment, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/227)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/227#issuecomment-1019511655):\n  Agree with the finding, the system as a whole seem to not deal with feeOnTransfer Token\n Mitigation can be as simple as never using them, or refactoring to check for actual amounts received\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\n\n\n/// @title Auction Participant\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Will generally be inherited to give another contract the ability to use its capital to buy arbitrage tokens\ncontract AuctionParticipant is Permissions {\n  bytes32 public constant IMPLIED_COLLATERAL_SERVICE_ROLE = keccak256(\"IMPLIED_COLLATERAL_SERVICE_ROLE\");\n\n  IAuction public auction;\n  ERC20 public auctionRewardToken;\n\n  uint256 public replenishingIndex;\n  uint256[] public auctionIds;\n  uint256 public claimableRewards;\n\n  bool internal setupCompleted;\n\n  function setupParticipant(\n    address _impliedCollateralService,\n    address _rewardToken,\n    address _auction\n  ) public {\n    require(!setupCompleted, \"Can only call setup once\");\n\n    _roleSetup(IMPLIED_COLLATERAL_SERVICE_ROLE, _impliedCollateralService);\n    auctionRewardToken = ERC20(_rewardToken);\n    auction = IAuction(_auction);\n\n    setupCompleted = true;\n  }\n\n  function purchaseArbitrageTokens(uint256 maxAmount)\n    external\n    onlyRole(IMPLIED_COLLATERAL_SERVICE_ROLE, \"Must have implied collateral service privs\")\n    returns (uint256 remaining)\n  {\n    uint256 balance = usableBalance();\n\n    if (maxAmount < balance) {\n      balance = maxAmount;\n    }\n\n    uint256 currentAuction = auction.currentAuctionId();\n    \n    if (!auction.auctionActive(currentAuction)) {\n      return maxAmount;\n    }\n\n    auctionIds.push(currentAuction);\n\n    auctionRewardToken.approve(address(auction), balance);\n    auction.purchaseArbitrageTokens(balance);\n    \n    return maxAmount - balance;\n  }\n\n  function claim() external {\n    if (auctionIds.length == 0 || replenishingIndex >= auctionIds.length) {\n      return;\n    }\n\n    uint256 auctionId = auctionIds[replenishingIndex];\n    uint256 replenishingId = auction.replenishingAuctionId();\n\n    if (auctionId > replenishingId) {\n      // Not yet replenishing this auction\n      return;\n    }\n    uint256 claimableTokens = auction.userClaimableArbTokens(address(this), auctionId);\n\n    if (claimableTokens == 0) {\n      // Nothing to claim yet\n      return;\n    }\n\n    uint256 balance = auctionRewardToken.balanceOf(address(this));\n\n    auction.claimArbitrage(auctionId);\n\n    uint256 finalBalance = auctionRewardToken.balanceOf(address(this));\n    uint256 rewardedAmount = finalBalance - balance;\n\n    claimableRewards = claimableRewards.add(rewardedAmount);\n\n    uint256 claimable = auction.userClaimableArbTokens(address(this), auctionId);\n\n    if (replenishingId > auctionId && claimable == 0) {\n      // Don't increment replenishingIndex if replenishingAuctionId == auctionId as\n      // claimable could be 0 due to the debt not being 100% replenished.\n      replenishingIndex = replenishingIndex + 1;\n    }\n\n    _handleRewardDistribution(rewardedAmount);\n  }\n\n  function outstandingArbTokens() public view returns (uint256 outstanding) {\n    outstanding = 0;\n\n    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) {\n      uint256 claimable = auction.balanceOfArbTokens(\n        auctionIds[i],\n        address(this)\n      );\n\n      outstanding = outstanding + claimable;\n    }\n\n    return outstanding;\n  }\n\n  function getAllAuctionIds() public view returns (uint256[] memory) {\n    return auctionIds;\n  }\n\n  function usableBalance() virtual public view returns(uint256) {\n    return auctionRewardToken.balanceOf(address(this));\n  }\n\n  function _handleRewardDistribution(uint256 rewarded) virtual internal {\n    // Do nothing\n    return;\n  }\n\n  function setReplenishingIndex(uint256 _index)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_index > replenishingIndex, \"Cannot replenishingIndex to old value\");\n    replenishingIndex = _index;\n  }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol",
            "AuctionParticipant.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-18",
                "Location": [
                    "claim",
                    "currentAuction",
                    "purchaseArbitrageTokens",
                    "handleDeficit",
                    "auctionIds",
                    "replenishingIndex"
                ],
                "Type": " AuctionParticipant.sol:  purchaseArbitrageTokens  should not push duplicate auctions",
                "Description": "\nIn AuctionParticpant.sol, every time purchaseArbitrageTokens is called, the current auction is pushed to auctionIds. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the claim function would have issues with replenishingIndex.\n\nSpecifically, even if replenishingIndex was incremented once in claim, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set replenishingIndex (due to the if statement on lines 79-82 that does nothing if there is no claimable yield).\n\nIt is likely that purchaseArbitrageTokens would be called multiple times on the same auction. In fact, the commented out code for handleDeficit (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of replenishingIndex.\n\nNOTE: This is a separate issue from the one I just submitted previously relating to replenishingIndex. The previous issue was related to an edge case where replenishingIndex might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.\n\n\nSee code for purchaseArbitrageTokens here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L40\n\nNotice that currentAuction is always appended to auctionIds.\n\n\n",
                "Repair": "\nAdd a check to the function to purchaseArbitrageTokens to ensure that duplicate ids are not added. For example, this can be achieved by changing auctionIds to a mapping instead of an array.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/87)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/87#issuecomment-1019521510):\n  I agree with the finding, adding the same auctionId can lead to undefined behaviour. This can break claiming of incentives. Because of that, I think medium severity to be appropriate\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./AuctionParticipant.sol\";\nimport \"./AbstractRewardMine.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IBonding.sol\";\n\n\n/// @title LP Auction Pool\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A portion of above peg profit is directed here and the capital is deployed into arbitrage auctions when possible.\n/// @notice The core functionality is implemented in AuctionParticipant and AbstractRewardMine. But together they make new composite functionality.\ncontract AuctionPool is Initializable, AuctionParticipant, AbstractRewardMine {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  uint256 public forfeitedRewards;\n\n  IBonding public bonding;\n  address public forfeitDestination;\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _rewardToken,\n    address _auction,\n    address _impliedCollateralService,\n    address _bonding,\n    address _miningService,\n    address _forfeitDestination\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    bonding = IBonding(_bonding);\n\n    _initialSetup(_rewardToken, _miningService);\n\n    setupParticipant(\n      _impliedCollateralService,\n      _rewardToken,\n      _auction\n    );\n    forfeitDestination = _forfeitDestination;\n  }\n\n  function onUnbond(address account, uint256 amount)\n    override\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    _checkForForfeit(account, amount, bondedBalance);\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n  }\n\n  function totalBonded() override public view returns (uint256) {\n    return bonding.totalBonded();\n  }\n\n  function balanceOfBonded(address account) override public view returns (uint256) {\n    return bonding.balanceOfBonded(account);\n  }\n\n  function totalDeclaredReward() override public view returns (uint256) {\n    // Outstanding Arb tokens + the claimable arb tokens that have been redeemed\n    // minus rewards that have been forfeited\n    return outstandingArbTokens() + claimableRewards - forfeitedRewards;\n  }\n\n  function totalReleasedReward() override public view returns (uint256) {\n    return claimableRewards + _globalWithdrawn;\n  }\n\n  function usableBalance() override public view returns(uint256) {\n    uint256 totalBalance = auctionRewardToken.balanceOf(address(this));\n\n    if (totalBalance > claimableRewards) {\n      return totalBalance - claimableRewards;\n    }\n\n    return 0;\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _checkForForfeit(address account, uint256 amount, uint256 bondedBalance) internal {\n    // This is the user's share of total rewards\n    uint256 userReward = balanceOfRewards(account);\n    uint256 globalRewarded = totalDeclaredReward();\n\n    uint256 earnedReward = 0;\n    \n    // This is done inline instead of using earned() to save gas\n    if (globalRewarded > 0 && userReward > 0) {\n      earnedReward = totalReleasedReward().mul(userReward).div(globalRewarded);\n    }\n\n    uint256 forfeitAmount = userReward.sub(earnedReward).mul(amount) / bondedBalance;\n    uint256 declaredRewardDecrease = earnedReward.mul(amount) / bondedBalance;\n\n    if (forfeitAmount > 0) {\n      forfeitedRewards = forfeitedRewards + forfeitAmount;\n    }\n\n    if (declaredRewardDecrease > 0) {\n      claimableRewards = claimableRewards.sub(\n        declaredRewardDecrease\n      );\n    }\n  }\n\n  function _afterWithdraw(address account, uint256 amount) override internal {\n    claimableRewards = claimableRewards.sub(amount);\n  }\n\n  function _handleRewardDistribution(uint256 rewarded) override internal {\n    if (forfeitedRewards > 0) {\n      uint256 coverage;\n      // Need to pay down some of the forfeited amount\n      if (rewarded > forfeitedRewards) {\n        // Can cover everything\n        coverage = forfeitedRewards;\n      } else {\n        coverage = rewarded;\n      }\n\n      forfeitedRewards = forfeitedRewards - coverage;\n      claimableRewards = claimableRewards.sub(coverage);\n\n      rewardToken.safeTransfer(forfeitDestination, coverage);\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setBonding(address _bonding)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_bonding != address(0), \"Not zero address\");\n    bonding = IBonding(_bonding);\n  }\n\n  function setForfeitDestination(address _forfeitDestination)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_forfeitDestination != address(0), \"Not zero address\");\n    forfeitDestination = _forfeitDestination;\n  }\n}\n\n\n",
        "CodeNames": [
            "AuctionPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-19",
                "Location": [
                    "setBonding"
                ],
                "Type": " MiningService.setBonding should use BONDING role instead of REINVESTOR one",
                "Description": "\nBONDING_ROLE cannot be managed after it was initialized.\n\n\nsetBonding set the wrong role via _swapRole:\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L116\n\n",
                "Repair": "\nSet BONDING_ROLE instead of REINVESTOR_ROLE in setBonding function:\n\nNow:\nsolidity\nfunction setBonding(address _bonding)\n  public\n  onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n{\n  require(_bonding != address(0), \"Cannot use address 0\");\n  _swapRole(_bonding, bonding, REINVESTOR_ROLE);\n  bonding = _bonding;\n}\n\n\nTo be:\nsolidity\nfunction setBonding(address _bonding)\n  public\n  onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n{\n  require(_bonding != address(0), \"Cannot use address 0\");\n  _swapRole(_bonding, bonding, BONDING_ROLE);\n  bonding = _bonding;\n}\n\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/370)\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-20",
                "Location": [
                    "realCommitment",
                    "purchaseArbitrageTokens",
                    "purchased",
                    "purchaseAndBurn"
                ],
                "Type": " Users Can Contribute To An Auction Without Directly Committing Collateral Tokens",
                "Description": "\npurchaseArbitrageTokens enables users to commit collateral tokens and in return receive arbitrage tokens which are redeemable in the future for Malt tokens. Each auction specifies a commitment cap which when reached, prevents users from participating in the auction. However, realCommitment can be ignored by directly sending the LiquidityExtension contract collateral tokens and subsequently calling purchaseArbitrageTokens.\n\n\nConsider the following scenario:\n\n*   An auction is currently active.\n*   A user sends collateral tokens to the LiquidityExtension contract.\n*   The same user calls purchaseArbitrageTokens with amount 0.\n*   The purchaseAndBurn call returns a positive purchased amount which is subsequently used in auction calculations.\n\nAs a result, a user could effectively influence the average malt price used throughout the Auction contract.\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L177-L214\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117-L128\n\n",
                "Repair": "\nConsider adding a check to ensure that realCommitment != 0 in purchaseArbitrageTokens.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/188)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/188#issuecomment-1020112892):\n  The warden has identified a way to side-step the cap on commitments.\n Because the commitments are used for calculating limits, but maltPurchased is used to calculate rewards, an exploiter can effectively use an auction to purchase as many arbitrage tokens as they desire.\n \n Using any amount greater than zero will eventually allow to end the auction, however, by using 0 this process can be repeated continuously.\n \n Agree with the finding and severity\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IRewardThrottle.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ISwingTrader.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ISupplyDistributionController.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThreshold = (10**18) / 100; // 1%\n  uint256 public lowerStabilityThreshold = (10**18) / 100;\n  uint256 public maxContributionBps = 70;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistance = 20; // 2%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100;\n\n  uint256 public daoRewardCut;\n  uint256 public lpRewardCut = 417;\n  uint256 public auctionPoolRewardCut = 113;\n  uint256 public swingTraderRewardCut = 417;\n  uint256 public treasuryRewardCut = 50;\n  uint256 public callerRewardCut = 3;\n\n  uint256 public lastStabilize;\n\n  ERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  IDAO public dao;\n  address public uniswapV2Factory;\n  ILiquidityExtension public liquidityExtension;\n  IMaltDataLab public maltDataLab;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n  IRewardThrottle public rewardThrottle;\n  ISwingTrader public swingTrader;\n  IImpliedCollateralService public impliedCollateralService;\n\n  address payable public treasuryMultisig;\n  address public auctionPool;\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event RewardDistribution(uint256 rewarded);\n  event SetAnnualYield(uint256 yield);\n  event SetStabilizeBackoff(uint256 period);\n  event SetAuctionBurnSkew(address auctionBurnReserveSkew);\n  event SetRewardCut(uint256 daoCut, uint256 lpCut, uint256 callerCut, uint256 treasuryCut, uint256 auctionPoolCut, uint256 swingTraderCut);\n  event SetTreasury(address newTreasury);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetNewMaltDataLab(address dataLab);\n  event SetAuctionContract(address auction);\n  event SetDexHandler(address dexHandler);\n  event SetDao(address dao);\n  event SetLiquidityExtension(address liquidityExtension);\n  event SetRewardThrottle(address rewardThrottle);\n  event SetSwingTrader(address swingTrader);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetAuctionPool(address auctionPool);\n  event SetMaxContribution(uint256 maxContribution);\n  event SetImpliedCollateralService(address impliedCollateralService);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _rewardToken,\n    address _malt,\n    address _auction,\n    address _uniswapV2Factory,\n    address payable _treasuryMultisig,\n    address _auctionPool\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(AUCTION_ROLE, _auction);\n\n    rewardToken = ERC20(_rewardToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n\n    uniswapV2Factory = _uniswapV2Factory;\n    treasuryMultisig = _treasuryMultisig;\n    auctionPool = _auctionPool;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _dexHandler,\n    address _maltDataLab,\n    address _auctionBurnReserveSkew,\n    address _rewardThrottle,\n    address _dao,\n    address _swingTrader,\n    address _liquidityExtension,\n    address _impliedCollateralService\n  ) external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    dao = IDAO(_dao);\n    swingTrader = ISwingTrader(_swingTrader);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function stabilize() external notSameBlock {\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    rewardThrottle.checkRewardUnderflow();\n\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n\n    if (!_shouldAdjustSupply(exchangeRate)) {\n      maltDataLab.trackReserveRatio();\n\n      lastStabilize = block.timestamp;\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    if (exchangeRate > maltDataLab.priceTarget()) {\n      _distributeSupply();\n    } else {\n      _startAuction();\n    }\n\n    lastStabilize = block.timestamp;\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    if (hasRole(ADMIN_ROLE, _msgSender())) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = priceTarget.mul(1000 + overrideDistance).div(1000);\n    uint256 lowerThreshold = priceTarget.mul(1000 - overrideDistance).div(1000);\n\n    return exchangeRate <= lowerThreshold || exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {\n    uint256 decimals = rewardToken.decimals();\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);\n    uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);\n\n    return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _distributeSupply() internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController).check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTrader.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    uint256 rewards = dexHandler.sellMalt();\n\n    auctionBurnReserveSkew.addAbovePegObservation(tradeSize);\n\n    uint256 remaining = _replenishLiquidityExtension(rewards);\n\n    _distributeRewards(remaining);\n\n    maltDataLab.trackReserveRatio();\n    impliedCollateralService.claim();\n  }\n\n  function _distributeRewards(uint256 rewarded) internal {\n    if (rewarded == 0) {\n      return;\n    }\n    rewardToken.approve(address(auction), rewarded);\n    rewarded = auction.allocateArbRewards(rewarded);\n\n    if (rewarded == 0) {\n      return;\n    }\n\n    uint256 callerCut = rewarded.mul(callerRewardCut).div(1000);\n    uint256 lpCut = rewarded.mul(lpRewardCut).div(1000);\n    uint256 daoCut = rewarded.mul(daoRewardCut).div(1000);\n    uint256 auctionPoolCut = rewarded.mul(auctionPoolRewardCut).div(1000);\n    uint256 swingTraderCut = rewarded.mul(swingTraderRewardCut).div(1000);\n\n    // Treasury gets paid after everyone else\n    uint256 treasuryCut = rewarded - daoCut - lpCut - callerCut - auctionPoolCut - swingTraderCut;\n\n    assert(treasuryCut <= rewarded);\n\n    if (callerCut > 0) {\n      rewardToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    if (auctionPoolCut > 0) {\n      rewardToken.safeTransfer(auctionPool, auctionPoolCut);\n    }\n\n    if (swingTraderCut > 0) {\n      rewardToken.safeTransfer(address(swingTrader), swingTraderCut);\n    }\n\n    if (treasuryCut > 0) {\n      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);\n    }\n\n    if (daoCut > 0) {\n      rewardToken.safeTransfer(address(dao), daoCut);\n    }\n\n    if (lpCut > 0) {\n      rewardToken.safeTransfer(address(rewardThrottle), lpCut);\n      rewardThrottle.handleReward();\n    }\n\n    emit RewardDistribution(rewarded);\n  }\n\n  function _replenishLiquidityExtension(uint256 rewards) internal returns (uint256 remaining) {\n    if (liquidityExtension.hasMinimumReserves() || rewards == 0) {\n      return rewards;\n    }\n\n    (uint256 deficit,) = liquidityExtension.collateralDeficit();\n\n    uint256 maxContrib = rewards.mul(maxContributionBps).div(100);\n\n    if (deficit >= maxContrib) {\n      rewardToken.safeTransfer(address(liquidityExtension), maxContrib);\n      return rewards - maxContrib;\n    }\n\n    rewardToken.safeTransfer(address(liquidityExtension), deficit);\n\n    return rewards - deficit;\n  }\n\n  function _startAuction() internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount == 0) {\n      return;\n    }\n\n    uint256 decimals = rewardToken.decimals();\n\n    uint256 amountUsed = swingTrader.buyMalt(purchaseAmount);\n\n    purchaseAmount = purchaseAmount - amountUsed;\n\n    if (purchaseAmount < 10**decimals) {\n      return;\n    }\n\n    auction.triggerAuction(priceTarget, purchaseAmount);\n\n    malt.mint(msg.sender, defaultIncentive*10**18);\n    emit MintMalt(defaultIncentive*10**18);\n\n    auctionBurnReserveSkew.addBelowPegObservation(purchaseAmount);\n\n    maltDataLab.trackReserveRatio();\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setAuctionBurnSkew(address _auctionBurnReserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    emit SetAuctionBurnSkew(_auctionBurnReserveSkew);\n  }\n\n  function setRewardCut(\n    uint256 _daoCut,\n    uint256 _lpCut,\n    uint256 _callerCut,\n    uint256 _auctionPoolCut,\n    uint256 _swingTraderCut\n  )\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    uint256 sum = _daoCut.add(_lpCut).add(_callerCut).add(_auctionPoolCut).add(_swingTraderCut);\n    require(sum <= 1000, \"Reward cut must be <= 100%\");\n    daoRewardCut = _daoCut;\n    lpRewardCut = _lpCut;\n    callerRewardCut = _callerCut;\n    auctionPoolRewardCut = _auctionPoolCut;\n    swingTraderRewardCut = _swingTraderCut;\n    treasuryRewardCut = 1000 - sum;\n\n    emit SetRewardCut(_daoCut, _lpCut, _callerCut, treasuryRewardCut, _auctionPoolCut, _swingTraderCut);\n  }\n\n  function setTreasury(address payable _newTreasury)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    treasuryMultisig = _newTreasury;\n    emit SetTreasury(_newTreasury);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive > 0, \"No negative incentive\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setNewDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetNewMaltDataLab(_dataLab);\n  }\n\n  function setAuctionContract(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n\n    if (address(auction) != address(0)) {\n      revokeRole(AUCTION_ROLE, address(auction));\n    }\n\n    auction = IAuction(_auction);\n    _setupRole(AUCTION_ROLE, _auction);\n    emit SetAuctionContract(_auction);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper > 0 && _lower > 0, \"Must be above 0\");\n\n    upperStabilityThreshold = _upper;\n    lowerStabilityThreshold = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setAuctionPool(address _auctionPool)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auctionPool != address(0), \"Not address 0\");\n\n    auctionPool = _auctionPool;\n    emit SetAuctionPool(_auctionPool);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setMaxContribution(uint256 _maxContribution)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maxContribution > 0 && _maxContribution <= 100, \"Must be between 0 and 100\");\n\n    maxContributionBps = _maxContribution;\n    emit SetMaxContribution(_maxContribution);\n  }\n\n  function setDexHandler(address _dexHandler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dexHandler != address(0), \"Not address 0\");\n    dexHandler = IDexHandler(_dexHandler);\n    emit SetDexHandler(_dexHandler);\n  }\n\n  function setDao(address _dao)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dao != address(0), \"Not address 0\");\n    dao = IDAO(_dao);\n    emit SetDao(_dao);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Not address 0\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    emit SetLiquidityExtension(_liquidityExtension);\n  }\n\n  function setRewardThrottle(address _rewardThrottle)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_rewardThrottle != address(0), \"Not address 0\");\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    emit SetRewardThrottle(_rewardThrottle);\n  }\n\n  function setSwingTrader(address _swingTrader)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_swingTrader != address(0), \"Not address 0\");\n    swingTrader = ISwingTrader(_swingTrader);\n    emit SetSwingTrader(_swingTrader);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_impliedCollateralService != address(0), \"Not address 0\");\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    emit SetImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\");\n    overrideDistance = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol",
            "StabilizerNode.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-21",
                "Location": [
                    "auctionActive",
                    "_startAuction",
                    "auctionExists",
                    "stabilize",
                    "_shouldAdjustSupply",
                    "triggerAuction"
                ],
                "Type": "  StabilizerNode  Will Mint An Incentive For Triggering An Auction Even If An Auction Exists Already",
                "Description": "\n_startAuction utilises the SwingTrader contract to purchase Malt. If SwingTrader has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, no auction is triggered if the current auction exists, but msg.sender is still rewarded for their call to stabilize.\n\n\n_shouldAdjustSupply initially checks if the current auction is active, however, it does not check if the current auction exists. There is a key distinction between the auctionActive and auctionExists functions which are not used consistently. Hence, an auction which is inactive but exists would satisfy the edge case and result in triggerAuction simply returning.\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L382-L386\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L342-L344\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L873-L888\n\n\n",
                "Repair": "\nConsider using auctionExists and auctionActive consistently in StabilizerNode and Auction to ensure this edge case cannot be abused.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/191) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/191#issuecomment-1020125296):\n  The warden found a way to effectively mint free malt by spamming the caller incentive by abusing a specific edge case.\n\n\n\n\n"
            },
            {
                "Name": "M-24",
                "Location": [
                    "_distributeRewards",
                    "allocateArbRewards"
                ],
                "Type": "  _distributeRewards  Does Not Reset Approval If Not All Tokens Were Allocated",
                "Description": "\n_distributeRewards attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to Auction is made via the allocateArbRewards function. Prior to this call, the StabilizerNode approves the contract for a fixed amount of tokens, however, the allocateArbRewards function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the StabilizerNode contract.\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L252-L253\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L809-L871\n\n\n",
                "Repair": "\nConsider resetting the approval amount if the input rewarded amount to allocateArbRewards is less than the output amount.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/229) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/229#issuecomment-1020720987):\n  Finding is valid, incorrect approvals can cause reverts (USDT being an example), and not fully resetting will also negate gas refunds\n\n\n\n\n"
            },
            {
                "Name": "M-26",
                "Location": [
                    "_endAuction",
                    "stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod",
                    "purchaseAndBurn"
                ],
                "Type": " Dutch auction can be manipulated",
                "Description": "\nWhen malt is under-peg and the swing trader module do not have enough capital to buy back to peg, a Dutch auction is triggered to sell arb token. The price of the Dutch auction decrease linearly toward endprice until _endAuction() is called. <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L589\n\n_endAuction() is called in\n\n1.  When auction.commitments = auction.maxCommitments\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L212\n\n2.  On stabilize() - checkAuctionFinalization() - _checkAuctionFinalization()\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L146\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754\n\n3.  On stabilize() -_startAuction() - triggerAuction() - _checkAuctionFinalization()\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L170\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754\n\nIt is possible manipulate the dutch auction by preventing _endAuction() being called.\n\n\nConsider someone call purchaseArbitrageTokens with auction.maxCommitments minus 1 wei, _endAuction won't be called because auction.commitments < auction.maxCommitments. Further purchase would revert because purchaseAndBurn (<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L184) would likely revert since swapping 1 wei in most AMM will fail due to rounding error. Even if it does not revert, there is no incentive to waste gas to purchase 1 wei of token.\n\nAs such, the only way for the auction to finalize is to call stabilize().\nHowever, this is not immediately possible because it require\nblock.timestamp = stabilizeWindowEnd where\nstabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod\nstabilizeBackoffPeriod is initially set to 5 minutes in the contract\n\nAfter 5 minute, stabilize() can be called by anyone. By using this exploit, an attacker can guarantee he can purchase at (startingPrice+endingPrice)/2 or lower, given the default 10 minute auctionLength and 5 minute stabilizeBackoffPeriod. (unless a privileged user call stabilize() which override the stability window)\n\nAlso note that stabilize() might not be called since there is no incentive.\n\n",
                "Repair": "\n1.  Incentivize stabilize() or incentivize a permission-less call to _endAuction()\n2.  Lock-in auction price when user commit purchase\n\n\n0xScotch (sponsor) labeled(https://github.com/code-423n4/2021-11-malt-findings/issues/375) sponsor confirmed\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/375#issuecomment-1020758586):\n  By purchasing all but 1 wei of arbitrageTokens, any caller can guarantee that the auction will offer the steepest discount.\n \n This is caused by the fact that AMMs (esp UniV2) will revert with small numbers, as rounding will cause the amountOut to == 0 which will cause a INSUFFICIENT_AMOUNT revert.\n \n I agree with the pre-conditions and the possibility of this to happen.\n In a sense I believe this can become the meta strategy that every dutch auction participant will use (the fight between buyers will be done by paying gas to be the first few to buy arbitrageTokens).\n \n So the question is how to avoid it.\n I guess purchasing at a time should lock the price for that particular buyer at that particular time (adding a mapping should increase cost of 20k on write and a few thousand gas on read).\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/375#issuecomment-1020759031):\n  TODO: Decide on severity\n \n Medium for sure, extract value reliably.\n Is it high though? Arguably the dutch auction is not properly coded as it allows to get a further discount instead of locking in a price for the user at time of deposit\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/375#issuecomment-1022195290):\n  While an argument for the Dutch Auction being coded wrong (user locking in price) can be made, that's not the definition of a Dutch Auciton\n \n <img width=\"600\" alt=\"Screenshot 2022-01-26 at 14 16 34\" src=\"https://user-images.githubusercontent.com/13383782/151169628-a1d8e7e7-15c2-4064-a985-9f923154170a.png\"\n https://www.investopedia.com/terms/d/dutchauction.asp\n \n So arguably the dutch auction is properly coded, it's that there's a specific way to sidestep it which is caused by:\n 1 wei tx reverting on swap\n sum of purchases not being enough\n \n For this conditions to happen the \"exploiter\" needs to be fast enough to place an order, in such a way that their order will leave 1 commitment left.\n I can imagine them setting up a contract that reverts if this condition isn't met and that checks for w/e amount is needed at that time.\n \n I would assume that having an admin privileged function to close the auction prematurely would solve this specific attack.\n \n I believe that the warden has identified a fairly reliable way to get a discount from the protocol because of the impact and some of the technicalities I believe Medium Severity to be more appropriate.\n This will be exploited, but in doing so will make the protocol successful (all auction full minus 1 wei), the premium / discount will be reliable predicted (50% between start and end) and as such I believe it will be priced in\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Auction.sol\";\n\n\nstruct EarlyExitData {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n}\n\nstruct AuctionExits {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n  mapping(address => EarlyExitData) accountExits;\n}\n\n\n/// @title Auction Escape Hatch\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Functionality to reduce risk profile of holding arbitrage tokens by allowing early exit\ncontract AuctionEscapeHatch is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  uint256 public maxEarlyExitBps = 200; // 20%\n  uint256 public cooloffPeriod = 60 * 60 * 24; // 24 hours\n\n  mapping(uint256 => AuctionExits) internal auctionEarlyExits;\n\n  event EarlyExit(address account, uint256 amount, uint256 received);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    address _auction,\n    address _handler\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function exitEarly(uint256 _auctionId, uint256 amount, uint256 minOut) external notSameBlock {\n    uint256 maltQuantity = _calculateMaltRequiredForExit(_auctionId, amount);\n\n    // TODO ensure this contract is added as a mint requester Sat 06 Nov 2021 20:13:49 GMT\n    malt.mint(address(dexHandler), maltQuantity);\n    uint256 amountOut = dexHandler.sellMalt();\n\n    require(amountOut > minOut, \"EarlyExit: Insufficient output\");\n\n    AuctionExits storage auctionExits = auctionEarlyExits[_auctionId];\n\n    auctionExits.exitedEarly = auctionExits.exitedEarly + amount;\n    auctionExits.earlyExitReturn = auctionExits.earlyExitReturn + amountOut;\n    auctionExits.maltUsed = auctionExits.maltUsed + maltQuantity;\n    auctionExits.accountExits[msg.sender].exitedEarly = auctionExits.accountExits[msg.sender].exitedEarly + amount; \n    auctionExits.accountExits[msg.sender].earlyExitReturn = auctionExits.accountExits[msg.sender].earlyExitReturn + amountOut; \n    auctionExits.accountExits[msg.sender].maltUsed = auctionExits.accountExits[msg.sender].maltUsed + maltQuantity; \n\n    auction.amendAccountParticipation(\n      msg.sender,\n      _auctionId,\n      amount,\n      maltQuantity\n    );\n\n    collateralToken.safeTransfer(msg.sender, amountOut);\n    emit EarlyExit(msg.sender, amount, amountOut);\n  }\n\n  function earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    if(active || block.timestamp < auctionEndTime) {\n      return 0;\n    }\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(account, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    uint256 userOutstanding = userCommitment - userRedeemed;\n\n    if (amount > userOutstanding) {\n      amount = userOutstanding;\n    }\n\n    if (amount == 0) {\n      return 0;\n    }\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      return amount + maxProfit;\n    } \n\n    return fullReturn;\n  }\n\n  function accountAuctionExits(address account, uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    EarlyExitData storage accountExits = auctionEarlyExits[auctionId].accountExits[account];\n\n    return (accountExits.exitedEarly, accountExits.earlyExitReturn, accountExits.maltUsed);\n  }\n\n  function globalAuctionExits(uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    AuctionExits storage auctionExits = auctionEarlyExits[auctionId];\n\n    return (auctionExits.exitedEarly, auctionExits.earlyExitReturn, auctionExits.maltUsed);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    require(!active, \"Cannot exit early on an active auction\");\n    require(block.timestamp > auctionEndTime, \"Auction not over\");\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(msg.sender, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    if (amount > (userCommitment - userRedeemed)) {\n      amount = userCommitment - userRedeemed;\n    }\n\n    require(amount > 0, \"Nothing to claim\");\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      uint256 desiredReturn = amount + maxProfit;\n      maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;\n    } \n\n    return maltQuantity;\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setEarlyExitBps(uint256 _earlyExitBps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, \"Must be between 0-100%\");\n    maxEarlyExitBps = _earlyExitBps;\n  }\n\n  function setCooloffPeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_period > 0, \"Cannot have 0 lookback period\");\n    cooloffPeriod = _period;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n}\n\n\n",
        "CodeNames": [
            "AuctionEscapeHatch.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-22",
                "Location": [
                    "_calculateMaltRequiredForExit",
                    "exitEarly"
                ],
                "Type": "  _calculateMaltRequiredForExit  Uses Spot Price To Calculate Malt Quantity In  exitEarly ",
                "Description": "\n_calculateMaltRequiredForExit in AuctionEscapeHatch currently uses Malt's spot price to calculate the quantity to return to the exiting user. This spot price simply tracks the Uniswap pool's reserves which can easily be manipulated via a flash loan attack to extract funds from the protocol.\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L65-L92\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L193\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L80-L109\n<https://shouldiusespotpriceasmyoracle.com/\n\n\n",
                "Repair": "\nConsider implementing/integrating a TWAP oracle to track the price of Malt.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/215)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/215#issuecomment-1020710474):\n  I feel like this issue highlights the design challenge that the sponsor will have to solve, on one hand the protocol is meant to stabilize the price of malt in specific pools (impossible to block / control every pool due to permissionless nature).\n At the same time in order to determine which direction to move the price to, they need to refer to the pricing of the underlying pools (in this case a UniV2Pool, most likely from QuickSwap)\n \n Personally I understand the finding and think it's valid, however I don't believe there's easy answers as to how the sponsor should address this.\n \n Whenever there's excess value there will be entities trying to seize it and perhaps through such a harsh environment this protocol can truly find a way to be sustainable.\n \n That said, I'll mark the finding as valid, but believe this specific issue underlines the challenges that await the sponsor in making the protocol succesful\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IBonding.sol\";\nimport \"./interfaces/IMiningService.sol\";\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Reward Reinvestor\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Provide a way to programmatically reinvest Malt rewards\ncontract RewardReinvestor is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public stakeToken;\n\n  IDexHandler public dexHandler;\n  IBonding public bonding;\n  IMiningService public miningService;\n  address public treasury;\n\n  event ProvideReinvest(address account, uint256 reward);\n  event SplitReinvest(address account, uint256 amountReward);\n  event SetDexHandler(address dexHandler);\n  event SetBonding(address bonding);\n  event SetMiningService(address miningService);\n  event SetTreasury(address _treasury);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _dexHandler,\n    address _bonding,\n    address _miningService,\n    address _uniswapV2Factory,\n    address _treasury\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    dexHandler = IDexHandler(_dexHandler);\n    bonding = IBonding(_bonding);\n    miningService = IMiningService(_miningService);\n    treasury = _treasury;\n\n    stakeToken = ERC20(UniswapV2Library.pairFor(_uniswapV2Factory, _maltToken, _rewardToken));\n  }\n\n  function provideReinvest(uint256 rewardLiquidity) external {\n    _retrieveReward(rewardLiquidity);\n\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    // This is how much malt is required\n    uint256 maltLiquidity = dexHandler.getOptimalLiquidity(address(malt), address(rewardToken), rewardBalance);\n\n    // Transfer the remaining Malt required\n    malt.safeTransferFrom(msg.sender, address(this), maltLiquidity);\n\n    _bondAccount(msg.sender);\n\n    emit ProvideReinvest(msg.sender, rewardLiquidity);\n  }\n\n  function splitReinvest(uint256 rewardLiquidity) external {\n    _retrieveReward(rewardLiquidity);\n\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    rewardToken.safeTransfer(address(dexHandler), rewardBalance.div(2));\n\n    dexHandler.buyMalt();\n\n    _bondAccount(msg.sender);\n\n    emit SplitReinvest(msg.sender, rewardLiquidity);\n  }\n\n  function _retrieveReward(uint256 rewardLiquidity) internal {\n    require(rewardLiquidity > 0, \"Cannot reinvest 0\");\n\n    miningService.withdrawRewardsForAccount(\n      msg.sender,\n      rewardLiquidity\n    );\n  }\n\n  function _bondAccount(address account) internal {\n    malt.safeTransfer(address(dexHandler), malt.balanceOf(address(this)));\n    rewardToken.safeTransfer(address(dexHandler), rewardToken.balanceOf(address(this)));\n\n    (,,uint256 liquidityCreated) = dexHandler.addLiquidity();\n\n    stakeToken.approve(address(bonding), liquidityCreated);\n\n    bonding.bondToAccount(account, liquidityCreated);\n\n    // If there is any carry / left overs then send to treasury\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance > 0) {\n      malt.safeTransfer(treasury, maltBalance);\n    }\n\n    if (rewardTokenBalance > 0) {\n      rewardToken.safeTransfer(treasury, rewardTokenBalance);\n    }\n  }\n\n  function setDexHandler(address _dexHandler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dexHandler != address(0), \"Not address 0\");\n    dexHandler = IDexHandler(_dexHandler);\n    emit SetDexHandler(_dexHandler);\n  }\n\n  function setBonding(address _bonding)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_bonding != address(0), \"Not address 0\");\n    bonding = IBonding(_bonding);\n    emit SetBonding(_bonding);\n  }\n\n  function setMiningService(address _miningService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_miningService != address(0), \"Not address 0\");\n    miningService = IMiningService(_miningService);\n    emit SetMiningService(_miningService);\n  }\n\n  function setTreasury(address _treasury)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_treasury != address(0), \"Not address 0\");\n    treasury = _treasury;\n    emit SetTreasury(_treasury);\n  }\n}\n\n\n",
        "CodeNames": [
            "RewardReinvestor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-23",
                "Location": [
                    "addLiquidity"
                ],
                "Type": "  addLiquidity  Does Not Reset Approval If Not All Tokens Were Added To Liquidity Pool",
                "Description": "\naddLiquidity is called when users reinvest their tokens through bonding events. The RewardReinvestor first transfers Malt and rewards tokens before adding liquidity to the token pool. addLiquidity provides protections against slippage by a margin of 5%, and any dust token amounts are transferred back to the caller. In this instance, the caller is the RewardReinvestor contract which further distributes the dust token amounts to the protocol's treasury. However, the token approval for this outcome is not handled properly. Dust approval amounts can accrue over time, leading to large Uniswap approval amounts by the UniswapHandler contract.\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L212-L214\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L216-L218\n\n",
                "Repair": "\nConsider resetting the approval amount if either maltUsed < maltBalance or rewardUsed < rewardBalance in addLiquidity.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/228)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/228#issuecomment-1020718747):\n  The UniV2Router will first calculate the amounts(https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L71) and then pull them(https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L73) from the msg.sender\n \n This means that approvals may not be fully utilized, leaving traces of approvals here and there.\n This can cause issues with certain tokens (USDT comes to mind), and will also not trigger gas refunds.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/lib/contracts/libraries/FullMath.sol';\n\nimport \"../Permissions.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\n\n/// @title Uniswap Interaction Handler\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A simple contract to make interacting with UniswapV2 pools easier.\n/// @notice The buyMalt method is locked down to avoid circumventing recovery mode\n/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct\ncontract UniswapHandler is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant BUYER_ROLE = keccak256(\"BUYER_ROLE\");\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public lpToken;\n  IUniswapV2Router02 public router;\n  address public uniswapV2Factory;\n\n  address[] public buyers;\n  mapping(address => bool) public buyersActive;\n\n  event AddMaltBuyer(address buyer);\n  event RemoveMaltBuyer(address buyer);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _lpToken,\n    address _router,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    router = IUniswapV2Router02(_router);\n\n    lpToken = ERC20(_lpToken);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);\n  }\n\n  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);\n  }\n\n  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n  }\n\n  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n\n    if (maltReserves == 0 || rewardReserves == 0) {\n      price = 0;\n      decimals = 18;\n      return (price, decimals);\n    }\n\n    uint256 rewardDecimals = rewardToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));\n      decimals = rewardDecimals;\n    } else if (rewardDecimals < maltDecimals) {\n      uint256 diff = maltDecimals - rewardDecimals;\n      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n      decimals = maltDecimals;\n    } else {\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);\n      decimals = rewardDecimals;\n    }\n  }\n\n  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)\n    external view returns (uint256 liquidityA)\n  {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      tokenA,\n      tokenB\n    );\n\n    liquidityA = UniswapV2Library.quote(\n      liquidityB,\n      reservesB,\n      reservesA\n    );\n  }\n\n  /*\n   * MUTATION FUNCTIONS\n   */\n  function buyMalt()\n    external\n    onlyRole(BUYER_ROLE, \"Must have buyer privs\")\n    returns (uint256 purchased)\n  {\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (rewardBalance == 0) {\n      return 0;\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(rewardToken);\n    path[1] = address(malt);\n\n    router.swapExactTokensForTokens(\n      rewardBalance,\n      0, // amountOutMin\n      path,\n      address(this),\n      now\n    );\n\n    purchased = malt.balanceOf(address(this));\n    malt.safeTransfer(msg.sender, purchased);\n  }\n\n  function sellMalt() external returns (uint256 rewards) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (maltBalance == 0) {\n      return 0;\n    }\n\n    malt.approve(address(router), maltBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(malt);\n    path[1] = address(rewardToken);\n\n    router.swapExactTokensForTokens(\n      maltBalance,\n      0,\n      path,\n      address(this),\n      now\n    );\n\n    rewards = rewardToken.balanceOf(address(this));\n    rewardToken.safeTransfer(msg.sender, rewards);\n  }\n\n  function addLiquidity() external returns (\n    uint256 maltUsed,\n    uint256 rewardUsed,\n    uint256 liquidityCreated\n  ) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance == 0 || rewardBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n    malt.approve(address(router), maltBalance);\n\n    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT\n    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n      address(malt),\n      address(rewardToken),\n      maltBalance,\n      rewardBalance,\n      maltBalance.mul(95).div(100),\n      rewardBalance.mul(95).div(100),\n      msg.sender, // transfer LP tokens to sender\n      now\n    );\n\n    if (maltUsed < maltBalance) {\n      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));\n    }\n\n    if (rewardUsed < rewardBalance) {\n      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));\n    }\n  }\n\n  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {\n    uint256 liquidityBalance = lpToken.balanceOf(address(this));\n\n    if (liquidityBalance == 0) {\n      return (0, 0);\n    }\n\n    lpToken.approve(address(router), liquidityBalance);\n\n    (amountMalt, amountReward) = router.removeLiquidity(\n      address(malt),\n      address(rewardToken),\n      liquidityBalance,\n      0,\n      0,\n      msg.sender, // transfer broken LP tokens to sender\n      now\n    );\n\n    if (amountMalt == 0 || amountReward == 0) {\n      liquidityBalance = lpToken.balanceOf(address(this));\n      lpToken.safeTransfer(msg.sender, liquidityBalance);\n      return (amountMalt, amountReward);\n    }\n  }\n\n  /*\n   * PRIVATE METHODS\n   */\n  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {\n    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST\n    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      sellToken,\n      buyToken\n    );\n\n    uint256 invariant = sellReserves.mul(buyReserves);\n\n    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        priceTarget,\n        buyBase.div(priceTarget).mul(buyBase).mul(997)\n      )\n    );\n\n    uint256 rightSide = sellReserves.mul(1000).div(997);\n\n    if (leftSide < rightSide) return 0;\n\n    return leftSide.sub(rightSide);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function addNewBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    require(_buyer != address(0), \"Cannot use address 0\");\n\n    if (buyersActive[_buyer]) {\n      return;\n    }\n\n    buyersActive[_buyer] = true;\n    buyers.push(_buyer);\n\n    _setupRole(BUYER_ROLE, _buyer);\n\n    emit AddMaltBuyer(_buyer);\n  }\n\n  function removeBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    if (buyers.length == 0 || !buyersActive[_buyer]) {\n      return;\n    }\n\n    address buyer;\n    buyersActive[_buyer] = false;\n\n    emit RemoveMaltBuyer(_buyer);\n    revokeRole(BUYER_ROLE, _buyer);\n\n    // Loop until the second last element\n    for (uint i = 0; i < buyers.length - 1; i = i + 1) {\n      if (buyers[i] == _buyer) {\n        // Replace the current item with the last and pop the last away.\n        buyers[i] = buyers[buyers.length - 1];\n        buyers.pop();\n        return;\n      }\n    }\n\n    // If we made it here then the buyers being removed is the last item\n    buyers.pop();\n  }\n\n  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IRewardThrottle.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ISwingTrader.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ISupplyDistributionController.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThreshold = (10**18) / 100; // 1%\n  uint256 public lowerStabilityThreshold = (10**18) / 100;\n  uint256 public maxContributionBps = 70;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistance = 20; // 2%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100;\n\n  uint256 public daoRewardCut;\n  uint256 public lpRewardCut = 417;\n  uint256 public auctionPoolRewardCut = 113;\n  uint256 public swingTraderRewardCut = 417;\n  uint256 public treasuryRewardCut = 50;\n  uint256 public callerRewardCut = 3;\n\n  uint256 public lastStabilize;\n\n  ERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  IDAO public dao;\n  address public uniswapV2Factory;\n  ILiquidityExtension public liquidityExtension;\n  IMaltDataLab public maltDataLab;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n  IRewardThrottle public rewardThrottle;\n  ISwingTrader public swingTrader;\n  IImpliedCollateralService public impliedCollateralService;\n\n  address payable public treasuryMultisig;\n  address public auctionPool;\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event RewardDistribution(uint256 rewarded);\n  event SetAnnualYield(uint256 yield);\n  event SetStabilizeBackoff(uint256 period);\n  event SetAuctionBurnSkew(address auctionBurnReserveSkew);\n  event SetRewardCut(uint256 daoCut, uint256 lpCut, uint256 callerCut, uint256 treasuryCut, uint256 auctionPoolCut, uint256 swingTraderCut);\n  event SetTreasury(address newTreasury);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetNewMaltDataLab(address dataLab);\n  event SetAuctionContract(address auction);\n  event SetDexHandler(address dexHandler);\n  event SetDao(address dao);\n  event SetLiquidityExtension(address liquidityExtension);\n  event SetRewardThrottle(address rewardThrottle);\n  event SetSwingTrader(address swingTrader);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetAuctionPool(address auctionPool);\n  event SetMaxContribution(uint256 maxContribution);\n  event SetImpliedCollateralService(address impliedCollateralService);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _rewardToken,\n    address _malt,\n    address _auction,\n    address _uniswapV2Factory,\n    address payable _treasuryMultisig,\n    address _auctionPool\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(AUCTION_ROLE, _auction);\n\n    rewardToken = ERC20(_rewardToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n\n    uniswapV2Factory = _uniswapV2Factory;\n    treasuryMultisig = _treasuryMultisig;\n    auctionPool = _auctionPool;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _dexHandler,\n    address _maltDataLab,\n    address _auctionBurnReserveSkew,\n    address _rewardThrottle,\n    address _dao,\n    address _swingTrader,\n    address _liquidityExtension,\n    address _impliedCollateralService\n  ) external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    dao = IDAO(_dao);\n    swingTrader = ISwingTrader(_swingTrader);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function stabilize() external notSameBlock {\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    rewardThrottle.checkRewardUnderflow();\n\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n\n    if (!_shouldAdjustSupply(exchangeRate)) {\n      maltDataLab.trackReserveRatio();\n\n      lastStabilize = block.timestamp;\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    if (exchangeRate > maltDataLab.priceTarget()) {\n      _distributeSupply();\n    } else {\n      _startAuction();\n    }\n\n    lastStabilize = block.timestamp;\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    if (hasRole(ADMIN_ROLE, _msgSender())) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = priceTarget.mul(1000 + overrideDistance).div(1000);\n    uint256 lowerThreshold = priceTarget.mul(1000 - overrideDistance).div(1000);\n\n    return exchangeRate <= lowerThreshold || exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {\n    uint256 decimals = rewardToken.decimals();\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);\n    uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);\n\n    return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _distributeSupply() internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController).check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTrader.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    uint256 rewards = dexHandler.sellMalt();\n\n    auctionBurnReserveSkew.addAbovePegObservation(tradeSize);\n\n    uint256 remaining = _replenishLiquidityExtension(rewards);\n\n    _distributeRewards(remaining);\n\n    maltDataLab.trackReserveRatio();\n    impliedCollateralService.claim();\n  }\n\n  function _distributeRewards(uint256 rewarded) internal {\n    if (rewarded == 0) {\n      return;\n    }\n    rewardToken.approve(address(auction), rewarded);\n    rewarded = auction.allocateArbRewards(rewarded);\n\n    if (rewarded == 0) {\n      return;\n    }\n\n    uint256 callerCut = rewarded.mul(callerRewardCut).div(1000);\n    uint256 lpCut = rewarded.mul(lpRewardCut).div(1000);\n    uint256 daoCut = rewarded.mul(daoRewardCut).div(1000);\n    uint256 auctionPoolCut = rewarded.mul(auctionPoolRewardCut).div(1000);\n    uint256 swingTraderCut = rewarded.mul(swingTraderRewardCut).div(1000);\n\n    // Treasury gets paid after everyone else\n    uint256 treasuryCut = rewarded - daoCut - lpCut - callerCut - auctionPoolCut - swingTraderCut;\n\n    assert(treasuryCut <= rewarded);\n\n    if (callerCut > 0) {\n      rewardToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    if (auctionPoolCut > 0) {\n      rewardToken.safeTransfer(auctionPool, auctionPoolCut);\n    }\n\n    if (swingTraderCut > 0) {\n      rewardToken.safeTransfer(address(swingTrader), swingTraderCut);\n    }\n\n    if (treasuryCut > 0) {\n      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);\n    }\n\n    if (daoCut > 0) {\n      rewardToken.safeTransfer(address(dao), daoCut);\n    }\n\n    if (lpCut > 0) {\n      rewardToken.safeTransfer(address(rewardThrottle), lpCut);\n      rewardThrottle.handleReward();\n    }\n\n    emit RewardDistribution(rewarded);\n  }\n\n  function _replenishLiquidityExtension(uint256 rewards) internal returns (uint256 remaining) {\n    if (liquidityExtension.hasMinimumReserves() || rewards == 0) {\n      return rewards;\n    }\n\n    (uint256 deficit,) = liquidityExtension.collateralDeficit();\n\n    uint256 maxContrib = rewards.mul(maxContributionBps).div(100);\n\n    if (deficit >= maxContrib) {\n      rewardToken.safeTransfer(address(liquidityExtension), maxContrib);\n      return rewards - maxContrib;\n    }\n\n    rewardToken.safeTransfer(address(liquidityExtension), deficit);\n\n    return rewards - deficit;\n  }\n\n  function _startAuction() internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount == 0) {\n      return;\n    }\n\n    uint256 decimals = rewardToken.decimals();\n\n    uint256 amountUsed = swingTrader.buyMalt(purchaseAmount);\n\n    purchaseAmount = purchaseAmount - amountUsed;\n\n    if (purchaseAmount < 10**decimals) {\n      return;\n    }\n\n    auction.triggerAuction(priceTarget, purchaseAmount);\n\n    malt.mint(msg.sender, defaultIncentive*10**18);\n    emit MintMalt(defaultIncentive*10**18);\n\n    auctionBurnReserveSkew.addBelowPegObservation(purchaseAmount);\n\n    maltDataLab.trackReserveRatio();\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setAuctionBurnSkew(address _auctionBurnReserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    emit SetAuctionBurnSkew(_auctionBurnReserveSkew);\n  }\n\n  function setRewardCut(\n    uint256 _daoCut,\n    uint256 _lpCut,\n    uint256 _callerCut,\n    uint256 _auctionPoolCut,\n    uint256 _swingTraderCut\n  )\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    uint256 sum = _daoCut.add(_lpCut).add(_callerCut).add(_auctionPoolCut).add(_swingTraderCut);\n    require(sum <= 1000, \"Reward cut must be <= 100%\");\n    daoRewardCut = _daoCut;\n    lpRewardCut = _lpCut;\n    callerRewardCut = _callerCut;\n    auctionPoolRewardCut = _auctionPoolCut;\n    swingTraderRewardCut = _swingTraderCut;\n    treasuryRewardCut = 1000 - sum;\n\n    emit SetRewardCut(_daoCut, _lpCut, _callerCut, treasuryRewardCut, _auctionPoolCut, _swingTraderCut);\n  }\n\n  function setTreasury(address payable _newTreasury)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    treasuryMultisig = _newTreasury;\n    emit SetTreasury(_newTreasury);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive > 0, \"No negative incentive\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setNewDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetNewMaltDataLab(_dataLab);\n  }\n\n  function setAuctionContract(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n\n    if (address(auction) != address(0)) {\n      revokeRole(AUCTION_ROLE, address(auction));\n    }\n\n    auction = IAuction(_auction);\n    _setupRole(AUCTION_ROLE, _auction);\n    emit SetAuctionContract(_auction);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper > 0 && _lower > 0, \"Must be above 0\");\n\n    upperStabilityThreshold = _upper;\n    lowerStabilityThreshold = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setAuctionPool(address _auctionPool)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auctionPool != address(0), \"Not address 0\");\n\n    auctionPool = _auctionPool;\n    emit SetAuctionPool(_auctionPool);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setMaxContribution(uint256 _maxContribution)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maxContribution > 0 && _maxContribution <= 100, \"Must be between 0 and 100\");\n\n    maxContributionBps = _maxContribution;\n    emit SetMaxContribution(_maxContribution);\n  }\n\n  function setDexHandler(address _dexHandler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dexHandler != address(0), \"Not address 0\");\n    dexHandler = IDexHandler(_dexHandler);\n    emit SetDexHandler(_dexHandler);\n  }\n\n  function setDao(address _dao)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dao != address(0), \"Not address 0\");\n    dao = IDAO(_dao);\n    emit SetDao(_dao);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Not address 0\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    emit SetLiquidityExtension(_liquidityExtension);\n  }\n\n  function setRewardThrottle(address _rewardThrottle)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_rewardThrottle != address(0), \"Not address 0\");\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    emit SetRewardThrottle(_rewardThrottle);\n  }\n\n  function setSwingTrader(address _swingTrader)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_swingTrader != address(0), \"Not address 0\");\n    swingTrader = ISwingTrader(_swingTrader);\n    emit SetSwingTrader(_swingTrader);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_impliedCollateralService != address(0), \"Not address 0\");\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    emit SetImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\");\n    overrideDistance = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapHandler.sol",
            "Auction.sol",
            "StabilizerNode.sol",
            "AbstractRewardMine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-25",
                "Location": [
                    "rewardToken",
                    "_distributeSupply",
                    "_calculateTradeSize",
                    "stabilize"
                ],
                "Type": " AMM pool can be drained using a flashloan and calling  stabilize ",
                "Description": "\nAll of the rewardToken in a given AMM pool can be removed from the AMM pool and distributed as LP rewards.\n\n\nIn the stabilize method in the StabilizerNode the initial check to see if the Malt price needs to be stabilized it uses a short period TWAP:\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156\n\nHowever, if the price is above the threshold for stabilization then the trade size required to stabilize looks at the AMM pool directly which is vulnerable to flashloan manipulation.\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L250-L275\n\nAttack:\n\n1.  Wait for TWAP to rise above the stabilization threshold\n2.  Flashloan remove all but a tiny amount of Malt from the pool.\n3.  Call stabilize. This will pass the TWAP check and execute _distributeSupply which in turn ultimately calls _calculateTradeSize in the UniswapHandler. This calculation will determine that almost all of the rewardToken needs to be removed from the pool to return the price to peg.\n4.  Malt will mint enough Malt to remove a lot of the rewardToken from the pool.\n5.  The protocol will now distribute that received rewardToken as rewards. 0.3% of which goes directly to the attacker and the rest goes to LP rewards, swing trader and the treasury.\n\nThe amount of money that can be directly stolen by a malicious actor is small but it can cause a lot of pain for the protocol as the pool will be destroyed and confusion around rewards will be created.\n\n",
                "Repair": "\nUse a short TWAP to calculate the trade size instead of reading directly from the pool.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/372) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/372#issuecomment-1020734907):\n  I believe the warden has identified a valid grief and potential exploit\n \n I'm not convinced on the simplicity of:\n 2. Flashloan remove all but a tiny amount of Malt from the pool.\n \n You'd have to buy that liquidity in order to be able to remove the malt, which effectively makes the operation not as straightforward (if not unprofitable for the attacker).\n \n I do believe the grief can be performed but in lack of a clear incentive for the attacker, am going to downgrade to Medium Severity.\n Can be done, but not clear on the incentives\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/lib/contracts/libraries/FullMath.sol';\n\nimport \"../Permissions.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\n\n/// @title Uniswap Interaction Handler\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A simple contract to make interacting with UniswapV2 pools easier.\n/// @notice The buyMalt method is locked down to avoid circumventing recovery mode\n/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct\ncontract UniswapHandler is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant BUYER_ROLE = keccak256(\"BUYER_ROLE\");\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public lpToken;\n  IUniswapV2Router02 public router;\n  address public uniswapV2Factory;\n\n  address[] public buyers;\n  mapping(address => bool) public buyersActive;\n\n  event AddMaltBuyer(address buyer);\n  event RemoveMaltBuyer(address buyer);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _lpToken,\n    address _router,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    router = IUniswapV2Router02(_router);\n\n    lpToken = ERC20(_lpToken);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);\n  }\n\n  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);\n  }\n\n  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n  }\n\n  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n\n    if (maltReserves == 0 || rewardReserves == 0) {\n      price = 0;\n      decimals = 18;\n      return (price, decimals);\n    }\n\n    uint256 rewardDecimals = rewardToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));\n      decimals = rewardDecimals;\n    } else if (rewardDecimals < maltDecimals) {\n      uint256 diff = maltDecimals - rewardDecimals;\n      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n      decimals = maltDecimals;\n    } else {\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);\n      decimals = rewardDecimals;\n    }\n  }\n\n  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)\n    external view returns (uint256 liquidityA)\n  {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      tokenA,\n      tokenB\n    );\n\n    liquidityA = UniswapV2Library.quote(\n      liquidityB,\n      reservesB,\n      reservesA\n    );\n  }\n\n  /*\n   * MUTATION FUNCTIONS\n   */\n  function buyMalt()\n    external\n    onlyRole(BUYER_ROLE, \"Must have buyer privs\")\n    returns (uint256 purchased)\n  {\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (rewardBalance == 0) {\n      return 0;\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(rewardToken);\n    path[1] = address(malt);\n\n    router.swapExactTokensForTokens(\n      rewardBalance,\n      0, // amountOutMin\n      path,\n      address(this),\n      now\n    );\n\n    purchased = malt.balanceOf(address(this));\n    malt.safeTransfer(msg.sender, purchased);\n  }\n\n  function sellMalt() external returns (uint256 rewards) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (maltBalance == 0) {\n      return 0;\n    }\n\n    malt.approve(address(router), maltBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(malt);\n    path[1] = address(rewardToken);\n\n    router.swapExactTokensForTokens(\n      maltBalance,\n      0,\n      path,\n      address(this),\n      now\n    );\n\n    rewards = rewardToken.balanceOf(address(this));\n    rewardToken.safeTransfer(msg.sender, rewards);\n  }\n\n  function addLiquidity() external returns (\n    uint256 maltUsed,\n    uint256 rewardUsed,\n    uint256 liquidityCreated\n  ) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance == 0 || rewardBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n    malt.approve(address(router), maltBalance);\n\n    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT\n    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n      address(malt),\n      address(rewardToken),\n      maltBalance,\n      rewardBalance,\n      maltBalance.mul(95).div(100),\n      rewardBalance.mul(95).div(100),\n      msg.sender, // transfer LP tokens to sender\n      now\n    );\n\n    if (maltUsed < maltBalance) {\n      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));\n    }\n\n    if (rewardUsed < rewardBalance) {\n      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));\n    }\n  }\n\n  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {\n    uint256 liquidityBalance = lpToken.balanceOf(address(this));\n\n    if (liquidityBalance == 0) {\n      return (0, 0);\n    }\n\n    lpToken.approve(address(router), liquidityBalance);\n\n    (amountMalt, amountReward) = router.removeLiquidity(\n      address(malt),\n      address(rewardToken),\n      liquidityBalance,\n      0,\n      0,\n      msg.sender, // transfer broken LP tokens to sender\n      now\n    );\n\n    if (amountMalt == 0 || amountReward == 0) {\n      liquidityBalance = lpToken.balanceOf(address(this));\n      lpToken.safeTransfer(msg.sender, liquidityBalance);\n      return (amountMalt, amountReward);\n    }\n  }\n\n  /*\n   * PRIVATE METHODS\n   */\n  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {\n    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST\n    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      sellToken,\n      buyToken\n    );\n\n    uint256 invariant = sellReserves.mul(buyReserves);\n\n    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        priceTarget,\n        buyBase.div(priceTarget).mul(buyBase).mul(997)\n      )\n    );\n\n    uint256 rightSide = sellReserves.mul(1000).div(997);\n\n    if (leftSide < rightSide) return 0;\n\n    return leftSide.sub(rightSide);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function addNewBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    require(_buyer != address(0), \"Cannot use address 0\");\n\n    if (buyersActive[_buyer]) {\n      return;\n    }\n\n    buyersActive[_buyer] = true;\n    buyers.push(_buyer);\n\n    _setupRole(BUYER_ROLE, _buyer);\n\n    emit AddMaltBuyer(_buyer);\n  }\n\n  function removeBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    if (buyers.length == 0 || !buyersActive[_buyer]) {\n      return;\n    }\n\n    address buyer;\n    buyersActive[_buyer] = false;\n\n    emit RemoveMaltBuyer(_buyer);\n    revokeRole(BUYER_ROLE, _buyer);\n\n    // Loop until the second last element\n    for (uint i = 0; i < buyers.length - 1; i = i + 1) {\n      if (buyers[i] == _buyer) {\n        // Replace the current item with the last and pop the last away.\n        buyers[i] = buyers[buyers.length - 1];\n        buyers.pop();\n        return;\n      }\n    }\n\n    // If we made it here then the buyers being removed is the last item\n    buyers.pop();\n  }\n\n  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST\n}\n\n\n",
        "CodeNames": [
            "UniswapHandler.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-27",
                "Location": [
                    "//solidity\n(maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n  address(malt),\n  address(rewardToken),\n  maltBalance, // @audit-info amountADesired\n  rewardBalance,\n  // @audit assumes that whatever is in this contract is already balanced. good assumption?\n  maltBalance.mul(95).div(100), // @audit-info amountAMin\n  rewardBalance.mul(95).div(100),\n  msg.sender, // transfer LP tokens to sender\n  now\n);\n"
                ],
                "Type": " Slippage checks when adding liquidity are too strict",
                "Description": "\nWhen adding liquidity through UniswapHandler.addLiquidity, the entire contract balances are used to add liquidity and the min amounts are set to 95% of these balances.\nIf the balances in this contract are unbalanced (the ratio is not similar to the current Uniswap pool reserve ratios) then this function will revert and no liquidity is added.\n\nSee UniswapHandler.buyMalt:\n\nsolidity\n(maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n  address(malt),\n  address(rewardToken),\n  maltBalance, // @audit-info amountADesired\n  rewardBalance,\n  // @audit assumes that whatever is in this contract is already balanced. good assumption?\n  maltBalance.mul(95).div(100), // @audit-info amountAMin\n  rewardBalance.mul(95).div(100),\n  msg.sender, // transfer LP tokens to sender\n  now\n);\n\n\n\nIf the contract has unbalanced balances, then the router.addLiquidity call will revert.\nNote that an attacker could even send tokens to this contract to make them unbalanced and revert, resulting in a griefing attack.\n\n",
                "Repair": "\nIt needs to be ensured that the balances in the contract are always balanced and match the current reserve ratio.\nIt might be better to avoid directly using the balances which can be manipulated by transferring tokens to the contract and accepting parameters instead of how many tokens to provide liquidity with from the caller side.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/257)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/257#issuecomment-1022202079):\n  Interestingly the warden highlights the other side of the \"missing slippage check\" argument.\n Slippage checks in general need to be calculated offChain (as you will get frontrun in the mempool, so the slippage check is a risk minimization tool more than anything else)\n \n The warden also specified a griefing attack that can be used because of the hardcoded check.\n The sponsor confirms, I think medium severity is appropriate\n\n\n\n"
            },
            {
                "Name": "M-29",
                "Location": [
                    "swapExactTokensForTokens(amountDai,"
                ],
                "Type": " User can bypass Recovery Mode via UniswapHandler to buy Malt ",
                "Description": "\nOne of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler, and then extract the token by abusing the add and remove liquidity function. This is considered a high severity issue because it undermine to protocol's ability to generate profit by the privileged role as designed and allow potential risk-free MEV.\n\n\n1.  User swap dai into malt and send malt directly to uniswapHandler, this is possible becuase uniswapHandler is whitelisted\n\nswapExactTokensForTokens(amountDai, 0, dai.address, malt.address], uniswapHandler.address, new Date().getTime() + 10000);\n2) User send matching amount of dai to uniswapHandler\n3) User call addLiquidity() and get back LP token\n4) User call removeLiquidity() and get back both dai and malt\n\n",
                "Repair": "\nAccording to documentation in <https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol\n\n Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.\n\n, this should be exploitable. Meanwhile the current implementation did not actually allow remove liquidity during recovery mode (refer to issue \"Unable to remove liquidity in Recovery Mode\")\nThis exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/325)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/325#issuecomment-1020752336):\n  The Malt token is programmed to explicitly prevent buying it when at discount.\n However, because addLiquidity and removeLiquidity are callable by anyone, and the UniswapHandler is whitelisted, through a calculated addition and removal of liquidity anyone can mimick buying Malt for a discount (by providing imbalanced underlying and redeeming them).\n \n I believe this sidesteps the majority of the functionality of the protocol, and while the attack is fairly simple, it denies the protocol functionality and as such agree with a High Severity\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/325#issuecomment-1025167069):\n  After re-review:\n Addressing each step:\n \n 1) The swap can be done as the whitelisting is bypassed (so finding is valid on that end)\n 2) User can send more liquidity\n 3) User can add liquidity at discount (as they bought at discount) (notice that this subjects them to potentially more IL so arguably the MEV extraction happened at step 1)\n 4) This cannot be done because of #323 which was found by the same warden. As per #323 you can't remove liquidity as the transfer will be from pool to user and as such will be reverted due to the system being in recovery mode.\n \n I believe that the warden identified a way to sidestep purchasing malt via purchase - send to UniswapHandler - add liquidity which should allow for some MEV extraction (with the user risking IL as they assume malt will go back to peg)\n \n Because of this there's still some validity to the finding, but it's not as dire as I originally believed.\n \n I'm going to downgrade the finding to Medium Severity as:\n 1) Value can be extracted\n 2) by bypassing the check for buying malt\n \n But this doesn't allow the selling of malt, so it's not a protocol breaking exploit but rather a way to gain MEV.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/lib/contracts/libraries/FullMath.sol';\n\nimport \"../Permissions.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\n\n/// @title Uniswap Interaction Handler\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A simple contract to make interacting with UniswapV2 pools easier.\n/// @notice The buyMalt method is locked down to avoid circumventing recovery mode\n/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct\ncontract UniswapHandler is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant BUYER_ROLE = keccak256(\"BUYER_ROLE\");\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public lpToken;\n  IUniswapV2Router02 public router;\n  address public uniswapV2Factory;\n\n  address[] public buyers;\n  mapping(address => bool) public buyersActive;\n\n  event AddMaltBuyer(address buyer);\n  event RemoveMaltBuyer(address buyer);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _lpToken,\n    address _router,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    router = IUniswapV2Router02(_router);\n\n    lpToken = ERC20(_lpToken);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);\n  }\n\n  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);\n  }\n\n  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n  }\n\n  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n\n    if (maltReserves == 0 || rewardReserves == 0) {\n      price = 0;\n      decimals = 18;\n      return (price, decimals);\n    }\n\n    uint256 rewardDecimals = rewardToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));\n      decimals = rewardDecimals;\n    } else if (rewardDecimals < maltDecimals) {\n      uint256 diff = maltDecimals - rewardDecimals;\n      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n      decimals = maltDecimals;\n    } else {\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);\n      decimals = rewardDecimals;\n    }\n  }\n\n  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)\n    external view returns (uint256 liquidityA)\n  {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      tokenA,\n      tokenB\n    );\n\n    liquidityA = UniswapV2Library.quote(\n      liquidityB,\n      reservesB,\n      reservesA\n    );\n  }\n\n  /*\n   * MUTATION FUNCTIONS\n   */\n  function buyMalt()\n    external\n    onlyRole(BUYER_ROLE, \"Must have buyer privs\")\n    returns (uint256 purchased)\n  {\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (rewardBalance == 0) {\n      return 0;\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(rewardToken);\n    path[1] = address(malt);\n\n    router.swapExactTokensForTokens(\n      rewardBalance,\n      0, // amountOutMin\n      path,\n      address(this),\n      now\n    );\n\n    purchased = malt.balanceOf(address(this));\n    malt.safeTransfer(msg.sender, purchased);\n  }\n\n  function sellMalt() external returns (uint256 rewards) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (maltBalance == 0) {\n      return 0;\n    }\n\n    malt.approve(address(router), maltBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(malt);\n    path[1] = address(rewardToken);\n\n    router.swapExactTokensForTokens(\n      maltBalance,\n      0,\n      path,\n      address(this),\n      now\n    );\n\n    rewards = rewardToken.balanceOf(address(this));\n    rewardToken.safeTransfer(msg.sender, rewards);\n  }\n\n  function addLiquidity() external returns (\n    uint256 maltUsed,\n    uint256 rewardUsed,\n    uint256 liquidityCreated\n  ) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance == 0 || rewardBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n    malt.approve(address(router), maltBalance);\n\n    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT\n    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n      address(malt),\n      address(rewardToken),\n      maltBalance,\n      rewardBalance,\n      maltBalance.mul(95).div(100),\n      rewardBalance.mul(95).div(100),\n      msg.sender, // transfer LP tokens to sender\n      now\n    );\n\n    if (maltUsed < maltBalance) {\n      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));\n    }\n\n    if (rewardUsed < rewardBalance) {\n      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));\n    }\n  }\n\n  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {\n    uint256 liquidityBalance = lpToken.balanceOf(address(this));\n\n    if (liquidityBalance == 0) {\n      return (0, 0);\n    }\n\n    lpToken.approve(address(router), liquidityBalance);\n\n    (amountMalt, amountReward) = router.removeLiquidity(\n      address(malt),\n      address(rewardToken),\n      liquidityBalance,\n      0,\n      0,\n      msg.sender, // transfer broken LP tokens to sender\n      now\n    );\n\n    if (amountMalt == 0 || amountReward == 0) {\n      liquidityBalance = lpToken.balanceOf(address(this));\n      lpToken.safeTransfer(msg.sender, liquidityBalance);\n      return (amountMalt, amountReward);\n    }\n  }\n\n  /*\n   * PRIVATE METHODS\n   */\n  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {\n    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST\n    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      sellToken,\n      buyToken\n    );\n\n    uint256 invariant = sellReserves.mul(buyReserves);\n\n    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        priceTarget,\n        buyBase.div(priceTarget).mul(buyBase).mul(997)\n      )\n    );\n\n    uint256 rightSide = sellReserves.mul(1000).div(997);\n\n    if (leftSide < rightSide) return 0;\n\n    return leftSide.sub(rightSide);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function addNewBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    require(_buyer != address(0), \"Cannot use address 0\");\n\n    if (buyersActive[_buyer]) {\n      return;\n    }\n\n    buyersActive[_buyer] = true;\n    buyers.push(_buyer);\n\n    _setupRole(BUYER_ROLE, _buyer);\n\n    emit AddMaltBuyer(_buyer);\n  }\n\n  function removeBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    if (buyers.length == 0 || !buyersActive[_buyer]) {\n      return;\n    }\n\n    address buyer;\n    buyersActive[_buyer] = false;\n\n    emit RemoveMaltBuyer(_buyer);\n    revokeRole(BUYER_ROLE, _buyer);\n\n    // Loop until the second last element\n    for (uint i = 0; i < buyers.length - 1; i = i + 1) {\n      if (buyers[i] == _buyer) {\n        // Replace the current item with the last and pop the last away.\n        buyers[i] = buyers[buyers.length - 1];\n        buyers.pop();\n        return;\n      }\n    }\n\n    // If we made it here then the buyers being removed is the last item\n    buyers.pop();\n  }\n\n  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IMiningService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\n\nimport \"./Permissions.sol\";\n\n\nstruct UserState {\n  uint256 bonded;\n\n  // TODO calculate average bonded period for log calc Tue 03 Aug 2021 11:22:39 BST\n  uint256 bondedEpoch;\n}\n\nstruct EpochState {\n  uint256 lastTotalBonded;\n  uint256 lastUpdateTime;\n  uint256 cumulativeTotalBonded;\n}\n\n\n/// @title LP Bonding\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract which LP tokens are bonded to to make a user eligible for protocol rewards\ncontract Bonding is Initializable, Permissions {\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public stakeToken;\n  IDAO public dao;\n  IMiningService public miningService;\n  IDexHandler public dexHandler;\n  IMaltDataLab public maltDataLab;\n\n  uint256 internal _globalBonded;\n  uint256 internal _currentEpoch;\n  address internal offering;\n  mapping(address => UserState) internal userState;\n  mapping(uint256 => EpochState) internal epochState;\n\n  event Bond(address indexed account, uint256 value);\n  event Unbond(address indexed account, uint256 value);\n  event UnbondAndBreak(address indexed account, uint256 amountLPToken, uint256 amountMalt, uint256 amountReward);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    address _dao,\n    address _miningService,\n    address _offering,\n    address _dexHandler,\n    address _maltDataLab\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    dao = IDAO(_dao);\n    offering = _offering;\n    stakeToken = ERC20(_stakeToken);\n    miningService = IMiningService(_miningService);\n    dexHandler = IDexHandler(_dexHandler);\n    malt = ERC20(_malt);\n    rewardToken = ERC20(_rewardToken);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n  }\n\n  function bond(uint256 amount) external {\n    bondToAccount(msg.sender, amount);\n  }\n\n  function bondToAccount(address account, uint256 amount)\n    public\n  {\n    if (msg.sender != offering) {\n      _notSameBlock();\n    }\n    require(amount > 0, \"Cannot bond 0\");\n\n    miningService.onBond(account, amount);\n\n    _bond(account, amount);\n  }\n\n  function unbond(uint256 amount)\n    external\n  {\n    require(amount > 0, \"Cannot unbond 0\");\n\n    uint256 bondedBalance = balanceOfBonded(msg.sender);\n\n    require(bondedBalance > 0, \"< bonded balance\");\n    require(amount <= bondedBalance, \"< bonded balance\");\n\n    // Avoid leaving dust behind\n    if (amount.add(1e16) > bondedBalance) {\n      amount = bondedBalance;\n    }\n\n    miningService.onUnbond(msg.sender, amount);\n\n    _unbond(amount);\n  }\n\n  function unbondAndBreak(uint256 amount)\n    external\n  {\n    require(amount > 0, \"Cannot unbond 0\");\n\n    uint256 bondedBalance = balanceOfBonded(msg.sender);\n\n    require(bondedBalance > 0, \"< bonded balance\");\n    require(amount <= bondedBalance, \"< bonded balance\");\n\n    // Avoid leaving dust behind\n    if (amount.add(1e16) > bondedBalance) {\n      amount = bondedBalance;\n    }\n\n    miningService.onUnbond(msg.sender, amount);\n\n    _unbondAndBreak(amount);\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function averageBondedValue(uint256 epoch) public view returns (uint256) {\n    EpochState storage state = epochState[epoch];\n    uint256 epochLength = dao.epochLength();\n    uint256 timeElapsed = epochLength;\n    uint256 epochStartTime = dao.getEpochStartTime(epoch);\n    uint256 diff;\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lastTotalBonded = state.lastTotalBonded;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastTotalBonded == 0) {\n      lastTotalBonded = _globalBonded;\n    }\n\n    if (block.timestamp < epochStartTime) {\n      return 0;\n    }\n\n    if (epochStartTime + epochLength <= lastUpdateTime) {\n      return maltDataLab.realValueOfLPToken((state.cumulativeTotalBonded) / epochLength);\n    }\n\n    if (epochStartTime + epochLength < block.timestamp) {\n      // The desired epoch is in the past\n      diff = (epochStartTime + epochLength) - lastUpdateTime;\n    } else {\n      diff = block.timestamp - lastUpdateTime;\n      timeElapsed = block.timestamp - epochStartTime;\n    }\n\n    if (timeElapsed == 0) {\n      // Only way timeElapsed should == 0 is when block.timestamp == epochStartTime\n      // Therefore just return the lastTotalBonded value\n      return maltDataLab.realValueOfLPToken(lastTotalBonded);\n    }\n\n    uint256 endValue = state.cumulativeTotalBonded + (lastTotalBonded.mul(diff));\n    return maltDataLab.realValueOfLPToken((endValue) / timeElapsed);\n  }\n\n  function totalBonded() public view returns (uint256) {\n    return _globalBonded;\n  }\n\n  function balanceOfBonded(address account) public view returns (uint256) {\n    return userState[account].bonded;\n  }\n\n  function bondedEpoch(address account) public view returns (uint256) {\n    return userState[account].bondedEpoch;\n  }\n\n  function epochData(uint256 epoch) public view returns(uint256, uint256, uint256) {\n    return (epochState[epoch].lastTotalBonded, epochState[epoch].lastUpdateTime, epochState[epoch].cumulativeTotalBonded);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _balanceCheck() internal view {\n    require(stakeToken.balanceOf(address(this)) >= totalBonded(), \"Balance inconsistency\");\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _bond(address account, uint256 amount) internal {\n    stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n\n    _addToBonded(account, amount);\n\n    _balanceCheck();\n\n    emit Bond(account, amount);\n  }\n\n  function _unbond(uint256 amountLPToken) internal notSameBlock {\n    _removeFromBonded(msg.sender, amountLPToken, \"LP: Insufficient bonded balance\");\n\n    stakeToken.safeTransfer(msg.sender, amountLPToken);\n\n    _balanceCheck();\n\n    emit Unbond(msg.sender, amountLPToken);\n  }\n\n  function _unbondAndBreak(uint256 amountLPToken) internal notSameBlock {\n    _removeFromBonded(msg.sender, amountLPToken, \"LP: Insufficient bonded balance\");\n\n    stakeToken.safeTransfer(address(dexHandler), amountLPToken);\n\n    (uint256 amountMalt, uint256 amountReward) = dexHandler.removeLiquidity();\n\n    malt.safeTransfer(msg.sender, amountMalt);\n    rewardToken.safeTransfer(msg.sender, amountReward);\n\n    _balanceCheck();\n\n    emit UnbondAndBreak(msg.sender, amountLPToken, amountMalt, amountReward);\n  }\n\n  function _addToBonded(address account, uint256 amount) internal {\n    userState[account].bonded = userState[account].bonded.add(amount);\n\n    _updateEpochState(_globalBonded.add(amount));\n\n    if (userState[account].bondedEpoch == 0) {\n      userState[account].bondedEpoch = dao.epoch();\n    }\n  }\n\n  function _removeFromBonded(address account, uint256 amount, string memory reason) internal {\n    userState[account].bonded = userState[account].bonded.sub(amount, reason);\n\n    _updateEpochState(_globalBonded.sub(amount, reason));\n  }\n\n  function _updateEpochState(uint256 newTotalBonded) internal {\n    EpochState storage state = epochState[_currentEpoch];\n    uint256 epoch = dao.epoch();\n    uint256 epochStartTime = dao.getEpochStartTime(_currentEpoch);\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lengthOfEpoch = dao.epochLength();\n    uint256 epochEndTime = epochStartTime + lengthOfEpoch;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastUpdateTime > epochEndTime) {\n      lastUpdateTime = epochEndTime;\n    }\n\n    if (epoch == _currentEpoch) {\n      // We are still in the same epoch. Just update\n      uint256 finalTime = block.timestamp;\n      if (block.timestamp > epochEndTime) {\n        // We are past the end of the epoch so cap to end of epoch\n        finalTime = epochEndTime;\n      } \n\n      uint256 diff = finalTime - lastUpdateTime;\n\n      if (diff > 0) {\n        state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n\n        state.lastUpdateTime = finalTime;\n        state.lastTotalBonded = newTotalBonded;\n      }\n    } else {\n      // We have crossed at least 1 epoch boundary\n\n      // Won't underflow due to check on lastUpdateTime above\n      uint256 diff = epochEndTime - lastUpdateTime;\n\n      state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n      state.lastUpdateTime = epochEndTime;\n      state.lastTotalBonded = _globalBonded;\n\n      for (uint256 i = _currentEpoch + 1; i <= epoch; i += 1) {\n        state = epochState[i];\n        epochStartTime = dao.getEpochStartTime(i);\n        epochEndTime = epochStartTime + lengthOfEpoch;\n        state.lastTotalBonded = _globalBonded;\n\n        if (epochEndTime < block.timestamp) {\n          // The desired epoch is in the past\n          diff = lengthOfEpoch;\n          state.lastUpdateTime = epochEndTime;\n        } else {\n          diff = block.timestamp - epochStartTime;\n          state.lastUpdateTime = block.timestamp;\n        }\n\n        state.cumulativeTotalBonded = state.lastTotalBonded.mul(diff);\n      }\n\n      state.lastTotalBonded = newTotalBonded;\n      _currentEpoch = epoch;\n    } \n\n    _globalBonded = newTotalBonded;\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_miningService != address(0), \"Cannot set 0 address\");\n    miningService = IMiningService(_miningService);\n  }\n\n  function setDAO(address _dao)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_dao != address(0), \"Cannot set 0 address\");\n    dao = IDAO(_dao);\n  }\n\n  function setDexHandler(address _dexHandler)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_dexHandler != address(0), \"Cannot set 0 address\");\n    dexHandler = IDexHandler(_dexHandler);\n  }\n\n  function setCurrentEpoch(uint256 _epoch)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _currentEpoch = _epoch;\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapHandler.sol",
            "Bonding.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-28",
                "Location": [
                    "//solidity\nif (amountMalt == 0 || amountReward == 0) {\n  liquidityBalance = lpToken.balanceOf(address(this));\n  lpToken.safeTransfer(msg.sender, liquidityBalance);\n  return (amountMalt, amountReward);\n}\n"
                ],
                "Type": " Bonding.sol _unbondAndBreak does not account for edge case where no tokens are returned",
                "Description": "\nIn Bonding.sol, the internal function _unbondAndBreak transfers a user's stake tokens to the dexHandler and then calls removeLiquidity on the dexHandler. Within the Uniswap handler (which is the only handler so far) removeLiquidity takes special care in the edge case where router.removeLiquidity returns zero tokens. Specifically, the Uniswap handler has this code:\n\nsolidity\nif (amountMalt == 0 || amountReward == 0) {\n  liquidityBalance = lpToken.balanceOf(address(this));\n  lpToken.safeTransfer(msg.sender, liquidityBalance);\n  return (amountMalt, amountReward);\n}\n\n\nIf this edge case does indeed happen (i.e. if something is preventing the Uniswap router from removing liquidity at the moment), then the Uniswap handler will transfer the LP tokens back to Bonding.sol. However, Bonding.sol does not have any logic to recognize that this happened, so the LP tokens will become stuck in the contract and the user will never get any of their value back. This could be very bad if the user unbonds a lot of LP and they don't get any of it back.\n\n\nSee _unbondAndBreak here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L226\n\nNotice how the edge case where amountMalt == 0 || amountReward == 0 is not considered in this function, but it is considered in the Uniswap handler's removeLiquidity here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L240\n\n",
                "Repair": "\nAdd a similar edge case check to _unbondAndBreak. In the case where LP tokens are transferred back to Bonding.sol instead of malt/reward, these LP tokens should be forwarded back to the user since the value is rightfully theirs.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/234)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/234#issuecomment-1022203715):\n  In the then case the tokens will be sent back to the Bonding.sol contract, which has no way of rescuing or returning the tokens, probably reverting would be a better solution.\n \n Because the warden identified a way for tokens to get stucked, I think Medium Severity to be appropriate\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nimport \"./interfaces/IStabilizerNode.sol\";\nimport \"./interfaces/IMovingAverage.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\n\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./libraries/SafeBurnMintableERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Malt Data Lab\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The central source of all of Malt protocol's internal data needs\n/// @dev Over time usage of MovingAverage will likely be replaced with more reliable oracles\ncontract MaltDataLab is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeBurnMintableERC20 for IBurnMintableERC20;\n\n  bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n  IBurnMintableERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  ILiquidityExtension public liquidityExtension;\n  IUniswapV2Pair public stakeToken;\n\n  IMovingAverage public reserveRatioMA;\n  IMovingAverage public maltPriceMA;\n  IMovingAverage public poolMaltReserveMA;\n\n  uint256 public priceTarget = 10**18; // $1\n  uint256 public reserveRatioLookback = 10 minutes;\n  uint256 public maltPriceLookback = 10 minutes;\n  uint256 public reserveLookback = 10 minutes;\n\n  event TrackMaltPrice(uint256 price);\n  event TrackPoolReserves(uint256 maltReserves, uint256 rewardReserves);\n  event TrackReserveRatio(uint256 rRatio, uint256 decimals);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    uint256 _priceTarget,\n    address _liquidityExtension,\n    address _reserveRatioMA,\n    address _maltPriceMA,\n    address _poolMaltReserveMA,\n    address _updater\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _roleSetup(UPDATER_ROLE, _updater);\n    _roleSetup(UPDATER_ROLE, initialAdmin);\n\n    stakeToken = IUniswapV2Pair(_stakeToken);\n    malt = IBurnMintableERC20(_malt);\n    rewardToken = IBurnMintableERC20(_rewardToken);\n    priceTarget = _priceTarget;\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    reserveRatioMA = IMovingAverage(_reserveRatioMA);\n    maltPriceMA = IMovingAverage(_maltPriceMA);\n    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);\n  }\n\n  function smoothedReserveRatio() public view returns (uint256) {\n    return reserveRatioMA.getValueWithLookback(reserveRatioLookback);\n  }\n\n  function smoothedMaltPrice() public view returns (uint256) {\n    return maltPriceMA.getValueWithLookback(maltPriceLookback);\n  }\n\n  function smoothedMaltInPool() public view returns (uint256) {\n    return poolMaltReserveMA.getValueWithLookback(reserveLookback);\n  }\n\n  function smoothedReserves() public view returns (uint256 maltReserves, uint256 collateralReserves) {\n    maltReserves = poolMaltReserveMA.getValueWithLookback(reserveLookback);\n    uint256 price = smoothedMaltPrice();\n    return (maltReserves, maltReserves.mul(price).div(priceTarget));\n  }\n\n  function reserveRatioAverage(uint256 _lookback) public view returns (uint256) {\n    return reserveRatioMA.getValueWithLookback(_lookback);\n  }\n\n  function maltPriceAverage(uint256 _lookback) public view returns (uint256) {\n    return maltPriceMA.getValueWithLookback(_lookback);\n  }\n\n  function maltInPoolAverage(uint256 _lookback) public view returns (uint256) {\n    return poolMaltReserveMA.getValueWithLookback(_lookback);\n  }\n\n  function realValueOfLPToken(uint256 amount) external view returns (uint256) {\n    uint256 maltPrice = smoothedMaltPrice();\n    (uint256 maltReserves, uint256 rewardReserves) = smoothedReserves();\n\n    if (maltReserves == 0) {\n      return 0;\n    }\n\n    uint256 totalLPSupply = stakeToken.totalSupply();\n\n    uint256 maltValue = amount.mul(maltReserves).div(totalLPSupply);\n    uint256 rewardValue = amount.mul(rewardReserves).div(totalLPSupply);\n\n    return rewardValue.add(maltValue.mul(maltPrice).div(priceTarget));\n  }\n\n  /*\n   * Public mutation methods\n   */\n  function trackReserveRatio() public {\n    (uint256 reserveRatio, uint256 decimals) = liquidityExtension.reserveRatio();\n\n    reserveRatioMA.update(reserveRatio);\n\n    emit TrackReserveRatio(reserveRatio, decimals);\n  }\n\n  function trackMaltPrice()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);\n      maltPriceMA.update(price);\n      emit TrackMaltPrice(price);\n    } else {\n      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);\n      maltPriceMA.update(price);\n\n      emit TrackMaltPrice(price);\n    }\n  }\n\n  function trackPoolReserves()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve1);\n      emit TrackPoolReserves(reserve1, reserve0);\n    } else {\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve0);\n      emit TrackPoolReserves(reserve0, reserve1);\n    }\n  }\n\n  function trackPool()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);\n      maltPriceMA.update(price);\n\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve1);\n      emit TrackMaltPrice(price);\n      emit TrackPoolReserves(reserve1, reserve0);\n    } else {\n      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);\n      maltPriceMA.update(price);\n\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve0);\n      emit TrackMaltPrice(price);\n      emit TrackPoolReserves(reserve0, reserve1);\n    }\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _normalizedPrice(\n    uint256 numerator,\n    uint256 denominator,\n    uint256 decimals\n  ) internal view returns(uint256 price) {\n    // Malt is 18 decimals\n    if (decimals > 18) {\n      uint256 diff = decimals - 18;\n      price = numerator.mul(10**decimals).div(denominator.mul(10**diff));\n    } else if (decimals < 18) {\n      uint256 diff = 18 - decimals;\n      price = (numerator.mul(10**diff)).mul(10**decimals).div(denominator);\n    } else {\n      price = numerator.mul(10**decimals).div(denominator);\n    }\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setLiquidityExtension(address _liquidityExtension) \n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Must be a valid address\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setPriceTarget(uint256 _price)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_price > 0, \"Cannot have 0 price\");\n    priceTarget = _price;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setMaltPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    maltPriceLookback = _lookback;\n  }\n\n  function setReserveLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    reserveLookback = _lookback;\n  }\n\n  function setReserveAverageContract(address _reserveRatioMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_reserveRatioMA != address(0), \"Cannot use 0 address\");\n    reserveRatioMA = IMovingAverage(_reserveRatioMA);\n  }\n\n  function setMaltPriceAverageContract(address _maltPriceMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maltPriceMA != address(0), \"Cannot use 0 address\");\n    maltPriceMA = IMovingAverage(_maltPriceMA);\n  }\n\n  function setMaltReservesAverageContract(address _poolMaltReserveMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_poolMaltReserveMA != address(0), \"Cannot use 0 address\");\n    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IRewardThrottle.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ISwingTrader.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ISupplyDistributionController.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThreshold = (10**18) / 100; // 1%\n  uint256 public lowerStabilityThreshold = (10**18) / 100;\n  uint256 public maxContributionBps = 70;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistance = 20; // 2%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100;\n\n  uint256 public daoRewardCut;\n  uint256 public lpRewardCut = 417;\n  uint256 public auctionPoolRewardCut = 113;\n  uint256 public swingTraderRewardCut = 417;\n  uint256 public treasuryRewardCut = 50;\n  uint256 public callerRewardCut = 3;\n\n  uint256 public lastStabilize;\n\n  ERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  IDAO public dao;\n  address public uniswapV2Factory;\n  ILiquidityExtension public liquidityExtension;\n  IMaltDataLab public maltDataLab;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n  IRewardThrottle public rewardThrottle;\n  ISwingTrader public swingTrader;\n  IImpliedCollateralService public impliedCollateralService;\n\n  address payable public treasuryMultisig;\n  address public auctionPool;\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event RewardDistribution(uint256 rewarded);\n  event SetAnnualYield(uint256 yield);\n  event SetStabilizeBackoff(uint256 period);\n  event SetAuctionBurnSkew(address auctionBurnReserveSkew);\n  event SetRewardCut(uint256 daoCut, uint256 lpCut, uint256 callerCut, uint256 treasuryCut, uint256 auctionPoolCut, uint256 swingTraderCut);\n  event SetTreasury(address newTreasury);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetNewMaltDataLab(address dataLab);\n  event SetAuctionContract(address auction);\n  event SetDexHandler(address dexHandler);\n  event SetDao(address dao);\n  event SetLiquidityExtension(address liquidityExtension);\n  event SetRewardThrottle(address rewardThrottle);\n  event SetSwingTrader(address swingTrader);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetAuctionPool(address auctionPool);\n  event SetMaxContribution(uint256 maxContribution);\n  event SetImpliedCollateralService(address impliedCollateralService);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _rewardToken,\n    address _malt,\n    address _auction,\n    address _uniswapV2Factory,\n    address payable _treasuryMultisig,\n    address _auctionPool\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(AUCTION_ROLE, _auction);\n\n    rewardToken = ERC20(_rewardToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n\n    uniswapV2Factory = _uniswapV2Factory;\n    treasuryMultisig = _treasuryMultisig;\n    auctionPool = _auctionPool;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _dexHandler,\n    address _maltDataLab,\n    address _auctionBurnReserveSkew,\n    address _rewardThrottle,\n    address _dao,\n    address _swingTrader,\n    address _liquidityExtension,\n    address _impliedCollateralService\n  ) external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    dao = IDAO(_dao);\n    swingTrader = ISwingTrader(_swingTrader);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function stabilize() external notSameBlock {\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    rewardThrottle.checkRewardUnderflow();\n\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n\n    if (!_shouldAdjustSupply(exchangeRate)) {\n      maltDataLab.trackReserveRatio();\n\n      lastStabilize = block.timestamp;\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    if (exchangeRate > maltDataLab.priceTarget()) {\n      _distributeSupply();\n    } else {\n      _startAuction();\n    }\n\n    lastStabilize = block.timestamp;\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    if (hasRole(ADMIN_ROLE, _msgSender())) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = priceTarget.mul(1000 + overrideDistance).div(1000);\n    uint256 lowerThreshold = priceTarget.mul(1000 - overrideDistance).div(1000);\n\n    return exchangeRate <= lowerThreshold || exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {\n    uint256 decimals = rewardToken.decimals();\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);\n    uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);\n\n    return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _distributeSupply() internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController).check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTrader.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    uint256 rewards = dexHandler.sellMalt();\n\n    auctionBurnReserveSkew.addAbovePegObservation(tradeSize);\n\n    uint256 remaining = _replenishLiquidityExtension(rewards);\n\n    _distributeRewards(remaining);\n\n    maltDataLab.trackReserveRatio();\n    impliedCollateralService.claim();\n  }\n\n  function _distributeRewards(uint256 rewarded) internal {\n    if (rewarded == 0) {\n      return;\n    }\n    rewardToken.approve(address(auction), rewarded);\n    rewarded = auction.allocateArbRewards(rewarded);\n\n    if (rewarded == 0) {\n      return;\n    }\n\n    uint256 callerCut = rewarded.mul(callerRewardCut).div(1000);\n    uint256 lpCut = rewarded.mul(lpRewardCut).div(1000);\n    uint256 daoCut = rewarded.mul(daoRewardCut).div(1000);\n    uint256 auctionPoolCut = rewarded.mul(auctionPoolRewardCut).div(1000);\n    uint256 swingTraderCut = rewarded.mul(swingTraderRewardCut).div(1000);\n\n    // Treasury gets paid after everyone else\n    uint256 treasuryCut = rewarded - daoCut - lpCut - callerCut - auctionPoolCut - swingTraderCut;\n\n    assert(treasuryCut <= rewarded);\n\n    if (callerCut > 0) {\n      rewardToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    if (auctionPoolCut > 0) {\n      rewardToken.safeTransfer(auctionPool, auctionPoolCut);\n    }\n\n    if (swingTraderCut > 0) {\n      rewardToken.safeTransfer(address(swingTrader), swingTraderCut);\n    }\n\n    if (treasuryCut > 0) {\n      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);\n    }\n\n    if (daoCut > 0) {\n      rewardToken.safeTransfer(address(dao), daoCut);\n    }\n\n    if (lpCut > 0) {\n      rewardToken.safeTransfer(address(rewardThrottle), lpCut);\n      rewardThrottle.handleReward();\n    }\n\n    emit RewardDistribution(rewarded);\n  }\n\n  function _replenishLiquidityExtension(uint256 rewards) internal returns (uint256 remaining) {\n    if (liquidityExtension.hasMinimumReserves() || rewards == 0) {\n      return rewards;\n    }\n\n    (uint256 deficit,) = liquidityExtension.collateralDeficit();\n\n    uint256 maxContrib = rewards.mul(maxContributionBps).div(100);\n\n    if (deficit >= maxContrib) {\n      rewardToken.safeTransfer(address(liquidityExtension), maxContrib);\n      return rewards - maxContrib;\n    }\n\n    rewardToken.safeTransfer(address(liquidityExtension), deficit);\n\n    return rewards - deficit;\n  }\n\n  function _startAuction() internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount == 0) {\n      return;\n    }\n\n    uint256 decimals = rewardToken.decimals();\n\n    uint256 amountUsed = swingTrader.buyMalt(purchaseAmount);\n\n    purchaseAmount = purchaseAmount - amountUsed;\n\n    if (purchaseAmount < 10**decimals) {\n      return;\n    }\n\n    auction.triggerAuction(priceTarget, purchaseAmount);\n\n    malt.mint(msg.sender, defaultIncentive*10**18);\n    emit MintMalt(defaultIncentive*10**18);\n\n    auctionBurnReserveSkew.addBelowPegObservation(purchaseAmount);\n\n    maltDataLab.trackReserveRatio();\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setAuctionBurnSkew(address _auctionBurnReserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    emit SetAuctionBurnSkew(_auctionBurnReserveSkew);\n  }\n\n  function setRewardCut(\n    uint256 _daoCut,\n    uint256 _lpCut,\n    uint256 _callerCut,\n    uint256 _auctionPoolCut,\n    uint256 _swingTraderCut\n  )\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    uint256 sum = _daoCut.add(_lpCut).add(_callerCut).add(_auctionPoolCut).add(_swingTraderCut);\n    require(sum <= 1000, \"Reward cut must be <= 100%\");\n    daoRewardCut = _daoCut;\n    lpRewardCut = _lpCut;\n    callerRewardCut = _callerCut;\n    auctionPoolRewardCut = _auctionPoolCut;\n    swingTraderRewardCut = _swingTraderCut;\n    treasuryRewardCut = 1000 - sum;\n\n    emit SetRewardCut(_daoCut, _lpCut, _callerCut, treasuryRewardCut, _auctionPoolCut, _swingTraderCut);\n  }\n\n  function setTreasury(address payable _newTreasury)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    treasuryMultisig = _newTreasury;\n    emit SetTreasury(_newTreasury);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive > 0, \"No negative incentive\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setNewDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetNewMaltDataLab(_dataLab);\n  }\n\n  function setAuctionContract(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n\n    if (address(auction) != address(0)) {\n      revokeRole(AUCTION_ROLE, address(auction));\n    }\n\n    auction = IAuction(_auction);\n    _setupRole(AUCTION_ROLE, _auction);\n    emit SetAuctionContract(_auction);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper > 0 && _lower > 0, \"Must be above 0\");\n\n    upperStabilityThreshold = _upper;\n    lowerStabilityThreshold = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setAuctionPool(address _auctionPool)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auctionPool != address(0), \"Not address 0\");\n\n    auctionPool = _auctionPool;\n    emit SetAuctionPool(_auctionPool);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setMaxContribution(uint256 _maxContribution)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maxContribution > 0 && _maxContribution <= 100, \"Must be between 0 and 100\");\n\n    maxContributionBps = _maxContribution;\n    emit SetMaxContribution(_maxContribution);\n  }\n\n  function setDexHandler(address _dexHandler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dexHandler != address(0), \"Not address 0\");\n    dexHandler = IDexHandler(_dexHandler);\n    emit SetDexHandler(_dexHandler);\n  }\n\n  function setDao(address _dao)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dao != address(0), \"Not address 0\");\n    dao = IDAO(_dao);\n    emit SetDao(_dao);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Not address 0\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    emit SetLiquidityExtension(_liquidityExtension);\n  }\n\n  function setRewardThrottle(address _rewardThrottle)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_rewardThrottle != address(0), \"Not address 0\");\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    emit SetRewardThrottle(_rewardThrottle);\n  }\n\n  function setSwingTrader(address _swingTrader)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_swingTrader != address(0), \"Not address 0\");\n    swingTrader = ISwingTrader(_swingTrader);\n    emit SetSwingTrader(_swingTrader);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_impliedCollateralService != address(0), \"Not address 0\");\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    emit SetImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\");\n    overrideDistance = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n}\n\n\n",
        "CodeNames": [
            "MaltDataLab.sol",
            "Auction.sol",
            "StabilizerNode.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-30",
                "Location": [
                    "maltPriceAverage",
                    "_startAuction",
                    "exchangeRate",
                    "trackPool",
                    "trackMaltPrice",
                    "trackPoolReserves",
                    "stabilize",
                    "_stabilityWindowOverride",
                    "fastAveragePeriod",
                    "UPDATER_ROLE"
                ],
                "Type": " Malt Protocol Uses Stale Results From  MaltDataLab  Which Can Be Abused By Users",
                "Description": "\nMaltDataLab integrates several MovingAverage contracts to fetch sensitive data for the Malt protocol. Primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. trackMaltPrice, trackPoolReserves and trackPool are called by a restricted role denoted as the UPDATER_ROLE and represented by an EOA account and not another contract. Hence, the EOA account must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to MaltDataLab and effectively extract value from other areas of the protocol which use stale values.\n\n\nConsider the following attack vector:\n\n*   The price of Malt exceeds the lower bound threshold and hence stabilize can be called by any user.\n*   The _stabilityWindowOverride function is satisfied, hence the function will execute.\n*   The state variable, exchangeRate, queries maltPriceAverage which may use an outdated exchange rate.\n*   _startAuction is executed which rewards msg.sender with 100 Malt as an incentive for triggering an auction.\n*   As the price is not subsequently updated, a malicious attacker could collude with a miner to censor further pool updates and continue calling stabilize on every fastAveragePeriod interval to extract incentive payments.\n*   If the payments exceed what the UPDATER_ROLE is willing to pay to call trackMaltPrice, a user is able to sustain this attack.\n\nThis threatens the overall stability of the protocol and should be properly handled to prevent such attacks. However, the fact that MaltDataLab uses a series of spot price data points to calculate the MovingAverage also creates an area of concern as well-funded actors could still manipulate the MovingAverage contract by sandwiching calls to trackMaltPrice, trackPool and trackPoolReserves.\n\ntrackMaltPrice, trackPool, and trackPoolReserves should be added to the following areas of the code where applicable.\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L159\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L173\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L177\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L881\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L710\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L190\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L105\n\n\n",
                "Repair": "\nConsider adding calls to trackMaltPrice, trackPoolReserves and trackPool wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Assuming the cumulative values are used in the MovingAverage contracts, then sensitive calls utilising MaltDataLab should be protected from flashloan attacks. However, currently this is not the case, rather MovingAverage consists of a series of spot price data points which can be manipulated by well-funded actors or via a flashloan. Therefore, there needs to be necessary changes made to MaltDataLab to use cumulative price updates as its moving average instead of spot price.\n\n0xScotch (sponsor) confirmed(https://github.com/code-423n4/2021-11-malt-findings/issues/373): \n  Gas issues were the reason updates weren't inlined into paths that update critical values. However based on some thoughts from the team over the past few weeks and suggestions in other audit findings I think we can reduce gas enough to make it viable to inline it \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-11-malt-findings/issues/373#issuecomment-1019283105):\n  1) Miners can censor transactions, that is a fact\n 2) Relying on an external call can cause race conditions or situations where the call didn't happen (price didn't update in time)\n 3) Arguably a malicious actor could collude with miners with the goal of extracting further value\n \n However, the target chain for the deployment is Polygon, so unless they were to create custom validator code, and collude 1-1 with each validator (no flashbots on Polygon, yet) then the attack is increasingly more complex.\n \n The attack is reliant on the externalities of the validator + somebody incentivized enough to exploit this.\n \n I agree with he finding and believe after stabilize the system should auto-update the prices\n Because of the external requirements am downgrading to medium severity\n\n\n"
            }
        ]
    }
]