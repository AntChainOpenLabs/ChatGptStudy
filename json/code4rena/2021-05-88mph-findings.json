[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"./libs/SafeERC20.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    MulticallUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\";\nimport {IMoneyMarket} from \"./moneymarkets/IMoneyMarket.sol\";\nimport {IFeeModel} from \"./models/fee/IFeeModel.sol\";\nimport {IInterestModel} from \"./models/interest/IInterestModel.sol\";\nimport {NFT} from \"./tokens/NFT.sol\";\nimport {FundingMultitoken} from \"./tokens/FundingMultitoken.sol\";\nimport {MPHMinter} from \"./rewards/MPHMinter.sol\";\nimport {IInterestOracle} from \"./models/interest-oracle/IInterestOracle.sol\";\nimport {DecMath} from \"./libs/DecMath.sol\";\nimport {Rescuable} from \"./libs/Rescuable.sol\";\nimport {Sponsorable} from \"./libs/Sponsorable.sol\";\nimport {console} from \"hardhat/console.sol\";\n\n/**\n    @title DeLorean Interest -- It's coming back from the future!\n    @author Zefram Lou\n    @notice The main pool contract for fixed-rate deposits\n    @dev The contract to interact with for most actions\n */\ncontract DInterest is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    Rescuable,\n    MulticallUpgradeable,\n    Sponsorable\n{\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n    using DecMath for uint256;\n\n    // Constants\n    uint256 internal constant PRECISION = 10**18;\n    /**\n        @dev used for sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex\n     */\n    uint256 internal constant EXTRA_PRECISION = 10**27;\n    /**\n        @dev used for funding.principalPerToken and deposit.interestRateMultiplierIntercept\n     */\n    uint256 internal constant ULTRA_PRECISION = 2**128;\n\n    // User deposit data\n    // Each deposit has an ID used in the depositNFT, which is equal to its index in `deposits` plus 1\n    struct Deposit {\n        uint256 virtualTokenTotalSupply; // depositAmount + interestAmount, behaves like a zero coupon bond\n        uint256 interestRate; // interestAmount = interestRate * depositAmount\n        uint256 feeRate; // feeAmount = feeRate * interestAmount\n        uint256 maturationTimestamp; // Unix timestamp after which the deposit may be withdrawn, in seconds\n        uint256 depositTimestamp; // Unix timestamp at time of deposit, in seconds\n        uint256 averageRecordedIncomeIndex; // Average income index at time of deposit, used for computing deposit surplus\n        uint256 fundingID; // The ID of the associated Funding struct. 0 if not funded.\n    }\n    Deposit[] internal deposits;\n\n    // Funding data\n    // Each funding has an ID used in the fundingMultitoken, which is equal to its index in `fundingList` plus 1\n    struct Funding {\n        uint256 depositID; // The ID of the associated Deposit struct.\n        uint256 recordedMoneyMarketIncomeIndex; // the income index at the last update (creation or withdrawal)\n        uint256 principalPerToken; // The amount of stablecoins that's earning interest for you per funding token you own. Scaled to 18 decimals regardless of stablecoin decimals.\n    }\n    Funding[] internal fundingList;\n    // the sum of (recordedFundedPrincipalAmount / recordedMoneyMarketIncomeIndex) of all fundings\n    uint256 public sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex;\n\n    // Params\n    /**\n        @dev Maximum deposit period, in seconds\n     */\n    uint256 public MaxDepositPeriod;\n    /**\n        @dev Minimum deposit amount, in stablecoins\n     */\n    uint256 public MinDepositAmount;\n\n    // Global variables\n    uint256 public totalDeposit;\n    uint256 public totalInterestOwed;\n    uint256 public totalFeeOwed;\n    uint256 public totalFundedPrincipalAmount;\n\n    // External smart contracts\n    IMoneyMarket public moneyMarket;\n    ERC20 public stablecoin;\n    IFeeModel public feeModel;\n    IInterestModel public interestModel;\n    IInterestOracle public interestOracle;\n    NFT public depositNFT;\n    FundingMultitoken public fundingMultitoken;\n    MPHMinter public mphMinter;\n\n    // Events\n    event EDeposit(\n        address indexed sender,\n        uint256 indexed depositID,\n        uint256 depositAmount,\n        uint256 interestAmount,\n        uint256 feeAmount,\n        uint256 maturationTimestamp\n    );\n    event ETopupDeposit(\n        address indexed sender,\n        uint256 indexed depositID,\n        uint256 depositAmount,\n        uint256 interestAmount,\n        uint256 feeAmount\n    );\n    event ERolloverDeposit(\n        address indexed sender,\n        uint256 indexed depositID,\n        uint256 indexed newDepositID\n    );\n    event EWithdraw(\n        address indexed sender,\n        uint256 indexed depositID,\n        uint256 tokenAmount,\n        uint256 feeAmount\n    );\n    event EFund(\n        address indexed sender,\n        uint256 indexed fundingID,\n        uint256 fundAmount,\n        uint256 tokenAmount\n    );\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        uint256 newValue\n    );\n\n    function __DInterest_init(\n        uint256 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _moneyMarket,\n        address _stablecoin,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) internal initializer {\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __DInterest_init_unchained(\n            _MaxDepositPeriod,\n            _MinDepositAmount,\n            _moneyMarket,\n            _stablecoin,\n            _feeModel,\n            _interestModel,\n            _interestOracle,\n            _depositNFT,\n            _fundingMultitoken,\n            _mphMinter\n        );\n    }\n\n    function __DInterest_init_unchained(\n        uint256 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _moneyMarket,\n        address _stablecoin,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) internal initializer {\n        // Verify input addresses\n        require(\n            _moneyMarket.isContract() &&\n                _stablecoin.isContract() &&\n                _feeModel.isContract() &&\n                _interestModel.isContract() &&\n                _interestOracle.isContract() &&\n                _depositNFT.isContract() &&\n                _fundingMultitoken.isContract() &&\n                _mphMinter.isContract(),\n            \"DInterest: An input address is not a contract\"\n        );\n\n        moneyMarket = IMoneyMarket(_moneyMarket);\n        stablecoin = ERC20(_stablecoin);\n        feeModel = IFeeModel(_feeModel);\n        interestModel = IInterestModel(_interestModel);\n        interestOracle = IInterestOracle(_interestOracle);\n        depositNFT = NFT(_depositNFT);\n        fundingMultitoken = FundingMultitoken(_fundingMultitoken);\n        mphMinter = MPHMinter(_mphMinter);\n\n        // Ensure moneyMarket uses the same stablecoin\n        require(\n            address(moneyMarket.stablecoin()) == _stablecoin,\n            \"DInterest: moneyMarket.stablecoin() != _stablecoin\"\n        );\n\n        // Ensure interestOracle uses the same moneyMarket\n        require(\n            address(interestOracle.moneyMarket()) == _moneyMarket,\n            \"DInterest: interestOracle.moneyMarket() != _moneyMarket\"\n        );\n\n        MaxDepositPeriod = _MaxDepositPeriod;\n        MinDepositAmount = _MinDepositAmount;\n    }\n\n    /**\n        @param _MaxDepositPeriod The maximum deposit period, in seconds\n        @param _MinDepositAmount The minimum deposit amount, in stablecoins\n        @param _moneyMarket Address of IMoneyMarket that's used for generating interest (owner must be set to this DInterest contract)\n        @param _stablecoin Address of the stablecoin used to store funds\n        @param _feeModel Address of the FeeModel contract that determines how fees are charged\n        @param _interestModel Address of the InterestModel contract that determines how much interest to offer\n        @param _interestOracle Address of the InterestOracle contract that provides the average interest rate\n        @param _depositNFT Address of the NFT representing ownership of deposits (owner must be set to this DInterest contract)\n        @param _fundingMultitoken Address of the ERC1155 multitoken representing ownership of fundings (this DInterest contract must have the minter-burner role)\n        @param _mphMinter Address of the contract for handling minting MPH to users\n     */\n    function initialize(\n        uint256 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _moneyMarket,\n        address _stablecoin,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) external virtual initializer {\n        __DInterest_init(\n            _MaxDepositPeriod,\n            _MinDepositAmount,\n            _moneyMarket,\n            _stablecoin,\n            _feeModel,\n            _interestModel,\n            _interestOracle,\n            _depositNFT,\n            _fundingMultitoken,\n            _mphMinter\n        );\n    }\n\n    /**\n        Public action functions\n     */\n\n    /**\n        @notice Create a deposit using `depositAmount` stablecoin that matures at timestamp `maturationTimestamp`.\n        @dev The ERC-721 NFT representing deposit ownership is given to msg.sender\n        @param depositAmount The amount of deposit, in stablecoin\n        @param maturationTimestamp The Unix timestamp of maturation, in seconds\n        @return depositID The ID of the created deposit\n        @return interestAmount The amount of fixed-rate interest\n     */\n    function deposit(uint256 depositAmount, uint256 maturationTimestamp)\n        external\n        nonReentrant\n        returns (uint256 depositID, uint256 interestAmount)\n    {\n        return _deposit(msg.sender, depositAmount, maturationTimestamp, false);\n    }\n\n    /**\n        @notice Add `depositAmount` stablecoin to the existing deposit with ID `depositID`.\n        @dev The interest rate for the topped up funds will be the current oracle rate.\n        @param depositID The deposit to top up\n        @param depositAmount The amount to top up, in stablecoin\n        @return interestAmount The amount of interest that will be earned by the topped up funds at maturation\n     */\n    function topupDeposit(uint256 depositID, uint256 depositAmount)\n        external\n        nonReentrant\n        returns (uint256 interestAmount)\n    {\n        return _topupDeposit(msg.sender, depositID, depositAmount);\n    }\n\n    /**\n        @notice Withdraw all funds from deposit with ID `depositID` and use them\n                to create a new deposit that matures at time `maturationTimestamp`\n        @param depositID The deposit to roll over\n        @param maturationTimestamp The Unix timestamp of the new deposit, in seconds\n        @return newDepositID The ID of the new deposit\n     */\n    function rolloverDeposit(uint256 depositID, uint256 maturationTimestamp)\n        external\n        nonReentrant\n        returns (uint256 newDepositID, uint256 interestAmount)\n    {\n        return _rolloverDeposit(msg.sender, depositID, maturationTimestamp);\n    }\n\n    /**\n        @notice Withdraws funds from the deposit with ID `depositID`.\n        @dev Virtual tokens behave like zero coupon bonds, after maturation withdrawing 1 virtual token\n             yields 1 stablecoin. The total supply is given by deposit.virtualTokenTotalSupply\n        @param depositID the deposit to withdraw from\n        @param virtualTokenAmount the amount of virtual tokens to withdraw\n        @param early True if intend to withdraw before maturation, false otherwise\n        @return withdrawnStablecoinAmount the amount of stablecoins withdrawn\n     */\n    function withdraw(\n        uint256 depositID,\n        uint256 virtualTokenAmount,\n        bool early\n    ) external nonReentrant returns (uint256 withdrawnStablecoinAmount) {\n        return\n            _withdraw(msg.sender, depositID, virtualTokenAmount, early, false);\n    }\n\n    /**\n        @notice Funds the fixed-rate interest of the deposit with ID `depositID`.\n                In exchange, the funder receives the future floating-rate interest\n                generated by the portion of the deposit whose interest was funded.\n        @dev The sender receives ERC-1155 multitokens (fundingMultitoken) representing\n             their floating-rate bonds.\n        @param depositID The deposit whose fixed-rate interest will be funded\n        @param fundAmount The amount of fixed-rate interest to fund.\n                          If it exceeds surplusOfDeposit(depositID), it will be set to\n                          the surplus value instead.\n        @param fundingID The ID of the fundingMultitoken the sender received\n     */\n    function fund(uint256 depositID, uint256 fundAmount)\n        external\n        nonReentrant\n        returns (uint256 fundingID)\n    {\n        return _fund(msg.sender, depositID, fundAmount);\n    }\n\n    /**\n        @notice Distributes the floating-rate interest accrued by a deposit to the\n                floating-rate bond holders.\n        @param fundingID The ID of the floating-rate bond\n        @return interestAmount The amount of interest distributed, in stablecoins\n     */\n    function payInterestToFunders(uint256 fundingID)\n        external\n        returns (uint256 interestAmount)\n    {\n        return _payInterestToFunders(fundingID);\n    }\n\n    /**\n        Sponsored action functions\n     */\n\n    function sponsoredDeposit(\n        uint256 depositAmount,\n        uint256 maturationTimestamp,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredDeposit.selector,\n            abi.encode(depositAmount, maturationTimestamp)\n        )\n        returns (uint256 depositID, uint256 interestAmount)\n    {\n        return\n            _deposit(\n                sponsorship.sender,\n                depositAmount,\n                maturationTimestamp,\n                false\n            );\n    }\n\n    function sponsoredTopupDeposit(\n        uint256 depositID,\n        uint256 depositAmount,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredTopupDeposit.selector,\n            abi.encode(depositID, depositAmount)\n        )\n        returns (uint256 interestAmount)\n    {\n        return _topupDeposit(sponsorship.sender, depositID, depositAmount);\n    }\n\n    function sponsoredRolloverDeposit(\n        uint256 depositID,\n        uint256 maturationTimestamp,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredRolloverDeposit.selector,\n            abi.encode(depositID, maturationTimestamp)\n        )\n        returns (uint256 newDepositID, uint256 interestAmount)\n    {\n        return\n            _rolloverDeposit(\n                sponsorship.sender,\n                depositID,\n                maturationTimestamp\n            );\n    }\n\n    function sponsoredWithdraw(\n        uint256 depositID,\n        uint256 virtualTokenAmount,\n        bool early,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredWithdraw.selector,\n            abi.encode(depositID, virtualTokenAmount, early)\n        )\n        returns (uint256 withdrawnStablecoinAmount)\n    {\n        return\n            _withdraw(\n                sponsorship.sender,\n                depositID,\n                virtualTokenAmount,\n                early,\n                false\n            );\n    }\n\n    function sponsoredFund(\n        uint256 depositID,\n        uint256 fundAmount,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredFund.selector,\n            abi.encode(depositID, fundAmount)\n        )\n        returns (uint256 fundingID)\n    {\n        return _fund(sponsorship.sender, depositID, fundAmount);\n    }\n\n    function sponsoredPayInterestToFunders(\n        uint256 fundingID,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredPayInterestToFunders.selector,\n            abi.encode(fundingID)\n        )\n        returns (uint256 interestAmount)\n    {\n        return _payInterestToFunders(fundingID);\n    }\n\n    /**\n        Public getter functions\n     */\n\n    /**\n        @notice Computes the amount of fixed-rate interest (before fees) that\n                will be given to a deposit of `depositAmount` stablecoins that\n                matures in `depositPeriodInSeconds` seconds.\n        @param depositAmount The deposit amount, in stablecoins\n        @param depositPeriodInSeconds The deposit period, in seconds\n        @return interestAmount The amount of fixed-rate interest (before fees)\n     */\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds\n    ) public virtual returns (uint256 interestAmount) {\n        (, uint256 moneyMarketInterestRatePerSecond) =\n            interestOracle.updateAndQuery();\n        (bool surplusIsNegative, uint256 surplusAmount) = surplus();\n\n        return\n            interestModel.calculateInterestAmount(\n                depositAmount,\n                depositPeriodInSeconds,\n                moneyMarketInterestRatePerSecond,\n                surplusIsNegative,\n                surplusAmount\n            );\n    }\n\n    /**\n        @notice Computes the floating interest amount owed to deficit funders, which will be paid out\n                when a funded deposit is withdrawn.\n                Formula: \\sum_i recordedFundedPrincipalAmount_i * (incomeIndex / recordedMoneyMarketIncomeIndex_i - 1)\n                = incomeIndex * (\\sum_i recordedFundedPrincipalAmount_i / recordedMoneyMarketIncomeIndex_i)\n                - \\sum_i recordedFundedPrincipalAmount_i\n                where i refers to a funding\n        @return interestOwed The floating-rate interest accrued to all floating-rate bond holders\n     */\n    function totalInterestOwedToFunders()\n        public\n        virtual\n        returns (uint256 interestOwed)\n    {\n        uint256 currentValue =\n            (moneyMarket.incomeIndex() *\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex) /\n                EXTRA_PRECISION;\n        uint256 initialValue = totalFundedPrincipalAmount;\n        if (currentValue < initialValue) {\n            return 0;\n        }\n        return currentValue - initialValue;\n    }\n\n    /**\n        @notice Computes the pool's overall surplus, which is the value of its holdings\n                in the `moneyMarket` minus the amount owed to depositors, funders, and\n                the fee beneficiary.\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function surplus()\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        uint256 totalValue = moneyMarket.totalValue();\n        uint256 totalOwed =\n            totalDeposit +\n                totalInterestOwed +\n                totalFeeOwed +\n                totalInterestOwedToFunders();\n        if (totalValue >= totalOwed) {\n            // Locked value more than owed deposits, positive surplus\n            isNegative = false;\n            surplusAmount = totalValue - totalOwed;\n        } else {\n            // Locked value less than owed deposits, negative surplus\n            isNegative = true;\n            surplusAmount = totalOwed - totalValue;\n        }\n    }\n\n    /**\n        @notice Computes the raw surplus of a deposit, which is the current value of the\n                deposit in the money market minus the amount owed (deposit + interest + fee).\n                The deposit's funding status is not considered here, meaning even if a deposit's\n                fixed-rate interest is fully funded, it likely will still have a non-zero surplus.\n        @param depositID The ID of the deposit\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function rawSurplusOfDeposit(uint256 depositID)\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\n        uint256 depositTokenTotalSupply = depositEntry.virtualTokenTotalSupply;\n        uint256 depositAmount =\n            depositTokenTotalSupply.decdiv(\n                depositEntry.interestRate + PRECISION\n            );\n        uint256 interestAmount = depositTokenTotalSupply - depositAmount;\n        uint256 feeAmount = interestAmount.decmul(depositEntry.feeRate);\n        uint256 currentDepositValue =\n            (depositAmount * currentMoneyMarketIncomeIndex) /\n                depositEntry.averageRecordedIncomeIndex;\n        uint256 owed = depositAmount + interestAmount + feeAmount;\n        if (currentDepositValue >= owed) {\n            // Locked value more than owed deposits, positive surplus\n            isNegative = false;\n            surplusAmount = currentDepositValue - owed;\n        } else {\n            // Locked value less than owed deposits, negative surplus\n            isNegative = true;\n            surplusAmount = owed - currentDepositValue;\n        }\n    }\n\n    /**\n        @notice Computes the surplus of a deposit, which is the raw surplus of the\n                unfunded part of the deposit. If the deposit is not funded, this will\n                return the same value as {rawSurplusOfDeposit}.\n        @param depositID The ID of the deposit\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function surplusOfDeposit(uint256 depositID)\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        (isNegative, surplusAmount) = rawSurplusOfDeposit(depositID);\n\n        uint256 fundingID = _getDeposit(depositID).fundingID;\n        if (fundingID != 0) {\n            uint256 totalPrincipal =\n                _depositVirtualTokenToPrincipal(\n                    depositID,\n                    _getDeposit(depositID).virtualTokenTotalSupply\n                );\n            uint256 principalPerToken =\n                _getFunding(fundingID).principalPerToken;\n            uint256 unfundedPrincipalAmount =\n                totalPrincipal -\n                    (fundingMultitoken.totalSupply(fundingID) *\n                        principalPerToken) /\n                    ULTRA_PRECISION;\n            surplusAmount =\n                (surplusAmount * unfundedPrincipalAmount) /\n                totalPrincipal;\n        }\n    }\n\n    /**\n        @notice Computes the amount of stablecoins that can be withdrawn\n                by burning `virtualTokenAmount` virtual tokens from the deposit\n                with ID `depositID` at time `timestamp`.\n        @dev The queried timestamp should >= the deposit's lastTopupTimestamp, since\n             the information before this time is forgotten.\n        @param depositID The ID of the deposit\n        @param virtualTokenAmount The amount of virtual tokens to burn\n        @return withdrawableAmount The amount of stablecoins (after fee) that can be withdrawn\n        @return feeAmount The amount of fees that will be given to the beneficiary\n     */\n    function withdrawableAmountOfDeposit(\n        uint256 depositID,\n        uint256 virtualTokenAmount\n    ) external view returns (uint256 withdrawableAmount, uint256 feeAmount) {\n        // Verify input\n        Deposit memory depositEntry = _getDeposit(depositID);\n        if (virtualTokenAmount == 0) {\n            return (0, 0);\n        } else {\n            if (virtualTokenAmount > depositEntry.virtualTokenTotalSupply) {\n                virtualTokenAmount = depositEntry.virtualTokenTotalSupply;\n            }\n        }\n\n        // Compute token amounts\n        bool early = block.timestamp < depositEntry.maturationTimestamp;\n        uint256 depositAmount =\n            virtualTokenAmount.decdiv(depositEntry.interestRate + PRECISION);\n        uint256 interestAmount = early ? 0 : virtualTokenAmount - depositAmount;\n        feeAmount = interestAmount.decmul(depositEntry.feeRate);\n        withdrawableAmount = depositAmount + interestAmount;\n\n        if (early) {\n            // apply fee to withdrawAmount\n            uint256 earlyWithdrawFee =\n                feeModel.getEarlyWithdrawFeeAmount(\n                    address(this),\n                    depositID,\n                    withdrawableAmount\n                );\n            feeAmount += earlyWithdrawFee;\n            withdrawableAmount -= earlyWithdrawFee;\n        }\n    }\n\n    /**\n        @notice Computes the floating-rate interest accrued in the floating-rate\n                bond with ID `fundingID`.\n        @param fundingID The ID of the floating-rate bond\n        @return The interest accrued, in stablecoins\n     */\n    function accruedInterestOfFunding(uint256 fundingID)\n        external\n        returns (uint256)\n    {\n        return _accruedInterestOfFunding(fundingID);\n    }\n\n    /**\n        @notice Returns the total number of deposits.\n        @return deposits.length\n     */\n    function depositsLength() external view returns (uint256) {\n        return deposits.length;\n    }\n\n    /**\n        @notice Returns the total number of floating-rate bonds.\n        @return fundingList.length\n     */\n    function fundingListLength() external view returns (uint256) {\n        return fundingList.length;\n    }\n\n    /**\n        @notice Returns the Deposit struct associated with the deposit with ID\n                `depositID`.\n        @param depositID The ID of the deposit\n        @return The deposit struct\n     */\n    function getDeposit(uint256 depositID)\n        external\n        view\n        returns (Deposit memory)\n    {\n        return deposits[depositID - 1];\n    }\n\n    /**\n        @notice Returns the Funding struct associated with the floating-rate bond with ID\n                `fundingID`.\n        @param fundingID The ID of the floating-rate bond\n        @return The Funding struct\n     */\n    function getFunding(uint256 fundingID)\n        external\n        view\n        returns (Funding memory)\n    {\n        return fundingList[fundingID - 1];\n    }\n\n    /**\n        @notice A floating-rate bond is no longer active if its principalPerToken becomes 0,\n                which occurs when the corresponding deposit is completely withdrawn. When\n                such a deposit is topped up, a new Funding struct and floating-rate bond will\n                be created.\n        @param fundingID The ID of the floating-rate bond\n        @return True if the funding is active, false otherwise\n     */\n    function fundingIsActive(uint256 fundingID) external view returns (bool) {\n        return _fundingIsActive(fundingID);\n    }\n\n    /**\n        @notice Returns the income index of the money market. The income index is\n                a non-decreasing value that can be used to determine the amount of\n                interest earned during a period.\n        @return The income index\n     */\n    function moneyMarketIncomeIndex() external returns (uint256) {\n        return moneyMarket.incomeIndex();\n    }\n\n    /**\n        Internal action functions\n     */\n\n    /**\n        @dev See {deposit}\n     */\n    function _deposit(\n        address sender,\n        uint256 depositAmount,\n        uint256 maturationTimestamp,\n        bool rollover\n    ) internal virtual returns (uint256 depositID, uint256 interestAmount) {\n        (depositID, interestAmount) = _depositRecordData(\n            sender,\n            depositAmount,\n            maturationTimestamp\n        );\n        _depositTransferFunds(sender, depositAmount, rollover);\n    }\n\n    function _depositRecordData(\n        address sender,\n        uint256 depositAmount,\n        uint256 maturationTimestamp\n    ) internal virtual returns (uint256 depositID, uint256 interestAmount) {\n        // Ensure input is valid\n        require(\n            depositAmount >= MinDepositAmount,\n            \"DInterest: Deposit amount too small\"\n        );\n        uint256 depositPeriod = maturationTimestamp - block.timestamp;\n        require(\n            depositPeriod <= MaxDepositPeriod,\n            \"DInterest: Deposit period too long\"\n        );\n\n        // Calculate interest\n        interestAmount = calculateInterestAmount(depositAmount, depositPeriod);\n        require(interestAmount > 0, \"DInterest: interestAmount == 0\");\n\n        // Calculate fee\n        depositID = deposits.length + 1;\n        uint256 feeAmount =\n            feeModel.getInterestFeeAmount(\n                address(this),\n                depositID,\n                interestAmount\n            );\n        interestAmount -= feeAmount;\n\n        // Record deposit data\n        deposits.push(\n            Deposit({\n                virtualTokenTotalSupply: depositAmount + interestAmount,\n                interestRate: interestAmount.decdiv(depositAmount),\n                feeRate: feeAmount.decdiv(interestAmount),\n                maturationTimestamp: maturationTimestamp,\n                depositTimestamp: block.timestamp,\n                fundingID: 0,\n                averageRecordedIncomeIndex: moneyMarket.incomeIndex()\n            })\n        );\n\n        // Update global values\n        totalDeposit += depositAmount;\n        totalInterestOwed += interestAmount;\n        totalFeeOwed += feeAmount;\n\n        // Mint depositNFT\n        depositNFT.mint(sender, depositID);\n\n        // Vest MPH to sender\n        mphMinter.createVestForDeposit(sender, depositID);\n\n        // Emit event\n        emit EDeposit(\n            sender,\n            depositID,\n            depositAmount,\n            interestAmount,\n            feeAmount,\n            maturationTimestamp\n        );\n    }\n\n    function _depositTransferFunds(\n        address sender,\n        uint256 depositAmount,\n        bool rollover\n    ) internal virtual {\n        // Only transfer funds from sender if it's not a rollover\n        // because if it is the funds are already in the contract\n        if (!rollover) {\n            // Transfer `depositAmount` stablecoin to DInterest\n            stablecoin.safeTransferFrom(sender, address(this), depositAmount);\n\n            // Lend `depositAmount` stablecoin to money market\n            stablecoin.safeApprove(address(moneyMarket), depositAmount);\n            moneyMarket.deposit(depositAmount);\n        }\n    }\n\n    /**\n        @dev See {topupDeposit}\n     */\n    function _topupDeposit(\n        address sender,\n        uint256 depositID,\n        uint256 depositAmount\n    ) internal virtual returns (uint256 interestAmount) {\n        interestAmount = _topupDepositRecordData(\n            sender,\n            depositID,\n            depositAmount\n        );\n        _topupDepositTransferFunds(sender, depositAmount);\n    }\n\n    function _topupDepositRecordData(\n        address sender,\n        uint256 depositID,\n        uint256 depositAmount\n    ) internal virtual returns (uint256 interestAmount) {\n        Deposit memory depositEntry = _getDeposit(depositID);\n        require(\n            depositNFT.ownerOf(depositID) == sender,\n            \"DInterest: not owner\"\n        );\n\n        // underflow check prevents topups after maturation\n        uint256 depositPeriod =\n            depositEntry.maturationTimestamp - block.timestamp;\n\n        // Calculate interest\n        interestAmount = calculateInterestAmount(depositAmount, depositPeriod);\n        require(interestAmount > 0, \"DInterest: interestAmount == 0\");\n\n        // Calculate fee\n        uint256 feeAmount =\n            feeModel.getInterestFeeAmount(\n                address(this),\n                depositID,\n                interestAmount\n            );\n        interestAmount -= feeAmount;\n\n        // Update deposit struct\n        uint256 currentDepositAmount =\n            depositEntry.virtualTokenTotalSupply.decdiv(\n                depositEntry.interestRate + PRECISION\n            );\n        uint256 currentInterestAmount =\n            depositEntry.virtualTokenTotalSupply - currentDepositAmount;\n        depositEntry.virtualTokenTotalSupply += depositAmount + interestAmount;\n        depositEntry.interestRate =\n            (PRECISION *\n                interestAmount +\n                currentDepositAmount *\n                depositEntry.interestRate) /\n            (depositAmount + currentDepositAmount);\n        depositEntry.feeRate =\n            (PRECISION *\n                feeAmount +\n                currentInterestAmount *\n                depositEntry.feeRate) /\n            (interestAmount + currentInterestAmount);\n        uint256 sumOfRecordedDepositAmountDivRecordedIncomeIndex =\n            (currentDepositAmount * EXTRA_PRECISION) /\n                depositEntry.averageRecordedIncomeIndex +\n                (depositAmount * EXTRA_PRECISION) /\n                moneyMarket.incomeIndex();\n        depositEntry.averageRecordedIncomeIndex =\n            ((depositAmount + currentDepositAmount) * EXTRA_PRECISION) /\n            sumOfRecordedDepositAmountDivRecordedIncomeIndex;\n\n        deposits[depositID - 1] = depositEntry;\n\n        // Update global values\n        totalDeposit += depositAmount;\n        totalInterestOwed += interestAmount;\n        totalFeeOwed += feeAmount;\n\n        // Update vest\n        mphMinter.updateVestForDeposit(\n            depositID,\n            currentDepositAmount,\n            depositAmount\n        );\n\n        // Emit event\n        emit ETopupDeposit(\n            sender,\n            depositID,\n            depositAmount,\n            interestAmount,\n            feeAmount\n        );\n    }\n\n    function _topupDepositTransferFunds(address sender, uint256 depositAmount)\n        internal\n        virtual\n    {\n        // Transfer `depositAmount` stablecoin to DInterest\n        stablecoin.safeTransferFrom(sender, address(this), depositAmount);\n\n        // Lend `depositAmount` stablecoin to money market\n        stablecoin.safeApprove(address(moneyMarket), depositAmount);\n        moneyMarket.deposit(depositAmount);\n    }\n\n    /**\n        @dev See {rolloverDeposit}\n     */\n    function _rolloverDeposit(\n        address sender,\n        uint256 depositID,\n        uint256 maturationTimestamp\n    ) internal virtual returns (uint256 newDepositID, uint256 interestAmount) {\n        // withdraw from existing deposit\n        uint256 withdrawnStablecoinAmount =\n            _withdraw(sender, depositID, type(uint256).max, false, true);\n\n        // deposit funds into a new deposit\n        (newDepositID, interestAmount) = _deposit(\n            sender,\n            withdrawnStablecoinAmount,\n            maturationTimestamp,\n            true\n        );\n\n        emit ERolloverDeposit(sender, depositID, newDepositID);\n    }\n\n    /**\n        @dev See {withdraw}\n        @param rollover True if being called from {_rolloverDeposit}, false otherwise\n     */\n    function _withdraw(\n        address sender,\n        uint256 depositID,\n        uint256 virtualTokenAmount,\n        bool early,\n        bool rollover\n    ) internal virtual returns (uint256 withdrawnStablecoinAmount) {\n        (\n            uint256 withdrawAmount,\n            uint256 feeAmount,\n            uint256 fundingInterestAmount,\n            uint256 refundAmount\n        ) = _withdrawRecordData(sender, depositID, virtualTokenAmount, early);\n        return\n            _withdrawTransferFunds(\n                sender,\n                _getDeposit(depositID).fundingID,\n                withdrawAmount,\n                feeAmount,\n                fundingInterestAmount,\n                refundAmount,\n                rollover\n            );\n    }\n\n    function _withdrawRecordData(\n        address sender,\n        uint256 depositID,\n        uint256 virtualTokenAmount,\n        bool early\n    )\n        internal\n        virtual\n        returns (\n            uint256 withdrawAmount,\n            uint256 feeAmount,\n            uint256 fundingInterestAmount,\n            uint256 refundAmount\n        )\n    {\n        // Verify input\n        require(virtualTokenAmount > 0, \"DInterest: 0 amount\");\n        Deposit memory depositEntry = _getDeposit(depositID);\n        require(\n            block.timestamp > depositEntry.depositTimestamp,\n            \"DInterest: Deposited in same block\"\n        );\n        if (early) {\n            require(\n                block.timestamp < depositEntry.maturationTimestamp,\n                \"DInterest: mature\"\n            );\n        } else {\n            require(\n                block.timestamp >= depositEntry.maturationTimestamp,\n                \"DInterest: immature\"\n            );\n        }\n        require(\n            depositNFT.ownerOf(depositID) == sender,\n            \"DInterest: not owner\"\n        );\n\n        // Check if withdrawing all funds\n        if (virtualTokenAmount > depositEntry.virtualTokenTotalSupply) {\n            virtualTokenAmount = depositEntry.virtualTokenTotalSupply;\n        }\n\n        // Compute token amounts\n        uint256 depositAmount =\n            virtualTokenAmount.decdiv(depositEntry.interestRate + PRECISION);\n        {\n            uint256 interestAmount =\n                early ? 0 : virtualTokenAmount - depositAmount;\n            withdrawAmount = depositAmount + interestAmount;\n            feeAmount = interestAmount.decmul(depositEntry.feeRate);\n        }\n\n        if (early) {\n            // apply fee to withdrawAmount\n            uint256 earlyWithdrawFee =\n                feeModel.getEarlyWithdrawFeeAmount(\n                    address(this),\n                    depositID,\n                    withdrawAmount\n                );\n            feeAmount += earlyWithdrawFee;\n            withdrawAmount -= earlyWithdrawFee;\n        }\n\n        // Update global values\n        totalDeposit -= depositAmount;\n        totalInterestOwed -= virtualTokenAmount - depositAmount;\n        totalFeeOwed -= (virtualTokenAmount - depositAmount).decmul(\n            depositEntry.feeRate\n        );\n\n        // If deposit was funded, compute funding interest payout\n        if (depositEntry.fundingID > 0) {\n            Funding storage funding = _getFunding(depositEntry.fundingID);\n\n            // Compute funded deposit amount before withdrawal\n            uint256 fundingTokenTotalSupply =\n                fundingMultitoken.totalSupply(depositEntry.fundingID);\n            uint256 recordedFundedPrincipalAmount =\n                (fundingTokenTotalSupply * funding.principalPerToken) /\n                    ULTRA_PRECISION;\n            uint256 totalPrincipal =\n                _depositVirtualTokenToPrincipal(\n                    depositID,\n                    depositEntry.virtualTokenTotalSupply\n                );\n\n            // Shrink funding principal per token value\n            uint256 totalPrincipalDecrease =\n                virtualTokenAmount +\n                    (virtualTokenAmount - depositAmount).decmul(\n                        depositEntry.feeRate\n                    );\n            if (\n                totalPrincipal <=\n                totalPrincipalDecrease + recordedFundedPrincipalAmount\n            ) {\n                // Not enough unfunded principal, need to decrease funding principal per token value\n                funding.principalPerToken =\n                    (funding.principalPerToken *\n                        (totalPrincipal - totalPrincipalDecrease)) /\n                    recordedFundedPrincipalAmount;\n            }\n\n            // Compute interest payout + refund\n            // and update relevant state\n            (\n                fundingInterestAmount,\n                refundAmount\n            ) = _computeAndUpdateFundingInterestAfterWithdraw(\n                depositEntry.fundingID,\n                recordedFundedPrincipalAmount,\n                early\n            );\n        }\n\n        // Burn `virtualTokenAmount` deposit virtual tokens\n        _getDeposit(depositID).virtualTokenTotalSupply -= virtualTokenAmount;\n\n        // Emit event\n        emit EWithdraw(sender, depositID, virtualTokenAmount, feeAmount);\n    }\n\n    function _withdrawTransferFunds(\n        address sender,\n        uint256 fundingID,\n        uint256 withdrawAmount,\n        uint256 feeAmount,\n        uint256 fundingInterestAmount,\n        uint256 refundAmount,\n        bool rollover\n    ) internal virtual returns (uint256 withdrawnStablecoinAmount) {\n        // Withdraw funds from money market\n        // Withdraws principal together with funding interest to save gas\n        if (rollover) {\n            // Rollover mode, don't withdraw `withdrawAmount` from moneyMarket\n\n            // We do this because feePlusFundingInterest might\n            // be slightly less due to rounding\n            uint256 feePlusFundingInterest =\n                moneyMarket.withdraw(feeAmount + fundingInterestAmount);\n            if (feePlusFundingInterest >= feeAmount + fundingInterestAmount) {\n                // enough to pay everything, if there's extra give to feeAmount\n                feeAmount = feePlusFundingInterest - fundingInterestAmount;\n            } else if (feePlusFundingInterest >= feeAmount) {\n                // enough to pay fee, give remainder to fundingInterestAmount\n                fundingInterestAmount = feePlusFundingInterest - feeAmount;\n            } else {\n                // not enough to pay fee, give everything to fee\n                feeAmount = feePlusFundingInterest;\n                fundingInterestAmount = 0;\n            }\n\n            // we're keeping the withdrawal amount in the money market\n            withdrawnStablecoinAmount = withdrawAmount;\n        } else {\n            uint256 actualWithdrawnAmount =\n                moneyMarket.withdraw(\n                    withdrawAmount + feeAmount + fundingInterestAmount\n                );\n\n            // We do this because `actualWithdrawnAmount` might\n            // be slightly less due to rounding\n            withdrawnStablecoinAmount = withdrawAmount;\n            if (\n                actualWithdrawnAmount >=\n                withdrawAmount + feeAmount + fundingInterestAmount\n            ) {\n                // enough to pay everything, if there's extra give to feeAmount\n                feeAmount =\n                    actualWithdrawnAmount -\n                    withdrawAmount -\n                    fundingInterestAmount;\n            } else if (actualWithdrawnAmount >= withdrawAmount + feeAmount) {\n                // enough to pay withdrawal + fee + remainder\n                // give remainder to funding interest\n                fundingInterestAmount =\n                    actualWithdrawnAmount -\n                    withdrawAmount -\n                    feeAmount;\n            } else if (actualWithdrawnAmount >= withdrawAmount) {\n                // enough to pay withdrawal + remainder\n                // give remainder to fee\n                feeAmount = actualWithdrawnAmount - withdrawAmount;\n            } else {\n                // not enough to pay withdrawal\n                // give everything to withdrawal\n                withdrawnStablecoinAmount = actualWithdrawnAmount;\n            }\n\n            if (withdrawnStablecoinAmount > 0) {\n                stablecoin.safeTransfer(sender, withdrawnStablecoinAmount);\n            }\n        }\n\n        // Send `feeAmount` stablecoin to feeModel beneficiary\n        if (feeAmount > 0) {\n            stablecoin.safeTransfer(feeModel.beneficiary(), feeAmount);\n        }\n\n        // Distribute `fundingInterestAmount` stablecoins to funders\n        if (fundingInterestAmount > 0) {\n            stablecoin.safeApprove(\n                address(fundingMultitoken),\n                fundingInterestAmount\n            );\n            fundingMultitoken.distributeDividends(\n                fundingID,\n                address(stablecoin),\n                fundingInterestAmount\n            );\n            // Mint funder rewards\n            if (fundingInterestAmount >= refundAmount) {\n                mphMinter.distributeFundingRewards(\n                    fundingID,\n                    fundingInterestAmount - refundAmount\n                );\n            }\n        }\n    }\n\n    /**\n        @dev See {fund}\n     */\n    function _fund(\n        address sender,\n        uint256 depositID,\n        uint256 fundAmount\n    ) internal virtual returns (uint256 fundingID) {\n        uint256 actualFundAmount;\n        (fundingID, actualFundAmount) = _fundRecordData(\n            sender,\n            depositID,\n            fundAmount\n        );\n        _fundTransferFunds(sender, actualFundAmount);\n    }\n\n    function _fundRecordData(\n        address sender,\n        uint256 depositID,\n        uint256 fundAmount\n    ) internal virtual returns (uint256 fundingID, uint256 actualFundAmount) {\n        Deposit storage depositEntry = _getDeposit(depositID);\n\n        (bool isNegative, uint256 surplusMagnitude) = surplus();\n        require(isNegative, \"DInterest: No deficit available\");\n\n        (isNegative, surplusMagnitude) = rawSurplusOfDeposit(depositID);\n        require(isNegative, \"DInterest: No deficit available\");\n        if (fundAmount > surplusMagnitude) {\n            fundAmount = surplusMagnitude;\n        }\n\n        // Create funding struct if one doesn't exist\n        uint256 incomeIndex = moneyMarket.incomeIndex();\n        require(incomeIndex > 0, \"DInterest: incomeIndex == 0\");\n        uint256 totalPrincipal =\n            _depositVirtualTokenToPrincipal(\n                depositID,\n                depositEntry.virtualTokenTotalSupply\n            );\n        uint256 totalPrincipalToFund;\n        fundingID = depositEntry.fundingID;\n        uint256 mintTokenAmount;\n        if (fundingID == 0 || _getFunding(fundingID).principalPerToken == 0) {\n            // The first funder, create struct\n            fundingList.push(\n                Funding({\n                    depositID: depositID,\n                    recordedMoneyMarketIncomeIndex: incomeIndex,\n                    principalPerToken: ULTRA_PRECISION\n                })\n            );\n            fundingID = fundingList.length;\n            depositEntry.fundingID = fundingID;\n            totalPrincipalToFund =\n                (totalPrincipal * fundAmount) /\n                surplusMagnitude;\n            mintTokenAmount = totalPrincipalToFund;\n        } else {\n            // Not the first funder\n            // Trigger interest payment for existing funders\n            _payInterestToFunders(fundingID);\n\n            // Compute amount of principal to fund\n            uint256 principalPerToken =\n                _getFunding(fundingID).principalPerToken;\n            uint256 unfundedPrincipalAmount =\n                totalPrincipal -\n                    (fundingMultitoken.totalSupply(fundingID) *\n                        principalPerToken) /\n                    ULTRA_PRECISION;\n            surplusMagnitude =\n                (surplusMagnitude * unfundedPrincipalAmount) /\n                totalPrincipal;\n            if (fundAmount > surplusMagnitude) {\n                fundAmount = surplusMagnitude;\n            }\n            totalPrincipalToFund =\n                (unfundedPrincipalAmount * fundAmount) /\n                surplusMagnitude;\n            mintTokenAmount =\n                (totalPrincipalToFund * ULTRA_PRECISION) /\n                principalPerToken;\n        }\n        // Mint funding multitoken\n        fundingMultitoken.mint(sender, fundingID, mintTokenAmount);\n\n        // Update relevant values\n        sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +=\n            (totalPrincipalToFund * EXTRA_PRECISION) /\n            incomeIndex;\n        totalFundedPrincipalAmount += totalPrincipalToFund;\n\n        // Emit event\n        emit EFund(sender, fundingID, fundAmount, mintTokenAmount);\n\n        actualFundAmount = fundAmount;\n    }\n\n    function _fundTransferFunds(address sender, uint256 fundAmount)\n        internal\n        virtual\n    {\n        // Transfer `fundAmount` stablecoins from msg.sender\n        stablecoin.safeTransferFrom(sender, address(this), fundAmount);\n\n        // Deposit `fundAmount` stablecoins into moneyMarket\n        stablecoin.safeApprove(address(moneyMarket), fundAmount);\n        moneyMarket.deposit(fundAmount);\n    }\n\n    /**\n        @dev See {payInterestToFunders}\n     */\n    function _payInterestToFunders(uint256 fundingID)\n        internal\n        virtual\n        returns (uint256 interestAmount)\n    {\n        Funding storage f = _getFunding(fundingID);\n        uint256 recordedMoneyMarketIncomeIndex =\n            f.recordedMoneyMarketIncomeIndex;\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\n        uint256 fundingTokenTotalSupply =\n            fundingMultitoken.totalSupply(fundingID);\n        uint256 recordedFundedPrincipalAmount =\n            (fundingTokenTotalSupply * f.principalPerToken) / ULTRA_PRECISION;\n\n        // Update funding values\n        sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex =\n            sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n            (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\n            currentMoneyMarketIncomeIndex -\n            (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\n            recordedMoneyMarketIncomeIndex;\n        f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\n\n        // Compute interest to funders\n        interestAmount =\n            (recordedFundedPrincipalAmount * currentMoneyMarketIncomeIndex) /\n            recordedMoneyMarketIncomeIndex -\n            recordedFundedPrincipalAmount;\n\n        // Distribute interest to funders\n        if (interestAmount > 0) {\n            interestAmount = moneyMarket.withdraw(interestAmount);\n            if (interestAmount > 0) {\n                stablecoin.safeApprove(\n                    address(fundingMultitoken),\n                    interestAmount\n                );\n                fundingMultitoken.distributeDividends(\n                    fundingID,\n                    address(stablecoin),\n                    interestAmount\n                );\n\n                // Mint funder rewards\n                mphMinter.distributeFundingRewards(fundingID, interestAmount);\n            }\n        }\n    }\n\n    /**\n        @dev Used in {_withdraw}. Computes the amount of interest to distribute\n             to the deposit's floating-rate bond holders. Also updates the Funding\n             struct associated with the floating-rate bond.\n        @param fundingID The ID of the floating-rate bond\n        @param recordedFundedPrincipalAmount The amount of principal funded before the withdrawal\n        @param early True if withdrawing before maturation, false otherwise\n        @return fundingInterestAmount The amount of interest to distribute to the floating-rate bond holders, plus the refund amount\n        @return refundAmount The amount of refund caused by an early withdraw\n     */\n    function _computeAndUpdateFundingInterestAfterWithdraw(\n        uint256 fundingID,\n        uint256 recordedFundedPrincipalAmount,\n        bool early\n    )\n        internal\n        virtual\n        returns (uint256 fundingInterestAmount, uint256 refundAmount)\n    {\n        Funding storage f = _getFunding(fundingID);\n        uint256 recordedMoneyMarketIncomeIndex =\n            f.recordedMoneyMarketIncomeIndex;\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\n        require(\n            currentMoneyMarketIncomeIndex > 0,\n            \"DInterest: currentMoneyMarketIncomeIndex == 0\"\n        );\n        uint256 currentFundedPrincipalAmount =\n            (fundingMultitoken.totalSupply(fundingID) * f.principalPerToken) /\n                ULTRA_PRECISION;\n\n        // Update funding values\n        {\n            uint256 currentFundedPrincipalAmountDivRecordedIncomeIndex =\n                (currentFundedPrincipalAmount * EXTRA_PRECISION) /\n                    currentMoneyMarketIncomeIndex;\n            uint256 recordedFundedPrincipalAmountDivRecordedIncomeIndex =\n                (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\n                    recordedMoneyMarketIncomeIndex;\n            if (\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n                    currentFundedPrincipalAmountDivRecordedIncomeIndex >=\n                recordedFundedPrincipalAmountDivRecordedIncomeIndex\n            ) {\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex =\n                    sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n                    currentFundedPrincipalAmountDivRecordedIncomeIndex -\n                    recordedFundedPrincipalAmountDivRecordedIncomeIndex;\n            } else {\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex = 0;\n            }\n        }\n\n        f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\n        totalFundedPrincipalAmount -=\n            recordedFundedPrincipalAmount -\n            currentFundedPrincipalAmount;\n\n        // Compute interest to funders\n        fundingInterestAmount =\n            (recordedFundedPrincipalAmount * currentMoneyMarketIncomeIndex) /\n            recordedMoneyMarketIncomeIndex -\n            recordedFundedPrincipalAmount;\n\n        // Add refund to interestAmount\n        if (early) {\n            Deposit memory depositEntry = _getDeposit(f.depositID);\n            (, uint256 moneyMarketInterestRatePerSecond) =\n                interestOracle.updateAndQuery();\n            refundAmount =\n                (((recordedFundedPrincipalAmount -\n                    currentFundedPrincipalAmount) * PRECISION)\n                    .decmul(moneyMarketInterestRatePerSecond) *\n                    (depositEntry.maturationTimestamp - block.timestamp)) /\n                PRECISION;\n            uint256 maxRefundAmount =\n                (recordedFundedPrincipalAmount - currentFundedPrincipalAmount)\n                    .decdiv(\n                    PRECISION +\n                        depositEntry.interestRate +\n                        depositEntry.interestRate.decmul(depositEntry.feeRate)\n                )\n                    .decmul(\n                    depositEntry.interestRate +\n                        depositEntry.interestRate.decmul(depositEntry.feeRate)\n                );\n            refundAmount = refundAmount <= maxRefundAmount\n                ? refundAmount\n                : maxRefundAmount;\n            fundingInterestAmount += refundAmount;\n        }\n    }\n\n    /**\n        Internal getter functions\n     */\n\n    /**\n        @dev See {getDeposit}\n     */\n    function _getDeposit(uint256 depositID)\n        internal\n        view\n        returns (Deposit storage)\n    {\n        return deposits[depositID - 1];\n    }\n\n    /**\n        @dev See {getFunding}\n     */\n    function _getFunding(uint256 fundingID)\n        internal\n        view\n        returns (Funding storage)\n    {\n        return fundingList[fundingID - 1];\n    }\n\n    /**\n        @dev See {fundingIsActive}\n     */\n    function _fundingIsActive(uint256 fundingID) internal view returns (bool) {\n        return _getFunding(fundingID).principalPerToken > 0;\n    }\n\n    /**\n        @dev Converts a virtual token value into the corresponding principal value.\n             Principal refers to deposit + full interest + fee.\n        @param depositID The ID of the deposit of the virtual tokens\n        @param virtualTokenAmount The virtual token value\n        @return The corresponding principal value\n     */\n    function _depositVirtualTokenToPrincipal(\n        uint256 depositID,\n        uint256 virtualTokenAmount\n    ) internal view virtual returns (uint256) {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        uint256 depositInterestRate = depositEntry.interestRate;\n        return\n            virtualTokenAmount.decdiv(depositInterestRate + PRECISION).decmul(\n                depositInterestRate +\n                    depositInterestRate.decmul(depositEntry.feeRate) +\n                    PRECISION\n            );\n    }\n\n    /**\n        @dev See {accruedInterestOfFunding}\n     */\n    function _accruedInterestOfFunding(uint256 fundingID)\n        internal\n        virtual\n        returns (uint256 fundingInterestAmount)\n    {\n        Funding storage f = _getFunding(fundingID);\n        uint256 fundingTokenTotalSupply =\n            fundingMultitoken.totalSupply(fundingID);\n        uint256 recordedFundedPrincipalAmount =\n            (fundingTokenTotalSupply * f.principalPerToken) / ULTRA_PRECISION;\n        uint256 recordedMoneyMarketIncomeIndex =\n            f.recordedMoneyMarketIncomeIndex;\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\n        require(\n            currentMoneyMarketIncomeIndex > 0,\n            \"DInterest: currentMoneyMarketIncomeIndex == 0\"\n        );\n\n        // Compute interest to funders\n        fundingInterestAmount =\n            (recordedFundedPrincipalAmount * currentMoneyMarketIncomeIndex) /\n            recordedMoneyMarketIncomeIndex -\n            recordedFundedPrincipalAmount;\n    }\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(\n        address, /*token*/\n        address /*target*/\n    ) internal view override {\n        require(msg.sender == owner(), \"DInterest: not owner\");\n    }\n\n    /**\n        Param setters (only callable by the owner)\n     */\n    function setFeeModel(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        feeModel = IFeeModel(newValue);\n        emit ESetParamAddress(msg.sender, \"feeModel\", newValue);\n    }\n\n    function setInterestModel(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        interestModel = IInterestModel(newValue);\n        emit ESetParamAddress(msg.sender, \"interestModel\", newValue);\n    }\n\n    function setInterestOracle(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        interestOracle = IInterestOracle(newValue);\n        require(\n            interestOracle.moneyMarket() == moneyMarket,\n            \"DInterest: moneyMarket mismatch\"\n        );\n        emit ESetParamAddress(msg.sender, \"interestOracle\", newValue);\n    }\n\n    function setRewards(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        moneyMarket.setRewards(newValue);\n        emit ESetParamAddress(msg.sender, \"moneyMarket.rewards\", newValue);\n    }\n\n    function setMPHMinter(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        mphMinter = MPHMinter(newValue);\n        emit ESetParamAddress(msg.sender, \"mphMinter\", newValue);\n    }\n\n    function setMaxDepositPeriod(uint256 newValue) external onlyOwner {\n        require(newValue > 0, \"DInterest: invalid value\");\n        MaxDepositPeriod = newValue;\n        emit ESetParamUint(msg.sender, \"MaxDepositPeriod\", newValue);\n    }\n\n    function setMinDepositAmount(uint256 newValue) external onlyOwner {\n        require(newValue > 0, \"DInterest: invalid value\");\n        MinDepositAmount = newValue;\n        emit ESetParamUint(msg.sender, \"MinDepositAmount\", newValue);\n    }\n\n    function setDepositNFTBaseURI(string calldata newURI) external onlyOwner {\n        depositNFT.setBaseURI(newURI);\n    }\n\n    function setDepositNFTContractURI(string calldata newURI)\n        external\n        onlyOwner\n    {\n        depositNFT.setContractURI(newURI);\n    }\n\n    function skimSurplus(address recipient) external onlyOwner {\n        (bool isNegative, uint256 surplusMagnitude) = surplus();\n        if (!isNegative) {\n            surplusMagnitude = moneyMarket.withdraw(surplusMagnitude);\n            stablecoin.safeTransfer(recipient, surplusMagnitude);\n        }\n    }\n\n    uint256[33] private __gap;\n}\n\n\n",
        "CodeNames": [
            "DInterest.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "depositAmount",
                    "deposit"
                ],
                "Type": " Incompatability with deflationary / fee-on-transfer tokens",
                "Description": "\nThe DInterest.deposit function takes a depositAmount parameter but this parameter is not the actual transferred amount for fee-on-transfer / deflationary (or other rebasing) tokens.\n\nThe actual deposited amount might be lower than the specified depositAmount of the function parameter.\n\nThis would lead to wrong interest rate calculations on the principal.\n\n",
                "Repair": "Recommend transferring the tokens first and comparing pre-/after token balances to compute the actual deposited amount.\n\nZeframLou (88mph) acknowledged(https://github.com/code-423n4/2021-05-88mph-findings/issues/16#issuecomment-844441370):\n While this is true, we have no plans to support fee-on-transfer or rebasing tokens.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "mph",
                    "payInterestToFunders",
                    "distributeFundingRewards",
                    "withdraw",
                    "rolloverDeposit"
                ],
                "Type": " Unchecking the ownership of  mph  in function  distributeFundingRewards  could cause several critical functions to revert",
                "Description": "\nIn contract MPHMinter, the function distributeFundingRewards does not check whether the contract itself is the owner of mph. If the contract is not the owner of mph, mph.ownerMint could revert, causing functions such as withdraw, rolloverDeposit, payInterestToFunders in the contract DInterest to revert as well.\n\n",
                "Repair": "Recommend adding a mph.owner() != address(this) check as in the other functions (e.g., mintVested).\n\nZeframLou (88mph) confirmed(https://github.com/code-423n4/2021-05-88mph-findings/issues/23#issuecomment-844625823):\n Fixed in this commit(https://github.com/88mphapp/88mph-contracts/commit/026dde3d30bddedbc1eeca6c87bce4bc5b5c7ee5).\n \n\n"
            }
        ]
    }
]