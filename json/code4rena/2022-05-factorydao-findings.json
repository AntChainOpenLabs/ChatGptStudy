[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IPriceGate.sol\";\n\n/// @title A factory pattern for the simplest price gates, what's the price and who does it go to?\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract has a management key that can add new gates\n/// @dev Note passing thru the gate forwards all gas, so beneficiary can be a contract, possibly malicious\ncontract FixedPricePassThruGate is IPriceGate {\n\n    // this represents a single gate\n    struct Gate {\n        uint ethCost;  // how much does it cost to pass thru it\n        address beneficiary;  // who gets the eth that is paid\n    }\n\n    // count the gates\n    uint public numGates;\n    // array-like map of gate structs\n    mapping (uint => Gate) public gates;\n\n    /// @notice This adds a price gate to the list of available price gates\n    /// @dev Anyone can call this, adding gates that don't get connected to merkleIndex isn't useful\n    /// @param _ethCost amount of ether required to pass thru the gate\n    /// @param _beneficiary who receives the ether\n    function addGate(uint _ethCost, address _beneficiary) external {\n        // prefix operator increments then evaluates, first gate is at index 1\n        Gate storage gate = gates[++numGates];\n        gate.ethCost = _ethCost;\n        gate.beneficiary = _beneficiary;\n    }\n\n    /// @notice Get the cost of passing thru this gate\n    /// @param index which gate are we talking about?\n    /// @return _ethCost the amount of ether required to pass thru this gate\n    function getCost(uint index) override external view returns (uint _ethCost) {\n        Gate memory gate = gates[index];\n        return gate.ethCost;\n    }\n\n    /// @notice Pass thru this gate, should be called by MerkleIndex\n    /// @dev This can be called by anyone, devs can call it to test it on mainnet\n    /// @param index which gate are we passing thru?\n    function passThruGate(uint index, address) override external payable {\n        Gate memory gate = gates[index];\n        require(msg.value >= gate.ethCost, 'Please send more ETH');\n\n        // pass thru ether\n        if (msg.value > 0) {\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n            (bool sent, bytes memory data) = gate.beneficiary.call{value: gate.ethCost}(\"\");\n            require(sent, 'ETH transfer failed');\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "FixedPricePassThruGate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "passThruGate"
                ],
                "Type": " SpeedBumpPriceGate: Excess ether did not return to the user",
                "Description": "\nThe passThruGate function of the SpeedBumpPriceGate contract is used to charge NFT purchase fees.\nSince the price of NFT will change due to the previous purchase, users are likely to send more ether than the actual purchase price in order to ensure that they can purchase NFT. However, the passThruGate function did not return the excess ether, which would cause asset loss to the user.\nConsider the following scenario:\n\n1.  An NFT is sold for 0.15 eth\n2.  User A believes that the value of the NFT is acceptable within 0.3 eth, considering that someone may buy the NFT before him, so user A transfers 0.3 eth to buy the NFT\n3.  When user A's transaction is executed, the price of the NFT is 0.15 eth, but since the contract does not return excess eth, user A actually spends 0.3 eth.\n\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82\n\n\n",
                "Repair": "\n      function passThruGate(uint index, address) override external payable {\n    +  function passThruGate(uint index, address payer) override external payable {\n            uint price = getCost(index);\n            require(msg.value = price, 'Please send more ETH');\n\n            // bump up the price\n            Gate storage gate = gates[index];\n            // multiply by the price increase factor\n            gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n            // move up the reference\n            gate.lastPurchaseBlock = block.number;\n\n            // pass thru the ether\n            if (msg.value  0) {\n                // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n              (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n    +          (bool sent, bytes memory data) = gate.beneficiary.call{value: price}(\"\");\n                require(sent, 'ETH transfer failed');\n            }\n    +      if (msg.value price  0){ \n    +         (bool sent, bytes memory data) = payer.call{value: msg.value price}(\"\");\n    +          require(sent, 'ETH transfer failed');}\n        }\n\nilluzen (FactoryDAO) confirmed, but disagreed with severity(https://github.com/code-423n4/2022-05-factorydao-findings/issues/48#issuecomment-1122005082)\n\nilluzen (FactoryDAO) resolved(https://github.com/code-423n4/2022-05-factorydao-findings/issues/48#issuecomment-1145528979):\n  https://github.com/code-423n4/2022-05-factorydao/pull/4\n\nJustin Goro (judge) commented(https://github.com/code-423n4/2022-05-factorydao-findings/issues/48#issuecomment-1154647062):\n  Maintaining severity as user funds are lost.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IPriceGate.sol\";\n\n/// @title A factory pattern for the simplest price gates, what's the price and who does it go to?\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract has a management key that can add new gates\n/// @dev Note passing thru the gate forwards all gas, so beneficiary can be a contract, possibly malicious\ncontract FixedPricePassThruGate is IPriceGate {\n\n    // this represents a single gate\n    struct Gate {\n        uint ethCost;  // how much does it cost to pass thru it\n        address beneficiary;  // who gets the eth that is paid\n    }\n\n    // count the gates\n    uint public numGates;\n    // array-like map of gate structs\n    mapping (uint => Gate) public gates;\n\n    /// @notice This adds a price gate to the list of available price gates\n    /// @dev Anyone can call this, adding gates that don't get connected to merkleIndex isn't useful\n    /// @param _ethCost amount of ether required to pass thru the gate\n    /// @param _beneficiary who receives the ether\n    function addGate(uint _ethCost, address _beneficiary) external {\n        // prefix operator increments then evaluates, first gate is at index 1\n        Gate storage gate = gates[++numGates];\n        gate.ethCost = _ethCost;\n        gate.beneficiary = _beneficiary;\n    }\n\n    /// @notice Get the cost of passing thru this gate\n    /// @param index which gate are we talking about?\n    /// @return _ethCost the amount of ether required to pass thru this gate\n    function getCost(uint index) override external view returns (uint _ethCost) {\n        Gate memory gate = gates[index];\n        return gate.ethCost;\n    }\n\n    /// @notice Pass thru this gate, should be called by MerkleIndex\n    /// @dev This can be called by anyone, devs can call it to test it on mainnet\n    /// @param index which gate are we passing thru?\n    function passThruGate(uint index, address) override external payable {\n        Gate memory gate = gates[index];\n        require(msg.value >= gate.ethCost, 'Please send more ETH');\n\n        // pass thru ether\n        if (msg.value > 0) {\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n            (bool sent, bytes memory data) = gate.beneficiary.call{value: gate.ethCost}(\"\");\n            require(sent, 'ETH transfer failed');\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title A factory pattern for basic staking, put tokens in, get more tokens (potentially multiple types) out\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Anyone can create a pool, and fees are taken out of rewards\n/// @dev Maximum possible pool obligations are computed at pool-creation-time and taken from creator at that time\n/// @dev Any unclaimed rewards are claimable after the pool has ended, pool funds are accounted for separately\ncontract PermissionlessBasicPoolFactory {\n\n    // this represents a single deposit into a staking pool, used to withdraw as well\n    struct Receipt {\n        uint id;   // primary key\n        uint amountDepositedWei;  // amount of tokens originally deposited\n        uint timeDeposited;  // the time the deposit was made\n        uint timeWithdrawn;  // the time the deposit was withdrawn, or 0 if not withdrawn yet\n        address owner;  // the owner of the deposit\n    }\n\n    // this represents a single staking pool with >= 1 reward tokens\n    struct Pool {\n        uint id; // primary key\n        uint[] rewardsWeiPerSecondPerToken; // array of reward rates, this number gets multiplied by time and tokens (not wei) to determine rewards\n        uint[] rewardsWeiClaimed;  // bookkeeping of how many rewards have been paid out for each token\n        uint[] rewardFunding;  // bookkeeping of how many rewards have been supplied for each token\n        uint maximumDepositWei;  // the size of the pool, maximum sum of all deposits\n        uint totalDepositsWei;  // current sum of all deposits\n        uint numReceipts;  // number of receipts issued\n        uint startTime;  // the time that the pool begins\n        uint endTime;    // time that the pool ends\n        uint taxPerCapita;  // portion of rewards that go to the contract creator\n        address depositToken;  // token that user deposits (stakes)\n        address excessBeneficiary;  // address that is able to reclaim unused rewards\n        address[] rewardTokens;  // array of token contract addresses that stakers will receive as rewards\n        mapping (uint => Receipt) receipts;  // mapping of receipt ids to receipt structs\n    }\n\n    // simple struct for UI to display relevant data\n    struct Metadata {\n        bytes32 name;\n        bytes32 ipfsHash;\n    }\n\n    // the number of staking pools ever created\n    uint public numPools;\n\n    // the beneficiary of taxes\n    address public globalBeneficiary;\n\n    // this is the settable tax imposed on new pools, fixed at pool creation time\n    uint public globalTaxPerCapita;\n\n    // pools[poolId] = poolStruct\n    mapping (uint => Pool) public pools;\n    // metadatas[poolId] = metadataStruct\n    mapping (uint => Metadata) public metadatas;\n    // taxes[poolId] = taxesCollected[rewardIndex]\n    mapping (uint => uint[]) public taxes;\n\n    // every time a deposit happens\n    event DepositOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time a withdrawal happens\n    event WithdrawalOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time excess rewards are withdrawn\n    event ExcessRewardsWithdrawn(uint indexed poolId);\n    // every time a pool is added\n    event PoolAdded(uint indexed poolId, bytes32 indexed name, address indexed depositToken);\n\n    /// @notice Whoever deploys the contract decides who receives how much fees\n    /// @param _globalBeneficiary the address that receives the fees and can also set the fees\n    /// @param _globalTaxPerCapita the amount of the rewards that goes to the globalBeneficiary * 1000 (perCapita)\n    constructor(address _globalBeneficiary, uint _globalTaxPerCapita) {\n        globalBeneficiary = _globalBeneficiary;\n        globalTaxPerCapita = _globalTaxPerCapita;\n    }\n\n    /// @notice Create a pool and fund it\n    /// @dev Anyone may call this function, but they must fund it, having called approve on all contracts beforehand\n    /// @dev Any malicious token contracts included here will make the pool malicious, but not effect other pools\n    /// @param startTime time at which pool starts, if in past, it is set to block.timestamp \"now\"\n    /// @param maxDeposit the maximum amount of tokens that can be deposited in this pool\n    /// @param rewardsWeiPerSecondPerToken the amount of tokens given out per second per token (not wei) deposited\n    /// @param programLengthDays the amount of days the pool will be open, this with the start time determines the end time\n    /// @param depositTokenAddress the token that users will put into the pool to receive rewards\n    /// @param excessBeneficiary the recipient of any unclaimed funds in the pool\n    /// @param rewardTokenAddresses the list of token contracts that will be given out as rewards for staking\n    /// @param ipfsHash a hash of any metadata about the pool, may be incorporated into interfaces\n    /// @param name name of pool, to be used by interfaces\n    function addPool (\n        uint startTime,\n        uint maxDeposit,\n        uint[] memory rewardsWeiPerSecondPerToken,\n        uint programLengthDays,\n        address depositTokenAddress,\n        address excessBeneficiary,\n        address[] memory rewardTokenAddresses,\n        bytes32 ipfsHash,\n        bytes32 name\n    ) external {\n        Pool storage pool = pools[++numPools];\n        pool.id = numPools;\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\n        pool.endTime = pool.startTime + (programLengthDays * 1 days);\n        pool.depositToken = depositTokenAddress;\n        pool.excessBeneficiary = excessBeneficiary;\n        pool.taxPerCapita = globalTaxPerCapita;\n\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n\n        // fill out the arrays with zeros\n        for (uint i = 0; i < rewardTokenAddresses.length; i++) {\n            pool.rewardTokens.push(rewardTokenAddresses[i]);\n            pool.rewardsWeiClaimed.push(0);\n            pool.rewardFunding.push(0);\n            taxes[numPools].push(0);\n        }\n        pool.maximumDepositWei = maxDeposit;\n\n        // this must be after pool initialization above\n        fundPool(pool.id);\n\n        {\n            Metadata storage metadata = metadatas[numPools];\n            metadata.ipfsHash = ipfsHash;\n            metadata.name = name;\n        }\n        emit PoolAdded(pool.id, name, depositTokenAddress);\n    }\n\n    /// @notice Add funds to a pool\n    /// @dev This function is internal because pools cannot be underfunded, liabilities are known at pool-creation-time\n    /// @param poolId index of pool that is being funded\n    function fundPool(uint poolId) internal {\n        Pool storage pool = pools[poolId];\n        bool success = true;\n        uint amount;\n        for (uint i = 0; i < pool.rewardFunding.length; i++) {\n            amount = getMaximumRewards(poolId, i);\n            // transfer the tokens from pool-creator to this contract\n            success = success && IERC20(pool.rewardTokens[i]).transferFrom(msg.sender, address(this), amount);\n            // bookkeeping to make sure pools don't share tokens\n            pool.rewardFunding[i] += amount;\n        }\n        require(success, 'Token deposits failed');\n    }\n\n    /// @notice Compute the rewards that would be received if the receipt was cashed out now\n    /// @dev This function does not inspect whether the receipt has already been cashed out\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId the id of the receipt that we are querying\n    /// @return rewardsLocal array of rewards, one entry for each reward token\n    function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {\n        Pool storage pool = pools[poolId];\n        Receipt memory receipt = pool.receipts[receiptId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(receipt.id == receiptId, 'Uninitialized receipt');\n        uint nowish = block.timestamp;\n        if (nowish > pool.endTime) {\n            nowish = pool.endTime;\n        }\n\n        uint secondsDiff = nowish - receipt.timeDeposited;\n        uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);\n        for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n            rewardsLocal[i] = (secondsDiff * pool.rewardsWeiPerSecondPerToken[i] * receipt.amountDepositedWei) / 1e18;\n        }\n\n        return rewardsLocal;\n    }\n\n    /// @notice Add funds to a pool\n    /// @dev Anyone may call this function, it simply puts tokens in the pool and returns a receipt\n    /// @dev If deposit amount causes pool to overflow, amount is decreased so pool is full\n    /// @param poolId which pool are we talking about?\n    /// @param amount amount of tokens to deposit\n    function deposit(uint poolId, uint amount) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(block.timestamp > pool.startTime, 'Cannot deposit before pool start');\n        require(block.timestamp < pool.endTime, 'Cannot deposit after pool ends');\n        require(pool.totalDepositsWei < pool.maximumDepositWei, 'Maximum deposit already reached');\n        if (pool.totalDepositsWei + amount > pool.maximumDepositWei) {\n            amount = pool.maximumDepositWei - pool.totalDepositsWei;\n        }\n        pool.totalDepositsWei += amount;\n        pool.numReceipts++;\n\n        Receipt storage receipt = pool.receipts[pool.numReceipts];\n        receipt.id = pool.numReceipts;\n        receipt.amountDepositedWei = amount;\n        receipt.timeDeposited = block.timestamp;\n        receipt.owner = msg.sender;\n\n        bool success = IERC20(pool.depositToken).transferFrom(msg.sender, address(this), amount);\n        require(success, 'Token transfer failed');\n\n        emit DepositOccurred(poolId, pool.numReceipts, msg.sender);\n    }\n\n    /// @notice Withdraw funds from pool\n    /// @dev Only receipt owner may call this function\n    /// @dev If any of the reward tokens are malicious, this function may break\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId which receipt is being cashed in\n    function withdraw(uint poolId, uint receiptId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        Receipt storage receipt = pool.receipts[receiptId];\n        require(receipt.id == receiptId, 'Can only withdraw real receipts');\n        require(receipt.owner == msg.sender || block.timestamp > pool.endTime, 'Can only withdraw your own deposit');\n        require(receipt.timeWithdrawn == 0, 'Can only withdraw once per receipt');\n\n        // close re-entry gate\n        receipt.timeWithdrawn = block.timestamp;\n\n        uint[] memory rewards = getRewards(poolId, receiptId);\n        pool.totalDepositsWei -= receipt.amountDepositedWei;\n        bool success = true;\n\n        for (uint i = 0; i < rewards.length; i++) {\n            pool.rewardsWeiClaimed[i] += rewards[i];\n            pool.rewardFunding[i] -= rewards[i];\n            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n            uint transferAmount = rewards[i] - tax;\n            taxes[poolId][i] += tax;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n        }\n\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n        require(success, 'Token transfer failed');\n\n        emit WithdrawalOccurred(poolId, receiptId, receipt.owner);\n    }\n\n    /// @notice Withdraw any unused rewards from the pool, after it has ended\n    /// @dev Anyone can call this, as the excess beneficiary is set at pool-creation-time\n    /// @param poolId which pool are we talking about?\n    function withdrawExcessRewards(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');\n        require(block.timestamp > pool.endTime, 'Contract must reach maturity');\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint rewards = pool.rewardFunding[i];\n            pool.rewardFunding[i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(pool.excessBeneficiary, rewards);\n        }\n        require(success, 'Token transfer failed');\n        emit ExcessRewardsWithdrawn(poolId);\n    }\n\n    /// @notice Withdraw taxes from pool\n    /// @dev Anyone may call this, it just moves the taxes from this contract to the globalBeneficiary\n    /// @param poolId which pool are we talking about?\n    function withdrawTaxes(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint tax = taxes[poolId][i];\n            taxes[poolId][i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);\n        }\n        require(success, 'Token transfer failed');\n    }\n\n    /// @notice Compute maximum rewards that could be given out by a given pool\n    /// @dev This is primarily used by fundPool to compute how many tokens to take from the pool-creator\n    /// @param poolId which pool are we talking about?\n    /// @param rewardIndex index into the rewards array, to avoid passing arrays around\n    /// @return maximumRewardAmount the theoretical maximum that will be paid from this reward token, if pool fills instantly\n    function getMaximumRewards(uint poolId, uint rewardIndex) public view returns (uint) {\n        Pool storage pool = pools[poolId];\n        // rewardsPerSecondPerToken * tokens * seconds\n        return pool.rewardsWeiPerSecondPerToken[rewardIndex] * pool.maximumDepositWei * (pool.endTime - pool.startTime) / 1e18;\n    }\n\n    /// @notice Get reward data about a pool\n    /// @dev This gets all the reward-relevant fields from the struct\n    /// @param poolId which pool are we talking about?\n    /// @return rewardsWeiPerSecondPerToken reward slope array\n    /// @return rewardsWeiClaimed rewards already claimed array\n    /// @return rewardTokens array of reward token contract addresses\n    /// @return rewardFunding array of amounts of reward tokens already dispensed\n    function getRewardData(uint poolId) external view returns (uint[] memory, uint[] memory, address[] memory, uint[] memory) {\n        Pool storage pool = pools[poolId];\n        return (pool.rewardsWeiPerSecondPerToken, pool.rewardsWeiClaimed, pool.rewardTokens, pool.rewardFunding);\n    }\n\n    /// @notice Get data about a specific receipt\n    /// @dev This gets all the fields from a receipt\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId which receipt are we talking about?\n    /// @return amountDepositedWei original deposit amount\n    /// @return timeDeposited the time of original deposit\n    /// @return timeWithdrawn time when receipt was cashed in, if ever\n    /// @return owner the beneficiary of the receipt, who deposited the tokens originally?\n    function getReceipt(uint poolId, uint receiptId) external view returns (uint, uint, uint, address) {\n        Pool storage pool = pools[poolId];\n        Receipt storage receipt = pool.receipts[receiptId];\n        return (receipt.amountDepositedWei, receipt.timeDeposited, receipt.timeWithdrawn, receipt.owner);\n    }\n\n    /// @notice Change the fee factor\n    /// @dev This can only be called by the global beneficiary\n    /// @param newTaxPerCapita the new fee\n    function setGlobalTax(uint newTaxPerCapita) external {\n        require(msg.sender == globalBeneficiary, 'Only globalBeneficiary can set tax');\n        require(newTaxPerCapita < 1000, 'Tax too high');\n        globalTaxPerCapita = newTaxPerCapita;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkledrops, that is, airdrops using merkleproofs to compute eligibility\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof,\n/// @dev therefore the total liabilities of the merkle tree are untrusted and tree balances must be managed separately\ncontract MerkleDropFactory {\n    using MerkleLib for bytes32;\n\n    // the number of airdrops in this contract\n    uint public numTrees = 0;\n\n    // this represents a single airdrop\n    struct MerkleTree {\n        bytes32 merkleRoot;  // merkleroot of tree whose leaves are (address,uint) pairs representing amount owed to user\n        bytes32 ipfsHash; // ipfs hash of entire dataset, as backup in case our servers turn off...\n        address tokenAddress; // address of token that is being airdropped\n        uint tokenBalance; // amount of tokens allocated for this tree\n        uint spentTokens; // amount of tokens dispensed from this tree\n    }\n\n    // withdrawn[recipient][treeIndex] = hasUserWithdrawnAirdrop\n    mapping (address => mapping (uint => bool)) public withdrawn;\n\n    // array-like map for all ze merkle trees (airdrops)\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // every time there's a withdraw\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint value);\n\n    // every time a tree is added\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-drop\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @param newRoot root hash of merkle tree representing liabilities == (destination, value) pairs\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0,  // ain't no tokens in here yet\n            0   // ain't nobody claimed no tokens yet either\n        );\n        // you don't get to add a tree without funding it\n        depositTokens(numTrees, tokenBalance);\n        // I guess we should tell people (interfaces) what happened\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-drop\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    /// @param value amount of tokens that will be sent to destination\n    /// @param proof array of hashes bridging from leaf (hash of destination | value) to merkle root\n    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\n        // no withdrawing from uninitialized merkle trees\n        require(treeIndex <= numTrees, \"Provided merkle index doesn't exist\");\n        // no withdrawing same airdrop twice\n        require(!withdrawn[destination][treeIndex], \"You have already withdrawn your entitled token.\");\n        // compute merkle leaf, this is first element of proof\n        bytes32 leaf = keccak256(abi.encode(destination, value));\n        // storage because we edit\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root\n        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // close re-entrance gate, prevent double claims\n        withdrawn[destination][treeIndex] = true;\n        // update struct\n        tree.tokenBalance -= value;\n        tree.spentTokens += value;\n        // transfer the tokens\n        // NOTE: if the token contract is malicious this call could re-enter this function\n        // which will fail because withdrawn will be set to true\n        require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");\n        emit WithdrawalOccurred(treeIndex, destination, value);\n    }\n\n}\n\n",
        "CodeNames": [
            "FixedPricePassThruGate.sol",
            "PermissionlessBasicPoolFactory.sol",
            "MerkleDropFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n        for (uint i = 0; i < rewards.length; i++) {\n            pool.rewardsWeiClaimed[i] += rewards[i];\n            pool.rewardFunding[i] -= rewards[i];\n            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n            uint transferAmount = rewards[i] tax;\n            taxes[poolId][i] += tax;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n        }\n\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n        require(success, 'Token transfer failed');\n"
                ],
                "Type": " DoS: Blacklisted user may prevent  withdrawExcessRewards() ",
                "Description": "\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L242-L256\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L234\n\n\nIf one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call withdraw() for that token.\n\nThe impact of one user not being able to call withdraw() is that the owner will now never be able to call withdrawExcessRewards() and therefore lock not only the users rewards and deposit but also and excess rewards attributed to the owner.\n\nThus, one malicious user may deliberately get them selves blacklisted to prevent the owner from claiming the final rewards. Since the attacker may do this with negligible balance in their deposit() this attack is very cheap.\n\n\nIt is possible for IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount); to fail for numerous reasons. Such as if a user has been blacklisted (in certain ERC20 tokens) or if a token is paused or there is an attack and the token is stuck.\n\nThis will prevent withdraw() from being called.\n\nsolidity\n        for (uint i = 0; i < rewards.length; i++) {\n            pool.rewardsWeiClaimed[i] += rewards[i];\n            pool.rewardFunding[i] -= rewards[i];\n            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n            uint transferAmount = rewards[i] tax;\n            taxes[poolId][i] += tax;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n        }\n\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n        require(success, 'Token transfer failed');\n\n\nSince line 245 of withdrawExcessRewards() requires that require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');, if one single user is unable to withdraw then it is impossible for the owner to claim the excess rewards and they are forever stuck in the contract.\n\n",
                "Repair": "\nConsider allowing withdrawExcessRewards() to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria.\n\nilluzen (FactoryDAO) confirmed, disagreed with severity and commented(https://github.com/code-423n4/2022-05-factorydao-findings/issues/57#issuecomment-1122022055):\n  Kind of a duplicate, but I like this angle better. However, malicious token contracts are explicitly considered in the contract as an acceptable risk. Will probably just wrap transfers in a try catch\n\nilluzen (FactoryDAO) resolved(https://github.com/code-423n4/2022-05-factorydao-findings/issues/57#issuecomment-1145530196):\n  https://github.com/code-423n4/2022-05-factorydao/pull/2\n\nJustin Goro (judge) commented(https://github.com/code-423n4/2022-05-factorydao-findings/issues/57#issuecomment-1154659729):\n  Maintaining severity as deposit tokens at risk.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkledrops, that is, airdrops using merkleproofs to compute eligibility\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof,\n/// @dev therefore the total liabilities of the merkle tree are untrusted and tree balances must be managed separately\ncontract MerkleDropFactory {\n    using MerkleLib for bytes32;\n\n    // the number of airdrops in this contract\n    uint public numTrees = 0;\n\n    // this represents a single airdrop\n    struct MerkleTree {\n        bytes32 merkleRoot;  // merkleroot of tree whose leaves are (address,uint) pairs representing amount owed to user\n        bytes32 ipfsHash; // ipfs hash of entire dataset, as backup in case our servers turn off...\n        address tokenAddress; // address of token that is being airdropped\n        uint tokenBalance; // amount of tokens allocated for this tree\n        uint spentTokens; // amount of tokens dispensed from this tree\n    }\n\n    // withdrawn[recipient][treeIndex] = hasUserWithdrawnAirdrop\n    mapping (address => mapping (uint => bool)) public withdrawn;\n\n    // array-like map for all ze merkle trees (airdrops)\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // every time there's a withdraw\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint value);\n\n    // every time a tree is added\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-drop\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @param newRoot root hash of merkle tree representing liabilities == (destination, value) pairs\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0,  // ain't no tokens in here yet\n            0   // ain't nobody claimed no tokens yet either\n        );\n        // you don't get to add a tree without funding it\n        depositTokens(numTrees, tokenBalance);\n        // I guess we should tell people (interfaces) what happened\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-drop\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    /// @param value amount of tokens that will be sent to destination\n    /// @param proof array of hashes bridging from leaf (hash of destination | value) to merkle root\n    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\n        // no withdrawing from uninitialized merkle trees\n        require(treeIndex <= numTrees, \"Provided merkle index doesn't exist\");\n        // no withdrawing same airdrop twice\n        require(!withdrawn[destination][treeIndex], \"You have already withdrawn your entitled token.\");\n        // compute merkle leaf, this is first element of proof\n        bytes32 leaf = keccak256(abi.encode(destination, value));\n        // storage because we edit\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root\n        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // close re-entrance gate, prevent double claims\n        withdrawn[destination][treeIndex] = true;\n        // update struct\n        tree.tokenBalance -= value;\n        tree.spentTokens += value;\n        // transfer the tokens\n        // NOTE: if the token contract is malicious this call could re-enter this function\n        // which will fail because withdrawn will be set to true\n        require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");\n        emit WithdrawalOccurred(treeIndex, destination, value);\n    }\n\n}\n\n",
        "CodeNames": [
            "MerkleDropFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "withdraw"
                ],
                "Type": " MerkleVesting withdrawal does not verify that tokens were transferred successfully",
                "Description": "\nAcross the codebase, the protocol is usually checking that ERC20 transfers have succeeded by checking their return value.\nThis check is missing in MerkleVesting's withdraw function.\n\n\nIf for some reason the ERC20 transfer is temporarily failing, the user would totally lose his allocation and funds.\nAll the state variables would already have been updated at this stage, so he can't call withdraw again.\nThere is no way to withdraw these locked tokens.\n\n\nAt the last point of withdraw, the function is sending(https://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleVesting.sol#L173) the funds to the user, and does not check the return value whether it has succeeded:\n\n            IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal);\n\nNote that this is (nicely and rightfully) done after all the state variables have been updated.\nAs the return value of the external call is not checked, if it has failed, the contract wouldn't know about it, and the function will finish \"successfully\".\n\n",
                "Repair": "\nAs done throughout the rest of the protocol, add a check that verifies that the transfer has succeeded.\n\n\nilluzen (FactoryDAO) acknowledged, disagreed with severity and commented(https://github.com/code-423n4/2022-05-factorydao-findings/issues/130#issuecomment-1122570209):\n  Debatable, since requiring successful transfer means we can't do non-standard tokens like USDT. Also, tokens could be malicious and simply lie about the success.\n\nJustin Goro (judge) commented(https://github.com/code-423n4/2022-05-factorydao-findings/issues/130#issuecomment-1155855225):\n  Regarding the non standard tokens that don't return bools, the common approach to performing a low level call with \n \n (bool success, _)  = address(token).call(//etc\n \n allows for transfers to be validated for USDT.\n \n Severity will stand because this function represents user funds.\n \n\n\n\n*\n\n \n\n"
            }
        ]
    }
]