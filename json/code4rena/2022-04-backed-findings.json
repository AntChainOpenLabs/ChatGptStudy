[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}\n\n\n",
        "CodeNames": [
            "NFTLoanFacilitator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "lend"
                ],
                "Type": " Can force borrower to pay huge interest",
                "Description": "\nNFTLoanFacilitator.sol#L148(https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L148)<br\n\nThe loan amount is used as a min loan amount. It can be matched as high as possible (realistically up to the collateral NFT's worth to remain in profit) and the borrower has to pay interest on the entire amount instead of just on the desired loan amount when the loan was created.\n\n\n*   User needs a 10k USDC loan, NFTs are illiquid and they only have a BAYC worth 350k$. So buying another NFT worth roughly the desired 10k$ is not feasible. They will put the entire 350k$ BAYC as collateral for the 10k USDC loan.\n*   A lender matches the loan calling lend with 350k USDC.\n*   The borrower now has to pay interest on the entire 350k USDC even though they only wanted a 10k loan. Otherwise, they risk losing their collateral. Their effective rate on their 10k loan is 35x higher.\n\n",
                "Repair": "\nThe loan amount should not have min amount semantics.\nWhen someone wants to get a loan, they specify a certain amount they need, they don't want to receive and pay interest on more than that.\n\nwilsoncusack (Backed Protocol) disputed and commented(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1090194769):\n  The ability to increase the loan amount is seen as a feature of the protocol, not a bug.\n\ngzeon (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1100042414):\n  While a larger loan size is strictly beneficial to the borrower, the higher interest payment it entitled is not. The warden suggested a valid situation that may cost the user more than intended. Considering the amount lost is bounded because the lender carry more risk for a larger loan, downgrading this to Medium risk for the sponsor to consider a maxLoanAmount parameter.\n\ngzeon (judge) increased severity to High and commented(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1100054828):\n  After considering #9(https://github.com/code-423n4/2022-04-backed-findings/issues/9) bringing up the loan origination fee, I believe this is a High risk issue for the protocol to not have a maxLoanAmount parameter.\n\nwilsoncusack (Backed Protocol) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1100502129):\n IMO it does not make sense to label this as High severity. This is not an exploit but is just the protocol working exactly as described in the README. \n\ngzeon (judge) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1100536164):\n  From README\n  Perpetual lender buyout: a lender can be boughtout at any time by a new lender who meets the existing terms and beats at least one term by at least 10%, e.g. 10% longer duration, 10% higher loan amount, 10% lower interest. The new lender pays the previous lender their principal + any interest owed. The loan duration restarts on buyout.\n \n I don't agree that allowing higher loan amount necessarily means the loan amount needs to be unbounded. Given the increased interest and origination fee, a higher loan amount is not necessarily \"beating existing terms\" as described in the README.\n\nwilsoncusack (Backed Protocol) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1100639005):\n  It certainly doesn't necessarily mean that but it is how we chose to implement it and I think the description is clear that there is no cap. We define \"beating\" as having one of those values changed by at least 10% and so I think it is beating as described by the readme. \n\n Nonetheless, I appreciate your drawing focus again to this point ([we discussed on twitter(https://twitter.com/WilsonCusack/status/1511683701800853506?s=20&t=SGd-Grp3L5yrL48Y3r_tEw) with our community during audit as this became a point of interest, and have of course considered this idea when designing the protocol at the outset). We will again consider adding a Boolean flag to each loan as to whether the borrower allows loan amount increases \n\nwilsoncusack (Backed Protocol) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1100866532):\n  Respect judge to have final say, but since this is going public want to make sure our take on this is clear. \n \n We believe the protocol design was clearly communicated in the README, including origination fee and the possibility for perpetually increasing loan amount. We think there is no \"exploit\" here, just people pointing out potential downsides to how the protocol is designed (as one might point out problems of impermanent loss with an AMM.) We view these as QA reports. We are interested in this feedback and listening to it in that we want to listen to potential users and make sure our protocol appeals to as many people as possible. \n\ngzeon (judge) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1100871827):\n  I consider this as an exploit because asset can be lost. Combining unbounded loan amount, interest rate and origination fee (max 5%), a malicious lender can grief borrower with limited risk and get a chance to seize the collateral as demonstrated in the POC. \n \n The fact that the code is working as described in README is irrelevant if it is going to make user lose their asset. If this is going to stay as a protocol design, I recommend to clearly communicate the risk of unbounded loan amount which is lacking in the contest repo.\n\nwilsoncusack (Backed Protocol) resolved(https://github.com/code-423n4/2022-04-backed-findings/issues/24#issuecomment-1105499280)\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n} else {\n    ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n        msg.sender,\n        currentLoanOwner,\n        accumulatedInterest + previousLoanAmount\n    );\n}\nILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n",
                    "//solidity\nThe original lender/borrower calls the following `repayAndCloseLoan()` function so that they receive their collateral NFT from the protocol.\n\nfunction repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n    Loan storage loan = loanInfo[loanId];\n\n\n    uint256 interest = _interestOwed(\n        loan.loanAmount,\n        loan.lastAccumulatedTimestamp,\n        loan.perAnumInterestRate,\n        loan.accumulatedInterest\n    );\n    address lender = IERC721(lendTicketContract).ownerOf(loanId);\n    loan.closed = true;\n    ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n    IERC721(loan.collateralContractAddress).safeTransferFrom(\n        address(this),\n        IERC721(borrowTicketContract).ownerOf(loanId),\n        loan.collateralTokenId\n    );\n\n\n    emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n    emit Close(loanId);\n}\n"
                ],
                "Type": " Borrower can be their own lender and steal funds from buyout due to reentrancy",
                "Description": "\nNFTLoanFacilitator.sol#L214-L221(https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L214-L221)<br\nNFTLoanFacilitator.sol#L230-L250(https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L230-L250)\n\nIf borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.\n\n\nThis exploit requires that the loanAssetContractAddress token transfers control to the receiver.\n\n\n*   Borrower creates loan with createLoan().\n*   The same Borrower calls lend(), funding their own loan. The Borrower receives the lend ticket, and funds are transferred to themself.\n*   A new lender attempts to buy out the loan. The original loan amount + accruedInterest are sent to the original lender (same person as borrower).\n*   Due to lack of checks-effects-interactions pattern, the borrower is able to immediately call repayAndCloseLoan() before the lend ticket is transferred to the new lender.\n\nThe following code illustrates that the new lender sends funds to the original lender prior to receiving the lend ticket in return.\nsolidity\n} else {\n    ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n        msg.sender,\n        currentLoanOwner,\n        accumulatedInterest + previousLoanAmount\n    );\n}\nILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n\n\nsolidity\nThe original lender/borrower calls the following repayAndCloseLoan() function so that they receive their collateral NFT from the protocol.\n\nfunction repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n    Loan storage loan = loanInfo[loanId];\n\n\n    uint256 interest = _interestOwed(\n        loan.loanAmount,\n        loan.lastAccumulatedTimestamp,\n        loan.perAnumInterestRate,\n        loan.accumulatedInterest\n    );\n    address lender = IERC721(lendTicketContract).ownerOf(loanId);\n    loan.closed = true;\n    ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n    IERC721(loan.collateralContractAddress).safeTransferFrom(\n        address(this),\n        IERC721(borrowTicketContract).ownerOf(loanId),\n        loan.collateralTokenId\n    );\n\n\n    emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n    emit Close(loanId);\n}\n\n\nFinally, the new lender receives the lend ticket that has no utility at this point. The borrower now possesses the NFT, original loan amount, and accrued interest.\n\n",
                "Repair": "\nMove the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely.\n\nIf desired, also require that the lender cannot be the same account as the borrower of a loan.\n\nwilsoncusack (Backed Protocol) confirmed and commented(https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1091968833):\n  Borrower would need to convince lender to use an ERC20 with this malicious callback, but yes is legit.\n\n  malicious ERC20<br\n - transfers value to borrow ticket holder<br\n - calls repay and close loan (would need funds available to do so, but still nets up)\n\nwilsoncusack (Backed Protocol) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1092334816):\n  Possibility of an ERC777 loan asset warrants this as high, I think. Even though the warden didn't suggest that vector.\n\nwilsoncusack (Backed Protocol) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1092724315):\n  Scratch that, I think ERC777 not possible because our contract isn't setup to receive them.\n\nwilsoncusack (Backed Protocol) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1092733859):\n  er erc777 does work because reception ack is not needed in the normal case.\n\nwilsoncusack (Backed Protocol) resolved(https://github.com/code-423n4/2022-04-backed-findings/issues/85#event-6430345280)\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1100148955):\n  Sponsor confirmed.\n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\nimport {NFTLoanTicket} from './NFTLoanTicket.sol';\nimport {NFTLoanFacilitator} from './NFTLoanFacilitator.sol';\nimport {NFTLoansTicketDescriptor} from './descriptors/NFTLoansTicketDescriptor.sol';\n\ncontract LendTicket is NFTLoanTicket, ILendTicket {\n\n    /// See NFTLoanTicket\n    constructor(\n        NFTLoanFacilitator _nftLoanFacilitator,\n        NFTLoansTicketDescriptor _descriptor\n    ) \n        NFTLoanTicket(\"Lend Ticket\", \"LNDT\", _nftLoanFacilitator, _descriptor) \n    {}\n\n    /// See {ILendTicket-loanFacilitatorTransfer}\n    function loanFacilitatorTransfer(address from, address to, uint256 loanId) external override loanFacilitatorOnly {\n        _transfer(from, to, loanId);\n    }\n\n    /// @dev exact copy of \n    /// https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L69-L96\n    /// with L78 - L81 removed to enable loanFacilitatorTransfer\n    function _transfer(\n        address from,\n        address to,\n        uint256 id\n    ) internal {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n}\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}\n\n\n",
        "CodeNames": [
            "LendTicket.sol",
            "NFTLoanFacilitator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "transfer",
                    "lend()",
                    "loanInfo",
                    "currentLoanOwner",
                    "accumulatedInterest + previousLoanAmount",
                    "ERC",
                    "loanAssetContractAddress"
                ],
                "Type": " currentLoanOwner can manipulate loanInfo when any lenders try to buyout",
                "Description": "\nNFTLoanFacilitator.sol#L205-L208(https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208)<br\nNFTLoanFacilitator.sol#L215-L218(https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218)\n\nIf an attacker already calls lend() to lend to a loan, the attacker can manipulate loanInfo by reentrancy attack when any lenders try to buyout. The attacker can set bad values of lendInfo (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.\n\n\nAn attacker lends a loan, and loanAssetContractAddress in loanInfo is ERC777 which is suffering from reentrancy attack. When a lender (victim) try to buyout the loan of the attacker:\n\n1.  The victim called lend().\n2.  In lend(), it always call ERC20(loanAssetContractAddress).safeTransfer to send accumulatedInterest + previousLoanAmount to currentLoanOwner (attacker).\n3.  The transfer of loanAssetContractAddress ERC777 will call _callTokensReceived so that the attacker can call lend() again in reentrancy with parameters:\n    *   loanId: same loan Id\n    *   interestRate: set to bad value (e.g. 0)\n    *   amount: same amount\n    *   durationSeconds: set to bad value (e.g. a long durationSeconds)\n    *   sendLendTicketTo: same address of the attacker (currentLoanOwner)\n4.  Now the variables in loanInfo are changed to bad value, and the victim will get the lend ticket but the loan term is manipulated, and can not set it back (because it requires a better term).\n\n\nvim\n\n",
                "Repair": "\nUse nonReentrant modifier on lend() to prevent reentrancy attack: OpenZeppelin/ReentrancyGuard.sol(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)<br\n\nwilsoncusack (Backed Protocol) acknowledged, but disagreed with High severity and commented(https://github.com/code-423n4/2022-04-backed-findings/issues/88#issuecomment-1091992426):\n  We should mitigate, but will think on this.\n\nwilsoncusack (Backed Protocol) confirmed and commented(https://github.com/code-423n4/2022-04-backed-findings/issues/88#issuecomment-1092333890):\n  Not sure whether this should be Medium or High risk.\n\nwilsoncusack (Backed Protocol) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/88#issuecomment-1092723962):\n  Thinking more, again we should definitely mitigate, but I think this is less severe because I do not think ERC777 tokens will work with our contract? The on received call will revert? So this would need to be a malicious ERC20 designed just for this.\n\nwilsoncusack (Backed Protocol) resolved and commented(https://github.com/code-423n4/2022-04-backed-findings/issues/88#issuecomment-1092733796):\n  er erc777 does work because reception ack is not needed in the normal case.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-04-backed-findings/issues/88#issuecomment-1100056759):\n  Sponsor confirmed with fix.\n\n\n\n*\n\n\n"
            }
        ]
    }
]