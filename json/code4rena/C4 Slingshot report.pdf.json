[
    {
        "Code": "// SPDX-License-Identifier: None\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./Adminable.sol\";\nimport \"./lib/Strings.sol\";\nimport \"./ModuleRegistry.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function balanceOf(uint amount) external returns (uint);\n    function withdraw(uint amount) external;\n}\n\n /// @title   Slingshot Trading Contract\n /// @author  DEXAG, Inc.\n /// @notice  This contract serves as the entrypoint for executing\n ///          a Slingshot transaction on-chain.\n /// @dev     The specific logic for each DEX/AMM is defined within its\n ///          own corresponding module that is stored in the module registry.\n ///          Slingshot.sol references these modules to appropriately execute a trade.\n ///          Slingshot.sol also performs some safety checks to account for slippage\n ///          and security. Slingshot.sol depends on the Slingshot backend to provide\n ///          the details of how a given transaction will be executed within a\n ///          particular market.\ncontract Slingshot is Adminable, Strings {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public ETH_ADDRESS;\n    IWETH public WETH;\n\n    struct TradeFormat {\n        address moduleAddress;\n        bytes encodedCalldata;\n    }\n\n    ModuleRegistry public moduleRegistry;\n\n    event Trade(\n        address indexed user,\n        address fromToken,\n        address toToken,\n        uint fromAmount,\n        uint toAmount,\n        address recipient\n    );\n    event NewModuleRegistry(address oldRegistry, address newRegistry);\n\n    /// @notice Use this function for post upgrade setup\n    /// @param _admin Address to control admin functions\n    function postUpgrade(address _admin) external onlyAdminIfInitialized {\n        // skip when initialized\n        if (!isInitialized()) initialize(_admin);\n        // all other post upgrade setup below\n    }\n\n    /// @notice Initialization function for proxy setup\n    /// @param _admin Address to control admin functions\n    function initialize(address _admin) internal initializer {\n        initializeAdmin(_admin);\n        ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n        WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    }\n\n    /// @notice Executes multi-hop trades to get the best result\n    /// @param fromToken Start token address\n    /// @param toToken Target token address\n    /// @param fromAmount The initial amount of fromToken to start trading with\n    /// @param trades Array of encoded trades that are atomically executed\n    /// @param finalAmountMin The minimum expected output after all trades have been executed\n    /// @param recipient The address that will receive the output of a trade\n    function executeTrades(\n        address fromToken,\n        address toToken,\n        uint fromAmount,\n        TradeFormat[] calldata trades,\n        uint finalAmountMin,\n        address recipient\n    ) public payable {\n        uint initialBalance = _getTokenBalance(toToken);\n        _transferFromOrWrap(fromToken, _msgSender(), fromAmount);\n        // Checks to make sure that module exists and is correct\n        for(uint i = 0; i < trades.length; i++) {\n            require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\");\n            // delagatecall message is made on module contract, which is trusted\n            (bool success, bytes memory data) = trades[i].moduleAddress.delegatecall(trades[i].encodedCalldata);\n\n            require(success, appendString(prependNumber(i, \", Slingshot: swap failed: \"), string(data)));\n        }\n\n        uint finalBalance = _getTokenBalance(toToken);\n        uint finalAmount = finalBalance.sub(initialBalance);\n\n        require(finalAmount >= finalAmountMin, \"Slingshot: result is lower than required min\");\n\n        // Send to recipient address. Generally expected to be msg.sender, but can also be defined by user.\n        // This allows for more flexibility, but isn't necessary.\n        _sendFunds(toToken, recipient, finalAmount);\n\n        emit Trade(_msgSender(), fromToken, toToken, fromAmount, finalAmount, recipient);\n    }\n\n    /// @notice Sets module registry used to verify modules\n    /// @param _moduleRegistry The address of module registry\n    function setModuleRegistry(address _moduleRegistry) external onlyAdmin {\n        address oldRegistry = address(moduleRegistry);\n        moduleRegistry = ModuleRegistry(_moduleRegistry);\n        emit NewModuleRegistry(oldRegistry, _moduleRegistry);\n    }\n\n    /// @notice In an unlikely scenario of tokens being send to this contract\n    ///         allow adming to rescue them.\n    /// @param token The address of the token to rescue\n    /// @param to The address of recipient\n    /// @param amount The amount of the token to rescue\n    function rescueTokens(address token, address to, uint amount) external onlyAdmin {\n        if (token == ETH_ADDRESS) {\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"Slingshot: ETH rescue failed.\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    /// @notice Transfer tokens from sender to this contract or wraps ETH\n    /// @param fromToken The address of the token\n    /// @param from The address of sender that provides token\n    /// @param amount The amount of the token to transfer\n    function _transferFromOrWrap(address fromToken, address from, uint amount) internal {\n        // transfer tokens or wrap ETH\n        if (fromToken == ETH_ADDRESS) {\n            require(msg.value == amount, \"Slingshot: incorect ETH value\");\n            WETH.deposit{value: amount}();\n        } else {\n            require(msg.value == 0, \"Slingshot: should not send ETH\");\n            IERC20(fromToken).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /// @notice Returns balancer of the token\n    /// @param token The address of the token\n    /// @return balance of the token, defaults to WETH for ETH\n    function _getTokenBalance(address token) internal view returns (uint) {\n        if (token == ETH_ADDRESS) {\n            return WETH.balanceOf(address(this));\n        } else {\n            return IERC20(token).balanceOf(address(this));\n        }\n    }\n\n    /// @notice Sends token funds. For ETH, it unwraps WETH\n    /// @param token The address of the token to send\n    /// @param to The address of recipient\n    /// @param amount The amount of the token to send\n    function _sendFunds(address token, address to, uint amount) internal {\n        if (token == ETH_ADDRESS) {\n            WETH.withdraw(amount);\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"Slingshot: ETH Transfer failed.\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "Slingshot.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "C4 Slingshot report.pdf_H-01",
                "Location": [
                    "fromToken",
                    "executeTrades()",
                    "executeTrades(DAI, WETH, 1000, [], 0, alice)",
                    "executeTrades(DAI, WETH, 0, [{TradeData}], 0, eve)",
                    "finalAmountMin",
                    "rescueTokens()"
                ],
                "Type": " Incorrectly encoded arguments to executeTrades() can allow tokens to be stolen",
                "Description": " This finding combines a couple weaknesses into one attack. The first weakness is a lack of validation on arguments to executeTrades, the second is that a pre-existing fromToken balance can be used in a trade:  1. Alice wants to convert 1000 DAI to WETH. She calls executeTrades(DAI, WETH, 1000, [], 0, alice).  2. Since trades is an empty array, and finalAmountMin is 0, the result is that 100 DAI are transferred to the Slingshot contract.  3. Eve (a miner or other 'front runner') may observe this, and immediately call executeTrades(DAI, WETH, 0, [{TradeData}], 0, eve).  4. With a correctly formatted array of TradeData, Eve will receive the proceeds of converting Alice's 1000 DAI to WETH.  This issue is essentially identical to the one described in Ethereum is a Dark Forest, where locked tokens are available to anyone, and thus recovery is susceptible to front running. It also provides an unauthorized alternative to rescueTokens(), however it is still a useful function to have, as it provides a method to recover the tokens without allowing a front runner to simulate and replay it.  ",
                "Repair": ""
            },
            {
                "Name": "C4 Slingshot report.pdf_M-01",
                "Location": [
                    "finalAmountMin"
                ],
                "Type": " Front Running/Sandwich Attacks",
                "Description": "If a finalAmountMin is chosen that does not closely reflect the received amount one wouldget at the market rate (even with just 1% slippage), this could lead to the trade being frontrunand to less tokens than with a tighter slippage amount.Balancer and Curve modules don't haveany slippage protection at all which makes it easy for attackers to profit from such an attack.The min amount returned is hardcoded to 1 for both protocols. The Sushiswap/Uniswapmodules are vulnerable as well, depending on the calldata that is defined by the victim trader.code423n4.comhttps://medium.com/@danrobinson/ethereum-is-a-dark-forest-ecc5f0505dffhttps://code423n4.com",
                "Repair": ""
            },
            {
                "Name": "C4 Slingshot report.pdf_M-02",
                "Location": [
                    "fromexecuteTrades",
                    "rescueToken",
                    "fromToken",
                    "finalAmountMin",
                    "swap()"
                ],
                "Type": " Front Running/Sandwich Attacks",
                "Description": "If tokens are accidently sent to Slingshot, arbitrary trades can be executed and those funds canbe stolen by anyone. This vulnerability impacts the rescueToken functionality and any fundstrapped in Slingshot\u2019s contract. Tokens and/or Eth have a higher likelihood of becoming trappedin Slingshot if finalAmountMin is not utilized properly. Recommend validating parameters inthe calldata passed to modules and ensuring the fromToken and amount parameter fromexecuteTrades is equivalent to the token being swapped and amount passed to swap().Additionally, approval values can be limited to value being traded and cleared after trades areexecuted.",
                "Repair": ""
            },
            {
                "Name": "C4 Slingshot report.pdf_M-03",
                "Location": [],
                "Type": " Infinite Approval abused by malicious admin",
                "Description": "Current Slingshot contracts assume a rapid development environment so they use a proxypattern with a trusted admin role. We do not expect any malicious behavior from admin,however we agree that in the current setup admin potentially would be able to use unlimitedapprovals to steal user\u2019s funds. We consider this medium severity.",
                "Repair": ""
            },
            {
                "Name": "C4 Slingshot report.pdf_M-04",
                "Location": [
                    "executeTrades"
                ],
                "Type": " Stuck tokens can be stolen",
                "Description": "Any tokens in the Slingshot contract can be stolen by creating a fake token and a Uniswap pairfor the stuck token and this fake token. Consider 10 WETH being stuck in the Slingshot contract.One can create a fake ERC20 token contract FAKE and a WETH <> FAKE Uniswap pair. Theattacker provides a tiny amount of initial WETH liquidity (for example, 1 gwei) and some amountof FAKE tokens. The attacker then executes executeTrades action such that the Slingshotcontract uses its Uniswap module to trade the 10 WETH into this pair.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./Initializable.sol\";\n\n /// @title   Admin Role Contract\n /// @author  DEXAG, Inc.\n /// @notice  This contract is a utility for an admin role access.\nabstract contract Adminable is Initializable, AccessControl {\n    bytes32 public constant SLINGSHOT_ADMIN_ROLE = keccak256(\"SLINGSHOT_ADMIN_ROLE\");\n\n    modifier onlyAdmin() {\n        require(hasRole(SLINGSHOT_ADMIN_ROLE, _msgSender()), \"Adminable: not an admin\");\n        _;\n    }\n\n    /// @param role role hash\n    modifier onlyRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"Adminable: not a role\");\n        _;\n    }\n\n    modifier onlyAdminIfInitialized() {\n        if (isInitialized()) {\n            // if admin is set, require admin to be msg.sender\n            if(getRoleMemberCount(SLINGSHOT_ADMIN_ROLE) > 0) {\n                require(hasRole(SLINGSHOT_ADMIN_ROLE, _msgSender()), \"Adminable: not an admin\");\n                _;\n            }\n            // if no admin is set, just silently skip the execution. Proxy owner\n            // and slingshot admin may be two separate wallets so we don't revert\n            // the transaction to avoid jeopardizing contract implementation deployemnt\n            // - at these gas prices, it'd be almost a crime if we did.\n        } else {\n            // if not initialized, just let it execute\n            _;\n        }\n    }\n\n    /// @notice Set default admin role\n    /// @param _admin Address to control admin functions\n    function initializeAdmin(address _admin) internal {\n        _setRoleAdmin(SLINGSHOT_ADMIN_ROLE, SLINGSHOT_ADMIN_ROLE);\n        _setupRole(SLINGSHOT_ADMIN_ROLE, _admin);\n    }\n}\n\n\n",
        "CodeNames": [
            "Adminable.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "C4 Slingshot report.pdf_M-05",
                "Location": [
                    "postUpgrade()",
                    "allonlyAdmin",
                    "initializeAdmin()"
                ],
                "Type": " Admin role lockout",
                "Description": "The initializeAdmin() function in Adminable.sol sets/updates admin role address inone-step. If an incorrect address (zero address or other) is mistakenly used then futureadministrative access or even recovering from this mistake is prevented because allonlyAdmin modifier functions (including postUpgrade() with onlyAdminIfInitialized,which ends up calling initializeAdmin()) require msg.sender to be the incorrectly usedadmin address (for which private keys may not be available to sign transactions). In such acase, contracts would have to be redeployed. Suggest using a two-step process where the newadmin address first claims ownership in one transaction and a second transaction from the newadmin address takes ownership.",
                "Repair": ""
            }
        ]
    }
]