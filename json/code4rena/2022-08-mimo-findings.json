[
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOEmptyVault.sol\";\nimport \"./MIMOFlashloan.sol\";\nimport \"./MIMOSwap.sol\";\n\n/**\n  @title A SuperVault V2 action contract for repaying an existing vault's debt and withdrawing all collateral without any additional capital.\n  @notice Should only be accessed through a MIMOProxy delegateCall\n */\ncontract MIMOEmptyVault is MIMOSwap, MIMOFlashloan, IMIMOEmtpyVault {\n  using SafeERC20 for IERC20;\n\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol\n    @param _dexAP The dexAddressProvider for the MIMO protocol\n    @param _lendingPool The AAVE lending pool used for flashloans\n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control\n   */\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry\n  ) MIMOFlashloan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Should be called by MIMOProxy through a delegatecall \n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing vaultId, FlashloanData struct, RebalanceData struct, SwapData struct\n   */\n  function executeAction(bytes calldata _calldata) external override {\n    (uint256 vaultId, FlashLoanData memory flData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (uint256, FlashLoanData, SwapData)\n    );\n    bytes memory params = abi.encode(msg.sender, vaultId, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes an emptyVault operation after taking a flashloan  \n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the target vault asset\n    @param amounts Uint array with one element corresponding to the amount of the target vault asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, target vault id, SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n    IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner));\n\n    if (initiator != address(mimoProxy)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 vaultCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    vaultCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amount + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"emptyVaultOperation(address,uint256,uint256,(uint256,bytes))\",\n        vaultCollateral,\n        vaultId,\n        amount,\n        swapData\n      )\n    );\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform rebalance logic within MIMOProxy context\n    @notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n    @param vaultCollateral Collateral of the vault to empty\n    @param vaultId vault id of the vault to be emptied\n    @param swapAmount Amount of collateral to swap to for par to repay vaultdebt\n    @param swapData SwapData passed from the flashloan call\n   */\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 vaultId,\n    uint256 swapAmount,\n    SwapData calldata swapData\n  ) external {\n    IVaultsCore core = a.core();\n\n    _aggregatorSwap(vaultCollateral, swapAmount, swapData);\n\n    IERC20 stablex = IERC20(a.stablex());\n    stablex.safeIncreaseAllowance(address(core), stablex.balanceOf(address(this)));\n    core.repayAll(vaultId);\n\n    uint256 withdrawAmount = a.vaultsData().vaultCollateralBalance(vaultId);\n\n    core.withdraw(vaultId, withdrawAmount);\n    vaultCollateral.safeTransfer(msg.sender, withdrawAmount);\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOEmptyVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n\n    ....\n    ....\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    //Paid off the flash loan but did not transfer the remaining balance back to mimoProxy or owner *//\n\n    return true;\n  }\n\n",
                    "\n  it(\"should be able to empty vault with 1inch\", async () = {\n  ...\n  ...\n  ...\n  ++++ console.log(\"before emptyVault balance:---\", (await wmatic.balanceOf(emptyVault.address)) + \"\");\n    const tx = await mimoProxy.execute(emptyVault.address, MIMOProxyData);\n    const receipt = await tx.wait(1);\n  ++++ console.log(\"after emptyVault balance: ---\", (await wmatic.balanceOf(emptyVault.address)) + \"\");  \n\n",
                    "\nbefore emptyVault balance:--- 0\nafter emptyVault balance: --- 44383268870065355782\n\n"
                ],
                "Type": "  MIMOEmptyVault.sol executeOperation()  does not transfer the Vault leftover assets to the owner, it is locked in the  MIMOEmptyVault ",
                "Description": "\nMIMOEmptyVault.sol executeAction() is supposed to pay off the debt and return the leftover assets to the owner of the Vault. \nBut in fact the emptyVault contract, after executing the executionOperation(), only pays back the flash loan, and does not transfer the leftover assets to the owner, and locked in the emptyVault contract.\n\n\n\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n\n    ....\n    ....\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    //Paid off the flash loan but did not transfer the remaining balance back to mimoProxy or owner *//\n\n    return true;\n  }\n\n\n\nAdd logs to test case\n\ntest/02_integration/MIMOEmtpyVault.test.ts\n\n\n  it(\"should be able to empty vault with 1inch\", async () = {\n  ...\n  ...\n  ...\n  ++++ console.log(\"before emptyVault balance:---\", (await wmatic.balanceOf(emptyVault.address)) + \"\");\n    const tx = await mimoProxy.execute(emptyVault.address, MIMOProxyData);\n    const receipt = await tx.wait(1);\n  ++++ console.log(\"after emptyVault balance: ---\", (await wmatic.balanceOf(emptyVault.address)) + \"\");  \n\n\n\nprint:\n\n\nbefore emptyVault balance:--- 0\nafter emptyVault balance: --- 44383268870065355782\n\n\n\n",
                "Repair": "\n\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n\n    ....\n    ....\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    //transfer the remaining balance back to mimoProxy or owner *//\n    ++++ vaultCollateral.safeTransfer(address(mimoProxy), vaultCollateral.balanceOf(address(this)) flashloanRepayAmount);\n\n    return true;\n  }\n\n\n\nRayXpub (Mimo) confirmed and commented(https://github.com/code-423n4/2022-08-mimo-findings/issues/18#issuecomment-1210512990):\n  We confirm this is a vulnerability and intend to fix this only the amount needed to repay the flashloan should be transferred from the MimoProxy to the MIMOEmptyVault action contract.\n\nhorsefacts (warden) reviewed mitigation:\n Status: \u2705 Resolved\n\n Finding: Wardens identified that MIMOEmptyVault transferred in a vault\u2019s full collateral balance when repaying vault rebalance flash loans, but did not return excess collateral to the vault owner when the flash loan repayment amount was less than the vault\u2019s collateral balance. Instead, the excess amount would be locked in the action contract.\n\n What changed: The Mimo team updated MIMOEmptyVault#emptyVaultOperation to transfer collateral exactly equal to the flashloan repayment amount(https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/MIMOEmptyVault.sol#L142), rather than the full vault balance. This behavior is demonstrated by an integration test(https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/test/02_integration/MIMOEmtpyVault.test.ts#L297).\n\n Why it works: Since excess collateral is never transferred to MIMOEmptyVault, it can no longer be locked in the contract.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOAutoAction.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOAutoAction is IMIMOAutoAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => AutomatedVault) internal _automatedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault automation parameters\n    @dev Can only be called by vault owner\n    @param vaultId Vault id of the vault to be automated\n    @param autoParams AutomatedVault struct containing all automation parameters\n   */\n  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n\n    uint256 toVaultMcr = a.config().collateralMinCollateralRatio(autoParams.toCollateral);\n    uint256 maxVarFee = (autoParams.targetRatio.wadDiv(toVaultMcr + autoParams.mcrBuffer) + WadRayMath.WAD).wadDiv(\n      autoParams.targetRatio\n    );\n\n    if (autoParams.varFee >= maxVarFee) {\n      revert CustomErrors.VARIABLE_FEE_TOO_HIGH(maxVarFee, autoParams.varFee);\n    }\n\n    _automatedVaults[vaultId] = autoParams;\n\n    emit AutomationSet(vaultId, autoParams);\n  }\n\n  /**\n    @return AutomatedVault struct of a specific vault id\n   */\n  function getAutomatedVault(uint256 vaultId) external view override returns (AutomatedVault memory) {\n    return _automatedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @notice Helper function calculating a vault's net value and LTV ratio\n    @param vaultId Vault id of the vault for which to return info\n    @return vaultRatio Vault collateral value / vault debt\n    @return vaultState VaultState struct of the target vault\n   */\n  function _getVaultStats(uint256 vaultId) internal view returns (uint256 vaultRatio, VaultState memory vaultState) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n    vaultRatio = vaultDebt == 0 ? type(uint256).max : collateralValue.wadDiv(vaultDebt);\n\n    vaultState = VaultState({ collateralType: collateralType, collateralValue: collateralValue, vaultDebt: vaultDebt });\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > autoVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOEmptyVault.sol\";\nimport \"./MIMOFlashloan.sol\";\nimport \"./MIMOSwap.sol\";\n\n/**\n  @title A SuperVault V2 action contract for repaying an existing vault's debt and withdrawing all collateral without any additional capital.\n  @notice Should only be accessed through a MIMOProxy delegateCall\n */\ncontract MIMOEmptyVault is MIMOSwap, MIMOFlashloan, IMIMOEmtpyVault {\n  using SafeERC20 for IERC20;\n\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol\n    @param _dexAP The dexAddressProvider for the MIMO protocol\n    @param _lendingPool The AAVE lending pool used for flashloans\n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control\n   */\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry\n  ) MIMOFlashloan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Should be called by MIMOProxy through a delegatecall \n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing vaultId, FlashloanData struct, RebalanceData struct, SwapData struct\n   */\n  function executeAction(bytes calldata _calldata) external override {\n    (uint256 vaultId, FlashLoanData memory flData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (uint256, FlashLoanData, SwapData)\n    );\n    bytes memory params = abi.encode(msg.sender, vaultId, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes an emptyVault operation after taking a flashloan  \n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the target vault asset\n    @param amounts Uint array with one element corresponding to the amount of the target vault asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, target vault id, SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n    IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner));\n\n    if (initiator != address(mimoProxy)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 vaultCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    vaultCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amount + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"emptyVaultOperation(address,uint256,uint256,(uint256,bytes))\",\n        vaultCollateral,\n        vaultId,\n        amount,\n        swapData\n      )\n    );\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform rebalance logic within MIMOProxy context\n    @notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n    @param vaultCollateral Collateral of the vault to empty\n    @param vaultId vault id of the vault to be emptied\n    @param swapAmount Amount of collateral to swap to for par to repay vaultdebt\n    @param swapData SwapData passed from the flashloan call\n   */\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 vaultId,\n    uint256 swapAmount,\n    SwapData calldata swapData\n  ) external {\n    IVaultsCore core = a.core();\n\n    _aggregatorSwap(vaultCollateral, swapAmount, swapData);\n\n    IERC20 stablex = IERC20(a.stablex());\n    stablex.safeIncreaseAllowance(address(core), stablex.balanceOf(address(this)));\n    core.repayAll(vaultId);\n\n    uint256 withdrawAmount = a.vaultsData().vaultCollateralBalance(vaultId);\n\n    core.withdraw(vaultId, withdrawAmount);\n    vaultCollateral.safeTransfer(msg.sender, withdrawAmount);\n  }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOManagedAction.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOManagedAction is IMIMOManagedAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => ManagedVault) internal _managedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n  mapping(address => bool) internal _managers;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault management parameters\n    @dev Can only be called by vault owner and can only appoint whitelisting managers as manger\n    @param vaultId Vault id of the vault to be put under management\n    @param mgtParams ManagedVault struct containing all management parameters\n   */\n  function setManagement(uint256 vaultId, ManagedVault calldata mgtParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n    if (!_managers[mgtParams.manager]) {\n      revert CustomErrors.MANAGER_NOT_LISTED();\n    }\n\n    _managedVaults[vaultId] = mgtParams;\n\n    emit ManagementSet(vaultId, mgtParams);\n  }\n\n  /**\n    @notice Whitelists or removes a manager\n    @dev Can only be called by protocol manager\n    @param manager Manager address\n    @param isManager Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function setManager(address manager, bool isManager) external override {\n    IAccessController controller = a.controller();\n\n    if (!controller.hasRole(controller.MANAGER_ROLE(), msg.sender)) {\n      revert CustomErrors.CALLER_NOT_PROTOCOL_MANAGER();\n    }\n\n    _managers[manager] = isManager;\n\n    emit ManagerSet(manager, isManager);\n  }\n\n  /**\n    @return ManagedVault struct of a specific vault id\n   */\n  function getManagedVault(uint256 vaultId) external view override returns (ManagedVault memory) {\n    return _managedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @return Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function getManager(address manager) external view override returns (bool) {\n    return _managers[manager];\n  }\n\n  /**\n    @notice Helper function calculating LTV ratio\n    @return Vault collateral value / vault debt\n   */\n  function _getVaultRatio(uint256 vaultId) internal view returns (uint256) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n\n    if (vaultDebt == 0) {\n      return (type(uint256).max);\n    }\n\n    uint256 vaultRatio = collateralValue.wadDiv(vaultDebt);\n\n    return (vaultRatio);\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    ManagedVault memory managedVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > managedVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOAutoAction.sol",
            "MIMOEmptyVault.sol",
            "MIMOManagedAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "vaultId",
                    "address(",
                    "mimoProxy",
                    "setManagement",
                    "vaultOwner"
                ],
                "Type": " Automation / management can be set for not yet existing vault",
                "Description": "\n<https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/automated/MIMOAutoAction.sol#L33\n\n<https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/managed/MIMOManagedAction.sol#L35\n\n\nvaultOwner returns zero for a non-existing vaultId. Similarly, proxyRegistry.getCurrentProxy(msg.sender) returns zero when msg.sender has not deployed a proxy yet. Those two facts can be combined to set automation for a vault ID that does not exist yet. When this is done by a user without a proxy, it will succeed, as both vaultOwner and mimoProxy are address(0), i.e. we have vaultOwner == mimoProxy.\n\nThe consequences of this are quite severe. As soon as the vault is created, it will be an automated vault (with potentially very high fees). An attacker can exploit this by setting very high fees before the creation of the vault and then performing actions for the automated vault, which leads to a loss of funds for the user.\n\nThe same attack is possible for setManagement.\n\n",
                "Repair": "\nDo not allow setting automation parameters for non-existing vaults, i.e. check that vaultOwner != address(0).\n\nRayXpub (Mimo) confirmed and commented(https://github.com/code-423n4/2022-08-mimo-findings/issues/68#issuecomment-1210497317):\n  We confirm that this is a high risk issue and intend to fix this.\n\nhorsefacts (warden) reviewed mitigation:\n Status: \u2705 Resolved after review (see finding M.H-01 in Mitigation Review section below)\n\n Finding: Wardens identified that malicious callers could configure automation and management parameters for uninitialized vaults when vault owner and proxy address were unset for a given vault ID and caller and returned adress(0), which caused an access control check to unintentionally pass.\n\n What changed: MIMOAutoAction#setAutomation now checks(https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/contracts/actions/automated/MIMOAutoAction.sol#L34) whether the vault owner is the zero address. An integration test(https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/test/02_integration/automated/MIMOAutoActionSecurity.test.ts#L119) demonstrates that attempting to call setAutomation on an uninitialized vault will revert. MIMOManagedAction#setAutomation performs the same check(https://github.com/mimo-capital/2022-08-mimo/blob/5a63c76ed74186d11d3adb361d3b3aacefa7795e/contracts/actions/managed/MIMOManagedAction.sol#L37), and an integration test(https://github.com/mimo-capital/2022-08-mimo/blob/5a63c76ed74186d11d3adb361d3b3aacefa7795e/test/01_unit/managed/MIMOManagedAction.test.ts#L123) exercises it.  \n\n Why it works: Since setAutomation now explicitly checks that the vault is initialized, configuration cannot be set for an uninitialized vault.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOEmptyVault.sol\";\nimport \"./MIMOFlashloan.sol\";\nimport \"./MIMOSwap.sol\";\n\n/**\n  @title A SuperVault V2 action contract for repaying an existing vault's debt and withdrawing all collateral without any additional capital.\n  @notice Should only be accessed through a MIMOProxy delegateCall\n */\ncontract MIMOEmptyVault is MIMOSwap, MIMOFlashloan, IMIMOEmtpyVault {\n  using SafeERC20 for IERC20;\n\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol\n    @param _dexAP The dexAddressProvider for the MIMO protocol\n    @param _lendingPool The AAVE lending pool used for flashloans\n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control\n   */\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry\n  ) MIMOFlashloan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Should be called by MIMOProxy through a delegatecall \n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing vaultId, FlashloanData struct, RebalanceData struct, SwapData struct\n   */\n  function executeAction(bytes calldata _calldata) external override {\n    (uint256 vaultId, FlashLoanData memory flData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (uint256, FlashLoanData, SwapData)\n    );\n    bytes memory params = abi.encode(msg.sender, vaultId, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes an emptyVault operation after taking a flashloan  \n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the target vault asset\n    @param amounts Uint array with one element corresponding to the amount of the target vault asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, target vault id, SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n    IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner));\n\n    if (initiator != address(mimoProxy)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 vaultCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    vaultCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amount + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"emptyVaultOperation(address,uint256,uint256,(uint256,bytes))\",\n        vaultCollateral,\n        vaultId,\n        amount,\n        swapData\n      )\n    );\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform rebalance logic within MIMOProxy context\n    @notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n    @param vaultCollateral Collateral of the vault to empty\n    @param vaultId vault id of the vault to be emptied\n    @param swapAmount Amount of collateral to swap to for par to repay vaultdebt\n    @param swapData SwapData passed from the flashloan call\n   */\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 vaultId,\n    uint256 swapAmount,\n    SwapData calldata swapData\n  ) external {\n    IVaultsCore core = a.core();\n\n    _aggregatorSwap(vaultCollateral, swapAmount, swapData);\n\n    IERC20 stablex = IERC20(a.stablex());\n    stablex.safeIncreaseAllowance(address(core), stablex.balanceOf(address(this)));\n    core.repayAll(vaultId);\n\n    uint256 withdrawAmount = a.vaultsData().vaultCollateralBalance(vaultId);\n\n    core.withdraw(vaultId, withdrawAmount);\n    vaultCollateral.safeTransfer(msg.sender, withdrawAmount);\n  }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\n/**\n    @title Errors library\n    @author MIMO\n    @notice Defines the error messages emtted by the different contracts of the MIMO protocol\n */\n\nlibrary CustomErrors {\n  error CANNOT_SET_TO_ADDRESS_ZERO();\n  error INITIATOR_NOT_AUTHORIZED(address actual, address expected);\n  error CALLER_NOT_LENDING_POOL(address actual, address expected);\n  error CANNOT_REPAY_FLASHLOAN();\n  error INVALID_AGGREGATOR();\n  error AGGREGATOR_CALL_FAILED();\n  error EXECUTION_NOT_AUTHORIZED(address owner, address caller, address target, bytes4 selector);\n  error EXECUTION_REVERTED();\n  error NOT_OWNER(address owner, address caller);\n  error OWNER_CHANGED(address originalOwner, address newOwner);\n  error TARGET_INVALID(address target);\n  error CALLER_NOT_VAULT_OWNER(address callerProxy, address vaultOwner);\n  error CALLER_NOT_PROTOCOL_MANAGER();\n  error MANAGER_NOT_LISTED();\n  error VAULT_NOT_UNDER_MANAGEMENT();\n  error CALLER_NOT_SELECTED_MANAGER();\n  error PROXY_ALREADY_EXISTS(address owner);\n  error MAX_OPERATIONS_REACHED();\n  error MINT_AMOUNT_GREATER_THAN_VAULT_DEBT();\n  error VAULT_VALUE_CHANGE_TOO_HIGH();\n  error FINAL_VAULT_RATIO_TOO_LOW(uint256 minRatio, uint256 actualRatio);\n  error VAULT_NOT_AUTOMATED();\n  error VAULT_TRIGGER_RATIO_NOT_REACHED(uint256 actual, uint256 expected);\n  error TARGETS_LENGTH_DIFFERENT_THAN_DATA_LENGTH(uint256 targetsLength, uint256 dataLength);\n  error LOW_LEVEL_CALL_FAILED();\n  error REBALANCE_AMOUNT_CANNOT_BE_ZERO();\n  error VARIABLE_FEE_TOO_HIGH(uint256 maxVarFee, uint256 actualVarFee);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\ninterface IGovernorAlpha {\n  /// @notice Possible states that a proposal may be in\n  enum ProposalState { Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }\n\n  struct Proposal {\n    // Unique id for looking up a proposal\n    uint256 id;\n    // Creator of the proposal\n    address proposer;\n    // The timestamp that the proposal will be available for execution, set once the vote succeeds\n    uint256 eta;\n    // the ordered list of target addresses for calls to be made\n    address[] targets;\n    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    uint256[] values;\n    // The ordered list of function signatures to be called\n    string[] signatures;\n    // The ordered list of calldata to be passed to each call\n    bytes[] calldatas;\n    // The timestamp at which voting begins: holders must delegate their votes prior to this timestamp\n    uint256 startTime;\n    // The timestamp at which voting ends: votes must be cast prior to this timestamp\n    uint256 endTime;\n    // Current number of votes in favor of this proposal\n    uint256 forVotes;\n    // Current number of votes in opposition to this proposal\n    uint256 againstVotes;\n    // Flag marking whether the proposal has been canceled\n    bool canceled;\n    // Flag marking whether the proposal has been executed\n    bool executed;\n    // Receipts of ballots for the entire set of voters\n    mapping(address => Receipt) receipts;\n  }\n\n  /// @notice Ballot receipt record for a voter\n  struct Receipt {\n    // Whether or not a vote has been cast\n    bool hasVoted;\n    // Whether or not the voter supports the proposal\n    bool support;\n    // The number of votes the voter had, which were cast\n    uint256 votes;\n  }\n\n  /// @notice An event emitted when a new proposal is created\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startTime,\n    uint256 endTime,\n    string description\n  );\n\n  /// @notice An event emitted when a vote has been cast on a proposal\n  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n  /// @notice An event emitted when a proposal has been canceled\n  event ProposalCanceled(uint256 id);\n\n  /// @notice An event emitted when a proposal has been queued in the Timelock\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  /// @notice An event emitted when a proposal has been executed in the Timelock\n  event ProposalExecuted(uint256 id);\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description,\n    uint256 endTime\n  ) external returns (uint256);\n\n  function queue(uint256 proposalId) external;\n\n  function execute(uint256 proposalId) external payable;\n\n  function cancel(uint256 proposalId) external;\n\n  function castVote(uint256 proposalId, bool support) external;\n\n  function getActions(uint256 proposalId)\n    external\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    );\n\n  function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\n\n  function state(uint256 proposalId) external view returns (ProposalState);\n\n  function quorumVotes() external view returns (uint256);\n\n  function proposalThreshold() external view returns (uint256);\n}\n\n\n",
        "CodeNames": [
            "MIMOEmptyVault.sol",
            "CustomErrors.sol",
            "IGovernorAlpha.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "execute(address target, bytes calldata data)",
                    "selector",
                    "signature",
                    "execute",
                    "data",
                    "target",
                    "bytes"
                ],
                "Type": " Incorrect implementation of access control in MIMOProxy:execute",
                "Description": "\n<https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L54\n\n<https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104\n\n\nThere is a function execute in MIMOProxy smart contract. The function performs a delegate call to the user-specified address with the specified data. As an access control, the function checks that either it was called by the owner or the owner has previously approved that the sender can call a specified target with specified calldata. See <https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104.\n\nThe check itself:\n\n        if (owner != msg.sender) {\n          bytes4 selector;\n          assembly {\n            selector := calldataload(data.offset)\n          }\n          if (!_permissions[msg.sender][target][selector]) {\n            revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n          }\n        }\n\nThe problem is how the selector is calculated. Specifically, calldataload(data.offset) reads first 4 bytes of data.  Imagine data.length == 0, does it mean that calldataload(data.offset) will return bytes4(0)? No.\n\nLet's see how calldata are accepted by functions in Solidity. The solidity function checks that the calldata length is less than needed, but does NOT check that there is no redundant data in calldata. That means, the function execute(address target, bytes calldata data) will definitely accept data that have target and data, but also in calldata can be other user-provided bytes. As a result,  calldataload(data.offset) can read trash, but not the data bytes.\n\nAnd in the case of execute function, an attacker can affect the execution by providing trash data at the end of the function. Namely, if the attacker has permission to call the function with some signature, the attacker can call proxy contract bypass check for signature and make delegate call directly with zero calldata.\n\nPlease see proof-of-concept (PoC), getAttackerCalldata returns a calldata with which it is possible to bypass check permission for signature. Function execute from PoC simulate check for permission to call signatureWithPermision, and enforce that data.length == 0. With calldata from getAttackerCalldata it works.\n\n\nAny account that has permission to call at least one function (signature) to the contract can call fallback function without permission to do so.\n\n\n    // SPDX-License-Identifier: MIT OR Apache-2.0\n\n    pragma solidity ^0.8.0;\n\n    interface IMIMOProxy {\n      event Execute(address indexed target, bytes data, bytes response);\n\n      event TransferOwnership(address indexed oldOwner, address indexed newOwner);\n\n      function initialize() external;\n\n      function getPermission(\n        address envoy,\n        address target,\n        bytes4 selector\n      ) external view returns (bool);\n\n      function owner() external view returns (address);\n\n      function minGasReserve() external view returns (uint256);\n\n      function execute(address target, bytes calldata data) external payable returns (bytes memory response);\n\n      function setPermission(\n        address envoy,\n        address target,\n        bytes4 selector,\n        bool permission\n      ) external;\n\n      function transferOwnership(address newOwner) external;\n\n      function multicall(address[] calldata targets, bytes[] calldata data) external returns (bytes[] memory);\n    }\n\n    contract PoC {\n        bytes4 public signatureWithPermision = bytes4(0xffffffff);\n\n        // Call this function with calldata that can be prepared in getAttackerCalldata\n        function execute(address target, bytes calldata data) external {\n            bytes4 selector;\n            assembly {\n                selector := calldataload(data.offset)\n            }\n\n            require(selector == signatureWithPermision);\n\n            require(data.length == 0);\n        }\n\n        // Function that prepare attacker calldata\n        function getAttackerCalldata() public view returns(bytes memory)  {\n            bytes memory usualCalldata = abi.encodeWithSelector(IMIMOProxy.execute.selector, msg.sender, new bytes(0));\n            return abi.encodePacked(usualCalldata, bytes32(signatureWithPermision));\n        }\n    }\n\n",
                "Repair": "\nAdd require(data.length = 4);.\n\nRayXpub (Mimo) commented(https://github.com/code-423n4/2022-08-mimo-findings/issues/159#issuecomment-1210479234):\n  We were not able to recreate the provided POC. The explanation is also incomplete we don't see how an attacker could bypass the permissions check through providing extra calldata in a signature. Please provide more details, or a working POC, on how the extra data can bypass the permissions check.\n\ngzeoneth (judge) commented(https://github.com/code-423n4/2022-08-mimo-findings/issues/159#issuecomment-1221562576):\n  This POC looks valid to me.\n \n Basically what the warden mean is if you construct the calldata like execute(some_addr, \"\") + 0xffffff\n \n 0x1cff79cd0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000^ffffffff\n \n data.offset would be at ^<br\n and calldataload(data.offset) would read 0xffffff\n \n\ngzeoneth (judge) commented(https://github.com/code-423n4/2022-08-mimo-findings/issues/159#issuecomment-1222005782):\n This might be clearer\n solidity\n pragma solidity ^0.8.0;\n \n contract PoC {\n     bytes4 public signatureWithPermision = bytes4(0xdead1337);\n \n     // Call this function with calldata that can be prepared in getAttackerCalldata\n     function execute(address target, bytes calldata data) view external returns(bytes memory) {\n         bytes4 selector;\n         assembly {\n             selector := calldataload(data.offset)\n         }\n         require(selector == signatureWithPermision, \"bad selector\");\n         return data;\n     }\n \n     // Function that prepare attacker calldata\n     function getAttackerCalldata() public view returns(bytes memory)  {\n         bytes memory usualCalldata = abi.encodeWithSelector(this.execute.selector, msg.sender, new bytes(0));\n         return abi.encodePacked(usualCalldata, signatureWithPermision);\n     }\n \n     function exploit() external returns(bytes memory data) {\n         (, data) = address(this).call(getAttackerCalldata());\n     }\n }\n \n \n If you call exploit, it would succeed but it shouldn't (since exploit call execute with 0x00000000.... instead of the permitted 4bytes 0xdead1337). \n \n The exploit here is if you permitted contract A to run function foo only, A.fallback() is also permitted.\n \n Your getSelector PoC won't work if you are passing a non-empty bytes, it would work if you construct a call like 0x0cbd17c800000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000dead1337<br\n which is equivalent to calling getSelector(\"\") with some extra data dead1337 at the end.\n \n Consider the calldata layout<br\n 00] 0cbd17c8<br\n 04] 0000000000000000000000000000000000000000000000000000000000000020 (data offset)<br\n 24] 0000000000000000000000000000000000000000000000000000000000000000 (data len)<br\n 44] dead1337\n \n data.offset = 0x04 + 0x20 (data offset) + 0x20 (1 word for length) = 0x44\n\nRayXpub (Mimo) confirmed(https://github.com/code-423n4/2022-08-mimo-findings/issues/159) \n\nhorsefacts (warden) reviewed mitigation:\n Status: \u2705 Resolved\n\n Finding: A warden identified that callers could bypass a permissions check in MIMOProxy#execute by passing specially constructed calldata, enabling the caller to invoke a contract\u2019s fallback function.\n\n What changed: MIMOProxy#execute now reads the first four bytes of the data parameter directly rather than using data.offset to extract the function selector from calldata. \n\n Why it works: Since attackers can no longer manipulate the extracted selector, they cannot bypass the permissions check. A unit test(https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/test/01_unit/proxy/MIMOProxy.test.ts#L103) demonstrates this behavior.\n\n\n\n*\n\n\n"
            }
        ]
    }
]