[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.3;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { IVotingEscrow } from \"./interfaces/IVotingEscrow.sol\";\nimport { IBlocklist } from \"./interfaces/IBlocklist.sol\";\n\n/// @title  VotingEscrow\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///           (see https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n///         mStable (AGPL) - forking Curve's Vyper contract and porting to Solidity\n///           (see https://github.com/mstable/mStable-contracts/blob/master/contracts/governance/IncentivisedVotingLockup.sol)\n///         FIAT DAO (AGPL) - this version\n/// @notice Plain Curve VotingEscrow mechanics with following adjustments:\n///            1) Delegation of lock and voting power\n///            2) Quit an existing lock and pay a penalty\n///            3) Whitelisting of SmartWallets outside the VotingEscrow\n///            4) Reduced pointHistory array size and, as a result, lifetime of the contract\n///            5) Removed public deposit_for and Aragon compatibility (no use case)\ncontract VotingEscrow is IVotingEscrow, ReentrancyGuard {\n    // Shared Events\n    event Deposit(\n        address indexed provider,\n        uint256 value,\n        uint256 locktime,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event Withdraw(\n        address indexed provider,\n        uint256 value,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event TransferOwnership(address owner);\n    event UpdateBlocklist(address blocklist);\n    event UpdatePenaltyRecipient(address recipient);\n    event CollectPenalty(uint256 amount, address recipient);\n    event Unlock();\n\n    // Shared global state\n    IERC20 public token;\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MAXTIME = 365 days;\n    uint256 public constant MULTIPLIER = 10**18;\n    address public owner;\n    address public penaltyRecipient; // receives collected penalty payments\n    uint256 public maxPenalty = 10**18; // penalty for quitters with MAXTIME remaining lock\n    uint256 public penaltyAccumulated; // accumulated and unwithdrawn penalty payments\n    address public blocklist;\n\n    // Lock state\n    uint256 public globalEpoch;\n    Point[1000000000000000000] public pointHistory; // 1e9 * userPointHistory-length, so sufficient for 1e9 users\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => int128) public slopeChanges;\n    mapping(address => LockedBalance) public locked;\n\n    // Voting token\n    string public name;\n    string public symbol;\n    uint256 public decimals = 18;\n\n    // Structs\n    struct Point {\n        int128 bias;\n        int128 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n        int128 delegated;\n        address delegatee;\n    }\n\n    // Miscellaneous\n    enum LockAction {\n        CREATE,\n        INCREASE_AMOUNT,\n        INCREASE_AMOUNT_AND_DELEGATION,\n        INCREASE_TIME,\n        WITHDRAW,\n        QUIT,\n        DELEGATE,\n        UNDELEGATE\n    }\n\n    /// @notice Initializes state\n    /// @param _owner The owner is able to update `owner`, `penaltyRecipient` and `penaltyRate`\n    /// @param _penaltyRecipient The recipient of penalty paid by lock quitters\n    /// @param _token The token locked in order to obtain voting power\n    /// @param _name The name of the voting token\n    /// @param _symbol The symbol of the voting token\n    constructor(\n        address _owner,\n        address _penaltyRecipient,\n        address _token,\n        string memory _name,\n        string memory _symbol\n    ) {\n        token = IERC20(_token);\n        pointHistory[0] = Point({\n            bias: int128(0),\n            slope: int128(0),\n            ts: block.timestamp,\n            blk: block.number\n        });\n\n        decimals = IERC20(_token).decimals();\n        require(decimals <= 18, \"Exceeds max decimals\");\n\n        name = _name;\n        symbol = _symbol;\n        owner = _owner;\n        penaltyRecipient = _penaltyRecipient;\n    }\n\n    modifier checkBlocklist() {\n        require(\n            !IBlocklist(blocklist).isBlocked(msg.sender),\n            \"Blocked contract\"\n        );\n        _;\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       Owner Functions       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Transfers ownership to a new owner\n    /// @param _addr The new owner\n    /// @dev Owner should always be a timelock contract\n    function transferOwnership(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        owner = _addr;\n        emit TransferOwnership(_addr);\n    }\n\n    /// @notice Updates the blocklist contract\n    function updateBlocklist(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        blocklist = _addr;\n        emit UpdateBlocklist(_addr);\n    }\n\n    /// @notice Updates the recipient of the accumulated penalty paid by quitters\n    function updatePenaltyRecipient(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        penaltyRecipient = _addr;\n        emit UpdatePenaltyRecipient(_addr);\n    }\n\n    /// @notice Removes quitlock penalty by setting it to zero\n    /// @dev This is an irreversible action\n    function unlock() external {\n        require(msg.sender == owner, \"Only owner\");\n        maxPenalty = 0;\n        emit Unlock();\n    }\n\n    /// @notice Forces an undelegation of virtual balance for a blocked locker\n    /// @dev Can only be called by the Blocklist contract (as part of a block)\n    /// @dev This is an irreversible action\n    function forceUndelegate(address _addr) external override {\n        require(msg.sender == blocklist, \"Only Blocklist\");\n        LockedBalance memory locked_ = locked[_addr];\n        address delegatee = locked_.delegatee;\n        int128 value = locked_.amount;\n\n        if (delegatee != _addr && value > 0) {\n            LockedBalance memory fromLocked;\n            locked_.delegatee = _addr;\n            fromLocked = locked[delegatee];\n            _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n            _delegate(_addr, locked_, value, LockAction.DELEGATE);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       LOCK MANAGEMENT       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Returns a user's lock expiration\n    /// @param _addr The address of the user\n    /// @return Expiration of the user's lock\n    function lockEnd(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /// @notice Returns the last available user point for a user\n    /// @param _addr User address\n    /// @return bias i.e. y\n    /// @return slope i.e. linear gradient\n    /// @return ts i.e. time point was logged\n    function getLastUserPoint(address _addr)\n        external\n        view\n        returns (\n            int128 bias,\n            int128 slope,\n            uint256 ts\n        )\n    {\n        uint256 uepoch = userPointEpoch[_addr];\n        if (uepoch == 0) {\n            return (0, 0, 0);\n        }\n        Point memory point = userPointHistory[_addr][uepoch];\n        return (point.bias, point.slope, point.ts);\n    }\n\n    /// @notice Records a checkpoint of both individual and global slope\n    /// @param _addr User address, or address(0) for only global\n    /// @param _oldLocked Old amount that user had locked, or null for global\n    /// @param _newLocked new amount that user has locked, or null for global\n    function _checkpoint(\n        address _addr,\n        LockedBalance memory _oldLocked,\n        LockedBalance memory _newLocked\n    ) internal {\n        Point memory userOldPoint;\n        Point memory userNewPoint;\n        int128 oldSlopeDelta = 0;\n        int128 newSlopeDelta = 0;\n        uint256 epoch = globalEpoch;\n\n        if (_addr != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.delegated > 0) {\n                userOldPoint.slope =\n                    _oldLocked.delegated /\n                    int128(int256(MAXTIME));\n                userOldPoint.bias =\n                    userOldPoint.slope *\n                    int128(int256(_oldLocked.end - block.timestamp));\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.delegated > 0) {\n                userNewPoint.slope =\n                    _newLocked.delegated /\n                    int128(int256(MAXTIME));\n                userNewPoint.bias =\n                    userNewPoint.slope *\n                    int128(int256(_newLocked.end - block.timestamp));\n            }\n\n            // Moved from bottom final if statement to resolve stack too deep err\n            // start {\n            // Now handle user history\n            uint256 uEpoch = userPointEpoch[_addr];\n            if (uEpoch == 0) {\n                userPointHistory[_addr][uEpoch + 1] = userOldPoint;\n            }\n\n            userPointEpoch[_addr] = uEpoch + 1;\n            userNewPoint.ts = block.timestamp;\n            userNewPoint.blk = block.number;\n            userPointHistory[_addr][uEpoch + 1] = userNewPoint;\n\n            // } end\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldSlopeDelta = slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newSlopeDelta = oldSlopeDelta;\n                } else {\n                    newSlopeDelta = slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint =\n            Point({\n                bias: 0,\n                slope: 0,\n                ts: block.timestamp,\n                blk: block.number\n            });\n        if (epoch > 0) {\n            lastPoint = pointHistory[epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint =\n            Point({ bias: 0, slope: 0, ts: lastPoint.ts, blk: lastPoint.blk });\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope =\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\n                (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 iterativeTime = _floorToWeek(lastCheckpoint);\n        for (uint256 i = 0; i < 255; i++) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            if (iterativeTime > block.timestamp) {\n                iterativeTime = block.timestamp;\n            } else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n            int128 biasDelta =\n                lastPoint.slope *\n                    int128(int256((iterativeTime - lastCheckpoint)));\n            lastPoint.bias = lastPoint.bias - biasDelta;\n            lastPoint.slope = lastPoint.slope + dSlope;\n            // This can happen\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            // This cannot happen - just in case\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = iterativeTime;\n            lastPoint.ts = iterativeTime;\n            lastPoint.blk =\n                initialLastPoint.blk +\n                (blockSlope * (iterativeTime - initialLastPoint.ts)) /\n                MULTIPLIER;\n\n            // when epoch is incremented, we either push here or after slopes updated below\n            epoch = epoch + 1;\n            if (iterativeTime == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                pointHistory[epoch] = lastPoint;\n            }\n        }\n\n        globalEpoch = epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_addr != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope =\n                lastPoint.slope +\n                userNewPoint.slope -\n                userOldPoint.slope;\n            lastPoint.bias =\n                lastPoint.bias +\n                userNewPoint.bias -\n                userOldPoint.bias;\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        pointHistory[epoch] = lastPoint;\n\n        if (_addr != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldSlopeDelta was <something> - userOldPoint.slope, so we cancel that\n                oldSlopeDelta = oldSlopeDelta + userOldPoint.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldSlopeDelta = oldSlopeDelta - userNewPoint.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = oldSlopeDelta;\n            }\n            if (_newLocked.end > block.timestamp) {\n                if (_newLocked.end > _oldLocked.end) {\n                    newSlopeDelta = newSlopeDelta - userNewPoint.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = newSlopeDelta;\n                }\n                // else: we recorded it already in oldSlopeDelta\n            }\n        }\n    }\n\n    /// @notice Public function to trigger global checkpoint\n    function checkpoint() external {\n        LockedBalance memory empty;\n        _checkpoint(address(0), empty, empty);\n    }\n\n    // See IVotingEscrow for documentation\n    function createLock(uint256 _value, uint256 _unlockTime)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(locked_.amount == 0, \"Lock exists\");\n        require(unlock_time >= locked_.end, \"Only increase lock end\"); // from using quitLock, user should increaseAmount instead\n        require(unlock_time > block.timestamp, \"Only future lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock and voting power (checkpoint)\n        locked_.amount += int128(int256(_value));\n        locked_.end = unlock_time;\n        locked_.delegated += int128(int256(_value));\n        locked_.delegatee = msg.sender;\n        locked[msg.sender] = locked_;\n        _checkpoint(msg.sender, LockedBalance(0, 0, 0, address(0)), locked_);\n        // Deposit locked tokens\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Transfer failed\"\n        );\n        emit Deposit(\n            msg.sender,\n            _value,\n            unlock_time,\n            LockAction.CREATE,\n            block.timestamp\n        );\n    }\n\n    // See IVotingEscrow for documentation\n    // @dev A lock is active until both lock.amount==0 and lock.end<=block.timestamp\n    function increaseAmount(uint256 _value)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        // Update lock\n        address delegatee = locked_.delegatee;\n        uint256 unlockTime = locked_.end;\n        LockAction action = LockAction.INCREASE_AMOUNT;\n        LockedBalance memory newLocked;\n        if (delegatee == msg.sender) {\n            // Undelegated lock\n            action = LockAction.INCREASE_AMOUNT_AND_DELEGATION;\n            newLocked = _copyLock(locked_);\n            newLocked.amount += int128(int256(_value));\n            newLocked.delegated += int128(int256(_value));\n            locked[msg.sender] = newLocked;\n        } else {\n            // Delegated lock, update sender's lock first\n            locked_.amount += int128(int256(_value));\n            locked[msg.sender] = locked_;\n            // Then, update delegatee's lock and voting power (checkpoint)\n            locked_ = locked[delegatee];\n            require(locked_.amount > 0, \"Delegatee has no lock\");\n            require(locked_.end > block.timestamp, \"Delegatee lock expired\");\n            newLocked = _copyLock(locked_);\n            newLocked.delegated += int128(int256(_value));\n            locked[delegatee] = newLocked;\n            emit Deposit(\n                delegatee,\n                _value,\n                newLocked.end,\n                LockAction.DELEGATE,\n                block.timestamp\n            );\n        }\n        // Checkpoint only for delegatee\n        _checkpoint(delegatee, locked_, newLocked);\n        // Deposit locked tokens\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Transfer failed\"\n        );\n        emit Deposit(msg.sender, _value, unlockTime, action, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function increaseUnlockTime(uint256 _unlockTime)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(unlock_time > locked_.end, \"Only increase lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock\n        uint256 oldUnlockTime = locked_.end;\n        locked_.end = unlock_time;\n        locked[msg.sender] = locked_;\n        if (locked_.delegatee == msg.sender) {\n            // Undelegated lock\n            require(oldUnlockTime > block.timestamp, \"Lock expired\");\n            LockedBalance memory oldLocked = _copyLock(locked_);\n            oldLocked.end = unlock_time;\n            _checkpoint(msg.sender, oldLocked, locked_);\n        }\n        emit Deposit(\n            msg.sender,\n            0,\n            unlock_time,\n            LockAction.INCREASE_TIME,\n            block.timestamp\n        );\n    }\n\n    // See IVotingEscrow for documentation\n    function withdraw() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end <= block.timestamp, \"Lock not expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 value = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.end = 0;\n        newLocked.delegated -= int128(int256(value));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // Send back deposited tokens\n        require(token.transfer(msg.sender, value), \"Transfer failed\");\n        emit Withdraw(msg.sender, value, LockAction.WITHDRAW, block.timestamp);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         DELEGATION         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function delegate(address _addr)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(!IBlocklist(blocklist).isBlocked(_addr), \"Blocked contract\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.delegatee != _addr, \"Already delegated\");\n        // Update locks\n        int128 value = locked_.amount;\n        address delegatee = locked_.delegatee;\n        LockedBalance memory fromLocked;\n        LockedBalance memory toLocked;\n        locked_.delegatee = _addr;\n        if (delegatee == msg.sender) {\n            // Delegate\n            fromLocked = locked_;\n            toLocked = locked[_addr];\n        } else if (_addr == msg.sender) {\n            // Undelegate\n            fromLocked = locked[delegatee];\n            toLocked = locked_;\n        } else {\n            // Re-delegate\n            fromLocked = locked[delegatee];\n            toLocked = locked[_addr];\n            // Update owner lock if not involved in delegation\n            locked[msg.sender] = locked_;\n        }\n        require(toLocked.amount > 0, \"Delegatee has no lock\");\n        require(toLocked.end > block.timestamp, \"Delegatee lock expired\");\n        require(toLocked.end >= fromLocked.end, \"Only delegate to longer lock\");\n        _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n        _delegate(_addr, toLocked, value, LockAction.DELEGATE);\n    }\n\n    // Delegates from/to lock and voting power\n    function _delegate(\n        address addr,\n        LockedBalance memory _locked,\n        int128 value,\n        LockAction action\n    ) internal {\n        LockedBalance memory newLocked = _copyLock(_locked);\n        if (action == LockAction.DELEGATE) {\n            newLocked.delegated += value;\n            emit Deposit(\n                addr,\n                uint256(int256(value)),\n                newLocked.end,\n                action,\n                block.timestamp\n            );\n        } else {\n            newLocked.delegated -= value;\n            emit Withdraw(\n                addr,\n                uint256(int256(value)),\n                action,\n                block.timestamp\n            );\n        }\n        locked[addr] = newLocked;\n        if (newLocked.amount > 0) {\n            // Only if lock (from lock) hasn't been withdrawn/quitted\n            _checkpoint(addr, _locked, newLocked);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         QUIT LOCK          ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function quitLock() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 value = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.delegated -= int128(int256(value));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.end = 0;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // apply penalty\n        uint256 penaltyRate = _calculatePenaltyRate(locked_.end);\n        uint256 penaltyAmount = (value * penaltyRate) / 10**18; // quitlock_penalty is in 18 decimals precision\n        penaltyAccumulated += penaltyAmount;\n        uint256 remainingAmount = value - penaltyAmount;\n        // Send back remaining tokens\n        require(token.transfer(msg.sender, remainingAmount), \"Transfer failed\");\n        emit Withdraw(msg.sender, value, LockAction.QUIT, block.timestamp);\n    }\n\n    // Calculate penalty rate (decreasing linearly)\n    function _calculatePenaltyRate(uint256 end)\n        internal\n        view\n        returns (uint256)\n    {\n        // We know that end > block.timestamp because expired locks cannot be quitted\n        return ((end - block.timestamp) * maxPenalty) / MAXTIME;\n    }\n\n    /// @notice Collect accumulated penalty from quitters\n    /// @dev Everyone can collect but penalty is sent to `penaltyRecipient`\n    function collectPenalty() external {\n        uint256 amount = penaltyAccumulated;\n        penaltyAccumulated = 0;\n        require(token.transfer(penaltyRecipient, amount), \"Transfer failed\");\n        emit CollectPenalty(amount, penaltyRecipient);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///            GETTERS         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // Creates a copy of a lock\n    function _copyLock(LockedBalance memory _locked)\n        internal\n        pure\n        returns (LockedBalance memory)\n    {\n        return\n            LockedBalance({\n                amount: _locked.amount,\n                end: _locked.end,\n                delegatee: _locked.delegatee,\n                delegated: _locked.delegated\n            });\n    }\n\n    // @dev Floors a timestamp to the nearest weekly increment\n    // @param _t Timestamp to floor\n    function _floorToWeek(uint256 _t) internal pure returns (uint256) {\n        return (_t / WEEK) * WEEK;\n    }\n\n    // @dev Uses binarysearch to find the most recent point history preceeding block\n    // @param _block Find the most recent point history before this block\n    // @param _maxEpoch Do not search pointHistories past this index\n    function _findBlockEpoch(uint256 _block, uint256 _maxEpoch)\n        internal\n        view\n        returns (uint256)\n    {\n        // Binary search\n        uint256 min = 0;\n        uint256 max = _maxEpoch;\n        // Will be always enough for 128-bit numbers\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n            uint256 mid = (min + max + 1) / 2;\n            if (pointHistory[mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // @dev Uses binarysearch to find the most recent user point history preceeding block\n    // @param _addr User for which to search\n    // @param _block Find the most recent point history before this block\n    function _findUserBlockEpoch(address _addr, uint256 _block)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 min = 0;\n        uint256 max = userPointEpoch[_addr];\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) {\n                break;\n            }\n            uint256 mid = (min + max + 1) / 2;\n            if (userPointHistory[_addr][mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOf(address _owner) public view override returns (uint256) {\n        uint256 epoch = userPointEpoch[_owner];\n        if (epoch == 0) {\n            return 0;\n        }\n        Point memory lastPoint = userPointHistory[_owner][epoch];\n        lastPoint.bias =\n            lastPoint.bias -\n            (lastPoint.slope * int128(int256(block.timestamp - lastPoint.ts)));\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOfAt(address _owner, uint256 _blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        // Get most recent user Point to block\n        uint256 userEpoch = _findUserBlockEpoch(_owner, _blockNumber);\n        if (userEpoch == 0) {\n            return 0;\n        }\n        Point memory upoint = userPointHistory[_owner][userEpoch];\n\n        // Get most recent global Point to block\n        uint256 maxEpoch = globalEpoch;\n        uint256 epoch = _findBlockEpoch(_blockNumber, maxEpoch);\n        Point memory point0 = pointHistory[epoch];\n\n        // Calculate delta (block & time) between user Point and target block\n        // Allowing us to calculate the average seconds per block between\n        // the two points\n        uint256 dBlock = 0;\n        uint256 dTime = 0;\n        if (epoch < maxEpoch) {\n            Point memory point1 = pointHistory[epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dTime = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dTime = block.timestamp - point0.ts;\n        }\n        // (Deterministically) Estimate the time at which block _blockNumber was mined\n        uint256 blockTime = point0.ts;\n        if (dBlock != 0) {\n            blockTime =\n                blockTime +\n                ((dTime * (_blockNumber - point0.blk)) / dBlock);\n        }\n        // Current Bias = most recent bias - (slope * time since update)\n        upoint.bias =\n            upoint.bias -\n            (upoint.slope * int128(int256(blockTime - upoint.ts)));\n        if (upoint.bias >= 0) {\n            return uint256(uint128(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Calculate total supply of voting power at a given time _t\n    /// @param _point Most recent point before time _t\n    /// @param _t Time at which to calculate supply\n    /// @return totalSupply at given point in time\n    function _supplyAt(Point memory _point, uint256 _t)\n        internal\n        view\n        returns (uint256)\n    {\n        Point memory lastPoint = _point;\n        // Floor the timestamp to weekly interval\n        uint256 iterativeTime = _floorToWeek(lastPoint.ts);\n        // Iterate through all weeks between _point & _t to account for slope changes\n        for (uint256 i = 0; i < 255; i++) {\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            // If week end is after timestamp, then truncate & leave dSlope to 0\n            if (iterativeTime > _t) {\n                iterativeTime = _t;\n            }\n            // else get most recent slope change\n            else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n\n            lastPoint.bias =\n                lastPoint.bias -\n                (lastPoint.slope *\n                    int128(int256(iterativeTime - lastPoint.ts)));\n            if (iterativeTime == _t) {\n                break;\n            }\n            lastPoint.slope = lastPoint.slope + dSlope;\n            lastPoint.ts = iterativeTime;\n        }\n\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupply() public view override returns (uint256) {\n        uint256 epoch_ = globalEpoch;\n        Point memory lastPoint = pointHistory[epoch_];\n        return _supplyAt(lastPoint, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupplyAt(uint256 _blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        uint256 epoch = globalEpoch;\n        uint256 targetEpoch = _findBlockEpoch(_blockNumber, epoch);\n\n        Point memory point = pointHistory[targetEpoch];\n\n        // If point.blk > _blockNumber that means we got the initial epoch & contract did not yet exist\n        if (point.blk > _blockNumber) {\n            return 0;\n        }\n\n        uint256 dTime = 0;\n        if (targetEpoch < epoch) {\n            Point memory pointNext = pointHistory[targetEpoch + 1];\n            if (point.blk != pointNext.blk) {\n                dTime =\n                    ((_blockNumber - point.blk) * (pointNext.ts - point.ts)) /\n                    (pointNext.blk - point.blk);\n            }\n        } else if (point.blk != block.number) {\n            dTime =\n                ((_blockNumber - point.blk) * (block.timestamp - point.ts)) /\n                (block.number - point.blk);\n        }\n        // Now dTime contains info on how far are we beyond point\n        return _supplyAt(point, point.ts + dTime);\n    }\n}\n\n\n",
        "CodeNames": [
            "VotingEscrow.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "transferFrom",
                    "token",
                    "transfer"
                ],
                "Type": " Unsafe usage of ERC20 transfer and transferFrom ",
                "Description": "\n<https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L425-L428<br\n<https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L485-L488<br\n<https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L546<br\n<https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L657<br\n<https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L676<br\n\nSome ERC20 tokens functions don't return a boolean, for example USDT, BNB, OMG. So the VotingEscrow contract simply won't work with tokens like that as the token.\n\n\nThe USDT's transfer and transferFrom functions doesn't return a bool, so the call to these functions will revert although the user has enough balance and the VotingEscrow contract won't work, assuming that token is USDT.\n\n\nManual auditing VS Code, some hardhat tests and me :)\n\n",
                "Repair": "\nUse the OpenZepplin's safeTransfer and safeTransferFrom functions.\n\nlacoop6tu (FIAT DAO) disputed and commented(https://github.com/code-423n4/2022-08-fiatdao-findings/issues/231#issuecomment-1216336341):\n  In our case the token is a BalancerV2 Pool Token which returns the boolean\n\nJustin Goro (judge) commented(https://github.com/code-423n4/2022-08-fiatdao-findings/issues/231#issuecomment-1232382424):\n  This should be acknowledged, not disputed, since there is nothing in documentation suggesting the token is inherently safe to use. \n\nelnilz (FIAT DAO) commented(https://github.com/code-423n4/2022-08-fiatdao-findings/issues/231#issuecomment-1241595744):\n  @Justin Goro it's a no-issue in our specific case bc we will use VotingEscrow in combination with token which returns bool upon transfer/transferFrom. So at best this is a QA issue bc we should document that. some wardens actually asked us about what token we will be using pointing out the issue.\n \n Now even if you'd want to award wardens who reported the issue it should then be a Med Risk bc if VotingEscrow is deployed with an unsafe token ppl would simply not be able to deposit into the contract but no funds would be at risk.\n\nelnilz (FIAT DAO) commented(https://github.com/code-423n4/2022-08-fiatdao-findings/issues/231#issuecomment-1242096432):\n  Fyi, even though we don't think this is an issue, we will make use of safeTransfer and safeTransferFrom so its a helpful submission nonetheless.\n\nJustin Goro (judge) commented(https://github.com/code-423n4/2022-08-fiatdao-findings/issues/231#issuecomment-1242900816):\n  It's tokens like BNB that led me to maintain the high risk rating. For BNB, transferFrom returns a bool but transfer doesn't. In other words, users can stake but not unstake on any protocol that doesn't use safeTransfer.\n \n I agree that wardens should contact sponsors but it's not a channel we can really monitor. So although the net result is a documentation fix rather than a bug fix, it's a documentation fix informed by the identification of a potentially show stopping bug rather than something like \"Comment typo: it should be Bitcoin, not bit coin\".\n\nIllIllI (warden) reviewed mitigation:\n  The sponsor disputed the issue because the token it's planned to be used with does correctly return a boolean. However, the sponsor decided to make a change to address the finding as Issue 18(https://github.com/fiatdao/veFDT/pull/19/files/9d532c58e30e9730050fe26dd82bb4c293691001). The fix properly replaces the require() statements that check for successful transfers, with calls to OpenZeppelin's safeTransfer(). The PR also replaces the internal definition of the IERC20 interface with OpenZeppelin's version. The prior version of the code's IERC20 included the function decimals(), which is not one of the required functions for the interface, so it's possible for the code to encounter a token without this function, but it would be immediately apparent what happened because the constructor is the function that calls decimals(). The change to using OpenZeppelin required making this distinction more visible due to the fact that they're defined separately as IERC20 and IERC20Metadata. The new code is not checking that the token actually supports the function (e.g. using a safeDecimals()-like function), but it is not any worse off that it had been prior to the change.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport { IVotingEscrow } from \"../interfaces/IVotingEscrow.sol\";\n\n/// @title Blocklist Checker implementation.\n/// @notice Checks if an address is blocklisted\n/// @dev This is a basic implementation using a mapping for address => bool\ncontract Blocklist {\n    mapping(address => bool) private _blocklist;\n    address public manager;\n    address public ve;\n\n    constructor(address _manager, address _ve) {\n        manager = _manager;\n        ve = _ve;\n    }\n\n    /// @notice Add address to blocklist\n    /// @dev only callable by owner.\n    /// @dev Allows blocklisting only of smart contracts\n    /// @param addr The contract address to blocklist\n    function block(address addr) external {\n        require(msg.sender == manager, \"Only manager\");\n        require(_isContract(addr), \"Only contracts\");\n        _blocklist[addr] = true;\n        IVotingEscrow(ve).forceUndelegate(addr);\n    }\n\n    /// @notice Check an address\n    /// @dev This method will be called by the VotingEscrow contract\n    /// @param addr The contract address to check\n    function isBlocked(address addr) public view returns (bool) {\n        return _blocklist[addr];\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "Blocklist.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "block(RiderAddress)"
                ],
                "Type": " Delegators can Avoid Lock Commitments if they can Reliably get Themselves Blocked when Needed",
                "Description": "\n<https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L526-L625<br\n\nUsers can enjoy the voting power of long lock times whilst not committing their tokens. This could cause the entire system to break down as the incentives don't work any more.\n\n\nThis exploit only works if a user is able to use the system and reliably get themselves blocked. Blocking policies are not in scope, so I am assuming there would be a list of bannable offences, and thus this condition could be fulfilled.<br\nConsider a user with two accounts, called Rider and Horse.<br\nRider has 100,000 tokens.<br\nHorse has 1 token.<br\nRider is a smart contract (required for an account to be bannable).<br\nRider locks for 1 week.<br\nHorse locks for 52 weeks.<br\nRider delegates to Horse.<br\nHorse can continue to extend its lock period and enjoy the maximised voting power.<br\nWhenever the user wants their tokens back, they simply need to get the Rider account blocked.<br\nWhen Rider is blocked, Blocklist.block(RiderAddress) is called, which in turn calls ve.forceUndelegate(RiderAddress).<br\nRider is now an undelegated account with an expired lock. It can call ve.withdraw() to get its tokens back.<br\nThe user can repeat this process with a fresh account taking the role of Rider.\n\n",
                "Repair": "\nforceUndelegate() could be made to set locked_.end = fromLocked.end. This would mean that blocked users are still locked into the system for the period they delegated for. However, this does have the downside of tokens being locked in the system without the full rights of the system which other users enjoy.<br\nAlternatively, this might be addressable through not blocking users that seem to be doing this, but of course that might have other undersirable consequences.\n\n### Proof of Concept\n\nPlease see warden's full report(https://github.com/code-423n4/2022-08-fiatdao-findings/issues/204) for proof of concept.\n\nlacoop6tu (FIAT DAO) confirmed, but disagreed with severity and commented(https://github.com/code-423n4/2022-08-fiatdao-findings/issues/204#issuecomment-1217847907):\n  2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\nJustin Goro (judge) commented(https://github.com/code-423n4/2022-08-fiatdao-findings/issues/204#issuecomment-1236040176):\n  Well spotted by warden! The inflation of voting points may lead to an exploit, depending on possible proposals. Severity maintained.\n\nIllIllI (warden) reviewed mitigation:\n  The sponsor disagreed with the severity and the judge updated the issue to be of Medium risk, and I agree with that severity. The finding was addressed via the fix for Issue 6(https://github.com/fiatdao/veFDT/pull/11/files/01aa495c4127d44025e442421a2d58256ee36f06) where the sponsor implemented the suggestion of the warden, to use the delegatee's lock endpoint in the re-delegation to self, rather than using the delegator's existing endpoint, since that endpoint may be far in the past. The delegate() and undelegate() functions have checks to ensure that the target for the votes always has at least as long a duration as the source of the votes. The fix enforces the same requirement for forceUndelegate() by assigning a longer duration.\n  \n  There are only two places in the code that change LockedBalance.end to a smaller value, which could possibly violate the contract invariants: in quitLock()(https://github.com/fiatdao/veFDT/blob/01aa495c4127d44025e442421a2d58256ee36f06/contracts/VotingEscrow.sol#L646-L651) where the struct is never written back to storage, and in withdraw()(https://github.com/fiatdao/veFDT/blob/01aa495c4127d44025e442421a2d58256ee36f06/contracts/VotingEscrow.sol#L537-L541) where it is indeed written back to storage. However, if the delegatee was able to withdraw, that means the delegator already would have been able to withdraw (since the delegatee's timestamp must always be greater than or equal to the delegator's when delegating(https://github.com/code-423n4/2022-08-fiatdao/blob/main/CheckpointMath.md#delegate) or increasing(https://github.com/code-423n4/2022-08-fiatdao/blob/main/CheckpointMath.md#increaseamount)), and therefore the mitigation is correct. The only extra wrinkle that the change makes, is that it now allows a malicious delegatee to front-run a delegator's block with an increaseUnlock(MAXTIME), but it's not clear what advantage that would give the delegatee, and furthermore, the delegator already put his/her trust in the delegatee, so it's something that could have occurred anyway, even without a call to forceUndelegate().\n\n\n\n*\n \n\n"
            }
        ]
    }
]