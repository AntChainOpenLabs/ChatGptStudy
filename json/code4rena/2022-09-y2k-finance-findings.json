[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10(18 priceFeed1.decimals()));\nreturn nowPrice / 1000000;\n",
                    "//solidity\nPegOracle pegOracle3 = new PegOracle(\n            0xB1552C5e96B312d0Bf8b554186F846C40614a540,  //usd-eth contract address\n            btcEthOracle\n        );\n"
                ],
                "Type": " Incorrect handling of  pricefeed.decimals() ",
                "Description": "*Submitted by carrotsmuggler, also found by 0x52, 0xDecorativePineapple, 0xPanas, auditor0517, Bahurum, durianSausage, hyh, Jeiwan, ladboy233, Lambda, pauliax, PwnPatrol, R2, Respx, scaraven, teawaterwire, and zzzitron*\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L46-L83\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300\n\n\nWrong math for handling pricefeed decimals. This code will only work for pricefeeds of 8 decimals, any others give wrong/incorrect data. The maths used can be shown in three lines:\n\nsolidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10(18 priceFeed1.decimals()));\nreturn nowPrice / 1000000;\n\n\nLine1: adds 4 decimals\nLine2: adds (18 d) decimals, (where d = pricefeed.decimals())\nLine3:  removes 6 decimals\n\nTotal: adds (16 d) decimals\n\nwhen d=8, the contract correctly returns an 8 decimal number. However, when d = 6, the function will return a 10 decimal number. This is further raised by (18-d = 12) decimals when checking for depeg event, leading to a 22 decimal number which is 4 orders of magnitude incorrect.\n\nif d=18, (like usd-eth pricefeeds) contract fails / returns 0.\n\nAll chainlink contracts which give price in eth, operate with 18 decimals. So this can cripple the system if added later.\n\n\nRunning the test  AssertTest.t.sol:testPegOracleMarketCreation and changing the line on\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/test/AssertTest.t.sol#L30\n\nto\n\nsolidity\nPegOracle pegOracle3 = new PegOracle(\n            0xB1552C5e96B312d0Bf8b554186F846C40614a540,  //usd-eth contract address\n            btcEthOracle\n        );\n\n\ngives this output\n\n    oracle3price1: 1085903802394919427                                                                                                                                                                               \n    oracle3price2: 13753840915281064000                                                                                                                                                                              \n    oracle3price1 / oracle3price2: 0\n\nreturning an oracle value of 0. Simulating with a mock price feed of 6 decimals gives results 4 orders of magnitude off.\n\n\nFoundry, VS-Code\n\n",
                "Repair": "\nSince only the price ratio is calculated, there is no point in increasing the decimal by (18-d) in the second line. Proposed solution:\n\nsolidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10(priceFeed1.decimals())) * 100;\nreturn nowPrice / 1000000;\n\n\nThis returns results in d decimals, no matter the value of d.\n\nMiguelBits (Y2K Finance) confirmed(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/195) \n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n    \n    < ... omitted ... \n\n    emit DepegInsurance(\n        keccak256(\n            abi.encodePacked(\n                marketIndex,\n                insrVault.idEpochBegin(epochEnd),\n                epochEnd\n            )\n        ),\n        tvl,\n        false,\n        epochEnd,\n        block.timestamp,\n        getLatestPrice(insrVault.tokenInsured()) // @audit getLatestPrice reverts while sequencer unavailable or during grace period\n    );\n}\n",
                    "//solidity\nfunction getLatestPrice(address _token)\n    public\n    view\n    returns (int256 nowPrice)\n{\n    < ... omitted ... \n\n    bool isSequencerUp = answer == 0;\n    if (!isSequencerUp) {\n        revert SequencerDown();\n    }\n\n    // Make sure the grace period has passed after the sequencer is back up.\n    uint256 timeSinceUp = block.timestamp startedAt;\n    if (timeSinceUp <= GRACE_PERIOD_TIME) { // @audit 1 hour\n        revert GracePeriodNotOver();\n    }\n\n    < ... omitted ... \n}\n",
                    "//solidity\nfunction withdraw(\n    uint256 id,\n    uint256 assets,\n    address receiver,\n    address owner\n)\n    external\n    override\n    epochHasEnded(id) // @audit same as require((block.timestamp  id) || idDepegged[id]), hence independent from triggers.\n    marketExists(id)\n    returns (uint256 shares)\n{\n    < ... omitted ... \n\n    uint256 entitledShares = beforeWithdraw(id, shares); // @audit ratio is idClaimTVL[id]/ifFinalTVL[id], hence zero unless triggers executed\n    \n    < ... omitted ... \n\n    emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n    asset.transfer(receiver, entitledShares);\n\n    return entitledShares;\n}\n"
                ],
                "Type": " End epoch cannot be triggered preventing winners to withdraw",
                "Description": "*Submitted by eierina*\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L277-L286\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203\n\n\nAt the end of an epoch, the triggerEndEpoch(...)(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) is called to trigger 'epoch end without depeg event', making risk users the winners and entitling them to withdraw(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203) (risk + hedge) from the vault.\nIn the case of the Arbitrum sequencer going down or restarting, there is a grace period of one hour(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L285) before the getLatestPrice()(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261) returns to execute without reverting. This means that the triggerEndEpoch(...)(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) cannot complete during this time, because it calls the getLatestPrice()(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261).\n\nMaking this high-priority because unless the triggerEndEpoch(...)(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) completes:\n\n*   winners cannot withdraw(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203) althought the epoch is over;\n*   during this time the strike price might be reached causing a depeg event at all effects turning the table for the winners;\n*   the getLatestPrice()(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261) is not functional to the completion of the triggerEndEpoch(...)(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198), nor to the withdraw(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203), but only informative used to initialize the event object emitted at the very end of the triggerEndEpoch function(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246).\n\nFirst two points each constitute independent justification, third point reinforces the first 2 points.\n\n\n\nFile: Controller.sol:L246(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246)\n\nRevert if getLatestPrice reverts.\n\nsolidity\nfunction triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n    \n    < ... omitted ... \n\n    emit DepegInsurance(\n        keccak256(\n            abi.encodePacked(\n                marketIndex,\n                insrVault.idEpochBegin(epochEnd),\n                epochEnd\n            )\n        ),\n        tvl,\n        false,\n        epochEnd,\n        block.timestamp,\n        getLatestPrice(insrVault.tokenInsured()) // @audit getLatestPrice reverts while sequencer unavailable or during grace period\n    );\n}\n\n\nFile: Controller.sol:L277-L286(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L277-L286)\n\nRevert if sequencer down or grace period after restart not over.\n\nsolidity\nfunction getLatestPrice(address _token)\n    public\n    view\n    returns (int256 nowPrice)\n{\n    < ... omitted ... \n\n    bool isSequencerUp = answer == 0;\n    if (!isSequencerUp) {\n        revert SequencerDown();\n    }\n\n    // Make sure the grace period has passed after the sequencer is back up.\n    uint256 timeSinceUp = block.timestamp startedAt;\n    if (timeSinceUp <= GRACE_PERIOD_TIME) { // @audit 1 hour\n        revert GracePeriodNotOver();\n    }\n\n    < ... omitted ... \n}\n\n\n\nFile: Vault.sol:L203(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203)\n\nCan execute if block.timestamp  epochEnd, but fails if trigger did not execute. Winners cannot withdraw.\n\nsolidity\nfunction withdraw(\n    uint256 id,\n    uint256 assets,\n    address receiver,\n    address owner\n)\n    external\n    override\n    epochHasEnded(id) // @audit same as require((block.timestamp  id) || idDepegged[id]), hence independent from triggers.\n    marketExists(id)\n    returns (uint256 shares)\n{\n    < ... omitted ... \n\n    uint256 entitledShares = beforeWithdraw(id, shares); // @audit ratio is idClaimTVL[id]/ifFinalTVL[id], hence zero unless triggers executed\n    \n    < ... omitted ... \n\n    emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n    asset.transfer(receiver, entitledShares);\n\n    return entitledShares;\n}\n\n\n",
                "Repair": "\nThe latest price is retrieved at the very end of the triggerEndEpoch(...)(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) for the only purpose of initializing the DepegInsurance event.\nSince it is used for informational purpose (logging / offchain logging) and not for functional purpose to the triggerEndEpoch(...)(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) execution, it can be relaxed.\n\nDepending on how the event is used, when getLatestPrice() is called for informative/logging purpose only, there could be few alternatives:\n\n*   log a 0 when SequencerDown or GRACE_PERIOD_TIME not passed\n*   log a 0 when SequencerDown and ignore GRACE_PERIOD_TIME\n\nOnce events are logged off-chain, some post processing may be used to correct/update the values with accurate data.\n\n3xHarry (Y2K Finance) commented(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/278#issuecomment-1254787198):\n  Great catch!\n\nMiguelBits (Y2K Finance) confirmed and commented(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/278#issuecomment-1256542257):\n  Fixed this by changing triggerEndEpoch, \n \n AggregatorV3Interface priceFeed = AggregatorV3Interface(\n             vaultFactory.tokenToOracle(insrVault.tokenInsured())\n         );\n         (\n             ,  \n             int256 price,\n             ,\n             ,\n             \n         ) = priceFeed.latestRoundData();\n \n         emit DepegInsurance(\n             keccak256(\n                 abi.encodePacked(\n                     marketIndex,\n                     insrVault.idEpochBegin(epochEnd),\n                     epochEnd\n                 )\n             ),\n             tvl,\n             true,\n             epochEnd,\n             block.timestamp,\n             price\n         );\n \n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/278#issuecomment-1281790980):\n  Agree with the points raised by the warden, especially on how getLatestPrice() is merely for informational purposes in the event emission.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SemiFungibleVault} from \"./SemiFungibleVault.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract Vault is SemiFungibleVault, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error AddressZero();\n    error AddressNotFactory(address _contract);\n    error AddressNotController(address _contract);\n    error MarketEpochDoesNotExist();\n    error EpochAlreadyStarted();\n    error EpochNotFinished();\n    error FeeMoreThan150(uint256 _fee);\n    error ZeroValue();\n    error OwnerDidNotAuthorize(address _sender, address _owner);\n    error EpochEndMustBeAfterBegin();\n    error MarketEpochExists();\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable tokenInsured;\n    address private treasury;\n    int256 public immutable strikePrice;\n    address private immutable factory;\n    address public controller;\n\n    uint256[] public epochs;\n    uint256 public timewindow;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => uint256) public idFinalTVL;\n    mapping(uint256 => uint256) public idClaimTVL;\n    // @audit uint32 for timestamp is enough for the next 80 years\n    mapping(uint256 => uint256) public idEpochBegin;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idDepegged;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idExists;\n    mapping(uint256 => uint256) public epochFee;\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only factory addresses can call functions that use this modifier\n      */\n    modifier onlyFactory() {\n        if(msg.sender != factory)\n            revert AddressNotFactory(msg.sender);\n        _;\n    }\n\n    /** @notice Only controller addresses can call functions that use this modifier\n      */\n    modifier onlyController() {\n        if(msg.sender != controller)\n            revert AddressNotController(msg.sender);\n        _;\n    }\n\n    /** @notice Only market addresses can call functions that use this modifier\n      */\n    modifier marketExists(uint256 id) {\n        if(idExists[id] != true)\n            revert MarketEpochDoesNotExist();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier before the current epoch has started\n      */\n    modifier epochHasNotStarted(uint256 id) {\n        if(block.timestamp > idEpochBegin[id] - timewindow)\n            revert EpochAlreadyStarted();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier after the current epoch has started\n      */\n    modifier epochHasEnded(uint256 id) {\n        if((block.timestamp < id) && idDepegged[id] == false)\n            revert EpochNotFinished();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice constructor\n        @param  _assetAddress    token address representing your asset to be deposited;\n        @param  _name   token name for the ERC1155 mints. Insert the name of your token; Example: Y2K_USDC_1.2$\n        @param  _symbol token symbol for the ERC1155 mints. insert here if risk or hedge + Symbol. Example: HedgeY2K or riskY2K;\n        @param  _token  address of the oracle to lookup the price in chainlink oracles;\n        @param  _strikePrice    uint256 representing the price to trigger the depeg event;\n        @param _controller  address of the controller contract, this contract can trigger the depeg events;\n     */\n    constructor(\n        address _assetAddress,\n        string memory _name,\n        string memory _symbol,\n        address _treasury,\n        address _token,\n        int256 _strikePrice,\n        address _controller\n    ) SemiFungibleVault(ERC20(_assetAddress), _name, _symbol) {\n\n        if(_treasury == address(0))\n            revert AddressZero();\n\n        if(_controller == address(0))\n            revert AddressZero();\n\n        if(_token == address(0))\n            revert AddressZero();\n\n        tokenInsured = _token;\n        treasury = _treasury;\n        strikePrice = _strikePrice;\n        factory = msg.sender;\n        controller = _controller;\n        timewindow = 1 days;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Deposit function from ERC4626, with payment of a fee to a treasury implemented;\n        @param  id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param  assets  uint256 representing how many assets the user wants to deposit, a fee will be taken from this value;\n        @param receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n        @return shares how many assets the owner is entitled to, removing the fee from it's shares;\n     */\n    function deposit(\n        uint256 id,\n        uint256 assets,\n        address receiver\n    )\n        public\n        override\n        marketExists(id)\n        epochHasNotStarted(id)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(id, assets)) != 0, \"ZeroValue\");\n\n        asset.transferFrom(msg.sender, address(this), shares);\n\n        _mint(receiver, id, shares, EMPTY);\n\n        emit Deposit(msg.sender, receiver, id, shares, shares);\n\n        return shares;\n    }\n\n    /**\n        @notice Deposit ETH function\n        @param  id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n        @return shares how many assets the owner is entitled to, removing the fee from its shares;\n     */\n    function depositETH(uint256 id, address receiver)\n        external\n        payable\n        returns (uint256 shares)\n    {\n        require(msg.value > 0, \"ZeroValue\");\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n        assert(IWETH(address(asset)).transfer(msg.sender, msg.value));\n\n        return deposit(id, msg.value, receiver);\n    }\n\n    /**\n    @notice Withdraw entitled deposited assets, checking if a depeg event //TODO add GOV token rewards\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n    @param assets   uint256 of how many assets you want to withdraw, this value will be used to calculate how many assets you are entitle to according to the events;\n    @param receiver  Address of the receiver of the assets provided by this function, that represent the ownership of the transfered asset;\n    @param owner    Address of the owner of these said assets;\n    @return shares How many shares the owner is entitled to, according to the conditions;\n     */\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        uint256 entitledShares = beforeWithdraw(id, shares);\n        _burn(owner, id, shares);\n\n        //Taking fee from the amount\n        uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);\n        entitledShares = entitledShares - feeValue;\n        asset.transfer(treasury, feeValue);\n\n        emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n        asset.transfer(receiver, entitledShares);\n\n        return entitledShares;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice returns total assets for the id of given epoch\n        @param  _id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n     */\n    function totalAssets(uint256 _id)\n        public\n        view\n        override\n        marketExists(_id)\n        returns (uint256)\n    {\n        return totalSupply(_id);\n    }\n\n    /**\n    @notice Calculates how much ether the %fee is taking from @param amount\n    @param amount Amount to withdraw from vault\n    @param _epoch Target epoch\n    @return feeValue Current fee value\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 _epoch)\n        public\n        view\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 1000 then divide by 5\n        return (amount * epochFee[_epoch]) / 1000;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           Factory FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Factory function, changes treasury address\n    @param _treasury New treasury address\n     */\n    function changeTreasury(address _treasury) public onlyFactory {\n        if(_treasury == address(0))\n            revert AddressZero();\n        treasury = _treasury;\n    }\n\n    /**\n    @notice Factory function, changes vault time window\n    @param _timewindow New vault time window\n     */\n    function changeTimewindow(uint256 _timewindow) public onlyFactory {\n        timewindow = _timewindow;\n    }\n\n    /**\n    @notice Factory function, changes controller address\n    @param _controller New controller address\n     */\n    function changeController(address _controller) public onlyFactory {\n        if(_controller == address(0))\n            revert AddressZero();\n        controller = _controller;\n    }\n\n    /**\n    @notice Function to deploy hedge assets for given epochs, after the creation of this vault\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function createAssets(uint256 epochBegin, uint256 epochEnd, uint256 _withdrawalFee)\n        public\n        onlyFactory\n    {\n        if(_withdrawalFee > 150)\n            revert FeeMoreThan150(_withdrawalFee);\n\n        if(idExists[epochEnd] == true)\n            revert MarketEpochExists();\n        \n        if(epochBegin >= epochEnd)\n            revert EpochEndMustBeAfterBegin();\n\n        idExists[epochEnd] = true;\n        idEpochBegin[epochEnd] = epochBegin;\n        epochs.push(epochEnd);\n\n        epochFee[epochEnd] = _withdrawalFee;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Controller can call this function to trigger the end of the epoch, storing the TVL of that epoch and if a depeg event occurred\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param depeg Boolean value indicating if the depeg event occurred, or not. Example: If depeg occurred depeg = true\n     */\n    function endEpoch(uint256 id, bool depeg)\n        public\n        onlyController\n        marketExists(id)\n    {\n        idDepegged[id] = depeg;\n        idFinalTVL[id] = totalAssets(id);\n    }\n\n    /**\n    @notice Function to be called after endEpoch, by the Controller only, this function stores the TVL of the counterparty vault in a mapping to be used for later calculations of the entitled withdraw\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param claimTVL uint256 representing the TVL the counterparty vault has, storing this value in a mapping\n     */\n    function setClaimTVL(uint256 id, uint256 claimTVL) public onlyController {\n        idClaimTVL[id] = claimTVL;\n    }\n\n    /**\n    solhint-disable-next-line max-line-length\n    @notice Function to be called after endEpoch and setClaimTVL functions, respecting the calls in order, after storing the TVL of the end of epoch and the TVL amount to claim, this function will allow the transfer of tokens to the counterparty vault\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param _counterparty Address of the other vault, meaning address of the risk vault, if this is an hedge vault, and vice-versa\n    */\n    function sendTokens(uint256 id, address _counterparty)\n        public\n        onlyController\n        marketExists(id)\n    {\n        asset.transfer(_counterparty, idFinalTVL[id]);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Calculations of how much the user will receive;\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param amount uint256 of the amount the user wants to withdraw\n    @return entitledAmount How much amount the user will receive, according to the conditions\n    */\n    function beforeWithdraw(uint256 id, uint256 amount)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        // in case the risk wins aka no depeg event\n        // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)\n        // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool\n        // in case there is a depeg event, the risk users can only withdraw the hedge\n        if (\n            keccak256(abi.encodePacked(symbol)) ==\n            keccak256(abi.encodePacked(\"rY2K\"))\n        ) {\n            if (!idDepegged[id]) {\n                //depeg event did not happen\n                /*\n                entitledAmount =\n                    (amount / idFinalTVL[id]) *\n                    idClaimTVL[id] +\n                    amount;\n                */\n                entitledAmount =\n                    amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                        idClaimTVL[id],\n                        1 ether\n                    ) +\n                    amount;\n            } else {\n                //depeg event did happen\n                entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                    idClaimTVL[id],\n                    1 ether\n                );\n            }\n        }\n        // in case the hedge wins aka depegging\n        // hedge users pay the hedge to risk users anyway,\n        // hedge guy can withdraw risk (that is transfered from the risk pool),\n        // withdraw = % tvl that hedge buyer owns\n        // otherwise hedge users cannot withdraw any Eth\n        else {\n            entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                idClaimTVL[id],\n                1 ether\n            );\n        }\n\n        return entitledAmount;\n    }\n    \n    /** @notice Lookup total epochs length\n      */\n    function epochsLength() public view returns (uint256) {\n        return epochs.length;\n    }\n\n    /** @notice Lookup next epochs' end from target\n        @param _epoch Target epoch\n        @return nextEpochEnd Next epoch end\n      */\n    function getNextEpoch(uint256 _epoch)\n        public\n        view\n        returns (uint256 nextEpochEnd)\n    {\n        for (uint256 i = 0; i < epochsLength(); i++) {\n            if (epochs[i] == _epoch) {\n                if (i == epochsLength() - 1) {\n                    return 0;\n                }\n                return epochs[i + 1];\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"forge-std/Script.sol\";\nimport \"../src/VaultFactory.sol\";\nimport \"../src/Controller.sol\";\nimport \"../src/rewards/RewardsFactory.sol\";\nimport \"../test/GovToken.sol\";\nimport \"../test/oracles/DepegOracle.sol\";\n\n/*\nforge script script/Maintain.s.sol:MaintainScript --rpc-url $ARBITRUM_RINKEBY_RPC_URL  --private-key $PRIVATE_KEY --broadcast -vv\n\nController address 0xE3790E0bc21F43868A2527a999A9a11c807AD659\nVault Factory address 0xAD78ccB7F26CAECf09406a0541012330874A8466\nRewards Factory address 0x2c4C123b87Ee0019F830c4AB30118c8f53cD2b9F\nGovToken address 0x4bd30F77809730E38EE59eE0e8FF008407dD3025\n*/\ncontract MaintainScript is Script {\n\n    address vf = 0xb597ADcE4adB828e5CAA724a8F4437568FD8bB6c;\n    address cl = 0xc359A787B34c71A9d1c89b4d88A362afe10970aB;\n    address rf = 0x076d579dc8E204a013e9524942AeAcac1Dd0c62C;\n    //address gt = 0x4bd30F77809730E38EE59eE0e8FF008407dD3025;\n\n    uint256 epochEnd = 1662825600;\n    uint256 epochBegin = block.timestamp;\n\n    uint256 FEE = 55;\n    uint256 nextEpochEnd = epochEnd + 30 minutes;\n    uint256 nextEpochBegin = epochBegin + 20 minutes;\n\n    uint256 rewardsDuration = 10 days;\n    uint256 rewardRate = 10;\n\n    // address tokenUSDC = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;\n    // address tokenDAI = 0x4dCf5ac4509888714dd43A5cCc46d7ab389D9c23;\n\n    // address oracleUSDC = 0x5f0423B1a6935dc5596e7A24d98532b67A0AeFd8;\n    // address oracleDAI = 0x3e3546c6b5689f7EAa1BA7Bc9571322c3168D786;\n\n    function run() public {\n        vm.startBroadcast();\n        Controller controller = Controller(cl);\n        controller.triggerEndEpoch(1, epochEnd);\n        controller.triggerEndEpoch(2, epochEnd);\n        controller.triggerEndEpoch(3, epochEnd);\n        // controller.triggerDepeg(4, epochEnd);\n        // controller.triggerDepeg(5, epochEnd);\n        // controller.triggerDepeg(6, epochEnd);\n        //GovToken govToken = GovToken(gt);\n        //deployMore();\n\n        vm.stopBroadcast();\n    }\n\n    function deployMore() public {\n        VaultFactory vaultFactory = VaultFactory(vf);\n        RewardsFactory rewardsFactory = RewardsFactory(rf);\n        console2.log(\"Market index\", vaultFactory.marketIndex());\n\n        //USDC\n        vaultFactory.deployMoreAssets(1, epochBegin, epochEnd, FEE);\n        rewardsFactory.createStakingRewards(1, epochEnd, rewardsDuration, rewardRate);\n\n        vaultFactory.deployMoreAssets(2, epochBegin, epochEnd, FEE);\n        rewardsFactory.createStakingRewards(2, epochEnd, rewardsDuration, rewardRate);\n\n        vaultFactory.deployMoreAssets(3, epochBegin, epochEnd, FEE);\n        rewardsFactory.createStakingRewards(3, epochEnd, rewardsDuration, rewardRate);\n\n        //DAI\n        vaultFactory.deployMoreAssets(4, epochBegin, epochEnd, FEE);\n        rewardsFactory.createStakingRewards(4, epochEnd, rewardsDuration, rewardRate);\n\n        vaultFactory.deployMoreAssets(5, epochBegin, epochEnd, FEE);\n        rewardsFactory.createStakingRewards(5, epochEnd, rewardsDuration, rewardRate);\n\n        vaultFactory.deployMoreAssets(6, epochBegin, epochEnd, FEE);\n        rewardsFactory.createStakingRewards(6, epochEnd, rewardsDuration, rewardRate);\n    }\n\n}\n\n\npragma solidity 0.4.24;\n\nimport \"./ChainlinkClient.sol\";\nimport \"./interfaces/AggregatorInterface.sol\";\nimport \"./vendor/SignedSafeMath.sol\";\nimport \"./vendor/Ownable.sol\";\nimport \"./vendor/SafeMathChainlink.sol\";\n\n/**\n * @title An example Chainlink contract with aggregation\n * @notice Requesters can use this contract as a framework for creating\n * requests to multiple Chainlink nodes and running aggregation\n * as the contract receives answers.\n */\ncontract Aggregator is AggregatorInterface, ChainlinkClient, Ownable {\n  using SafeMathChainlink for uint256;\n  using SignedSafeMath for int256;\n\n  struct Answer {\n    uint128 minimumResponses;\n    uint128 maxResponses;\n    int256[] responses;\n  }\n\n  event ResponseReceived(int256 indexed response, uint256 indexed answerId, address indexed sender);\n\n  int256 private currentAnswerValue;\n  uint256 private updatedTimestampValue;\n  uint256 private latestCompletedAnswer;\n  uint128 public paymentAmount;\n  uint128 public minimumResponses;\n  bytes32[] public jobIds;\n  address[] public oracles;\n\n  uint256 private answerCounter = 1;\n  mapping(address => bool) public authorizedRequesters;\n  mapping(bytes32 => uint256) private requestAnswers;\n  mapping(uint256 => Answer) private answers;\n  mapping(uint256 => int256) private currentAnswers;\n  mapping(uint256 => uint256) private updatedTimestamps;\n\n  uint256 constant private MAX_ORACLE_COUNT = 28;\n\n  /**\n   * @notice Deploy with the address of the LINK token and arrays of matching\n   * length containing the addresses of the oracles and their corresponding\n   * Job IDs.\n   * @dev Sets the LinkToken address for the network, addresses of the oracles,\n   * and jobIds in storage.\n   * @param _link The address of the LINK token\n   * @param _paymentAmount the amount of LINK to be sent to each oracle for each request\n   * @param _minimumResponses the minimum number of responses\n   * before an answer will be calculated\n   * @param _oracles An array of oracle addresses\n   * @param _jobIds An array of Job IDs\n   */\n  constructor(\n    address _link,\n    uint128 _paymentAmount,\n    uint128 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  ) public Ownable() {\n    setChainlinkToken(_link);\n    updateRequestDetails(_paymentAmount, _minimumResponses, _oracles, _jobIds);\n  }\n\n  /**\n   * @notice Creates a Chainlink request for each oracle in the oracles array.\n   * @dev This example does not include request parameters. Reference any documentation\n   * associated with the Job IDs used to determine the required parameters per-request.\n   */\n  function requestRateUpdate()\n    external\n    ensureAuthorizedRequester()\n  {\n    Chainlink.Request memory request;\n    bytes32 requestId;\n    uint256 oraclePayment = paymentAmount;\n\n    for (uint i = 0; i < oracles.length; i++) {\n      request = buildChainlinkRequest(jobIds[i], this, this.chainlinkCallback.selector);\n      requestId = sendChainlinkRequestTo(oracles[i], request, oraclePayment);\n      requestAnswers[requestId] = answerCounter;\n    }\n    answers[answerCounter].minimumResponses = minimumResponses;\n    answers[answerCounter].maxResponses = uint128(oracles.length);\n\n    emit NewRound(answerCounter, msg.sender, block.timestamp);\n\n    answerCounter = answerCounter.add(1);\n  }\n\n  /**\n   * @notice Receives the answer from the Chainlink node.\n   * @dev This function can only be called by the oracle that received the request.\n   * @param _clRequestId The Chainlink request ID associated with the answer\n   * @param _response The answer provided by the Chainlink node\n   */\n  function chainlinkCallback(bytes32 _clRequestId, int256 _response)\n    external\n  {\n    validateChainlinkCallback(_clRequestId);\n\n    uint256 answerId = requestAnswers[_clRequestId];\n    delete requestAnswers[_clRequestId];\n\n    answers[answerId].responses.push(_response);\n    emit ResponseReceived(_response, answerId, msg.sender);\n    updateLatestAnswer(answerId);\n    deleteAnswer(answerId);\n  }\n\n  /**\n   * @notice Updates the arrays of oracles and jobIds with new values,\n   * overwriting the old values.\n   * @dev Arrays are validated to be equal length.\n   * @param _paymentAmount the amount of LINK to be sent to each oracle for each request\n   * @param _minimumResponses the minimum number of responses\n   * before an answer will be calculated\n   * @param _oracles An array of oracle addresses\n   * @param _jobIds An array of Job IDs\n   */\n  function updateRequestDetails(\n    uint128 _paymentAmount,\n    uint128 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  )\n    public\n    onlyOwner()\n    validateAnswerRequirements(_minimumResponses, _oracles, _jobIds)\n  {\n    paymentAmount = _paymentAmount;\n    minimumResponses = _minimumResponses;\n    jobIds = _jobIds;\n    oracles = _oracles;\n  }\n\n  /**\n   * @notice Allows the owner of the contract to withdraw any LINK balance\n   * available on the contract.\n   * @dev The contract will need to have a LINK balance in order to create requests.\n   * @param _recipient The address to receive the LINK tokens\n   * @param _amount The amount of LINK to send from the contract\n   */\n  function transferLINK(address _recipient, uint256 _amount)\n    public\n    onlyOwner()\n  {\n    LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());\n    require(linkToken.transfer(_recipient, _amount), \"LINK transfer failed\");\n  }\n\n  /**\n   * @notice Called by the owner to permission other addresses to generate new\n   * requests to oracles.\n   * @param _requester the address whose permissions are being set\n   * @param _allowed boolean that determines whether the requester is\n   * permissioned or not\n   */\n  function setAuthorization(address _requester, bool _allowed)\n    external\n    onlyOwner()\n  {\n    authorizedRequesters[_requester] = _allowed;\n  }\n\n  /**\n   * @notice Cancels an outstanding Chainlink request.\n   * The oracle contract requires the request ID and additional metadata to\n   * validate the cancellation. Only old answers can be cancelled.\n   * @param _requestId is the identifier for the chainlink request being cancelled\n   * @param _payment is the amount of LINK paid to the oracle for the request\n   * @param _expiration is the time when the request expires\n   */\n  function cancelRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    uint256 _expiration\n  )\n    external\n    ensureAuthorizedRequester()\n  {\n    uint256 answerId = requestAnswers[_requestId];\n    require(answerId < latestCompletedAnswer, \"Cannot modify an in-progress answer\");\n\n    delete requestAnswers[_requestId];\n    answers[answerId].responses.push(0);\n    deleteAnswer(answerId);\n\n    cancelChainlinkRequest(\n      _requestId,\n      _payment,\n      this.chainlinkCallback.selector,\n      _expiration\n    );\n  }\n\n  /**\n   * @notice Called by the owner to kill the contract. This transfers all LINK\n   * balance and ETH balance (if there is any) to the owner.\n   */\n  function destroy()\n    external\n    onlyOwner()\n  {\n    LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());\n    transferLINK(owner, linkToken.balanceOf(address(this)));\n    selfdestruct(owner);\n  }\n\n  /**\n   * @dev Performs aggregation of the answers received from the Chainlink nodes.\n   * Assumes that at least half the oracles are honest and so can't control the\n   * middle of the ordered responses.\n   * @param _answerId The answer ID associated with the group of requests\n   */\n  function updateLatestAnswer(uint256 _answerId)\n    private\n    ensureMinResponsesReceived(_answerId)\n    ensureOnlyLatestAnswer(_answerId)\n  {\n    uint256 responseLength = answers[_answerId].responses.length;\n    uint256 middleIndex = responseLength.div(2);\n    int256 currentAnswerTemp;\n    if (responseLength % 2 == 0) {\n      int256 median1 = quickselect(answers[_answerId].responses, middleIndex);\n      int256 median2 = quickselect(answers[_answerId].responses, middleIndex.add(1)); // quickselect is 1 indexed\n      currentAnswerTemp = median1.add(median2) / 2; // signed integers are not supported by SafeMath\n    } else {\n      currentAnswerTemp = quickselect(answers[_answerId].responses, middleIndex.add(1)); // quickselect is 1 indexed\n    }\n    currentAnswerValue = currentAnswerTemp;\n    latestCompletedAnswer = _answerId;\n    updatedTimestampValue = now;\n    updatedTimestamps[_answerId] = now;\n    currentAnswers[_answerId] = currentAnswerTemp;\n    emit AnswerUpdated(currentAnswerTemp, _answerId, now);\n  }\n\n  /**\n   * @notice get the most recently reported answer\n   */\n  function latestAnswer()\n    external\n    view\n    returns (int256)\n  {\n    return currentAnswers[latestCompletedAnswer];\n  }\n\n  /**\n   * @notice get the last updated at block timestamp\n   */\n  function latestTimestamp()\n    external\n    view\n    returns (uint256)\n  {\n    return updatedTimestamps[latestCompletedAnswer];\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param _roundId the answer number to retrieve the answer for\n   */\n  function getAnswer(uint256 _roundId)\n    external\n    view\n    returns (int256)\n  {\n    return currentAnswers[_roundId];\n  }\n\n  /**\n   * @notice get block timestamp when an answer was last updated\n   * @param _roundId the answer number to retrieve the updated timestamp for\n   */\n  function getTimestamp(uint256 _roundId)\n    external\n    view\n    returns (uint256)\n  {\n    return updatedTimestamps[_roundId];\n  }\n\n  /**\n   * @notice get the latest completed round where the answer was updated\n   */\n  function latestRound()\n    external\n    view\n    returns (uint256)\n  {\n    return latestCompletedAnswer;\n  }\n\n  /**\n   * @dev Returns the kth value of the ordered array\n   * See: http://www.cs.yale.edu/homes/aspnes/pinewiki/QuickSelect.html\n   * @param _a The list of elements to pull from\n   * @param _k The index, 1 based, of the elements you want to pull from when ordered\n   */\n  function quickselect(int256[] memory _a, uint256 _k)\n    private\n    pure\n    returns (int256)\n  {\n    int256[] memory a = _a;\n    uint256 k = _k;\n    uint256 aLen = a.length;\n    int256[] memory a1 = new int256[](aLen);\n    int256[] memory a2 = new int256[](aLen);\n    uint256 a1Len;\n    uint256 a2Len;\n    int256 pivot;\n    uint256 i;\n\n    while (true) {\n      pivot = a[aLen.div(2)];\n      a1Len = 0;\n      a2Len = 0;\n      for (i = 0; i < aLen; i++) {\n        if (a[i] < pivot) {\n          a1[a1Len] = a[i];\n          a1Len++;\n        } else if (a[i] > pivot) {\n          a2[a2Len] = a[i];\n          a2Len++;\n        }\n      }\n      if (k <= a1Len) {\n        aLen = a1Len;\n        (a, a1) = swap(a, a1);\n      } else if (k > (aLen.sub(a2Len))) {\n        k = k.sub(aLen.sub(a2Len));\n        aLen = a2Len;\n        (a, a2) = swap(a, a2);\n      } else {\n        return pivot;\n      }\n    }\n  }\n\n  /**\n   * @dev Swaps the pointers to two uint256 arrays in memory\n   * @param _a The pointer to the first in memory array\n   * @param _b The pointer to the second in memory array\n   */\n  function swap(int256[] memory _a, int256[] memory _b)\n    private\n    pure\n    returns(int256[] memory, int256[] memory)\n  {\n    return (_b, _a);\n  }\n\n  /**\n   * @dev Cleans up the answer record if all responses have been received.\n   * @param _answerId The identifier of the answer to be deleted\n   */\n  function deleteAnswer(uint256 _answerId)\n    private\n    ensureAllResponsesReceived(_answerId)\n  {\n    delete answers[_answerId];\n  }\n\n  /**\n   * @dev Prevents taking an action if the minimum number of responses has not\n   * been received for an answer.\n   * @param _answerId The the identifier of the answer that keeps track of the responses.\n   */\n  modifier ensureMinResponsesReceived(uint256 _answerId) {\n    if (answers[_answerId].responses.length >= answers[_answerId].minimumResponses) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Prevents taking an action if not all responses are received for an answer.\n   * @param _answerId The the identifier of the answer that keeps track of the responses.\n   */\n  modifier ensureAllResponsesReceived(uint256 _answerId) {\n    if (answers[_answerId].responses.length == answers[_answerId].maxResponses) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Prevents taking an action if a newer answer has been recorded.\n   * @param _answerId The current answer's identifier.\n   * Answer IDs are in ascending order.\n   */\n  modifier ensureOnlyLatestAnswer(uint256 _answerId) {\n    if (latestCompletedAnswer <= _answerId) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Ensures corresponding number of oracles and jobs.\n   * @param _oracles The list of oracles.\n   * @param _jobIds The list of jobs.\n   */\n  modifier validateAnswerRequirements(\n    uint256 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  ) {\n    require(_oracles.length <= MAX_ORACLE_COUNT, \"cannot have more than 45 oracles\");\n    require(_oracles.length >= _minimumResponses, \"must have at least as many oracles as responses\");\n    require(_oracles.length == _jobIds.length, \"must have exactly as many oracles as job IDs\");\n    _;\n  }\n\n  /**\n   * @dev Reverts if `msg.sender` is not authorized to make requests.\n   */\n  modifier ensureAuthorizedRequester() {\n    require(authorizedRequesters[msg.sender] || msg.sender == owner, \"Not an authorized address for creating requests\");\n    _;\n  }\n\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "Controller.sol",
            "Maintain.s.sol",
            "Aggregator.sol",
            "ERC4626.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n",
                    "//solidity\n    function setClaimTVL(uint256 id, uint256 claimTVL) public onlyController {\n        idClaimTVL[id] = claimTVL;\n    }\n",
                    "//solidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        uint256 entitledShares = beforeWithdraw(id, shares);\n        _burn(owner, id, shares);\n\n        //Taking fee from the amount\n        uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);\n        entitledShares = entitledShares feeValue;\n        asset.transfer(treasury, feeValue);\n\n        emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n        asset.transfer(receiver, entitledShares);\n\n        return entitledShares;\n    }\n",
                    "//solidity\n    function beforeWithdraw(uint256 id, uint256 amount)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        // in case the risk wins aka no depeg event\n        // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)\n        // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool\n        // in case there is a depeg event, the risk users can only withdraw the hedge\n        if (\n            keccak256(abi.encodePacked(symbol)) ==\n            keccak256(abi.encodePacked(\"rY2K\"))\n        ) {\n            if (!idDepegged[id]) {\n                //depeg event did not happen\n                /*\n                entitledAmount =\n                    (amount / idFinalTVL[id]) *\n                    idClaimTVL[id] +\n                    amount;\n                */\n                entitledAmount =\n                    amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                        idClaimTVL[id],\n                        1 ether\n                    ) +\n                    amount;\n            } else {\n                //depeg event did happen\n                entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                    idClaimTVL[id],\n                    1 ether\n                );\n            }\n        }\n        // in case the hedge wins aka depegging\n        // hedge users pay the hedge to risk users anyway,\n        // hedge guy can withdraw risk (that is transfered from the risk pool),\n        // withdraw = % tvl that hedge buyer owns\n        // otherwise hedge users cannot withdraw any Eth\n        else {\n            entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                idClaimTVL[id],\n                1 ether\n            );\n        }\n\n        return entitledAmount;\n    }\n",
                    "//solidity\n    function testWithdrawFromRiskAfterDepegWhenThereIsNoCounterparty() public {\n        vm.deal(chad, AMOUNT * CHAD_MULTIPLIER);\n\n        vm.startPrank(admin);\n        FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), \"y2kFRAX_99*\");\n        vm.stopPrank();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n        \n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        // chad deposits in risk vault, and no one deposits in hedge vault\n        vm.startPrank(chad);\n        ERC20(WETH).approve(risk, AMOUNT * CHAD_MULTIPLIER);\n        vRisk.depositETH{value: AMOUNT * CHAD_MULTIPLIER}(endEpoch, chad);\n\n        assertTrue(vRisk.balanceOf(chad,endEpoch) == (AMOUNT * CHAD_MULTIPLIER));\n        vm.stopPrank();\n\n        vm.warp(beginEpoch + 10 days);\n\n        // depeg occurs\n        controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);\n\n        vm.startPrank(chad);\n\n        // chad withdraws from risk vault\n        uint256 assets = vRisk.balanceOf(chad,endEpoch);\n        vRisk.withdraw(endEpoch, assets, chad, chad);\n\n        assertTrue(vRisk.balanceOf(chad,endEpoch) == NULL_BALANCE);\n        uint256 entitledShares = vRisk.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares vRisk.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(chad));\n\n        // chad receives nothing\n        assertEq(entitledShares, 0);\n        assertEq(ERC20(WETH).balanceOf(chad), 0);\n\n        vm.stopPrank();\n    }\n",
                    "//solidity\n    function testWithdrawFromHedgeAfterDepegWhenThereIsNoCounterparty() public {\n        vm.deal(alice, AMOUNT);\n\n        vm.startPrank(admin);\n        FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), \"y2kFRAX_99*\");\n        vm.stopPrank();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n        \n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        // alice deposits in hedge vault, and no one deposits in risk vault\n        vm.startPrank(alice);\n        ERC20(WETH).approve(hedge, AMOUNT);\n        vHedge.depositETH{value: AMOUNT}(endEpoch, alice);\n\n        assertTrue(vHedge.balanceOf(alice,endEpoch) == (AMOUNT));\n        vm.stopPrank();\n\n        vm.warp(beginEpoch + 10 days);\n\n        // depeg occurs\n        controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);\n\n        vm.startPrank(alice);\n\n        // alice withdraws from hedge vault\n        uint256 assets = vHedge.balanceOf(alice,endEpoch);\n        vHedge.withdraw(endEpoch, assets, alice, alice);\n\n        assertTrue(vHedge.balanceOf(alice,endEpoch) == NULL_BALANCE);\n        uint256 entitledShares = vHedge.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares vHedge.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(alice));\n        \n        // alice receives nothing\n        assertEq(entitledShares, 0);\n        assertEq(ERC20(WETH).balanceOf(alice), 0);\n\n        vm.stopPrank();\n    }\n"
                ],
                "Type": " Users who deposit in one vault can lose all deposits and receive nothing when counterparty vault has no deposits",
                "Description": "*Submitted by rbserver, also found by 0x52, carrotsmuggler, Ch_301, imare, Jeiwan, ladboy233, Lambda, Tointer, unforgiven, and wagmi*\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148-L192\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L350-L352\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426\n\n\nFor a market, if users only deposit in the hedge vault or only deposit in the risk vault but not in both, then these users will lose their deposits and receive nothing when they call the following withdraw function after the depeg event occurs.\n\nIf the vault that has deposits is called Vault A, and the counterparty vault that has no deposit is called Vault B, then:\n\n*   As shown by the triggerDepeg function below, when executing insrVault.sendTokens(epochEnd, address(riskVault)) and riskVault.sendTokens(epochEnd, address(insrVault)), the deposits of Vault A are transferred to Vault B but nothing is transferred to Vault A since Vault B has no deposit;\n*   When triggerDepeg executes insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd)) and riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd)), Vault B's idClaimTVL[id] is set to Vault A's idFinalTVL(epochEnd)) but Vault A's idClaimTVL[id] is set to 0 because Vault B's idFinalTVL(epochEnd) is 0.\n\nBecause of these, calling the beforeWithdraw function below will return a 0 entitledAmount, and calling withdraw then transfers that 0 amount to the user who has deposited. As a result, these users' deposits are transferred to the counterparty vault, and they receive nothing at all.\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148-L192\n\nsolidity\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L350-L352\n\nsolidity\n    function setClaimTVL(uint256 id, uint256 claimTVL) public onlyController {\n        idClaimTVL[id] = claimTVL;\n    }\n\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234\n\nsolidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        uint256 entitledShares = beforeWithdraw(id, shares);\n        _burn(owner, id, shares);\n\n        //Taking fee from the amount\n        uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);\n        entitledShares = entitledShares feeValue;\n        asset.transfer(treasury, feeValue);\n\n        emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n        asset.transfer(receiver, entitledShares);\n\n        return entitledShares;\n    }\n\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426\n\nsolidity\n    function beforeWithdraw(uint256 id, uint256 amount)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        // in case the risk wins aka no depeg event\n        // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)\n        // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool\n        // in case there is a depeg event, the risk users can only withdraw the hedge\n        if (\n            keccak256(abi.encodePacked(symbol)) ==\n            keccak256(abi.encodePacked(\"rY2K\"))\n        ) {\n            if (!idDepegged[id]) {\n                //depeg event did not happen\n                /*\n                entitledAmount =\n                    (amount / idFinalTVL[id]) *\n                    idClaimTVL[id] +\n                    amount;\n                */\n                entitledAmount =\n                    amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                        idClaimTVL[id],\n                        1 ether\n                    ) +\n                    amount;\n            } else {\n                //depeg event did happen\n                entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                    idClaimTVL[id],\n                    1 ether\n                );\n            }\n        }\n        // in case the hedge wins aka depegging\n        // hedge users pay the hedge to risk users anyway,\n        // hedge guy can withdraw risk (that is transfered from the risk pool),\n        // withdraw = % tvl that hedge buyer owns\n        // otherwise hedge users cannot withdraw any Eth\n        else {\n            entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                idClaimTVL[id],\n                1 ether\n            );\n        }\n\n        return entitledAmount;\n    }\n\n\n\nPlease append the following tests in testAssertTest.t.sol. These tests will pass to demonstrate the described scenarios.\n\nsolidity\n    function testWithdrawFromRiskAfterDepegWhenThereIsNoCounterparty() public {\n        vm.deal(chad, AMOUNT * CHAD_MULTIPLIER);\n\n        vm.startPrank(admin);\n        FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), \"y2kFRAX_99*\");\n        vm.stopPrank();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n        \n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        // chad deposits in risk vault, and no one deposits in hedge vault\n        vm.startPrank(chad);\n        ERC20(WETH).approve(risk, AMOUNT * CHAD_MULTIPLIER);\n        vRisk.depositETH{value: AMOUNT * CHAD_MULTIPLIER}(endEpoch, chad);\n\n        assertTrue(vRisk.balanceOf(chad,endEpoch) == (AMOUNT * CHAD_MULTIPLIER));\n        vm.stopPrank();\n\n        vm.warp(beginEpoch + 10 days);\n\n        // depeg occurs\n        controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);\n\n        vm.startPrank(chad);\n\n        // chad withdraws from risk vault\n        uint256 assets = vRisk.balanceOf(chad,endEpoch);\n        vRisk.withdraw(endEpoch, assets, chad, chad);\n\n        assertTrue(vRisk.balanceOf(chad,endEpoch) == NULL_BALANCE);\n        uint256 entitledShares = vRisk.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares vRisk.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(chad));\n\n        // chad receives nothing\n        assertEq(entitledShares, 0);\n        assertEq(ERC20(WETH).balanceOf(chad), 0);\n\n        vm.stopPrank();\n    }\n\n\nsolidity\n    function testWithdrawFromHedgeAfterDepegWhenThereIsNoCounterparty() public {\n        vm.deal(alice, AMOUNT);\n\n        vm.startPrank(admin);\n        FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), \"y2kFRAX_99*\");\n        vm.stopPrank();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n        \n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        // alice deposits in hedge vault, and no one deposits in risk vault\n        vm.startPrank(alice);\n        ERC20(WETH).approve(hedge, AMOUNT);\n        vHedge.depositETH{value: AMOUNT}(endEpoch, alice);\n\n        assertTrue(vHedge.balanceOf(alice,endEpoch) == (AMOUNT));\n        vm.stopPrank();\n\n        vm.warp(beginEpoch + 10 days);\n\n        // depeg occurs\n        controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);\n\n        vm.startPrank(alice);\n\n        // alice withdraws from hedge vault\n        uint256 assets = vHedge.balanceOf(alice,endEpoch);\n        vHedge.withdraw(endEpoch, assets, alice, alice);\n\n        assertTrue(vHedge.balanceOf(alice,endEpoch) == NULL_BALANCE);\n        uint256 entitledShares = vHedge.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares vHedge.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(alice));\n        \n        // alice receives nothing\n        assertEq(entitledShares, 0);\n        assertEq(ERC20(WETH).balanceOf(alice), 0);\n\n        vm.stopPrank();\n    }\n\n\n\nVSCode\n\n",
                "Repair": "\nWhen users only deposit in one vault, and no one deposits in the counterparty vault, the insurance practice of hedging and risking actually does not exist. In this situation, after the epoch is started, the users, who have deposited, should be allowed to withdraw their full deposit amounts.\n\n3xHarry (Y2K Finance) confirmed(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/409)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.4.24;\n\nimport \"./ChainlinkClient.sol\";\nimport \"./interfaces/AggregatorInterface.sol\";\nimport \"./vendor/SignedSafeMath.sol\";\nimport \"./vendor/Ownable.sol\";\nimport \"./vendor/SafeMathChainlink.sol\";\n\n/**\n * @title An example Chainlink contract with aggregation\n * @notice Requesters can use this contract as a framework for creating\n * requests to multiple Chainlink nodes and running aggregation\n * as the contract receives answers.\n */\ncontract Aggregator is AggregatorInterface, ChainlinkClient, Ownable {\n  using SafeMathChainlink for uint256;\n  using SignedSafeMath for int256;\n\n  struct Answer {\n    uint128 minimumResponses;\n    uint128 maxResponses;\n    int256[] responses;\n  }\n\n  event ResponseReceived(int256 indexed response, uint256 indexed answerId, address indexed sender);\n\n  int256 private currentAnswerValue;\n  uint256 private updatedTimestampValue;\n  uint256 private latestCompletedAnswer;\n  uint128 public paymentAmount;\n  uint128 public minimumResponses;\n  bytes32[] public jobIds;\n  address[] public oracles;\n\n  uint256 private answerCounter = 1;\n  mapping(address => bool) public authorizedRequesters;\n  mapping(bytes32 => uint256) private requestAnswers;\n  mapping(uint256 => Answer) private answers;\n  mapping(uint256 => int256) private currentAnswers;\n  mapping(uint256 => uint256) private updatedTimestamps;\n\n  uint256 constant private MAX_ORACLE_COUNT = 28;\n\n  /**\n   * @notice Deploy with the address of the LINK token and arrays of matching\n   * length containing the addresses of the oracles and their corresponding\n   * Job IDs.\n   * @dev Sets the LinkToken address for the network, addresses of the oracles,\n   * and jobIds in storage.\n   * @param _link The address of the LINK token\n   * @param _paymentAmount the amount of LINK to be sent to each oracle for each request\n   * @param _minimumResponses the minimum number of responses\n   * before an answer will be calculated\n   * @param _oracles An array of oracle addresses\n   * @param _jobIds An array of Job IDs\n   */\n  constructor(\n    address _link,\n    uint128 _paymentAmount,\n    uint128 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  ) public Ownable() {\n    setChainlinkToken(_link);\n    updateRequestDetails(_paymentAmount, _minimumResponses, _oracles, _jobIds);\n  }\n\n  /**\n   * @notice Creates a Chainlink request for each oracle in the oracles array.\n   * @dev This example does not include request parameters. Reference any documentation\n   * associated with the Job IDs used to determine the required parameters per-request.\n   */\n  function requestRateUpdate()\n    external\n    ensureAuthorizedRequester()\n  {\n    Chainlink.Request memory request;\n    bytes32 requestId;\n    uint256 oraclePayment = paymentAmount;\n\n    for (uint i = 0; i < oracles.length; i++) {\n      request = buildChainlinkRequest(jobIds[i], this, this.chainlinkCallback.selector);\n      requestId = sendChainlinkRequestTo(oracles[i], request, oraclePayment);\n      requestAnswers[requestId] = answerCounter;\n    }\n    answers[answerCounter].minimumResponses = minimumResponses;\n    answers[answerCounter].maxResponses = uint128(oracles.length);\n\n    emit NewRound(answerCounter, msg.sender, block.timestamp);\n\n    answerCounter = answerCounter.add(1);\n  }\n\n  /**\n   * @notice Receives the answer from the Chainlink node.\n   * @dev This function can only be called by the oracle that received the request.\n   * @param _clRequestId The Chainlink request ID associated with the answer\n   * @param _response The answer provided by the Chainlink node\n   */\n  function chainlinkCallback(bytes32 _clRequestId, int256 _response)\n    external\n  {\n    validateChainlinkCallback(_clRequestId);\n\n    uint256 answerId = requestAnswers[_clRequestId];\n    delete requestAnswers[_clRequestId];\n\n    answers[answerId].responses.push(_response);\n    emit ResponseReceived(_response, answerId, msg.sender);\n    updateLatestAnswer(answerId);\n    deleteAnswer(answerId);\n  }\n\n  /**\n   * @notice Updates the arrays of oracles and jobIds with new values,\n   * overwriting the old values.\n   * @dev Arrays are validated to be equal length.\n   * @param _paymentAmount the amount of LINK to be sent to each oracle for each request\n   * @param _minimumResponses the minimum number of responses\n   * before an answer will be calculated\n   * @param _oracles An array of oracle addresses\n   * @param _jobIds An array of Job IDs\n   */\n  function updateRequestDetails(\n    uint128 _paymentAmount,\n    uint128 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  )\n    public\n    onlyOwner()\n    validateAnswerRequirements(_minimumResponses, _oracles, _jobIds)\n  {\n    paymentAmount = _paymentAmount;\n    minimumResponses = _minimumResponses;\n    jobIds = _jobIds;\n    oracles = _oracles;\n  }\n\n  /**\n   * @notice Allows the owner of the contract to withdraw any LINK balance\n   * available on the contract.\n   * @dev The contract will need to have a LINK balance in order to create requests.\n   * @param _recipient The address to receive the LINK tokens\n   * @param _amount The amount of LINK to send from the contract\n   */\n  function transferLINK(address _recipient, uint256 _amount)\n    public\n    onlyOwner()\n  {\n    LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());\n    require(linkToken.transfer(_recipient, _amount), \"LINK transfer failed\");\n  }\n\n  /**\n   * @notice Called by the owner to permission other addresses to generate new\n   * requests to oracles.\n   * @param _requester the address whose permissions are being set\n   * @param _allowed boolean that determines whether the requester is\n   * permissioned or not\n   */\n  function setAuthorization(address _requester, bool _allowed)\n    external\n    onlyOwner()\n  {\n    authorizedRequesters[_requester] = _allowed;\n  }\n\n  /**\n   * @notice Cancels an outstanding Chainlink request.\n   * The oracle contract requires the request ID and additional metadata to\n   * validate the cancellation. Only old answers can be cancelled.\n   * @param _requestId is the identifier for the chainlink request being cancelled\n   * @param _payment is the amount of LINK paid to the oracle for the request\n   * @param _expiration is the time when the request expires\n   */\n  function cancelRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    uint256 _expiration\n  )\n    external\n    ensureAuthorizedRequester()\n  {\n    uint256 answerId = requestAnswers[_requestId];\n    require(answerId < latestCompletedAnswer, \"Cannot modify an in-progress answer\");\n\n    delete requestAnswers[_requestId];\n    answers[answerId].responses.push(0);\n    deleteAnswer(answerId);\n\n    cancelChainlinkRequest(\n      _requestId,\n      _payment,\n      this.chainlinkCallback.selector,\n      _expiration\n    );\n  }\n\n  /**\n   * @notice Called by the owner to kill the contract. This transfers all LINK\n   * balance and ETH balance (if there is any) to the owner.\n   */\n  function destroy()\n    external\n    onlyOwner()\n  {\n    LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());\n    transferLINK(owner, linkToken.balanceOf(address(this)));\n    selfdestruct(owner);\n  }\n\n  /**\n   * @dev Performs aggregation of the answers received from the Chainlink nodes.\n   * Assumes that at least half the oracles are honest and so can't control the\n   * middle of the ordered responses.\n   * @param _answerId The answer ID associated with the group of requests\n   */\n  function updateLatestAnswer(uint256 _answerId)\n    private\n    ensureMinResponsesReceived(_answerId)\n    ensureOnlyLatestAnswer(_answerId)\n  {\n    uint256 responseLength = answers[_answerId].responses.length;\n    uint256 middleIndex = responseLength.div(2);\n    int256 currentAnswerTemp;\n    if (responseLength % 2 == 0) {\n      int256 median1 = quickselect(answers[_answerId].responses, middleIndex);\n      int256 median2 = quickselect(answers[_answerId].responses, middleIndex.add(1)); // quickselect is 1 indexed\n      currentAnswerTemp = median1.add(median2) / 2; // signed integers are not supported by SafeMath\n    } else {\n      currentAnswerTemp = quickselect(answers[_answerId].responses, middleIndex.add(1)); // quickselect is 1 indexed\n    }\n    currentAnswerValue = currentAnswerTemp;\n    latestCompletedAnswer = _answerId;\n    updatedTimestampValue = now;\n    updatedTimestamps[_answerId] = now;\n    currentAnswers[_answerId] = currentAnswerTemp;\n    emit AnswerUpdated(currentAnswerTemp, _answerId, now);\n  }\n\n  /**\n   * @notice get the most recently reported answer\n   */\n  function latestAnswer()\n    external\n    view\n    returns (int256)\n  {\n    return currentAnswers[latestCompletedAnswer];\n  }\n\n  /**\n   * @notice get the last updated at block timestamp\n   */\n  function latestTimestamp()\n    external\n    view\n    returns (uint256)\n  {\n    return updatedTimestamps[latestCompletedAnswer];\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param _roundId the answer number to retrieve the answer for\n   */\n  function getAnswer(uint256 _roundId)\n    external\n    view\n    returns (int256)\n  {\n    return currentAnswers[_roundId];\n  }\n\n  /**\n   * @notice get block timestamp when an answer was last updated\n   * @param _roundId the answer number to retrieve the updated timestamp for\n   */\n  function getTimestamp(uint256 _roundId)\n    external\n    view\n    returns (uint256)\n  {\n    return updatedTimestamps[_roundId];\n  }\n\n  /**\n   * @notice get the latest completed round where the answer was updated\n   */\n  function latestRound()\n    external\n    view\n    returns (uint256)\n  {\n    return latestCompletedAnswer;\n  }\n\n  /**\n   * @dev Returns the kth value of the ordered array\n   * See: http://www.cs.yale.edu/homes/aspnes/pinewiki/QuickSelect.html\n   * @param _a The list of elements to pull from\n   * @param _k The index, 1 based, of the elements you want to pull from when ordered\n   */\n  function quickselect(int256[] memory _a, uint256 _k)\n    private\n    pure\n    returns (int256)\n  {\n    int256[] memory a = _a;\n    uint256 k = _k;\n    uint256 aLen = a.length;\n    int256[] memory a1 = new int256[](aLen);\n    int256[] memory a2 = new int256[](aLen);\n    uint256 a1Len;\n    uint256 a2Len;\n    int256 pivot;\n    uint256 i;\n\n    while (true) {\n      pivot = a[aLen.div(2)];\n      a1Len = 0;\n      a2Len = 0;\n      for (i = 0; i < aLen; i++) {\n        if (a[i] < pivot) {\n          a1[a1Len] = a[i];\n          a1Len++;\n        } else if (a[i] > pivot) {\n          a2[a2Len] = a[i];\n          a2Len++;\n        }\n      }\n      if (k <= a1Len) {\n        aLen = a1Len;\n        (a, a1) = swap(a, a1);\n      } else if (k > (aLen.sub(a2Len))) {\n        k = k.sub(aLen.sub(a2Len));\n        aLen = a2Len;\n        (a, a2) = swap(a, a2);\n      } else {\n        return pivot;\n      }\n    }\n  }\n\n  /**\n   * @dev Swaps the pointers to two uint256 arrays in memory\n   * @param _a The pointer to the first in memory array\n   * @param _b The pointer to the second in memory array\n   */\n  function swap(int256[] memory _a, int256[] memory _b)\n    private\n    pure\n    returns(int256[] memory, int256[] memory)\n  {\n    return (_b, _a);\n  }\n\n  /**\n   * @dev Cleans up the answer record if all responses have been received.\n   * @param _answerId The identifier of the answer to be deleted\n   */\n  function deleteAnswer(uint256 _answerId)\n    private\n    ensureAllResponsesReceived(_answerId)\n  {\n    delete answers[_answerId];\n  }\n\n  /**\n   * @dev Prevents taking an action if the minimum number of responses has not\n   * been received for an answer.\n   * @param _answerId The the identifier of the answer that keeps track of the responses.\n   */\n  modifier ensureMinResponsesReceived(uint256 _answerId) {\n    if (answers[_answerId].responses.length >= answers[_answerId].minimumResponses) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Prevents taking an action if not all responses are received for an answer.\n   * @param _answerId The the identifier of the answer that keeps track of the responses.\n   */\n  modifier ensureAllResponsesReceived(uint256 _answerId) {\n    if (answers[_answerId].responses.length == answers[_answerId].maxResponses) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Prevents taking an action if a newer answer has been recorded.\n   * @param _answerId The current answer's identifier.\n   * Answer IDs are in ascending order.\n   */\n  modifier ensureOnlyLatestAnswer(uint256 _answerId) {\n    if (latestCompletedAnswer <= _answerId) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Ensures corresponding number of oracles and jobs.\n   * @param _oracles The list of oracles.\n   * @param _jobIds The list of jobs.\n   */\n  modifier validateAnswerRequirements(\n    uint256 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  ) {\n    require(_oracles.length <= MAX_ORACLE_COUNT, \"cannot have more than 45 oracles\");\n    require(_oracles.length >= _minimumResponses, \"must have at least as many oracles as responses\");\n    require(_oracles.length == _jobIds.length, \"must have exactly as many oracles as job IDs\");\n    _;\n  }\n\n  /**\n   * @dev Reverts if `msg.sender` is not authorized to make requests.\n   */\n  modifier ensureAuthorizedRequester() {\n    require(authorizedRequesters[msg.sender] || msg.sender == owner, \"Not an authorized address for creating requests\");\n    _;\n  }\n\n}\n\n\n",
        "CodeNames": [
            "Aggregator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "uint"
                ],
                "Type": " LOSS OF PRECISION RESULTING IN WRONG VALUE FOR PRICE RATIO",
                "Description": "*Submitted by 0xDecorativePineapple, also found by 0xPanas and Lambda*\n\nThe project implements a price oracle in order to get the relative price between the pegged asset and the price of the original asset (example: stETH to ETH). If the ratio (the pegged asset divided by the original asset) is 1 the Token is pegged, otherwise is depegged.\n\nBelow is a code snippet from the PegOracle.sol(https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/oracles/PegOracle.sol) function.\n\n     if (price1  price2) {\n                nowPrice = (price2 * 10000) / price1;\n            } else {\n                nowPrice = (price1 * 10000) / price2;\n            }\n\n            int256 decimals10 = int256(10(18 priceFeed1.decimals()));\n            nowPrice = nowPrice * decimals10;\n\n            return (\n                roundID1,\n                nowPrice / 1000000,\n                startedAt1,\n                timeStamp1,\n                answeredInRound1\n            );\n        }\n\nTo fetch the ratio at any time, the PegOracle.sol performs some calculations; first the relative price is multiplied by 1e4 and then it returns the above calculation divided by 1e6.\n\nThe Controller.sol(https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol) file makes an external call to the PegOracle.sol(https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/oracles/PegOracle.sol) oracle to get the relative price. After, the value returned, it is multiplied by 10(18-(priceFeed.decimals()) and the result represents the relative price between the two assets.\n\nThe result is converted to 18 decimal points in order to be compared with the Strike Price passed by the admin on VaultFactory.sol.\n\nDue to the fact that the first multiplication is first divided by 1e6 ([PegOracle.sol#L78)(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L78)( and then re-multiplied by uint256 decimals = 10(18-(priceFeed.decimals())); ([Controller.sol#L299-L300(https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300))  it leads to loss of precision. This behavior will make the relative price between the assets incorrect.\n\n\nBelow is a test that illustrates the above issue for various oracle pairs. The calculated ratio is compared against a modified version of an example of different price denominator, provided by Chainlink(https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination).\n\n    // SPDX-License-Identifier: MIT\n    pragma solidity 0.8.15;\n\n    import \"forge-std/Test.sol\";\n    import \"../lib/AggregatorV3Interface.sol\";\n\n    //run with: forge test --fork-url https://arb1.arbitrum.io/rpc -vv \n\n    contract PegOracle {\n\n        /*\n        @dev  for example: oracle1 would be stETH / USD, while oracle2 would be ETH / USD oracle\n        */\n        address public oracle1;\n        address public oracle2;\n\n        uint8 public decimals;\n\n        AggregatorV3Interface internal priceFeed1;\n        AggregatorV3Interface internal priceFeed2;\n\n        / @notice Contract constructor\n          * @param _oracle1 First oracle address\n          * @param _oracle2 Second oracle address\n          */\n        constructor(address _oracle1, address _oracle2) {\n            require(_oracle1 != address(0), \"oracle1 cannot be the zero address\");\n            require(_oracle2 != address(0), \"oracle2 cannot be the zero address\");\n            require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n            priceFeed1 = AggregatorV3Interface(_oracle1);\n            priceFeed2 = AggregatorV3Interface(_oracle2);\n            require(\n                (priceFeed1.decimals() == priceFeed2.decimals()),\n                \"Decimals must be the same\"\n            );\n\n            oracle1 = _oracle1;\n            oracle2 = _oracle2;\n\n            decimals = priceFeed1.decimals();\n        }\n\n        / @notice Returns oracle-fed data from the latest round\n          * @return roundID Current round id \n          * @return nowPrice Current price\n          * @return startedAt Starting timestamp\n          * @return timeStamp Current timestamp\n          * @return answeredInRound Round id for which answer was computed \n          */ \n        function latestRoundData()\n            public\n            view\n            returns (\n                uint80 roundID,\n                int256 nowPrice,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            )\n        {\n            (\n                uint80 roundID1,\n                int256 price1,\n                uint256 startedAt1,\n                uint256 timeStamp1,\n                uint80 answeredInRound1\n            ) = priceFeed1.latestRoundData();\n\n            int256 price2 = getOracle2_Price();\n\n            if (price1  price2) {\n                nowPrice = (price2 * 10000) / price1;\n            } else {\n                nowPrice = (price1 * 10000) / price2;\n            }\n\n            int256 decimals10 = int256(10(18 priceFeed1.decimals()));\n            nowPrice = nowPrice * decimals10;\n\n            return (\n                roundID1,\n                nowPrice / 1000000, //1000000,\n                startedAt1,\n                timeStamp1,\n                answeredInRound1\n            );\n        }\n\n        /* solhint-disbable-next-line func-name-mixedcase */\n        / @notice Lookup first oracle price\n          * @return price Current first oracle price\n          */ \n        function getOracle1_Price() public view returns (int256 price) {\n            (\n                uint80 roundID1,\n                int256 price1,\n                ,\n                uint256 timeStamp1,\n                uint80 answeredInRound1\n            ) = priceFeed1.latestRoundData();\n\n            require(price1  0, \"Chainlink price <= 0\");\n            require(\n                answeredInRound1 = roundID1,\n                \"RoundID from Oracle is outdated!\"\n            );\n            require(timeStamp1 != 0, \"Timestamp == 0 !\");\n\n            return price1;\n        }\n\n        /* solhint-disbable-next-line func-name-mixedcase */\n        / @notice Lookup second oracle price\n          * @return price Current second oracle price\n          */ \n        function getOracle2_Price() public view returns (int256 price) {\n            (\n                uint80 roundID2,\n                int256 price2,\n                ,\n                uint256 timeStamp2,\n                uint80 answeredInRound2\n            ) = priceFeed2.latestRoundData();\n\n            require(price2  0, \"Chainlink price <= 0\");\n            require(\n                answeredInRound2 = roundID2,\n                \"RoundID from Oracle is outdated!\"\n            );\n            require(timeStamp2 != 0, \"Timestamp == 0 !\");\n\n            return price2;\n        }\n        \n        function latestRoundData2()\n            public\n            view\n            returns (\n                uint80 roundID,\n                int256 nowPrice,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            )\n        {\n            (\n                uint80 roundID1,\n                int256 price1,\n                uint256 startedAt1,\n                uint256 timeStamp1,\n                uint80 answeredInRound1\n            ) = priceFeed1.latestRoundData();\n\n            price1 = scalePriceTo18(price1, priceFeed1.decimals());\n\n            int256 price2 = scalePriceTo18(getOracle2_Price(), priceFeed1.decimals());\n\n\n            return (\n                roundID1,\n                price1  * 1e18 / price2, \n                startedAt1,\n                timeStamp1,\n                answeredInRound1\n            );\n        }\n\n\n    function scalePriceTo18(int256 _price, uint8 _priceDecimals)\n            internal\n            pure\n            returns (int256)\n        {\n            if (_priceDecimals < 18) {\n                return _price * int256(10  uint256(18 _priceDecimals));\n            } else if (_priceDecimals  18) {\n                return _price * int256(10  uint256(_priceDecimals 18));\n            }\n            return _price;\n        }\n    } \n\n\n\n\n    contract TestOracles is Test {\n        address WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n\n        address tokenFRAX = 0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F;\n        address tokenMIM = 0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A;\n        address tokenFEI = 0x4A717522566C7A09FD2774cceDC5A8c43C5F9FD2;\n        address tokenUSDC = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;\n        address tokenDAI = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\n        address tokenSTETH = 0xEfa0dB536d2c8089685630fafe88CF7805966FC3;\n\n        address oracleFRAX = 0x0809E3d38d1B4214958faf06D8b1B1a2b73f2ab8;\n        address oracleMIM = 0x87121F6c9A9F6E90E59591E4Cf4804873f54A95b;\n        address oracleFEI = 0x7c4720086E6feb755dab542c46DE4f728E88304d;\n        address oracleUSDC = 0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3;\n        address oracleDAI = 0xc5C8E77B397E531B8EC06BFb0048328B30E9eCfB;\n        address oracleSTETH = 0x07C5b924399cc23c24a95c8743DE4006a32b7f2a;\n        address oracleETH = 0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612;\n        address btcEthOracle = 0xc5a90A6d7e4Af242dA238FFe279e9f2BA0c64B2e;\n\n        PegOracle pegOracle = new PegOracle(oracleSTETH, oracleETH);\n        PegOracle pegOracle2 = new PegOracle(oracleFRAX, oracleFEI);\n        PegOracle pegOracle3 = new PegOracle(oracleDAI, oracleFEI);\n\n        function setUp() public {}\n\n        function convertBasedOnContractsLogic(int256 price, uint8 oracleDecimals) public returns(int256 newPrice){\n            uint256 decimals = 10(18oracleDecimals );\n            int256 newPrice = price * int256(decimals);\n            return newPrice;\n        }\n\n        function testOraclePrices() public {\n            (, int256 var1 ,,,) = pegOracle.latestRoundData();\n            emit log_int(convertBasedOnContractsLogic(var1, pegOracle.decimals()));\n\n            (, int256 var2 ,,,) = pegOracle.latestRoundData2();\n            emit log_int(var2);\n\n            (, int256 var3 ,,,) = pegOracle2.latestRoundData();\n            emit log_int(convertBasedOnContractsLogic(var3, pegOracle2.decimals()));\n\n            (, int256 var4 ,,,) = pegOracle2.latestRoundData2();\n            emit log_int(var4);\n\n\n            (, int256 var5 ,,,) = pegOracle3.latestRoundData();\n            emit log_int(convertBasedOnContractsLogic(var5, pegOracle3.decimals()));\n\n            (, int256 var6 ,,,) = pegOracle3.latestRoundData2();\n            emit log_int(var6);\n        }\n\n    }\n\nHere is the output after running the with:  forge test --fork-url https://arb1.arbitrum.io/rpc -vv  :\n990500000000000000\n990544616614592905\n\n996300000000000000\n1003669952945847834\n\n996000000000000000\n1003940775578783463\n\n",
                "Repair": "\nSince the 2 assets are required to having the same amount of decimals a formula that transforms the relative price to 1e18 could be:\nx * 1e18 / y .\n\nAn example that Chainlink implements, that includes a scalePrice function, in order to find a different price denominator could be found here(https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination).\n\nMiguelBits (Y2K Finance) acknowledged(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/323) \n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/323#issuecomment-1280944745):\n  Agree with the issue; the precision loss may be the decisive factor between whether a depeg is ruled to have happened. Since the core functionality and user funds are at stake, the high severity is appropriate here.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.4.24;\n\nimport \"./ChainlinkClient.sol\";\nimport \"./interfaces/AggregatorInterface.sol\";\nimport \"./vendor/SignedSafeMath.sol\";\nimport \"./vendor/Ownable.sol\";\nimport \"./vendor/SafeMathChainlink.sol\";\n\n/**\n * @title An example Chainlink contract with aggregation\n * @notice Requesters can use this contract as a framework for creating\n * requests to multiple Chainlink nodes and running aggregation\n * as the contract receives answers.\n */\ncontract Aggregator is AggregatorInterface, ChainlinkClient, Ownable {\n  using SafeMathChainlink for uint256;\n  using SignedSafeMath for int256;\n\n  struct Answer {\n    uint128 minimumResponses;\n    uint128 maxResponses;\n    int256[] responses;\n  }\n\n  event ResponseReceived(int256 indexed response, uint256 indexed answerId, address indexed sender);\n\n  int256 private currentAnswerValue;\n  uint256 private updatedTimestampValue;\n  uint256 private latestCompletedAnswer;\n  uint128 public paymentAmount;\n  uint128 public minimumResponses;\n  bytes32[] public jobIds;\n  address[] public oracles;\n\n  uint256 private answerCounter = 1;\n  mapping(address => bool) public authorizedRequesters;\n  mapping(bytes32 => uint256) private requestAnswers;\n  mapping(uint256 => Answer) private answers;\n  mapping(uint256 => int256) private currentAnswers;\n  mapping(uint256 => uint256) private updatedTimestamps;\n\n  uint256 constant private MAX_ORACLE_COUNT = 28;\n\n  /**\n   * @notice Deploy with the address of the LINK token and arrays of matching\n   * length containing the addresses of the oracles and their corresponding\n   * Job IDs.\n   * @dev Sets the LinkToken address for the network, addresses of the oracles,\n   * and jobIds in storage.\n   * @param _link The address of the LINK token\n   * @param _paymentAmount the amount of LINK to be sent to each oracle for each request\n   * @param _minimumResponses the minimum number of responses\n   * before an answer will be calculated\n   * @param _oracles An array of oracle addresses\n   * @param _jobIds An array of Job IDs\n   */\n  constructor(\n    address _link,\n    uint128 _paymentAmount,\n    uint128 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  ) public Ownable() {\n    setChainlinkToken(_link);\n    updateRequestDetails(_paymentAmount, _minimumResponses, _oracles, _jobIds);\n  }\n\n  /**\n   * @notice Creates a Chainlink request for each oracle in the oracles array.\n   * @dev This example does not include request parameters. Reference any documentation\n   * associated with the Job IDs used to determine the required parameters per-request.\n   */\n  function requestRateUpdate()\n    external\n    ensureAuthorizedRequester()\n  {\n    Chainlink.Request memory request;\n    bytes32 requestId;\n    uint256 oraclePayment = paymentAmount;\n\n    for (uint i = 0; i < oracles.length; i++) {\n      request = buildChainlinkRequest(jobIds[i], this, this.chainlinkCallback.selector);\n      requestId = sendChainlinkRequestTo(oracles[i], request, oraclePayment);\n      requestAnswers[requestId] = answerCounter;\n    }\n    answers[answerCounter].minimumResponses = minimumResponses;\n    answers[answerCounter].maxResponses = uint128(oracles.length);\n\n    emit NewRound(answerCounter, msg.sender, block.timestamp);\n\n    answerCounter = answerCounter.add(1);\n  }\n\n  /**\n   * @notice Receives the answer from the Chainlink node.\n   * @dev This function can only be called by the oracle that received the request.\n   * @param _clRequestId The Chainlink request ID associated with the answer\n   * @param _response The answer provided by the Chainlink node\n   */\n  function chainlinkCallback(bytes32 _clRequestId, int256 _response)\n    external\n  {\n    validateChainlinkCallback(_clRequestId);\n\n    uint256 answerId = requestAnswers[_clRequestId];\n    delete requestAnswers[_clRequestId];\n\n    answers[answerId].responses.push(_response);\n    emit ResponseReceived(_response, answerId, msg.sender);\n    updateLatestAnswer(answerId);\n    deleteAnswer(answerId);\n  }\n\n  /**\n   * @notice Updates the arrays of oracles and jobIds with new values,\n   * overwriting the old values.\n   * @dev Arrays are validated to be equal length.\n   * @param _paymentAmount the amount of LINK to be sent to each oracle for each request\n   * @param _minimumResponses the minimum number of responses\n   * before an answer will be calculated\n   * @param _oracles An array of oracle addresses\n   * @param _jobIds An array of Job IDs\n   */\n  function updateRequestDetails(\n    uint128 _paymentAmount,\n    uint128 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  )\n    public\n    onlyOwner()\n    validateAnswerRequirements(_minimumResponses, _oracles, _jobIds)\n  {\n    paymentAmount = _paymentAmount;\n    minimumResponses = _minimumResponses;\n    jobIds = _jobIds;\n    oracles = _oracles;\n  }\n\n  /**\n   * @notice Allows the owner of the contract to withdraw any LINK balance\n   * available on the contract.\n   * @dev The contract will need to have a LINK balance in order to create requests.\n   * @param _recipient The address to receive the LINK tokens\n   * @param _amount The amount of LINK to send from the contract\n   */\n  function transferLINK(address _recipient, uint256 _amount)\n    public\n    onlyOwner()\n  {\n    LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());\n    require(linkToken.transfer(_recipient, _amount), \"LINK transfer failed\");\n  }\n\n  /**\n   * @notice Called by the owner to permission other addresses to generate new\n   * requests to oracles.\n   * @param _requester the address whose permissions are being set\n   * @param _allowed boolean that determines whether the requester is\n   * permissioned or not\n   */\n  function setAuthorization(address _requester, bool _allowed)\n    external\n    onlyOwner()\n  {\n    authorizedRequesters[_requester] = _allowed;\n  }\n\n  /**\n   * @notice Cancels an outstanding Chainlink request.\n   * The oracle contract requires the request ID and additional metadata to\n   * validate the cancellation. Only old answers can be cancelled.\n   * @param _requestId is the identifier for the chainlink request being cancelled\n   * @param _payment is the amount of LINK paid to the oracle for the request\n   * @param _expiration is the time when the request expires\n   */\n  function cancelRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    uint256 _expiration\n  )\n    external\n    ensureAuthorizedRequester()\n  {\n    uint256 answerId = requestAnswers[_requestId];\n    require(answerId < latestCompletedAnswer, \"Cannot modify an in-progress answer\");\n\n    delete requestAnswers[_requestId];\n    answers[answerId].responses.push(0);\n    deleteAnswer(answerId);\n\n    cancelChainlinkRequest(\n      _requestId,\n      _payment,\n      this.chainlinkCallback.selector,\n      _expiration\n    );\n  }\n\n  /**\n   * @notice Called by the owner to kill the contract. This transfers all LINK\n   * balance and ETH balance (if there is any) to the owner.\n   */\n  function destroy()\n    external\n    onlyOwner()\n  {\n    LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());\n    transferLINK(owner, linkToken.balanceOf(address(this)));\n    selfdestruct(owner);\n  }\n\n  /**\n   * @dev Performs aggregation of the answers received from the Chainlink nodes.\n   * Assumes that at least half the oracles are honest and so can't control the\n   * middle of the ordered responses.\n   * @param _answerId The answer ID associated with the group of requests\n   */\n  function updateLatestAnswer(uint256 _answerId)\n    private\n    ensureMinResponsesReceived(_answerId)\n    ensureOnlyLatestAnswer(_answerId)\n  {\n    uint256 responseLength = answers[_answerId].responses.length;\n    uint256 middleIndex = responseLength.div(2);\n    int256 currentAnswerTemp;\n    if (responseLength % 2 == 0) {\n      int256 median1 = quickselect(answers[_answerId].responses, middleIndex);\n      int256 median2 = quickselect(answers[_answerId].responses, middleIndex.add(1)); // quickselect is 1 indexed\n      currentAnswerTemp = median1.add(median2) / 2; // signed integers are not supported by SafeMath\n    } else {\n      currentAnswerTemp = quickselect(answers[_answerId].responses, middleIndex.add(1)); // quickselect is 1 indexed\n    }\n    currentAnswerValue = currentAnswerTemp;\n    latestCompletedAnswer = _answerId;\n    updatedTimestampValue = now;\n    updatedTimestamps[_answerId] = now;\n    currentAnswers[_answerId] = currentAnswerTemp;\n    emit AnswerUpdated(currentAnswerTemp, _answerId, now);\n  }\n\n  /**\n   * @notice get the most recently reported answer\n   */\n  function latestAnswer()\n    external\n    view\n    returns (int256)\n  {\n    return currentAnswers[latestCompletedAnswer];\n  }\n\n  /**\n   * @notice get the last updated at block timestamp\n   */\n  function latestTimestamp()\n    external\n    view\n    returns (uint256)\n  {\n    return updatedTimestamps[latestCompletedAnswer];\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param _roundId the answer number to retrieve the answer for\n   */\n  function getAnswer(uint256 _roundId)\n    external\n    view\n    returns (int256)\n  {\n    return currentAnswers[_roundId];\n  }\n\n  /**\n   * @notice get block timestamp when an answer was last updated\n   * @param _roundId the answer number to retrieve the updated timestamp for\n   */\n  function getTimestamp(uint256 _roundId)\n    external\n    view\n    returns (uint256)\n  {\n    return updatedTimestamps[_roundId];\n  }\n\n  /**\n   * @notice get the latest completed round where the answer was updated\n   */\n  function latestRound()\n    external\n    view\n    returns (uint256)\n  {\n    return latestCompletedAnswer;\n  }\n\n  /**\n   * @dev Returns the kth value of the ordered array\n   * See: http://www.cs.yale.edu/homes/aspnes/pinewiki/QuickSelect.html\n   * @param _a The list of elements to pull from\n   * @param _k The index, 1 based, of the elements you want to pull from when ordered\n   */\n  function quickselect(int256[] memory _a, uint256 _k)\n    private\n    pure\n    returns (int256)\n  {\n    int256[] memory a = _a;\n    uint256 k = _k;\n    uint256 aLen = a.length;\n    int256[] memory a1 = new int256[](aLen);\n    int256[] memory a2 = new int256[](aLen);\n    uint256 a1Len;\n    uint256 a2Len;\n    int256 pivot;\n    uint256 i;\n\n    while (true) {\n      pivot = a[aLen.div(2)];\n      a1Len = 0;\n      a2Len = 0;\n      for (i = 0; i < aLen; i++) {\n        if (a[i] < pivot) {\n          a1[a1Len] = a[i];\n          a1Len++;\n        } else if (a[i] > pivot) {\n          a2[a2Len] = a[i];\n          a2Len++;\n        }\n      }\n      if (k <= a1Len) {\n        aLen = a1Len;\n        (a, a1) = swap(a, a1);\n      } else if (k > (aLen.sub(a2Len))) {\n        k = k.sub(aLen.sub(a2Len));\n        aLen = a2Len;\n        (a, a2) = swap(a, a2);\n      } else {\n        return pivot;\n      }\n    }\n  }\n\n  /**\n   * @dev Swaps the pointers to two uint256 arrays in memory\n   * @param _a The pointer to the first in memory array\n   * @param _b The pointer to the second in memory array\n   */\n  function swap(int256[] memory _a, int256[] memory _b)\n    private\n    pure\n    returns(int256[] memory, int256[] memory)\n  {\n    return (_b, _a);\n  }\n\n  /**\n   * @dev Cleans up the answer record if all responses have been received.\n   * @param _answerId The identifier of the answer to be deleted\n   */\n  function deleteAnswer(uint256 _answerId)\n    private\n    ensureAllResponsesReceived(_answerId)\n  {\n    delete answers[_answerId];\n  }\n\n  /**\n   * @dev Prevents taking an action if the minimum number of responses has not\n   * been received for an answer.\n   * @param _answerId The the identifier of the answer that keeps track of the responses.\n   */\n  modifier ensureMinResponsesReceived(uint256 _answerId) {\n    if (answers[_answerId].responses.length >= answers[_answerId].minimumResponses) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Prevents taking an action if not all responses are received for an answer.\n   * @param _answerId The the identifier of the answer that keeps track of the responses.\n   */\n  modifier ensureAllResponsesReceived(uint256 _answerId) {\n    if (answers[_answerId].responses.length == answers[_answerId].maxResponses) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Prevents taking an action if a newer answer has been recorded.\n   * @param _answerId The current answer's identifier.\n   * Answer IDs are in ascending order.\n   */\n  modifier ensureOnlyLatestAnswer(uint256 _answerId) {\n    if (latestCompletedAnswer <= _answerId) {\n      _;\n    }\n  }\n\n  /**\n   * @dev Ensures corresponding number of oracles and jobs.\n   * @param _oracles The list of oracles.\n   * @param _jobIds The list of jobs.\n   */\n  modifier validateAnswerRequirements(\n    uint256 _minimumResponses,\n    address[] _oracles,\n    bytes32[] _jobIds\n  ) {\n    require(_oracles.length <= MAX_ORACLE_COUNT, \"cannot have more than 45 oracles\");\n    require(_oracles.length >= _minimumResponses, \"must have at least as many oracles as responses\");\n    require(_oracles.length == _jobIds.length, \"must have exactly as many oracles as job IDs\");\n    _;\n  }\n\n  /**\n   * @dev Reverts if `msg.sender` is not authorized to make requests.\n   */\n  modifier ensureAuthorizedRequester() {\n    require(authorizedRequesters[msg.sender] || msg.sender == owner, \"Not an authorized address for creating requests\");\n    _;\n  }\n\n}\n\n\npragma solidity ^0.4.11;\n\n\nimport \"./interfaces/ERC677.sol\";\nimport \"./interfaces/ERC677Receiver.sol\";\n\n\ncontract ERC677Token is ERC677 {\n\n  /**\n  * @dev transfer token to a contract address with additional data if the recipient is a contact.\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  * @param _data The extra data to be passed to the receiving contract.\n  */\n  function transferAndCall(address _to, uint _value, bytes _data)\n    public\n    returns (bool success)\n  {\n    super.transfer(_to, _value);\n    Transfer(msg.sender, _to, _value, _data);\n    if (isContract(_to)) {\n      contractFallback(_to, _value, _data);\n    }\n    return true;\n  }\n\n\n  // PRIVATE\n\n  function contractFallback(address _to, uint _value, bytes _data)\n    private\n  {\n    ERC677Receiver receiver = ERC677Receiver(_to);\n    receiver.onTokenTransfer(msg.sender, _value, _data);\n  }\n\n  function isContract(address _addr)\n    private\n    returns (bool hasCode)\n  {\n    uint length;\n    assembly { length := extcodesize(_addr) }\n    return length > 0;\n  }\n\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "Aggregator.sol",
            "ERC677Token.sol",
            "IERC1155.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual returns (uint256 shares) {\n        require(\n            msg.sender == owner || isApprovedForAll(owner, receiver),\n            \"Only owner can withdraw, or owner has approved receiver for all\"\n        );\n",
                    "//solidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n"
                ],
                "Type": " Griefing attack on the Vaults is possible, withdrawing the winning side stakes",
                "Description": "*Submitted by hyh, also found by 0x4non, 0xNazgul, Haruxe, joestakey, KIntern_NA, pauliax, peritoflores, PwnPatrol, Respx, rotcivegaf, scaraven, and Tointer*\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218\n\n\n*Anyone* can withdraw to receiver once the receiver is isApprovedForAll(owner, receiver). The funds will be sent to receiver, but it will happen whenever an arbitrary msg.sender wants. The only precondition is the presence of any approvals.\n\nThis can be easily used to sabotage the system as a whole. Say there are two depositors in the hedge Vault, Bob and David, both trust each other and approved each other. Mike the attacker observing the coming end of epoch where no depeg happened, calls the withdraw() for both Bob and David in the last block of the epoch. Mike gained nothing, while both Bob and David lost the payoff that was guaranteed for them at this point.\n\nSetting the severity to be high as this can be routinely used to sabotage the Y2K users, both risk and hedge, depriving them from the payouts whenever they happen to be on the winning side. Usual attackers here can be the users from another side, risk users attacking hedge vault, and vice versa.\n\n\nisApprovedForAll() in withdrawal functions checks the receiver to be approved, not the caller.\n\nSemiFungibleVault's withdraw:\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119\n\nsolidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual returns (uint256 shares) {\n        require(\n            msg.sender == owner || isApprovedForAll(owner, receiver),\n            \"Only owner can withdraw, or owner has approved receiver for all\"\n        );\n\n\nVault's withdraw:\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218\n\nsolidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n\nThis way anyone at any time can run withdraw from the Vaults whenever owner has some address approved.\n\n",
                "Repair": "\nConsider changing the approval requirement to be for the caller, not receiver:\n\nSemiFungibleVault's withdraw:\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119\n\nsolidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual returns (uint256 shares) {\n        require(\n          msg.sender == owner || isApprovedForAll(owner, receiver),\n+           msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"Only owner can withdraw, or owner has approved receiver for all\"\n        );\n\n\nVault's withdraw:\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218\n\nsolidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n          isApprovedForAll(owner, receiver) == false)\n+           isApprovedForAll(owner, msg.sender) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n\nMiguelBits (Y2K Finance) confirmed and commented(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/434#issuecomment-1254129699):\n  Implementing this.\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/434#issuecomment-1280213733):\n  Agree with the warden's finding, and the impact of \"depriving them (y2k users) from the payouts whenever they happen to be on the winning side\".\n\n\n\n*\n\n\n"
            }
        ]
    }
]