[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./oz/interfaces/IERC20.sol\";\nimport \"./oz/libraries/SafeERC20.sol\";\nimport \"./utils/Owner.sol\";\nimport \"./oz/utils/Pausable.sol\";\nimport \"./oz/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IBoostV2.sol\";\nimport \"./utils/Errors.sol\";\n\n/** @title Warden Pledge contract */\n/// @author Paladin\n/*\n    Delegation market (Pledge version) based on Curve Boost V2 contract\n*/\ncontract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Constants :\n    uint256 public constant UNIT = 1e18;\n    uint256 public constant MAX_PCT = 10000;\n    uint256 public constant WEEK = 7 * 86400;\n\n    // Storage :\n\n    struct Pledge{\n        // Target amount of veCRV (balance scaled by Boost v2, fetched as adjusted_balance)\n        uint256 targetVotes;\n        // Difference of votes between the target and the receiver balance at the start of the Pledge\n        // (used for later extend/increase of some parameters the Pledge)\n        uint256 votesDifference;\n        // Price per vote per second, set by the owner\n        uint256 rewardPerVote;\n        // Address to receive the Boosts\n        address receiver;\n        // Address of the token given as rewards to Boosters\n        address rewardToken;\n        // Timestamp of end of the Pledge\n        uint64 endTimestamp;\n        // Set to true if the Pledge is canceled, or when closed after the endTimestamp\n        bool closed;\n    }\n\n    /** @notice List of all Pledges */\n    Pledge[] public pledges;\n\n    /** @notice Owner of each Pledge (ordered by index in the pledges list) */\n    mapping(uint256 => address) public pledgeOwner;\n    /** @notice List of all Pledges for each owner */\n    mapping(address => uint256[]) public ownerPledges;\n\n    /** @notice Amount of rewards available for each Pledge */\n    // sorted by Pledge index\n    mapping(uint256 => uint256) public pledgeAvailableRewardAmounts;\n\n\n    /** @notice Address of the votingToken to delegate */\n    IVotingEscrow public votingEscrow;\n    /** @notice Address of the Delegation Boost contract */\n    IBoostV2 public delegationBoost;\n\n\n    /** @notice Minimum amount of reward per vote for each reward token */\n    // Also used to whitelist the tokens for rewards\n    mapping(address => uint256) public minAmountRewardToken;\n\n\n    /** @notice ratio of fees to pay the protocol (in BPS) */\n    uint256 public protocalFeeRatio = 250; //bps\n    /** @notice Address to receive protocol fees */\n    address public chestAddress;\n\n    /** @notice Minimum target of votes for a Pledge */\n    uint256 public minTargetVotes;\n\n    /** @notice Minimum delegation time, taken from veBoost contract */\n    uint256 public minDelegationTime = 1 weeks;\n\n\n    // Events\n\n    /** @notice Event emitted when xx */\n    event NewPledge(\n        address creator,\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote,\n        uint256 endTimestamp\n    );\n    /** @notice Event emitted when xx */\n    event ExtendPledgeDuration(uint256 indexed pledgeId, uint256 oldEndTimestamp, uint256 newEndTimestamp);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeTargetVotes(uint256 indexed pledgeId, uint256 oldTargetVotes, uint256 newTargetVotes);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeRewardPerVote(uint256 indexed pledgeId, uint256 oldRewardPerVote, uint256 newRewardPerVote);\n    /** @notice Event emitted when xx */\n    event ClosePledge(uint256 indexed pledgeId);\n    /** @notice Event emitted when xx */\n    event RetrievedPledgeRewards(uint256 indexed pledgeId, address receiver, uint256 amount);\n\n    /** @notice Event emitted when xx */\n    event Pledged(uint256 indexed pledgeId, address indexed user, uint256 amount, uint256 endTimestamp);\n\n    /** @notice Event emitted when xx */\n    event NewRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event UpdateRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event RemoveRewardToken(address indexed token);\n\n    /** @notice Event emitted when xx */\n    event ChestUpdated(address oldChest, address newChest);\n    /** @notice Event emitted when xx */\n    event PlatformFeeUpdated(uint256 oldfee, uint256 newFee);\n    /** @notice Event emitted when xx */\n    event MinTargetUpdated(uint256 oldMinTarget, uint256 newMinTargetVotes);\n\n\n\n    // Constructor\n\n    /**\n    * @dev Creates the contract, set the given base parameters\n    * @param _votingEscrow address of the voting token to delegate\n    * @param _delegationBoost address of the contract handling delegation\n    * @param _minTargetVotes min amount of veToken to target in a Pledge\n    */\n    constructor(\n        address _votingEscrow,\n        address _delegationBoost,\n        address _chestAddress,\n        uint256 _minTargetVotes\n    ) {\n        votingEscrow = IVotingEscrow(_votingEscrow);\n        delegationBoost = IBoostV2(_delegationBoost);\n\n        chestAddress = _chestAddress;\n\n        minTargetVotes = _minTargetVotes;\n    }\n\n    \n    // View Methods\n\n    /**\n    * @notice Amount of Pledges listed in this contract\n    * @dev Amount of Pledges listed in this contract\n    * @return uint256: Amount of Pledges listed in this contract\n    */\n    function pledgesIndex() public view returns(uint256){\n        return pledges.length;\n    }\n\n    /**\n    * @notice Get all Pledges created by the user\n    * @dev Get all Pledges created by the user\n    * @param user Address of the user\n    * @return uint256[]: List of Pledges IDs\n    */\n    function getUserPledges(address user) external view returns(uint256[] memory){\n        return ownerPledges[user];\n    }\n\n    /**\n    * @notice Get all the Pledges\n    * @dev Get all the Pledges\n    * @return Pledge[]: List of Pledge structs\n    */\n    function getAllPledges() external view returns(Pledge[] memory){\n        return pledges;\n    }\n\n    /**\n    * @dev Rounds down given timestamp to weekly periods\n    * @param timestamp timestamp to round down\n    * @return uint256: rounded down timestamp\n    */\n    function _getRoundedTimestamp(uint256 timestamp) internal pure returns(uint256) {\n        return (timestamp / WEEK) * WEEK;\n    }\n\n\n    // Pledgers Methods\n\n    /**\n    * @notice Delegates boost to a given Pledge & receive rewards\n    * @dev Delegates boost to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledge(uint256 pledgeId, uint256 amount, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n    }\n\n    /**\n    * @notice Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @dev Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param percent Percent of balance to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledgePercent(uint256 pledgeId, uint256 percent, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        if(percent > MAX_PCT) revert Errors.PercentOverMax();\n\n        uint256 amount = (votingEscrow.balanceOf(msg.sender) * percent) / MAX_PCT;\n\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n        \n    }\n\n    /**\n    * @dev Delegates the boost to the Pledge receiver & sends rewards to the delegator\n    * @param pledgeId Pledge to delegate to\n    * @param user Address of the delegator\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        if(amount == 0) revert Errors.NullValue();\n\n        // Load Pledge parameters & check the Pledge is still active\n        Pledge memory pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // To join until the end of the pledge, user can input 0 as endTimestamp\n        // so it's override by the Pledge's endTimestamp\n        if(endTimestamp == 0) endTimestamp = pledgeParams.endTimestamp;\n        if(endTimestamp > pledgeParams.endTimestamp || endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        // Calculated the effective Pledge duration\n        uint256 boostDuration = endTimestamp - block.timestamp;\n\n        // Check that the user has enough boost delegation available & set the correct allowance to this contract\n        delegationBoost.checkpoint_user(user);\n        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n\n        // Check that this will not go over the Pledge target of votes\n        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n\n        // Creates the DelegationBoost\n        delegationBoost.boost(\n            pledgeParams.receiver,\n            amount,\n            endTimestamp,\n            user\n        );\n\n        // Re-calculate the new Boost bias & slope (using Boostv2 logic)\n        uint256 slope = amount / boostDuration;\n        uint256 bias = slope * boostDuration;\n\n        // Rewards are set in the Pledge as reward/veToken/sec\n        // To find the total amount of veToken delegated through the whole Boost duration\n        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases\n        // each second of the Boost duration\n        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n        // Then we can calculate the total amount of rewards for this Boost\n        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n\n        if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n\n        // Send the rewards to the user\n        IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);\n\n        emit Pledged(pledgeId, user, amount, endTimestamp);\n    }\n\n\n    // Pledge Creators Methods\n\n    struct CreatePledgeVars {\n        uint256 duration;\n        uint256 votesDifference;\n        uint256 totalRewardAmount;\n        uint256 feeAmount;\n        uint256 newPledgeID;\n    }\n\n    /**\n    * @notice Creates a new Pledge\n    * @dev Creates a new Pledge\n    * @param receiver Address to receive the boost delegation\n    * @param rewardToken Address of the token distributed as reward\n    * @param targetVotes Maximum taget of votes to have (own balacne + delegation) for the receiver\n    * @param rewardPerVote Amount of reward given for each vote delegation (per second)\n    * @param endTimestamp End of the Pledge\n    * @param maxTotalRewardAmount Maximum total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum feeamount allowed ot be pulled by this contract\n    * @return uint256: Newly created Pledge ID\n    */\n    function createPledge(\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote, // reward/veToken/second\n        uint256 endTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant returns(uint256){\n        address creator = msg.sender;\n\n        if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress();\n        if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin();\n        if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();\n        if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow();\n\n        if(endTimestamp == 0) revert Errors.NullEndTimestamp();\n        if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        CreatePledgeVars memory vars;\n        vars.duration = endTimestamp - block.timestamp;\n        if(vars.duration < minDelegationTime) revert Errors.DurationTooShort();\n\n        // Get the missing votes for the given receiver to reach the target votes\n        // We ignore any delegated boost here because they might expire during the Pledge duration\n        // (we can have a future version of this contract using adjusted_balance)\n        vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);\n\n        vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n        vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);\n\n        vars.newPledgeID = pledgesIndex();\n\n        // Add the total reards as available for the Pledge & write Pledge parameters in storage\n        pledgeAvailableRewardAmounts[vars.newPledgeID] += vars.totalRewardAmount;\n\n        pledges.push(Pledge(\n            targetVotes,\n            vars.votesDifference,\n            rewardPerVote,\n            receiver,\n            rewardToken,\n            safe64(endTimestamp),\n            false\n        ));\n\n        pledgeOwner[vars.newPledgeID] = creator;\n        ownerPledges[creator].push(vars.newPledgeID);\n\n        emit NewPledge(creator, receiver, rewardToken, targetVotes, rewardPerVote, endTimestamp);\n\n        return vars.newPledgeID;\n    }\n\n    /**\n    * @notice Extends the Pledge duration\n    * @dev Extends the Pledge duration & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newEndTimestamp New end of the Pledge\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function extendPledge(\n        uint256 pledgeId,\n        uint256 newEndTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n        if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();\n        uint256 oldEndTimestamp = pledgeParams.endTimestamp;\n        if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();\n\n        uint256 addedDuration = newEndTimestamp - oldEndTimestamp;\n        if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();\n        uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.endTimestamp = safe64(newEndTimestamp);\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit ExtendPledgeDuration(pledgeId, oldEndTimestamp, newEndTimestamp);\n    }\n\n    /**\n    * @notice Increases the Pledge reward per vote delegated\n    * @dev Increases the Pledge reward per vote delegated & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newRewardPerVote New amount of reward given for each vote delegation (per second)\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function increasePledgeRewardPerVote(\n        uint256 pledgeId,\n        uint256 newRewardPerVote,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        uint256 oldRewardPerVote = pledgeParams.rewardPerVote;\n        if(newRewardPerVote <= oldRewardPerVote) revert Errors.RewardsPerVotesTooLow();\n        uint256 remainingDuration = pledgeParams.endTimestamp - block.timestamp;\n        uint256 rewardPerVoteDiff = newRewardPerVote - oldRewardPerVote;\n        uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.rewardPerVote = newRewardPerVote;\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit IncreasePledgeRewardPerVote(pledgeId, oldRewardPerVote, newRewardPerVote);\n    }\n\n    /**\n    * @notice Retrieves all non distributed rewards from a closed Pledge\n    * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge\n    * @param receiver Address to receive the remaining rewards\n    */\n    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.endTimestamp > block.timestamp) revert Errors.PledgeNotExpired();\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        // Set the Pledge as Closed\n        if(!pledgeParams.closed) pledgeParams.closed = true;\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n    }\n\n    /**\n    * @notice Closes a Pledge and retrieves all non distributed rewards from a Pledge\n    * @dev Closes a Pledge and retrieves all non distributed rewards from a Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge to close\n    * @param receiver Address to receive the remaining rewards\n    */\n    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeAlreadyClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // Set the Pledge as Closed\n        pledgeParams.closed = true;\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n\n        emit ClosePledge(pledgeId);\n    }\n\n\n    // Admin Methods\n\n    /**\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minRewardPerSecond == 0) revert Errors.NullValue();\n        \n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit NewRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param tokens List of token addresses to add\n    * @param minRewardsPerSecond Minmum amount of reward per vote per second for each token in the list\n    */\n    function addMultipleRewardToken(address[] calldata tokens, uint256[] calldata minRewardsPerSecond) external onlyOwner {\n        uint256 length = tokens.length;\n\n        if(length == 0) revert Errors.EmptyArray();\n        if(length != minRewardsPerSecond.length) revert Errors.InequalArraySizes();\n\n        for(uint256 i = 0; i < length;){\n            _addRewardToken(tokens[i], minRewardsPerSecond[i]);\n\n            unchecked{ ++i; }\n        }\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function addRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        _addRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Updates a reward token\n    * @dev Updates a reward token\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function updateRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        if(minRewardPerSecond == 0) revert Errors.InvalidValue();\n\n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit UpdateRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Removes a reward token from the whitelist\n    * @dev Removes a reward token from the whitelist\n    * @param token Address of the token\n    */\n    function removeRewardToken(address token) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        \n        minAmountRewardToken[token] = 0;\n        \n        emit RemoveRewardToken(token);\n    }\n    \n    /**\n    * @notice Updates the Chest address\n    * @dev Updates the Chest address\n    * @param chest Address of the new Chest\n    */\n    function updateChest(address chest) external onlyOwner {\n        if(chest == address(0)) revert Errors.ZeroAddress();\n        address oldChest = chestAddress;\n        chestAddress = chest;\n\n        emit ChestUpdated(oldChest, chest);\n    }\n\n    /**\n    * @notice Updates the new min target of votes for Pledges\n    * @dev Updates the new min target of votes for Pledges\n    * @param newMinTargetVotes New minimum target of votes\n    */\n    function updateMinTargetVotes(uint256 newMinTargetVotes) external onlyOwner {\n        if(newMinTargetVotes == 0) revert Errors.InvalidValue();\n        uint256 oldMinTarget = minTargetVotes;\n        minTargetVotes = newMinTargetVotes;\n\n        emit MinTargetUpdated(oldMinTarget, newMinTargetVotes);\n    }\n\n    /**\n    * @notice Updates the Platfrom fees BPS ratio\n    * @dev Updates the Platfrom fees BPS ratio\n    * @param newFee New fee ratio\n    */\n    function updatePlatformFee(uint256 newFee) external onlyOwner {\n        if(newFee > 500) revert Errors.InvalidValue();\n        uint256 oldfee = protocalFeeRatio;\n        protocalFeeRatio = newFee;\n\n        emit PlatformFeeUpdated(oldfee, newFee);\n    }\n\n    /**\n     * @notice Pauses the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n    * @notice Recovers ERC2O tokens sent by mistake to the contract\n    * @dev Recovers ERC2O tokens sent by mistake to the contract\n    * @param token Address tof the EC2O token\n    * @return bool: success\n    */\n    function recoverERC20(address token) external onlyOwner returns(bool) {\n        if(minAmountRewardToken[token] != 0) revert Errors.CannotRecoverToken();\n\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        if(amount == 0) revert Errors.NullValue();\n        IERC20(token).safeTransfer(owner(), amount);\n\n        return true;\n    }\n\n    // Utils \n\n    function safe64(uint256 n) internal pure returns (uint64) {\n        if(n > type(uint64).max) revert Errors.NumberExceed64Bits();\n        return uint64(n);\n    }\n\n\n}\n\n",
        "CodeNames": [
            "WardenPledge.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "_pledge"
                ],
                "Type": " Due to loss of precision, targetVotes may not reach",
                "Description": "*Submitted by cccz(https://github.com/code-423n4/2022-10-paladin-findings/issues/59)*\n\nIn the _pledge function, require delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount <= pledgeParams.targetVotes.\n\nIn reality, when the user pledges the amount of votes, the actual votes received by the receiver are the bias in the following calculation. And the bias will be less than amount due to the loss of precision.\n\n            uint256 slope = amount / boostDuration;\n            uint256 bias = slope * boostDuration;\n\nThis means that the balance of receiver may not reach targetVotes\n\n        point = self._checkpoint_read(_user, False)\n        amount += (point.bias point.slope * (block.timestamp point.ts))\n        return amount\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L245-L246\n\n<https://github.com/curvefi/curve-veBoost/blob/master/contracts/BoostV2.vy#L192-L209\n\n<https://github.com/curvefi/curve-veBoost/blob/master/contracts/BoostV2.vy#L175\n\n",
                "Repair": "\nUse bias instead of amount in the check below:\n\n            uint256 slope = amount / boostDuration;\n            uint256 bias = slope * boostDuration;\n            if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + bias  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n            delegationBoost.boost(\n                pledgeParams.receiver,\n                amount,\n                endTimestamp,\n                user\n            );\n\nKogaroshi (Paladin) acknowledged and commented(https://github.com/code-423n4/2022-10-paladin-findings/issues/59#issuecomment-1296374082):\n  The current check is made that way to prevent any unnecessary call to the BoostV2 contract (and save gas by not creating the Boost) in the case of a targetVotes overflow.\n\n*\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction createPledge(\n    address receiver,\n    address rewardToken,\n    uint256 targetVotes,\n    uint256 rewardPerVote, // reward/veToken/second\n    uint256 endTimestamp,\n    uint256 maxTotalRewardAmount,\n    uint256 maxFeeAmount\n) external whenNotPaused nonReentrant returns(uint256){\n    ...\n    // Get the missing votes for the given receiver to reach the target votes\n    // We ignore any delegated boost here because they might expire during the Pledge duration\n    // (we can have a future version of this contract using adjusted_balance)\n    vars.votesDifference = targetVotes votingEscrow.balanceOf(receiver);\n\n    vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n    ...\n  }\n",
                    "//solidity\nfunction extendPledge(\n    uint256 pledgeId,\n    uint256 newEndTimestamp,\n    uint256 maxTotalRewardAmount,\n    uint256 maxFeeAmount\n) external whenNotPaused nonReentrant {\n    ...\n    Pledge storage pledgeParams = pledges[pledgeId];\n    ...\n    uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;\n    ...\n}\n\nfunction increasePledgeRewardPerVote(\n    uint256 pledgeId,\n    uint256 newRewardPerVote,\n    uint256 maxTotalRewardAmount,\n    uint256 maxFeeAmount\n) external whenNotPaused nonReentrant {\n    ...\n    Pledge storage pledgeParams = pledges[pledgeId];\n    ...\n    uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;\n    ...\n}\n",
                    "//solidity\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n        ...\n        // Check that this will not go over the Pledge target of votes\n        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n        ...\n    }\n    "
                ],
                "Type": " Reward can be over- or undercounted in  extendPledge  and  increasePledgeRewardPerVote ",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-10-paladin-findings/issues/163), also found by Aymen0909(https://github.com/code-423n4/2022-10-paladin-findings/issues/280), Trust(https://github.com/code-423n4/2022-10-paladin-findings/issues/234), 0xDjango(https://github.com/code-423n4/2022-10-paladin-findings/issues/186), Chom(https://github.com/code-423n4/2022-10-paladin-findings/issues/94), Lambda(https://github.com/code-423n4/2022-10-paladin-findings/issues/83), and Ruhum(https://github.com/code-423n4/2022-10-paladin-findings/issues/61)*\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432\n\n\nTotal reward amount in extendPledge and increasePledgeRewardPerVote can be calculated incorrectly due to cached pledgeParams.votesDifference, which can lead to two outcomes:\n\n1.  total reward amount is higher, thus a portion of it won't be claimable;\n2.  total reward amount is lower, thus the pledge target won't be reached.\n\n\nWhen a pledge is created, the creator chooses the target\u2013the total amount of votes they want to reach with the pledge. Based on a target, the number of missing votes is calculated, which is then used to calculated the total reward amount ([WardenPledge.sol#L325-L327(https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L327)):\n\nsolidity\nfunction createPledge(\n    address receiver,\n    address rewardToken,\n    uint256 targetVotes,\n    uint256 rewardPerVote, // reward/veToken/second\n    uint256 endTimestamp,\n    uint256 maxTotalRewardAmount,\n    uint256 maxFeeAmount\n) external whenNotPaused nonReentrant returns(uint256){\n    ...\n    // Get the missing votes for the given receiver to reach the target votes\n    // We ignore any delegated boost here because they might expire during the Pledge duration\n    // (we can have a future version of this contract using adjusted_balance)\n    vars.votesDifference = targetVotes votingEscrow.balanceOf(receiver);\n\n    vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n    ...\n  }\n\n\nWhen extending a pledge or increasing a pledge reward per vote, current veToken balance of the pledge's receiver (votingEscrow.balanceOf(receiver)) can be different from the one it had when the pledge was created (e.g. the receiver managed to lock more CRV or some of locked tokens have expired). However pledgeParams.votesDifference is not recalculated ([WardenPledge.sol#L387(https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387), WardenPledge.sol#L432(https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432)):\n\nsolidity\nfunction extendPledge(\n    uint256 pledgeId,\n    uint256 newEndTimestamp,\n    uint256 maxTotalRewardAmount,\n    uint256 maxFeeAmount\n) external whenNotPaused nonReentrant {\n    ...\n    Pledge storage pledgeParams = pledges[pledgeId];\n    ...\n    uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;\n    ...\n}\n\nfunction increasePledgeRewardPerVote(\n    uint256 pledgeId,\n    uint256 newRewardPerVote,\n    uint256 maxTotalRewardAmount,\n    uint256 maxFeeAmount\n) external whenNotPaused nonReentrant {\n    ...\n    Pledge storage pledgeParams = pledges[pledgeId];\n    ...\n    uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;\n    ...\n}\n\n\nThis can lead to two consequences:\n\n1.  When receiver's veToken balance has increased (i.e. votesDifference got in fact smaller), pledge creator will overpay for pledge extension and pledge reward per vote increase. This extra reward cannot be received by pledgers because a receiver cannot get more votes than pledgeParams.targetVotes (which is not updated when modifying a pledge):\n    solidity\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n        ...\n        // Check that this will not go over the Pledge target of votes\n        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n        ...\n    }\n    \n2.  When receiver's veToken balance has decreased (i.e. votesDifference got in fact bigger), the pledge target cannot be reached because the reward amount was underpaid in extendPledge/increasePledgeRewardPerVote.\n\n",
                "Repair": "\nConsider updating votesDifference when extending a pledge or increasing a pledge reward per vote.\n\nKogaroshi (Paladin) confirmed and commented(https://github.com/code-423n4/2022-10-paladin-findings/issues/163#issuecomment-1301496158):\n  As stated in #91(https://github.com/code-423n4/2022-10-paladin-findings/issues/91), new method for needed votes & needed reward calculations is introduced in this commit(https://github.com/PaladinFinance/Warden-v2/pull/2/commits/edc9b0280bbb4144d3983642eeab9db17499e9f6), allowing to get the exact amount of reward token the Pledge creator should pay when extending the Pledge or increasing the rewardPerVote.\n\n*\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "retrievePledgeRewards()",
                    "totalRewardAmount",
                    "createPledge"
                ],
                "Type": "  Fees charged from entire theoretical pledge amount instead of actual pledge amount",
                "Description": "*Submitted by Trust(https://github.com/code-423n4/2022-10-paladin-findings/issues/235), also found by 0x52(https://github.com/code-423n4/2022-10-paladin-findings/issues/142)*\n\nPaladin receives a 5% cut from Boost purchases, as documented on the website(https://paladin.vote/#/):\n\n\"Warden takes a 5% fee on Boost purchases, and 5% on Quest incentives. However, there are various pricing tiers for Quest creators. Contact the Paladin team for more info.\"\n\nHere's how fee calculation looks at  createPledge function:\n\n    vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n    vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n    if(vars.totalRewardAmount  maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n    if(vars.feeAmount  maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n    // Pull all the rewards in this contract\n    IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);\n    // And transfer the fees from the Pledge creator to the Chest contract\n    IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);\n\nThe issue is that the fee is taken up front, assuming totalRewardAmount will actually be rewarded by the pledge. In practice, the rewards actually utilized can be anywhere from zero to totalRewardAmount. Indeed, reward will only be totalRewardAmount if, in the entire period from pledge creation to pledge expiry, the desired targetVotes will be fulfilled, which is extremly unlikely.\n\nAs a result, if pledge expires with no pledgers, protocol will still take 5%. This behavior is both unfair and against the docs, as it's not \"Paladin receives a 5% cut from Boost purchases\".\n\n\nPaladin fee collection assumes pledges will be matched immediately and fully, which is not realistic. Therefore far too many fees are collected at user's expense.\n\n\n1.  Bob creates a pledge, with target = 200, current balance = 100, rewardVotes = 10, remaining time = 1 week.\n2.  Protocol collects (200 100) &ast; 10 &ast; WEEK_SECONDS &ast; 5% fees\n3.  A week passed, rewards were not attractive enough to bring pledgers.\n4.  After expiry, Bob calls retrievePledgeRewards() and gets 100 &ast; 10 &ast; WEEK_SECONDS back, but 5% of the fees still went to chestAddress.\n\n",
                "Repair": "\nFee collection should be done after the pledge completes, in one of the close functions or in a newly created pull function for owner to collect fees. Otherwise, it is a completely unfair system.\n\nKogaroshi (Paladin) acknowledged and commented(https://github.com/code-423n4/2022-10-paladin-findings/issues/235#issuecomment-1298449433):\n  The issue is acknowledged, and we do calculate fee on the basis of all rewards, and not only the one that are gonna be used to reward users.\n \n The fee ratio is gonna be of 1% to start with (might change before deploy based on market estimations), and the Core team will be able to change the ratio quickly to adapt it to market and Pledge creators needs (with also considering the Paladin DAO revenues). The Paladin team will also considers Pledge creators that are in specific cases and overpay fees (because they already have delegated boost that will last through the whole Pledge and more), and will be able to refund a part of those fees to the creator if the DAO agrees.\n\n And if this system does not fit in the current market, and is a blocker to potential Pledge creators, we will be able to modify the way fees are handled, and deploy a new iteration of Pledge pretty fast to answer the issue.\n\n*\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "//solidity\n    function pause() external onlyOwner {\n        _pause();\n    }\n",
                    "//solidity\n    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        ...\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        if(remainingAmount  0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            ...\n\n        }\n\n        ...\n    }\n",
                    "//solidity\n    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        ...\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        ...\n\n        if(remainingAmount  0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            ...\n\n        }\n    }\n",
                    "typescript\n        it.only('Pausing WardenPledge contract, which takes effect immediately, by its owner can unexpectedly block pledge creator from calling closePledge function', async () = {\n            // before calling the createPledge function, the wardenPledge contract owns no rewardToken1\n            const rewardToken1BalanceWardenPledgeBefore = await rewardToken1.balanceOf(wardenPledge.address)\n            expect(rewardToken1BalanceWardenPledgeBefore).to.be.eq(0)\n\n            const rewardToken1BalanceCreatorBefore = await rewardToken1.balanceOf(creator.address)\n\n            // creator calls the createPledge function\n            await wardenPledge.connect(creator).createPledge(\n                receiver.address,\n                rewardToken1.address,\n                target_votes,\n                reward_per_vote,\n                end_timestamp,\n                max_total_reward_amount,\n                max_fee_amount\n            )\n\n            // after one week, admin, who is the owner of the wardenPledge contract, calls the pause function, which takes effect immediately\n            await advanceTime(WEEK.toNumber())\n            await wardenPledge.connect(admin).pause()\n\n            // Since an emergency that requires an increase of cash flow occurs, creator decides to close the pledge for getting back the deposited rewardToken1 amount.\n            // Without knowing in advance that the wardenPledge contract would be paused,\n            //   creator calls the closePledge function and anticipates to receive the deposited rewardToken1 amount.\n            // Unfortunately, admin's pause transaction has been executed just before creator's closePledge transaction is executed, which causes creator's closePledge transaction to revert.\n            await expect(\n                wardenPledge.connect(creator).closePledge(pledge_id, creator.address)\n            ).to.be.revertedWith(\"Pausable: paused\")\n\n            // after creator's closePledge transaction reverts, creator does not receive the deposited rewardToken1 amount, which is unexpected to her or him\n            const rewardToken1BalanceCreatorAfter = await rewardToken1.balanceOf(creator.address)\n            expect(rewardToken1BalanceCreatorAfter).to.be.lt(rewardToken1BalanceCreatorBefore)\n\n            // meanwhile, the wardenPledge contract still holds the creator's deposited rewardToken1 amount\n            const rewardToken1BalanceWardenPledgeAfter = await rewardToken1.balanceOf(wardenPledge.address)\n            expect(rewardToken1BalanceWardenPledgeAfter).to.be.gt(0)\n        });\n"
                ],
                "Type": " Pausing  WardenPledge  contract, which takes effect immediately, by its owner can unexpectedly block pledge creator from calling  closePledge  or  retrievePledgeRewards  function",
                "Description": "*Submitted by rbserver(https://github.com/code-423n4/2022-10-paladin-findings/issues/269), also found by 0x1f8b(https://github.com/code-423n4/2022-10-paladin-findings/issues/282), 0xSmartContract(https://github.com/code-423n4/2022-10-paladin-findings/issues/248), Trust(https://github.com/code-423n4/2022-10-paladin-findings/issues/233), hansfriese(https://github.com/code-423n4/2022-10-paladin-findings/issues/194), ctf_sec(https://github.com/code-423n4/2022-10-paladin-findings/issues/70), cccz(https://github.com/code-423n4/2022-10-paladin-findings/issues/58), and codexploder(https://github.com/code-423n4/2022-10-paladin-findings/issues/30)*\n\n<https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L636-L638\n\n<https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L488-L515\n\n<https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L456-L480\n\n\nThe owner of the WardenPledge contract is able to call the pause function to pause this contract. When the WardenPledge contract is paused, calling the closePledge or retrievePledgeRewards function that uses the whenNotPaused modifier reverts, and the pledge creator is not able to get back any of the reward token amount, which was deposited by the creator previously. Because calling the pause function takes effect immediately, it can be unexpected to the creator for suddenly not being able to call the closePledge or retrievePledgeRewards function. For instance, when an emergency occurs that requires an increase of cash flow, the creator wants to close the pledge early so she or he can use the remaining deposited reward token amount. However, just before the creator's closePledge transaction is executed, the pause transaction has been sent by the owner of the WardenPledge contract for some reason and executed. Without knowing in advance that the WardenPledge contract would be paused, the creator anticipates receiving the remaining deposited reward token amount but this is not the case since calling the closePledge function reverts. Because the creator unexpectedly fails to receive such amount and might fail to deal with the emergency, disputes with the protocol can occur, and the user experience becomes degraded.\n\n<https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L636-L638\n\nsolidity\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L488-L515\n\nsolidity\n    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        ...\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        if(remainingAmount  0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            ...\n\n        }\n\n        ...\n    }\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L456-L480\n\nsolidity\n    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        ...\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        ...\n\n        if(remainingAmount  0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            ...\n\n        }\n    }\n\n\n\nPlease append the following test in the pause & unpause describe block in testwardenPledge.test.ts. This test will pass to demonstrate the described scenario.\n\ntypescript\n        it.only('Pausing WardenPledge contract, which takes effect immediately, by its owner can unexpectedly block pledge creator from calling closePledge function', async () = {\n            // before calling the createPledge function, the wardenPledge contract owns no rewardToken1\n            const rewardToken1BalanceWardenPledgeBefore = await rewardToken1.balanceOf(wardenPledge.address)\n            expect(rewardToken1BalanceWardenPledgeBefore).to.be.eq(0)\n\n            const rewardToken1BalanceCreatorBefore = await rewardToken1.balanceOf(creator.address)\n\n            // creator calls the createPledge function\n            await wardenPledge.connect(creator).createPledge(\n                receiver.address,\n                rewardToken1.address,\n                target_votes,\n                reward_per_vote,\n                end_timestamp,\n                max_total_reward_amount,\n                max_fee_amount\n            )\n\n            // after one week, admin, who is the owner of the wardenPledge contract, calls the pause function, which takes effect immediately\n            await advanceTime(WEEK.toNumber())\n            await wardenPledge.connect(admin).pause()\n\n            // Since an emergency that requires an increase of cash flow occurs, creator decides to close the pledge for getting back the deposited rewardToken1 amount.\n            // Without knowing in advance that the wardenPledge contract would be paused,\n            //   creator calls the closePledge function and anticipates to receive the deposited rewardToken1 amount.\n            // Unfortunately, admin's pause transaction has been executed just before creator's closePledge transaction is executed, which causes creator's closePledge transaction to revert.\n            await expect(\n                wardenPledge.connect(creator).closePledge(pledge_id, creator.address)\n            ).to.be.revertedWith(\"Pausable: paused\")\n\n            // after creator's closePledge transaction reverts, creator does not receive the deposited rewardToken1 amount, which is unexpected to her or him\n            const rewardToken1BalanceCreatorAfter = await rewardToken1.balanceOf(creator.address)\n            expect(rewardToken1BalanceCreatorAfter).to.be.lt(rewardToken1BalanceCreatorBefore)\n\n            // meanwhile, the wardenPledge contract still holds the creator's deposited rewardToken1 amount\n            const rewardToken1BalanceWardenPledgeAfter = await rewardToken1.balanceOf(wardenPledge.address)\n            expect(rewardToken1BalanceWardenPledgeAfter).to.be.gt(0)\n        });\n\n\n\nVSCode\n\n",
                "Repair": "\nThe pause function can be updated to be time-delayed so the pledge creator can have more time to react. One way would be making this function only callable by a timelock governance contract.\n\nKogaroshi (Paladin) confirmed(https://github.com/code-423n4/2022-10-paladin-findings/issues/70)\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 67 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-10-paladin-findings/issues/212) by robee received the top score from the judge.\n\n*The following wardens also submitted reports: ajtra(https://github.com/code-423n4/2022-10-paladin-findings/issues/277), \nrbserver(https://github.com/code-423n4/2022-10-paladin-findings/issues/272), \nadriro(https://github.com/code-423n4/2022-10-paladin-findings/issues/267), \nperitoflores(https://github.com/code-423n4/2022-10-paladin-findings/issues/266), \nJosiah(https://github.com/code-423n4/2022-10-paladin-findings/issues/264), \ntnevler(https://github.com/code-423n4/2022-10-paladin-findings/issues/262), \nhorsefacts(https://github.com/code-423n4/2022-10-paladin-findings/issues/251), \nbrgltd(https://github.com/code-423n4/2022-10-paladin-findings/issues/250), \ndjxploit(https://github.com/code-423n4/2022-10-paladin-findings/issues/246), \nminhtrng(https://github.com/code-423n4/2022-10-paladin-findings/issues/244), \nDravee(https://github.com/code-423n4/2022-10-paladin-findings/issues/240), \nB2(https://github.com/code-423n4/2022-10-paladin-findings/issues/239), \nTrust(https://github.com/code-423n4/2022-10-paladin-findings/issues/237), \nlukris02(https://github.com/code-423n4/2022-10-paladin-findings/issues/231), \ndelfin454000(https://github.com/code-423n4/2022-10-paladin-findings/issues/230), \nc3phas(https://github.com/code-423n4/2022-10-paladin-findings/issues/224), \nRaoulSchaffranek(https://github.com/code-423n4/2022-10-paladin-findings/issues/220), \nWaze(https://github.com/code-423n4/2022-10-paladin-findings/issues/211), \nTricko(https://github.com/code-423n4/2022-10-paladin-findings/issues/209), \nJTJabba(https://github.com/code-423n4/2022-10-paladin-findings/issues/204), \na12jmx(https://github.com/code-423n4/2022-10-paladin-findings/issues/192), \nSm4rty(https://github.com/code-423n4/2022-10-paladin-findings/issues/190), \n0xSmartContract(https://github.com/code-423n4/2022-10-paladin-findings/issues/187), \nimare(https://github.com/code-423n4/2022-10-paladin-findings/issues/178), \n0xNazgul(https://github.com/code-423n4/2022-10-paladin-findings/issues/173), \nJeiwan(https://github.com/code-423n4/2022-10-paladin-findings/issues/168), \n0x52(https://github.com/code-423n4/2022-10-paladin-findings/issues/156), \nDiana(https://github.com/code-423n4/2022-10-paladin-findings/issues/151), \nshark(https://github.com/code-423n4/2022-10-paladin-findings/issues/140), \n__141345__(https://github.com/code-423n4/2022-10-paladin-findings/issues/138), \ncarlitox477(https://github.com/code-423n4/2022-10-paladin-findings/issues/136), \nktg(https://github.com/code-423n4/2022-10-paladin-findings/issues/134), \nAwesome(https://github.com/code-423n4/2022-10-paladin-findings/issues/132), \nPicodes(https://github.com/code-423n4/2022-10-paladin-findings/issues/129), \ncorerouter(https://github.com/code-423n4/2022-10-paladin-findings/issues/125), \n0x007(https://github.com/code-423n4/2022-10-paladin-findings/issues/123), \nRedOneN(https://github.com/code-423n4/2022-10-paladin-findings/issues/122), \ncryptonue(https://github.com/code-423n4/2022-10-paladin-findings/issues/115), \njayphbee(https://github.com/code-423n4/2022-10-paladin-findings/issues/111), \n0xDjango(https://github.com/code-423n4/2022-10-paladin-findings/issues/110), \nRuhum(https://github.com/code-423n4/2022-10-paladin-findings/issues/108), \npashov(https://github.com/code-423n4/2022-10-paladin-findings/issues/107), \ncylzxje(https://github.com/code-423n4/2022-10-paladin-findings/issues/99), \nChom(https://github.com/code-423n4/2022-10-paladin-findings/issues/95), \nReyAdmirado(https://github.com/code-423n4/2022-10-paladin-findings/issues/88), \nRolezn(https://github.com/code-423n4/2022-10-paladin-findings/issues/85), \nLambda(https://github.com/code-423n4/2022-10-paladin-findings/issues/82), \nctf_sec(https://github.com/code-423n4/2022-10-paladin-findings/issues/78), \nladboy233(https://github.com/code-423n4/2022-10-paladin-findings/issues/74), \n8olidity(https://github.com/code-423n4/2022-10-paladin-findings/issues/72), \nch0bu(https://github.com/code-423n4/2022-10-paladin-findings/issues/71), \njwood(https://github.com/code-423n4/2022-10-paladin-findings/issues/62), \ncccz(https://github.com/code-423n4/2022-10-paladin-findings/issues/57), \noyc_109(https://github.com/code-423n4/2022-10-paladin-findings/issues/56), \nyixxas(https://github.com/code-423n4/2022-10-paladin-findings/issues/43), \ndic0de(https://github.com/code-423n4/2022-10-paladin-findings/issues/42), \nchaduke(https://github.com/code-423n4/2022-10-paladin-findings/issues/35), \ncsanuragjain(https://github.com/code-423n4/2022-10-paladin-findings/issues/27), \nchrisdior4(https://github.com/code-423n4/2022-10-paladin-findings/issues/26), \nneko_nyaa(https://github.com/code-423n4/2022-10-paladin-findings/issues/23), \nBnke0x0(https://github.com/code-423n4/2022-10-paladin-findings/issues/22), \n0x1f8b(https://github.com/code-423n4/2022-10-paladin-findings/issues/20), \nrvierdiiev(https://github.com/code-423n4/2022-10-paladin-findings/issues/18), \nleosathya(https://github.com/code-423n4/2022-10-paladin-findings/issues/7), \nRaymondFam(https://github.com/code-423n4/2022-10-paladin-findings/issues/3), and \nMathieu(https://github.com/code-423n4/2022-10-paladin-findings/issues/2).*\n\n\n"
            },
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nFile: /contracts/WardenPledge.sol\n268:        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n"
                ],
                "Type": " Using unchecked blocks to save gas",
                "Description": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn\u2019t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block\nsee resource(https://github.com/ethereum/solidity/issues/10695)\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L268\n\nsolidity\nFile: /contracts/WardenPledge.sol\n268:        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n\n\nThe operation pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount; cannot underflow due to the check on Line 267(https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L267) that ensures that pledgeAvailableRewardAmounts[pledgeId] is greater than rewardAmount before perfoming the arithmetic operation.\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nfunction recoverERC20(address token) external onlyOwner returns(bool) {\n\tif(minAmountRewardToken[token] != 0) revert Errors.CannotRecoverToken();\n\n\tuint256 amount = IERC20(token).balanceOf(address(this));\n\tif(amount == 0) revert Errors.NullValue();\n\tIERC20(token).safeTransfer(owner(), amount);\n\n\treturn true;\n}\n",
                    "//solidity\nif(minAmountRewardToken[token] != 0)\n",
                    "//solidity\nfunction updateRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n",
                    "//solidity\nfunction recoverERC20(address token) external onlyOwner returns(bool) {\n"
                ],
                "Type": " Owner can transfer all ERC20 reward token out using function recoverERC20",
                "Description": "*Submitted by ladboy233(https://github.com/code-423n4/2022-10-paladin-findings/issues/68), also found by yixxas(https://github.com/code-423n4/2022-10-paladin-findings/issues/283), JTJabba(https://github.com/code-423n4/2022-10-paladin-findings/issues/274), rbserver(https://github.com/code-423n4/2022-10-paladin-findings/issues/270), Aymen0909(https://github.com/code-423n4/2022-10-paladin-findings/issues/259), horsefacts(https://github.com/code-423n4/2022-10-paladin-findings/issues/249), minhtrng(https://github.com/code-423n4/2022-10-paladin-findings/issues/247), 0xhunter(https://github.com/code-423n4/2022-10-paladin-findings/issues/242), Trust(https://github.com/code-423n4/2022-10-paladin-findings/issues/236), peritoflores(https://github.com/code-423n4/2022-10-paladin-findings/issues/219), 0xDecorativePineapple(https://github.com/code-423n4/2022-10-paladin-findings/issues/207), Dravee(https://github.com/code-423n4/2022-10-paladin-findings/issues/206), hansfriese(https://github.com/code-423n4/2022-10-paladin-findings/issues/196), imare(https://github.com/code-423n4/2022-10-paladin-findings/issues/179), Jeiwan(https://github.com/code-423n4/2022-10-paladin-findings/issues/162), wagmi(https://github.com/code-423n4/2022-10-paladin-findings/issues/154), 0x52(https://github.com/code-423n4/2022-10-paladin-findings/issues/148), Picodes(https://github.com/code-423n4/2022-10-paladin-findings/issues/130), cryptonue(https://github.com/code-423n4/2022-10-paladin-findings/issues/116), pashov(https://github.com/code-423n4/2022-10-paladin-findings/issues/106), Bnke0x0(https://github.com/code-423n4/2022-10-paladin-findings/issues/84), Lambda(https://github.com/code-423n4/2022-10-paladin-findings/issues/81), Nyx(https://github.com/code-423n4/2022-10-paladin-findings/issues/60), cccz(https://github.com/code-423n4/2022-10-paladin-findings/issues/54), dic0de(https://github.com/code-423n4/2022-10-paladin-findings/issues/44), csanuragjain(https://github.com/code-423n4/2022-10-paladin-findings/issues/29), and rvierdiiev(https://github.com/code-423n4/2022-10-paladin-findings/issues/17)*\n\nThe function recoverERC20 is very privileged. It means to recover any token that is accidently sent to the contract.\n\nsolidity\nfunction recoverERC20(address token) external onlyOwner returns(bool) {\n\tif(minAmountRewardToken[token] != 0) revert Errors.CannotRecoverToken();\n\n\tuint256 amount = IERC20(token).balanceOf(address(this));\n\tif(amount == 0) revert Errors.NullValue();\n\tIERC20(token).safeTransfer(owner(), amount);\n\n\treturn true;\n}\n\n\nHowever, admin / owner can use this function to transfer all the reserved reward tokens, which result in fund loss of the pledge creator and the loss of reward for users that want to delegate the veToken.\n\nAlso, the recovered token is sent to owner directly instead of sending to a recipient address.\n\nThe safeguard\n\nsolidity\nif(minAmountRewardToken[token] != 0)\n\n\ncannot stop owner transferring funds because if the owner is compromised or misbehaves, he can adjust the whitelist easily.\n\n\nThe admin can set minAmountRewardToken[token] to 0 first by calling updateRewardToken:\n\nsolidity\nfunction updateRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n\n\nBy doing this the admin removes the token from the whitelist, then the token can call recoverERC20 to transfer all the token into the owner wallet.\n\nsolidity\nfunction recoverERC20(address token) external onlyOwner returns(bool) {\n\n\n",
                "Repair": "\nWe recommend that the project uses a multisig wallet to safeguard the owner's wallet.\n\nWe can also keep track of the reserved amount for rewarding token and only transfer the remaining amount of token out.\n\nsolidity\n pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n reservedReward[token] += totalRewardAmount;\n\n\nThen we can change the implementation to:\n\nsolidity\nfunction recoverERC20(address token, address recipient) external onlyOwner returns(bool) {\n\n\tuint256 amount = IERC20(token).balanceOf(address(this));\n\tif(amount == 0) revert Errors.NullValue();\n\n\tif(minAmountRewardToken[token] == 0) {\n\t // if it is not whitelisted, we assume it is mistakenly sent, \n\t   // we transfer the token to recipient\n\t IERC20(token).safeTransfer(recipient, amount);\n\t} else {\n\t// revert if the owner over transfer\n\tif(amount   reservedReward[token]) revert rewardReserved();\n\t  IERC20(token).safeTransfer(recipient, amount reservedReward[token]);\n\t}\n\n\treturn true;\n\n}\n\n\nKogaroshi (Paladin) confirmed(https://github.com/code-423n4/2022-10-paladin-findings/issues/17)\n\nKogaroshi (Paladin) commented(https://github.com/code-423n4/2022-10-paladin-findings/issues/68#issuecomment-1296375338):\n  Interesting proposed Mitigation to be noted. \n*\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\n        // Get the missing votes for the given receiver to reach the target votes\n        // We ignore any delegated boost here because they might expire during the Pledge duration\n        // (we can have a future version of this contract using adjusted_balance)\n        vars.votesDifference = targetVotes votingEscrow.balanceOf(receiver);\n\n        vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n        vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(vars.totalRewardAmount  maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(vars.feeAmount  maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);\n",
                    "//solidity\n        // Rewards are set in the Pledge as reward/veToken/sec\n        // To find the total amount of veToken delegated through the whole Boost duration\n        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases\n        // each second of the Boost duration\n        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n        // Then we can calculate the total amount of rewards for this Boost\n        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n\n        if(rewardAmount  pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n"
                ],
                "Type": " Pledge may be out of reward due to the decay in veCRV balance. targetVotes is never reached.",
                "Description": "*Submitted by Chom(https://github.com/code-423n4/2022-10-paladin-findings/issues/91), also found by Jeiwan(https://github.com/code-423n4/2022-10-paladin-findings/issues/167), Picodes(https://github.com/code-423n4/2022-10-paladin-findings/issues/131), and KingNFT(https://github.com/code-423n4/2022-10-paladin-findings/issues/120)*\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L335\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L259-L268\n\n\nPledge may be out of reward due to the decay in veCRV balance. The receiver may lose his reward given to boosters but get nothing in return since her targetVotes is never reached.\n\n\nAccording to Curve documentation at <https://curve.readthedocs.io/dao-vecrv.html\n\n    A user\u2019s veCRV balance decays linearly as the remaining time until the CRV unlock decreases. For example, a balance of 4000 CRV locked for one year provides the same amount of veCRV as 2000 CRV locked for two years, or 1000 CRV locked for four years.\n\nOn creation, targetVotes = 100, balance = 20 - votesDifference = 80 - reward is allocated for 80 votes\n\nsolidity\n        // Get the missing votes for the given receiver to reach the target votes\n        // We ignore any delegated boost here because they might expire during the Pledge duration\n        // (we can have a future version of this contract using adjusted_balance)\n        vars.votesDifference = targetVotes votingEscrow.balanceOf(receiver);\n\n        vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n        vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(vars.totalRewardAmount  maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(vars.feeAmount  maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);\n\n\nThen 1 week passed, receiver's balance decay to 10\n\nOn creation, targetVotes = 100, balance = 10 but votesDifference stays 80, and reward has only allocated for 80 votes.\n\nsolidity\n        // Rewards are set in the Pledge as reward/veToken/sec\n        // To find the total amount of veToken delegated through the whole Boost duration\n        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases\n        // each second of the Boost duration\n        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n        // Then we can calculate the total amount of rewards for this Boost\n        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n\n        if(rewardAmount  pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n\n\nA booster boosts 80 votes and takes all rewards in the pool. However, only 80 (From booster) + 10 (From receiver) = 90 votes is active. Not 100 votes that receiver promise in the targetVotes.\n\nThen, if another booster tries to boost 10 votes, it will be reverted with RewardsBalanceTooLow since the first booster has taken all reward that is allocated for only 80 votes.\n\n",
                "Repair": "\nYou should provide a way for the creator to provide additional rewards after the pledge creation. Or provide some reward refreshment function that recalculates votesDifference and transfers the required additional reward.\n\nKogaroshi (Paladin) confirmed, resolved, and commented(https://github.com/code-423n4/2022-10-paladin-findings/issues/91#issuecomment-1301494542):\n  Changed the logic in PR 2(https://github.com/PaladinFinance/Warden-v2/pull/2), commit(https://github.com/PaladinFinance/Warden-v2/pull/2/commits/edc9b0280bbb4144d3983642eeab9db17499e9f6)\n Now the whole amount of votes needed for each second of the Pledge duration is calculated, taking in account the receiver potential veCRV balance, and the veCRV decay.\n \n This should allow to add only the exact amount of reward needed to the Pledge reward pool, and have always the correct amount of rewards to achieve the vote target of the Pledge at all times.\n\nKogaroshi (Paladin) commented(https://github.com/code-423n4/2022-10-paladin-findings/issues/91#issuecomment-1301495120):\n  If possible, a feedback on the new calculation and logic would be appreciated.\n\n*\n\n\n"
            },
            {
                "Name": "",
                "Location": [
                    "\n    owner param should be validated to make sure the owner address is not address(0).\n    Otherwise if not given the right input all only owner accessible functions will be unaccessible.\n    \n    \n"
                ],
                "Type": " Not verified owner",
                "Description": "\n\n    owner param should be validated to make sure the owner address is not address(0).\n    Otherwise if not given the right input all only owner accessible functions will be unaccessible.\n    \n    \n\n\n\n        Ownable.sol.transferOwnership newOwner\n\n\n",
                "Repair": ""
            },
            {
                "Name": "0",
                "Location": [
                    "\n    The following functions are missing commenting as describe below:\n    \n"
                ],
                "Type": " Missing commenting",
                "Description": "\n\n    The following functions are missing commenting as describe below:\n    \n\n\n\n        Pausable.sol, paused (public), @return is missing\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: /contracts/WardenPledge.sol\n60:    IVotingEscrow public votingEscrow;\n",
                    "//solidity\nFile: /contracts/WardenPledge.sol\n62:    IBoostV2 public delegationBoost;\n"
                ],
                "Type": " Using immutable on variables that are only set in the constructor and never after",
                "Description": "\nUse immutable if you want to assign a permanent value at construction. Use constants if you already know the permanent value. Both get directly embedded in bytecode, saving SLOAD.\nVariables only set in the constructor and never edited afterwards should be marked as immutable, as it would avoid the expensive storage-writing operation in the constructor (around 20 000 gas per variable) and replace the expensive storage-reading operations (around 2100 gas per reading) to a less expensive value reading (3 gas)\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L60\n\nsolidity\nFile: /contracts/WardenPledge.sol\n60:    IVotingEscrow public votingEscrow;\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L62\n\nsolidity\nFile: /contracts/WardenPledge.sol\n62:    IBoostV2 public delegationBoost;\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: /contracts/WardenPledge.sol\n79:    uint256 public minDelegationTime = 1 weeks;\n",
                    "diff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..642a848 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -76,7 +76,7 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     uint256 public minTargetVotes;\n\n     / @notice Minimum delegation time, taken from veBoost contract */\n   uint256 public minDelegationTime = 1 weeks;\n+    uint256 public constant minDelegationTime = 1 weeks;\n\n"
                ],
                "Type": " Use constants for variables whose value is known beforehand and is never changed",
                "Description": "\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L79\n\nsolidity\nFile: /contracts/WardenPledge.sol\n79:    uint256 public minDelegationTime = 1 weeks;\n\n\ndiff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..642a848 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -76,7 +76,7 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     uint256 public minTargetVotes;\n\n     / @notice Minimum delegation time, taken from veBoost contract */\n   uint256 public minDelegationTime = 1 weeks;\n+    uint256 public constant minDelegationTime = 1 weeks;\n\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: /contracts/WardenPledge.sol\n222:    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n\n240:        delegationBoost.checkpoint_user(user); //@audit: 1st SLOAD\n241:        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance(); //@audit: 2nd SLOAD\n242:        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate(); //@audit: 3rd SLOAD\n\n245:        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow(); //@audit: 4th SLOAD\n\n248:        delegationBoost.boost( //@audit: 5th SLOAD\n            pledgeParams.receiver,\n            amount,\n            endTimestamp,\n            user\n        );\n\n",
                    "diff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..5b3d1bd 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -237,15 +237,16 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n         uint256 boostDuration = endTimestamp block.timestamp;\n\n         // Check that the user has enough boost delegation available & set the correct allowance to this contract\n       delegationBoost.checkpoint_user(user);\n       if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n       if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n+         IBoostV2 _delegationBoost = delegationBoost;\n+        _delegationBoost.checkpoint_user(user);\n+        if(_delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n+        if(_delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n\n         // Check that this will not go over the Pledge target of votes\n       if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n+        if(_delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n\n         // Creates the DelegationBoost\n       delegationBoost.boost(\n+        _delegationBoost.boost(\n             pledgeParams.receiver,\n             amount,\n             endTimestamp,\n",
                    "//solidity\nFile: /contracts/WardenPledge.sol\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n\n\n267:        if(rewardAmount  pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow(); //@audit: 1st access\n268:        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount; //@audit: 2nd access\n",
                    "diff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..2bb2cd2 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -263,9 +263,10 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n         uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n         // Then we can calculate the total amount of rewards for this Boost\n         uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n+        uint _pledgeAvailableRewardAmounts = pledgeAvailableRewardAmounts[pledgeId];\n\n       if(rewardAmount  pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n       pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n+        if(rewardAmount  _pledgeAvailableRewardAmounts) revert Errors.RewardsBalanceTooLow();\n+        pledgeAvailableRewardAmounts[pledgeId] = _pledgeAvailableRewardAmounts rewardAmount;\n\n         // Send the rewards to the user\n         IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);\n",
                    "//solidity\nFile: /contracts/WardenPledge.sol\n299:    function createPledge(\n\n312:        if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted(); //@audit: 1st access\n313:        if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow(); //@audit: 2nd access\n",
                    "diff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..247e5f8 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -309,8 +309,9 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n\n         if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress();\n         if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin();\n       if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();\n       if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow();\n+        uint256 _minAmountRewardToken = minAmountRewardToken[rewardToken]\n+        if(_minAmountRewardToken == 0) revert Errors.TokenNotWhitelisted();\n+        if(rewardPerVote < _minAmountRewardToken) revert Errors.RewardPerVoteTooLow();\n\n         if(endTimestamp == 0) revert Errors.NullEndTimestamp();\n         if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n"
                ],
                "Type": " Cache storage values in memory to minimize SLOADs",
                "Description": "\nThe code can be optimized by minimizing the number of SLOADs.\n\nSLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.\n\nNB: *Some functions have been truncated where neccessary to just show affected parts of the code*\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L222-L274\n\n\nsolidity\nFile: /contracts/WardenPledge.sol\n222:    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n\n240:        delegationBoost.checkpoint_user(user); //@audit: 1st SLOAD\n241:        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance(); //@audit: 2nd SLOAD\n242:        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate(); //@audit: 3rd SLOAD\n\n245:        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow(); //@audit: 4th SLOAD\n\n248:        delegationBoost.boost( //@audit: 5th SLOAD\n            pledgeParams.receiver,\n            amount,\n            endTimestamp,\n            user\n        );\n\n\n\ndiff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..5b3d1bd 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -237,15 +237,16 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n         uint256 boostDuration = endTimestamp block.timestamp;\n\n         // Check that the user has enough boost delegation available & set the correct allowance to this contract\n       delegationBoost.checkpoint_user(user);\n       if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n       if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n+         IBoostV2 _delegationBoost = delegationBoost;\n+        _delegationBoost.checkpoint_user(user);\n+        if(_delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n+        if(_delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n\n         // Check that this will not go over the Pledge target of votes\n       if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n+        if(_delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount  pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n\n         // Creates the DelegationBoost\n       delegationBoost.boost(\n+        _delegationBoost.boost(\n             pledgeParams.receiver,\n             amount,\n             endTimestamp,\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L222-L274\n\n\nsolidity\nFile: /contracts/WardenPledge.sol\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n\n\n267:        if(rewardAmount  pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow(); //@audit: 1st access\n268:        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount; //@audit: 2nd access\n\n\ndiff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..2bb2cd2 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -263,9 +263,10 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n         uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n         // Then we can calculate the total amount of rewards for this Boost\n         uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n+        uint _pledgeAvailableRewardAmounts = pledgeAvailableRewardAmounts[pledgeId];\n\n       if(rewardAmount  pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n       pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n+        if(rewardAmount  _pledgeAvailableRewardAmounts) revert Errors.RewardsBalanceTooLow();\n+        pledgeAvailableRewardAmounts[pledgeId] = _pledgeAvailableRewardAmounts rewardAmount;\n\n         // Send the rewards to the user\n         IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L299-L358\n\n\nsolidity\nFile: /contracts/WardenPledge.sol\n299:    function createPledge(\n\n312:        if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted(); //@audit: 1st access\n313:        if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow(); //@audit: 2nd access\n\n\ndiff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..247e5f8 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -309,8 +309,9 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n\n         if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress();\n         if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin();\n       if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();\n       if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow();\n+        uint256 _minAmountRewardToken = minAmountRewardToken[rewardToken]\n+        if(_minAmountRewardToken == 0) revert Errors.TokenNotWhitelisted();\n+        if(rewardPerVote < _minAmountRewardToken) revert Errors.RewardPerVoteTooLow();\n\n         if(endTimestamp == 0) revert Errors.NullEndTimestamp();\n         if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: /contracts/WardenPledge.sol\n227:        Pledge memory pledgeParams = pledges[pledgeId];\n"
                ],
                "Type": " Using storage instead of memory for structs/arrays saves gas",
                "Description": "\nWhen fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read. Instead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a memory variable, is if the full struct/array is being returned by the function, is being passed to a function that requires memory, or if the array/struct is being read from another memory array/struct\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L227\n\nsolidity\nFile: /contracts/WardenPledge.sol\n227:        Pledge memory pledgeParams = pledges[pledgeId];\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./oz/interfaces/IERC20.sol\";\nimport \"./oz/libraries/SafeERC20.sol\";\nimport \"./utils/Owner.sol\";\nimport \"./oz/utils/Pausable.sol\";\nimport \"./oz/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IBoostV2.sol\";\nimport \"./utils/Errors.sol\";\n\n/** @title Warden Pledge contract */\n/// @author Paladin\n/*\n    Delegation market (Pledge version) based on Curve Boost V2 contract\n*/\ncontract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Constants :\n    uint256 public constant UNIT = 1e18;\n    uint256 public constant MAX_PCT = 10000;\n    uint256 public constant WEEK = 7 * 86400;\n\n    // Storage :\n\n    struct Pledge{\n        // Target amount of veCRV (balance scaled by Boost v2, fetched as adjusted_balance)\n        uint256 targetVotes;\n        // Difference of votes between the target and the receiver balance at the start of the Pledge\n        // (used for later extend/increase of some parameters the Pledge)\n        uint256 votesDifference;\n        // Price per vote per second, set by the owner\n        uint256 rewardPerVote;\n        // Address to receive the Boosts\n        address receiver;\n        // Address of the token given as rewards to Boosters\n        address rewardToken;\n        // Timestamp of end of the Pledge\n        uint64 endTimestamp;\n        // Set to true if the Pledge is canceled, or when closed after the endTimestamp\n        bool closed;\n    }\n\n    /** @notice List of all Pledges */\n    Pledge[] public pledges;\n\n    /** @notice Owner of each Pledge (ordered by index in the pledges list) */\n    mapping(uint256 => address) public pledgeOwner;\n    /** @notice List of all Pledges for each owner */\n    mapping(address => uint256[]) public ownerPledges;\n\n    /** @notice Amount of rewards available for each Pledge */\n    // sorted by Pledge index\n    mapping(uint256 => uint256) public pledgeAvailableRewardAmounts;\n\n\n    /** @notice Address of the votingToken to delegate */\n    IVotingEscrow public votingEscrow;\n    /** @notice Address of the Delegation Boost contract */\n    IBoostV2 public delegationBoost;\n\n\n    /** @notice Minimum amount of reward per vote for each reward token */\n    // Also used to whitelist the tokens for rewards\n    mapping(address => uint256) public minAmountRewardToken;\n\n\n    /** @notice ratio of fees to pay the protocol (in BPS) */\n    uint256 public protocalFeeRatio = 250; //bps\n    /** @notice Address to receive protocol fees */\n    address public chestAddress;\n\n    /** @notice Minimum target of votes for a Pledge */\n    uint256 public minTargetVotes;\n\n    /** @notice Minimum delegation time, taken from veBoost contract */\n    uint256 public minDelegationTime = 1 weeks;\n\n\n    // Events\n\n    /** @notice Event emitted when xx */\n    event NewPledge(\n        address creator,\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote,\n        uint256 endTimestamp\n    );\n    /** @notice Event emitted when xx */\n    event ExtendPledgeDuration(uint256 indexed pledgeId, uint256 oldEndTimestamp, uint256 newEndTimestamp);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeTargetVotes(uint256 indexed pledgeId, uint256 oldTargetVotes, uint256 newTargetVotes);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeRewardPerVote(uint256 indexed pledgeId, uint256 oldRewardPerVote, uint256 newRewardPerVote);\n    /** @notice Event emitted when xx */\n    event ClosePledge(uint256 indexed pledgeId);\n    /** @notice Event emitted when xx */\n    event RetrievedPledgeRewards(uint256 indexed pledgeId, address receiver, uint256 amount);\n\n    /** @notice Event emitted when xx */\n    event Pledged(uint256 indexed pledgeId, address indexed user, uint256 amount, uint256 endTimestamp);\n\n    /** @notice Event emitted when xx */\n    event NewRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event UpdateRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event RemoveRewardToken(address indexed token);\n\n    /** @notice Event emitted when xx */\n    event ChestUpdated(address oldChest, address newChest);\n    /** @notice Event emitted when xx */\n    event PlatformFeeUpdated(uint256 oldfee, uint256 newFee);\n    /** @notice Event emitted when xx */\n    event MinTargetUpdated(uint256 oldMinTarget, uint256 newMinTargetVotes);\n\n\n\n    // Constructor\n\n    /**\n    * @dev Creates the contract, set the given base parameters\n    * @param _votingEscrow address of the voting token to delegate\n    * @param _delegationBoost address of the contract handling delegation\n    * @param _minTargetVotes min amount of veToken to target in a Pledge\n    */\n    constructor(\n        address _votingEscrow,\n        address _delegationBoost,\n        address _chestAddress,\n        uint256 _minTargetVotes\n    ) {\n        votingEscrow = IVotingEscrow(_votingEscrow);\n        delegationBoost = IBoostV2(_delegationBoost);\n\n        chestAddress = _chestAddress;\n\n        minTargetVotes = _minTargetVotes;\n    }\n\n    \n    // View Methods\n\n    /**\n    * @notice Amount of Pledges listed in this contract\n    * @dev Amount of Pledges listed in this contract\n    * @return uint256: Amount of Pledges listed in this contract\n    */\n    function pledgesIndex() public view returns(uint256){\n        return pledges.length;\n    }\n\n    /**\n    * @notice Get all Pledges created by the user\n    * @dev Get all Pledges created by the user\n    * @param user Address of the user\n    * @return uint256[]: List of Pledges IDs\n    */\n    function getUserPledges(address user) external view returns(uint256[] memory){\n        return ownerPledges[user];\n    }\n\n    /**\n    * @notice Get all the Pledges\n    * @dev Get all the Pledges\n    * @return Pledge[]: List of Pledge structs\n    */\n    function getAllPledges() external view returns(Pledge[] memory){\n        return pledges;\n    }\n\n    /**\n    * @dev Rounds down given timestamp to weekly periods\n    * @param timestamp timestamp to round down\n    * @return uint256: rounded down timestamp\n    */\n    function _getRoundedTimestamp(uint256 timestamp) internal pure returns(uint256) {\n        return (timestamp / WEEK) * WEEK;\n    }\n\n\n    // Pledgers Methods\n\n    /**\n    * @notice Delegates boost to a given Pledge & receive rewards\n    * @dev Delegates boost to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledge(uint256 pledgeId, uint256 amount, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n    }\n\n    /**\n    * @notice Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @dev Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param percent Percent of balance to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledgePercent(uint256 pledgeId, uint256 percent, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        if(percent > MAX_PCT) revert Errors.PercentOverMax();\n\n        uint256 amount = (votingEscrow.balanceOf(msg.sender) * percent) / MAX_PCT;\n\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n        \n    }\n\n    /**\n    * @dev Delegates the boost to the Pledge receiver & sends rewards to the delegator\n    * @param pledgeId Pledge to delegate to\n    * @param user Address of the delegator\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        if(amount == 0) revert Errors.NullValue();\n\n        // Load Pledge parameters & check the Pledge is still active\n        Pledge memory pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // To join until the end of the pledge, user can input 0 as endTimestamp\n        // so it's override by the Pledge's endTimestamp\n        if(endTimestamp == 0) endTimestamp = pledgeParams.endTimestamp;\n        if(endTimestamp > pledgeParams.endTimestamp || endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        // Calculated the effective Pledge duration\n        uint256 boostDuration = endTimestamp - block.timestamp;\n\n        // Check that the user has enough boost delegation available & set the correct allowance to this contract\n        delegationBoost.checkpoint_user(user);\n        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n\n        // Check that this will not go over the Pledge target of votes\n        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n\n        // Creates the DelegationBoost\n        delegationBoost.boost(\n            pledgeParams.receiver,\n            amount,\n            endTimestamp,\n            user\n        );\n\n        // Re-calculate the new Boost bias & slope (using Boostv2 logic)\n        uint256 slope = amount / boostDuration;\n        uint256 bias = slope * boostDuration;\n\n        // Rewards are set in the Pledge as reward/veToken/sec\n        // To find the total amount of veToken delegated through the whole Boost duration\n        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases\n        // each second of the Boost duration\n        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n        // Then we can calculate the total amount of rewards for this Boost\n        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n\n        if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n\n        // Send the rewards to the user\n        IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);\n\n        emit Pledged(pledgeId, user, amount, endTimestamp);\n    }\n\n\n    // Pledge Creators Methods\n\n    struct CreatePledgeVars {\n        uint256 duration;\n        uint256 votesDifference;\n        uint256 totalRewardAmount;\n        uint256 feeAmount;\n        uint256 newPledgeID;\n    }\n\n    /**\n    * @notice Creates a new Pledge\n    * @dev Creates a new Pledge\n    * @param receiver Address to receive the boost delegation\n    * @param rewardToken Address of the token distributed as reward\n    * @param targetVotes Maximum taget of votes to have (own balacne + delegation) for the receiver\n    * @param rewardPerVote Amount of reward given for each vote delegation (per second)\n    * @param endTimestamp End of the Pledge\n    * @param maxTotalRewardAmount Maximum total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum feeamount allowed ot be pulled by this contract\n    * @return uint256: Newly created Pledge ID\n    */\n    function createPledge(\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote, // reward/veToken/second\n        uint256 endTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant returns(uint256){\n        address creator = msg.sender;\n\n        if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress();\n        if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin();\n        if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();\n        if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow();\n\n        if(endTimestamp == 0) revert Errors.NullEndTimestamp();\n        if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        CreatePledgeVars memory vars;\n        vars.duration = endTimestamp - block.timestamp;\n        if(vars.duration < minDelegationTime) revert Errors.DurationTooShort();\n\n        // Get the missing votes for the given receiver to reach the target votes\n        // We ignore any delegated boost here because they might expire during the Pledge duration\n        // (we can have a future version of this contract using adjusted_balance)\n        vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);\n\n        vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n        vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);\n\n        vars.newPledgeID = pledgesIndex();\n\n        // Add the total reards as available for the Pledge & write Pledge parameters in storage\n        pledgeAvailableRewardAmounts[vars.newPledgeID] += vars.totalRewardAmount;\n\n        pledges.push(Pledge(\n            targetVotes,\n            vars.votesDifference,\n            rewardPerVote,\n            receiver,\n            rewardToken,\n            safe64(endTimestamp),\n            false\n        ));\n\n        pledgeOwner[vars.newPledgeID] = creator;\n        ownerPledges[creator].push(vars.newPledgeID);\n\n        emit NewPledge(creator, receiver, rewardToken, targetVotes, rewardPerVote, endTimestamp);\n\n        return vars.newPledgeID;\n    }\n\n    /**\n    * @notice Extends the Pledge duration\n    * @dev Extends the Pledge duration & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newEndTimestamp New end of the Pledge\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function extendPledge(\n        uint256 pledgeId,\n        uint256 newEndTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n        if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();\n        uint256 oldEndTimestamp = pledgeParams.endTimestamp;\n        if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();\n\n        uint256 addedDuration = newEndTimestamp - oldEndTimestamp;\n        if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();\n        uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.endTimestamp = safe64(newEndTimestamp);\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit ExtendPledgeDuration(pledgeId, oldEndTimestamp, newEndTimestamp);\n    }\n\n    /**\n    * @notice Increases the Pledge reward per vote delegated\n    * @dev Increases the Pledge reward per vote delegated & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newRewardPerVote New amount of reward given for each vote delegation (per second)\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function increasePledgeRewardPerVote(\n        uint256 pledgeId,\n        uint256 newRewardPerVote,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        uint256 oldRewardPerVote = pledgeParams.rewardPerVote;\n        if(newRewardPerVote <= oldRewardPerVote) revert Errors.RewardsPerVotesTooLow();\n        uint256 remainingDuration = pledgeParams.endTimestamp - block.timestamp;\n        uint256 rewardPerVoteDiff = newRewardPerVote - oldRewardPerVote;\n        uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.rewardPerVote = newRewardPerVote;\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit IncreasePledgeRewardPerVote(pledgeId, oldRewardPerVote, newRewardPerVote);\n    }\n\n    /**\n    * @notice Retrieves all non distributed rewards from a closed Pledge\n    * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge\n    * @param receiver Address to receive the remaining rewards\n    */\n    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.endTimestamp > block.timestamp) revert Errors.PledgeNotExpired();\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        // Set the Pledge as Closed\n        if(!pledgeParams.closed) pledgeParams.closed = true;\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n    }\n\n    /**\n    * @notice Closes a Pledge and retrieves all non distributed rewards from a Pledge\n    * @dev Closes a Pledge and retrieves all non distributed rewards from a Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge to close\n    * @param receiver Address to receive the remaining rewards\n    */\n    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeAlreadyClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // Set the Pledge as Closed\n        pledgeParams.closed = true;\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n\n        emit ClosePledge(pledgeId);\n    }\n\n\n    // Admin Methods\n\n    /**\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minRewardPerSecond == 0) revert Errors.NullValue();\n        \n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit NewRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param tokens List of token addresses to add\n    * @param minRewardsPerSecond Minmum amount of reward per vote per second for each token in the list\n    */\n    function addMultipleRewardToken(address[] calldata tokens, uint256[] calldata minRewardsPerSecond) external onlyOwner {\n        uint256 length = tokens.length;\n\n        if(length == 0) revert Errors.EmptyArray();\n        if(length != minRewardsPerSecond.length) revert Errors.InequalArraySizes();\n\n        for(uint256 i = 0; i < length;){\n            _addRewardToken(tokens[i], minRewardsPerSecond[i]);\n\n            unchecked{ ++i; }\n        }\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function addRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        _addRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Updates a reward token\n    * @dev Updates a reward token\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function updateRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        if(minRewardPerSecond == 0) revert Errors.InvalidValue();\n\n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit UpdateRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Removes a reward token from the whitelist\n    * @dev Removes a reward token from the whitelist\n    * @param token Address of the token\n    */\n    function removeRewardToken(address token) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        \n        minAmountRewardToken[token] = 0;\n        \n        emit RemoveRewardToken(token);\n    }\n    \n    /**\n    * @notice Updates the Chest address\n    * @dev Updates the Chest address\n    * @param chest Address of the new Chest\n    */\n    function updateChest(address chest) external onlyOwner {\n        if(chest == address(0)) revert Errors.ZeroAddress();\n        address oldChest = chestAddress;\n        chestAddress = chest;\n\n        emit ChestUpdated(oldChest, chest);\n    }\n\n    /**\n    * @notice Updates the new min target of votes for Pledges\n    * @dev Updates the new min target of votes for Pledges\n    * @param newMinTargetVotes New minimum target of votes\n    */\n    function updateMinTargetVotes(uint256 newMinTargetVotes) external onlyOwner {\n        if(newMinTargetVotes == 0) revert Errors.InvalidValue();\n        uint256 oldMinTarget = minTargetVotes;\n        minTargetVotes = newMinTargetVotes;\n\n        emit MinTargetUpdated(oldMinTarget, newMinTargetVotes);\n    }\n\n    /**\n    * @notice Updates the Platfrom fees BPS ratio\n    * @dev Updates the Platfrom fees BPS ratio\n    * @param newFee New fee ratio\n    */\n    function updatePlatformFee(uint256 newFee) external onlyOwner {\n        if(newFee > 500) revert Errors.InvalidValue();\n        uint256 oldfee = protocalFeeRatio;\n        protocalFeeRatio = newFee;\n\n        emit PlatformFeeUpdated(oldfee, newFee);\n    }\n\n    /**\n     * @notice Pauses the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n    * @notice Recovers ERC2O tokens sent by mistake to the contract\n    * @dev Recovers ERC2O tokens sent by mistake to the contract\n    * @param token Address tof the EC2O token\n    * @return bool: success\n    */\n    function recoverERC20(address token) external onlyOwner returns(bool) {\n        if(minAmountRewardToken[token] != 0) revert Errors.CannotRecoverToken();\n\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        if(amount == 0) revert Errors.NullValue();\n        IERC20(token).safeTransfer(owner(), amount);\n\n        return true;\n    }\n\n    // Utils \n\n    function safe64(uint256 n) internal pure returns (uint64) {\n        if(n > type(uint64).max) revert Errors.NumberExceed64Bits();\n        return uint64(n);\n    }\n\n\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n",
        "CodeNames": [
            "WardenPledge.sol",
            "SafeERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: /contracts/WardenPledge.sol\n222:    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n223:        if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n224:        if(amount == 0) revert Errors.NullValue();\n",
                    "diff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..dfd3ff4 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -220,8 +220,9 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     * @param endTimestamp End of delegation\n     */\n     function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n       if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n         if(amount == 0) revert Errors.NullValue();\n+        if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n\n         // Load Pledge parameters & check the Pledge is still active\n         Pledge memory pledgeParams = pledges[pledgeId];\n",
                    "//solidity\nFile: /contracts/WardenPledge.sol\n456:    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n457:        if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n458:        address creator = pledgeOwner[pledgeId];\n459:        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n460:        if(receiver == address(0)) revert Errors.ZeroAddress();\n",
                    "diff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..9c82ad9 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -454,10 +454,11 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     * @param receiver Address to receive the remaining rewards\n     */\n     function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n+        if(receiver == address(0)) revert Errors.ZeroAddress();\n         if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n         address creator = pledgeOwner[pledgeId];\n         if(msg.sender != creator) revert Errors.NotPledgeCreator();\n       if(receiver == address(0)) revert Errors.ZeroAddress();\n+\n\n         Pledge storage pledgeParams = pledges[pledgeId];\n         if(pledgeParams.endTimestamp  block.timestamp) revert Errors.PledgeNotExpired();\n",
                    "//solidity\nFile: /contracts/WardenPledge.sol\n488:    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n489:        if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n490:        address creator = pledgeOwner[pledgeId];\n491:        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n492:        if(receiver == address(0)) revert Errors.ZeroAddress();\n",
                    "diff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..c06f2ee 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -486,10 +486,11 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     * @param receiver Address to receive the remaining rewards\n     */\n     function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n+        if(receiver == address(0)) revert Errors.ZeroAddress();\n         if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n         address creator = pledgeOwner[pledgeId];\n         if(msg.sender != creator) revert Errors.NotPledgeCreator();\n       if(receiver == address(0)) revert Errors.ZeroAddress();\n",
                    "//solidity\nFile: /contracts/WardenPledge.sol\n525:    function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n526:        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n527:        if(token == address(0)) revert Errors.ZeroAddress();\n528:        if(minRewardPerSecond == 0) revert Errors.NullValue();\n",
                    "diff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..71d0087 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -523,10 +523,10 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n     */\n     function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n       if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n         if(token == address(0)) revert Errors.ZeroAddress();\n         if(minRewardPerSecond == 0) revert Errors.NullValue();\n\n+        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n+\n         minAmountRewardToken[token] = minRewardPerSecond;\n\n         emit NewRewardToken(token, minRewardPerSecond);\n"
                ],
                "Type": "  require()  or  revert()  statements that check input arguments should be at the top of the function",
                "Description": "\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (2100 gas) in a function that may ultimately revert in the unhappy case.\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L222-L274\n\nsolidity\nFile: /contracts/WardenPledge.sol\n222:    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n223:        if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n224:        if(amount == 0) revert Errors.NullValue();\n\n\ndiff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..dfd3ff4 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -220,8 +220,9 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     * @param endTimestamp End of delegation\n     */\n     function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n       if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n         if(amount == 0) revert Errors.NullValue();\n+        if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n\n         // Load Pledge parameters & check the Pledge is still active\n         Pledge memory pledgeParams = pledges[pledgeId];\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L456-L480\n\nsolidity\nFile: /contracts/WardenPledge.sol\n456:    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n457:        if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n458:        address creator = pledgeOwner[pledgeId];\n459:        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n460:        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n\ndiff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..9c82ad9 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -454,10 +454,11 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     * @param receiver Address to receive the remaining rewards\n     */\n     function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n+        if(receiver == address(0)) revert Errors.ZeroAddress();\n         if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n         address creator = pledgeOwner[pledgeId];\n         if(msg.sender != creator) revert Errors.NotPledgeCreator();\n       if(receiver == address(0)) revert Errors.ZeroAddress();\n+\n\n         Pledge storage pledgeParams = pledges[pledgeId];\n         if(pledgeParams.endTimestamp  block.timestamp) revert Errors.PledgeNotExpired();\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L488-L515\n\nsolidity\nFile: /contracts/WardenPledge.sol\n488:    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n489:        if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n490:        address creator = pledgeOwner[pledgeId];\n491:        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n492:        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n\ndiff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..c06f2ee 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -486,10 +486,11 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     * @param receiver Address to receive the remaining rewards\n     */\n     function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n+        if(receiver == address(0)) revert Errors.ZeroAddress();\n         if(pledgeId = pledgesIndex()) revert Errors.InvalidPledgeID();\n         address creator = pledgeOwner[pledgeId];\n         if(msg.sender != creator) revert Errors.NotPledgeCreator();\n       if(receiver == address(0)) revert Errors.ZeroAddress();\n\n\n<https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L525-L533\n\nsolidity\nFile: /contracts/WardenPledge.sol\n525:    function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n526:        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n527:        if(token == address(0)) revert Errors.ZeroAddress();\n528:        if(minRewardPerSecond == 0) revert Errors.NullValue();\n\n\ndiff\ndiff --git a/contracts/WardenPledge.sol b/contracts/WardenPledge.sol\nindex beb990d..71d0087 100644\n--a/contracts/WardenPledge.sol\n+++ b/contracts/WardenPledge.sol\n@@ -523,10 +523,10 @@ contract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n     * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n     */\n     function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n       if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n         if(token == address(0)) revert Errors.ZeroAddress();\n         if(minRewardPerSecond == 0) revert Errors.NullValue();\n\n+        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n+\n         minAmountRewardToken[token] = minRewardPerSecond;\n\n         emit NewRewardToken(token, minRewardPerSecond);\n\n\n\n",
                "Repair": ""
            }
        ]
    }
]