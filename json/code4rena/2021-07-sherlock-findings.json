[
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\npragma abicoder v2;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '../interfaces/IManager.sol';\n\nimport '../libraries/LibSherX.sol';\nimport '../libraries/LibPool.sol';\n\ncontract Manager is IManager {\n  using SafeMath for uint256;\n\n  // Once transaction has been mined, protocol is officialy insured.\n\n  //\n  // Modifiers\n  //\n\n  modifier onlyGovMain() {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    _;\n  }\n\n  // Validates if token is eligble for premium payments\n  function onlyValidToken(PoolStorage.Base storage ps, IERC20 _token) private view {\n    require(address(_token) != address(this), 'SHERX');\n    require(ps.premiums, 'WHITELIST');\n  }\n\n  //\n  // State changing methods\n  //\n\n  function setTokenPrice(IERC20 _token, uint256 _newUsd) external override onlyGovMain {\n    LibPool.payOffDebtAll(_token);\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n    (usdPerBlock, usdPool) = _setTokenPrice(_token, _newUsd, usdPerBlock, usdPool);\n    _setData(usdPerBlock, usdPool);\n  }\n\n  function setTokenPrice(IERC20[] memory _token, uint256[] memory _newUsd)\n    external\n    override\n    onlyGovMain\n  {\n    require(_token.length == _newUsd.length, 'LENGTH');\n\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n    for (uint256 i; i < _token.length; i++) {\n      LibPool.payOffDebtAll(_token[i]);\n      (usdPerBlock, usdPool) = _setTokenPrice(_token[i], _newUsd[i], usdPerBlock, usdPool);\n    }\n    _setData(usdPerBlock, usdPool);\n  }\n\n  function setProtocolPremium(\n    bytes32 _protocol,\n    IERC20 _token,\n    uint256 _premium\n  ) external override onlyGovMain {\n    LibPool.payOffDebtAll(_token);\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n    (usdPerBlock, usdPool) = _setProtocolPremium(_protocol, _token, _premium, usdPerBlock, usdPool);\n    _setData(usdPerBlock, usdPool);\n  }\n\n  function setProtocolPremium(\n    bytes32 _protocol,\n    IERC20[] memory _token,\n    uint256[] memory _premium\n  ) external override onlyGovMain {\n    require(_token.length == _premium.length, 'LENGTH');\n\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n\n    for (uint256 i; i < _token.length; i++) {\n      LibPool.payOffDebtAll(_token[i]);\n      (usdPerBlock, usdPool) = _setProtocolPremium(\n        _protocol,\n        _token[i],\n        _premium[i],\n        usdPerBlock,\n        usdPool\n      );\n    }\n    _setData(usdPerBlock, usdPool);\n  }\n\n  function setProtocolPremium(\n    bytes32[] memory _protocol,\n    IERC20[][] memory _token,\n    uint256[][] memory _premium\n  ) external override onlyGovMain {\n    require(_protocol.length == _token.length, 'LENGTH_1');\n    require(_protocol.length == _premium.length, 'LENGTH_2');\n\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n\n    for (uint256 i; i < _protocol.length; i++) {\n      require(_token[i].length == _premium[i].length, 'LENGTH_3');\n      for (uint256 j; j < _token[i].length; j++) {\n        LibPool.payOffDebtAll(_token[i][j]);\n        (usdPerBlock, usdPool) = _setProtocolPremium(\n          _protocol[i],\n          _token[i][j],\n          _premium[i][j],\n          usdPerBlock,\n          usdPool\n        );\n      }\n    }\n    _setData(usdPerBlock, usdPool);\n  }\n\n  function setProtocolPremiumAndTokenPrice(\n    bytes32 _protocol,\n    IERC20 _token,\n    uint256 _premium,\n    uint256 _newUsd\n  ) external override onlyGovMain {\n    LibPool.payOffDebtAll(_token);\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n\n    (usdPerBlock, usdPool) = _setProtocolPremiumAndTokenPrice(\n      _protocol,\n      _token,\n      _premium,\n      _newUsd,\n      usdPerBlock,\n      usdPool\n    );\n    _setData(usdPerBlock, usdPool);\n  }\n\n  function setProtocolPremiumAndTokenPrice(\n    bytes32 _protocol,\n    IERC20[] memory _token,\n    uint256[] memory _premium,\n    uint256[] memory _newUsd\n  ) external override onlyGovMain {\n    require(_token.length == _premium.length, 'LENGTH_1');\n    require(_token.length == _newUsd.length, 'LENGTH_2');\n\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n\n    for (uint256 i; i < _token.length; i++) {\n      LibPool.payOffDebtAll(_token[i]);\n      (usdPerBlock, usdPool) = _setProtocolPremiumAndTokenPrice(\n        _protocol,\n        _token[i],\n        _premium[i],\n        _newUsd[i],\n        usdPerBlock,\n        usdPool\n      );\n    }\n    _setData(usdPerBlock, usdPool);\n  }\n\n  function setProtocolPremiumAndTokenPrice(\n    bytes32[] memory _protocol,\n    IERC20 _token,\n    uint256[] memory _premium,\n    uint256 _newUsd\n  ) external override onlyGovMain {\n    require(_protocol.length == _premium.length, 'LENGTH');\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    onlyValidToken(ps, _token);\n    LibPool.payOffDebtAll(_token);\n\n    uint256 oldPremium = ps.totalPremiumPerBlock;\n    uint256 newPremium = oldPremium;\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n\n    uint256 oldUsd = _setTokenPrice(_token, _newUsd);\n\n    for (uint256 i; i < _protocol.length; i++) {\n      require(ps.isProtocol[_protocol[i]], 'NON_PROTOCOL');\n      // This calculation mimicks the logic in `_setProtocolPremium() private`\n      // But only write `newPremium` to storage once\n      newPremium = newPremium.sub(ps.protocolPremium[_protocol[i]]).add(_premium[i]);\n      ps.protocolPremium[_protocol[i]] = _premium[i];\n    }\n    ps.totalPremiumPerBlock = newPremium;\n    (usdPerBlock, usdPool) = _updateData(\n      ps,\n      usdPerBlock,\n      usdPool,\n      oldPremium,\n      newPremium,\n      oldUsd,\n      _newUsd\n    );\n    _setData(usdPerBlock, usdPool);\n  }\n\n  function setProtocolPremiumAndTokenPrice(\n    bytes32[] memory _protocol,\n    IERC20[][] memory _token,\n    uint256[][] memory _premium,\n    uint256[][] memory _newUsd\n  ) external override onlyGovMain {\n    (uint256 usdPerBlock, uint256 usdPool) = _getData();\n    require(_protocol.length == _token.length, 'LENGTH_1');\n    require(_protocol.length == _premium.length, 'LENGTH_2');\n    require(_protocol.length == _newUsd.length, 'LENGTH_3');\n\n    for (uint256 i; i < _protocol.length; i++) {\n      require(_token[i].length == _premium[i].length, 'LENGTH_4');\n      require(_token[i].length == _newUsd[i].length, 'LENGTH_5');\n      for (uint256 j; j < _token[i].length; j++) {\n        LibPool.payOffDebtAll(_token[i][j]);\n        (usdPerBlock, usdPool) = _setProtocolPremiumAndTokenPrice(\n          _protocol[i],\n          _token[i][j],\n          _premium[i][j],\n          _newUsd[i][j],\n          usdPerBlock,\n          usdPool\n        );\n      }\n    }\n    _setData(usdPerBlock, usdPool);\n  }\n\n  /// @notice Update internal (storage) USD price of `_token` with `_newUsd` and return updated memory variables\n  /// @param _token Token address\n  /// @param _newUsd USD amount\n  /// @param usdPerBlock The sum of internal USD that protocols pay as premium\n  /// @param usdPool The sum of all premiums paid that are still in the pool, multiplied by the internal USD value\n  /// @return Updated usdPerBlock based on `_newUsd`\n  /// @return Updated usdPool based on `_newUsd`\n  function _setTokenPrice(\n    IERC20 _token,\n    uint256 _newUsd,\n    uint256 usdPerBlock,\n    uint256 usdPool\n  ) private returns (uint256, uint256) {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    onlyValidToken(ps, _token);\n\n    uint256 oldUsd = _setTokenPrice(_token, _newUsd);\n    uint256 premium = ps.totalPremiumPerBlock;\n    (usdPerBlock, usdPool) = _updateData(\n      ps,\n      usdPerBlock,\n      usdPool,\n      premium,\n      premium,\n      oldUsd,\n      _newUsd\n    );\n    return (usdPerBlock, usdPool);\n  }\n\n  /// @notice Update internal (storage) USD price of `_token` with `_newUsd`\n  /// @param _token Token address\n  /// @param _newUsd USD amount\n  /// @return oldUsd The previous usd amount that was stored\n  function _setTokenPrice(IERC20 _token, uint256 _newUsd) private returns (uint256 oldUsd) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n\n    oldUsd = sx.tokenUSD[_token];\n    // used for setProtocolPremiumAndTokenPrice, if same token prices are updated\n    if (oldUsd != _newUsd) {\n      sx.tokenUSD[_token] = _newUsd;\n    }\n  }\n\n  /// @notice Update premium of `_protocol` using `_token` with `_premium` and return updated memory variables\n  /// @param _protocol Protocol identifier\n  /// @param _token Token address\n  /// @param _premium The new premium per block\n  /// @param usdPerBlock The sum of internal USD that protocols pay as premium\n  /// @param usdPool The sum of all premiums paid that are still in the pool, multiplied by the internal USD value\n  /// @return Updated usdPerBlock based on `_premium`\n  /// @return Updated usdPool based on `_premium`\n  function _setProtocolPremium(\n    bytes32 _protocol,\n    IERC20 _token,\n    uint256 _premium,\n    uint256 usdPerBlock,\n    uint256 usdPool\n  ) private returns (uint256, uint256) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    onlyValidToken(ps, _token);\n\n    (uint256 oldPremium, uint256 newPremium) = _setProtocolPremium(ps, _protocol, _premium);\n\n    uint256 usd = sx.tokenUSD[_token];\n    (usdPerBlock, usdPool) = _updateData(\n      ps,\n      usdPerBlock,\n      usdPool,\n      oldPremium,\n      newPremium,\n      usd,\n      usd\n    );\n    return (usdPerBlock, usdPool);\n  }\n\n  /// @notice Update premium of `_protocol` with `_premium` using pool storage `ps` and return old and new total premium per block\n  /// @param ps Pointer to pool storage based on token address\n  /// @param _protocol Protocol identifier\n  /// @param _premium The new premium per block\n  /// @return oldPremium Previous sum of premiums being paid in the used token\n  /// @return newPremium Updated sum of premiums being paid in the used token\n  function _setProtocolPremium(\n    PoolStorage.Base storage ps,\n    bytes32 _protocol,\n    uint256 _premium\n  ) private returns (uint256 oldPremium, uint256 newPremium) {\n    require(ps.isProtocol[_protocol], 'NON_PROTOCOL');\n\n    oldPremium = ps.totalPremiumPerBlock;\n    // to calculate the new totalPremiumPerBlock\n    // - subtract the original premium the protocol paid.\n    // - add the new premium the protocol is about to pay.\n    newPremium = oldPremium.sub(ps.protocolPremium[_protocol]).add(_premium);\n\n    ps.totalPremiumPerBlock = newPremium;\n    // Actually register the new premium for the protocol\n    ps.protocolPremium[_protocol] = _premium;\n  }\n\n  /// @notice Update premium of `_protocol` using `_token` with `_premium` + update `_token` USD value with `_newUsd` and returns updated memory variables\n  /// @param _protocol Protocol identifier\n  /// @param _token Token address\n  /// @param _premium The new premium per block\n  /// @param _newUsd USD amount\n  /// @param usdPerBlock The sum of internal USD that protocols pay as premium\n  /// @param usdPool The sum of all premiums paid that are still in the pool, multiplied by the internal USD value\n  /// @return Updated usdPerBlock based on `_premium`\n  /// @return Updated usdPool based on `_premium`\n  function _setProtocolPremiumAndTokenPrice(\n    bytes32 _protocol,\n    IERC20 _token,\n    uint256 _premium,\n    uint256 _newUsd,\n    uint256 usdPerBlock,\n    uint256 usdPool\n  ) private returns (uint256, uint256) {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    onlyValidToken(ps, _token);\n\n    uint256 oldUsd = _setTokenPrice(_token, _newUsd);\n    (uint256 oldPremium, uint256 newPremium) = _setProtocolPremium(ps, _protocol, _premium);\n    (usdPerBlock, usdPool) = _updateData(\n      ps,\n      usdPerBlock,\n      usdPool,\n      oldPremium,\n      newPremium,\n      oldUsd,\n      _newUsd\n    );\n    return (usdPerBlock, usdPool);\n  }\n\n  /// @notice Read current usdPerBlock and usdPool from storage\n  /// @return usdPerBlock Current usdPerBlock\n  /// @return usdPool Current usdPool\n  function _getData() private view returns (uint256 usdPerBlock, uint256 usdPool) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    usdPerBlock = sx.totalUsdPerBlock;\n    usdPool = LibSherX.viewAccrueUSDPool();\n  }\n\n  /// @notice Update in memory `usdPerBlock` and `usdPool` based on the old/new premiums and prices. Return updated values.\n  /// @param ps Pointer to pool storage based on token address\n  /// @param usdPerBlock Current in memory value of usdPerBlock\n  /// @param usdPool Current in memory value of usdPool\n  /// @param _oldPremium Old sum of premiums paid by protocols using token\n  /// @param _newPremium new sum of premium paid by protocols using token (based on update)\n  /// @param _oldUsd Old stored usd price of token\n  /// @param _newUsd New stored usd price of token (based on update)\n  /// @return Updated usdPerBlock\n  /// @return Updated usdPool\n  function _updateData(\n    PoolStorage.Base storage ps,\n    uint256 usdPerBlock,\n    uint256 usdPool,\n    uint256 _oldPremium,\n    uint256 _newPremium,\n    uint256 _oldUsd,\n    uint256 _newUsd\n  ) private view returns (uint256, uint256) {\n    // `sub` represents the old usdPerBlock for this particulair token\n    // This is calculated using the previous stored `totalPremiumPerBlock` and `tokenUSD`\n    uint256 sub = _oldPremium.mul(_oldUsd);\n    // `add` represents the new usdPerblock for this particulair token\n    // This is calculated using the current in memory value of `_newPremium` and `_newUsd`\n    uint256 add = _newPremium.mul(_newUsd);\n\n    // To make sure the usdPerBlock uint doesn't attempt a potential underflow operation\n    // Changed the order of sub and add's based on if statement\n    // Goal is to subtract the old value `sub` and add the new value `add from `usdPerBlock`\n    if (sub > add) {\n      usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));\n    } else {\n      usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));\n    }\n\n    // In case underyling == 0, the token is not part of the usdPool.\n    if (ps.sherXUnderlying > 0) {\n      // To make sure the usdPool uint doesn't attempt a potential underflow operation\n      // Goal is to update the current usdPool based on the `_newUsd` value\n      // ~ substract `_oldUsd` * `ps.sherXUnderlying`\n      // ~ add `_newUsd` * `ps.sherXUnderlying`\n      // If _newUsd == _oldUsd, nothing changes\n      if (_newUsd > _oldUsd) {\n        usdPool = usdPool.add(_newUsd.sub(_oldUsd).mul(ps.sherXUnderlying).div(10**18));\n      } else if (_newUsd < _oldUsd) {\n        usdPool = usdPool.sub(_oldUsd.sub(_newUsd).mul(ps.sherXUnderlying).div(10**18));\n      }\n    }\n\n    return (usdPerBlock, usdPool);\n  }\n\n  /// @notice Use in memory variables of `usdPerBlock` and `usdPool` and write to storage\n  /// @param usdPerBlock Current in memory value of usdPerBlock\n  /// @param usdPool Current in memory value of usdPool\n  function _setData(uint256 usdPerBlock, uint256 usdPool) private {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n\n    LibSherX.accrueSherX();\n\n    uint256 _currentTotalSupply = sx20.totalSupply;\n\n    if (usdPerBlock > 0 && _currentTotalSupply == 0) {\n      // initial accrue, mint 1 SHERX per block\n      sx.sherXPerBlock = 10**18;\n    } else if (usdPool > 0) {\n      // Calculate new sherXPerBlock based on the updated usdPerBlock and usdPool values\n      sx.sherXPerBlock = _currentTotalSupply.mul(usdPerBlock).div(usdPool);\n    } else {\n      sx.sherXPerBlock = 0;\n    }\n    sx.internalTotalSupply = _currentTotalSupply;\n    sx.internalTotalSupplySettled = block.number;\n\n    sx.totalUsdPerBlock = usdPerBlock;\n    sx.totalUsdPool = usdPool;\n    sx.totalUsdLastSettled = block.number;\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\npragma abicoder v2;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '../interfaces/IPoolBase.sol';\n\nimport '../storage/GovStorage.sol';\n\nimport '../libraries/LibPool.sol';\n\ncontract PoolBase is IPoolBase {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ILock;\n\n  //\n  // View methods\n  //\n\n  function getCooldownFee(IERC20 _token) external view override returns (uint32) {\n    return baseData().activateCooldownFee;\n  }\n\n  function getSherXWeight(IERC20 _token) external view override returns (uint16) {\n    return baseData().sherXWeight;\n  }\n\n  function getGovPool(IERC20 _token) external view override returns (address) {\n    return baseData().govPool;\n  }\n\n  function isPremium(IERC20 _token) external view override returns (bool) {\n    return baseData().premiums;\n  }\n\n  function isStake(IERC20 _token) external view override returns (bool) {\n    return baseData().stakes;\n  }\n\n  function getProtocolBalance(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().protocolBalance[_protocol];\n  }\n\n  function getProtocolPremium(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().protocolPremium[_protocol];\n  }\n\n  function getLockToken(IERC20 _token) external view override returns (ILock) {\n    return baseData().lockToken;\n  }\n\n  function isProtocol(bytes32 _protocol, IERC20 _token) external view override returns (bool) {\n    return baseData().isProtocol[_protocol];\n  }\n\n  function getProtocols(IERC20 _token) external view override returns (bytes32[] memory) {\n    return baseData().protocols;\n  }\n\n  function getUnstakeEntry(\n    address _staker,\n    uint256 _id,\n    IERC20 _token\n  ) external view override returns (PoolStorage.UnstakeEntry memory) {\n    return baseData().unstakeEntries[_staker][_id];\n  }\n\n  function getTotalAccruedDebt(IERC20 _token) external view override returns (uint256) {\n    baseData();\n    return LibPool.getTotalAccruedDebt(_token);\n  }\n\n  function getFirstMoneyOut(IERC20 _token) external view override returns (uint256) {\n    return baseData().firstMoneyOut;\n  }\n\n  function getAccruedDebt(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    baseData();\n    return LibPool.accruedDebt(_protocol, _token);\n  }\n\n  function getTotalPremiumPerBlock(IERC20 _token) external view override returns (uint256) {\n    return baseData().totalPremiumPerBlock;\n  }\n\n  function getPremiumLastPaid(IERC20 _token) external view override returns (uint40) {\n    return baseData().totalPremiumLastPaid;\n  }\n\n  function getSherXUnderlying(IERC20 _token) external view override returns (uint256) {\n    return baseData().sherXUnderlying;\n  }\n\n  function getUnstakeEntrySize(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().unstakeEntries[_staker].length;\n  }\n\n  function getInitialUnstakeEntry(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) {\n      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) {\n        continue;\n      }\n      if (\n        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=\n        uint40(block.number)\n      ) {\n        continue;\n      }\n      return i;\n    }\n    return ps.unstakeEntries[_staker].length;\n  }\n\n  function getUnactivatedStakersPoolBalance(IERC20 _token) public view override returns (uint256) {\n    return baseData().stakeBalance;\n  }\n\n  function getStakersPoolBalance(IERC20 _token) public view override returns (uint256) {\n    return LibPool.stakeBalance(baseData());\n  }\n\n  function getStakerPoolBalance(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    PoolStorage.Base storage ps = baseData();\n    if (ps.lockToken.totalSupply() == 0) {\n      return 0;\n    }\n    return\n      ps.lockToken.balanceOf(_staker).mul(getStakersPoolBalance(_token)).div(\n        ps.lockToken.totalSupply()\n      );\n  }\n\n  function getTotalUnmintedSherX(IERC20 _token) public view override returns (uint256) {\n    baseData();\n    return LibPool.getTotalUnmintedSherX(_token);\n  }\n\n  function getUnallocatedSherXStored(IERC20 _token) public view override returns (uint256) {\n    return baseData().unallocatedSherX;\n  }\n\n  function getUnallocatedSherXTotal(IERC20 _token) external view override returns (uint256) {\n    return getUnallocatedSherXStored(_token).add(LibPool.getTotalUnmintedSherX(_token));\n  }\n\n  function getUnallocatedSherXFor(address _user, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    baseData();\n    return LibPool.getUnallocatedSherXFor(_user, _token);\n  }\n\n  function getTotalSherXPerBlock(IERC20 _token) public view override returns (uint256) {\n    return SherXStorage.sx().sherXPerBlock.mul(baseData().sherXWeight).div(uint16(-1));\n  }\n\n  function getSherXPerBlock(IERC20 _token) external view override returns (uint256) {\n    return getSherXPerBlock(msg.sender, _token);\n  }\n\n  function getSherXPerBlock(address _user, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    if (ps.lockToken.totalSupply() == 0) {\n      return 0;\n    }\n    return\n      getTotalSherXPerBlock(_token).mul(ps.lockToken.balanceOf(_user)).div(\n        ps.lockToken.totalSupply()\n      );\n  }\n\n  function getSherXPerBlock(uint256 _lock, IERC20 _token) external view override returns (uint256) {\n    // simulates staking (adding lock)\n    return\n      getTotalSherXPerBlock(_token).mul(_lock).div(baseData().lockToken.totalSupply().add(_lock));\n  }\n\n  function getSherXLastAccrued(IERC20 _token) external view override returns (uint40) {\n    return baseData().sherXLastAccrued;\n  }\n\n  function LockToTokenXRate(IERC20 _token) external view override returns (uint256) {\n    return LockToToken(10**18, _token);\n  }\n\n  function LockToToken(uint256 _amount, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    uint256 balance = LibPool.stakeBalance(ps);\n    uint256 totalLock = ps.lockToken.totalSupply();\n    if (totalLock == 0 || balance == 0) {\n      revert('NO_DATA');\n    }\n    return balance.mul(_amount).div(totalLock);\n  }\n\n  function TokenToLockXRate(IERC20 _token) external view override returns (uint256) {\n    return TokenToLock(10**18, _token);\n  }\n\n  function TokenToLock(uint256 _amount, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    uint256 balance = LibPool.stakeBalance(ps);\n    uint256 totalLock = ps.lockToken.totalSupply();\n    if (totalLock == 0 || balance == 0) {\n      return 10**18;\n    }\n    return totalLock.mul(_amount).div(balance);\n  }\n\n  //\n  // State changing methods\n  //\n\n  function setCooldownFee(uint32 _fee, IERC20 _token) external override {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n\n    baseData().activateCooldownFee = _fee;\n  }\n\n  function depositProtocolBalance(\n    bytes32 _protocol,\n    uint256 _amount,\n    IERC20 _token\n  ) external override {\n    require(_amount > 0, 'AMOUNT');\n    require(GovStorage.gs().protocolIsCovered[_protocol], 'PROTOCOL');\n    PoolStorage.Base storage ps = baseData();\n    require(ps.isProtocol[_protocol], 'NO_DEPOSIT');\n\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n    ps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].add(_amount);\n  }\n\n  function withdrawProtocolBalance(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    IERC20 _token\n  ) external override {\n    require(msg.sender == GovStorage.gs().protocolAgents[_protocol], 'SENDER');\n    require(_amount > 0, 'AMOUNT');\n    require(_receiver != address(0), 'RECEIVER');\n    PoolStorage.Base storage ps = baseData();\n\n    LibPool.payOffDebtAll(_token);\n\n    if (_amount == uint256(-1)) {\n      _amount = ps.protocolBalance[_protocol];\n    }\n\n    _token.safeTransfer(_receiver, _amount);\n    ps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].sub(_amount);\n  }\n\n  function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) {\n    require(_amount > 0, 'AMOUNT');\n    PoolStorage.Base storage ps = baseData();\n\n    ps.lockToken.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 fee = _amount.mul(ps.activateCooldownFee).div(uint32(-1));\n    if (fee > 0) {\n      // stake of user gets burned\n      // representative amount token get added to first money out pool\n      uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());\n      ps.firstMoneyOut = ps.firstMoneyOut.add(tokenAmount);\n\n      ps.lockToken.burn(address(this), fee);\n    }\n\n    ps.unstakeEntries[msg.sender].push(\n      PoolStorage.UnstakeEntry(uint40(block.number), _amount.sub(fee))\n    );\n\n    return ps.unstakeEntries[msg.sender].length - 1;\n  }\n\n  function cancelCooldown(uint256 _id, IERC20 _token) external override {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown >= uint40(block.number),\n      'COOLDOWN_EXPIRED'\n    );\n    delete ps.unstakeEntries[msg.sender][_id];\n    ps.lockToken.safeTransfer(msg.sender, withdraw.lock);\n  }\n\n  function unstakeWindowExpiry(\n    address _account,\n    uint256 _id,\n    IERC20 _token\n  ) external override {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[_account][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow < uint40(block.number),\n      'UNSTAKE_WINDOW_NOT_EXPIRED'\n    );\n    delete ps.unstakeEntries[_account][_id];\n    ps.lockToken.safeTransfer(_account, withdraw.lock);\n  }\n\n  function unstake(\n    uint256 _id,\n    address _receiver,\n    IERC20 _token\n  ) external override returns (uint256 amount) {\n    PoolStorage.Base storage ps = baseData();\n    require(_receiver != address(0), 'RECEIVER');\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n    // period is including\n    require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow >= uint40(block.number),\n      'UNSTAKE_WINDOW_EXPIRED'\n    );\n    amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());\n\n    ps.stakeBalance = ps.stakeBalance.sub(amount);\n    delete ps.unstakeEntries[msg.sender][_id];\n    ps.lockToken.burn(address(this), withdraw.lock);\n    _token.safeTransfer(_receiver, amount);\n  }\n\n  function payOffDebtAll(IERC20 _token) external override {\n    baseData();\n    LibPool.payOffDebtAll(_token);\n  }\n\n  function cleanProtocol(\n    bytes32 _protocol,\n    uint256 _index,\n    bool _forceDebt,\n    address _receiver,\n    IERC20 _token\n  ) external override {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    require(_receiver != address(0), 'RECEIVER');\n\n    PoolStorage.Base storage ps = baseData();\n    require(ps.protocols[_index] == _protocol, 'INDEX');\n\n    // If protocol has 0 accrued debt, the premium should also be 0\n    // If protocol has >0 accrued debt, needs to be bigger then balance\n    // Otherwise just update premium to 0 for the protocol first and then delete\n    uint256 accrued = LibPool.accruedDebt(_protocol, _token);\n    if (accrued == 0) {\n      require(ps.protocolPremium[_protocol] == 0, 'CAN_NOT_DELETE');\n    } else {\n      require(accrued > ps.protocolBalance[_protocol], 'CAN_NOT_DELETE2');\n    }\n\n    // send the remainder of the protocol balance to the sherx underlying\n    if (_forceDebt && accrued > 0) {\n      ps.sherXUnderlying = ps.sherXUnderlying.add(ps.protocolBalance[_protocol]);\n      delete ps.protocolBalance[_protocol];\n    }\n\n    // send any leftovers back to the protocol receiver\n    if (ps.protocolBalance[_protocol] > 0) {\n      _token.safeTransfer(_receiver, ps.protocolBalance[_protocol]);\n      delete ps.protocolBalance[_protocol];\n    }\n\n    // move last index to index of _protocol\n    ps.protocols[_index] = ps.protocols[ps.protocols.length - 1];\n    // remove last index\n    ps.protocols.pop();\n    ps.isProtocol[_protocol] = false;\n    // could still be >0, if accrued more debt than needed.\n    if (ps.protocolPremium[_protocol] > 0) {\n      ps.totalPremiumPerBlock = ps.totalPremiumPerBlock.sub(ps.protocolPremium[_protocol]);\n      delete ps.protocolPremium[_protocol];\n    }\n  }\n\n  function baseData() internal view returns (PoolStorage.Base storage ps) {\n    ps = PoolStorage.ps(bps());\n    require(ps.govPool != address(0), 'INVALID_TOKEN');\n  }\n\n  function bps() internal pure returns (IERC20 rt) {\n    // These fields are not accessible from assembly\n    bytes memory array = msg.data;\n    uint256 index = msg.data.length;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n      rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport '../storage/PoolStorage.sol';\nimport '../storage/SherXStorage.sol';\n\nlibrary LibPool {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ILock;\n\n  function stakeBalance(PoolStorage.Base storage ps) public view returns (uint256) {\n    uint256 balance = ps.stakeBalance;\n\n    if (address(ps.strategy) != address(0)) {\n      balance = balance.add(ps.strategy.balanceOf());\n    }\n\n    return balance.sub(ps.firstMoneyOut);\n  }\n\n  function accruedDebt(bytes32 _protocol, IERC20 _token) public view returns (uint256) {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    return _accruedDebt(ps, _protocol, block.number.sub(ps.totalPremiumLastPaid));\n  }\n\n  function getTotalAccruedDebt(IERC20 _token) public view returns (uint256) {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    return _getTotalAccruedDebt(ps, block.number.sub(ps.totalPremiumLastPaid));\n  }\n\n  function getTotalUnmintedSherX(IERC20 _token) public view returns (uint256 sherX) {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    sherX = block.number.sub(ps.sherXLastAccrued).mul(sx.sherXPerBlock).mul(ps.sherXWeight).div(\n      uint16(-1)\n    );\n  }\n\n  function getUnallocatedSherXFor(address _user, IERC20 _token)\n    external\n    view\n    returns (uint256 withdrawable_amount)\n  {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n\n    uint256 userAmount = ps.lockToken.balanceOf(_user);\n    uint256 totalAmount = ps.lockToken.totalSupply();\n    if (totalAmount == 0) {\n      return 0;\n    }\n\n    uint256 raw_amount =\n      ps.sWeight.add(getTotalUnmintedSherX(_token)).mul(userAmount).div(totalAmount);\n    withdrawable_amount = raw_amount.sub(ps.sWithdrawn[_user]);\n  }\n\n  function stake(\n    PoolStorage.Base storage ps,\n    uint256 _amount,\n    address _receiver\n  ) external returns (uint256 lock) {\n    uint256 totalLock = ps.lockToken.totalSupply();\n    if (totalLock == 0) {\n      // mint initial lock\n      lock = 10**18;\n    } else {\n      // mint lock based on funds in pool\n      lock = _amount.mul(totalLock).div(stakeBalance(ps));\n    }\n    ps.stakeBalance = ps.stakeBalance.add(_amount);\n    ps.lockToken.mint(_receiver, lock);\n  }\n\n  function payOffDebtAll(IERC20 _token) external {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    uint256 blocks = block.number.sub(ps.totalPremiumLastPaid);\n\n    uint256 totalAccruedDebt;\n    for (uint256 i = 0; i < ps.protocols.length; i++) {\n      totalAccruedDebt = totalAccruedDebt.add(_payOffDebt(ps, ps.protocols[i], blocks));\n    }\n    // move funds to the sherX etf\n    ps.sherXUnderlying = ps.sherXUnderlying.add(totalAccruedDebt);\n    ps.totalPremiumLastPaid = uint40(block.number);\n  }\n\n  function _payOffDebt(\n    PoolStorage.Base storage ps,\n    bytes32 _protocol,\n    uint256 _blocks\n  ) private returns (uint256 debt) {\n    debt = _accruedDebt(ps, _protocol, _blocks);\n    ps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].sub(debt);\n  }\n\n  function _accruedDebt(\n    PoolStorage.Base storage ps,\n    bytes32 _protocol,\n    uint256 _blocks\n  ) private view returns (uint256) {\n    return _blocks.mul(ps.protocolPremium[_protocol]);\n  }\n\n  function _getTotalAccruedDebt(PoolStorage.Base storage ps, uint256 _blocks)\n    private\n    view\n    returns (uint256)\n  {\n    return _blocks.mul(ps.totalPremiumPerBlock);\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '../interfaces/ISherX.sol';\n\nimport '../storage/SherXERC20Storage.sol';\n\nimport '../libraries/LibPool.sol';\nimport '../libraries/LibSherX.sol';\nimport '../libraries/LibSherXERC20.sol';\n\ncontract SherX is ISherX {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //\n  // Modifiers\n  //\n\n  modifier onlyGovMain() {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    _;\n  }\n\n  //\n  // View methods\n  //\n\n  function getTotalUsdPerBlock() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdPerBlock;\n  }\n\n  function getTotalUsdPoolStored() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdPool;\n  }\n\n  function getTotalUsdPool() external view override returns (uint256) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    return sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));\n  }\n\n  function getTotalUsdLastSettled() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdLastSettled;\n  }\n\n  function getStoredUsd(IERC20 _token) external view override returns (uint256) {\n    return SherXStorage.sx().tokenUSD[_token];\n  }\n\n  function getUnmintedSherX(IERC20 _token) internal view returns (uint256) {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    SherXStorage.Base storage sx = SherXStorage.sx();\n\n    return\n      block.number.sub(ps.sherXLastAccrued).mul(sx.sherXPerBlock).mul(ps.sherXWeight).div(\n        uint16(-1)\n      );\n  }\n\n  function getTotalSherXUnminted() external view override returns (uint256) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 total =\n      block\n        .number\n        .sub(gs.watsonsSherxLastAccrued)\n        .mul(sx.sherXPerBlock)\n        .mul(gs.watsonsSherxWeight)\n        .div(uint16(-1));\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      total = total.add(getUnmintedSherX(gs.tokensStaker[i]));\n    }\n    return total;\n  }\n\n  function getTotalSherX() external view override returns (uint256) {\n    return LibSherX.getTotalSherX();\n  }\n\n  function getSherXPerBlock() external view override returns (uint256) {\n    return SherXStorage.sx().sherXPerBlock;\n  }\n\n  function getSherXBalance() external view override returns (uint256) {\n    return getSherXBalance(msg.sender);\n  }\n\n  function getSherXBalance(address _user) public view override returns (uint256) {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    uint256 balance = sx20.balances[_user];\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      balance = balance.add(LibPool.getUnallocatedSherXFor(_user, gs.tokensStaker[i]));\n    }\n    return balance;\n  }\n\n  function getInternalTotalSupply() external view override returns (uint256) {\n    return SherXStorage.sx().internalTotalSupply;\n  }\n\n  function getInternalTotalSupplySettled() external view override returns (uint256) {\n    return SherXStorage.sx().internalTotalSupplySettled;\n  }\n\n  function calcUnderlying()\n    external\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return calcUnderlying(msg.sender);\n  }\n\n  function calcUnderlying(address _user)\n    public\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return LibSherX.calcUnderlying(getSherXBalance(_user));\n  }\n\n  function calcUnderlying(uint256 _amount)\n    external\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return LibSherX.calcUnderlying(_amount);\n  }\n\n  function calcUnderlyingInStoredUSD() external view override returns (uint256) {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    return calcUnderlyingInStoredUSD(sx20.balances[msg.sender]);\n  }\n\n  function calcUnderlyingInStoredUSD(uint256 _amount) public view override returns (uint256 usd) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 total = LibSherX.getTotalSherX();\n    if (total == 0) {\n      return 0;\n    }\n    for (uint256 i; i < gs.tokensSherX.length; i++) {\n      IERC20 token = gs.tokensSherX[i];\n\n      usd = usd.add(\n        PoolStorage\n          .ps(token)\n          .sherXUnderlying\n          .add(LibPool.getTotalAccruedDebt(token))\n          .mul(_amount)\n          .mul(sx.tokenUSD[token])\n          .div(10**18)\n          .div(total)\n      );\n    }\n  }\n\n  //\n  // State changing methods\n  //\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) external override {\n    doYield(ILock(msg.sender), from, to, amount);\n  }\n\n  function setInitialWeight() external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.watsonsAddress != address(0), 'WATS_UNSET');\n    require(gs.watsonsSherxWeight == 0, 'ALREADY_INIT');\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);\n      require(ps.sherXWeight == 0, 'ALREADY_INIT_2');\n    }\n\n    gs.watsonsSherxWeight = uint16(-1);\n  }\n\n  function setWeights(\n    IERC20[] memory _tokens,\n    uint256[] memory _weights,\n    uint256 _watsons\n  ) external override onlyGovMain {\n    require(_tokens.length == _weights.length, 'LENGTH');\n    // NOTE: can potentially be made more gas efficient\n    // Do not loop over all staker tokens\n    // But just over the tokens in the _tokens array\n    LibSherX.accrueSherX();\n\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 weightAdd;\n    uint256 weightSub;\n\n    for (uint256 i; i < _tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(_tokens[i]);\n      // Disabled tokens can not have ps.sherXWeight > 0\n      require(ps.stakes, 'DISABLED');\n\n      weightAdd = weightAdd.add(_weights[i]);\n      weightSub = weightSub.add(ps.sherXWeight);\n      ps.sherXWeight = uint16(_weights[i]);\n    }\n    if (_watsons != uint256(-1)) {\n      weightAdd = weightAdd.add(_watsons);\n      weightSub = weightSub.add(gs.watsonsSherxWeight);\n\n      gs.watsonsSherxWeight = uint16(_watsons);\n    }\n\n    require(weightAdd == weightSub, 'SUM');\n  }\n\n  function harvest() external override {\n    harvestFor(msg.sender);\n  }\n\n  function harvest(ILock _token) external override {\n    harvestFor(msg.sender, _token);\n  }\n\n  function harvest(ILock[] calldata _tokens) external override {\n    for (uint256 i; i < _tokens.length; i++) {\n      harvestFor(msg.sender, _tokens[i]);\n    }\n  }\n\n  function harvestFor(address _user) public override {\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);\n      harvestFor(_user, ps.lockToken);\n    }\n  }\n\n  function harvestFor(address _user, ILock _token) public override {\n    // could potentially call harvest function for token that are not in the pool\n    // if balance > 0, tx will revert\n    uint256 stakeBalance = _token.balanceOf(_user);\n    if (stakeBalance > 0) {\n      doYield(_token, _user, _user, 0);\n    }\n    emit Harvest(_user, _token);\n  }\n\n  function harvestFor(address _user, ILock[] calldata _tokens) external override {\n    for (uint256 i; i < _tokens.length; i++) {\n      harvestFor(_user, _tokens[i]);\n    }\n  }\n\n  function redeem(uint256 _amount, address _receiver) external override {\n    require(_amount > 0, 'AMOUNT');\n    require(_receiver != address(0), 'RECEIVER');\n\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    LibSherX.accrueUSDPool();\n\n    // Note: LibSherX.accrueSherX() is removed as the calcUnderlying already takes it into consideration (without changing state)\n    // Calculate the current `amounts` of underlying `tokens` for `_amount` of SherX\n    (IERC20[] memory tokens, uint256[] memory amounts) = LibSherX.calcUnderlying(_amount);\n    LibSherXERC20.burn(msg.sender, _amount);\n\n    uint256 subUsdPool = 0;\n    for (uint256 i; i < tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(tokens[i]);\n\n      // Expensive operation, only execute to prevent tx reverts\n      if (amounts[i] > ps.sherXUnderlying) {\n        LibPool.payOffDebtAll(tokens[i]);\n      }\n      // Remove the token as underlying of SherX\n      ps.sherXUnderlying = ps.sherXUnderlying.sub(amounts[i]);\n      // As the tokens are transferred, remove from the current usdPool\n      // By summing the total that needs to be deducted in the `subUsdPool` value\n      subUsdPool = subUsdPool.add(amounts[i].mul(sx.tokenUSD[tokens[i]]).div(10**18));\n\n      tokens[i].safeTransfer(_receiver, amounts[i]);\n    }\n    sx.totalUsdPool = sx.totalUsdPool.sub(subUsdPool);\n    LibSherX.settleInternalSupply(_amount);\n  }\n\n  function accrueSherX() external override {\n    LibSherX.accrueSherX();\n  }\n\n  function accrueSherX(IERC20 _token) external override {\n    LibSherX.accrueSherX(_token);\n  }\n\n  function accrueSherXWatsons() external override {\n    LibSherX.accrueSherXWatsons();\n  }\n\n  function doYield(\n    ILock token,\n    address from,\n    address to,\n    uint256 amount\n  ) private {\n    IERC20 underlying = token.underlying();\n    PoolStorage.Base storage ps = PoolStorage.ps(underlying);\n    require(ps.lockToken == token, 'SENDER');\n\n    LibSherX.accrueSherX(underlying);\n    uint256 userAmount = ps.lockToken.balanceOf(from);\n    uint256 totalAmount = ps.lockToken.totalSupply();\n\n    uint256 ineglible_yield_amount;\n    if (totalAmount > 0) {\n      ineglible_yield_amount = ps.sWeight.mul(amount).div(totalAmount);\n    } else {\n      ineglible_yield_amount = amount;\n    }\n\n    if (from != address(0)) {\n      uint256 raw_amount = ps.sWeight.mul(userAmount).div(totalAmount);\n      uint256 withdrawable_amount = raw_amount.sub(ps.sWithdrawn[from]);\n      if (withdrawable_amount > 0) {\n        // store the data in a single calc\n        ps.sWithdrawn[from] = raw_amount.sub(ineglible_yield_amount);\n        // The `withdrawable_amount` is allocated to `from`, subtract from `unallocatedSherX`\n        ps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);\n        PoolStorage.Base storage psSherX = PoolStorage.ps(IERC20(address(this)));\n        if (from == address(this)) {\n          // add SherX harvested by the pool itself to first money out pool.\n          psSherX.stakeBalance = psSherX.stakeBalance.add(withdrawable_amount);\n          psSherX.firstMoneyOut = psSherX.firstMoneyOut.add(withdrawable_amount);\n        } else {\n          LibPool.stake(psSherX, withdrawable_amount, from);\n        }\n      } else {\n        ps.sWithdrawn[from] = ps.sWithdrawn[from].sub(ineglible_yield_amount);\n      }\n    } else {\n      ps.sWeight = ps.sWeight.add(ineglible_yield_amount);\n    }\n\n    if (to != address(0)) {\n      ps.sWithdrawn[to] = ps.sWithdrawn[to].add(ineglible_yield_amount);\n    } else {\n      ps.sWeight = ps.sWeight.sub(ineglible_yield_amount);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "Manager.sol",
            "PoolBase.sol",
            "LibPool.sol",
            "SherX.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\ndebt = _accruedDebt(ps, _protocol, _blocks);\n// this can revert tx\nps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].sub(debt);\n"
                ],
                "Type": " Single under-funded protocol can break paying off debt",
                "Description": "\nThe SherXERC20.payOffDebtAll function iterates over all protocols of the token.\nIf _a single project_ does not have enough funds to cover the premium payments, the transactions come to a halt, see _payOffDebt:\n\nsolidity\ndebt = _accruedDebt(ps, _protocol, _blocks);\n// this can revert tx\nps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].sub(debt);\n\n\nMany core functions require paying off debt first and can therefore revert when a single protocol cannot pay the token premium:\nsetTokenPrice\nsetProtocolPremium\nwithdrawProtocolBalance\nredeem\netc.\n\nThis scenario that a protocol is unable to pay a premium does not seem unlikely especially as there can be many protocols and each protocol can pay premiums in potentially many tokens and have to continuously re-deposit to their account to increase the balance.\nIt is also rather involved to remove the protocol's coverage and remove the premium payments for the token. It requires governance interaction and potentially paying for the accumulated debt themselves.\n\nEvert0x (Sherlock) acknowledged(https://github.com/code-423n4/2021-07-sherlock-findings/issues/119#issuecomment-889143141):\n  This was a design tradeoff. As governance we can see it coming as the balance is slowly draining. But the fact the protocols are able to withdraw the full amount at any time could surprise the governance. (and make the reverts in the functions above happening)\n\n We are thinking to add a rule in the withdrawProtocolBalance to only allow withdrawals with at least 2 days of remaining balance. Allowing enough time for governance calls to remove the protocol.\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../interfaces/IGovDev.sol';\n\ncontract GovDev is IGovDev {\n  function getGovDev() external view override returns (address) {\n    return LibDiamond.contractOwner();\n  }\n\n  function transferGovDev(address _govDev) external override {\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    require(_govDev != LibDiamond.contractOwner(), 'SAME_DEV');\n    LibDiamond.setContractOwner(_govDev);\n  }\n\n  function updateSolution(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) external override {\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    return LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../interfaces/IGov.sol';\n\nimport '../storage/GovStorage.sol';\nimport '../storage/PoolStorage.sol';\nimport '../storage/SherXStorage.sol';\n\ncontract Gov is IGov {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //\n  // Modifiers\n  //\n\n  modifier onlyGovMain() {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    _;\n  }\n\n  //\n  // View methods\n  //\n\n  function getGovMain() external view override returns (address) {\n    return GovStorage.gs().govMain;\n  }\n\n  function getWatsons() external view override returns (address) {\n    return GovStorage.gs().watsonsAddress;\n  }\n\n  function getWatsonsSherXWeight() external view override returns (uint16) {\n    return GovStorage.gs().watsonsSherxWeight;\n  }\n\n  function getWatsonsSherxLastAccrued() external view override returns (uint40) {\n    return GovStorage.gs().watsonsSherxLastAccrued;\n  }\n\n  function getWatsonsSherXPerBlock() public view override returns (uint256) {\n    GovStorage.Base storage gs = GovStorage.gs();\n    SherXStorage.Base storage sx = SherXStorage.sx();\n\n    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(uint16(-1));\n  }\n\n  function getWatsonsUnmintedSherX() external view override returns (uint256) {\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    return block.number.sub(gs.watsonsSherxLastAccrued).mul(getWatsonsSherXPerBlock());\n  }\n\n  function getUnstakeWindow() external view override returns (uint40) {\n    return GovStorage.gs().unstakeWindow;\n  }\n\n  function getCooldown() external view override returns (uint40) {\n    return GovStorage.gs().unstakeCooldown;\n  }\n\n  function getTokensStaker() external view override returns (IERC20[] memory) {\n    return GovStorage.gs().tokensStaker;\n  }\n\n  function getTokensSherX() external view override returns (IERC20[] memory) {\n    return GovStorage.gs().tokensSherX;\n  }\n\n  function getProtocolIsCovered(bytes32 _protocol) external view override returns (bool) {\n    return GovStorage.gs().protocolIsCovered[_protocol];\n  }\n\n  function getProtocolManager(bytes32 _protocol) external view override returns (address) {\n    // NOTE: UNUSED\n    return GovStorage.gs().protocolManagers[_protocol];\n  }\n\n  function getProtocolAgent(bytes32 _protocol) external view override returns (address) {\n    return GovStorage.gs().protocolAgents[_protocol];\n  }\n\n  //\n  // State changing methods\n  //\n\n  function setInitialGovMain(address _govMain) external override {\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    require(_govMain != address(0), 'ZERO_GOV');\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    require(gs.govMain == address(0), 'ALREADY_SET');\n\n    gs.govMain = _govMain;\n  }\n\n  function transferGovMain(address _govMain) external override onlyGovMain {\n    require(_govMain != address(0), 'ZERO_GOV');\n    require(GovStorage.gs().govMain != _govMain, 'SAME_GOV');\n    GovStorage.gs().govMain = _govMain;\n  }\n\n  function setWatsonsAddress(address _watsons) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    require(_watsons != address(0), 'ZERO_WATS');\n    require(gs.watsonsAddress != _watsons, 'SAME_WATS');\n    gs.watsonsAddress = _watsons;\n  }\n\n  function setUnstakeWindow(uint40 _unstakeWindow) external override onlyGovMain {\n    require(_unstakeWindow < 25000000, 'MAX'); // ~ approximate 10 years of blocks\n    GovStorage.gs().unstakeWindow = _unstakeWindow;\n  }\n\n  function setCooldown(uint40 _period) external override onlyGovMain {\n    require(_period < 25000000, 'MAX'); // ~ approximate 10 years of blocks\n    GovStorage.gs().unstakeCooldown = _period;\n  }\n\n  function protocolAdd(\n    bytes32 _protocol,\n    address _eoaProtocolAgent,\n    address _eoaManager,\n    IERC20[] memory _tokens\n  ) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(!gs.protocolIsCovered[_protocol], 'COVERED');\n    gs.protocolIsCovered[_protocol] = true;\n\n    protocolUpdate(_protocol, _eoaProtocolAgent, _eoaManager);\n    protocolDepositAdd(_protocol, _tokens);\n  }\n\n  function protocolUpdate(\n    bytes32 _protocol,\n    address _eoaProtocolAgent,\n    address _eoaManager\n  ) public override onlyGovMain {\n    require(_protocol != bytes32(0), 'ZERO_PROTOCOL');\n    require(_eoaProtocolAgent != address(0), 'ZERO_AGENT');\n    require(_eoaManager != address(0), 'ZERO_MANAGER');\n\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.protocolIsCovered[_protocol], 'NOT_COVERED');\n\n    // NOTE: UNUSED\n    gs.protocolManagers[_protocol] = _eoaManager;\n    gs.protocolAgents[_protocol] = _eoaProtocolAgent;\n  }\n\n  function protocolDepositAdd(bytes32 _protocol, IERC20[] memory _tokens)\n    public\n    override\n    onlyGovMain\n  {\n    require(_protocol != bytes32(0), 'ZERO_PROTOCOL');\n    require(_tokens.length > 0, 'ZERO');\n\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.protocolIsCovered[_protocol], 'NOT_COVERED');\n\n    for (uint256 i; i < _tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(_tokens[i]);\n      require(ps.premiums, 'INIT');\n      require(!ps.isProtocol[_protocol], 'ALREADY_ADDED');\n\n      ps.isProtocol[_protocol] = true;\n      ps.protocols.push(_protocol);\n    }\n  }\n\n  function protocolRemove(bytes32 _protocol) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.protocolIsCovered[_protocol], 'NOT_COVERED');\n\n    for (uint256 i; i < gs.tokensSherX.length; i++) {\n      IERC20 token = gs.tokensSherX[i];\n\n      PoolStorage.Base storage ps = PoolStorage.ps(token);\n      // basically need to check if accruedDebt > 0, but this is true in case protocolPremium > 0\n      require(ps.protocolPremium[_protocol] == 0, 'DEBT');\n      require(!ps.isProtocol[_protocol], 'POOL_PROTOCOL');\n    }\n    delete gs.protocolIsCovered[_protocol];\n    delete gs.protocolManagers[_protocol];\n    delete gs.protocolAgents[_protocol];\n  }\n\n  function tokenInit(\n    IERC20 _token,\n    address _govPool,\n    ILock _lock,\n    bool _protocolPremium\n  ) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(address(_token) != address(0), 'ZERO_TOKEN');\n\n    if (_govPool != address(0)) {\n      ps.govPool = _govPool;\n    }\n    require(ps.govPool != address(0), 'ZERO_GOV');\n\n    if (address(_lock) != address(0)) {\n      if (address(ps.lockToken) == address(0)) {\n        require(_lock.getOwner() == address(this), 'OWNER');\n        require(_lock.totalSupply() == 0, 'SUPPLY');\n        // If not native (e.g. NOT SherX), verify underlying mapping\n        if (address(_token) != address(this)) {\n          require(_lock.underlying() == _token, 'UNDERLYING');\n        }\n        ps.lockToken = _lock;\n      }\n      if (address(ps.lockToken) == address(_lock)) {\n        require(!ps.stakes, 'STAKES_SET');\n        ps.stakes = true;\n        gs.tokensStaker.push(_token);\n      } else {\n        revert('WRONG_LOCK');\n      }\n    }\n\n    if (_protocolPremium) {\n      require(!ps.premiums, 'PREMIUMS_SET');\n      ps.premiums = true;\n      gs.tokensSherX.push(_token);\n    }\n  }\n\n  function tokenDisableStakers(IERC20 _token, uint256 _index) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(gs.tokensStaker[_index] == _token, 'INDEX');\n    require(ps.sherXWeight == 0, 'ACTIVE_WEIGHT');\n\n    delete ps.stakes;\n    // lockToken is kept, as stakers should be able to unstake\n    // staking can be reenabled by calling tokenInit\n    gs.tokensStaker[_index] = gs.tokensStaker[gs.tokensStaker.length - 1];\n    gs.tokensStaker.pop();\n  }\n\n  function tokenDisableProtocol(IERC20 _token, uint256 _index) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(gs.tokensSherX[_index] == _token, 'INDEX');\n    require(ps.totalPremiumPerBlock == 0, 'ACTIVE_PREMIUM');\n    // Can not remove with active underlying, SherX holders will see drop in underlying value\n    require(ps.sherXUnderlying == 0, 'ACTIVE_SHERX');\n\n    delete ps.premiums;\n    gs.tokensSherX[_index] = gs.tokensSherX[gs.tokensSherX.length - 1];\n    gs.tokensSherX.pop();\n  }\n\n  // Unloading all tokens, likely before calling tokenRemove\n  function tokenUnload(\n    IERC20 _token,\n    IRemove _native,\n    address _remaining\n  ) external override onlyGovMain {\n    require(address(_native) != address(0), 'ZERO_NATIVE');\n    require(_remaining != address(0), 'ZERO_REMAIN');\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(ps.govPool != address(0), 'EMPTY');\n\n    // Protocol are technically still able to deposit, ps.premiums is still true\n    // This makes sure the sherx underlying doesn't grow anymore\n    // this function is called before the disable protocol\n    // disable stakes --> unload tokens --> disable protocol (sherx) --> remove\n\n    require(!ps.stakes, 'STAKES_SET');\n    require(ps.totalPremiumPerBlock == 0, 'ACTIVE_PREMIUM');\n    require(address(ps.strategy) == address(0), 'ACTIVE_STRATEGY');\n\n    uint256 totalToken = ps.firstMoneyOut.add(ps.sherXUnderlying);\n\n    // `firstMoneyOut` and `sherXUnderlying` are two 'pools' that needs to be swapped\n    // in a single transaction.\n    // If `sherXUnderlying` is not swapped in a single tx, the price of SherX (underlying value)\n    // will drop\n    // If `firstMoneyOut` is not swapped in a single tx, the buffer will be reduced in $ value\n    // This code piece swaps these tokens for other tokens in the solution\n    // The goal is to keep the current $ value of these two 'pools' somewhat equal before/after swap\n    if (totalToken > 0) {\n      _token.approve(address(_native), totalToken);\n\n      (IERC20 newToken, uint256 newFmo, uint256 newSherxUnderlying) =\n        _native.swap(_token, ps.firstMoneyOut, ps.sherXUnderlying);\n\n      PoolStorage.Base storage ps2 = PoolStorage.ps(newToken);\n      require(ps2.govPool != address(0), 'EMPTY_SWAP');\n\n      ps2.stakeBalance = ps2.stakeBalance.add(newFmo);\n      ps2.firstMoneyOut = ps2.firstMoneyOut.add(newFmo);\n      ps2.sherXUnderlying = ps2.sherXUnderlying.add(newSherxUnderlying);\n    }\n\n    uint256 totalFee = ps.unallocatedSherX;\n    if (totalFee > 0) {\n      IERC20(address(this)).safeTransfer(_remaining, totalFee);\n      delete ps.unallocatedSherX;\n    }\n\n    uint256 balance = ps.stakeBalance.sub(ps.firstMoneyOut);\n    if (balance > 0) {\n      _token.safeTransfer(_remaining, balance);\n      delete ps.stakeBalance;\n    }\n\n    delete ps.sherXUnderlying;\n    delete ps.firstMoneyOut;\n  }\n\n  function tokenRemove(IERC20 _token) external override onlyGovMain {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(ps.govPool != address(0), 'EMPTY');\n    require(!ps.stakes, 'STAKES_SET');\n    require(!ps.premiums, 'PREMIUMS_SET');\n    require(ps.protocols.length == 0, 'ACTIVE_PROTOCOLS');\n    require(ps.stakeBalance == 0, 'BALANCE_SET');\n    // NOTE: removed because firstMoneyOut will always be less or equal to stakeBalance\n    require(ps.unallocatedSherX == 0, 'SHERX_SET');\n\n    delete ps.govPool;\n    delete ps.lockToken;\n    delete ps.activateCooldownFee;\n    delete ps.sherXWeight;\n    delete ps.sherXLastAccrued;\n\n    // NOTE: storage variables need to be kept. To make sure readding the token works\n    // IF readding the token, verify off chain if the storage is sufficient.\n    // Create re-adding plan off chain if this isn't the case. (e.g. clean storage by doing calls)\n    //delete ps.sWithdrawn\n    //delete ps.sWeight;\n\n    delete ps.totalPremiumLastPaid;\n  }\n}\n\n\n",
        "CodeNames": [
            "GovDev.sol",
            "Gov.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    " //solidity\nfunction bps() internal pure returns (IERC20 rt) {\n  // These fields are not accessible from assembly\n  bytes memory array = msg.data;\n  uint256 index = msg.data.length;\n\n  // solhint-disable-next-line no-inline-assembly\n  assembly {\n    // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n    rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n  }\n}\n",
                    " //solidity\npragma //solidity 0.8.6;\n\ninterface IERC20 {}\n\nerror StaticCallFailed();\n\ncontract BadEncoding {\n  /// Will return address(1). But address(0) is expected!\n  function f() external view returns (address) {\n    address actual = address(0);\n    address injected = address(1);\n\n    (bool success, bytes memory ret) = address(this).staticcall(abi.encodeWithSelector(this.g.selector, actual, injected));\n\n    if (!success) revert StaticCallFailed();\n\n    return abi.decode(ret, (address));\n  }\n  function g(IERC20 _token) external pure returns (IERC20) {\n    // to get rid of the unused warning\n    _token;\n    // Does it always match _token?\n    return bps();\n  }\n  // From Sherlock Protocol: PoolBase.sol\n  function bps() internal pure returns (IERC20 rt) {\n    // These fields are not accessible from assembly\n    bytes memory array = msg.data;\n    uint256 index = msg.data.length;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n      rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n    }\n  }\n}\n",
                    " //solidity\nfunction unstake(\n  uint256 _id,\n  address _receiver,\n  IERC20 _token\n) external override returns (uint256 amount) {\n  PoolStorage.Base storage ps = baseData();\n  require(_receiver != address(0), 'RECEIVER');\n  GovStorage.Base storage gs = GovStorage.gs();\n  PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];\n  require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n  // period is including\n  require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');\n  require(\n    withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow = uint40(block.number),\n    'UNSTAKE_WINDOW_EXPIRED'\n  );\n  amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());\n\n  ps.stakeBalance = ps.stakeBalance.sub(amount);\n  delete ps.unstakeEntries[msg.sender][_id];\n  ps.lockToken.burn(address(this), withdraw.lock);\n  _token.safeTransfer(_receiver, amount);\n}\n",
                    " //solidity\nbytes memory exploitPayload = abi.encodeWithSignature(\n  PoolBase.unstake.selector,\n  (uint256(_id), address(_receiver), address(Token2), address(Token1))\n);\npoolAddress.call(exploitPayload);\n"
                ],
                "Type": " [Bug",
                "Description": "\n solidity\nfunction bps() internal pure returns (IERC20 rt) {\n  // These fields are not accessible from assembly\n  bytes memory array = msg.data;\n  uint256 index = msg.data.length;\n\n  // solhint-disable-next-line no-inline-assembly\n  assembly {\n    // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n    rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n  }\n}\n\n\nThe above function is designed to expect the token at the end of calldata, but a malicious user can inject extra values at the end of calldata and fake return values.\n\nThe following contract demonstrates an example:\n\n solidity\npragma solidity 0.8.6;\n\ninterface IERC20 {}\n\nerror StaticCallFailed();\n\ncontract BadEncoding {\n  /// Will return address(1). But address(0) is expected!\n  function f() external view returns (address) {\n    address actual = address(0);\n    address injected = address(1);\n\n    (bool success, bytes memory ret) = address(this).staticcall(abi.encodeWithSelector(this.g.selector, actual, injected));\n\n    if (!success) revert StaticCallFailed();\n\n    return abi.decode(ret, (address));\n  }\n  function g(IERC20 _token) external pure returns (IERC20) {\n    // to get rid of the unused warning\n    _token;\n    // Does it always match _token?\n    return bps();\n  }\n  // From Sherlock Protocol: PoolBase.sol\n  function bps() internal pure returns (IERC20 rt) {\n    // These fields are not accessible from assembly\n    bytes memory array = msg.data;\n    uint256 index = msg.data.length;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n      rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n    }\n  }\n}\n\n\nThis example can be used to exploit the protocol:\n\n solidity\nfunction unstake(\n  uint256 _id,\n  address _receiver,\n  IERC20 _token\n) external override returns (uint256 amount) {\n  PoolStorage.Base storage ps = baseData();\n  require(_receiver != address(0), 'RECEIVER');\n  GovStorage.Base storage gs = GovStorage.gs();\n  PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];\n  require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n  // period is including\n  require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');\n  require(\n    withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow = uint40(block.number),\n    'UNSTAKE_WINDOW_EXPIRED'\n  );\n  amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());\n\n  ps.stakeBalance = ps.stakeBalance.sub(amount);\n  delete ps.unstakeEntries[msg.sender][_id];\n  ps.lockToken.burn(address(this), withdraw.lock);\n  _token.safeTransfer(_receiver, amount);\n}\n\n\nState token Token1. Let's say there is a more expensive token\nToken2.\n\nHere's an example exploit:\n\n solidity\nbytes memory exploitPayload = abi.encodeWithSignature(\n  PoolBase.unstake.selector,\n  (uint256(_id), address(_receiver), address(Token2), address(Token1))\n);\npoolAddress.call(exploitPayload);\n\n\nAll the calculations on ps would be done on Token2, but at the end, because of, _token.safeTransfer(_receiver, amount);, Token2 would be transferred. Assuming that Token2 is more expensive than Token1, the attacker makes a profit.\n\nSimilarly, the same technique can be used at a lot of other places. Even if this exploit is not profitable, the fact that the computations can be done on two different tokens is buggy.\n\nThere are several other places where the same pattern is used. All of them needs to be fixed. I've not written an exhaustive list.\n\nEvert0x (Sherlock) confirmed(https://github.com/code-423n4/2021-07-sherlock-findings/issues/90)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../interfaces/IPayout.sol';\n\nimport '../storage/PayoutStorage.sol';\n\nimport '../libraries/LibSherX.sol';\nimport '../libraries/LibSherXERC20.sol';\n\ncontract Payout is IPayout {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //\n  // Modifiers\n  //\n\n  modifier onlyGovMain() {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    _;\n  }\n\n  modifier onlyGovPayout() {\n    require(msg.sender == PayoutStorage.ps().govPayout, 'NOT_GOV_PAY');\n    _;\n  }\n\n  //\n  // View methods\n  //\n\n  function getGovPayout() external view override returns (address) {\n    return PayoutStorage.ps().govPayout;\n  }\n\n  //\n  // State changing methods\n  //\n\n  function setInitialGovPayout(address _govPayout) external override {\n    PayoutStorage.Base storage ps = PayoutStorage.ps();\n\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    require(_govPayout != address(0), 'ZERO_GOV');\n    require(ps.govPayout == address(0), 'ALREADY_SET');\n\n    ps.govPayout = _govPayout;\n  }\n\n  function transferGovPayout(address _govPayout) external override onlyGovMain {\n    PayoutStorage.Base storage ps = PayoutStorage.ps();\n\n    require(_govPayout != address(0), 'ZERO_GOV');\n    require(ps.govPayout != _govPayout, 'SAME_GOV');\n    ps.govPayout = _govPayout;\n  }\n\n  /// @notice Transfer certain amount of underlying tokens of unallocated SherX to `_payout`\n  /// @param _payout Account to receive underlying tokens\n  /// @param _exclude Token to exclude from payout\n  /// @param curTotalUsdPool The current `sx.totalUsdPool`\n  /// @param totalSherX The amount of SherX to use for payout\n  /// @return sherUsd Total amount of USD of the underlying tokens that are being transferred\n  function _doSherX(\n    address _payout,\n    address _exclude,\n    uint256 curTotalUsdPool,\n    uint256 totalSherX\n  ) private returns (uint256 sherUsd) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    // Calculate the current `amounts` of underlying `tokens` for `totalSherX`\n    (IERC20[] memory tokens, uint256[] memory amounts) = LibSherX.calcUnderlying(totalSherX);\n    uint256 subUsdPool;\n\n    for (uint256 i; i < tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(tokens[i]);\n\n      // Expensive operation, only execute to prevent tx reverts\n      if (amounts[i] > ps.sherXUnderlying) {\n        LibPool.payOffDebtAll(tokens[i]);\n      }\n\n      if (address(tokens[i]) == _exclude) {\n        // Return USD value of token that is excluded from payout\n        sherUsd = amounts[i].mul(sx.tokenUSD[tokens[i]]);\n      } else {\n        // Remove the token as underlying of SherX\n        ps.sherXUnderlying = ps.sherXUnderlying.sub(amounts[i]);\n        // As the tokens are transferred, remove from the current usdPool\n        // By summing the total that needs to be deducted in the `subUsdPool` value\n        subUsdPool = subUsdPool.add(amounts[i].mul(sx.tokenUSD[tokens[i]]).div(10**18));\n        // NOTE: transfer can potentially be optimized, as payout call itself also does transfers\n        tokens[i].safeTransfer(_payout, amounts[i]);\n      }\n    }\n    // Subtract the total amount that needs to be subtracted from the `sx.totalUsdPool`\n    sx.totalUsdPool = curTotalUsdPool.sub(subUsdPool);\n  }\n\n  function payout(\n    address _payout,\n    IERC20[] memory _tokens,\n    uint256[] memory _firstMoneyOut,\n    uint256[] memory _amounts,\n    uint256[] memory _unallocatedSherX,\n    address _exclude\n  ) external override onlyGovPayout {\n    // all pools (including SherX pool) can be deducted fmo and balance\n    // deducting balance will reduce the users underlying value of stake token\n    // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards\n    // for users that did not claim them (e.g materialized them and included in SherX pool)\n\n    require(address(_payout) != address(0), 'ZERO_PAY');\n    require(address(_payout) != address(this), 'THIS_PAY');\n    require(_tokens.length == _firstMoneyOut.length, 'LENGTH_1');\n    require(_tokens.length == _amounts.length, 'LENGTH_2');\n    require(_tokens.length == _unallocatedSherX.length, 'LENGTH_3');\n\n    LibSherX.accrueSherX();\n\n    uint256 totalUnallocatedSherX;\n    uint256 totalSherX;\n\n    for (uint256 i; i < _tokens.length; i++) {\n      IERC20 token = _tokens[i];\n      uint256 firstMoneyOut = _firstMoneyOut[i];\n      uint256 amounts = _amounts[i];\n      uint256 unallocatedSherX = _unallocatedSherX[i];\n\n      PoolStorage.Base storage ps = PoolStorage.ps(token);\n      require(ps.govPool != address(0), 'INIT');\n      require(ps.unallocatedSherX >= unallocatedSherX, 'ERR_UNALLOC_FEE');\n\n      if (unallocatedSherX > 0) {\n        // Subtract from `sWeight` as the tokens are not claimable anymore\n        ps.sWeight = ps.sWeight.sub(unallocatedSherX);\n        // Subtract from unallocated, as the tokens are now allocated to this payout call\n        ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);\n        // Update the memory variable `totalUnallocatedSherX` to execute on `_doSherX` later\n        totalUnallocatedSherX = totalUnallocatedSherX.add(unallocatedSherX);\n      }\n\n      uint256 total = firstMoneyOut.add(amounts);\n      if (total == 0) {\n        continue;\n      }\n      if (firstMoneyOut > 0) {\n        ps.firstMoneyOut = ps.firstMoneyOut.sub(firstMoneyOut);\n      }\n      ps.stakeBalance = ps.stakeBalance.sub(total);\n\n      if (address(token) == address(this)) {\n        // If the token address == address(this), it's SherX\n        totalSherX = total;\n      } else {\n        // NOTE: Inside the _doSherX() call tokens are also transferred, potential gas optimalisation if tokens\n        // are transferred at once\n        token.safeTransfer(_payout, total);\n      }\n    }\n\n    if (totalUnallocatedSherX > 0) {\n      // Sum the SherX that is used from the pool + the SherX unallocated as rewards\n      totalSherX = totalSherX.add(totalUnallocatedSherX);\n    }\n    if (totalSherX == 0) {\n      return;\n    }\n\n    // NOTE: sx20().totalSupply is always > 0 when this codes hit.\n\n    uint256 curTotalUsdPool = LibSherX.viewAccrueUSDPool();\n    uint256 excludeUsd = _doSherX(_payout, _exclude, curTotalUsdPool, totalSherX);\n\n    // usd excluded, divided by the price per SherX token = amount of sherx to not burn.\n    uint256 deduction =\n      excludeUsd.div(curTotalUsdPool.div(SherXERC20Storage.sx20().totalSupply)).div(10e17);\n    // deduct that amount from the tokens being burned, to keep the same USD value\n    uint256 burnAmount = totalSherX.sub(deduction);\n\n    LibSherXERC20.burn(address(this), burnAmount);\n    LibSherX.settleInternalSupply(burnAmount);\n  }\n}\n\n\n",
        "CodeNames": [
            "Payout.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\n// Expensive operation, only execute to prevent tx reverts\nif (amounts[i]  ps.sherXUnderlying) {\n  LibPool.payOffDebtAll(tokens[i]);\n}\n"
                ],
                "Type": "  _doSherX  optimistically assumes premiums will be paid",
                "Description": "\nThe _doSherX function does not attempt to pay off the accrued premiums (\"pay off debt\") for most tokens, only for the ones that would otherwise revert the tx:\n\nsolidity\n// Expensive operation, only execute to prevent tx reverts\nif (amounts[i]  ps.sherXUnderlying) {\n  LibPool.payOffDebtAll(tokens[i]);\n}\n\n\nThe amounts = LibSherX.calcUnderlying(totalSherX) array is an optimistic view assuming all outstanding, accrued premiums would indeed be paid until now. However, it could be that a protocol does not have enough balance to pay out these premiums and updating the state using LibPool.payOffDebtAll(tokens[i]); would fail for a token.\n\nAn inflated amount is then paid out to the user based on the optimistic calcUnderlying call.\n\nEvert0x (Sherlock) acknowledged(https://github.com/code-423n4/2021-07-sherlock-findings/issues/107#issuecomment-889148550):\n  Fair point, the protocol is optimistic the protocols can payoff their debt.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../interfaces/IGovDev.sol';\n\ncontract GovDev is IGovDev {\n  function getGovDev() external view override returns (address) {\n    return LibDiamond.contractOwner();\n  }\n\n  function transferGovDev(address _govDev) external override {\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    require(_govDev != LibDiamond.contractOwner(), 'SAME_DEV');\n    LibDiamond.setContractOwner(_govDev);\n  }\n\n  function updateSolution(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) external override {\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    return LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n  }\n}\n\n\n",
        "CodeNames": [
            "GovDev.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\n// https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/GovDev.sol#L25\nfunction updateSolution(IDiamondCut.FacetCut[] memory _diamondCut,address _init,bytes memory _calldata) external override {\n  require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n  return LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n}\n"
                ],
                "Type": " reputation risks with  updateSolution ",
                "Description": "\nGovDev.sol has a function updateSolution to upgrade parts of the contract via the Diamond construction.\nVia updateSolution, any functionality can be changed and all the funds can be accessed/rugged.\nEven if this is well intended the project could still be called out resulting in a reputation risk, see for example(https://twitter.com/RugDocIO/status/1411732108029181960).\n\nNote: there is a function transferGovDev which can be used to disable the updateSolution\nsolidity\n// https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/GovDev.sol#L25\nfunction updateSolution(IDiamondCut.FacetCut[] memory _diamondCut,address _init,bytes memory _calldata) external override {\n  require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n  return LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n}\n\n",
                "Repair": "Recommend applying extra safeguards for example to limit the time period where updateSolution can be used.\n\nEvert0x (Sherlock) acknowledged(https://github.com/code-423n4/2021-07-sherlock-findings/issues/4#issuecomment-889940845):\n  Fair point, although we are not anonymous, we still want to mitigate this risk.\n\n I'm thinking something like this\n update is pushed, everyone can review the code changes\n 14 days of waiting, people are able to get their funds out\n update is executed.\n\n Downside is that it doesn't allow us to fix potential critical issues fast.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../interfaces/IGov.sol';\n\nimport '../storage/GovStorage.sol';\nimport '../storage/PoolStorage.sol';\nimport '../storage/SherXStorage.sol';\n\ncontract Gov is IGov {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //\n  // Modifiers\n  //\n\n  modifier onlyGovMain() {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    _;\n  }\n\n  //\n  // View methods\n  //\n\n  function getGovMain() external view override returns (address) {\n    return GovStorage.gs().govMain;\n  }\n\n  function getWatsons() external view override returns (address) {\n    return GovStorage.gs().watsonsAddress;\n  }\n\n  function getWatsonsSherXWeight() external view override returns (uint16) {\n    return GovStorage.gs().watsonsSherxWeight;\n  }\n\n  function getWatsonsSherxLastAccrued() external view override returns (uint40) {\n    return GovStorage.gs().watsonsSherxLastAccrued;\n  }\n\n  function getWatsonsSherXPerBlock() public view override returns (uint256) {\n    GovStorage.Base storage gs = GovStorage.gs();\n    SherXStorage.Base storage sx = SherXStorage.sx();\n\n    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(uint16(-1));\n  }\n\n  function getWatsonsUnmintedSherX() external view override returns (uint256) {\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    return block.number.sub(gs.watsonsSherxLastAccrued).mul(getWatsonsSherXPerBlock());\n  }\n\n  function getUnstakeWindow() external view override returns (uint40) {\n    return GovStorage.gs().unstakeWindow;\n  }\n\n  function getCooldown() external view override returns (uint40) {\n    return GovStorage.gs().unstakeCooldown;\n  }\n\n  function getTokensStaker() external view override returns (IERC20[] memory) {\n    return GovStorage.gs().tokensStaker;\n  }\n\n  function getTokensSherX() external view override returns (IERC20[] memory) {\n    return GovStorage.gs().tokensSherX;\n  }\n\n  function getProtocolIsCovered(bytes32 _protocol) external view override returns (bool) {\n    return GovStorage.gs().protocolIsCovered[_protocol];\n  }\n\n  function getProtocolManager(bytes32 _protocol) external view override returns (address) {\n    // NOTE: UNUSED\n    return GovStorage.gs().protocolManagers[_protocol];\n  }\n\n  function getProtocolAgent(bytes32 _protocol) external view override returns (address) {\n    return GovStorage.gs().protocolAgents[_protocol];\n  }\n\n  //\n  // State changing methods\n  //\n\n  function setInitialGovMain(address _govMain) external override {\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    require(_govMain != address(0), 'ZERO_GOV');\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    require(gs.govMain == address(0), 'ALREADY_SET');\n\n    gs.govMain = _govMain;\n  }\n\n  function transferGovMain(address _govMain) external override onlyGovMain {\n    require(_govMain != address(0), 'ZERO_GOV');\n    require(GovStorage.gs().govMain != _govMain, 'SAME_GOV');\n    GovStorage.gs().govMain = _govMain;\n  }\n\n  function setWatsonsAddress(address _watsons) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    require(_watsons != address(0), 'ZERO_WATS');\n    require(gs.watsonsAddress != _watsons, 'SAME_WATS');\n    gs.watsonsAddress = _watsons;\n  }\n\n  function setUnstakeWindow(uint40 _unstakeWindow) external override onlyGovMain {\n    require(_unstakeWindow < 25000000, 'MAX'); // ~ approximate 10 years of blocks\n    GovStorage.gs().unstakeWindow = _unstakeWindow;\n  }\n\n  function setCooldown(uint40 _period) external override onlyGovMain {\n    require(_period < 25000000, 'MAX'); // ~ approximate 10 years of blocks\n    GovStorage.gs().unstakeCooldown = _period;\n  }\n\n  function protocolAdd(\n    bytes32 _protocol,\n    address _eoaProtocolAgent,\n    address _eoaManager,\n    IERC20[] memory _tokens\n  ) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(!gs.protocolIsCovered[_protocol], 'COVERED');\n    gs.protocolIsCovered[_protocol] = true;\n\n    protocolUpdate(_protocol, _eoaProtocolAgent, _eoaManager);\n    protocolDepositAdd(_protocol, _tokens);\n  }\n\n  function protocolUpdate(\n    bytes32 _protocol,\n    address _eoaProtocolAgent,\n    address _eoaManager\n  ) public override onlyGovMain {\n    require(_protocol != bytes32(0), 'ZERO_PROTOCOL');\n    require(_eoaProtocolAgent != address(0), 'ZERO_AGENT');\n    require(_eoaManager != address(0), 'ZERO_MANAGER');\n\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.protocolIsCovered[_protocol], 'NOT_COVERED');\n\n    // NOTE: UNUSED\n    gs.protocolManagers[_protocol] = _eoaManager;\n    gs.protocolAgents[_protocol] = _eoaProtocolAgent;\n  }\n\n  function protocolDepositAdd(bytes32 _protocol, IERC20[] memory _tokens)\n    public\n    override\n    onlyGovMain\n  {\n    require(_protocol != bytes32(0), 'ZERO_PROTOCOL');\n    require(_tokens.length > 0, 'ZERO');\n\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.protocolIsCovered[_protocol], 'NOT_COVERED');\n\n    for (uint256 i; i < _tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(_tokens[i]);\n      require(ps.premiums, 'INIT');\n      require(!ps.isProtocol[_protocol], 'ALREADY_ADDED');\n\n      ps.isProtocol[_protocol] = true;\n      ps.protocols.push(_protocol);\n    }\n  }\n\n  function protocolRemove(bytes32 _protocol) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.protocolIsCovered[_protocol], 'NOT_COVERED');\n\n    for (uint256 i; i < gs.tokensSherX.length; i++) {\n      IERC20 token = gs.tokensSherX[i];\n\n      PoolStorage.Base storage ps = PoolStorage.ps(token);\n      // basically need to check if accruedDebt > 0, but this is true in case protocolPremium > 0\n      require(ps.protocolPremium[_protocol] == 0, 'DEBT');\n      require(!ps.isProtocol[_protocol], 'POOL_PROTOCOL');\n    }\n    delete gs.protocolIsCovered[_protocol];\n    delete gs.protocolManagers[_protocol];\n    delete gs.protocolAgents[_protocol];\n  }\n\n  function tokenInit(\n    IERC20 _token,\n    address _govPool,\n    ILock _lock,\n    bool _protocolPremium\n  ) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(address(_token) != address(0), 'ZERO_TOKEN');\n\n    if (_govPool != address(0)) {\n      ps.govPool = _govPool;\n    }\n    require(ps.govPool != address(0), 'ZERO_GOV');\n\n    if (address(_lock) != address(0)) {\n      if (address(ps.lockToken) == address(0)) {\n        require(_lock.getOwner() == address(this), 'OWNER');\n        require(_lock.totalSupply() == 0, 'SUPPLY');\n        // If not native (e.g. NOT SherX), verify underlying mapping\n        if (address(_token) != address(this)) {\n          require(_lock.underlying() == _token, 'UNDERLYING');\n        }\n        ps.lockToken = _lock;\n      }\n      if (address(ps.lockToken) == address(_lock)) {\n        require(!ps.stakes, 'STAKES_SET');\n        ps.stakes = true;\n        gs.tokensStaker.push(_token);\n      } else {\n        revert('WRONG_LOCK');\n      }\n    }\n\n    if (_protocolPremium) {\n      require(!ps.premiums, 'PREMIUMS_SET');\n      ps.premiums = true;\n      gs.tokensSherX.push(_token);\n    }\n  }\n\n  function tokenDisableStakers(IERC20 _token, uint256 _index) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(gs.tokensStaker[_index] == _token, 'INDEX');\n    require(ps.sherXWeight == 0, 'ACTIVE_WEIGHT');\n\n    delete ps.stakes;\n    // lockToken is kept, as stakers should be able to unstake\n    // staking can be reenabled by calling tokenInit\n    gs.tokensStaker[_index] = gs.tokensStaker[gs.tokensStaker.length - 1];\n    gs.tokensStaker.pop();\n  }\n\n  function tokenDisableProtocol(IERC20 _token, uint256 _index) external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(gs.tokensSherX[_index] == _token, 'INDEX');\n    require(ps.totalPremiumPerBlock == 0, 'ACTIVE_PREMIUM');\n    // Can not remove with active underlying, SherX holders will see drop in underlying value\n    require(ps.sherXUnderlying == 0, 'ACTIVE_SHERX');\n\n    delete ps.premiums;\n    gs.tokensSherX[_index] = gs.tokensSherX[gs.tokensSherX.length - 1];\n    gs.tokensSherX.pop();\n  }\n\n  // Unloading all tokens, likely before calling tokenRemove\n  function tokenUnload(\n    IERC20 _token,\n    IRemove _native,\n    address _remaining\n  ) external override onlyGovMain {\n    require(address(_native) != address(0), 'ZERO_NATIVE');\n    require(_remaining != address(0), 'ZERO_REMAIN');\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(ps.govPool != address(0), 'EMPTY');\n\n    // Protocol are technically still able to deposit, ps.premiums is still true\n    // This makes sure the sherx underlying doesn't grow anymore\n    // this function is called before the disable protocol\n    // disable stakes --> unload tokens --> disable protocol (sherx) --> remove\n\n    require(!ps.stakes, 'STAKES_SET');\n    require(ps.totalPremiumPerBlock == 0, 'ACTIVE_PREMIUM');\n    require(address(ps.strategy) == address(0), 'ACTIVE_STRATEGY');\n\n    uint256 totalToken = ps.firstMoneyOut.add(ps.sherXUnderlying);\n\n    // `firstMoneyOut` and `sherXUnderlying` are two 'pools' that needs to be swapped\n    // in a single transaction.\n    // If `sherXUnderlying` is not swapped in a single tx, the price of SherX (underlying value)\n    // will drop\n    // If `firstMoneyOut` is not swapped in a single tx, the buffer will be reduced in $ value\n    // This code piece swaps these tokens for other tokens in the solution\n    // The goal is to keep the current $ value of these two 'pools' somewhat equal before/after swap\n    if (totalToken > 0) {\n      _token.approve(address(_native), totalToken);\n\n      (IERC20 newToken, uint256 newFmo, uint256 newSherxUnderlying) =\n        _native.swap(_token, ps.firstMoneyOut, ps.sherXUnderlying);\n\n      PoolStorage.Base storage ps2 = PoolStorage.ps(newToken);\n      require(ps2.govPool != address(0), 'EMPTY_SWAP');\n\n      ps2.stakeBalance = ps2.stakeBalance.add(newFmo);\n      ps2.firstMoneyOut = ps2.firstMoneyOut.add(newFmo);\n      ps2.sherXUnderlying = ps2.sherXUnderlying.add(newSherxUnderlying);\n    }\n\n    uint256 totalFee = ps.unallocatedSherX;\n    if (totalFee > 0) {\n      IERC20(address(this)).safeTransfer(_remaining, totalFee);\n      delete ps.unallocatedSherX;\n    }\n\n    uint256 balance = ps.stakeBalance.sub(ps.firstMoneyOut);\n    if (balance > 0) {\n      _token.safeTransfer(_remaining, balance);\n      delete ps.stakeBalance;\n    }\n\n    delete ps.sherXUnderlying;\n    delete ps.firstMoneyOut;\n  }\n\n  function tokenRemove(IERC20 _token) external override onlyGovMain {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    require(ps.govPool != address(0), 'EMPTY');\n    require(!ps.stakes, 'STAKES_SET');\n    require(!ps.premiums, 'PREMIUMS_SET');\n    require(ps.protocols.length == 0, 'ACTIVE_PROTOCOLS');\n    require(ps.stakeBalance == 0, 'BALANCE_SET');\n    // NOTE: removed because firstMoneyOut will always be less or equal to stakeBalance\n    require(ps.unallocatedSherX == 0, 'SHERX_SET');\n\n    delete ps.govPool;\n    delete ps.lockToken;\n    delete ps.activateCooldownFee;\n    delete ps.sherXWeight;\n    delete ps.sherXLastAccrued;\n\n    // NOTE: storage variables need to be kept. To make sure readding the token works\n    // IF readding the token, verify off chain if the storage is sufficient.\n    // Create re-adding plan off chain if this isn't the case. (e.g. clean storage by doing calls)\n    //delete ps.sWithdrawn\n    //delete ps.sWeight;\n\n    delete ps.totalPremiumLastPaid;\n  }\n}\n\n\n",
        "CodeNames": [
            "Gov.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\n// https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309\nfunction doYield(ILock token,address from, address to, uint256 amount) private {\n...\nps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);\n\n//https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108\n function payout( address _payout, IERC20[] memory _tokens, uint256[] memory _firstMoneyOut, uint256[] memory _amounts, uint256[] memory _unallocatedSherX,  address _exclude ) external override onlyGovPayout {\n    // all pools (including SherX pool) can be deducted fmo and balance\n    // deducting balance will reduce the users underlying value of stake token\n    // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards\n    // for users that did not claim them (e.g materialized them and included in SherX pool)\n....\n    // Subtract from unallocated, as the tokens are now allocated to this payout call\n        ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);\n"
                ],
                "Type": " Yield distribution after large payout seems unfair",
                "Description": "\nWhen a large payout occurs, it will lower unallocatedSherX. This could mean some parties might not be able to get their Yield.\n\nThe first couple of users (for which harvest is called or which transfer tokens) will be able to get their full Yield, until the moment unallocatedSherX is depleted. The next users don't get any yield at all. This doesn't seem fair.\n\nsolidity\n// https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309\nfunction doYield(ILock token,address from, address to, uint256 amount) private {\n...\nps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);\n\n//https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108\n function payout( address _payout, IERC20[] memory _tokens, uint256[] memory _firstMoneyOut, uint256[] memory _amounts, uint256[] memory _unallocatedSherX,  address _exclude ) external override onlyGovPayout {\n    // all pools (including SherX pool) can be deducted fmo and balance\n    // deducting balance will reduce the users underlying value of stake token\n    // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards\n    // for users that did not claim them (e.g materialized them and included in SherX pool)\n....\n    // Subtract from unallocated, as the tokens are now allocated to this payout call\n        ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);\n\n\n",
                "Repair": "Recommend that If unallocatedSherX is insufficient to provide for all the yields, only give the yields partly (so that each user gets their fair share).\n\nEvert0x (Sherlock) disputed(https://github.com/code-423n4/2021-07-sherlock-findings/issues/50#issuecomment-889996060):\n  Not only unallocatedSherX is subtracted but also sWeight, which is used to calculate the reward. I wrote some extra tests and in my experience the remaining SherX (in the unallocatedSherX variable) is splitted in a fair way.\n\nEvert0x (Sherlock) confirmed(https://github.com/code-423n4/2021-07-sherlock-findings/issues/50#issuecomment-891724441):\n  Together with gpersoon I discussed both issue #49 and #50 and based on both findings we found a med-risk issue. In case payout() is called with _unallocatedSherX  0 and a user called harvest() before the payout call. It blocks the user from calling harvest() again. + blocks the lock token transfer.\n\n Mitigations step is to stop calling payout() with _unallocatedSherX  0\n\n\n"
            }
        ]
    }
]