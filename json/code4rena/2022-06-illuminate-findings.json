[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol'; // library of market place specific constructs\nimport './Swivel.sol'; // library of swivel specific constructs\nimport './Element.sol'; // library of element specific constructs\nimport './Safe.sol';\nimport './Cast.sol';\n\n/// @title Lender.sol\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users. \n/// @notice The contract holds the principal tokens for each market and mints an ERC-5095 position to users to represent their lent positions.\ncontract Lender {\n    error Unauthorized();\n    error NotEqual(string);\n    error Exists(address);\n    error Invalid(string);\n\n    /// @notice minimum amount of time the admin must wait before executing a withdrawl\n    uint256 constant public HOLD = 3 days;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace.sol contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal may be used by a lender\n    mapping(uint8 => bool) public paused;\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping (address => uint256) public withdrawals;\n\n    /// @notice emitted upon executed lend\n    event Lend(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 returned);\n    /// @notice emitted upon minted ERC5095 to user\n    event Mint(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n    /// @notice emitted on token withdrawal scheduling\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted on token withdrawal blocking\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted on a change to the feenominators array\n\n    /// @notice initializes the Lender contract\n    /// @param s the swivel contract\n    /// @param p the pendle contract\n    /// @param t the tempus contract\n    constructor(\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u underlying token's address, used to define the market being approved\n    /// @param m maturity of the underlying token, used to define the market being approved\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful, false otherwise\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // max is the maximum integer value for a 256 unsighed integer\n        uint256 max = 2**256 - 1;\n\n        // approve the underlying for max per given principal\n        for (uint8 i; i < 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses. \n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {\n        uint256 len = u.length;\n        if (len != a.length) {\n            revert NotEqual('array length');\n        }\n        uint256 max = 2**256 - 1;\n\n        for (uint256 i; i < len; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        feenominator = f;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists(marketPlace);\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on illuminate\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful, false otherwise\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public returns (bool) {\n        //use market interface to fetch the market for the given market pair\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        //use safe transfer lib and ERC interface...\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n        //use ERC5095 interface...\n        IERC5095(principalToken(u, m)).mint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method signature for both illuminate and yield\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y yieldspace pool that will execute the swap for the principal token\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y\n    ) public unpaused(p) returns (uint256) {\n        // check the principal is illuminate or yield\n        if (p != uint8(MarketPlace.Principals.Illuminate) && p != uint8(MarketPlace.Principals.Yield)) {\n            revert Invalid('principal');\n        }\n\n        // uses yield token interface...\n        IYield pool = IYield(y);\n\n        // the yield token must match the market pair\n        if (address(pool.base()) != u) {\n            revert NotEqual('underlying');\n        } else if (pool.maturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // transfer from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Purchase yield PTs to lender.sol (address(this))\n            uint256 returned = yield(u, y, a - calculateFee(a), address(this));\n            // Mint and distribute equivalent illuminate PTs\n            IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n            \n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n        else {\n            // Purchase illuminate PTs directly to msg.sender\n            uint256 returned = yield(u, y, a - calculateFee(a), msg.sender);\n\n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n    }\n\n    /// @notice lend method signature for swivel\n    /// @dev lends to yield pool. remaining balance is sent to the yield pool\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y yield pool\n    /// @param o array of swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        {\n            // returned represents the number of underlying tokens to lend to yield\n            uint256 returned;\n\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {\n                    revert NotEqual('maturity');\n                }\n\n                {\n                    uint256 amount = a[i];\n                    // Determine the fee\n                    uint256 fee = calculateFee(amount);\n                    // Track accumulated fees\n                    totalFee += fee;\n                    // Amount lent for this order\n                    uint256 amountLent = amount - fee;\n                    // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                    lent += amountLent;\n                    // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                    returned += amountLent * order.premium / order.principal;\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n      \n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n\n    /// @notice lend method signature for element\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed deadline is a timestamp by which the swap must be executed\n    /// @param e element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) public unpaused(p) returns (uint256) {\n        // Get the principal token for this market for element\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // the element token must match the market pair\n        if (IElementToken(principal).underlying() != u) {\n            revert NotEqual('underlying');\n        } else if (IElementToken(principal).unlockTimestamp() > m) {\n            revert NotEqual('maturity');\n        }\n        // Transfer underlying token from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] += calculateFee(a);\n\n        uint256 purchased;\n        {\n            // Create the variables needed to execute an element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000',\n                poolId: i,\n                amount: a - calculateFee(a),\n                kind: Element.SwapKind.In,\n                assetIn: Any(u),\n                assetOut: Any(principal)\n            });\n\n            // Conduct the swap on element\n            purchased = IElement(e).swap(swap, fund, r, d);\n        }\n\n        emit Lend(p, u, m, purchased);\n        return purchased;\n    }\n\n    /// @notice lend method signature for pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        IPendleToken token = IPendleToken(principal);\n\n        // confirm that we are in the correct market\n        if (token.yieldToken() != u) {\n            revert NotEqual('underlying');\n        } else if (token.expiry() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = calculateFee(a);\n            fees[u] += fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0];\n\n        }\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for tempus\n    /// @dev This method can be called before maturity to lend to Tempus while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param t tempus pool that houses the underlying principal tokens\n    /// @param x tempus amm that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n        {\n            // Instantiate market and tokens\n            address principal = IMarketPlace(marketPlace).markets(u, m, p);\n            if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n                revert NotEqual('underlying');\n            } else if (ITempus(principal).maturityTime() > m) {\n                revert NotEqual('maturity');\n            }\n\n            // Get the underlying token\n            IERC20 underlyingToken = IERC20(u);\n\n            // Transfer funds from user to Illuminate, Scope to avoid stack limit\n            Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n        }\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r minimum number of tokens to lend (sets a limit on the order)\n    /// @param x amm that is used to conduct the swap\n    /// @param s contract that holds the principal token for this market\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        address s\n    ) public unpaused(p) returns (uint256) {\n\n        // Get the principal token for this market for this market\n        ISenseToken token = ISenseToken(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Verify that the underlying and maturity match up\n        if (token.underlying() != u) { // gauruntee the input token is the right token\n            revert NotEqual('underlying'); \n        } else if (ISense(s).pt() != address(token)) {\n            revert NotEqual('principal token'); \n        } else if (ISense(x).maturity() > m) { // gauruntee the input amm has the correct maturity\n            revert NotEqual('maturity');\n        }\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine lent amount after fees\n            lent = a - fee;\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Swap those tokens for the principal tokens\n        uint256 returned = ISense(x).swapUnderlyingForPTs(s, m, lent, r);\n\n        // Get the address of the ERC5095 token for this market\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n\n        // Mint the illuminate tokens based on the returned amount\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice this method can be called before maturity to lend to APWine while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the minimum amount of zero-coupon tokens to return accounting for slippage\n    /// @param pool the address of a given APWine pool\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        address pool,\n        address aave,\n        uint256 i\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        if (IAPWineToken(principal).getUnderlyingOfIBTAddress() != u) {\n            revert NotEqual('underlying');\n        }\n        // Dont necessarily need to validate APWINE maturity (They have 1 maturity per underlying)\n        // Potentially add redundant implied maturity calculation\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine the amount lent after fees\n            lent = a - fee;\n        }\n\n        // Deposit into aave\n        IAave(aave).deposit(u, lent, address(this), 0);\n\n        // Swap on the APWine Pool using the provided market and params\n        uint256 returned = IAPWineRouter(pool).swapExactAmountIn(i, 1, lent, 0, r, address(this));\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @dev lend method signature for Notional\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        INotional token = INotional(principal);\n\n        // Verify that the underlying and maturity match up\n        (IERC20 underlying, ) = token.getUnderlyingToken();\n        if (address(underlying) != u) {\n            revert NotEqual('underlying');\n        } else if (token.getMaturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Notional Token wrapper\n        uint256 returned = token.deposit(a - fee, address(this));\n\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice transfers excess funds to yield pool after principal tokens have been lent out\n    /// @dev this method is only used by the yield, illuminate and swivel protocols\n    /// @param u address of an underlying asset\n    /// @param y the yield pool to lend to\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the receiving address for PTs\n    /// @return uint256 the amount of tokens sent to the yield pool\n    function yield(\n        address u,\n        address y,\n        uint256 a,\n        address r\n    ) internal returns (uint256) {\n        // preview exact swap slippage on yield\n        uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));\n\n        // send the remaing amount to the given yield pool\n        Safe.transfer(IERC20(u), y, a);\n\n        // lend out the remaining tokens in the yield pool\n        IYield(y).sellBase(r, returned);\n\n        return returned;\n    }\n\n    /// @notice withdraws accumulated lending fees of the underlying token\n    /// @param e address of the underlying token to withdraw\n    /// @return bool true if successful\n    function withdrawFee(address e) external authorized(admin) returns (bool) {\n        // Get the token to be withdrawn\n        IERC20 token = IERC20(e);\n\n        // Get the balance to be transferred\n        uint256 balance = fees[e];\n\n        // Reset accumulated fees of the token to 0\n        fees[e] = 0;\n\n        // Transfer the accumulated fees to the admin\n        Safe.transfer(token, admin, balance);\n        return true;\n    }\n\n    /// @notice this method returns the fee based on the amount passed to it. If the feenominator is 0, then there is no fee.\n    /// @param a amount of underlying tokens to calculate the fee for\n    /// @return uint256 The total for for the given amount\n    function calculateFee(uint256 a) internal view returns (uint256) {\n        return feenominator > 0 ? a / feenominator : 0;\n    }\n\n    /// @notice allows the admin to schedule the withdrawal of tokens\n    /// @param e address of (erc20) token to withdraw\n    /// @return bool true if successful\n    function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n        uint256 when = block.timestamp + HOLD;\n        withdrawals[e] = when;\n\n        emit ScheduleWithdrawal(e, when);\n        return true;\n    }\n\n    /// @notice emergency function to block unplanned withdrawals\n    /// @param e address of token withdrawal to block\n    /// @return bool true if successful\n    function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n        withdrawals[e] = 0;\n\n        emit BlockWithdrawal(e);\n        return true;\n    }\n\n    /// @notice allows the admin to withdraw the given token, provided the holding period has been observed\n    /// @param e Address of token to withdraw\n    /// @return bool true if successful\n    function withdraw(address e) external authorized(admin) returns (bool) {\n        uint256 when = withdrawals[e];\n        require (when != 0, 'no withdrawal scheduled');\n  \n        require (block.timestamp >= when, 'withdrawal still on hold');\n  \n        withdrawals[e] = 0;\n  \n        IERC20 token = IERC20(e);\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\n  \n        return true;\n    }\n\n    /// @notice retrieves the ERC5095 token for the given market\n    /// @param u address of the underlying\n    /// @param m uint256 representing the maturity of the market\n    /// @return address of the ERC5095 token for the market\n    function principalToken(address u, uint256 m) internal returns (address) {\n        return IMarketPlace(marketPlace).markets(u, m, 0);\n    }\n\n    /// @notice pauses a market and prevents execution of all lending for that market\n    /// @param p principal enum value\n    /// @param b bool representing whether to pause or unpause\n    /// @return bool true if successful\n    function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n        paused[p] = b;\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param p principal enum value\n    modifier unpaused(uint8 p) {\n        if (paused[p]) {\n            revert Invalid('paused');\n        }\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Lender.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] calldata a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        // returned represents the number of underlying tokens to lend to yield\n        uint256 returned;\n\n        {\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity  m) {\n                    revert NotEqual('maturity');\n                }\n                // Determine the fee\n                uint256 fee = calculateFee(a[i]);\n                // Track accumulated fees\n                totalFee += fee;\n                // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                lent += a[i] fee;\n                // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                returned += (a[i] fee) * (order.premium / order.principal);\n\n                unchecked {\n                    i++;\n                }\n            }\n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n"
                ],
                "Type": " Division Before Multiplication Can Lead To Zero Rounding Of Return Amount",
                "Description": "\nThere is a division before multiplication bug that exists in lend()(https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280) for the Swivel case.\n\nIf order.premium is less than order.principal then returned will round to zero due to the integer rounding.\n\nWhen this occurs the user's funds are essentially lost. That is because they transfer in the underlying tokens but the amount sent to yield(u, y, returned, address(this)) will be zero.\n\n\nsolidity\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] calldata a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        // returned represents the number of underlying tokens to lend to yield\n        uint256 returned;\n\n        {\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity  m) {\n                    revert NotEqual('maturity');\n                }\n                // Determine the fee\n                uint256 fee = calculateFee(a[i]);\n                // Track accumulated fees\n                totalFee += fee;\n                // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                lent += a[i] fee;\n                // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                returned += (a[i] fee) * (order.premium / order.principal);\n\n                unchecked {\n                    i++;\n                }\n            }\n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n\n\nSpecifically the function returned += (a[i] fee) * (order.premium / order.principal);\n\n",
                "Repair": "\nThe multiplication should occur before division, that is ((a[i] fee) * order.premium) / order.principal);.\n\nJTraversa (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/48) \n\nAlex the Entreprenerd (warden) commented(https://github.com/code-423n4/2022-06-illuminate-findings/issues/48#issuecomment-1195909365):\n  Also see how Swivel Calculates it(https://github.com/Swivel-Finance/swivel/blob/0ce3edfd05e3546a10ff9d751ead219c0ba35d21/contracts/v2/swivel/Swivel.sol#L131)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n            address[] memory path = new address[(2);\n            path[0] = u;\n            path[1] = principal;\n\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a fee, r, path, address(this), d)[0];\n"
                ],
                "Type": " Pendle Uses Wrong Return Value For  swapExactTokensForTokens() ",
                "Description": "\nThe function swapExactTokensForTokens() will return and array with the 0 index being the input amount follow by each output amount. The 0 index is incorrectly used in Pendle lend() function as the output amount. As a result the value of returned will be the invalid (i.e. the input rather than the output).\n\nSince this impacts how many PTs will be minted to the msg.sender, the value will very likely be significantly over or under stated depending on the exchange rate. Hence the msg.sender will receive an invalid number of PT tokens.\n\n\nsolidity\n            address[] memory path = new address[(2);\n            path[0] = u;\n            path[1] = principal;\n\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a fee, r, path, address(this), d)[0];\n\n\n",
                "Repair": "\nThe amount of principal returned should be index 1 of the array returned by swapExactTokensForTokens().\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/94)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [
                    "lend",
                    "illuminateToken.balanceOf(address(this))  0",
                    "depositAndFix"
                ],
                "Type": " Tempus lend method wrongly calculates amount of iPT tokens to mint",
                "Description": "\nThe Tempus lend method calculates the amount of tokens to mint as amountReturnedFromTempus lenderBalanceOfMetaPrincipalToken.\nThis seems wrong as there's no connection between the two items. Tempus has no relation to the iPT token.\n\n\nWrong amount of iPT will be minted to the user.\nIf the Lender contract has iPT balance, the function will revert, otherwise, user will get minted 0 iPT tokes.\n\n\nThis(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L469) is how the lend method calculates the amount of iPT tokens to mint:\n\n            uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a fee, true, r, d) -\n                illuminateToken.balanceOf(address(this));\n            illuminateToken.mint(msg.sender, returned);\n\nThe Tempus depositAndFix method does not return(https://etherscan.io/address/0xdB5fD0678eED82246b599da6BC36B56157E4beD8#code#F1#L127) anything.\nTherefore this calculation will revert if illuminateToken.balanceOf(address(this))  0, or will return 0 if the balance is 0.\n\nNote: there's another issue here where the depositAndFix sends wrong parameters I will submit it in another issue.]\n\n",
                "Repair": "\nI believe that what you intended to do is to check how many Tempus principal tokens the contract received.\n\nSo you need to check Lender's x.tempusPool().principalShare() before and after the swap, and the delta is the amount received.\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/222)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-11",
                "Location": [
                    "lend"
                ],
                "Type": " Not minting iPTs for lenders in several lend functions",
                "Description": "\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L192-L235\n\n\nUsing any of the lend function mentioned, will result in loss of funds to the lender as the funds are transferred from them but no iPTs are sent back to them!\n\nBasically making lending via these external PTs unusable.\n\n\nThere is no minting of iPTs to the lender (or at all) in the 2 lend functions below:<br\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367\n\nCorresponding to lending of (respectively):<br\nswivel<br\nelement<br\n\nFurthermore, in:<br\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L227-L234<br\nComment says \"Purchase illuminate PTs directly to msg.sender\", but this is not happening. sending yield PTs at best.\n\n",
                "Repair": "\nMint the appropriate amount of iPTs to the lender like in the rest of the lend functions.\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/391)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface IMarketPlace {\n    function markets(\n        address,\n        uint256,\n        uint8\n    ) external returns (address);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC20Metadata{\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n\ninterface IERC5095 is IERC2612 {\n    event Redeem(address, address, uint256);\n\n    function maturity() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function convertToUnderlying(uint256) external returns (uint256);\n\n    function convertToPrincipal(uint256) external returns (uint256);\n\n    function maxRedeem(address) external returns (uint256);\n\n    function previewRedeem(uint256) external returns (uint256);\n\n    function maxWithdraw(address) external returns (uint256);\n\n    function previewWithdraw(uint256) external returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function redeem(uint256, address, address) external returns (uint256);\n\n    function mint(address t, uint256 a) external returns (bool);\n\n    function burn(address t, uint256 a) external returns (bool);\n}\n\ninterface IAPWine {\n    function withdraw(address, uint256) external;\n}\n\ninterface ITempus {\n    function redeemToBacking(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ninterface ISwivel {\n    function redeemZcToken(\n        address u,\n        uint256 m,\n        uint256 a\n    ) external returns (bool);\n}\n\ninterface IYield {\n    function redeem(address to, uint256 amount) external returns (uint256);\n}\n\ninterface IPendle {\n    function redeemAfterExpiry(\n        bytes32,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ISense {\n    function redeem(\n        address,\n        uint256,\n        uint256\n    ) external;\n}\n\ninterface IElementToken {\n    function unlockTimestamp() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function withdrawPrincipal(uint256 amount, address destination) external;\n}\n\ninterface IYieldToken {\n    function redeem(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\ninterface INotional {\n    function maxRedeem(address) external returns (uint256);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Interfaces.sol\";\nimport \"./ERC20Permit.sol\";\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    constructor(address _underlying, uint256 _maturity, address _redeemer, address l, string memory name_, string memory symbol_, uint8 decimals_) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = l;\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, underlyingAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, underlyingAmount);     \n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, principalAmount);     \n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function mint(address t, uint256 a) external onlyAdmin(lender) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    /// @param a Admin address\n    modifier onlyAdmin(address a) {\n    require(msg.sender == a, 'sender must be admin');\n    _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Interfaces.sol",
            "ERC5095.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "redeem",
                    "underlyingAmount"
                ],
                "Type": " Allowance check always true in ERC5095 redeem",
                "Description": "\nIn redeem, it is checked that the allowance is larger than underlyingAmount, which is the return parameter (i.e., equal to 0 at that point). Therefore, this check is always true and there is no actual allowance check, allowing anyone to redeem for another user.\n\n",
                "Repair": "\nChange the underlyingAmount to principalAmount, which is the intended parameter.\n\nsourabhmarathe (Illuminate) disputed and commented(https://github.com/code-423n4/2022-06-illuminate-findings/issues/173#issuecomment-1171523121):\n  While we did not actually intend to audit the 5095 implementation, as 5095 itself is not yet final, we did describe its purpose in our codebase in the initial readme, and didn't specify that it was not in scope.\n (we wanted wardens to understand its role in our infra)\n \n With that context, we will leave it up to the judges whether or not to accept issues related to the ERC5095 token.\n\ngzeoneth (judge) commented(https://github.com/code-423n4/2022-06-illuminate-findings/issues/173#issuecomment-1186221171):\n  I think it is fair to accept issues related to the ERC5095 token.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-08",
                "Location": [
                    "redeem",
                    "authRedeem"
                ],
                "Type": " ERC5095 redeem/withdraw does not update allowances",
                "Description": "\nERC5095's redeem/withdraw allows an ERC20-approved account to redeem user's tokens, but does not update the allowance after burning.\n\n\nUser Mal can burn more tokens than Alice allowed him to.\nHe can set himself to be the receiver of the underlying, therefore Alice will lose funds.\n\n\nwithdraw(https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100) and redeem(https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L116) functions check that the msg.sender has enough approvals to redeem the tokens:\n\n                require(_allowance[holder][msg.sender] = underlyingAmount, 'not enough approvals');\n\nBut they do not update the allowances.\nThey then call authRedeem, which also does not update the allowances.\nTherefore, an approved user could \"re-use his approval\" again and again and redeem whole of approver's funds to himself.\n\n",
                "Repair": "\nUpdate the allowances upon spending.\n\nsourabhmarathe (Illuminate) confirmed and commented(https://github.com/code-423n4/2022-06-illuminate-findings/issues/245#issuecomment-1169166982):\n  While we did not actually intend to audit the 5095 itself, as 5095 itself is not yet final, we did describe its purpose in our codebase in the initial readme, and didn't specify that it was not in scope.\n \n With that context, we will leave it up to the judges whether or not to accept issues related to the ERC5095 token.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface IMarketPlace {\n    function markets(\n        address,\n        uint256,\n        uint8\n    ) external returns (address);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC20Metadata{\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n\ninterface IERC5095 is IERC2612 {\n    event Redeem(address, address, uint256);\n\n    function maturity() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function convertToUnderlying(uint256) external returns (uint256);\n\n    function convertToPrincipal(uint256) external returns (uint256);\n\n    function maxRedeem(address) external returns (uint256);\n\n    function previewRedeem(uint256) external returns (uint256);\n\n    function maxWithdraw(address) external returns (uint256);\n\n    function previewWithdraw(uint256) external returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function redeem(uint256, address, address) external returns (uint256);\n\n    function mint(address t, uint256 a) external returns (bool);\n\n    function burn(address t, uint256 a) external returns (bool);\n}\n\ninterface IAPWine {\n    function withdraw(address, uint256) external;\n}\n\ninterface ITempus {\n    function redeemToBacking(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ninterface ISwivel {\n    function redeemZcToken(\n        address u,\n        uint256 m,\n        uint256 a\n    ) external returns (bool);\n}\n\ninterface IYield {\n    function redeem(address to, uint256 amount) external returns (uint256);\n}\n\ninterface IPendle {\n    function redeemAfterExpiry(\n        bytes32,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ISense {\n    function redeem(\n        address,\n        uint256,\n        uint256\n    ) external;\n}\n\ninterface IElementToken {\n    function unlockTimestamp() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function withdrawPrincipal(uint256 amount, address destination) external;\n}\n\ninterface IYieldToken {\n    function redeem(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\ninterface INotional {\n    function maxRedeem(address) external returns (uint256);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\n\nlibrary Element {\n    // TODO are these established element names? kind? not type? etc...\n    // TODO In, Out vs GIVEN_IN, GIVEN_OUT. If those names are needed they should be GivenIn etc...\n    enum SwapKind {\n        In,\n        Out\n    }\n\n    // TODO audit structure / names / order-of-members etc...\n    struct SingleSwap {\n        bytes userData;\n        bytes32 poolId;\n        uint256 amount;\n        SwapKind kind;\n        Any assetIn;\n        Any assetOut;\n    }\n\n    struct FundManagement {\n        address sender;\n        address payable recipient;\n        bool fromInternalBalance;\n        bool toInternalBalance;\n    }\n}\n\n\n",
        "CodeNames": [
            "Interfaces.sol",
            "Element.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "redeem",
                    "redeem(o, m, amount)",
                    "amount"
                ],
                "Type": " Redeem Sense can be bricked",
                "Description": "\nSense's redeem can be totally DOSd due to user supplied input.\n\n\nUsing this attack, Sense market can not be redeemed.\n\n\nThis(https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L253:#L262) is how Sense market is being redeemed:\n\n            IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n            uint256 amount = token.balanceOf(lender);\n            Safe.transferFrom(token, lender, address(this), amount);\n            ISense(d).redeem(o, m, amount);\n\nThe problem is that d is user supplied input and the function only tries to redeem the amount that was transferred from Lender.\n\nA user can supply malicious d contract which does nothing on redeem(o, m, amount).\nThe user will then call Redeemer's redeem with his malicious contract.\nRedeemer will transfer all the prinicipal from Lender to itself, will call d (noop), and finish.\nSense market has not been redeemed.\n\nNow if somebody tries to call Sense market's redeem again, the amount variable will be 0, and Redeemer will try to redeem 0 from Sense.\n\nAll the original principal is locked and lost in the contract,\nlike tears in rain.\n\n",
                "Repair": "\nI think you should either use a whitelisted Sense address, or send to ISense(d).redeem Redeemer's whole principal balance.\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/244)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-16",
                "Location": [
                    "redeem",
                    "maxRedeem",
                    "amount"
                ],
                "Type": " Unable to redeem from Notional",
                "Description": "\nThe maxRedeem function is a view function which only returns the balance of the Redeemer.sol contract. After this value is obtained, the PT is not redeemed from Notional. The user will be unable to redeem PT from Notional through Redeemer.sol.\n\n\nNotional code:\n\n        function maxRedeem(address owner) public view override returns (uint256) {\n            return balanceOf(owner);\n        }\n\n\nCall redeem(https://github.com/notional-finance/wrapped-fcash/blob/019cfa20369d5e0d9e7a38fea936cc649704780d/contracts/wfCashERC4626.sol#L205) from Notional using the amount from maxRedeem as the shares input after the call to maxRedeem.\n\nkenzo (warden) commented(https://github.com/code-423n4/2022-06-illuminate-findings/issues/341#issuecomment-1168420524):\n  Should be high severity as affects user funds.\n\ngzeoneth (judge) increased severity to High(https://github.com/code-423n4/2022-06-illuminate-findings/issues/341)\n\nsourabhmarathe (Illuminate) confirmed and commented(https://github.com/code-423n4/2022-06-illuminate-findings/issues/341#issuecomment-1219540859)\n This is confirmed as a high-risk issue.\n\n*\n\n \n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface IMarketPlace {\n    function markets(\n        address,\n        uint256,\n        uint8\n    ) external returns (address);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC20Metadata{\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n\ninterface IERC5095 is IERC2612 {\n    event Redeem(address, address, uint256);\n\n    function maturity() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function convertToUnderlying(uint256) external returns (uint256);\n\n    function convertToPrincipal(uint256) external returns (uint256);\n\n    function maxRedeem(address) external returns (uint256);\n\n    function previewRedeem(uint256) external returns (uint256);\n\n    function maxWithdraw(address) external returns (uint256);\n\n    function previewWithdraw(uint256) external returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function redeem(uint256, address, address) external returns (uint256);\n\n    function mint(address t, uint256 a) external returns (bool);\n\n    function burn(address t, uint256 a) external returns (bool);\n}\n\ninterface IAPWine {\n    function withdraw(address, uint256) external;\n}\n\ninterface ITempus {\n    function redeemToBacking(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ninterface ISwivel {\n    function redeemZcToken(\n        address u,\n        uint256 m,\n        uint256 a\n    ) external returns (bool);\n}\n\ninterface IYield {\n    function redeem(address to, uint256 amount) external returns (uint256);\n}\n\ninterface IPendle {\n    function redeemAfterExpiry(\n        bytes32,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ISense {\n    function redeem(\n        address,\n        uint256,\n        uint256\n    ) external;\n}\n\ninterface IElementToken {\n    function unlockTimestamp() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function withdrawPrincipal(uint256 amount, address destination) external;\n}\n\ninterface IYieldToken {\n    function redeem(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\ninterface INotional {\n    function maxRedeem(address) external returns (uint256);\n}\n\n\n",
        "CodeNames": [
            "Interfaces.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "mint"
                ],
                "Type": " Lender: no check for paused market on mint",
                "Description": "\nLender's mint function does not check(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172) whether the supplied market is paused.\n\n\nEven if a market is paused due to insolvency/bugs, an attacker can issue iPTs.\n\nThis renders the whole pause and insolvency protection mechanism ineffective.  See POC.\n\n\nLet's say market P has become insolvent, and Illuminate pauses that market, as it doesn't want to create further bad debt.\n\nLet's say P's principal tokens's value has declined severely in the market because of the insolvency.\n\nAn attacker can buy many worthless P principal tokens for cheap, then call Lender and mint from them iPT.\n\nThe attacker is now owed underlying which belongs to the legitimate users. There won't be enough funds to repay everybody.\n\n",
                "Repair": "\nCheck in mint that the market is not paused.\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/260)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface IMarketPlace {\n    function markets(\n        address,\n        uint256,\n        uint8\n    ) external returns (address);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC20Metadata{\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n\ninterface IERC5095 is IERC2612 {\n    event Redeem(address, address, uint256);\n\n    function maturity() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function convertToUnderlying(uint256) external returns (uint256);\n\n    function convertToPrincipal(uint256) external returns (uint256);\n\n    function maxRedeem(address) external returns (uint256);\n\n    function previewRedeem(uint256) external returns (uint256);\n\n    function maxWithdraw(address) external returns (uint256);\n\n    function previewWithdraw(uint256) external returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function redeem(uint256, address, address) external returns (uint256);\n\n    function mint(address t, uint256 a) external returns (bool);\n\n    function burn(address t, uint256 a) external returns (bool);\n}\n\ninterface IAPWine {\n    function withdraw(address, uint256) external;\n}\n\ninterface ITempus {\n    function redeemToBacking(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ninterface ISwivel {\n    function redeemZcToken(\n        address u,\n        uint256 m,\n        uint256 a\n    ) external returns (bool);\n}\n\ninterface IYield {\n    function redeem(address to, uint256 amount) external returns (uint256);\n}\n\ninterface IPendle {\n    function redeemAfterExpiry(\n        bytes32,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ISense {\n    function redeem(\n        address,\n        uint256,\n        uint256\n    ) external;\n}\n\ninterface IElementToken {\n    function unlockTimestamp() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function withdrawPrincipal(uint256 amount, address destination) external;\n}\n\ninterface IYieldToken {\n    function redeem(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\ninterface INotional {\n    function maxRedeem(address) external returns (uint256);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\n\nlibrary Element {\n    // TODO are these established element names? kind? not type? etc...\n    // TODO In, Out vs GIVEN_IN, GIVEN_OUT. If those names are needed they should be GivenIn etc...\n    enum SwapKind {\n        In,\n        Out\n    }\n\n    // TODO audit structure / names / order-of-members etc...\n    struct SingleSwap {\n        bytes userData;\n        bytes32 poolId;\n        uint256 amount;\n        SwapKind kind;\n        Any assetIn;\n        Any assetOut;\n    }\n\n    struct FundManagement {\n        address sender;\n        address payable recipient;\n        bool fromInternalBalance;\n        bool toInternalBalance;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol'; // library of market place specific constructs\nimport './Swivel.sol'; // library of swivel specific constructs\nimport './Element.sol'; // library of element specific constructs\nimport './Safe.sol';\nimport './Cast.sol';\n\n/// @title Lender.sol\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users. \n/// @notice The contract holds the principal tokens for each market and mints an ERC-5095 position to users to represent their lent positions.\ncontract Lender {\n    error Unauthorized();\n    error NotEqual(string);\n    error Exists(address);\n    error Invalid(string);\n\n    /// @notice minimum amount of time the admin must wait before executing a withdrawl\n    uint256 constant public HOLD = 3 days;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace.sol contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal may be used by a lender\n    mapping(uint8 => bool) public paused;\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping (address => uint256) public withdrawals;\n\n    /// @notice emitted upon executed lend\n    event Lend(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 returned);\n    /// @notice emitted upon minted ERC5095 to user\n    event Mint(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n    /// @notice emitted on token withdrawal scheduling\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted on token withdrawal blocking\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted on a change to the feenominators array\n\n    /// @notice initializes the Lender contract\n    /// @param s the swivel contract\n    /// @param p the pendle contract\n    /// @param t the tempus contract\n    constructor(\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u underlying token's address, used to define the market being approved\n    /// @param m maturity of the underlying token, used to define the market being approved\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful, false otherwise\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // max is the maximum integer value for a 256 unsighed integer\n        uint256 max = 2**256 - 1;\n\n        // approve the underlying for max per given principal\n        for (uint8 i; i < 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses. \n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {\n        uint256 len = u.length;\n        if (len != a.length) {\n            revert NotEqual('array length');\n        }\n        uint256 max = 2**256 - 1;\n\n        for (uint256 i; i < len; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        feenominator = f;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists(marketPlace);\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on illuminate\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful, false otherwise\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public returns (bool) {\n        //use market interface to fetch the market for the given market pair\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        //use safe transfer lib and ERC interface...\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n        //use ERC5095 interface...\n        IERC5095(principalToken(u, m)).mint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method signature for both illuminate and yield\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y yieldspace pool that will execute the swap for the principal token\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y\n    ) public unpaused(p) returns (uint256) {\n        // check the principal is illuminate or yield\n        if (p != uint8(MarketPlace.Principals.Illuminate) && p != uint8(MarketPlace.Principals.Yield)) {\n            revert Invalid('principal');\n        }\n\n        // uses yield token interface...\n        IYield pool = IYield(y);\n\n        // the yield token must match the market pair\n        if (address(pool.base()) != u) {\n            revert NotEqual('underlying');\n        } else if (pool.maturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // transfer from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Purchase yield PTs to lender.sol (address(this))\n            uint256 returned = yield(u, y, a - calculateFee(a), address(this));\n            // Mint and distribute equivalent illuminate PTs\n            IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n            \n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n        else {\n            // Purchase illuminate PTs directly to msg.sender\n            uint256 returned = yield(u, y, a - calculateFee(a), msg.sender);\n\n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n    }\n\n    /// @notice lend method signature for swivel\n    /// @dev lends to yield pool. remaining balance is sent to the yield pool\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y yield pool\n    /// @param o array of swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        {\n            // returned represents the number of underlying tokens to lend to yield\n            uint256 returned;\n\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {\n                    revert NotEqual('maturity');\n                }\n\n                {\n                    uint256 amount = a[i];\n                    // Determine the fee\n                    uint256 fee = calculateFee(amount);\n                    // Track accumulated fees\n                    totalFee += fee;\n                    // Amount lent for this order\n                    uint256 amountLent = amount - fee;\n                    // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                    lent += amountLent;\n                    // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                    returned += amountLent * order.premium / order.principal;\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n      \n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n\n    /// @notice lend method signature for element\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed deadline is a timestamp by which the swap must be executed\n    /// @param e element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) public unpaused(p) returns (uint256) {\n        // Get the principal token for this market for element\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // the element token must match the market pair\n        if (IElementToken(principal).underlying() != u) {\n            revert NotEqual('underlying');\n        } else if (IElementToken(principal).unlockTimestamp() > m) {\n            revert NotEqual('maturity');\n        }\n        // Transfer underlying token from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] += calculateFee(a);\n\n        uint256 purchased;\n        {\n            // Create the variables needed to execute an element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000',\n                poolId: i,\n                amount: a - calculateFee(a),\n                kind: Element.SwapKind.In,\n                assetIn: Any(u),\n                assetOut: Any(principal)\n            });\n\n            // Conduct the swap on element\n            purchased = IElement(e).swap(swap, fund, r, d);\n        }\n\n        emit Lend(p, u, m, purchased);\n        return purchased;\n    }\n\n    /// @notice lend method signature for pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        IPendleToken token = IPendleToken(principal);\n\n        // confirm that we are in the correct market\n        if (token.yieldToken() != u) {\n            revert NotEqual('underlying');\n        } else if (token.expiry() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = calculateFee(a);\n            fees[u] += fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0];\n\n        }\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for tempus\n    /// @dev This method can be called before maturity to lend to Tempus while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param t tempus pool that houses the underlying principal tokens\n    /// @param x tempus amm that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n        {\n            // Instantiate market and tokens\n            address principal = IMarketPlace(marketPlace).markets(u, m, p);\n            if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n                revert NotEqual('underlying');\n            } else if (ITempus(principal).maturityTime() > m) {\n                revert NotEqual('maturity');\n            }\n\n            // Get the underlying token\n            IERC20 underlyingToken = IERC20(u);\n\n            // Transfer funds from user to Illuminate, Scope to avoid stack limit\n            Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n        }\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r minimum number of tokens to lend (sets a limit on the order)\n    /// @param x amm that is used to conduct the swap\n    /// @param s contract that holds the principal token for this market\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        address s\n    ) public unpaused(p) returns (uint256) {\n\n        // Get the principal token for this market for this market\n        ISenseToken token = ISenseToken(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Verify that the underlying and maturity match up\n        if (token.underlying() != u) { // gauruntee the input token is the right token\n            revert NotEqual('underlying'); \n        } else if (ISense(s).pt() != address(token)) {\n            revert NotEqual('principal token'); \n        } else if (ISense(x).maturity() > m) { // gauruntee the input amm has the correct maturity\n            revert NotEqual('maturity');\n        }\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine lent amount after fees\n            lent = a - fee;\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Swap those tokens for the principal tokens\n        uint256 returned = ISense(x).swapUnderlyingForPTs(s, m, lent, r);\n\n        // Get the address of the ERC5095 token for this market\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n\n        // Mint the illuminate tokens based on the returned amount\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice this method can be called before maturity to lend to APWine while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the minimum amount of zero-coupon tokens to return accounting for slippage\n    /// @param pool the address of a given APWine pool\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        address pool,\n        address aave,\n        uint256 i\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        if (IAPWineToken(principal).getUnderlyingOfIBTAddress() != u) {\n            revert NotEqual('underlying');\n        }\n        // Dont necessarily need to validate APWINE maturity (They have 1 maturity per underlying)\n        // Potentially add redundant implied maturity calculation\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine the amount lent after fees\n            lent = a - fee;\n        }\n\n        // Deposit into aave\n        IAave(aave).deposit(u, lent, address(this), 0);\n\n        // Swap on the APWine Pool using the provided market and params\n        uint256 returned = IAPWineRouter(pool).swapExactAmountIn(i, 1, lent, 0, r, address(this));\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @dev lend method signature for Notional\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        INotional token = INotional(principal);\n\n        // Verify that the underlying and maturity match up\n        (IERC20 underlying, ) = token.getUnderlyingToken();\n        if (address(underlying) != u) {\n            revert NotEqual('underlying');\n        } else if (token.getMaturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Notional Token wrapper\n        uint256 returned = token.deposit(a - fee, address(this));\n\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice transfers excess funds to yield pool after principal tokens have been lent out\n    /// @dev this method is only used by the yield, illuminate and swivel protocols\n    /// @param u address of an underlying asset\n    /// @param y the yield pool to lend to\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the receiving address for PTs\n    /// @return uint256 the amount of tokens sent to the yield pool\n    function yield(\n        address u,\n        address y,\n        uint256 a,\n        address r\n    ) internal returns (uint256) {\n        // preview exact swap slippage on yield\n        uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));\n\n        // send the remaing amount to the given yield pool\n        Safe.transfer(IERC20(u), y, a);\n\n        // lend out the remaining tokens in the yield pool\n        IYield(y).sellBase(r, returned);\n\n        return returned;\n    }\n\n    /// @notice withdraws accumulated lending fees of the underlying token\n    /// @param e address of the underlying token to withdraw\n    /// @return bool true if successful\n    function withdrawFee(address e) external authorized(admin) returns (bool) {\n        // Get the token to be withdrawn\n        IERC20 token = IERC20(e);\n\n        // Get the balance to be transferred\n        uint256 balance = fees[e];\n\n        // Reset accumulated fees of the token to 0\n        fees[e] = 0;\n\n        // Transfer the accumulated fees to the admin\n        Safe.transfer(token, admin, balance);\n        return true;\n    }\n\n    /// @notice this method returns the fee based on the amount passed to it. If the feenominator is 0, then there is no fee.\n    /// @param a amount of underlying tokens to calculate the fee for\n    /// @return uint256 The total for for the given amount\n    function calculateFee(uint256 a) internal view returns (uint256) {\n        return feenominator > 0 ? a / feenominator : 0;\n    }\n\n    /// @notice allows the admin to schedule the withdrawal of tokens\n    /// @param e address of (erc20) token to withdraw\n    /// @return bool true if successful\n    function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n        uint256 when = block.timestamp + HOLD;\n        withdrawals[e] = when;\n\n        emit ScheduleWithdrawal(e, when);\n        return true;\n    }\n\n    /// @notice emergency function to block unplanned withdrawals\n    /// @param e address of token withdrawal to block\n    /// @return bool true if successful\n    function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n        withdrawals[e] = 0;\n\n        emit BlockWithdrawal(e);\n        return true;\n    }\n\n    /// @notice allows the admin to withdraw the given token, provided the holding period has been observed\n    /// @param e Address of token to withdraw\n    /// @return bool true if successful\n    function withdraw(address e) external authorized(admin) returns (bool) {\n        uint256 when = withdrawals[e];\n        require (when != 0, 'no withdrawal scheduled');\n  \n        require (block.timestamp >= when, 'withdrawal still on hold');\n  \n        withdrawals[e] = 0;\n  \n        IERC20 token = IERC20(e);\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\n  \n        return true;\n    }\n\n    /// @notice retrieves the ERC5095 token for the given market\n    /// @param u address of the underlying\n    /// @param m uint256 representing the maturity of the market\n    /// @return address of the ERC5095 token for the market\n    function principalToken(address u, uint256 m) internal returns (address) {\n        return IMarketPlace(marketPlace).markets(u, m, 0);\n    }\n\n    /// @notice pauses a market and prevents execution of all lending for that market\n    /// @param p principal enum value\n    /// @param b bool representing whether to pause or unpause\n    /// @return bool true if successful\n    function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n        paused[p] = b;\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param p principal enum value\n    modifier unpaused(uint8 p) {\n        if (paused[p]) {\n            revert Invalid('paused');\n        }\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Interfaces.sol",
            "Element.sol",
            "Lender.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "returned",
                    "ISense",
                    "lend",
                    "maturity",
                    "IYield",
                    "base",
                    "IAPWineRouter",
                    "swapExactAmountIn",
                    "yield",
                    "pool",
                    "mint",
                    "swapUnderlyingForPTs"
                ],
                "Type": " Able to mint any amount of PT",
                "Description": "\nLender.sol#L192-L235(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235)\n\nLender.sol#L486-L534(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534)\n\nLender.sol#L545-L589(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589)\n\n\nSome of the lend functions do not validate addresses sent as input which could lead to a malicous user being able to mint more PT tokens than they should.\n\nFunctions affect:\n\n*   Illuminate and Yield lend function(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235).\n\n*   Sense lend function(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534).\n\n*   APWine lend function(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589).\n\n\nIn the Illuminate and Yield lend function:\n\n1.  Let the Yieldspace pool y be a malicious contract that implements the IYield interface.\n\n2.  The base and maturity functions for y may return any value so the conditions on lines 208 and 210 are easily passed.\n\n3.  The caller of lend sends any amount a for the desired underlying u.\n\n4.  If principal token p corresponds to the Yield principal, then the yield function is called which has a return value controlled by the malicious contract y(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L648).\n\n5.  The mint function is then called for the principal token with an underlying u and a maturity m which will then mint the returned amount of principal tokens to the malicious user.\n\nIn the Sense lend function:\n\n1.  Let the amm x input variable be a malicous contract that implements the ISense interface.\n\n2.  The malicious user sends any amount of underlying to Lender.sol.\n\n3.  Since the amm isn't validated, the swapUnderlyingForPTs function can return any amount for returned that is used to mint the Illuminate tokens.\n\n4.  The malicious user gains a disproportionate amount of PT.\n\nIn the APWine lend function:\n\n1.  Let the APWine pool input variable be a malicous contract that implements the IAPWineRouter interface.\n\n2.  The malicious user sends any amount of underlying to Lender.sol.\n\n3.  The swapExactAmountIn function of the malicious pool contract returns any amount for returned.\n\n4.  The mint function is called for the PT with underlying u and maturity m with the attacker controlled returned amount.\n\n\nConsider validating the input addresses of y(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L197), x(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L492) and pool(https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L551) through a whitelisting procedure if possible or validating that the returned amounts correspond with the amount of PT gained from the protocols by checking the balance before and after the PTs are gained and checking the difference is equal to returned.\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/349)\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n// Adapted from: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol\n\npragma solidity 0.8.13;\n\nimport {IERC20} from './Interfaces.sol';\n\n/**\n  @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n  @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n  @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n*/\n\nlibrary Safe {\n    /// @param e Erc20 token to execute the call with\n    /// @param t To address\n    /// @param a Amount being transferred\n    function transfer(\n        IERC20 e,\n        address t,\n        uint256 a\n    ) internal {\n        bool result;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let pointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(pointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(pointer, 4), and(t, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(pointer, 36), a) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            result := call(gas(), e, 0, pointer, 68, 0, 0)\n        }\n\n        require(success(result), 'transfer failed');\n    }\n\n    /// @param e Erc20 token to execute the call with\n    /// @param f From address\n    /// @param t To address\n    /// @param a Amount being transferred\n    function transferFrom(\n        IERC20 e,\n        address f,\n        address t,\n        uint256 a\n    ) internal {\n        bool result;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let pointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(pointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(pointer, 4), and(f, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(pointer, 36), and(t, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(pointer, 68), a) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            result := call(gas(), e, 0, pointer, 100, 0, 0)\n        }\n\n        require(success(result), 'transfer from failed');\n    }\n\n    /// @notice normalize the acceptable values of true or null vs the unacceptable value of false (or something malformed)\n    /// @param r Return value from the assembly `call()` to Erc20['selector']\n    function success(bool r) private pure returns (bool) {\n        bool result;\n\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(r) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                result := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                result := 1\n            }\n            default {\n                // It returned some malformed input.\n                result := 0\n            }\n        }\n\n        return result;\n    }\n\n    function approve(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), 'APPROVE_FAILED');\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool) {\n        bool result;\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                result := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                result := 1\n            }\n            default {\n                // It returned some malformed input.\n                result := 0\n            }\n        }\n\n        return result;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface IMarketPlace {\n    function markets(\n        address,\n        uint256,\n        uint8\n    ) external returns (address);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC20Metadata{\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n\ninterface IERC5095 is IERC2612 {\n    event Redeem(address, address, uint256);\n\n    function maturity() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function convertToUnderlying(uint256) external returns (uint256);\n\n    function convertToPrincipal(uint256) external returns (uint256);\n\n    function maxRedeem(address) external returns (uint256);\n\n    function previewRedeem(uint256) external returns (uint256);\n\n    function maxWithdraw(address) external returns (uint256);\n\n    function previewWithdraw(uint256) external returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function redeem(uint256, address, address) external returns (uint256);\n\n    function mint(address t, uint256 a) external returns (bool);\n\n    function burn(address t, uint256 a) external returns (bool);\n}\n\ninterface IAPWine {\n    function withdraw(address, uint256) external;\n}\n\ninterface ITempus {\n    function redeemToBacking(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ninterface ISwivel {\n    function redeemZcToken(\n        address u,\n        uint256 m,\n        uint256 a\n    ) external returns (bool);\n}\n\ninterface IYield {\n    function redeem(address to, uint256 amount) external returns (uint256);\n}\n\ninterface IPendle {\n    function redeemAfterExpiry(\n        bytes32,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ISense {\n    function redeem(\n        address,\n        uint256,\n        uint256\n    ) external;\n}\n\ninterface IElementToken {\n    function unlockTimestamp() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function withdrawPrincipal(uint256 amount, address destination) external;\n}\n\ninterface IYieldToken {\n    function redeem(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\ninterface INotional {\n    function maxRedeem(address) external returns (uint256);\n}\n\n\n",
        "CodeNames": [
            "Safe.sol",
            "Interfaces.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-12",
                "Location": [
                    "transferFrom(IERC",
                    "redeem"
                ],
                "Type": " Funds may be stuck when  redeeming  for Illuminate",
                "Description": "\nFunds may be stuck when redeeming for Illuminate.\n\n\nAssuming the goal of calling redeem for Illuminate here(https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is to redeem the Illuminate principal held by the lender or the redeemer, then there is an issue because the wrong balance(https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120) is checked. So if no msg.sender has a positive balance funds will be lost.\n\nNow assuming the goal of calling redeem for Illuminate here(https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is for users to redeem their Illuminate principal and receive the underlying as suggested by this comment(https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L127), then the underlying is not sent back to users because Safe.transferFrom(IERC20(u), lender, address(this), amount); send the funds to the redeemer, not the user.\n\n",
                "Repair": "\nClarify the purpose of this function and fix the corresponding bug.\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/384) \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-13",
                "Location": [
                    "//solidity\nuint256 amount = token.balanceOf(msg.sender);\n",
                    "//solidity\ntoken.burn(o, amount);\n",
                    "//solidity\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            // Get Illuminate's principal token\n            IERC5095 token = IERC5095(principal);\n            // Get the amount of tokens to be redeemed from the sender\n            uint256 amount = token.balanceOf(msg.sender);\n            // Make sure the market has matured\n            if (block.timestamp < token.maturity()) {\n                revert Invalid('not matured');\n            }\n            // Burn the prinicipal token from Illuminate\n            token.burn(o, amount);\n            // Transfer the original underlying token back to the user\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n",
                    "//solidity\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n",
                    "//solidity\ncontract ERC5095 is ERC20Permit, IERC5095 {\n",
                    "//solidity\n    function _burn(address src, uint wad) internal virtual returns (bool) {\n        unchecked {\n            require(_balanceOf[src] = wad, \"ERC20: Insufficient balance\");\n            _balanceOf[src] = _balanceOf[src] wad;\n            _totalSupply = _totalSupply wad;\n            emit Transfer(src, address(0), wad);\n        }\n\n        return true;\n    }\n"
                ],
                "Type": " Illuminate PT redeeming allows for burning from other accounts",
                "Description": "\nIlluminate PT burns shares from a user supplied address account instead of user's account. With such a discrepancy a malicious user can burn all other's user shares by having the necessary shares on her balance, while burning them from everyone else.\n\nSetting the severity to be high as this allows for system-wide stealing of user's funds.\n\n\nRedeemer's Illuminate redeem() checks the balance of msg.sender, but burns from the balance of user supplied o address:\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128\n\nL120:\n\nsolidity\nuint256 amount = token.balanceOf(msg.sender);\n\n\nL126:\n\nsolidity\ntoken.burn(o, amount);\n\n\nsolidity\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            // Get Illuminate's principal token\n            IERC5095 token = IERC5095(principal);\n            // Get the amount of tokens to be redeemed from the sender\n            uint256 amount = token.balanceOf(msg.sender);\n            // Make sure the market has matured\n            if (block.timestamp < token.maturity()) {\n                revert Invalid('not matured');\n            }\n            // Burn the prinicipal token from Illuminate\n            token.burn(o, amount);\n            // Transfer the original underlying token back to the user\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n\no address isn't validated and used as provided.\n\nBurning proceeds as usual, Illuminate PT burns second argument a from the first argument f, i.e. f's balance to be reduced by a:\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L121-L127\n\nsolidity\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L7\n\nsolidity\ncontract ERC5095 is ERC20Permit, IERC5095 {\n\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC20.sol#L187-L196\n\nsolidity\n    function _burn(address src, uint wad) internal virtual returns (bool) {\n        unchecked {\n            require(_balanceOf[src] = wad, \"ERC20: Insufficient balance\");\n            _balanceOf[src] = _balanceOf[src] wad;\n            _totalSupply = _totalSupply wad;\n            emit Transfer(src, address(0), wad);\n        }\n\n        return true;\n    }\n\n\nThis way a malicious user owning some Illuminate PT can burn the same amount of PT as she owns from any another account, that is essentially from all other accounts, obtaining all the underlying tokens from the system. The behavior is somewhat similar to the public burn case.\n\n",
                "Repair": "\no address looks to be not needed in Illuminate PT case.\n\nConsider burning the shares from msg.sender, for example:\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L125-L126\n\nsolidity\n            // Burn the prinicipal token from Illuminate\n          token.burn(o, amount);\n+           token.burn(msg.sender, amount);\n\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/387)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface IMarketPlace {\n    function markets(\n        address,\n        uint256,\n        uint8\n    ) external returns (address);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC20Metadata{\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n\ninterface IERC5095 is IERC2612 {\n    event Redeem(address, address, uint256);\n\n    function maturity() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function convertToUnderlying(uint256) external returns (uint256);\n\n    function convertToPrincipal(uint256) external returns (uint256);\n\n    function maxRedeem(address) external returns (uint256);\n\n    function previewRedeem(uint256) external returns (uint256);\n\n    function maxWithdraw(address) external returns (uint256);\n\n    function previewWithdraw(uint256) external returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function redeem(uint256, address, address) external returns (uint256);\n\n    function mint(address t, uint256 a) external returns (bool);\n\n    function burn(address t, uint256 a) external returns (bool);\n}\n\ninterface IAPWine {\n    function withdraw(address, uint256) external;\n}\n\ninterface ITempus {\n    function redeemToBacking(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ninterface ISwivel {\n    function redeemZcToken(\n        address u,\n        uint256 m,\n        uint256 a\n    ) external returns (bool);\n}\n\ninterface IYield {\n    function redeem(address to, uint256 amount) external returns (uint256);\n}\n\ninterface IPendle {\n    function redeemAfterExpiry(\n        bytes32,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ISense {\n    function redeem(\n        address,\n        uint256,\n        uint256\n    ) external;\n}\n\ninterface IElementToken {\n    function unlockTimestamp() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function withdrawPrincipal(uint256 amount, address destination) external;\n}\n\ninterface IYieldToken {\n    function redeem(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\ninterface INotional {\n    function maxRedeem(address) external returns (uint256);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol';\nimport './Safe.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    error Invalid(string);\n    error Unauthorized();\n    error Exists(string);\n\n    /// @notice address that is allowed to set the lender and marketplace\n    address public admin;\n    /// @notice address used to access the MarketPlace's markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n    /// @notice third party contract needed to lend on APWine\n    address public apwineAddr;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    /// @param a the APWine contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t,\n        address a\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        apwineAddr = a;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists('marketplace');\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set, false otherwise\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exists('lender');\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice redeems underlying token for Illuminate, APWine and Tempus protocols\n    /// @dev Illuminate burns its tokens prior to redemption, unlike APWine and\n    /// Tempus, which redeem PTs to the redeemer, transferring the underlying to\n    /// this redeemer contract. Consequently, only Illuminate's redeem returns funds\n    /// to the user.\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u the underlying token being redeemed\n    /// @param m the maturity of the market being redeemed\n    /// @param o address of the controller or contract that manages the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address o\n    ) public returns (bool) {\n        // Get the address of the principal token being redeemed\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            // Get Illuminate's principal token\n            IERC5095 token = IERC5095(principal);\n            // Get the amount of tokens to be redeemed from the sender\n            uint256 amount = token.balanceOf(msg.sender);\n            // Make sure the market has matured\n            if (block.timestamp < token.maturity()) {\n                revert Invalid('not matured');\n            }\n            // Burn the prinicipal token from Illuminate\n            token.burn(o, amount);\n            // Transfer the original underlying token back to the user\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            emit Redeem(0, u, m, amount);\n        }\n        else {\n            // Get the amount of tokens to be redeemed from the principal token\n            uint256 amount = IERC20(principal).balanceOf(lender);\n            // Transfer the principal token from the lender contract to here\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            if (p == uint8(MarketPlace.Principals.Apwine)) {\n                // Redeem the underlying token from APWine to Illuminate\n                IAPWine(apwineAddr).withdraw(o, amount);\n            } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n                // Redeem the tokens from the Tempus contract to Illuminate\n                ITempus(tempusAddr).redeemToBacking(o, amount, 0, address(this));\n            } else {\n                revert Invalid('principal');\n            }\n            emit Redeem(0, u, m, amount);\n        }\n\n        return true;\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element and Notional protocols\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) public returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Make sure we have the correct principal\n        if (\n            p != uint8(MarketPlace.Principals.Swivel) &&\n            p != uint8(MarketPlace.Principals.Element) &&\n            p != uint8(MarketPlace.Principals.Yield) &&\n            p != uint8(MarketPlace.Principals.Notional)\n        ) {\n            revert Invalid('principal');\n        }\n\n        // The amount redeemed should be the balance of the principal token held by the Illuminate contract\n        uint256 amount = IERC20(principal).balanceOf(lender);\n\n        // Transfer the principal token from the lender contract to here\n        Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems zc tokens to the sender's address\n            ISwivel(swivelAddr).redeemZcToken(u, m, amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from element\n            IElementToken(principal).withdrawPrincipal(amount, marketPlace);\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems prinicipal tokens from yield\n            IYieldToken(principal).redeem(address(this), address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems the principal token from notional\n            amount = INotional(principal).maxRedeem(address(this));\n        }\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param i forge id used by Pendle to redeem the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        bytes32 i\n    ) public returns (bool) {\n        // Check the principal is Pendle\n        if (p != uint8(MarketPlace.Principals.Pendle)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token that is being redeemed by the user\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Pendle contract\n        IPendle(pendleAddr).redeemAfterExpiry(i, u, m);\n        \n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param d Sense contract that splits the loan's prinicpal and yield\n    /// @param o Sense contract that [d] calls into to adapt the underlying to Sense\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address d,\n        address o\n    ) public returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token for the given market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Sense contract\n        ISense(d).redeem(o, m, amount);\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the underlying asset to be burned and sent to the to\n    /// @return bool true if the underlying asset was burned successfully\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    ) public authorized(IMarketPlace(marketPlace).markets(u, m, 0)) returns (bool) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).markets(u, m, 0));\n\n        // Make sure the market has matured\n        if (block.timestamp < pt.maturity()) {\n            revert Invalid('not matured');\n        }\n\n        // Burn the user's principal tokens\n        pt.burn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, a);\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Interfaces.sol",
            "Redeemer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-14",
                "Location": [
                    "//solidity\nfunction redeem(\n    uint8 p,\n    address u,\n    uint256 m\n) public returns (bool) {\n    // Get the principal token that is being redeemed by the user\n    address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n    // Make sure we have the correct principal\n    if (\n        p != uint8(MarketPlace.Principals.Swivel) &&\n        p != uint8(MarketPlace.Principals.Element) &&\n        p != uint8(MarketPlace.Principals.Yield) &&\n        p != uint8(MarketPlace.Principals.Notional)\n    ) {\n        revert Invalid('principal');\n    }\n\n    // The amount redeemed should be the balance of the principal token held by the Illuminate contract\n    uint256 amount = IERC20(principal).balanceOf(lender);\n\n    // Transfer the principal token from the lender contract to here\n    Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\n    if (p == uint8(MarketPlace.Principals.Swivel)) {\n        // Redeems zc tokens to the sender's address\n        ISwivel(swivelAddr).redeemZcToken(u, m, amount);\n    } else if (p == uint8(MarketPlace.Principals.Element)) {\n        // Redeems principal tokens from element\n        IElementToken(principal).withdrawPrincipal(amount, marketPlace);\n    } else if (p == uint8(MarketPlace.Principals.Yield)) {\n        // Redeems prinicipal tokens from yield\n        IYieldToken(principal).redeem(address(this), address(this), amount);\n    } else if (p == uint8(MarketPlace.Principals.Notional)) {\n        // Redeems the principal token from notional\n        amount = INotional(principal).maxRedeem(address(this));\n    }\n\n    emit Redeem(p, u, m, amount);\n    return true;\n}\n",
                    "//solidity\nfunction previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n    if (hasMatured()) {\n        assets = convertToAssets(shares);\n    } else {\n        // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n            currencyId,\n            shares,\n            maturity,\n            0,\n            block.timestamp\n        );\n    }\n}\n"
                ],
                "Type": "  Redeemer.sol#redeem()  can be called by anyone before maturity, which may lead to loss of user funds",
                "Description": "\nsolidity\nfunction redeem(\n    uint8 p,\n    address u,\n    uint256 m\n) public returns (bool) {\n    // Get the principal token that is being redeemed by the user\n    address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n    // Make sure we have the correct principal\n    if (\n        p != uint8(MarketPlace.Principals.Swivel) &&\n        p != uint8(MarketPlace.Principals.Element) &&\n        p != uint8(MarketPlace.Principals.Yield) &&\n        p != uint8(MarketPlace.Principals.Notional)\n    ) {\n        revert Invalid('principal');\n    }\n\n    // The amount redeemed should be the balance of the principal token held by the Illuminate contract\n    uint256 amount = IERC20(principal).balanceOf(lender);\n\n    // Transfer the principal token from the lender contract to here\n    Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\n    if (p == uint8(MarketPlace.Principals.Swivel)) {\n        // Redeems zc tokens to the sender's address\n        ISwivel(swivelAddr).redeemZcToken(u, m, amount);\n    } else if (p == uint8(MarketPlace.Principals.Element)) {\n        // Redeems principal tokens from element\n        IElementToken(principal).withdrawPrincipal(amount, marketPlace);\n    } else if (p == uint8(MarketPlace.Principals.Yield)) {\n        // Redeems prinicipal tokens from yield\n        IYieldToken(principal).redeem(address(this), address(this), amount);\n    } else if (p == uint8(MarketPlace.Principals.Notional)) {\n        // Redeems the principal token from notional\n        amount = INotional(principal).maxRedeem(address(this));\n    }\n\n    emit Redeem(p, u, m, amount);\n    return true;\n}\n\n\nThere are some protocols (eg Notional) that allows redeem before maturity, when doing so, they will  actually make a market sell, usually means a discounted sale.\n\nSince redeem() is a public function, anyone can call it before maturity, and force the whole protocol to sell it's holdings at a discounted price, causing fund loss to the stake holders.\n\n<https://github.com/notional-finance/wrapped-fcash/blob/8f76be58dda648ea58eef863432c14c940e13900/contracts/wfCashERC4626.sol#L155-L169\n\nsolidity\nfunction previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n    if (hasMatured()) {\n        assets = convertToAssets(shares);\n    } else {\n        // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n            currencyId,\n            shares,\n            maturity,\n            0,\n            block.timestamp\n        );\n    }\n}\n\n\n",
                "Repair": "\nConsider only allow unauthenticated call after maturity.\n\nJTraversa (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/347)\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface IMarketPlace {\n    function markets(\n        address,\n        uint256,\n        uint8\n    ) external returns (address);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC20Metadata{\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n\ninterface IERC5095 is IERC2612 {\n    event Redeem(address, address, uint256);\n\n    function maturity() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function convertToUnderlying(uint256) external returns (uint256);\n\n    function convertToPrincipal(uint256) external returns (uint256);\n\n    function maxRedeem(address) external returns (uint256);\n\n    function previewRedeem(uint256) external returns (uint256);\n\n    function maxWithdraw(address) external returns (uint256);\n\n    function previewWithdraw(uint256) external returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function redeem(uint256, address, address) external returns (uint256);\n\n    function mint(address t, uint256 a) external returns (bool);\n\n    function burn(address t, uint256 a) external returns (bool);\n}\n\ninterface IAPWine {\n    function withdraw(address, uint256) external;\n}\n\ninterface ITempus {\n    function redeemToBacking(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ninterface ISwivel {\n    function redeemZcToken(\n        address u,\n        uint256 m,\n        uint256 a\n    ) external returns (bool);\n}\n\ninterface IYield {\n    function redeem(address to, uint256 amount) external returns (uint256);\n}\n\ninterface IPendle {\n    function redeemAfterExpiry(\n        bytes32,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ISense {\n    function redeem(\n        address,\n        uint256,\n        uint256\n    ) external;\n}\n\ninterface IElementToken {\n    function unlockTimestamp() external returns (uint256);\n\n    function underlying() external returns (address);\n\n    function withdrawPrincipal(uint256 amount, address destination) external;\n}\n\ninterface IYieldToken {\n    function redeem(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\ninterface INotional {\n    function maxRedeem(address) external returns (uint256);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol'; // library of market place specific constructs\nimport './Swivel.sol'; // library of swivel specific constructs\nimport './Element.sol'; // library of element specific constructs\nimport './Safe.sol';\nimport './Cast.sol';\n\n/// @title Lender.sol\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users. \n/// @notice The contract holds the principal tokens for each market and mints an ERC-5095 position to users to represent their lent positions.\ncontract Lender {\n    error Unauthorized();\n    error NotEqual(string);\n    error Exists(address);\n    error Invalid(string);\n\n    /// @notice minimum amount of time the admin must wait before executing a withdrawl\n    uint256 constant public HOLD = 3 days;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace.sol contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal may be used by a lender\n    mapping(uint8 => bool) public paused;\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping (address => uint256) public withdrawals;\n\n    /// @notice emitted upon executed lend\n    event Lend(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 returned);\n    /// @notice emitted upon minted ERC5095 to user\n    event Mint(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n    /// @notice emitted on token withdrawal scheduling\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted on token withdrawal blocking\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted on a change to the feenominators array\n\n    /// @notice initializes the Lender contract\n    /// @param s the swivel contract\n    /// @param p the pendle contract\n    /// @param t the tempus contract\n    constructor(\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u underlying token's address, used to define the market being approved\n    /// @param m maturity of the underlying token, used to define the market being approved\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful, false otherwise\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // max is the maximum integer value for a 256 unsighed integer\n        uint256 max = 2**256 - 1;\n\n        // approve the underlying for max per given principal\n        for (uint8 i; i < 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses. \n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {\n        uint256 len = u.length;\n        if (len != a.length) {\n            revert NotEqual('array length');\n        }\n        uint256 max = 2**256 - 1;\n\n        for (uint256 i; i < len; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        feenominator = f;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists(marketPlace);\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on illuminate\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful, false otherwise\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public returns (bool) {\n        //use market interface to fetch the market for the given market pair\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        //use safe transfer lib and ERC interface...\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n        //use ERC5095 interface...\n        IERC5095(principalToken(u, m)).mint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method signature for both illuminate and yield\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y yieldspace pool that will execute the swap for the principal token\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y\n    ) public unpaused(p) returns (uint256) {\n        // check the principal is illuminate or yield\n        if (p != uint8(MarketPlace.Principals.Illuminate) && p != uint8(MarketPlace.Principals.Yield)) {\n            revert Invalid('principal');\n        }\n\n        // uses yield token interface...\n        IYield pool = IYield(y);\n\n        // the yield token must match the market pair\n        if (address(pool.base()) != u) {\n            revert NotEqual('underlying');\n        } else if (pool.maturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // transfer from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Purchase yield PTs to lender.sol (address(this))\n            uint256 returned = yield(u, y, a - calculateFee(a), address(this));\n            // Mint and distribute equivalent illuminate PTs\n            IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n            \n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n        else {\n            // Purchase illuminate PTs directly to msg.sender\n            uint256 returned = yield(u, y, a - calculateFee(a), msg.sender);\n\n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n    }\n\n    /// @notice lend method signature for swivel\n    /// @dev lends to yield pool. remaining balance is sent to the yield pool\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y yield pool\n    /// @param o array of swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        {\n            // returned represents the number of underlying tokens to lend to yield\n            uint256 returned;\n\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {\n                    revert NotEqual('maturity');\n                }\n\n                {\n                    uint256 amount = a[i];\n                    // Determine the fee\n                    uint256 fee = calculateFee(amount);\n                    // Track accumulated fees\n                    totalFee += fee;\n                    // Amount lent for this order\n                    uint256 amountLent = amount - fee;\n                    // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                    lent += amountLent;\n                    // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                    returned += amountLent * order.premium / order.principal;\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n      \n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n\n    /// @notice lend method signature for element\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed deadline is a timestamp by which the swap must be executed\n    /// @param e element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) public unpaused(p) returns (uint256) {\n        // Get the principal token for this market for element\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // the element token must match the market pair\n        if (IElementToken(principal).underlying() != u) {\n            revert NotEqual('underlying');\n        } else if (IElementToken(principal).unlockTimestamp() > m) {\n            revert NotEqual('maturity');\n        }\n        // Transfer underlying token from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] += calculateFee(a);\n\n        uint256 purchased;\n        {\n            // Create the variables needed to execute an element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000',\n                poolId: i,\n                amount: a - calculateFee(a),\n                kind: Element.SwapKind.In,\n                assetIn: Any(u),\n                assetOut: Any(principal)\n            });\n\n            // Conduct the swap on element\n            purchased = IElement(e).swap(swap, fund, r, d);\n        }\n\n        emit Lend(p, u, m, purchased);\n        return purchased;\n    }\n\n    /// @notice lend method signature for pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        IPendleToken token = IPendleToken(principal);\n\n        // confirm that we are in the correct market\n        if (token.yieldToken() != u) {\n            revert NotEqual('underlying');\n        } else if (token.expiry() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = calculateFee(a);\n            fees[u] += fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0];\n\n        }\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for tempus\n    /// @dev This method can be called before maturity to lend to Tempus while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param t tempus pool that houses the underlying principal tokens\n    /// @param x tempus amm that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n        {\n            // Instantiate market and tokens\n            address principal = IMarketPlace(marketPlace).markets(u, m, p);\n            if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n                revert NotEqual('underlying');\n            } else if (ITempus(principal).maturityTime() > m) {\n                revert NotEqual('maturity');\n            }\n\n            // Get the underlying token\n            IERC20 underlyingToken = IERC20(u);\n\n            // Transfer funds from user to Illuminate, Scope to avoid stack limit\n            Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n        }\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r minimum number of tokens to lend (sets a limit on the order)\n    /// @param x amm that is used to conduct the swap\n    /// @param s contract that holds the principal token for this market\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        address s\n    ) public unpaused(p) returns (uint256) {\n\n        // Get the principal token for this market for this market\n        ISenseToken token = ISenseToken(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Verify that the underlying and maturity match up\n        if (token.underlying() != u) { // gauruntee the input token is the right token\n            revert NotEqual('underlying'); \n        } else if (ISense(s).pt() != address(token)) {\n            revert NotEqual('principal token'); \n        } else if (ISense(x).maturity() > m) { // gauruntee the input amm has the correct maturity\n            revert NotEqual('maturity');\n        }\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine lent amount after fees\n            lent = a - fee;\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Swap those tokens for the principal tokens\n        uint256 returned = ISense(x).swapUnderlyingForPTs(s, m, lent, r);\n\n        // Get the address of the ERC5095 token for this market\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n\n        // Mint the illuminate tokens based on the returned amount\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice this method can be called before maturity to lend to APWine while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the minimum amount of zero-coupon tokens to return accounting for slippage\n    /// @param pool the address of a given APWine pool\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        address pool,\n        address aave,\n        uint256 i\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        if (IAPWineToken(principal).getUnderlyingOfIBTAddress() != u) {\n            revert NotEqual('underlying');\n        }\n        // Dont necessarily need to validate APWINE maturity (They have 1 maturity per underlying)\n        // Potentially add redundant implied maturity calculation\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine the amount lent after fees\n            lent = a - fee;\n        }\n\n        // Deposit into aave\n        IAave(aave).deposit(u, lent, address(this), 0);\n\n        // Swap on the APWine Pool using the provided market and params\n        uint256 returned = IAPWineRouter(pool).swapExactAmountIn(i, 1, lent, 0, r, address(this));\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @dev lend method signature for Notional\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        INotional token = INotional(principal);\n\n        // Verify that the underlying and maturity match up\n        (IERC20 underlying, ) = token.getUnderlyingToken();\n        if (address(underlying) != u) {\n            revert NotEqual('underlying');\n        } else if (token.getMaturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Notional Token wrapper\n        uint256 returned = token.deposit(a - fee, address(this));\n\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice transfers excess funds to yield pool after principal tokens have been lent out\n    /// @dev this method is only used by the yield, illuminate and swivel protocols\n    /// @param u address of an underlying asset\n    /// @param y the yield pool to lend to\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the receiving address for PTs\n    /// @return uint256 the amount of tokens sent to the yield pool\n    function yield(\n        address u,\n        address y,\n        uint256 a,\n        address r\n    ) internal returns (uint256) {\n        // preview exact swap slippage on yield\n        uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));\n\n        // send the remaing amount to the given yield pool\n        Safe.transfer(IERC20(u), y, a);\n\n        // lend out the remaining tokens in the yield pool\n        IYield(y).sellBase(r, returned);\n\n        return returned;\n    }\n\n    /// @notice withdraws accumulated lending fees of the underlying token\n    /// @param e address of the underlying token to withdraw\n    /// @return bool true if successful\n    function withdrawFee(address e) external authorized(admin) returns (bool) {\n        // Get the token to be withdrawn\n        IERC20 token = IERC20(e);\n\n        // Get the balance to be transferred\n        uint256 balance = fees[e];\n\n        // Reset accumulated fees of the token to 0\n        fees[e] = 0;\n\n        // Transfer the accumulated fees to the admin\n        Safe.transfer(token, admin, balance);\n        return true;\n    }\n\n    /// @notice this method returns the fee based on the amount passed to it. If the feenominator is 0, then there is no fee.\n    /// @param a amount of underlying tokens to calculate the fee for\n    /// @return uint256 The total for for the given amount\n    function calculateFee(uint256 a) internal view returns (uint256) {\n        return feenominator > 0 ? a / feenominator : 0;\n    }\n\n    /// @notice allows the admin to schedule the withdrawal of tokens\n    /// @param e address of (erc20) token to withdraw\n    /// @return bool true if successful\n    function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n        uint256 when = block.timestamp + HOLD;\n        withdrawals[e] = when;\n\n        emit ScheduleWithdrawal(e, when);\n        return true;\n    }\n\n    /// @notice emergency function to block unplanned withdrawals\n    /// @param e address of token withdrawal to block\n    /// @return bool true if successful\n    function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n        withdrawals[e] = 0;\n\n        emit BlockWithdrawal(e);\n        return true;\n    }\n\n    /// @notice allows the admin to withdraw the given token, provided the holding period has been observed\n    /// @param e Address of token to withdraw\n    /// @return bool true if successful\n    function withdraw(address e) external authorized(admin) returns (bool) {\n        uint256 when = withdrawals[e];\n        require (when != 0, 'no withdrawal scheduled');\n  \n        require (block.timestamp >= when, 'withdrawal still on hold');\n  \n        withdrawals[e] = 0;\n  \n        IERC20 token = IERC20(e);\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\n  \n        return true;\n    }\n\n    /// @notice retrieves the ERC5095 token for the given market\n    /// @param u address of the underlying\n    /// @param m uint256 representing the maturity of the market\n    /// @return address of the ERC5095 token for the market\n    function principalToken(address u, uint256 m) internal returns (address) {\n        return IMarketPlace(marketPlace).markets(u, m, 0);\n    }\n\n    /// @notice pauses a market and prevents execution of all lending for that market\n    /// @param p principal enum value\n    /// @param b bool representing whether to pause or unpause\n    /// @return bool true if successful\n    function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n        paused[p] = b;\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param p principal enum value\n    modifier unpaused(uint8 p) {\n        if (paused[p]) {\n            revert Invalid('paused');\n        }\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Interfaces.sol",
            "Lender.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-15",
                "Location": [
                    "redeem",
                    "principal"
                ],
                "Type": " Incorrect implementation of APWine and Tempus  redeem ",
                "Description": "\nRedeeming APWine and Tempus PT will always fail, causing a portion of iPT to not be able to be redeemed for the underlying token.\n\nThe issue is caused by the incorrect implementation of redeem:\n\n    uint256 amount = IERC20(principal).balanceOf(lender);\n    Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\nThe first line correctly calculates the balance of PT token available in Lender. However, the second line tries to transfer the underlying token u instead of principal from Lender to Redeemer. Therefore, the redeeming process will always fail as both APWine.withdraw and ITempus.redeemToBacking will try to redeem non-existent PT.\n\n",
                "Repair": "\nFix the transfer line:\n\n    Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\nsourabhmarathe (Illuminate) confirmed(https://github.com/code-423n4/2022-06-illuminate-findings/issues/268)\n\nkenzo (warden) commented(https://github.com/code-423n4/2022-06-illuminate-findings/issues/268#issuecomment-1168768768):\n (Referring all dups here, severity should be upgraded as user funds at risk)\n\ngzeoneth (judge) increased severity to High and commented(https://github.com/code-423n4/2022-06-illuminate-findings/issues/268#issuecomment-1186253468):\n Agree.\n\n\n\n*\n\n\n"
            }
        ]
    }
]