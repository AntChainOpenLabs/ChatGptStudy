[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IUniversalVault {\n    /* user events */\n\n    event Locked(address delegate, address token, uint256 amount);\n    event Unlocked(address delegate, address token, uint256 amount);\n    event RageQuit(address delegate, address token, bool notified, string reason);\n\n    /* data types */\n\n    struct LockData {\n        address delegate;\n        address token;\n        uint256 balance;\n    }\n\n    /* initialize function */\n\n    function initialize() external;\n\n    /* user functions */\n\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function rageQuit(address delegate, address token)\n        external\n        returns (bool notified, string memory error);\n\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n\n    function transferETH(address to, uint256 amount) external payable;\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        external\n        pure\n        returns (bytes32 lockID);\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) external view returns (bytes32 permissionHash);\n\n    function getNonce() external view returns (uint256 nonce);\n\n    function owner() external view returns (address ownerAddress);\n\n    function getLockSetCount() external view returns (uint256 count);\n\n    function getLockAt(uint256 index) external view returns (LockData memory lockData);\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        returns (uint256 balance);\n\n    function getBalanceLocked(address token) external view returns (uint256 balance);\n\n    function checkBalances() external view returns (bool validity);\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport {EIP712} from \"./EIP712.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {OwnableERC721} from \"./OwnableERC721.sol\";\nimport {IRageQuit} from \"../hypervisor/Hypervisor.sol\";\n\nimport {IUniversalVault} from \"../interfaces/IUniversalVault.sol\";\nimport {IVisorService} from \"../interfaces/IVisorService.sol\";\n\n/// @title Visor\n/// @notice Vault for isolated storage of staking tokens\n/// @dev Warning: not compatible with rebasing tokens\ncontract Visor is\n    IUniversalVault,\n    EIP712(\"UniversalVault\", \"1.0.0\"),\n    ERC1271,\n    OwnableERC721,\n    Initializable,\n    IERC721Receiver\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using Address for address payable;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /* constant */\n\n    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks\n    // the gas requirement cannot be determined at runtime by querying the delegate\n    // as it could potentially be manipulated by a malicious delegate who could force\n    // the calls to revert.\n    // The gas limit could alternatively be set upon vault initialization or creation\n    // of a lock, but the gas consumption trade-offs are not favorable.\n    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant RAGEQUIT_GAS = 500000;\n    bytes32 public constant LOCK_TYPEHASH =\n        keccak256(\"Lock(address delegate,address token,uint256 amount,uint256 nonce)\");\n    bytes32 public constant UNLOCK_TYPEHASH =\n        keccak256(\"Unlock(address delegate,address token,uint256 amount,uint256 nonce)\");\n\n    string public constant VERSION = \"VISOR-2.0.3\";\n\n    /* storage */\n\n    uint256 private _nonce;\n    mapping(bytes32 => LockData) private _locks;\n    EnumerableSet.Bytes32Set private _lockSet;\n    string public uri;\n\n    struct Nft {\n      uint256 tokenId; \n      address nftContract;\n    }\n\n    Nft[] public nfts;\n    mapping(bytes32=>bool) public nftApprovals;\n    mapping(bytes32=>uint256) public erc20Approvals;\n\n    struct TimelockERC20 {\n      address recipient;\n      address token;\n      uint256 amount;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC20) public timelockERC20s; \n    mapping(address=>bytes32[]) public timelockERC20Keys;\n    mapping(address=>uint256) public timelockERC20Balances;\n\n    struct TimelockERC721 {\n      address recipient;\n      address nftContract;\n      uint256 tokenId;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC721) public timelockERC721s; \n    mapping(address=>bytes32[]) public timelockERC721Keys;\n\n    event AddNftToken(address nftContract, uint256 tokenId);\n    event RemoveNftToken(address nftContract, uint256 tokenId);\n    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n\n    /* initialization function */\n\n    function initializeLock() external initializer {}\n\n    function initialize() external override initializer {\n      OwnableERC721._setNFT(msg.sender);\n    }\n\n    /* ether receive */\n\n    receive() external payable {}\n\n    /* internal  */\n\n    function _addNft(address nftContract, uint256 tokenId) internal {\n\n      nfts.push(\n        Nft({\n          tokenId: tokenId,\n          nftContract: nftContract\n        })\n      );\n      emit AddNftToken(nftContract, tokenId);\n    }\n\n    function _removeNft(address nftContract, uint256 tokenId) internal {\n      uint256 len = nfts.length;\n      for (uint256 i = 0; i < len; i++) {\n        Nft memory nftInfo = nfts[i];\n        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {\n          if(i != len - 1) {\n            nfts[i] = nfts[len - 1];\n          }\n          nfts.pop();\n          emit RemoveNftToken(nftContract, tokenId);\n          break;\n        }\n      }\n    }\n\n    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {\n        return OwnableERC721.owner();\n    }\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        public\n        pure\n        override\n        returns (bytes32 lockID)\n    {\n        return keccak256(abi.encodePacked(delegate, token));\n    }\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) public view override returns (bytes32 permissionHash) {\n        return\n            EIP712._hashTypedDataV4(\n                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))\n            );\n    }\n\n    function getNonce() external view override returns (uint256 nonce) {\n        return _nonce;\n    }\n\n    function owner()\n        public\n        view\n        override(IUniversalVault, OwnableERC721)\n        returns (address ownerAddress)\n    {\n        return OwnableERC721.owner();\n    }\n\n    function getLockSetCount() external view override returns (uint256 count) {\n        return _lockSet.length();\n    }\n\n    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {\n        return _locks[_lockSet.at(index)];\n    }\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _locks[calculateLockID(delegate, token)].balance;\n    }\n\n    function getBalanceLocked(address token) public view override returns (uint256 balance) {\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            if (_lockData.token == token && _lockData.balance > balance)\n                balance = _lockData.balance;\n        }\n        return balance;\n    }\n\n    function checkBalances() external view override returns (bool validity) {\n        // iterate over all token locks and validate sufficient balance\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            // fetch storage lock reference\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            // if insufficient balance and no\u220ft shutdown, return false\n            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;\n        }\n        // if sufficient balance or shutdown, return true\n        return true;\n    }\n\n    // @notice Get ERC721 from nfts[] by index\n    /// @param i nfts index of nfts[] \n    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {\n        require(i < nfts.length, \"ID overflow\");\n        Nft memory ni = nfts[i];\n        nftContract = ni.nftContract;\n        tokenId = ni.tokenId;\n    }\n\n    // @notice Get index of ERC721 in nfts[]\n    /// @param nftContract Address of ERC721 \n    /// @param tokenId tokenId for NFT in nftContract \n    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {\n        uint256 len = nfts.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {\n                return i;\n            }\n        }\n        require(false, \"Token not found\");\n    }\n\n    // @notice Get number of timelocks for given ERC20 token \n    function getTimeLockCount(address token) public view returns(uint256) {\n      return timelockERC20Keys[token].length;\n    }\n\n    // @notice Get number of timelocks for NFTs of a given ERC721 contract \n    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {\n      return timelockERC721Keys[nftContract].length;\n    }\n\n    /* user functions */\n\n    /// @notice Lock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: anytime\n    /// state scope:\n    /// - insert or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being locked\n    /// @param amount Amount of tokens being locked\n    /// @param permission Permission signature payload\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // add lock to storage\n        if (_lockSet.contains(lockID)) {\n            // if lock already exists, increase amount\n            _locks[lockID].balance = _locks[lockID].balance.add(amount);\n        } else {\n            // if does not exist, create new lock\n            // add lock to set\n            assert(_lockSet.add(lockID));\n            // add lock data to storage\n            _locks[lockID] = LockData(msg.sender, token, amount);\n        }\n\n        // validate sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,\n            \"UniversalVault: insufficient balance\"\n        );\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Locked(msg.sender, token, amount);\n    }\n\n    /// @notice Unlock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being unlocked\n    /// @param amount Amount of tokens being unlocked\n    /// @param permission Permission signature payload\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // update lock data\n        if (_locks[lockID].balance > amount) {\n            // substract amount from lock balance\n            _locks[lockID].balance = _locks[lockID].balance.sub(amount);\n        } else {\n            // delete lock data\n            delete _locks[lockID];\n            assert(_lockSet.remove(lockID));\n        }\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Unlocked(msg.sender, token, amount);\n    }\n\n    /// @notice Forcibly cancel delegate lock\n    /// @dev This function will attempt to notify the delegate of the rage quit using\n    ///      a fixed amount of gas.\n    /// access control: only owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove item from _locks\n    /// token transfer: none\n    /// @param delegate Address of delegate\n    /// @param token Address of token being unlocked\n    function rageQuit(address delegate, address token)\n        external\n        override\n        onlyOwner\n        returns (bool notified, string memory error)\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(delegate, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // attempt to notify delegate\n        if (delegate.isContract()) {\n            // check for sufficient gas\n            require(gasleft() >= RAGEQUIT_GAS, \"UniversalVault: insufficient gas\");\n\n            // attempt rageQuit notification\n            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {\n                notified = true;\n            } catch Error(string memory res) {\n                notified = false;\n                error = res;\n            } catch (bytes memory) {\n                notified = false;\n            }\n        }\n\n        // update lock storage\n        assert(_lockSet.remove(lockID));\n        delete _locks[lockID];\n\n        // emit event\n        emit RageQuit(delegate, token, notified, error);\n    }\n\n    function setURI(string memory _uri) public onlyOwner {\n      uri = _uri;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault\n    /// access control: only owner\n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC20 tokens out of vault\n    /// @param token Address of token being transferred\n    /// @param delegate Address being approved\n    /// @param amount Amount of tokens approved to transfer\n    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {\n      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault with an approved account\n    /// access control: only approved accounts in erc20Approvals \n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function delegatedTransferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        if(msg.sender != _getOwner()) {\n\n        require( \n            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,\n            \"Account not approved to transfer amount\"); \n        } \n\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n        \n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @notice Transfer ETH out of vault\n    /// access control: only owner\n    /// state machine: when balance >= amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param to Address of the to\n    /// @param amount Amount of ETH to transfer\n    function transferETH(address to, uint256 amount) external payable override onlyOwner {\n      // perform transfer\n      TransferHelper.safeTransferETH(to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC721 token out of vault\n    /// @param delegate Account address being approved to transfer nft  \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function approveTransferERC721(\n      address delegate, \n      address nftContract, \n      uint256 tokenId\n    ) external onlyOwner {\n      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;\n    }\n\n    /// @notice Transfer ERC721 out of vault\n    /// access control: only owner or approved\n    /// ERC721 transfer: transfer any ERC721 token\n    /// @param to recipient address \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function transferERC721(\n        address to,\n        address nftContract,\n        uint256 tokenId\n    ) external {\n        if(msg.sender != _getOwner()) {\n          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\"); \n        } \n\n        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {\n          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {\n              require(\n                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, \n                \"NFT locked and not expired\"\n              );\n              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, \"NFT locked and must be withdrawn by timelock recipient\");\n          }\n        }\n\n        _removeNft(nftContract, tokenId);\n        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n    // @notice Adjust nfts[] on ERC721 token recieved \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {\n      _addNft(msg.sender, tokenId);\n      return IERC721Receiver.onERC721Received.selector;\n    }\n\n    // @notice Lock ERC721 in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw \n    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n \n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n\n      require(\n        timelockERC721s[key].expires == 0,\n        \"TimelockERC721 already exists\"\n      );\n     \n      timelockERC721s[key] = TimelockERC721({\n          recipient: recipient,\n          nftContract: nftContract,\n          tokenId: tokenId,\n          expires: expires\n      });\n\n      timelockERC721Keys[nftContract].push(key);\n\n      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);\n      emit TimeLockERC20(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Withdraw ERC721 in vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n      require(\n        timelockERC721s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC721s[key].recipient, \"Not recipient\");\n\n      _removeNft(nftContract, tokenId);\n      delete timelockERC721s[key];\n\n      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);\n      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {\n\n      require(\n        IERC20(token).allowance(msg.sender, address(this)) >= amount, \n        \"Amount not approved\"\n      );\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n\n      require(\n        timelockERC20s[key].expires == 0,\n        \"TimelockERC20 already exists\"\n      );\n    \n      timelockERC20s[key] = TimelockERC20({\n          recipient: recipient,\n          token: token,\n          amount: amount,\n          expires: expires\n      });\n      timelockERC20Keys[token].push(key);\n      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);\n      IERC20(token).transferFrom(msg.sender, address(this), amount);\n      emit TimeLockERC20(recipient, token, amount, expires);\n    }\n\n    // @notice Withdraw ERC20 from vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {\n\n      require(\n        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),\n        \"Insufficient balance\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n      require(\n        timelockERC20s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC20s[key].recipient, \"Not recipient\");\n      \n      delete timelockERC20s[key];\n\n      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);\n      TransferHelper.safeTransfer(token, recipient, amount);\n      emit TimeUnlockERC20(recipient, token, amount, expires);\n    }\n\n}\n\n\n",
        "CodeNames": [
            "IUniversalVault.sol",
            "Visor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "timelockERC",
                    "nftApprovals",
                    "timeUnlockERC",
                    "transferERC",
                    "timeLockERC"
                ],
                "Type": " A previously timelocked NFT token becomes permanently stuck in vault if it\u2019s ever moved back into the vault",
                "Description": "\nLet\u2019s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using timeLockERC721() with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using timeUnlockERC721().\n\nThis is possible because transferERC721() does all the timelock checks on expires/block.timestamp and recipient/msg.sender as is done in timeUnlockERC721(). But it misses deleting timelockERC721s[key] for that NFT tokenID (as done in L572 of timeUnlockERC721()).\n\nBecause of this missing deletion, if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the transferERC721() call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock).\n\nThe impact is that, without access/control to the earlier timelock recipient, this NFT token is now locked in the vault forever.\n\n1. Alice time locks a particular NFT token with delegate Eve as recipient using timeLockERC721()\n2. Eve transfers NFT to Bob using transferERC721() but without calling timeUnlockERC721() first\n3. Alice buys the same NFT back from Bob (e.g. because it is now considered rare and more valuable) and again puts it back in her vault but this time without locking/delegating it to any recipient i.e. intending to control it herself.\n4. Because this NFT's timelock data and delegate approval for Eve is never removed after Step 2, the NFT is still treated as timelocked in the vault with previous delegate Eve as the recipient (because of stale data in timelockERC721s and nftApprovals)\n5. Alice now cannot withdraw her own NFT without Eve\u2019s help because the check on L510 will only allow Eve to transfer this NFT out of the vault.\n6. If Eve is no longer trusted/accessible then the NFT is locked in the vault forever.\n\n",
                "Repair": "Recommend adding delete timelockERC721s timelockERC721Keys[nftContract][i]]; after L510.\n\nxyz-ctrl (Visor) confirmed(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/35#issuecomment-857003620):\n\nztcrypto (Visor) patched(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/35#issuecomment-889188488):\n patch link(https://github.com/VisorFinance/visor-core/commit/71797204108fee8375bfb99a435c0e379bbcbd84#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "transferERC",
                    "approveTransferERC"
                ],
                "Type": " NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens",
                "Description": "\nNFT transfer approvals that are set to true in approveTransferERC721() are never set to false and there is no way to remove such an nft approval.\n\nImpact 1: The approval is not removed (set to false) after a transfer in transferERC721(). So if the NFT is ever moved back into the owner's vault again, then the previous/compromised delegate can again transfer it to any address of choice without requiring a new approval.\n\nImpact 2: If a delegate becomes compromised/untrustworthy after granting approval but before transfer then the owner will lose its NFT because there is no mechanism to revoke the approval that was granted earlier.\n\nPoC-1(https://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L477-L487):\n* Alice grants Eve approval to transfer a particular NFT out of its vault using approveTransferERC721()\n* Eve, who has transfer rights to that NFT from Alice\u2019s vault,  transfers that NFT to Bob using transferERC721()\n* Alice decides to buy back that NFT (e.g. because it is now considered rare and more valuable) from Bob and transfers it back to its vault\n* Eve, who continues to have transfer rights to that NFT from Alice\u2019s vault, can steal that NFT and transfer to anyone\n\nPoC-2(https://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L489-L522):\n* Alice grants Eve approval to transfer a particular NFT out of its vault using approveTransferERC721()\n* Alice learns that Eve\u2019s keys are compromises or that Eve is malicious and wants to revoke the approval but there is no mechanism to do so\n* Eve (or whoever stole her credentials) has transfer rights to that NFT from Alice\u2019s vault and can steal that NFT and transfer to anyone\n\n",
                "Repair": "Recommend adding a boolean parameter to approveTransferERC721() and set the nftApprovals  to that parameter which can be true for giving approval and false for removing/revoking approval\nIf msg.sender != _getOwner(), call approveTransferERC721() with the boolean false to remove approval before making a transfer in transferERC721() on L515.\n\nxyz-ctrl (Visor) commented(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/34#issuecomment-862438325):\n duplicate\n https://github.com/code-423n4/2021-05-visorfinance-findings/issues/35\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/34#issuecomment-873475636):\n #35 is about token being stuck in the vault. This issue is about not being able to revoke approval. Marking this as separate.\n\nztcrypto (Visor) patched(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/34#issuecomment-889187960):\n  patch link(https://github.com/VisorFinance/visor-core/commit/71797204108fee8375bfb99a435c0e379bbcbd84#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "transferERC",
                    "timelockERC",
                    "timeUnlockERC"
                ],
                "Type": "  transferERC721  doesn't clean  timelockERC721s ",
                "Description": "\nThe function transferERC721 works similar to the functions timeUnlockERC721 with timelocked NFT's.\nHowever timeUnlockERC721 cleans timelockERC721s (delete timelockERC721s[key];), while transferERC721 doesn't clean timelockERC721s\n\nThis could mean that timelock keys could be used later on (when the NFT would have been transferred to the contract on a later moment in time). Also, the administration doesn't correspond to the available NFT's. Additionally doing a delete gives backs some gas (at least for now).\n\nSee Issue #19(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/19) for code referenced in proof of concept\n\n",
                "Repair": "Recommend checking if the timelockERC721s mapping should also be cleaned from transferERC721, if so adapt the code accordingly.\n\nxyz-ctrl (Visor) confirmed(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/19#issuecomment-862433933):\n\nztcrypto (Visor) patched(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/19#issuecomment-889177823):\n  patch link(https://github.com/VisorFinance/visor-core/commit/cc22d6e450e16aaa9eb3af1ee4d9e6ac8afe43da#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport {EIP712} from \"./EIP712.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {OwnableERC721} from \"./OwnableERC721.sol\";\nimport {IRageQuit} from \"../hypervisor/Hypervisor.sol\";\n\nimport {IUniversalVault} from \"../interfaces/IUniversalVault.sol\";\nimport {IVisorService} from \"../interfaces/IVisorService.sol\";\n\n/// @title Visor\n/// @notice Vault for isolated storage of staking tokens\n/// @dev Warning: not compatible with rebasing tokens\ncontract Visor is\n    IUniversalVault,\n    EIP712(\"UniversalVault\", \"1.0.0\"),\n    ERC1271,\n    OwnableERC721,\n    Initializable,\n    IERC721Receiver\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using Address for address payable;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /* constant */\n\n    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks\n    // the gas requirement cannot be determined at runtime by querying the delegate\n    // as it could potentially be manipulated by a malicious delegate who could force\n    // the calls to revert.\n    // The gas limit could alternatively be set upon vault initialization or creation\n    // of a lock, but the gas consumption trade-offs are not favorable.\n    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant RAGEQUIT_GAS = 500000;\n    bytes32 public constant LOCK_TYPEHASH =\n        keccak256(\"Lock(address delegate,address token,uint256 amount,uint256 nonce)\");\n    bytes32 public constant UNLOCK_TYPEHASH =\n        keccak256(\"Unlock(address delegate,address token,uint256 amount,uint256 nonce)\");\n\n    string public constant VERSION = \"VISOR-2.0.3\";\n\n    /* storage */\n\n    uint256 private _nonce;\n    mapping(bytes32 => LockData) private _locks;\n    EnumerableSet.Bytes32Set private _lockSet;\n    string public uri;\n\n    struct Nft {\n      uint256 tokenId; \n      address nftContract;\n    }\n\n    Nft[] public nfts;\n    mapping(bytes32=>bool) public nftApprovals;\n    mapping(bytes32=>uint256) public erc20Approvals;\n\n    struct TimelockERC20 {\n      address recipient;\n      address token;\n      uint256 amount;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC20) public timelockERC20s; \n    mapping(address=>bytes32[]) public timelockERC20Keys;\n    mapping(address=>uint256) public timelockERC20Balances;\n\n    struct TimelockERC721 {\n      address recipient;\n      address nftContract;\n      uint256 tokenId;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC721) public timelockERC721s; \n    mapping(address=>bytes32[]) public timelockERC721Keys;\n\n    event AddNftToken(address nftContract, uint256 tokenId);\n    event RemoveNftToken(address nftContract, uint256 tokenId);\n    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n\n    /* initialization function */\n\n    function initializeLock() external initializer {}\n\n    function initialize() external override initializer {\n      OwnableERC721._setNFT(msg.sender);\n    }\n\n    /* ether receive */\n\n    receive() external payable {}\n\n    /* internal  */\n\n    function _addNft(address nftContract, uint256 tokenId) internal {\n\n      nfts.push(\n        Nft({\n          tokenId: tokenId,\n          nftContract: nftContract\n        })\n      );\n      emit AddNftToken(nftContract, tokenId);\n    }\n\n    function _removeNft(address nftContract, uint256 tokenId) internal {\n      uint256 len = nfts.length;\n      for (uint256 i = 0; i < len; i++) {\n        Nft memory nftInfo = nfts[i];\n        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {\n          if(i != len - 1) {\n            nfts[i] = nfts[len - 1];\n          }\n          nfts.pop();\n          emit RemoveNftToken(nftContract, tokenId);\n          break;\n        }\n      }\n    }\n\n    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {\n        return OwnableERC721.owner();\n    }\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        public\n        pure\n        override\n        returns (bytes32 lockID)\n    {\n        return keccak256(abi.encodePacked(delegate, token));\n    }\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) public view override returns (bytes32 permissionHash) {\n        return\n            EIP712._hashTypedDataV4(\n                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))\n            );\n    }\n\n    function getNonce() external view override returns (uint256 nonce) {\n        return _nonce;\n    }\n\n    function owner()\n        public\n        view\n        override(IUniversalVault, OwnableERC721)\n        returns (address ownerAddress)\n    {\n        return OwnableERC721.owner();\n    }\n\n    function getLockSetCount() external view override returns (uint256 count) {\n        return _lockSet.length();\n    }\n\n    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {\n        return _locks[_lockSet.at(index)];\n    }\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _locks[calculateLockID(delegate, token)].balance;\n    }\n\n    function getBalanceLocked(address token) public view override returns (uint256 balance) {\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            if (_lockData.token == token && _lockData.balance > balance)\n                balance = _lockData.balance;\n        }\n        return balance;\n    }\n\n    function checkBalances() external view override returns (bool validity) {\n        // iterate over all token locks and validate sufficient balance\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            // fetch storage lock reference\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            // if insufficient balance and no\u220ft shutdown, return false\n            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;\n        }\n        // if sufficient balance or shutdown, return true\n        return true;\n    }\n\n    // @notice Get ERC721 from nfts[] by index\n    /// @param i nfts index of nfts[] \n    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {\n        require(i < nfts.length, \"ID overflow\");\n        Nft memory ni = nfts[i];\n        nftContract = ni.nftContract;\n        tokenId = ni.tokenId;\n    }\n\n    // @notice Get index of ERC721 in nfts[]\n    /// @param nftContract Address of ERC721 \n    /// @param tokenId tokenId for NFT in nftContract \n    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {\n        uint256 len = nfts.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {\n                return i;\n            }\n        }\n        require(false, \"Token not found\");\n    }\n\n    // @notice Get number of timelocks for given ERC20 token \n    function getTimeLockCount(address token) public view returns(uint256) {\n      return timelockERC20Keys[token].length;\n    }\n\n    // @notice Get number of timelocks for NFTs of a given ERC721 contract \n    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {\n      return timelockERC721Keys[nftContract].length;\n    }\n\n    /* user functions */\n\n    /// @notice Lock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: anytime\n    /// state scope:\n    /// - insert or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being locked\n    /// @param amount Amount of tokens being locked\n    /// @param permission Permission signature payload\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // add lock to storage\n        if (_lockSet.contains(lockID)) {\n            // if lock already exists, increase amount\n            _locks[lockID].balance = _locks[lockID].balance.add(amount);\n        } else {\n            // if does not exist, create new lock\n            // add lock to set\n            assert(_lockSet.add(lockID));\n            // add lock data to storage\n            _locks[lockID] = LockData(msg.sender, token, amount);\n        }\n\n        // validate sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,\n            \"UniversalVault: insufficient balance\"\n        );\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Locked(msg.sender, token, amount);\n    }\n\n    /// @notice Unlock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being unlocked\n    /// @param amount Amount of tokens being unlocked\n    /// @param permission Permission signature payload\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // update lock data\n        if (_locks[lockID].balance > amount) {\n            // substract amount from lock balance\n            _locks[lockID].balance = _locks[lockID].balance.sub(amount);\n        } else {\n            // delete lock data\n            delete _locks[lockID];\n            assert(_lockSet.remove(lockID));\n        }\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Unlocked(msg.sender, token, amount);\n    }\n\n    /// @notice Forcibly cancel delegate lock\n    /// @dev This function will attempt to notify the delegate of the rage quit using\n    ///      a fixed amount of gas.\n    /// access control: only owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove item from _locks\n    /// token transfer: none\n    /// @param delegate Address of delegate\n    /// @param token Address of token being unlocked\n    function rageQuit(address delegate, address token)\n        external\n        override\n        onlyOwner\n        returns (bool notified, string memory error)\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(delegate, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // attempt to notify delegate\n        if (delegate.isContract()) {\n            // check for sufficient gas\n            require(gasleft() >= RAGEQUIT_GAS, \"UniversalVault: insufficient gas\");\n\n            // attempt rageQuit notification\n            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {\n                notified = true;\n            } catch Error(string memory res) {\n                notified = false;\n                error = res;\n            } catch (bytes memory) {\n                notified = false;\n            }\n        }\n\n        // update lock storage\n        assert(_lockSet.remove(lockID));\n        delete _locks[lockID];\n\n        // emit event\n        emit RageQuit(delegate, token, notified, error);\n    }\n\n    function setURI(string memory _uri) public onlyOwner {\n      uri = _uri;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault\n    /// access control: only owner\n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC20 tokens out of vault\n    /// @param token Address of token being transferred\n    /// @param delegate Address being approved\n    /// @param amount Amount of tokens approved to transfer\n    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {\n      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault with an approved account\n    /// access control: only approved accounts in erc20Approvals \n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function delegatedTransferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        if(msg.sender != _getOwner()) {\n\n        require( \n            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,\n            \"Account not approved to transfer amount\"); \n        } \n\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n        \n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @notice Transfer ETH out of vault\n    /// access control: only owner\n    /// state machine: when balance >= amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param to Address of the to\n    /// @param amount Amount of ETH to transfer\n    function transferETH(address to, uint256 amount) external payable override onlyOwner {\n      // perform transfer\n      TransferHelper.safeTransferETH(to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC721 token out of vault\n    /// @param delegate Account address being approved to transfer nft  \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function approveTransferERC721(\n      address delegate, \n      address nftContract, \n      uint256 tokenId\n    ) external onlyOwner {\n      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;\n    }\n\n    /// @notice Transfer ERC721 out of vault\n    /// access control: only owner or approved\n    /// ERC721 transfer: transfer any ERC721 token\n    /// @param to recipient address \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function transferERC721(\n        address to,\n        address nftContract,\n        uint256 tokenId\n    ) external {\n        if(msg.sender != _getOwner()) {\n          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\"); \n        } \n\n        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {\n          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {\n              require(\n                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, \n                \"NFT locked and not expired\"\n              );\n              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, \"NFT locked and must be withdrawn by timelock recipient\");\n          }\n        }\n\n        _removeNft(nftContract, tokenId);\n        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n    // @notice Adjust nfts[] on ERC721 token recieved \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {\n      _addNft(msg.sender, tokenId);\n      return IERC721Receiver.onERC721Received.selector;\n    }\n\n    // @notice Lock ERC721 in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw \n    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n \n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n\n      require(\n        timelockERC721s[key].expires == 0,\n        \"TimelockERC721 already exists\"\n      );\n     \n      timelockERC721s[key] = TimelockERC721({\n          recipient: recipient,\n          nftContract: nftContract,\n          tokenId: tokenId,\n          expires: expires\n      });\n\n      timelockERC721Keys[nftContract].push(key);\n\n      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);\n      emit TimeLockERC20(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Withdraw ERC721 in vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n      require(\n        timelockERC721s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC721s[key].recipient, \"Not recipient\");\n\n      _removeNft(nftContract, tokenId);\n      delete timelockERC721s[key];\n\n      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);\n      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {\n\n      require(\n        IERC20(token).allowance(msg.sender, address(this)) >= amount, \n        \"Amount not approved\"\n      );\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n\n      require(\n        timelockERC20s[key].expires == 0,\n        \"TimelockERC20 already exists\"\n      );\n    \n      timelockERC20s[key] = TimelockERC20({\n          recipient: recipient,\n          token: token,\n          amount: amount,\n          expires: expires\n      });\n      timelockERC20Keys[token].push(key);\n      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);\n      IERC20(token).transferFrom(msg.sender, address(this), amount);\n      emit TimeLockERC20(recipient, token, amount, expires);\n    }\n\n    // @notice Withdraw ERC20 from vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {\n\n      require(\n        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),\n        \"Insufficient balance\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n      require(\n        timelockERC20s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC20s[key].recipient, \"Not recipient\");\n      \n      delete timelockERC20s[key];\n\n      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);\n      TransferHelper.safeTransfer(token, recipient, amount);\n      emit TimeUnlockERC20(recipient, token, amount, expires);\n    }\n\n}\n\n\n",
        "CodeNames": [
            "Visor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "transferERC"
                ],
                "Type": " Approval for NFT transfers is not removed after transfer",
                "Description": "\nThe Visor.transferERC721 does not reset the approval for the NFT.\n\nAn approved delegatee can move the NFT out of the contract once.\nIt could be moved to a market and bought by someone else who then deposits it again to the same vault.\nThe first delegatee can steal the NFT and move it out of the contract a second time.\n\n",
                "Repair": "Recommend resetting the approval on transfer.\n\nxyz-ctrl (Visor) confirmed(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/48#issuecomment-856953219):\n We will be mitigating this issue for our next release and before these experimental features are introduced in platform.\n PR pending\n\nztcrypto (Visor) commented(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/48#issuecomment-889192312):\n duplicate of above ones and fixed\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "timelockERC"
                ],
                "Type": "  timelockERC721Keys  could exceed the block size limit",
                "Description": "\nOn line 504 of Visor.sol, looping through the timelockERC721Keys could exceed the block size limit\n\n",
                "Repair": "Recommend transfer by index instead of token ID\n\nxyz-ctrl (Visor) acknowledged(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/65#issuecomment-862604018):\n sponsor acknowledged\n We will be significantly refactoring experimental nft functionality in our next version before exposing to users of platform.\n In this refactor we will cap size of nft collection\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/65#issuecomment-873558427):\n I\u2019m going to bump it to medium severity because this may happen if project is very successful\n\nztcrypto (Visor) patched(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/65#issuecomment-889198875):\n patch link(https://github.com/VisorFinance/visor-core/commit/585bedc435c297af5c91be7f525acf0832885a09#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)\n\n By using EnumerableSets\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IUniversalVault {\n    /* user events */\n\n    event Locked(address delegate, address token, uint256 amount);\n    event Unlocked(address delegate, address token, uint256 amount);\n    event RageQuit(address delegate, address token, bool notified, string reason);\n\n    /* data types */\n\n    struct LockData {\n        address delegate;\n        address token;\n        uint256 balance;\n    }\n\n    /* initialize function */\n\n    function initialize() external;\n\n    /* user functions */\n\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function rageQuit(address delegate, address token)\n        external\n        returns (bool notified, string memory error);\n\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n\n    function transferETH(address to, uint256 amount) external payable;\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        external\n        pure\n        returns (bytes32 lockID);\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) external view returns (bytes32 permissionHash);\n\n    function getNonce() external view returns (uint256 nonce);\n\n    function owner() external view returns (address ownerAddress);\n\n    function getLockSetCount() external view returns (uint256 count);\n\n    function getLockAt(uint256 index) external view returns (LockData memory lockData);\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        returns (uint256 balance);\n\n    function getBalanceLocked(address token) external view returns (uint256 balance);\n\n    function checkBalances() external view returns (bool validity);\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/drafts/IERC20Permit.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\";\n\nimport {IHypervisor} from \"./hypervisor/Hypervisor.sol\";\nimport {IUniversalVault} from \"./visor/Visor.sol\";\nimport {IFactory} from \"./factory/IFactory.sol\";\n\n/// @title Mainframe\ncontract Mainframe is ERC721Holder {\n    function mintVisorAndStake(\n        address hypervisor,\n        address visorFactory,\n        address visorOwner,\n        uint256 amount,\n        bytes32 salt,\n        bytes calldata permission\n    ) external returns (address vault) {\n        // create vault\n        vault = IFactory(visorFactory).create2(\"\", salt);\n        // get staking token\n        address stakingToken = IHypervisor(hypervisor).getHypervisorData().stakingToken;\n        // transfer ownership\n        IERC721(visorFactory).safeTransferFrom(address(this), visorOwner, uint256(vault));\n        // transfer tokens\n        TransferHelper.safeTransferFrom(stakingToken, msg.sender, vault, amount);\n        // stake\n        IHypervisor(hypervisor).stake(vault, amount, permission);\n    }\n\n    struct Permit {\n        address owner;\n        address spender;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function mintVisorPermitAndStake(\n        address hypervisor,\n        address visorFactory,\n        address visorOwner,\n        bytes32 salt,\n        Permit calldata permit,\n        bytes calldata permission\n    ) external returns (address vault) {\n        // create vault\n        vault = IFactory(visorFactory).create2(\"\", salt);\n        // transfer ownership\n        IERC721(visorFactory).safeTransferFrom(address(this), visorOwner, uint256(vault));\n        // permit and stake\n        permitAndStake(hypervisor, vault, permit, permission);\n        // return vault\n        return vault;\n    }\n\n    function permitAndStake(\n        address hypervisor,\n        address vault,\n        Permit calldata permit,\n        bytes calldata permission\n    ) public {\n        // get staking token\n        address stakingToken = IHypervisor(hypervisor).getHypervisorData().stakingToken;\n        // permit transfer\n        IERC20Permit(stakingToken).permit(\n            permit.owner,\n            permit.spender,\n            permit.value,\n            permit.deadline,\n            permit.v,\n            permit.r,\n            permit.s\n        );\n        // transfer tokens\n        TransferHelper.safeTransferFrom(stakingToken, msg.sender, vault, permit.value);\n        // stake\n        IHypervisor(hypervisor).stake(vault, permit.value, permission);\n    }\n\n    struct StakeRequest {\n        address hypervisor;\n        address vault;\n        uint256 amount;\n        bytes permission;\n    }\n\n    function stakeMulti(StakeRequest[] calldata requests) external {\n        for (uint256 index = 0; index < requests.length; index++) {\n            StakeRequest calldata request = requests[index];\n            IHypervisor(request.hypervisor).stake(request.vault, request.amount, request.permission);\n        }\n    }\n\n    struct UnstakeRequest {\n        address hypervisor;\n        address vault;\n        uint256 amount;\n        bytes permission;\n    }\n\n    function unstakeMulti(UnstakeRequest[] calldata requests) external {\n        for (uint256 index = 0; index < requests.length; index++) {\n            UnstakeRequest calldata request = requests[index];\n            IHypervisor(request.hypervisor).unstakeAndClaim(\n                request.vault,\n                request.amount,\n                request.permission\n            );\n        }\n    }\n\n    function predictDeterministicAddress(\n        address master,\n        bytes32 salt,\n        address deployer\n    ) external pure returns (address instance) {\n        return Clones.predictDeterministicAddress(master, salt, deployer);\n    }\n\n    function stake(\n        address hypervisor,\n        address vault,\n        uint256 value,\n        bytes calldata permission\n    ) public {\n        // get staking token\n        address stakingToken = IHypervisor(hypervisor).getHypervisorData().stakingToken;\n        // transfer tokens\n        TransferHelper.safeTransferFrom(stakingToken, msg.sender, vault, value);\n        // stake\n        IHypervisor(hypervisor).stake(vault, value, permission);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport {EIP712} from \"./EIP712.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {OwnableERC721} from \"./OwnableERC721.sol\";\nimport {IRageQuit} from \"../hypervisor/Hypervisor.sol\";\n\nimport {IUniversalVault} from \"../interfaces/IUniversalVault.sol\";\nimport {IVisorService} from \"../interfaces/IVisorService.sol\";\n\n/// @title Visor\n/// @notice Vault for isolated storage of staking tokens\n/// @dev Warning: not compatible with rebasing tokens\ncontract Visor is\n    IUniversalVault,\n    EIP712(\"UniversalVault\", \"1.0.0\"),\n    ERC1271,\n    OwnableERC721,\n    Initializable,\n    IERC721Receiver\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using Address for address payable;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /* constant */\n\n    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks\n    // the gas requirement cannot be determined at runtime by querying the delegate\n    // as it could potentially be manipulated by a malicious delegate who could force\n    // the calls to revert.\n    // The gas limit could alternatively be set upon vault initialization or creation\n    // of a lock, but the gas consumption trade-offs are not favorable.\n    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant RAGEQUIT_GAS = 500000;\n    bytes32 public constant LOCK_TYPEHASH =\n        keccak256(\"Lock(address delegate,address token,uint256 amount,uint256 nonce)\");\n    bytes32 public constant UNLOCK_TYPEHASH =\n        keccak256(\"Unlock(address delegate,address token,uint256 amount,uint256 nonce)\");\n\n    string public constant VERSION = \"VISOR-2.0.3\";\n\n    /* storage */\n\n    uint256 private _nonce;\n    mapping(bytes32 => LockData) private _locks;\n    EnumerableSet.Bytes32Set private _lockSet;\n    string public uri;\n\n    struct Nft {\n      uint256 tokenId; \n      address nftContract;\n    }\n\n    Nft[] public nfts;\n    mapping(bytes32=>bool) public nftApprovals;\n    mapping(bytes32=>uint256) public erc20Approvals;\n\n    struct TimelockERC20 {\n      address recipient;\n      address token;\n      uint256 amount;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC20) public timelockERC20s; \n    mapping(address=>bytes32[]) public timelockERC20Keys;\n    mapping(address=>uint256) public timelockERC20Balances;\n\n    struct TimelockERC721 {\n      address recipient;\n      address nftContract;\n      uint256 tokenId;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC721) public timelockERC721s; \n    mapping(address=>bytes32[]) public timelockERC721Keys;\n\n    event AddNftToken(address nftContract, uint256 tokenId);\n    event RemoveNftToken(address nftContract, uint256 tokenId);\n    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n\n    /* initialization function */\n\n    function initializeLock() external initializer {}\n\n    function initialize() external override initializer {\n      OwnableERC721._setNFT(msg.sender);\n    }\n\n    /* ether receive */\n\n    receive() external payable {}\n\n    /* internal  */\n\n    function _addNft(address nftContract, uint256 tokenId) internal {\n\n      nfts.push(\n        Nft({\n          tokenId: tokenId,\n          nftContract: nftContract\n        })\n      );\n      emit AddNftToken(nftContract, tokenId);\n    }\n\n    function _removeNft(address nftContract, uint256 tokenId) internal {\n      uint256 len = nfts.length;\n      for (uint256 i = 0; i < len; i++) {\n        Nft memory nftInfo = nfts[i];\n        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {\n          if(i != len - 1) {\n            nfts[i] = nfts[len - 1];\n          }\n          nfts.pop();\n          emit RemoveNftToken(nftContract, tokenId);\n          break;\n        }\n      }\n    }\n\n    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {\n        return OwnableERC721.owner();\n    }\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        public\n        pure\n        override\n        returns (bytes32 lockID)\n    {\n        return keccak256(abi.encodePacked(delegate, token));\n    }\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) public view override returns (bytes32 permissionHash) {\n        return\n            EIP712._hashTypedDataV4(\n                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))\n            );\n    }\n\n    function getNonce() external view override returns (uint256 nonce) {\n        return _nonce;\n    }\n\n    function owner()\n        public\n        view\n        override(IUniversalVault, OwnableERC721)\n        returns (address ownerAddress)\n    {\n        return OwnableERC721.owner();\n    }\n\n    function getLockSetCount() external view override returns (uint256 count) {\n        return _lockSet.length();\n    }\n\n    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {\n        return _locks[_lockSet.at(index)];\n    }\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _locks[calculateLockID(delegate, token)].balance;\n    }\n\n    function getBalanceLocked(address token) public view override returns (uint256 balance) {\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            if (_lockData.token == token && _lockData.balance > balance)\n                balance = _lockData.balance;\n        }\n        return balance;\n    }\n\n    function checkBalances() external view override returns (bool validity) {\n        // iterate over all token locks and validate sufficient balance\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            // fetch storage lock reference\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            // if insufficient balance and no\u220ft shutdown, return false\n            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;\n        }\n        // if sufficient balance or shutdown, return true\n        return true;\n    }\n\n    // @notice Get ERC721 from nfts[] by index\n    /// @param i nfts index of nfts[] \n    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {\n        require(i < nfts.length, \"ID overflow\");\n        Nft memory ni = nfts[i];\n        nftContract = ni.nftContract;\n        tokenId = ni.tokenId;\n    }\n\n    // @notice Get index of ERC721 in nfts[]\n    /// @param nftContract Address of ERC721 \n    /// @param tokenId tokenId for NFT in nftContract \n    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {\n        uint256 len = nfts.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {\n                return i;\n            }\n        }\n        require(false, \"Token not found\");\n    }\n\n    // @notice Get number of timelocks for given ERC20 token \n    function getTimeLockCount(address token) public view returns(uint256) {\n      return timelockERC20Keys[token].length;\n    }\n\n    // @notice Get number of timelocks for NFTs of a given ERC721 contract \n    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {\n      return timelockERC721Keys[nftContract].length;\n    }\n\n    /* user functions */\n\n    /// @notice Lock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: anytime\n    /// state scope:\n    /// - insert or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being locked\n    /// @param amount Amount of tokens being locked\n    /// @param permission Permission signature payload\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // add lock to storage\n        if (_lockSet.contains(lockID)) {\n            // if lock already exists, increase amount\n            _locks[lockID].balance = _locks[lockID].balance.add(amount);\n        } else {\n            // if does not exist, create new lock\n            // add lock to set\n            assert(_lockSet.add(lockID));\n            // add lock data to storage\n            _locks[lockID] = LockData(msg.sender, token, amount);\n        }\n\n        // validate sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,\n            \"UniversalVault: insufficient balance\"\n        );\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Locked(msg.sender, token, amount);\n    }\n\n    /// @notice Unlock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being unlocked\n    /// @param amount Amount of tokens being unlocked\n    /// @param permission Permission signature payload\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // update lock data\n        if (_locks[lockID].balance > amount) {\n            // substract amount from lock balance\n            _locks[lockID].balance = _locks[lockID].balance.sub(amount);\n        } else {\n            // delete lock data\n            delete _locks[lockID];\n            assert(_lockSet.remove(lockID));\n        }\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Unlocked(msg.sender, token, amount);\n    }\n\n    /// @notice Forcibly cancel delegate lock\n    /// @dev This function will attempt to notify the delegate of the rage quit using\n    ///      a fixed amount of gas.\n    /// access control: only owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove item from _locks\n    /// token transfer: none\n    /// @param delegate Address of delegate\n    /// @param token Address of token being unlocked\n    function rageQuit(address delegate, address token)\n        external\n        override\n        onlyOwner\n        returns (bool notified, string memory error)\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(delegate, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // attempt to notify delegate\n        if (delegate.isContract()) {\n            // check for sufficient gas\n            require(gasleft() >= RAGEQUIT_GAS, \"UniversalVault: insufficient gas\");\n\n            // attempt rageQuit notification\n            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {\n                notified = true;\n            } catch Error(string memory res) {\n                notified = false;\n                error = res;\n            } catch (bytes memory) {\n                notified = false;\n            }\n        }\n\n        // update lock storage\n        assert(_lockSet.remove(lockID));\n        delete _locks[lockID];\n\n        // emit event\n        emit RageQuit(delegate, token, notified, error);\n    }\n\n    function setURI(string memory _uri) public onlyOwner {\n      uri = _uri;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault\n    /// access control: only owner\n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC20 tokens out of vault\n    /// @param token Address of token being transferred\n    /// @param delegate Address being approved\n    /// @param amount Amount of tokens approved to transfer\n    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {\n      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault with an approved account\n    /// access control: only approved accounts in erc20Approvals \n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function delegatedTransferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        if(msg.sender != _getOwner()) {\n\n        require( \n            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,\n            \"Account not approved to transfer amount\"); \n        } \n\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n        \n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @notice Transfer ETH out of vault\n    /// access control: only owner\n    /// state machine: when balance >= amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param to Address of the to\n    /// @param amount Amount of ETH to transfer\n    function transferETH(address to, uint256 amount) external payable override onlyOwner {\n      // perform transfer\n      TransferHelper.safeTransferETH(to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC721 token out of vault\n    /// @param delegate Account address being approved to transfer nft  \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function approveTransferERC721(\n      address delegate, \n      address nftContract, \n      uint256 tokenId\n    ) external onlyOwner {\n      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;\n    }\n\n    /// @notice Transfer ERC721 out of vault\n    /// access control: only owner or approved\n    /// ERC721 transfer: transfer any ERC721 token\n    /// @param to recipient address \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function transferERC721(\n        address to,\n        address nftContract,\n        uint256 tokenId\n    ) external {\n        if(msg.sender != _getOwner()) {\n          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\"); \n        } \n\n        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {\n          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {\n              require(\n                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, \n                \"NFT locked and not expired\"\n              );\n              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, \"NFT locked and must be withdrawn by timelock recipient\");\n          }\n        }\n\n        _removeNft(nftContract, tokenId);\n        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n    // @notice Adjust nfts[] on ERC721 token recieved \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {\n      _addNft(msg.sender, tokenId);\n      return IERC721Receiver.onERC721Received.selector;\n    }\n\n    // @notice Lock ERC721 in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw \n    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n \n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n\n      require(\n        timelockERC721s[key].expires == 0,\n        \"TimelockERC721 already exists\"\n      );\n     \n      timelockERC721s[key] = TimelockERC721({\n          recipient: recipient,\n          nftContract: nftContract,\n          tokenId: tokenId,\n          expires: expires\n      });\n\n      timelockERC721Keys[nftContract].push(key);\n\n      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);\n      emit TimeLockERC20(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Withdraw ERC721 in vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n      require(\n        timelockERC721s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC721s[key].recipient, \"Not recipient\");\n\n      _removeNft(nftContract, tokenId);\n      delete timelockERC721s[key];\n\n      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);\n      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {\n\n      require(\n        IERC20(token).allowance(msg.sender, address(this)) >= amount, \n        \"Amount not approved\"\n      );\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n\n      require(\n        timelockERC20s[key].expires == 0,\n        \"TimelockERC20 already exists\"\n      );\n    \n      timelockERC20s[key] = TimelockERC20({\n          recipient: recipient,\n          token: token,\n          amount: amount,\n          expires: expires\n      });\n      timelockERC20Keys[token].push(key);\n      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);\n      IERC20(token).transferFrom(msg.sender, address(this), amount);\n      emit TimeLockERC20(recipient, token, amount, expires);\n    }\n\n    // @notice Withdraw ERC20 from vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {\n\n      require(\n        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),\n        \"Insufficient balance\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n      require(\n        timelockERC20s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC20s[key].recipient, \"Not recipient\");\n      \n      delete timelockERC20s[key];\n\n      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);\n      TransferHelper.safeTransfer(token, recipient, amount);\n      emit TimeUnlockERC20(recipient, token, amount, expires);\n    }\n\n}\n\n\n// This is a file copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/token/ERC721/IERC721Receiver.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\n",
        "CodeNames": [
            "IUniversalVault.sol",
            "Mainframe.sol",
            "Visor.sol",
            "IERC721Receiver.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "timeUnlockERC",
                    "onERC",
                    "transferERC",
                    "safeTransferFrom",
                    "_removeNft"
                ],
                "Type": " Unbounded loop in  _removeNft  could lead to a griefing/DOS attack",
                "Description": "\nGriefing/DOS attack is possible when a malicious NFT contract sends many NFTs to the vault, which could cause excessive gas consumed and even transactions reverted when other users are trying to unlock or transfer NFTs.\n\nThe function _removeNft uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas.\nThe function onERC721Received is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts.\nA malicious user could write an NFT contract, which calls onERC721Received of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., safeTransferFrom) its NFT.\nThe vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, transferERC721 and timeUnlockERC721, fail since the malicious NFT contract reverts all safeTransferFrom calls.\nAs a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time.\n\n",
                "Repair": "Recommend using a mapping (e.g., mapping(address=Nft[]) nfts) to store the received NFTs into separate arrays according to nftContract instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly.\n\nxyz-ctrl (Visor) confirmed(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-856368771):\n sponsor confirmed\n We are working to mitigate this issue in our next upgrade\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-873481532):\nI\u2019m making this high severity because it doesn\u2019t need a malicious actor to happen. This can happen by simply being very successful\n\nxyz-ctrl (Visor) commented(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-856368771):\n  Agreed. We merged a pr with mitigations a few weeks ago here VisorFinance/visor-core#2(https://github.com/VisorFinance/visor-core/pull/2)\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-873524863):\n Duplicate of #66(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/66)\n\nztcrypto (Visor) patched(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80#issuecomment-889198308):\n duplicated and patched\n link(https://github.com/VisorFinance/visor-core/commit/585bedc435c297af5c91be7f525acf0832885a09#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IUniversalVault {\n    /* user events */\n\n    event Locked(address delegate, address token, uint256 amount);\n    event Unlocked(address delegate, address token, uint256 amount);\n    event RageQuit(address delegate, address token, bool notified, string reason);\n\n    /* data types */\n\n    struct LockData {\n        address delegate;\n        address token;\n        uint256 balance;\n    }\n\n    /* initialize function */\n\n    function initialize() external;\n\n    /* user functions */\n\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function rageQuit(address delegate, address token)\n        external\n        returns (bool notified, string memory error);\n\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n\n    function transferETH(address to, uint256 amount) external payable;\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        external\n        pure\n        returns (bytes32 lockID);\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) external view returns (bytes32 permissionHash);\n\n    function getNonce() external view returns (uint256 nonce);\n\n    function owner() external view returns (address ownerAddress);\n\n    function getLockSetCount() external view returns (uint256 count);\n\n    function getLockAt(uint256 index) external view returns (LockData memory lockData);\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        returns (uint256 balance);\n\n    function getBalanceLocked(address token) external view returns (uint256 balance);\n\n    function checkBalances() external view returns (bool validity);\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/drafts/IERC20Permit.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\";\n\nimport {IHypervisor} from \"./hypervisor/Hypervisor.sol\";\nimport {IUniversalVault} from \"./visor/Visor.sol\";\nimport {IFactory} from \"./factory/IFactory.sol\";\n\n/// @title Mainframe\ncontract Mainframe is ERC721Holder {\n    function mintVisorAndStake(\n        address hypervisor,\n        address visorFactory,\n        address visorOwner,\n        uint256 amount,\n        bytes32 salt,\n        bytes calldata permission\n    ) external returns (address vault) {\n        // create vault\n        vault = IFactory(visorFactory).create2(\"\", salt);\n        // get staking token\n        address stakingToken = IHypervisor(hypervisor).getHypervisorData().stakingToken;\n        // transfer ownership\n        IERC721(visorFactory).safeTransferFrom(address(this), visorOwner, uint256(vault));\n        // transfer tokens\n        TransferHelper.safeTransferFrom(stakingToken, msg.sender, vault, amount);\n        // stake\n        IHypervisor(hypervisor).stake(vault, amount, permission);\n    }\n\n    struct Permit {\n        address owner;\n        address spender;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function mintVisorPermitAndStake(\n        address hypervisor,\n        address visorFactory,\n        address visorOwner,\n        bytes32 salt,\n        Permit calldata permit,\n        bytes calldata permission\n    ) external returns (address vault) {\n        // create vault\n        vault = IFactory(visorFactory).create2(\"\", salt);\n        // transfer ownership\n        IERC721(visorFactory).safeTransferFrom(address(this), visorOwner, uint256(vault));\n        // permit and stake\n        permitAndStake(hypervisor, vault, permit, permission);\n        // return vault\n        return vault;\n    }\n\n    function permitAndStake(\n        address hypervisor,\n        address vault,\n        Permit calldata permit,\n        bytes calldata permission\n    ) public {\n        // get staking token\n        address stakingToken = IHypervisor(hypervisor).getHypervisorData().stakingToken;\n        // permit transfer\n        IERC20Permit(stakingToken).permit(\n            permit.owner,\n            permit.spender,\n            permit.value,\n            permit.deadline,\n            permit.v,\n            permit.r,\n            permit.s\n        );\n        // transfer tokens\n        TransferHelper.safeTransferFrom(stakingToken, msg.sender, vault, permit.value);\n        // stake\n        IHypervisor(hypervisor).stake(vault, permit.value, permission);\n    }\n\n    struct StakeRequest {\n        address hypervisor;\n        address vault;\n        uint256 amount;\n        bytes permission;\n    }\n\n    function stakeMulti(StakeRequest[] calldata requests) external {\n        for (uint256 index = 0; index < requests.length; index++) {\n            StakeRequest calldata request = requests[index];\n            IHypervisor(request.hypervisor).stake(request.vault, request.amount, request.permission);\n        }\n    }\n\n    struct UnstakeRequest {\n        address hypervisor;\n        address vault;\n        uint256 amount;\n        bytes permission;\n    }\n\n    function unstakeMulti(UnstakeRequest[] calldata requests) external {\n        for (uint256 index = 0; index < requests.length; index++) {\n            UnstakeRequest calldata request = requests[index];\n            IHypervisor(request.hypervisor).unstakeAndClaim(\n                request.vault,\n                request.amount,\n                request.permission\n            );\n        }\n    }\n\n    function predictDeterministicAddress(\n        address master,\n        bytes32 salt,\n        address deployer\n    ) external pure returns (address instance) {\n        return Clones.predictDeterministicAddress(master, salt, deployer);\n    }\n\n    function stake(\n        address hypervisor,\n        address vault,\n        uint256 value,\n        bytes calldata permission\n    ) public {\n        // get staking token\n        address stakingToken = IHypervisor(hypervisor).getHypervisorData().stakingToken;\n        // transfer tokens\n        TransferHelper.safeTransferFrom(stakingToken, msg.sender, vault, value);\n        // stake\n        IHypervisor(hypervisor).stake(vault, value, permission);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport {EIP712} from \"./EIP712.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {OwnableERC721} from \"./OwnableERC721.sol\";\nimport {IRageQuit} from \"../hypervisor/Hypervisor.sol\";\n\nimport {IUniversalVault} from \"../interfaces/IUniversalVault.sol\";\nimport {IVisorService} from \"../interfaces/IVisorService.sol\";\n\n/// @title Visor\n/// @notice Vault for isolated storage of staking tokens\n/// @dev Warning: not compatible with rebasing tokens\ncontract Visor is\n    IUniversalVault,\n    EIP712(\"UniversalVault\", \"1.0.0\"),\n    ERC1271,\n    OwnableERC721,\n    Initializable,\n    IERC721Receiver\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using Address for address payable;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /* constant */\n\n    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks\n    // the gas requirement cannot be determined at runtime by querying the delegate\n    // as it could potentially be manipulated by a malicious delegate who could force\n    // the calls to revert.\n    // The gas limit could alternatively be set upon vault initialization or creation\n    // of a lock, but the gas consumption trade-offs are not favorable.\n    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant RAGEQUIT_GAS = 500000;\n    bytes32 public constant LOCK_TYPEHASH =\n        keccak256(\"Lock(address delegate,address token,uint256 amount,uint256 nonce)\");\n    bytes32 public constant UNLOCK_TYPEHASH =\n        keccak256(\"Unlock(address delegate,address token,uint256 amount,uint256 nonce)\");\n\n    string public constant VERSION = \"VISOR-2.0.3\";\n\n    /* storage */\n\n    uint256 private _nonce;\n    mapping(bytes32 => LockData) private _locks;\n    EnumerableSet.Bytes32Set private _lockSet;\n    string public uri;\n\n    struct Nft {\n      uint256 tokenId; \n      address nftContract;\n    }\n\n    Nft[] public nfts;\n    mapping(bytes32=>bool) public nftApprovals;\n    mapping(bytes32=>uint256) public erc20Approvals;\n\n    struct TimelockERC20 {\n      address recipient;\n      address token;\n      uint256 amount;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC20) public timelockERC20s; \n    mapping(address=>bytes32[]) public timelockERC20Keys;\n    mapping(address=>uint256) public timelockERC20Balances;\n\n    struct TimelockERC721 {\n      address recipient;\n      address nftContract;\n      uint256 tokenId;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC721) public timelockERC721s; \n    mapping(address=>bytes32[]) public timelockERC721Keys;\n\n    event AddNftToken(address nftContract, uint256 tokenId);\n    event RemoveNftToken(address nftContract, uint256 tokenId);\n    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n\n    /* initialization function */\n\n    function initializeLock() external initializer {}\n\n    function initialize() external override initializer {\n      OwnableERC721._setNFT(msg.sender);\n    }\n\n    /* ether receive */\n\n    receive() external payable {}\n\n    /* internal  */\n\n    function _addNft(address nftContract, uint256 tokenId) internal {\n\n      nfts.push(\n        Nft({\n          tokenId: tokenId,\n          nftContract: nftContract\n        })\n      );\n      emit AddNftToken(nftContract, tokenId);\n    }\n\n    function _removeNft(address nftContract, uint256 tokenId) internal {\n      uint256 len = nfts.length;\n      for (uint256 i = 0; i < len; i++) {\n        Nft memory nftInfo = nfts[i];\n        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {\n          if(i != len - 1) {\n            nfts[i] = nfts[len - 1];\n          }\n          nfts.pop();\n          emit RemoveNftToken(nftContract, tokenId);\n          break;\n        }\n      }\n    }\n\n    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {\n        return OwnableERC721.owner();\n    }\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        public\n        pure\n        override\n        returns (bytes32 lockID)\n    {\n        return keccak256(abi.encodePacked(delegate, token));\n    }\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) public view override returns (bytes32 permissionHash) {\n        return\n            EIP712._hashTypedDataV4(\n                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))\n            );\n    }\n\n    function getNonce() external view override returns (uint256 nonce) {\n        return _nonce;\n    }\n\n    function owner()\n        public\n        view\n        override(IUniversalVault, OwnableERC721)\n        returns (address ownerAddress)\n    {\n        return OwnableERC721.owner();\n    }\n\n    function getLockSetCount() external view override returns (uint256 count) {\n        return _lockSet.length();\n    }\n\n    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {\n        return _locks[_lockSet.at(index)];\n    }\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _locks[calculateLockID(delegate, token)].balance;\n    }\n\n    function getBalanceLocked(address token) public view override returns (uint256 balance) {\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            if (_lockData.token == token && _lockData.balance > balance)\n                balance = _lockData.balance;\n        }\n        return balance;\n    }\n\n    function checkBalances() external view override returns (bool validity) {\n        // iterate over all token locks and validate sufficient balance\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            // fetch storage lock reference\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            // if insufficient balance and no\u220ft shutdown, return false\n            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;\n        }\n        // if sufficient balance or shutdown, return true\n        return true;\n    }\n\n    // @notice Get ERC721 from nfts[] by index\n    /// @param i nfts index of nfts[] \n    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {\n        require(i < nfts.length, \"ID overflow\");\n        Nft memory ni = nfts[i];\n        nftContract = ni.nftContract;\n        tokenId = ni.tokenId;\n    }\n\n    // @notice Get index of ERC721 in nfts[]\n    /// @param nftContract Address of ERC721 \n    /// @param tokenId tokenId for NFT in nftContract \n    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {\n        uint256 len = nfts.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {\n                return i;\n            }\n        }\n        require(false, \"Token not found\");\n    }\n\n    // @notice Get number of timelocks for given ERC20 token \n    function getTimeLockCount(address token) public view returns(uint256) {\n      return timelockERC20Keys[token].length;\n    }\n\n    // @notice Get number of timelocks for NFTs of a given ERC721 contract \n    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {\n      return timelockERC721Keys[nftContract].length;\n    }\n\n    /* user functions */\n\n    /// @notice Lock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: anytime\n    /// state scope:\n    /// - insert or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being locked\n    /// @param amount Amount of tokens being locked\n    /// @param permission Permission signature payload\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // add lock to storage\n        if (_lockSet.contains(lockID)) {\n            // if lock already exists, increase amount\n            _locks[lockID].balance = _locks[lockID].balance.add(amount);\n        } else {\n            // if does not exist, create new lock\n            // add lock to set\n            assert(_lockSet.add(lockID));\n            // add lock data to storage\n            _locks[lockID] = LockData(msg.sender, token, amount);\n        }\n\n        // validate sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,\n            \"UniversalVault: insufficient balance\"\n        );\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Locked(msg.sender, token, amount);\n    }\n\n    /// @notice Unlock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being unlocked\n    /// @param amount Amount of tokens being unlocked\n    /// @param permission Permission signature payload\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // update lock data\n        if (_locks[lockID].balance > amount) {\n            // substract amount from lock balance\n            _locks[lockID].balance = _locks[lockID].balance.sub(amount);\n        } else {\n            // delete lock data\n            delete _locks[lockID];\n            assert(_lockSet.remove(lockID));\n        }\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Unlocked(msg.sender, token, amount);\n    }\n\n    /// @notice Forcibly cancel delegate lock\n    /// @dev This function will attempt to notify the delegate of the rage quit using\n    ///      a fixed amount of gas.\n    /// access control: only owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove item from _locks\n    /// token transfer: none\n    /// @param delegate Address of delegate\n    /// @param token Address of token being unlocked\n    function rageQuit(address delegate, address token)\n        external\n        override\n        onlyOwner\n        returns (bool notified, string memory error)\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(delegate, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // attempt to notify delegate\n        if (delegate.isContract()) {\n            // check for sufficient gas\n            require(gasleft() >= RAGEQUIT_GAS, \"UniversalVault: insufficient gas\");\n\n            // attempt rageQuit notification\n            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {\n                notified = true;\n            } catch Error(string memory res) {\n                notified = false;\n                error = res;\n            } catch (bytes memory) {\n                notified = false;\n            }\n        }\n\n        // update lock storage\n        assert(_lockSet.remove(lockID));\n        delete _locks[lockID];\n\n        // emit event\n        emit RageQuit(delegate, token, notified, error);\n    }\n\n    function setURI(string memory _uri) public onlyOwner {\n      uri = _uri;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault\n    /// access control: only owner\n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC20 tokens out of vault\n    /// @param token Address of token being transferred\n    /// @param delegate Address being approved\n    /// @param amount Amount of tokens approved to transfer\n    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {\n      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault with an approved account\n    /// access control: only approved accounts in erc20Approvals \n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function delegatedTransferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        if(msg.sender != _getOwner()) {\n\n        require( \n            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,\n            \"Account not approved to transfer amount\"); \n        } \n\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n        \n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @notice Transfer ETH out of vault\n    /// access control: only owner\n    /// state machine: when balance >= amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param to Address of the to\n    /// @param amount Amount of ETH to transfer\n    function transferETH(address to, uint256 amount) external payable override onlyOwner {\n      // perform transfer\n      TransferHelper.safeTransferETH(to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC721 token out of vault\n    /// @param delegate Account address being approved to transfer nft  \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function approveTransferERC721(\n      address delegate, \n      address nftContract, \n      uint256 tokenId\n    ) external onlyOwner {\n      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;\n    }\n\n    /// @notice Transfer ERC721 out of vault\n    /// access control: only owner or approved\n    /// ERC721 transfer: transfer any ERC721 token\n    /// @param to recipient address \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function transferERC721(\n        address to,\n        address nftContract,\n        uint256 tokenId\n    ) external {\n        if(msg.sender != _getOwner()) {\n          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\"); \n        } \n\n        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {\n          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {\n              require(\n                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, \n                \"NFT locked and not expired\"\n              );\n              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, \"NFT locked and must be withdrawn by timelock recipient\");\n          }\n        }\n\n        _removeNft(nftContract, tokenId);\n        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n    // @notice Adjust nfts[] on ERC721 token recieved \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {\n      _addNft(msg.sender, tokenId);\n      return IERC721Receiver.onERC721Received.selector;\n    }\n\n    // @notice Lock ERC721 in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw \n    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n \n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n\n      require(\n        timelockERC721s[key].expires == 0,\n        \"TimelockERC721 already exists\"\n      );\n     \n      timelockERC721s[key] = TimelockERC721({\n          recipient: recipient,\n          nftContract: nftContract,\n          tokenId: tokenId,\n          expires: expires\n      });\n\n      timelockERC721Keys[nftContract].push(key);\n\n      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);\n      emit TimeLockERC20(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Withdraw ERC721 in vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n      require(\n        timelockERC721s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC721s[key].recipient, \"Not recipient\");\n\n      _removeNft(nftContract, tokenId);\n      delete timelockERC721s[key];\n\n      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);\n      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {\n\n      require(\n        IERC20(token).allowance(msg.sender, address(this)) >= amount, \n        \"Amount not approved\"\n      );\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n\n      require(\n        timelockERC20s[key].expires == 0,\n        \"TimelockERC20 already exists\"\n      );\n    \n      timelockERC20s[key] = TimelockERC20({\n          recipient: recipient,\n          token: token,\n          amount: amount,\n          expires: expires\n      });\n      timelockERC20Keys[token].push(key);\n      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);\n      IERC20(token).transferFrom(msg.sender, address(this), amount);\n      emit TimeLockERC20(recipient, token, amount, expires);\n    }\n\n    // @notice Withdraw ERC20 from vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {\n\n      require(\n        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),\n        \"Insufficient balance\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n      require(\n        timelockERC20s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC20s[key].recipient, \"Not recipient\");\n      \n      delete timelockERC20s[key];\n\n      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);\n      TransferHelper.safeTransfer(token, recipient, amount);\n      emit TimeUnlockERC20(recipient, token, amount, expires);\n    }\n\n}\n\n\n",
        "CodeNames": [
            "IUniversalVault.sol",
            "Mainframe.sol",
            "Visor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "safeTransfer",
                    "timelockERC",
                    "timeUnlockERC",
                    "TransferHelper",
                    "transfer",
                    "transferERC",
                    "timeLockERC",
                    "transferFrom",
                    "delegatedTransferERC",
                    "transferFrom()",
                    "TimeLockERC"
                ],
                "Type": " Unhandled return value of  transferFrom  in  timeLockERC20()  could lead to fund loss for recipients",
                "Description": "\nERC20 implementations are not always consistent. Some implementations of transfer\u00a0and transferFrom could return \u2018false\u2019 on failure instead of reverting. It is safer to wrap such calls into\u00a0require()\u00a0statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from Consensys Diligence Audit of Aave Protocol V2(https://consensys.net/diligence/audits/2020/09/aave-protocol-v2/#unhandled-return-values-of-transfer-and-transferfrom).\n\nWhile the contract uses Uniswap\u2019s TransferHelper library function safeTransfer in other places for ERC20 tokens, or OpenZeppelin\u2019s saferTransferFrom for ERC721 tokens (both of which call the token\u2019s transfer/transferFrom functions and check return value for success and return data), it misses using TransferHelper.safeTransferFrom in this one case on L610 in timeLockERC20() when tokens are transferred from owner to the vault and instead directly uses the token\u2019s transferFrom() call without checking for its return value.\n\nThe impact can be that for an arbitrary ERC20 token, this transferFrom() call may return failure but the vault logic misses that, assumes it was successfully transferred into the vault and updates the timelockERC20Balances accounting accordingly. The timeUnlockERC20(), transferERC20() or delegatedTransferERC20() calls for that token will fail because the vault contract balance would have less tokens than accounted for in timelockERC20Balances because of the previously failed (but ignored) transferFrom() call.\n\n1. Let\u2019s say Alice owes Bob 100 USD after a week, for which they agree that Alice will pay in 100 tokens of USD stablecoin tokenA.\n2. Alice, the vault owner, calls timeLockERC20() for recipient=Bob, token=tokenA, amount=100 and expiry=1-week-from-then (corresponding Unix timestamp) but tokenA\u2019s implementation does not revert on failure but instead returns true/false. If the transferFrom failed, say because Alice did not have those 100 tokenAs, the return value is ignored on L610 in timeLockERC20() and vault logic considers that it indeed has 100 tokenAs locked for Bob.\n3. Bob looks at the TimeLockERC20 event emitted in the successful timeLockERC20() transaction from Alice and assumes 100 tokenAs are indeed locked by Alice in the vault for him which can be withdrawn after expiry.\n4. After timelock expiry, Bob tries to transfer the 100 tokenAs Alice locked in the vault for him. The TransferHelper.safeTransfer() call on L637 in timeUnlockERC20() fails because the vault has 0 tokenAs because they were never successfully transferred in Step 2.\n5. Bob could thus be tricked into thinking that 100 tokenAs are locked in the vault for him by Alice but they never were. This leads to loss of funds for Bob.\n\n",
                "Repair": "Recommend replacing use of\nsolidity\nIERC20(token).transferFrom(msg.sender, address(this), amount);\n\nwith\nsolidity\nTransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n\nThis will revert on transfer failure for e.g. if msg.sender does not have a token balance = amount.\n\nxyz-ctrl (Visor) acknowledged(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/39#issuecomment-862446159):\n sponsor acknowledged\n disagree with severity 0\n While we may include refactor in next version, this is all foreseen behavior and is component of many stable ethereum project.\n The onus here is on client\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/39#issuecomment-873477796):\n I\u2019m going to make it medium as the risk is there but it could be mitigated by UI and tokens that are used.\n\nztcrypto (Visor) patched(https://github.com/code-423n4/2021-05-visorfinance-findings/issues/39#issuecomment-889172980):\n fixed patch link(https://github.com/VisorFinance/visor-core/commit/71797204108fee8375bfb99a435c0e379bbcbd84#diff-b094db7ce2f99cbcbde7ec178a6754bac666e2192f076807acbd70d49ddd0559)\n\n\n"
            }
        ]
    }
]