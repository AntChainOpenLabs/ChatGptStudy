[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Total supply can be incorrect in  ERC20 ",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/ERC20.sol#L33\n<https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L95\n\n_totalSupply can be initialized to something different than 0, which would lead to an inaccurate total supply, and could easily break integrations, computations of market cap, etc.\n\n\nIf the constructor is called with _initialSupply = 1000, the totalSupply will be initialized to 1000.\n\nAs all the others computations are correct, there will be for ever a discrepancy of 1000 between the real total supply and the one of the contract.\n\n",
                "Repair": "\nRemove _initialSupply.\n\nnivasan1 (Canto) acknowledged(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/88)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/88#issuecomment-1214474058):\n  Same bug as from Canto V1.\n Recommend the sponsor to just set to 0 and remove the assignment from the constructor\n\n  See: https://github.com/code-423n4/2022-06-canto-findings/issues/108\n\nPlease note: the following additional discussions took place after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.\n\nshung (warden) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/88#issuecomment-1236024995):\n  In the provided contracts, v2 repo is included: https://github.com/code-423n4/2022-06-canto-v2\n \n However, in this submission, the second line of code provided links to the v1 repo. The described issue only exists in v1 version. In v2 version the issue does not exist because msg.sender balance is updated along with the total supply: https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/ERC20.sol#L34\n \n Therefore this finding seems invalid.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/88#issuecomment-1236132294):\n  @shung You're right, I must have missed the line with the mitigation.\n \n The current code will update the _totalSupply and will give the balance to the deployer.\n \n This is a mistake on my part and the finding should have been closed as invalid as it was mitigated in the V2 code in scope.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/88#issuecomment-1236133140):\n  While a nitpick I'd recommend changing the code to use _mint as it the code in scope will not emit an event which may cause issues if you're tracking via theGraph or similar.\n \n Either way I made a mistake here, sorry about that.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "javascript\n    function doTransferOut(address payable to, uint amount) virtual override internal {\n        require(address(_accountant) != address(0));\n        EIP20Interface token = EIP20Interface(underlying);\n        if (to != address(_accountant)) {\n            uint err = _accountant.supplyMarket(amount);\n            if (err != 0) { revert AccountantRedeemError(amount); }\n        }   \n        token.transfer(to, amount);\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 { success := not(0) }\n                case 32 { \n                    returndatacopy(0, 0, 32)\n                    success := mload(0)\n                }\n                default { revert(0, 0) }\n        } \n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n        require(token.balanceOf(address(this)) == 0, \"cNote::doTransferOut: TransferOut Failed\"); // <-ERROR\n    }\n"
                ],
                "Type": " Deny of service in  CNote.doTransferOut ",
                "Description": "\n<https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/CNote.sol#L148<br\n\nThe CNote.doTransferOut method is susceptible to denial of service.\n\n\nThe logic of the doTransferOut method in CNote is as follows:\n\njavascript\n    function doTransferOut(address payable to, uint amount) virtual override internal {\n        require(address(_accountant) != address(0));\n        EIP20Interface token = EIP20Interface(underlying);\n        if (to != address(_accountant)) {\n            uint err = _accountant.supplyMarket(amount);\n            if (err != 0) { revert AccountantRedeemError(amount); }\n        }   \n        token.transfer(to, amount);\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 { success := not(0) }\n                case 32 { \n                    returndatacopy(0, 0, 32)\n                    success := mload(0)\n                }\n                default { revert(0, 0) }\n        } \n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n        require(token.balanceOf(address(this)) == 0, \"cNote::doTransferOut: TransferOut Failed\"); // <-ERROR\n    }\n\n\nThe doTransferOut method receives an amount which is transferred to to, after it the balance of the contract token is checked to be equal to zero or the transaction will be reverted.\n\nIn the following cases a denial of service will occur:\n\n*   In the case that is used an amount different than the balance, the transaction will be reverted.\n*   In the case that an attacker front-runs the transaction and sends one token more than the established by the _accountant.\n*   In case of increasing balance tokens like mDai that constantly change their balance, the established by the _accountant will be different when the transaction is persisted.\n\n",
                "Repair": "\n*   Use balance differences instead of the 0 check.\n\nnivasan1 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/43)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/43#issuecomment-1216823120):\n  The warden has shown how, anyone, via a simple transfer of underlying can deny the functionality of doTransferOut.\n \n Because the function is used in multiple functions inherited from CToken, and the griefing can be easily run by anyone, I believe High Severity to be appropriate.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [],
                "Type": " Underlying asset price oracle for  CToken  in  BaseV1-periphery  is inaccurate",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/Stableswap/BaseV1-periphery.sol#L489<br\n\nUnderlying asset price oracle for CToken in BaseV1-periphery is inaccurate.\n\n\n        function getUnderlyingPrice(CToken ctoken) external override view returns(uint price) {\n            IBaseV1Pair pair;\n            uint8 stable;\n            bool stablePair;\n            address underlying;\n\n            if (compareStrings(ctoken.symbol(), \"cCANTO\")) {\n                stable = 0;\n                underlying = address(wcanto);\n            } \n            //set price statically to 1 when the Comptroller is retrieving Price\n            else if (compareStrings(ctoken.symbol(), \"cNOTE\") && msg.sender == Comptroller) {\n                return 1; // Note price is fixed to 1\n            }\n\nWe should not be return 1. 1 is 1 wei. We should be 10 &ast;&ast; 18\n\n\nVIM\n\n",
                "Repair": "\nWe can return 10 &ast;&ast; 18\n\nnivasan1 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/134)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/134#issuecomment-1216832609):\n  The warden has shown what probably is a developer mistake, which will scale down the price of the cNOTE token to 1.\n \n The sponsor confirms.\n \n It should be noted that if cNOTE always returns 1e18 then the math for diff(https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L147-L148) will always be zero, meaning the interest will exclusively be dictated by baseRatePerYear.\n \n Because the sponsor confirms, and because the comments point to values \"scaled by 1e18\" I believe the finding to be valid, and since the \"math is wrong\", I do agree with High Severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [],
                "Type": " Oracle  periodSize  is very low allowing the TWAP price to be easily manipulated",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-core.sol#L72\n\nTWAP oracle easily manipulated.\n\n\nperiodSize is set to 0 meaning that the oracle will take a new observation every single block, which would allow an attacker to easily flood the TWAP oracle and manipulate the price.\n\n",
                "Repair": "\nIncrease periodSize to be greater than 0, 1800 is typically standard.\n\nnivasan1 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/124)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/124#issuecomment-1216838068):\n  The warden has identified a constant set to zero for the time in between TWAP observations.\n \n Because the code change:\n Is a mistake (evidenced by the comments)\n Causes the TWAP (already put into question in previous contest) to become a Spot Oracle\n There's no way to remediate as the variable is constant\n The change will end up resulting in a manipulatable quote which will impact getUnderlyingPrice\n \n I agree with High Severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [],
                "Type": " The LP pair underlying price quote could be manipulated",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-periphery.sol#L522-L526<br\n<https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-periphery.sol#L198-L217\n\nThe underlying price for LP pool pair can be manipulated. This kind of price mainpulation happened before, can be found here: Warp Fincance event(https://rekt.news/warp-finance-rekt/).\n\nWhich may lead to the exploit of the pool by a malicious user.\n\n\nfile: lending-market-v2/contracts/Stableswap/BaseV1-periphery.sol<br\n522-526\uff0c 198-217:\n\n                uint price0 = (token0 != USDC) ? IBaseV1Pair(pairFor(USDC, token0, stable0)).quote(token0, 1, 8) : 1;\n                uint price1 = (token1 != USDC) ? IBaseV1Pair(pairFor(USDC, token1, stable1)).quote(token1, 1, 8) : 1;\n                // how much of each asset is 1 LP token redeemable for\n                (uint amt0, uint amt1) = quoteRemoveLiquidity(token0, token1, stablePair, 1);\n                price = amt0 * price0 + amt1 * price1;\n\n\n        function quoteRemoveLiquidity(\n            address tokenA,\n            address tokenB,\n            bool stable,\n            uint liquidity\n        ) public view returns (uint amountA, uint amountB) {\n            // create the pair if it doesn\"t exist yet\n            address _pair = IBaseV1Factory(factory).getPair(tokenA, tokenB, stable);\n\n            if (_pair == address(0)) {\n                return (0,0);\n            }\n\n            (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n            uint _totalSupply = erc20(_pair).totalSupply();\n\n            amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution\n            amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution\n\n        }\n\nThe price of the LP pair is determined by the TVL of the pool, given by:<br\namt0 * price0 + amt1 * price1. However, when a malicious user dumps large amount of any token into the pool, the whole TVL will be significantly increased, which leads to inproper calculation of the price.\n\n",
                "Repair": "\nA differenct approach to calculate the LP price can be found here(https://cmichel.io/pricing-lp-tokens/).\n\nnivasan1 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/152)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/152#issuecomment-1216847622):\n  The warden has shown how the LP Token Pricing math is incorrect, this is a mispricing that historically has resulted in total loss of funds and the subject is well known.\n \n Remediation can be attained by following the guide linked:\n https://cmichel.io/pricing-lp-tokens/\n \n Because the:\n Math is incorrect\n Exploit allows anyone to inflate prices within 1 block (no risk)\n \n High Severity is appropriate.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [],
                "Type": "  getBorrowRate  returns rate per year instead of per block",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/NoteInterest.sol#L118<br\n<https://github.com/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/CToken.sol#L209\n\nAccording to the documentation in InterestRateModel, getBorrowRate has to return the borrow rate per block and the function borrowRatePerBlock in CToken directly returns the value of getBorrowRate. However, the rate per year is returned for NoteInterest. Therefore, using NoteInterest as an interest model will result in completely wrong values.\n\n",
                "Repair": "\nReturn baseRatePerBlock.\n\nnivasan1 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/38)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/38#issuecomment-1216901711):\n  The warden has shown that the borrowRate is returning per-year values instead of per-block values.\n \n The effect of this is that the accounting will be magnified massively.\n \n While impact should be mostly loss of value to interest and incorrect yield, due to the math being wrong I do agree with High Severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [
                    "javascript\n\t\tbool success = cnote.transfer(treasury, amtToSweep);\n\t\tif (!success) { revert  SweepError(treasury , amtToSweep); }\n\t\tTreasuryInterface Treas = TreasuryInterface(treasury);\n\t\tTreas.redeem(address(cnote),amtToSweep);\n\t\trequire(cnote.balanceOf(treasury) == 0, \"AccountantDelegate::sweepInterestError\");\n"
                ],
                "Type": " Deny of service in  AccountantDelegate.sweepInterest ",
                "Description": "\n<https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/Accountant/AccountantDelegate.sol#L101\n\nThe sweepInterest method is susceptible to denial of service.\n\n\nThe logic of the sweepInterest method relative to the treasury is as follows:\n\njavascript\n\t\tbool success = cnote.transfer(treasury, amtToSweep);\n\t\tif (!success) { revert  SweepError(treasury , amtToSweep); }\n\t\tTreasuryInterface Treas = TreasuryInterface(treasury);\n\t\tTreas.redeem(address(cnote),amtToSweep);\n\t\trequire(cnote.balanceOf(treasury) == 0, \"AccountantDelegate::sweepInterestError\");\n\n\nAs you can see, amtToSweep is passed to it and redeem that amount. Later it is checked that the balance of cnote in the treasury address must be 0. However, all calculations related to amtToSweep come out of the balance of address(this)(https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/Accountant/AccountantDelegate.sol#L83-L84) so if a third party sends a single token cnote to the address of treasury the method will be denied.\n\n",
                "Repair": "\n*   Check that the balance is the same after and before the bool success = cnote.transfer(treasury, amtToSweep);\n\nnivasan1 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/28)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-v2-findings/issues/28#issuecomment-1216930433):\n  The warden has shown how, due to an incorrect invariant (treasury having zero cNote), any griefer can permanently brick the sweepInterest function.\n \n The finding shows how a loss of yield can be achieved, so Medium Severity would be in order.\n \n However, because:\n an invariant was broken\n the tokens cannot be withdrawn via an alternative method\n \n I believe High Severity to be more appropriate.\n\n\n\n*\n\n\n"
            }
        ]
    }
]