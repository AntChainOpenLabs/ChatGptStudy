[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/utils/MerkleProofLib.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./Caviar.sol\";\n\n/// @title Pair\n/// @author out.eth (@outdoteth)\n/// @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.\ncontract Pair is ERC20, ERC721TokenReceiver {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n    address public immutable nft;\n    address public immutable baseToken; // address(0) for ETH\n    bytes32 public immutable merkleRoot;\n    LpToken public immutable lpToken;\n    Caviar public immutable caviar;\n    uint256 public closeTimestamp;\n\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Buy(uint256 inputAmount, uint256 outputAmount);\n    event Sell(uint256 inputAmount, uint256 outputAmount);\n    event Wrap(uint256[] tokenIds);\n    event Unwrap(uint256[] tokenIds);\n    event Close(uint256 closeTimestamp);\n    event Withdraw(uint256 tokenId);\n\n    constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n        nft = _nft;\n        baseToken = _baseToken; // use address(0) for native ETH\n        merkleRoot = _merkleRoot;\n        lpToken = new LpToken(pairSymbol);\n        caviar = Caviar(msg.sender);\n    }\n\n    // ************************ //\n    //      Core AMM logic      //\n    // ***********************  //\n\n    /// @notice Adds liquidity to the pair.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @param minLpTokenAmount The minimum amount of LP tokens to mint.\n    /// @return lpTokenAmount The amount of LP tokens minted.\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n        public\n        payable\n        returns (uint256 lpTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check the token amount inputs are not zero\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate the lp token shares to mint\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n\n        // check that the amount of lp tokens outputted is greater than the min amount\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens in\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // mint lp tokens to sender\n        lpToken.mint(msg.sender, lpTokenAmount);\n\n        // transfer base tokens in if the base token is not ETH\n        if (baseToken != address(0)) {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair.\n    /// @param lpTokenAmount The amount of LP tokens to burn.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // *** Checks *** //\n\n        // calculate the output amounts\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);\n\n        // check that the base token output amount is greater than the min amount\n        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");\n\n        // check that the fractional token output amount is greater than the min amount\n        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);\n\n        // *** Interactions *** //\n\n        // burn lp tokens from sender\n        lpToken.burn(msg.sender, lpTokenAmount);\n\n        if (baseToken == address(0)) {\n            // if base token is native ETH then send ether to sender\n            msg.sender.safeTransferETH(baseTokenOutputAmount);\n        } else {\n            // transfer base tokens to sender\n            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);\n        }\n\n        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);\n    }\n\n    /// @notice Buys fractional tokens from the pair.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // *** Checks *** //\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate required input amount using xyk invariant\n        inputAmount = buyQuote(outputAmount);\n\n        // check that the required amount of base tokens is less than the max amount\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, outputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // refund surplus eth\n            uint256 refundAmount = maxInputAmount - inputAmount;\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n        } else {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n\n        emit Buy(inputAmount, outputAmount);\n    }\n\n    /// @notice Sells fractional tokens to the pair.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @return outputAmount The amount of base tokens received.\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n        // *** Checks *** //\n\n        // calculate output amount using xyk invariant\n        outputAmount = sellQuote(inputAmount);\n\n        // check that the outputted amount of fractional tokens is greater than the min amount\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens from sender\n        _transferFrom(msg.sender, address(this), inputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // transfer ether out\n            msg.sender.safeTransferETH(outputAmount);\n        } else {\n            // transfer base tokens out\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n        }\n\n        emit Sell(inputAmount, outputAmount);\n    }\n\n    // ******************** //\n    //      Wrap logic      //\n    // ******************** //\n\n    /// @notice Wraps NFTs into fractional tokens.\n    /// @param tokenIds The ids of the NFTs to wrap.\n    /// @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.\n    /// @return fractionalTokenAmount The amount of fractional tokens minted.\n    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n        public\n        returns (uint256 fractionalTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check that wrapping is not closed\n        require(closeTimestamp == 0, \"Wrap: closed\");\n\n        // check the tokens exist in the merkle root\n        _validateTokenIds(tokenIds, proofs);\n\n        // *** Effects *** //\n\n        // mint fractional tokens to sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _mint(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts from sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        emit Wrap(tokenIds);\n    }\n\n    /// @notice Unwraps fractional tokens into NFTs.\n    /// @param tokenIds The ids of the NFTs to unwrap.\n    /// @return fractionalTokenAmount The amount of fractional tokens burned.\n    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n        // *** Effects *** //\n\n        // burn fractional tokens from sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _burn(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts to sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        emit Unwrap(tokenIds);\n    }\n\n    // *********************** //\n    //      NFT AMM logic      //\n    // *********************** //\n\n    /// @notice nftAdd Adds liquidity to the pair using NFTs.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param tokenIds The ids of the NFTs to add.\n    /// @param minLpTokenAmount The minimum amount of lp tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return lpTokenAmount The amount of lp tokens minted.\n    function nftAdd(\n        uint256 baseTokenAmount,\n        uint256[] calldata tokenIds,\n        uint256 minLpTokenAmount,\n        bytes32[][] calldata proofs\n    ) public payable returns (uint256 lpTokenAmount) {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);\n\n        // add liquidity using the fractional tokens and base tokens\n        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair using NFTs.\n    /// @param lpTokenAmount The amount of lp tokens to remove.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param tokenIds The ids of the NFTs to remove.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // remove liquidity and send fractional tokens and base tokens to sender\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) =\n            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Buys NFTs from the pair using base tokens.\n    /// @param tokenIds The ids of the NFTs to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // buy fractional tokens using base tokens\n        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Sells NFTs to the pair for base tokens.\n    /// @param tokenIds The ids of the NFTs to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return outputAmount The amount of base tokens received.\n    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)\n        public\n        returns (uint256 outputAmount)\n    {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 inputAmount = wrap(tokenIds, proofs);\n\n        // sell fractional tokens for base tokens\n        outputAmount = sell(inputAmount, minOutputAmount);\n    }\n\n    // ****************************** //\n    //      Emergency exit logic      //\n    // ****************************** //\n\n    /// @notice Closes the pair to new wraps.\n    /// @dev Can only be called by the caviar owner. This is used as an emergency exit in case\n    ///      the caviar owner suspects that the pair has been compromised.\n    function close() public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Close: not owner\");\n\n        // set the close timestamp with a grace period\n        closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;\n\n        // remove the pair from the Caviar contract\n        caviar.destroy(nft, baseToken, merkleRoot);\n\n        emit Close(closeTimestamp);\n    }\n\n    /// @notice Withdraws a particular NFT from the pair.\n    /// @dev Can only be called by the caviar owner after the close grace period has passed. This\n    ///      is used to auction off the NFTs in the pair in case NFTs get stuck due to liquidity\n    ///      imbalances. Proceeds from the auction should be distributed pro rata to fractional\n    ///      token holders. See documentation for more details.\n    function withdraw(uint256 tokenId) public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Withdraw: not owner\");\n\n        // check that the close period has been set\n        require(closeTimestamp != 0, \"Withdraw not initiated\");\n\n        // check that the close grace period has passed\n        require(block.timestamp >= closeTimestamp, \"Not withdrawable yet\");\n\n        // transfer the nft to the caviar owner\n        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(tokenId);\n    }\n\n    // ***************** //\n    //      Getters      //\n    // ***************** //\n\n    function baseTokenReserves() public view returns (uint256) {\n        return _baseTokenReserves();\n    }\n\n    function fractionalTokenReserves() public view returns (uint256) {\n        return balanceOf[address(this)];\n    }\n\n    /// @notice The current price of one fractional token in base tokens with 18 decimals of precision.\n    /// @dev Calculated by dividing the base token reserves by the fractional token reserves.\n    /// @return price The price of one fractional token in base tokens * 1e18.\n    function price() public view returns (uint256) {\n        return (_baseTokenReserves() * ONE) / fractionalTokenReserves();\n    }\n\n    /// @notice The amount of base tokens required to buy a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @return inputAmount The amount of base tokens required.\n    function buyQuote(uint256 outputAmount) public view returns (uint256) {\n        return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n    }\n\n    /// @notice The amount of base tokens received for selling a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @return outputAmount The amount of base tokens received.\n    function sellQuote(uint256 inputAmount) public view returns (uint256) {\n        uint256 inputAmountWithFee = inputAmount * 997;\n        return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n    }\n\n    /// @notice The amount of lp tokens received for adding a given amount of base tokens and fractional tokens.\n    /// @dev Calculated as a share of existing deposits. If there are no existing deposits, then initializes to\n    ///      sqrt(baseTokenAmount * fractionalTokenAmount).\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @return lpTokenAmount The amount of lp tokens received.\n    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        if (lpTokenSupply > 0) {\n            // calculate amount of lp tokens as a fraction of existing reserves\n            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\n            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\n            return Math.min(baseTokenShare, fractionalTokenShare);\n        } else {\n            // if there is no liquidity then init\n            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n        }\n    }\n\n    /// @notice The amount of base tokens and fractional tokens received for burning a given amount of lp tokens.\n    /// @dev Calculated as a share of existing deposits.\n    /// @param lpTokenAmount The amount of lp tokens to burn.\n    /// @return baseTokenAmount The amount of base tokens received.\n    /// @return fractionalTokenAmount The amount of fractional tokens received.\n    function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;\n        uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;\n\n        return (baseTokenOutputAmount, fractionalTokenOutputAmount);\n    }\n\n    // ************************ //\n    //      Internal utils      //\n    // ************************ //\n\n    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /// @dev Validates that the given tokenIds are valid for the contract's merkle root. Reverts\n    ///      if any of the tokenId proofs are invalid.\n    function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {\n        // if merkle root is not set then all tokens are valid\n        if (merkleRoot == bytes23(0)) return;\n\n        // validate merkle proofs against merkle root\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));\n            require(isValid, \"Invalid merkle proof\");\n        }\n    }\n\n    /// @dev Returns the current base token reserves. If the base token is ETH then it ignores\n    ///      the msg.value that is being sent in the current call context - this is to ensure the\n    ///      xyk math is correct in the buy() and add() functions.\n    function _baseTokenReserves() internal view returns (uint256) {\n        return baseToken == address(0)\n            ? address(this).balance - msg.value // subtract the msg.value if the base token is ETH\n            : ERC20(baseToken).balanceOf(address(this));\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport \"ERC721A/ERC721A.sol\";\n\ncontract FakeAzukis is ERC721A {\n    constructor() ERC721A(\"Fake Azuki\", \"AZUKI\") {}\n\n    function mint(address to, uint256 quantity) public {\n        _mint(to, quantity);\n    }\n\n    function tokenURI(uint256 tokenId) public pure override returns (string memory) {\n        return string(\n            abi.encodePacked(\n                \"https://ikzttp.mypinata.cloud/ipfs/QmQFkLSQysj94s5GvTHPyzTxrawwtjgiiYS2TBLgrvw8CW/\", _toString(tokenId)\n            )\n        );\n    }\n}\n\ncontract CreateFakeAzukisScript is Script {\n    function setUp() public {}\n\n    function run() public {\n        vm.startBroadcast();\n\n        FakeAzukis fakeAzukis = new FakeAzukis();\n        console.log(\"fake Azuki:\", address(fakeAzukis));\n\n        fakeAzukis.mint(msg.sender, 250);\n        fakeAzukis.mint(msg.sender, 250);\n    }\n}\n\n\n",
        "CodeNames": [
            "Pair.sol",
            "CreateFakeAzukis.s.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "diff\nfunction buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n    // * Checks * //\n\n    // check that correct eth input was sent if the baseToken equals address(0) then native ETH is used\n    require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n    // calculate required input amount using xyk invariant\n+   @audit Use current balances\n    inputAmount = buyQuote(outputAmount);\n\n    // check that the required amount of base tokens is less than the max amount\n    require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n    // * Effects * //\n+   @audit Modifies just fractional balance\n    // transfer fractional tokens to sender\n    _transferFrom(address(this), msg.sender, outputAmount);\n\n    // * Interactions * //\n\n    if (baseToken == address(0)) {\n        // refund surplus eth\n        uint256 refundAmount = maxInputAmount inputAmount;\n        if (refundAmount  0) msg.sender.safeTransferETH(refundAmount);\n    } else {\n\n        // transfer base tokens in\n+       @audit If an ERC-777 token is used, we can re call buy function with the same balance of base token, but with different fractional balance\n        ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n\n    }\n    emit Buy(inputAmount, outputAmount);\n}\n",
                    "//solidity\nfunction buyQuote(uint256 outputAmount) public view returns (uint256) {\n    return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() outputAmount) * 997);\n}\n",
                    "diff\nfunction sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n    // * Checks * //\n\n    // calculate output amount using xyk invariant\n    outputAmount = sellQuote(inputAmount);\n\n    // check that the outputted amount of fractional tokens is greater than the min amount\n    require(outputAmount = minOutputAmount, \"Slippage: amount out\");\n\n    // * Effects * //\n\n    // transfer fractional tokens from sender\n+   //@audit fractional balance is updated\n    _transferFrom(msg.sender, address(this), inputAmount);\n\n    // * Interactions * //\n\n    if (baseToken == address(0)) {\n        // transfer ether out\n        msg.sender.safeTransferETH(outputAmount);\n    } else {\n        // transfer base tokens out\n+       @audit If an ERC-777 token is used, we can re call sell function with the same balance of base token, but with different fractional balance.\n        ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n    }\n\n    emit Sell(inputAmount, outputAmount);\n}\n",
                    "function sellQuote(uint256 inputAmount) public view returns (uint256) {\n    uint256 inputAmountWithFee = inputAmount * 997;\n    return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n}\n"
                ],
                "Type": " Reentrancy in buy function for ERC777 tokens allows buying funds with considerable discount",
                "Description": "*Submitted by carlitox477(https://github.com/code-423n4/2022-12-caviar-findings/issues/343), also found by minhquanym(https://github.com/code-423n4/2022-12-caviar-findings/issues/445), gzeon(https://github.com/code-423n4/2022-12-caviar-findings/issues/422), 9svR6w(https://github.com/code-423n4/2022-12-caviar-findings/issues/268), Lambda(https://github.com/code-423n4/2022-12-caviar-findings/issues/258), koxuan(https://github.com/code-423n4/2022-12-caviar-findings/issues/221), KingNFT(https://github.com/code-423n4/2022-12-caviar-findings/issues/211), cozzetti(https://github.com/code-423n4/2022-12-caviar-findings/issues/125), rvierdiiev(https://github.com/code-423n4/2022-12-caviar-findings/issues/111), and cccz(https://github.com/code-423n4/2022-12-caviar-findings/issues/78)*\n\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L95<br\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L137<br\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L172<br\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L203\n\nCurrent implementation of functions add, remove, buy and sell first transfer fractional tokens, and then base tokens.\n\nIf this base token is ERC777 (extension of ERC20), we can call this function without updating the base token balance, but updating the fractional token balance.\n\n\nAllows to drain funds of a pairs which implements an ERC-777 token.\n\n\ndiff\nfunction buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n    // * Checks * //\n\n    // check that correct eth input was sent if the baseToken equals address(0) then native ETH is used\n    require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n    // calculate required input amount using xyk invariant\n+   @audit Use current balances\n    inputAmount = buyQuote(outputAmount);\n\n    // check that the required amount of base tokens is less than the max amount\n    require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n    // * Effects * //\n+   @audit Modifies just fractional balance\n    // transfer fractional tokens to sender\n    _transferFrom(address(this), msg.sender, outputAmount);\n\n    // * Interactions * //\n\n    if (baseToken == address(0)) {\n        // refund surplus eth\n        uint256 refundAmount = maxInputAmount inputAmount;\n        if (refundAmount  0) msg.sender.safeTransferETH(refundAmount);\n    } else {\n\n        // transfer base tokens in\n+       @audit If an ERC-777 token is used, we can re call buy function with the same balance of base token, but with different fractional balance\n        ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n\n    }\n    emit Buy(inputAmount, outputAmount);\n}\n\n\nsolidity\nfunction buyQuote(uint256 outputAmount) public view returns (uint256) {\n    return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() outputAmount) * 997);\n}\n\n\nThe buy quote is used to calculate the amount of fractional token that the user will receive, and it should be less/equal to maxInputAmount sent by parameter in order to achieve a successful execution of function buy.\n\nCurrent buy quote can be mathematically expressed as: $frac{outputAmount times 1000 times baseTokenReserves}{fractionalTokenReserves outPutAmount} times 997$.\n\nThen, about sales\n\ndiff\nfunction sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n    // * Checks * //\n\n    // calculate output amount using xyk invariant\n    outputAmount = sellQuote(inputAmount);\n\n    // check that the outputted amount of fractional tokens is greater than the min amount\n    require(outputAmount = minOutputAmount, \"Slippage: amount out\");\n\n    // * Effects * //\n\n    // transfer fractional tokens from sender\n+   //@audit fractional balance is updated\n    _transferFrom(msg.sender, address(this), inputAmount);\n\n    // * Interactions * //\n\n    if (baseToken == address(0)) {\n        // transfer ether out\n        msg.sender.safeTransferETH(outputAmount);\n    } else {\n        // transfer base tokens out\n+       @audit If an ERC-777 token is used, we can re call sell function with the same balance of base token, but with different fractional balance.\n        ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n    }\n\n    emit Sell(inputAmount, outputAmount);\n}\n\n\nfunction sellQuote(uint256 inputAmount) public view returns (uint256) {\n    uint256 inputAmountWithFee = inputAmount * 997;\n    return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n}\n\n\nCurrent sellQuote function can be expressed mathematically as:\n\n$inputAmount = frac{inputAmount times 997 times baseTokenReserves}{fractionalTokenReserves times 1000 + inputAmountWithFee}$\n\nThen we can think next scenario to drain a pair which use an ERC-777 token as base token:\n\n1.  Let's suppose the pair has 1000 base tokens(BT777) and 1000 Fractional reserve tokens (FRT)\n2.  The attacker call buy function, all with next inputs:\n    *   outputAmount = 50\n    *   maxInputAmount = 80\n3.  The attacker implements a hook, that will be executed 6 times (using a counter inside a malicus contract) when a transfer is done, and call the buy function. After this 6 times the malicious contract is call again, but this times calls the sell function, doing a huge sell for the fractional reserve token obtained.\n\nA simulation of this attack can be visualized in next table\n\n| Operation      | outputAmount (FRT) | maxInputAmount (BT777) | BT777 reserve | FRT reserve | inputAmount (BT777 to pay) | inputAmount < maxInputAmount |\n| :------------| -----------------| ---------------------| ------------| ----------| -------------------------| ---------------------------: |\n| Attaker buy 1  | 50                 | 80                     | 1000          | 1000        | 52                         |                         TRUE |\n| Callback buy 2 | 50                 | 80                     | 1000          | 950         | 55                         |                         TRUE |\n| Callback buy 3 | 50                 | 80                     | 1000          | 900         | 59                         |                         TRUE |\n| Callback buy 4 | 50                 | 80                     | 1000          | 850         | 62                         |                         TRUE |\n| Callback buy 5 | 50                 | 80                     | 1000          | 800         | 66                         |                         TRUE |\n| Callback buy 6 | 50                 | 80                     | 1000          | 750         | 71                         |                         TRUE |\n| Callback buy 7 | 50                 | 80                     | 1000          | 700         | 77                         |                         TRUE |\n\nThe result of this operation is that the attaker/malicious contract has 350 FRT, while BT777 reserve still has 1000 and FRT reserve has 650 tokens. The success execution needs that the attacker pays 442 BT777 eventually.\n\nTo do this, the last operation of the malicious contract is calling sell function\n\n| Operation    | inputAmount(BT777) | minOutputAmount | BT777 reserve | FRT reserve | outputAmount (BT777 to receive) | outputAmount  minOutputAmount |\n| :----------| -----------------| --------------| ------------| ----------| ------------------------------| -----------------------------: |\n| calback Sell | 350                | 442             | 1000          | 650         | 536                             |                           TRUE |\n\nThe result is that the attacker now controls 536 BT777, the attacker use this balance to pay the debt of 442 BT77, with a profit of 94 BT77 tokens.\n\n\nAdd openzeppelin nonReentrant modifier to mentioned functions, or state clear in the documentation that this protocol should not be used with ERC777 tokens.\n\noutdoteth (Caviar) acknowledged and commented(https://github.com/code-423n4/2022-12-caviar-findings/issues/343#issuecomment-1372238278):\n  Technically valid, though we don't intend to support erc777 tokens.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n// calculate amount of lp tokens as a fraction of existing reserves\nuint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\nuint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\nreturn Math.min(baseTokenShare, fractionalTokenShare);\n",
                    "//solidity\n// test/Pair/unit.Add.t.sol\n\nfunction testLockOfFunds_AUDIT() public {\n    address alice = address(0x31337);\n    address bob = address(0x12345);\n    vm.label(alice, \"alice\");\n    vm.label(bob, \"bob\");\n\n    deal(address(usd), alice, 100e18, true);\n    deal(address(usd), bob, 100e18, true);\n    deal(address(p), alice, 100e18, true);\n    deal(address(p), bob, 100e18, true);\n\n    // Alice is the first liquidity provider.\n    vm.startPrank(alice);\n    usd.approve(address(p), type(uint256).max);\n    p.add(10 ether, 10 ether, 0);\n    vm.stopPrank();\n\n    // Bob provides liquidity to the pool and sets the minimal LP amount.\n    // The token amounts are deposited in different proportions, thus the smaller\n    // one will be chosen to calculate the amount of LP tokens Bob will receive.\n    vm.startPrank(bob);\n    usd.approve(address(p), type(uint256).max);\n    uint256 minLPAmount = 1e18;\n    uint256 bobLPAmount = p.add(1.2 ether, 1 ether, minLPAmount);\n    vm.stopPrank();\n\n    // Bob has received the minimal LP amount he wanted.\n    assertEq(bobLPAmount, minLPAmount);\n\n    // However, after removing all his liquidity from the pool...\n    (uint256 bobUSDBefore, uint256 bobFracBefore) = (usd.balanceOf(bob), p.balanceOf(bob));\n    vm.prank(bob);\n    p.remove(minLPAmount, 0, 0);\n    (uint256 bobUSDAfter, uint256 bobFracAfter) = (usd.balanceOf(bob), p.balanceOf(bob));\n\n    // ... Bob received less USD than he deposited.\n    assertEq(bobUSDAfter bobUSDBefore, 1.018181818181818181 ether);\n    assertEq(bobFracAfter bobFracBefore, 1.000000000000000000 ether);\n}\n"
                ],
                "Type": " Liquidity providers may lose funds when adding liquidity",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-12-caviar-findings/issues/376), also found by minhtrng(https://github.com/code-423n4/2022-12-caviar-findings/issues/507), minhquanym(https://github.com/code-423n4/2022-12-caviar-findings/issues/444), HE1M(https://github.com/code-423n4/2022-12-caviar-findings/issues/398), wait(https://github.com/code-423n4/2022-12-caviar-findings/issues/388), hansfriese(https://github.com/code-423n4/2022-12-caviar-findings/issues/350), BAHOZ(https://github.com/code-423n4/2022-12-caviar-findings/issues/342), unforgiven(https://github.com/code-423n4/2022-12-caviar-findings/issues/340), 0xxm(https://github.com/code-423n4/2022-12-caviar-findings/issues/332), Junnon(https://github.com/code-423n4/2022-12-caviar-findings/issues/329), bytehat(https://github.com/code-423n4/2022-12-caviar-findings/issues/326), UNCHAIN(https://github.com/code-423n4/2022-12-caviar-findings/issues/316), carlitox477(https://github.com/code-423n4/2022-12-caviar-findings/issues/288), RaymondFam(https://github.com/code-423n4/2022-12-caviar-findings/issues/287), Chom(https://github.com/code-423n4/2022-12-caviar-findings/issues/285), CRYP70(https://github.com/code-423n4/2022-12-caviar-findings/issues/278), 9svR6w(https://github.com/code-423n4/2022-12-caviar-findings/issues/275), mauricio1802(https://github.com/code-423n4/2022-12-caviar-findings/issues/252), __141345__(https://github.com/code-423n4/2022-12-caviar-findings/issues/234), hihen(https://github.com/code-423n4/2022-12-caviar-findings/issues/222), caventa(https://github.com/code-423n4/2022-12-caviar-findings/issues/195), koxuan(https://github.com/code-423n4/2022-12-caviar-findings/issues/173), obront(https://github.com/code-423n4/2022-12-caviar-findings/issues/142), nicobevi(https://github.com/code-423n4/2022-12-caviar-findings/issues/122), shung(https://github.com/code-423n4/2022-12-caviar-findings/issues/90), cccz(https://github.com/code-423n4/2022-12-caviar-findings/issues/31), Bobface(https://github.com/code-423n4/2022-12-caviar-findings/issues/30), and chaduke(https://github.com/code-423n4/2022-12-caviar-findings/issues/17)*\n\nLiquidity providers may lose a portion of provided liquidity in either of the pair tokens. While the minLpTokenAmount protects from slippage when adding liquidity, it doesn't protect from providing liquidity at different K.\n\n\nThe Pair contract is designed to receive liquidity from liquidity providers ([Pair.sol#L63(https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)). First liquidity provider in a pool may provide arbitrary token amounts and set the initial price ([Pair.sol#L425-L426(https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L425-L426)), but all other liquidity providers must provide liquidity proportionally to current pool reserves ([Pair.sol#L420-L423(https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)). Since a pool is made of two tokens and liquidity is provided in both tokens, there's a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, the smaller of the proportions is chosen to calculate the amount of LP tokens minted ([Pair.sol#L420-L423(https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)):\n\nsolidity\n// calculate amount of lp tokens as a fraction of existing reserves\nuint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\nuint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\nreturn Math.min(baseTokenShare, fractionalTokenShare);\n\n\nAs a result, the difference in proportions will create an excess of tokens that won't be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it'll be shared among all liquidity providers of the pool. While the minLpTokenAmount argument of the add function ([Pair.sol#L63(https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn't allow them to minimize the disproportion of token amounts or avoid it at all.\n\nsolidity\n// test/Pair/unit.Add.t.sol\n\nfunction testLockOfFunds_AUDIT() public {\n    address alice = address(0x31337);\n    address bob = address(0x12345);\n    vm.label(alice, \"alice\");\n    vm.label(bob, \"bob\");\n\n    deal(address(usd), alice, 100e18, true);\n    deal(address(usd), bob, 100e18, true);\n    deal(address(p), alice, 100e18, true);\n    deal(address(p), bob, 100e18, true);\n\n    // Alice is the first liquidity provider.\n    vm.startPrank(alice);\n    usd.approve(address(p), type(uint256).max);\n    p.add(10 ether, 10 ether, 0);\n    vm.stopPrank();\n\n    // Bob provides liquidity to the pool and sets the minimal LP amount.\n    // The token amounts are deposited in different proportions, thus the smaller\n    // one will be chosen to calculate the amount of LP tokens Bob will receive.\n    vm.startPrank(bob);\n    usd.approve(address(p), type(uint256).max);\n    uint256 minLPAmount = 1e18;\n    uint256 bobLPAmount = p.add(1.2 ether, 1 ether, minLPAmount);\n    vm.stopPrank();\n\n    // Bob has received the minimal LP amount he wanted.\n    assertEq(bobLPAmount, minLPAmount);\n\n    // However, after removing all his liquidity from the pool...\n    (uint256 bobUSDBefore, uint256 bobFracBefore) = (usd.balanceOf(bob), p.balanceOf(bob));\n    vm.prank(bob);\n    p.remove(minLPAmount, 0, 0);\n    (uint256 bobUSDAfter, uint256 bobFracAfter) = (usd.balanceOf(bob), p.balanceOf(bob));\n\n    // ... Bob received less USD than he deposited.\n    assertEq(bobUSDAfter bobUSDBefore, 1.018181818181818181 ether);\n    assertEq(bobFracAfter bobFracBefore, 1.000000000000000000 ether);\n}\n\n\n",
                "Repair": "\nIn the add function, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router: UniswapV2Router02.sol#L45-L60(https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L45-L60).\n\noutdoteth (Caviar) confirmed and commented(https://github.com/code-423n4/2022-12-caviar-findings/issues/376#issuecomment-1373894006):\n  Fixed in: https://github.com/outdoteth/caviar/pull/2\n \n By allowing a user to specify a minPrice and maxPrice that they are willing to LP at along with the minLpTokenAmount that they would like to receive. The price calculation is based on this: https://github.com/outdoteth/caviar/blob/main/src/Pair.sol#L471\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/utils/MerkleProofLib.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./Caviar.sol\";\n\n/// @title Pair\n/// @author out.eth (@outdoteth)\n/// @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.\ncontract Pair is ERC20, ERC721TokenReceiver {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n    address public immutable nft;\n    address public immutable baseToken; // address(0) for ETH\n    bytes32 public immutable merkleRoot;\n    LpToken public immutable lpToken;\n    Caviar public immutable caviar;\n    uint256 public closeTimestamp;\n\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Buy(uint256 inputAmount, uint256 outputAmount);\n    event Sell(uint256 inputAmount, uint256 outputAmount);\n    event Wrap(uint256[] tokenIds);\n    event Unwrap(uint256[] tokenIds);\n    event Close(uint256 closeTimestamp);\n    event Withdraw(uint256 tokenId);\n\n    constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n        nft = _nft;\n        baseToken = _baseToken; // use address(0) for native ETH\n        merkleRoot = _merkleRoot;\n        lpToken = new LpToken(pairSymbol);\n        caviar = Caviar(msg.sender);\n    }\n\n    // ************************ //\n    //      Core AMM logic      //\n    // ***********************  //\n\n    /// @notice Adds liquidity to the pair.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @param minLpTokenAmount The minimum amount of LP tokens to mint.\n    /// @return lpTokenAmount The amount of LP tokens minted.\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n        public\n        payable\n        returns (uint256 lpTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check the token amount inputs are not zero\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate the lp token shares to mint\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n\n        // check that the amount of lp tokens outputted is greater than the min amount\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens in\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // mint lp tokens to sender\n        lpToken.mint(msg.sender, lpTokenAmount);\n\n        // transfer base tokens in if the base token is not ETH\n        if (baseToken != address(0)) {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair.\n    /// @param lpTokenAmount The amount of LP tokens to burn.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // *** Checks *** //\n\n        // calculate the output amounts\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);\n\n        // check that the base token output amount is greater than the min amount\n        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");\n\n        // check that the fractional token output amount is greater than the min amount\n        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);\n\n        // *** Interactions *** //\n\n        // burn lp tokens from sender\n        lpToken.burn(msg.sender, lpTokenAmount);\n\n        if (baseToken == address(0)) {\n            // if base token is native ETH then send ether to sender\n            msg.sender.safeTransferETH(baseTokenOutputAmount);\n        } else {\n            // transfer base tokens to sender\n            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);\n        }\n\n        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);\n    }\n\n    /// @notice Buys fractional tokens from the pair.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // *** Checks *** //\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate required input amount using xyk invariant\n        inputAmount = buyQuote(outputAmount);\n\n        // check that the required amount of base tokens is less than the max amount\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, outputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // refund surplus eth\n            uint256 refundAmount = maxInputAmount - inputAmount;\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n        } else {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n\n        emit Buy(inputAmount, outputAmount);\n    }\n\n    /// @notice Sells fractional tokens to the pair.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @return outputAmount The amount of base tokens received.\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n        // *** Checks *** //\n\n        // calculate output amount using xyk invariant\n        outputAmount = sellQuote(inputAmount);\n\n        // check that the outputted amount of fractional tokens is greater than the min amount\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens from sender\n        _transferFrom(msg.sender, address(this), inputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // transfer ether out\n            msg.sender.safeTransferETH(outputAmount);\n        } else {\n            // transfer base tokens out\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n        }\n\n        emit Sell(inputAmount, outputAmount);\n    }\n\n    // ******************** //\n    //      Wrap logic      //\n    // ******************** //\n\n    /// @notice Wraps NFTs into fractional tokens.\n    /// @param tokenIds The ids of the NFTs to wrap.\n    /// @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.\n    /// @return fractionalTokenAmount The amount of fractional tokens minted.\n    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n        public\n        returns (uint256 fractionalTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check that wrapping is not closed\n        require(closeTimestamp == 0, \"Wrap: closed\");\n\n        // check the tokens exist in the merkle root\n        _validateTokenIds(tokenIds, proofs);\n\n        // *** Effects *** //\n\n        // mint fractional tokens to sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _mint(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts from sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        emit Wrap(tokenIds);\n    }\n\n    /// @notice Unwraps fractional tokens into NFTs.\n    /// @param tokenIds The ids of the NFTs to unwrap.\n    /// @return fractionalTokenAmount The amount of fractional tokens burned.\n    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n        // *** Effects *** //\n\n        // burn fractional tokens from sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _burn(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts to sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        emit Unwrap(tokenIds);\n    }\n\n    // *********************** //\n    //      NFT AMM logic      //\n    // *********************** //\n\n    /// @notice nftAdd Adds liquidity to the pair using NFTs.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param tokenIds The ids of the NFTs to add.\n    /// @param minLpTokenAmount The minimum amount of lp tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return lpTokenAmount The amount of lp tokens minted.\n    function nftAdd(\n        uint256 baseTokenAmount,\n        uint256[] calldata tokenIds,\n        uint256 minLpTokenAmount,\n        bytes32[][] calldata proofs\n    ) public payable returns (uint256 lpTokenAmount) {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);\n\n        // add liquidity using the fractional tokens and base tokens\n        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair using NFTs.\n    /// @param lpTokenAmount The amount of lp tokens to remove.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param tokenIds The ids of the NFTs to remove.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // remove liquidity and send fractional tokens and base tokens to sender\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) =\n            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Buys NFTs from the pair using base tokens.\n    /// @param tokenIds The ids of the NFTs to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // buy fractional tokens using base tokens\n        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Sells NFTs to the pair for base tokens.\n    /// @param tokenIds The ids of the NFTs to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return outputAmount The amount of base tokens received.\n    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)\n        public\n        returns (uint256 outputAmount)\n    {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 inputAmount = wrap(tokenIds, proofs);\n\n        // sell fractional tokens for base tokens\n        outputAmount = sell(inputAmount, minOutputAmount);\n    }\n\n    // ****************************** //\n    //      Emergency exit logic      //\n    // ****************************** //\n\n    /// @notice Closes the pair to new wraps.\n    /// @dev Can only be called by the caviar owner. This is used as an emergency exit in case\n    ///      the caviar owner suspects that the pair has been compromised.\n    function close() public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Close: not owner\");\n\n        // set the close timestamp with a grace period\n        closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;\n\n        // remove the pair from the Caviar contract\n        caviar.destroy(nft, baseToken, merkleRoot);\n\n        emit Close(closeTimestamp);\n    }\n\n    /// @notice Withdraws a particular NFT from the pair.\n    /// @dev Can only be called by the caviar owner after the close grace period has passed. This\n    ///      is used to auction off the NFTs in the pair in case NFTs get stuck due to liquidity\n    ///      imbalances. Proceeds from the auction should be distributed pro rata to fractional\n    ///      token holders. See documentation for more details.\n    function withdraw(uint256 tokenId) public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Withdraw: not owner\");\n\n        // check that the close period has been set\n        require(closeTimestamp != 0, \"Withdraw not initiated\");\n\n        // check that the close grace period has passed\n        require(block.timestamp >= closeTimestamp, \"Not withdrawable yet\");\n\n        // transfer the nft to the caviar owner\n        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(tokenId);\n    }\n\n    // ***************** //\n    //      Getters      //\n    // ***************** //\n\n    function baseTokenReserves() public view returns (uint256) {\n        return _baseTokenReserves();\n    }\n\n    function fractionalTokenReserves() public view returns (uint256) {\n        return balanceOf[address(this)];\n    }\n\n    /// @notice The current price of one fractional token in base tokens with 18 decimals of precision.\n    /// @dev Calculated by dividing the base token reserves by the fractional token reserves.\n    /// @return price The price of one fractional token in base tokens * 1e18.\n    function price() public view returns (uint256) {\n        return (_baseTokenReserves() * ONE) / fractionalTokenReserves();\n    }\n\n    /// @notice The amount of base tokens required to buy a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @return inputAmount The amount of base tokens required.\n    function buyQuote(uint256 outputAmount) public view returns (uint256) {\n        return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n    }\n\n    /// @notice The amount of base tokens received for selling a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @return outputAmount The amount of base tokens received.\n    function sellQuote(uint256 inputAmount) public view returns (uint256) {\n        uint256 inputAmountWithFee = inputAmount * 997;\n        return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n    }\n\n    /// @notice The amount of lp tokens received for adding a given amount of base tokens and fractional tokens.\n    /// @dev Calculated as a share of existing deposits. If there are no existing deposits, then initializes to\n    ///      sqrt(baseTokenAmount * fractionalTokenAmount).\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @return lpTokenAmount The amount of lp tokens received.\n    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        if (lpTokenSupply > 0) {\n            // calculate amount of lp tokens as a fraction of existing reserves\n            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\n            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\n            return Math.min(baseTokenShare, fractionalTokenShare);\n        } else {\n            // if there is no liquidity then init\n            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n        }\n    }\n\n    /// @notice The amount of base tokens and fractional tokens received for burning a given amount of lp tokens.\n    /// @dev Calculated as a share of existing deposits.\n    /// @param lpTokenAmount The amount of lp tokens to burn.\n    /// @return baseTokenAmount The amount of base tokens received.\n    /// @return fractionalTokenAmount The amount of fractional tokens received.\n    function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;\n        uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;\n\n        return (baseTokenOutputAmount, fractionalTokenOutputAmount);\n    }\n\n    // ************************ //\n    //      Internal utils      //\n    // ************************ //\n\n    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /// @dev Validates that the given tokenIds are valid for the contract's merkle root. Reverts\n    ///      if any of the tokenId proofs are invalid.\n    function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {\n        // if merkle root is not set then all tokens are valid\n        if (merkleRoot == bytes23(0)) return;\n\n        // validate merkle proofs against merkle root\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));\n            require(isValid, \"Invalid merkle proof\");\n        }\n    }\n\n    /// @dev Returns the current base token reserves. If the base token is ETH then it ignores\n    ///      the msg.value that is being sent in the current call context - this is to ensure the\n    ///      xyk math is correct in the buy() and add() functions.\n    function _baseTokenReserves() internal view returns (uint256) {\n        return baseToken == address(0)\n            ? address(this).balance - msg.value // subtract the msg.value if the base token is ETH\n            : ERC20(baseToken).balanceOf(address(this));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport \"solmate/utils/LibString.sol\";\n\nimport \"../src/Caviar.sol\";\nimport \"../src/Pair.sol\";\n\ncontract CreatePairScript is Script {\n    using stdJson for string;\n\n    function setUp() public {}\n\n    function run() public {\n        vm.broadcast();\n\n        address caviar = vm.envAddress(\"CAVIAR_ADDRESS\");\n        address nft = vm.envAddress(\"NFT_ADDRESS\");\n\n        create(nft, address(0), \"invisible-friends-mids.json\", caviar);\n    }\n\n    function create(address nft, address baseToken, string memory rankingFile, address caviar) public returns (Pair) {\n        // generate the merkle root\n        bytes32 merkleRoot = generateMerkleRoot(rankingFile);\n\n        // create the pair\n        Pair pair = Caviar(caviar).create(nft, baseToken, merkleRoot);\n        console.log(\"pair:\", address(pair));\n        console.log(\"merkle root:\");\n        console.logBytes32(merkleRoot);\n\n        return pair;\n    }\n\n    function generateMerkleRoot(string memory rankingFile) public returns (bytes32) {\n        string[] memory inputs = new string[](3);\n\n        inputs[0] = \"node\";\n        inputs[1] = \"./script/helpers/generate-merkle-root.js\";\n        inputs[2] = rankingFile;\n\n        bytes memory res = vm.ffi(inputs);\n        bytes32 output = abi.decode(res, (bytes32));\n\n        return output;\n    }\n\n    function generateMerkleProofs(string memory rankingFile, uint256[] memory tokenIds)\n        public\n        returns (bytes32[][] memory)\n    {\n        bytes32[][] memory proofs = new bytes32[][](tokenIds.length);\n\n        string[] memory inputs = new string[](4);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            inputs[0] = \"node\";\n            inputs[1] = \"./script/helpers/generate-merkle-proof.js\";\n            inputs[2] = rankingFile;\n            inputs[3] = LibString.toString(tokenIds[i]);\n\n            bytes memory res = vm.ffi(inputs);\n            bytes32[] memory output = abi.decode(res, (bytes32[]));\n            proofs[i] = output;\n        }\n\n        return proofs;\n    }\n}\n\n\n",
        "CodeNames": [
            "Pair.sol",
            "CreatePair.s.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n    uint256 lpTokenSupply = lpToken.totalSupply();\n    if (lpTokenSupply  0) {\n        // calculate amount of lp tokens as a fraction of existing reserves\n        uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\n        uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\n        return Math.min(baseTokenShare, fractionalTokenShare);\n    } else {\n        // if there is no liquidity then init\n        return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n    }\n}\n",
                    "//solidity\nbaseTokenShare = (X * 1) / 1e9;\nfractionalTokenShare = (Y * 1) / 1e9;\n"
                ],
                "Type": " First depositor can break minting of shares",
                "Description": "*Submitted by minhquanym(https://github.com/code-423n4/2022-12-caviar-findings/issues/442), also found by Apocalypto(https://github.com/code-423n4/2022-12-caviar-findings/issues/500), 0xDecorativePineapple(https://github.com/code-423n4/2022-12-caviar-findings/issues/495), Franfran(https://github.com/code-423n4/2022-12-caviar-findings/issues/485), dipp(https://github.com/code-423n4/2022-12-caviar-findings/issues/476), rjs(https://github.com/code-423n4/2022-12-caviar-findings/issues/471), ak1(https://github.com/code-423n4/2022-12-caviar-findings/issues/470), Tricko(https://github.com/code-423n4/2022-12-caviar-findings/issues/469), Jeiwan(https://github.com/code-423n4/2022-12-caviar-findings/issues/382), unforgiven(https://github.com/code-423n4/2022-12-caviar-findings/issues/358), hansfriese(https://github.com/code-423n4/2022-12-caviar-findings/issues/352), BAHOZ(https://github.com/code-423n4/2022-12-caviar-findings/issues/341), unforgiven(https://github.com/code-423n4/2022-12-caviar-findings/issues/338), bytehat(https://github.com/code-423n4/2022-12-caviar-findings/issues/317), UNCHAIN(https://github.com/code-423n4/2022-12-caviar-findings/issues/310), immeas(https://github.com/code-423n4/2022-12-caviar-findings/issues/249), SamGMK(https://github.com/code-423n4/2022-12-caviar-findings/issues/247), fs0c(https://github.com/code-423n4/2022-12-caviar-findings/issues/242), Tointer(https://github.com/code-423n4/2022-12-caviar-findings/issues/240), haku(https://github.com/code-423n4/2022-12-caviar-findings/issues/239), Koolex(https://github.com/code-423n4/2022-12-caviar-findings/issues/235), __141345__(https://github.com/code-423n4/2022-12-caviar-findings/issues/232), ElKu(https://github.com/code-423n4/2022-12-caviar-findings/issues/231), rajatbeladiya(https://github.com/code-423n4/2022-12-caviar-findings/issues/216), hihen(https://github.com/code-423n4/2022-12-caviar-findings/issues/207), izhelyazkov(https://github.com/code-423n4/2022-12-caviar-findings/issues/196), KingNFT(https://github.com/code-423n4/2022-12-caviar-findings/issues/174), koxuan(https://github.com/code-423n4/2022-12-caviar-findings/issues/151), 0x52(https://github.com/code-423n4/2022-12-caviar-findings/issues/149), carrotsmuggler(https://github.com/code-423n4/2022-12-caviar-findings/issues/130), yixxas(https://github.com/code-423n4/2022-12-caviar-findings/issues/128), HE1M(https://github.com/code-423n4/2022-12-caviar-findings/issues/123), supernova(https://github.com/code-423n4/2022-12-caviar-findings/issues/121), cozzetti(https://github.com/code-423n4/2022-12-caviar-findings/issues/119), rvierdiiev(https://github.com/code-423n4/2022-12-caviar-findings/issues/113), SamGMK(https://github.com/code-423n4/2022-12-caviar-findings/issues/99), aviggiano(https://github.com/code-423n4/2022-12-caviar-findings/issues/88), seyni(https://github.com/code-423n4/2022-12-caviar-findings/issues/87), lumoswiz(https://github.com/code-423n4/2022-12-caviar-findings/issues/77), ladboy233(https://github.com/code-423n4/2022-12-caviar-findings/issues/58), chaduke(https://github.com/code-423n4/2022-12-caviar-findings/issues/56), cccz(https://github.com/code-423n4/2022-12-caviar-findings/issues/33), and eyexploit(https://github.com/code-423n4/2022-12-caviar-findings/issues/19)*\n\nThe attack vector and impact is the same as TOB-YEARN-003(https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.\n\n\nIn Pair.add(), the amount of LP token minted is calculated as\n\nsolidity\nfunction addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n    uint256 lpTokenSupply = lpToken.totalSupply();\n    if (lpTokenSupply  0) {\n        // calculate amount of lp tokens as a fraction of existing reserves\n        uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\n        uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\n        return Math.min(baseTokenShare, fractionalTokenShare);\n    } else {\n        // if there is no liquidity then init\n        return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n    }\n}\n\n\nAn attacker can exploit using these steps\n\n1.  Create and add 1 wei baseToken 1 wei quoteToken to the pair. At this moment, attacker is minted 1 wei LP token because sqrt(1 * 1) = 1\n2.  Transfer large amount of baseToken and quoteToken directly to the pair, such as 1e9 baseToken 1e9 quoteToken. Since no new LP token is minted, 1 wei LP token worths 1e9 baseToken 1e9 quoteToken.\n3.  Normal users add liquidity to pool will receive 0 LP token if they add less than 1e9 token because of rounding division.\n\nsolidity\nbaseTokenShare = (X * 1) / 1e9;\nfractionalTokenShare = (Y * 1) / 1e9;\n\n\n",
                "Repair": "\n*   Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address(https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when lpTokenSupply == 0, send the first min liquidity LP tokens to the zero address to enable share dilution.\n*   In add(), ensure the number of LP tokens to be minted is non-zero:\n\nsolidity\nrequire(lpTokenAmount != 0, \"No LP minted\");\n\n\noutdoteth (Caviar) confirmed and commented(https://github.com/code-423n4/2022-12-caviar-findings/issues/442#issuecomment-1373902458):\n  Fixed in: https://github.com/outdoteth/caviar/pull/3\n\n\n\n*\n \n\n"
            }
        ]
    }
]