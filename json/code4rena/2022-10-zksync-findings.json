[
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMailbox.sol\";\nimport \"../libraries/Merkle.sol\";\nimport \"../libraries/PriorityQueue.sol\";\nimport \"../Storage.sol\";\nimport \"../Config.sol\";\nimport \"../../common/libraries/UncheckedMath.sol\";\nimport \"../../common/L2ContractHelper.sol\";\nimport \"./Base.sol\";\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 block number\n    /// @param _blockNumber The executed L2 block number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 block where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 block\n    /// @param _blockNumber The executed L2 block number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    function proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _log, _proof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 block number\n    function _proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_blockNumber <= s.totalBlocksExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBlock, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n        // Check that the proof length is exactly the same as tree height, to prevent\n        // any shorter/longer paths attack on the Merkle path validation\n        require(_proof.length == L2_TO_L1_LOG_MERKLE_TREE_HEIGHT, \"rz\");\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_blockNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message calldata _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBlock: _message.txNumberInBlock,\n                sender: L2_TO_L1_MESSENGER,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @return The estimated ergs\n    function l2TransactionBaseCost(\n        uint256, // _gasPrice\n        uint256, // _ergsLimit\n        uint32 // _calldataLength\n    ) public pure returns (uint256) {\n        // TODO: estimate gas for L1 execute\n        return 0;\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2Transaction(msg.sender, _contractL2, _l2Value, _calldata, _ergsLimit, _factoryDeps);\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_ergsLimit <= PRIORITY_TX_MAX_ERGS_LIMIT, \"ui\");\n        uint64 expirationBlock = uint64(block.number + PRIORITY_EXPIRATION);\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n        // TODO: Restore after stable priority op fee modeling. (SMA-1230)\n        // uint256 baseCost = l2TransactionBaseCost(tx.gasprice, _ergsLimit, uint32(_calldata.length));\n        // uint256 layer2Tip = msg.value - baseCost;\n\n        canonicalTxHash = _writePriorityOp(\n            _sender,\n            txId,\n            _l2Value,\n            _contractL2,\n            _calldata,\n            expirationBlock,\n            _ergsLimit,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        address _sender,\n        uint256 _txId,\n        uint256 _l2Value,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint64 _expirationBlock,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = serializeL2Transaction(\n            _txId,\n            _l2Value,\n            _sender,\n            _contractAddressL2,\n            _calldata,\n            _ergsLimit,\n            _factoryDeps\n        );\n        canonicalTxHash = keccak256(abi.encode(transaction));\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationBlock: _expirationBlock,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that needed for operator to simulate priority queue offchain\n        emit NewPriorityRequest(_txId, canonicalTxHash, _expirationBlock, transaction, _factoryDeps);\n    }\n\n    /// @dev Accepts the parameters of the l2 transaction and converts it to the canonical form.\n    /// @param _txId Priority operation ID, used as a unique identifier so that transactions always have a different hash\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _sender The L2 address of the account that initiates the transaction\n    /// @param _contractAddressL2 The L2 receiver address\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return The canonical form of the l2 transaction parameters\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n                reserved: [uint256(_txId), _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] calldata _factoryDeps)\n        internal\n        pure\n        returns (uint256[] memory hashedFactoryDeps)\n    {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/Diamond.sol\";\nimport \"../Config.sol\";\nimport \"./Base.sol\";\n\n/// @title DiamondCut contract responsible for the management of upgrades.\n/// @author Matter Labs\ncontract DiamondCutFacet is Base, IDiamondCut {\n    constructor() {\n        // Caution check for config value.\n        // Should be greater than 0, otherwise zero approvals will be enough to make an instant upgrade!\n        assert(SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE > 0);\n    }\n\n    /// @dev Starts the upgrade process. Only the current governor can propose an upgrade.\n    /// @param _facetCuts The set of proposed changes to the facets (adding/replacement/removing)\n    /// @param _initAddress Address of the fallback contract that will be called after the upgrade execution\n    function proposeDiamondCut(Diamond.FacetCut[] calldata _facetCuts, address _initAddress) external onlyGovernor {\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp == 0, \"a3\"); // proposal already exists\n\n        // NOTE: governor commits only to the `facetCuts` and `initAddress`, but not to the calldata on `initAddress` call.\n        // That means the governor can call `initAddress` with ANY calldata while executing the upgrade.\n        s.diamondCutStorage.proposedDiamondCutHash = keccak256(abi.encode(_facetCuts, _initAddress));\n        s.diamondCutStorage.proposedDiamondCutTimestamp = block.timestamp;\n        s.diamondCutStorage.currentProposalId += 1;\n\n        emit DiamondCutProposal(_facetCuts, _initAddress);\n    }\n\n    /// @notice Removes the upgrade proposal. Only current governor can remove proposal.\n    function cancelDiamondCutProposal() external onlyGovernor {\n        emit DiamondCutProposalCancelation(\n            s.diamondCutStorage.currentProposalId,\n            s.diamondCutStorage.proposedDiamondCutHash\n        );\n        require(_resetProposal(), \"g1\"); // failed cancel diamond cut\n    }\n\n    /// @notice Executes a proposed governor upgrade. Only the current governor can execute the upgrade.\n    /// NOTE: Governor can execute diamond cut ONLY with proposed `facetCuts` and `initAddress`.\n    /// `initCalldata` can be arbitrarily.\n    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        bool approvedBySecurityCouncil = s.diamondCutStorage.securityCouncilEmergencyApprovals >=\n            SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE;\n\n        bool upgradeNoticePeriodPassed = block.timestamp >=\n            s.diamondCutStorage.proposedDiamondCutTimestamp + UPGRADE_NOTICE_PERIOD;\n\n        require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n        require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n        // should not be frozen or should have enough security council approvals\n\n        require(\n            s.diamondCutStorage.proposedDiamondCutHash ==\n                keccak256(abi.encode(_diamondCut.facetCuts, _diamondCut.initAddress)),\n            \"a4\"\n        ); // proposal should be created\n\n        require(_resetProposal(), \"a5\"); // failed reset proposal\n\n        if (diamondStorage.isFrozen) {\n            diamondStorage.isFrozen = false;\n            emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n        }\n\n        Diamond.diamondCut(_diamondCut);\n\n        emit DiamondCutProposalExecution(_diamondCut);\n    }\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    function emergencyFreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        _resetProposal();\n\n        diamondStorage.isFrozen = true;\n        // Limited-time freezing feature will be added in the future upgrades, so keeping this variable for simplification\n        s.diamondCutStorage.lastDiamondFreezeTimestamp = block.timestamp;\n\n        emit EmergencyFreeze();\n    }\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    function unfreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n\n        _resetProposal();\n\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n    }\n\n    /// @notice Gives another approval for the instant upgrade (diamond cut) by the security council member\n    /// @param _diamondCutHash The hash of the diamond cut that security council members want to approve. Needed to prevent unintentional approvals, including reorg attacks\n    function approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32 _diamondCutHash) external {\n        require(s.diamondCutStorage.securityCouncilMembers[msg.sender], \"a9\"); // not a security council member\n        uint256 currentProposalId = s.diamondCutStorage.currentProposalId;\n        require(s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] < currentProposalId, \"ao\"); // already approved this proposal\n        s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] = currentProposalId;\n\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp != 0, \"f0\"); // there is no proposed diamond cut\n        require(s.diamondCutStorage.proposedDiamondCutHash == _diamondCutHash, \"f1\"); // proposed diamond cut do not match to the approved\n        uint256 securityCouncilEmergencyApprovals = s.diamondCutStorage.securityCouncilEmergencyApprovals;\n        s.diamondCutStorage.securityCouncilEmergencyApprovals = securityCouncilEmergencyApprovals + 1;\n\n        emit EmergencyDiamondCutApproved(\n            msg.sender,\n            currentProposalId,\n            securityCouncilEmergencyApprovals,\n            _diamondCutHash\n        );\n    }\n\n    /// @dev Set up the proposed diamond cut state to the default values\n    /// @return Whether the proposal is reset or it was already empty\n    function _resetProposal() private returns (bool) {\n        if (s.diamondCutStorage.proposedDiamondCutTimestamp == 0) {\n            return false;\n        }\n\n        delete s.diamondCutStorage.proposedDiamondCutHash;\n        delete s.diamondCutStorage.proposedDiamondCutTimestamp;\n        delete s.diamondCutStorage.securityCouncilEmergencyApprovals;\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"../../zksync/libraries/Diamond.sol\";\nimport \"../../zksync/facets/Getters.sol\";\n\ncontract DiamondCutTest is GettersFacet {\n    function diamondCut(Diamond.DiamondCutData memory _diamondCut) external {\n        Diamond.diamondCut(_diamondCut);\n    }\n}\n\n\n",
        "CodeNames": [
            "Mailbox.sol",
            "DiamondCut.sol",
            "DiamondCutTest.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "_calldata",
                    "upgradeNoticePeriod",
                    "diamondCut"
                ],
                "Type": "  diamondCut  is not protected in case of governor's key leakage",
                "Description": "*Submitted by HE1M(https://github.com/code-423n4/2022-10-zksync-findings/issues/46), also found by codehacker(https://github.com/code-423n4/2022-10-zksync-findings/issues/315)*\n\nWhen the governor proposes a diamondCut, governor must wait for upgradeNoticePeriod to be passed, or security council members have to approve the proposal to bypass the notice period, so that the governor can execute the proposal.\n\n       require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n       require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n\nIf the governor's key is leaked and noticed by zkSync, the attacker must wait for the notice period to execute the already proposed diamondCut with the malicious _calldata based on the note below from zkSync, or to propose a new malicious diamondCut. For, both cases, the attacker loses time.\n\n NOTE: proposeDiamondCut commits data associated with an upgrade but does not execute it. While the upgrade is associated with facetCuts and (address _initAddress, bytes _calldata) the upgrade will be committed to the facetCuts and _initAddress. This is done on purpose, to leave some freedom to the governor to change calldata for the upgrade between proposing and executing it.\n\nSince, there is a notice period (as zkSync noticed the key leakage, security council member will not approve the proposal, so bypassing the notice period is not possible), there is enough time for zkSync to apply security measures (pausing any deposit/withdraw, reporting in media to not execute any transaction in zkSync, and so on).\n\nBut, the attacker can be smarter, just before the proposal be executed by the governor (i.e. the notice period is passed or security council members approved it), the attacker executes the proposal earlier than governor with the malicious _calldata. In other words, the attacker front runs the governor.\n\nTherefore, if zkSync notices the governor's key leakage beforehand, there is enough time to protect the project. But, if zkSync does not notice the governor's key leakage, the attacker can change the _calldata into a malicious one in the last moment so that it is not possible to protect the project.\n\n\nDiamond.sol#L277(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Diamond.sol#L277)<br\nDiamondCut.sol#L46(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L46)\n\n",
                "Repair": "\n_calldata should be included in the proposed diamondCut:[DiamondCut.sol#L27(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L27).\n\nOr, at least one of the security council members should approve the _calldata during execution of the proposal.\n\nmiladpiri (zkSync) confirmed and commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/46#issuecomment-1324267775):\n  It is a valid issue, and the fix is going to be implemented, so we confirm the issue as medium! Thanks.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/46#issuecomment-1335849634):\n  In contrast to other reports, this shows how a malicious proposal could be injected, bypassing the timelock protection, for this reason (after consulting with a second Judge), I agree with marking it as a distinct finding and agree with Medium Severity.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n/// @dev Bytes in raw L2 log\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBlock, address sender, bytes32 key, bytes32 value)\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\n\n/// @dev Length of the bytes array with L2->L1 logs\nuint256 constant L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\n\n/// @dev L2 -> L1 logs Merkle tree height\nuint256 constant L2_TO_L1_LOG_MERKLE_TREE_HEIGHT = 9;\n\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\n/// @dev Actually equal to the `keccak256(new bytes(L2_LOG_BYTES))`\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\n\n/// @dev Length of the bytes array with initial storage changes\nuint256 constant INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + 64 * 4896;\n\n/// @dev Length of the bytes array with repeated storage changes\nuint256 constant REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + 40 * 7787;\n\n// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\n\n/// @dev The address of the special smart contract that can send arbitrary length message as an L2 log\naddress constant L2_TO_L1_MESSENGER = address(0x8008);\n\n/// @dev The address of the bootloader start program\naddress constant L2_BOOTLOADER_ADDRESS = address(0x8001);\n\n/// @dev The address of the known code storage system contract\naddress constant L2_KNOWN_CODE_STORAGE_ADDRESS = address(0x8004);\n\n/// @dev The address of the context system contract\naddress constant L2_SYSTEM_CONTEXT_ADDRESS = address(0x800b);\n\n/// @dev Denotes the first byte of the zkSync transaction that came from L1.\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\n\n/// @dev Expected average period of block creation\nuint256 constant BLOCK_PERIOD = 13 seconds;\n\n/// @dev Expiration delta for priority request to be satisfied (in seconds)\n/// @dev otherwise incorrect block with priority op could not be reverted.\nuint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\n\n/// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\nuint256 constant PRIORITY_EXPIRATION = $(\n    defined(PRIORITY_EXPIRATION) ? PRIORITY_EXPIRATION : PRIORITY_EXPIRATION_PERIOD / BLOCK_PERIOD\n);\n\n/// @dev Notice period before activation preparation status of upgrade mode (in seconds)\n/// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\nuint256 constant UPGRADE_NOTICE_PERIOD = $$(defined(UPGRADE_NOTICE_PERIOD) ? UPGRADE_NOTICE_PERIOD : \"14 days\");\n\n/// @dev Timestamp - seconds since unix epoch\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = $$(\n    defined(COMMIT_TIMESTAMP_NOT_OLDER) ? COMMIT_TIMESTAMP_NOT_OLDER : \"365 days\"\n);\n\n/// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = $$(\n    defined(COMMIT_TIMESTAMP_APPROXIMATION_DELTA) ? COMMIT_TIMESTAMP_APPROXIMATION_DELTA : \"365 days\"\n);\n\n/// @dev Bit mask to apply for verifier public input before verifying.\nuint256 constant INPUT_MASK = $$(~uint256(0) >> 8);\n\n/// @dev The maximum number of ergs that a user can request for L1 -> L2 transactions\nuint256 constant PRIORITY_TX_MAX_ERGS_LIMIT = 2097152;\n\n/// @dev Number of security council members that should approve an emergency upgrade\nuint256 constant SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE = $$(\n    SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE\n);\n\n\n",
        "CodeNames": [
            "Config.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "sol\nuint256 constant BLOCK_PERIOD = 13 seconds;\n",
                    "sol\nuint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\n/// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\nuint256 constant PRIORITY_EXPIRATION = PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\n",
                    "python\n 3*24*60*60 / 13    # 3 days / 13 sec block period\n19938.46153846154\n 3*24*60*60 / 12    # 3 days / 12 sec block period\n21600.0\n 21600 19938      # difference in blocks\n1662\n 1662 * 12 / (60 * 60) # difference in hours\n5.54\n"
                ],
                "Type": "  BLOCK_PERIOD  is incorrect",
                "Description": "*Submitted by Soosh(https://github.com/code-423n4/2022-10-zksync-findings/issues/259)*\n\nConfig.sol#L47(https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/zksync/Config.sol#L47)<br\n\nThe BLOCK_PERIOD is set to 13 seconds in Config.sol.\n\nsol\nuint256 constant BLOCK_PERIOD = 13 seconds;\n\n\nSince moving to Proof-of-Stake (PoS) after the Merge, block times on ethereum are fixed at 12 seconds per block (slots).\n<https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#:~:text=Whereas%20under%20proof%2Dof%2Dwork,block%20proposer%20in%20every%20slot.\n\n\nThis results in incorrect calculation of PRIORITY_EXPIRATION which is used to determine when a transaction in the Priority Queue should be considered expired.\n\nsol\nuint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\n/// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\nuint256 constant PRIORITY_EXPIRATION = PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\n\n\nThe time difference can be calulated\n\npython\n 3*24*60*60 / 13    # 3 days / 13 sec block period\n19938.46153846154\n 3*24*60*60 / 12    # 3 days / 12 sec block period\n21600.0\n 21600 19938      # difference in blocks\n1662\n 1662 * 12 / (60 * 60) # difference in hours\n5.54\n\n\nBy using block time of 13 seconds, a transaction in the Priority Queue incorrectly expires 5.5 hours earlier than is expected.\n\n5.5 hours is a significant amount of time difference so I believe this issue to be Medium severity.\n\n",
                "Repair": "\nChange the block period to be 12 seconds\n\nsol\nuint256 constant BLOCK_PERIOD = 12 seconds;\n\n\nmiladpiri (zkSync) confirmed and commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/259#issuecomment-1324171828):\n  This is a valid medium issue! Thanks!\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/259#issuecomment-1329983294):\n  The warden has shown how, due to an incorrect configuration, L2Transactions will expire earlier than intended.\n \n The value would normally be rated a Low Severity, however, because the Warden has shown a more specific impact, I agree with Medium Severity.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 13 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-10-zksync-findings/issues/49) by HE1M received the top score from the judge.\n\n*The following wardens also submitted reports: brgltd(https://github.com/code-423n4/2022-10-zksync-findings/issues/361), rbserver(https://github.com/code-423n4/2022-10-zksync-findings/issues/348), pashov(https://github.com/code-423n4/2022-10-zksync-findings/issues/346), ladboy233(https://github.com/code-423n4/2022-10-zksync-findings/issues/239), 0xSmartContract(https://github.com/code-423n4/2022-10-zksync-findings/issues/227), datapunk(https://github.com/code-423n4/2022-10-zksync-findings/issues/212), cccz(https://github.com/code-423n4/2022-10-zksync-findings/issues/186), ctf_sec(https://github.com/code-423n4/2022-10-zksync-findings/issues/172), Tomo(https://github.com/code-423n4/2022-10-zksync-findings/issues/158), Rolezn(https://github.com/code-423n4/2022-10-zksync-findings/issues/110), jayjonah8(https://github.com/code-423n4/2022-10-zksync-findings/issues/77), and chaduke(https://github.com/code-423n4/2022-10-zksync-findings/issues/13).*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"../../zksync/facets/Governance.sol\";\n\ncontract GovernanceFacetTest is GovernanceFacet {\n    constructor() {\n        s.governor = msg.sender;\n    }\n\n    function isValidator(address _validator) external view returns (bool) {\n        return s.validators[_validator];\n    }\n\n    function getPendingGovernor() external view returns (address) {\n        return s.pendingGovernor;\n    }\n\n    function getGovernor() external view returns (address) {\n        return s.governor;\n    }\n}\n\n\n",
        "CodeNames": [
            "GovernanceFacetTest.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "1",
                "Location": [
                    "GovernanceFacet"
                ],
                "Type": "",
                "Description": "\nThe critical parameters in initialize(...) are not set safely:\n\n*   s.governor should be set to msg.sender, because a wrong governor address will result in loss of access to all other parts, and later changing the governor to the correct address.\n*   _l2BootloaderBytecodeHash should be validated like L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash) as in GovernanceFacet\n*   _l2DefaultAccountBytecodeHash should be validated like L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash) as in GovernanceFacet\n\nDiamondInit.sol#L39(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L39)<br\nDiamondInit.sol#L58(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L58)<br\nDiamondInit.sol#L59(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L59)<br\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "2",
                "Location": [],
                "Type": "",
                "Description": "\nBetter to have also approveEmergencyDiamondCutAsSecurityCouncilMemberBySignature, in case the security council members do not have access to ethereum blockchain or in case it is needed to approve just in one transaction by batch of signatures (to bypass the notice period).\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "javascript\npragma //solidity 0.8.15;\n\ncontract TesterA {\nuint private _a;\nfunction testShort() public {\n_a += 1;\n}\n}\n\ncontract TesterB {\nuint private _a;\nfunction testLong() public {\n_a = _a + 1;\n}\n}\n"
                ],
                "Type": " Avoid compound assignment operator in state variables",
                "Description": "\nUsing compound assignment operators for state variables (like State += X or State -= X ...) it's more expensive than using operator assignment (like State = State + X or State = State X ...).\n\nProof of concept (*without optimizations*):\n\njavascript\npragma solidity 0.8.15;\n\ncontract TesterA {\nuint private _a;\nfunction testShort() public {\n_a += 1;\n}\n}\n\ncontract TesterB {\nuint private _a;\nfunction testLong() public {\n_a = _a + 1;\n}\n}\n\n\nGas saving executing: 13 per entry\n\n    TesterA.testShort: 43507\n    TesterB.testLong:  43494\n\nAffected source code:\n\n*   DiamondCut.sol:29(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L29)\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "javascript\npragma //solidity 0.8.16;\n\ncontract TesterA {\nfunction testDiv(uint a) public returns (uint) { return a / 2; }\n}\n\ncontract TesterB {\nfunction testShift(uint a) public returns (uint) { return a  1; }\n}\n",
                    "javascript\npragma //solidity 0.8.16;\n\ncontract TesterA {\nfunction testMul(uint a) public returns (uint) { return a * 2; }\n}\n\ncontract TesterB {\nfunction testShift(uint a) public returns (uint) { return a << 1; }\n}\n"
                ],
                "Type": " Shift right or left instead of dividing or multiply by 2",
                "Description": "\nShifting one to the right will calculate a division by two.\n\nhe SHR opcode only requires 3 gas, compared to the DIV opcode's consumption of 5. Additionally, shifting is used to get around Solidity's division operation's division-by-0 prohibition.\n\nProof of concept (*without optimizations*):\n\njavascript\npragma solidity 0.8.16;\n\ncontract TesterA {\nfunction testDiv(uint a) public returns (uint) { return a / 2; }\n}\n\ncontract TesterB {\nfunction testShift(uint a) public returns (uint) { return a  1; }\n}\n\n\nGas saving executing: 172 per entry\n\n    TesterA.testDiv:    21965 \n    TesterB.testShift:  21793   \n\nThe same optimization can be used to multiply by 2, using the left shift.\n\njavascript\npragma solidity 0.8.16;\n\ncontract TesterA {\nfunction testMul(uint a) public returns (uint) { return a * 2; }\n}\n\ncontract TesterB {\nfunction testShift(uint a) public returns (uint) { return a << 1; }\n}\n\n\nGas saving executing: 201 per entry\n\n    TesterA.testMul:    21994\n    TesterB.testShift:  21793    \n\nAffected source code:\n\n/:\n\n*   Merkle.sol:34(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Merkle.sol#L34)\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMailbox.sol\";\nimport \"../libraries/Merkle.sol\";\nimport \"../libraries/PriorityQueue.sol\";\nimport \"../Storage.sol\";\nimport \"../Config.sol\";\nimport \"../../common/libraries/UncheckedMath.sol\";\nimport \"../../common/L2ContractHelper.sol\";\nimport \"./Base.sol\";\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 block number\n    /// @param _blockNumber The executed L2 block number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 block where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 block\n    /// @param _blockNumber The executed L2 block number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    function proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _log, _proof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 block number\n    function _proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_blockNumber <= s.totalBlocksExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBlock, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n        // Check that the proof length is exactly the same as tree height, to prevent\n        // any shorter/longer paths attack on the Merkle path validation\n        require(_proof.length == L2_TO_L1_LOG_MERKLE_TREE_HEIGHT, \"rz\");\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_blockNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message calldata _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBlock: _message.txNumberInBlock,\n                sender: L2_TO_L1_MESSENGER,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @return The estimated ergs\n    function l2TransactionBaseCost(\n        uint256, // _gasPrice\n        uint256, // _ergsLimit\n        uint32 // _calldataLength\n    ) public pure returns (uint256) {\n        // TODO: estimate gas for L1 execute\n        return 0;\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2Transaction(msg.sender, _contractL2, _l2Value, _calldata, _ergsLimit, _factoryDeps);\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_ergsLimit <= PRIORITY_TX_MAX_ERGS_LIMIT, \"ui\");\n        uint64 expirationBlock = uint64(block.number + PRIORITY_EXPIRATION);\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n        // TODO: Restore after stable priority op fee modeling. (SMA-1230)\n        // uint256 baseCost = l2TransactionBaseCost(tx.gasprice, _ergsLimit, uint32(_calldata.length));\n        // uint256 layer2Tip = msg.value - baseCost;\n\n        canonicalTxHash = _writePriorityOp(\n            _sender,\n            txId,\n            _l2Value,\n            _contractL2,\n            _calldata,\n            expirationBlock,\n            _ergsLimit,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        address _sender,\n        uint256 _txId,\n        uint256 _l2Value,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint64 _expirationBlock,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = serializeL2Transaction(\n            _txId,\n            _l2Value,\n            _sender,\n            _contractAddressL2,\n            _calldata,\n            _ergsLimit,\n            _factoryDeps\n        );\n        canonicalTxHash = keccak256(abi.encode(transaction));\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationBlock: _expirationBlock,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that needed for operator to simulate priority queue offchain\n        emit NewPriorityRequest(_txId, canonicalTxHash, _expirationBlock, transaction, _factoryDeps);\n    }\n\n    /// @dev Accepts the parameters of the l2 transaction and converts it to the canonical form.\n    /// @param _txId Priority operation ID, used as a unique identifier so that transactions always have a different hash\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _sender The L2 address of the account that initiates the transaction\n    /// @param _contractAddressL2 The L2 receiver address\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return The canonical form of the l2 transaction parameters\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n                reserved: [uint256(_txId), _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] calldata _factoryDeps)\n        internal\n        pure\n        returns (uint256[] memory hashedFactoryDeps)\n    {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./Base.sol\";\nimport \"../Config.sol\";\nimport \"../interfaces/IExecutor.sol\";\nimport \"../libraries/PairingsBn254.sol\";\nimport \"../libraries/PriorityQueue.sol\";\nimport \"../../common/libraries/UncheckedMath.sol\";\nimport \"../../common/libraries/UnsafeBytes.sol\";\nimport \"../../common/L2ContractHelper.sol\";\n\n/// @title zkSync Executor contract capable of processing events emitted in the zkSync protocol.\n/// @author Matter Labs\ncontract ExecutorFacet is Base, IExecutor {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @dev Process one block commit using the previous block StoredBlockInfo\n    /// @dev returns new block StoredBlockInfo\n    /// @notice Does not change storage\n    function _commitOneBlock(StoredBlockInfo memory _previousBlock, CommitBlockInfo calldata _newBlock)\n        internal\n        view\n        returns (StoredBlockInfo memory storedNewBlock)\n    {\n        require(_newBlock.blockNumber == _previousBlock.blockNumber + 1, \"f\"); // only commit next block\n\n        // Check that block contain all meta information for L2 logs.\n        // Get the chained hash of priority transaction hashes.\n        (\n            uint256 expectedNumberOfLayer1Txs,\n            bytes32 expectedPriorityOperationsHash,\n            bytes32 previousBlockHash,\n            uint256 l2BlockTimestamp\n        ) = _processL2Logs(_newBlock);\n\n        require(_previousBlock.blockHash == previousBlockHash, \"l\");\n        // Check that the priority operation hash in the L2 logs is as expected\n        require(expectedPriorityOperationsHash == _newBlock.priorityOperationsHash, \"t\");\n        // Check that the number of processed priority operations is as expected\n        require(expectedNumberOfLayer1Txs == _newBlock.numberOfLayer1Txs);\n        // Check that the timestamp that came from the Bootloader is expected\n        require(l2BlockTimestamp == _newBlock.timestamp);\n\n        // Preventing \"stack too deep error\"\n        {\n            // Check the timestamp of the new block\n            bool timestampNotTooSmall = block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER <= l2BlockTimestamp;\n            bool timestampNotTooBig = l2BlockTimestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA;\n            require(timestampNotTooSmall, \"h\"); // New block timestamp is too small\n            require(timestampNotTooBig, \"h1\"); // New block timestamp is too big\n\n            // Check the index of repeated storage writes\n            uint256 newStorageChangesIndexes = uint256(uint32(bytes4(_newBlock.initialStorageChanges[:4])));\n            require(\n                _previousBlock.indexRepeatedStorageChanges + newStorageChangesIndexes ==\n                    _newBlock.indexRepeatedStorageChanges,\n                \"yq\"\n            );\n        }\n\n        // Create block commitment for the proof verification\n        bytes32 commitment = _createBlockCommitment(_newBlock);\n\n        return\n            StoredBlockInfo(\n                _newBlock.blockNumber,\n                _newBlock.newStateRoot,\n                _newBlock.indexRepeatedStorageChanges,\n                _newBlock.numberOfLayer1Txs,\n                _newBlock.priorityOperationsHash,\n                _newBlock.l2LogsTreeRoot,\n                _newBlock.timestamp,\n                commitment\n            );\n    }\n\n    function _calculateBlockHash(StoredBlockInfo memory _previousBlock, CommitBlockInfo calldata _newBlock)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(_previousBlock.blockHash, _newBlock.newStateRoot));\n    }\n\n    /// @dev Check that L2 logs are proper and block contain all meta information for them\n    function _processL2Logs(CommitBlockInfo calldata _newBlock)\n        internal\n        pure\n        returns (\n            uint256 numberOfLayer1Txs,\n            bytes32 chainedPriorityTxsHash,\n            bytes32 previousBlockHash,\n            uint256 blockTimestamp\n        )\n    {\n        // Copy L2 to L1 logs into memory.\n        bytes memory emittedL2Logs = _newBlock.l2Logs[4:];\n        bytes[] calldata l2Messages = _newBlock.l2ArbitraryLengthMessages;\n        uint256 currentMessage;\n        // Auxiliary variable that is needed to enforce that `previousBlockHash` and `blockTimestamp` was read exactly one time\n        bool isSystemContextLogProcessed;\n        bytes[] calldata factoryDeps = _newBlock.factoryDeps;\n        uint256 currentBytecode;\n\n        chainedPriorityTxsHash = EMPTY_STRING_KECCAK;\n\n        // linear traversal of the logs\n        for (uint256 i = 0; i < emittedL2Logs.length; i = i.uncheckedAdd(L2_TO_L1_LOG_SERIALIZE_SIZE)) {\n            (address logSender, ) = UnsafeBytes.readAddress(emittedL2Logs, i + 4);\n\n            // show preimage for hashed message stored in log\n            if (logSender == L2_TO_L1_MESSENGER) {\n                (bytes32 hashedMessage, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 56);\n                require(keccak256(l2Messages[currentMessage]) == hashedMessage, \"k2\");\n\n                currentMessage = currentMessage.uncheckedInc();\n            } else if (logSender == L2_BOOTLOADER_ADDRESS) {\n                (bytes32 canonicalTxHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 24);\n                chainedPriorityTxsHash = keccak256(abi.encode(chainedPriorityTxsHash, canonicalTxHash));\n\n                // Overflow is not realistic\n                numberOfLayer1Txs = numberOfLayer1Txs.uncheckedInc();\n            } else if (logSender == L2_SYSTEM_CONTEXT_ADDRESS) {\n                // Make sure that the system context log wasn't processed yet, to\n                // avoid accident double reading `blockTimestamp` and `previousBlockHash`\n                require(!isSystemContextLogProcessed, \"fx\");\n                (blockTimestamp, ) = UnsafeBytes.readUint256(emittedL2Logs, i + 24);\n                (previousBlockHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 56);\n                // Mark system context log as processed\n                isSystemContextLogProcessed = true;\n            } else if (logSender == L2_KNOWN_CODE_STORAGE_ADDRESS) {\n                (bytes32 bytecodeHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 24);\n                require(bytecodeHash == L2ContractHelper.hashL2Bytecode(factoryDeps[currentBytecode]), \"k3\");\n\n                currentBytecode = currentBytecode.uncheckedInc();\n            }\n        }\n        // To check that only relevant preimages have been included in the calldata\n        require(currentBytecode == factoryDeps.length, \"ym\");\n        require(currentMessage == l2Messages.length, \"pl\");\n        // `blockTimestamp` and `previousBlockHash` wasn't read from L2 logs\n        require(isSystemContextLogProcessed, \"by\");\n    }\n\n    /// @notice Commit block\n    /// @notice 1. Checks timestamp.\n    /// @notice 2. Process L2 logs.\n    /// @notice 3. Store block commitments.\n    function commitBlocks(StoredBlockInfo memory _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)\n        external\n        override\n        nonReentrant\n        onlyValidator\n    {\n        // Check that we commit blocks after last committed block\n        require(s.storedBlockHashes[s.totalBlocksCommitted] == _hashStoredBlockInfo(_lastCommittedBlockData), \"i\"); // incorrect previous block data\n\n        uint256 blocksLength = _newBlocksData.length;\n        for (uint256 i = 0; i < blocksLength; i = i.uncheckedInc()) {\n            _lastCommittedBlockData = _commitOneBlock(_lastCommittedBlockData, _newBlocksData[i]);\n            s.storedBlockHashes[_lastCommittedBlockData.blockNumber] = _hashStoredBlockInfo(_lastCommittedBlockData);\n\n            emit BlockCommit(\n                _lastCommittedBlockData.blockNumber,\n                _lastCommittedBlockData.blockHash,\n                _lastCommittedBlockData.commitment\n            );\n        }\n\n        s.totalBlocksCommitted = s.totalBlocksCommitted + blocksLength;\n    }\n\n    /// @dev Pops the priority operations from the priority queue and returns a rolling hash of operations\n    function _collectOperationsFromPriorityQueue(uint256 _nPriorityOps) internal returns (bytes32 concatHash) {\n        concatHash = EMPTY_STRING_KECCAK;\n\n        for (uint256 i = 0; i < _nPriorityOps; i = i.uncheckedInc()) {\n            PriorityOperation memory priorityOp = s.priorityQueue.popFront();\n            concatHash = keccak256(abi.encode(concatHash, priorityOp.canonicalTxHash));\n        }\n    }\n\n    /// @dev Executes one block\n    /// @dev 1. Processes all pending operations (Complete priority requests)\n    /// @dev 2. Finalizes block on Ethereum\n    /// @dev _executedBlockIdx is an index in the array of the blocks that we want to execute together\n    function _executeOneBlock(StoredBlockInfo memory _storedBlock, uint256 _executedBlockIdx) internal {\n        uint256 currentBlockNumber = _storedBlock.blockNumber;\n        require(currentBlockNumber == s.totalBlocksExecuted + _executedBlockIdx + 1, \"k\"); // Execute blocks in order\n        require(\n            _hashStoredBlockInfo(_storedBlock) == s.storedBlockHashes[currentBlockNumber],\n            \"exe10\" // executing block should be committed\n        );\n\n        bytes32 priorityOperationsHash = _collectOperationsFromPriorityQueue(_storedBlock.numberOfLayer1Txs);\n        require(priorityOperationsHash == _storedBlock.priorityOperationsHash, \"x\"); // priority operations hash does not match to expected\n\n        // Save root hash of L2 -> L1 logs tree\n        s.l2LogsRootHashes[currentBlockNumber] = _storedBlock.l2LogsTreeRoot;\n    }\n\n    /// @notice Execute blocks, complete priority operations and process withdrawals.\n    /// @notice 1. Processes all pending operations (Complete priority requests)\n    /// @notice 2. Finalizes block on Ethereum\n    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external nonReentrant onlyValidator {\n        uint256 nBlocks = _blocksData.length;\n        for (uint256 i = 0; i < nBlocks; i = i.uncheckedInc()) {\n            _executeOneBlock(_blocksData[i], i);\n            emit BlockExecution(_blocksData[i].blockNumber, _blocksData[i].blockHash, _blocksData[i].commitment);\n        }\n\n        s.totalBlocksExecuted = s.totalBlocksExecuted + nBlocks;\n        require(s.totalBlocksExecuted <= s.totalBlocksVerified, \"n\"); // Can't execute blocks more then committed and proven currently.\n    }\n\n    /// @notice Blocks commitment verification.\n    /// @notice Only verifies block commitments without any other processing\n    function proveBlocks(\n        StoredBlockInfo calldata _prevBlock,\n        StoredBlockInfo[] calldata _committedBlocks,\n        ProofInput calldata _proof\n    ) external nonReentrant onlyValidator {\n        // Save the variables into the stack to save gas on reading them later\n        uint256 currentTotalBlocksVerified = s.totalBlocksVerified;\n        uint256 committedBlocksLength = _committedBlocks.length;\n\n        // Save the variable from the storage to memory to save gas\n        VerifierParams memory verifierParams = s.verifierParams;\n\n        // Initialize the array, that will be used as public input to the ZKP\n        uint256[] memory proofPublicInput = new uint256[](committedBlocksLength);\n\n        // Check that the block passed by the validator is indeed the first unverified block\n        require(_hashStoredBlockInfo(_prevBlock) == s.storedBlockHashes[currentTotalBlocksVerified], \"t1\");\n\n        bytes32 prevBlockCommitment = _prevBlock.commitment;\n        for (uint256 i = 0; i < committedBlocksLength; i = i.uncheckedInc()) {\n            require(\n                _hashStoredBlockInfo(_committedBlocks[i]) ==\n                    s.storedBlockHashes[currentTotalBlocksVerified.uncheckedInc()],\n                \"o1\"\n            );\n\n            bytes32 currentBlockCommitment = _committedBlocks[i].commitment;\n            proofPublicInput[i] = _getBlockProofPublicInput(\n                prevBlockCommitment,\n                currentBlockCommitment,\n                _proof,\n                verifierParams\n            );\n\n            prevBlockCommitment = currentBlockCommitment;\n            currentTotalBlocksVerified = currentTotalBlocksVerified.uncheckedInc();\n        }\n\n        // #if DUMMY_VERIFIER == false\n        bool successVerifyProof = s.verifier.verify_serialized_proof(proofPublicInput, _proof.serializedProof);\n        require(successVerifyProof, \"p\"); // Proof verification fail\n\n        // Verify the recursive part that was given to us through the public input\n        bool successProofAggregation = _verifyRecursivePartOfProof(_proof.recurisiveAggregationInput);\n        require(successProofAggregation, \"hh\"); // Proof aggregation must be valid\n        // #endif\n\n        require(currentTotalBlocksVerified <= s.totalBlocksCommitted, \"q\");\n        emit BlocksVerification(s.totalBlocksVerified, currentTotalBlocksVerified);\n        s.totalBlocksVerified = currentTotalBlocksVerified;\n    }\n\n    /// @dev Gets zk proof public input\n    function _getBlockProofPublicInput(\n        bytes32 _prevBlockCommitment,\n        bytes32 _currentBlockCommitment,\n        ProofInput calldata _proof,\n        VerifierParams memory _verifierParams\n    ) internal pure returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        _prevBlockCommitment,\n                        _currentBlockCommitment,\n                        _verifierParams.recursionNodeLevelVkHash,\n                        _verifierParams.recursionLeafLevelVkHash,\n                        _verifierParams.recursionCircuitsSetVksHash,\n                        _proof.recurisiveAggregationInput\n                    )\n                )\n            ) & INPUT_MASK;\n    }\n\n    /// @dev Verify a part of the zkp, that is responsible for the aggregation\n    function _verifyRecursivePartOfProof(uint256[] calldata _recurisiveAggregationInput) internal view returns (bool) {\n        require(_recurisiveAggregationInput.length == 4);\n\n        PairingsBn254.G1Point memory pairWithGen = PairingsBn254.new_g1_checked(\n            _recurisiveAggregationInput[0],\n            _recurisiveAggregationInput[1]\n        );\n        PairingsBn254.G1Point memory pairWithX = PairingsBn254.new_g1_checked(\n            _recurisiveAggregationInput[2],\n            _recurisiveAggregationInput[3]\n        );\n\n        PairingsBn254.G2Point memory g2Gen = PairingsBn254.new_g2(\n            [\n                0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\n                0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\n            ],\n            [\n                0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\n                0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n            ]\n        );\n        PairingsBn254.G2Point memory g2X = PairingsBn254.new_g2(\n            [\n                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\n                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0\n            ],\n            [\n                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\n                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\n            ]\n        );\n\n        return PairingsBn254.pairingProd2(pairWithGen, g2Gen, pairWithX, g2X);\n    }\n\n    /// @notice Reverts unexecuted blocks\n    /// @param _newLastBlock block number after which blocks should be reverted\n    /// NOTE: Doesn't delete the stored data about blocks, but only decreases\n    /// counters that are responsible for the number of blocks\n    function revertBlocks(uint256 _newLastBlock) external nonReentrant onlyValidator {\n        require(s.totalBlocksCommitted > _newLastBlock, \"v1\"); // the last committed block is less new last block\n        uint256 newTotalBlocksCommitted = _maxU256(_newLastBlock, s.totalBlocksExecuted);\n\n        if (newTotalBlocksCommitted < s.totalBlocksVerified) {\n            s.totalBlocksVerified = newTotalBlocksCommitted;\n        }\n        s.totalBlocksCommitted = newTotalBlocksCommitted;\n\n        emit BlocksRevert(s.totalBlocksCommitted, s.totalBlocksVerified, s.totalBlocksExecuted);\n    }\n\n    /// @notice Returns larger of two values\n    function _maxU256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? b : a;\n    }\n\n    /// @dev Creates block commitment from its data\n    function _createBlockCommitment(CommitBlockInfo calldata _newBlockData) internal view returns (bytes32) {\n        bytes32 passThroughDataHash = keccak256(_blockPassThroughData(_newBlockData));\n        bytes32 metadataHash = keccak256(_blockMetaParameters());\n        bytes32 auxiliaryOutputHash = keccak256(_blockAuxilaryOutput(_newBlockData));\n\n        return keccak256(abi.encode(passThroughDataHash, metadataHash, auxiliaryOutputHash));\n    }\n\n    function _blockPassThroughData(CommitBlockInfo calldata _block) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _block.indexRepeatedStorageChanges,\n                _block.newStateRoot,\n                uint64(0), // index repeated storage changes in zkPorter\n                bytes32(0) // zkPorter block hash\n            );\n    }\n\n    function _blockMetaParameters() internal view returns (bytes memory) {\n        return abi.encodePacked(s.zkPorterIsAvailable, s.l2BootloaderBytecodeHash, s.l2DefaultAccountBytecodeHash);\n    }\n\n    function _blockAuxilaryOutput(CommitBlockInfo calldata _block) internal pure returns (bytes memory) {\n        bytes32 initialStorageChangesHash = keccak256(_block.initialStorageChanges);\n        bytes32 repeatedStorageChangesHash = keccak256(_block.repeatedStorageChanges);\n        bytes32 l2ToL1LogsHash = keccak256(_block.l2Logs);\n\n        return abi.encode(_block.l2LogsTreeRoot, l2ToL1LogsHash, initialStorageChangesHash, repeatedStorageChangesHash);\n    }\n\n    /// @notice Returns the keccak hash of the ABI-encoded StoredBlockInfo\n    function _hashStoredBlockInfo(StoredBlockInfo memory _storedBlockInfo) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_storedBlockInfo));\n    }\n}\n\n\n",
        "CodeNames": [
            "Mailbox.sol",
            "Executor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "3",
                "Location": [],
                "Type": "",
                "Description": "\nBetter to have config facet, in case some update is needed in the config.sol. Therefore, it is not necessary to redeploy the facets that imported config (like Executor and Mailbox).\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/L2ContractHelper.sol\";\n\n/// @author Matter Labs\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to zkSync v2.0\n/// @dev It is standard implementation of ERC20 Bridge that can be used as a refference\n/// for any other custom token bridges.\ncontract L1ERC20Bridge is IL1Bridge, AllowListed, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList immutable allowList;\n\n    /// @dev zkSync smart contract that used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox immutable zkSyncMailbox;\n\n    /// @dev Ergs limit for requesting L2 deposit finalization transaction\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPOSIT_ERGS_LIMIT = 2097152;\n\n    /// @dev Ergs limit for requesting L1 -> L2 transaction of deploying L2 bridge instance\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT = 2097152;\n\n    /// @dev A mapping L2 block number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(address => mapping(bytes32 => uint256))) depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address of the factory that deploys proxy for L2 tokens\n    address public l2TokenFactory;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2ProxyTokenBytecodeHash;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _mailbox, IAllowList _allowList) reentrancyGuardInitializer {\n        zkSyncMailbox = _mailbox;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge\n    /// @notice _factoryDeps[1] == a raw bytecode of token proxy\n    /// @param _l2TokenFactory Pre-calculated address of L2 token beacon proxy\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2TokenFactory,\n        address _governor\n    ) external reentrancyGuardInitializer {\n        // We are expecting to see the exect two bytecodes that are needed to initiailize the bridge\n        require(_factoryDeps.length == 2, \"mk\");\n        l2ProxyTokenBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n        l2TokenFactory = _l2TokenFactory;\n\n        bytes32 create2Salt = bytes32(0);\n        bytes memory create2Input = abi.encode(address(this), l2ProxyTokenBytecodeHash, _governor);\n        bytes32 l2BridgeBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes memory deployL2BridgeCalldata = abi.encodeCall(\n            IContractDeployer.create2,\n            (create2Salt, l2BridgeBytecodeHash, create2Input)\n        );\n\n        l2Bridge = L2ContractHelper.computeCreate2Address(\n            address(this),\n            create2Salt,\n            l2BridgeBytecodeHash,\n            keccak256(create2Input)\n        );\n\n        zkSyncMailbox.requestL2Transaction(\n            DEPLOYER_SYSTEM_CONTRACT_ADDRESS,\n            0,\n            deployL2BridgeCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @return txHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) external payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 txHash) {\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount > 0, \"1T\"); // empty deposit amount\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount);\n        txHash = zkSyncMailbox.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            DEPOSIT_ERGS_LIMIT,\n            new bytes[](0)\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][txHash] = amount;\n\n        emit DepositInitiated(msg.sender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring funds\n    function _depositFunds(\n        address _from,\n        IERC20 _token,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n        );\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BlockNumber The L2 block number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the deposit (L1 -> L2 transaction) was included in the L2 block with failed status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 for fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBlock = number of transaction in the block\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(0)\n        });\n        bool success = zkSyncMailbox.proveL2LogInclusion(_l2BlockNumber, _l2MessageIndex, l2Log, _merkleProof);\n        require(success, \"yn\");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, \"y1\");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], \"pw\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSyncMailbox.proveL2MessageInclusion(\n                _l2BlockNumber,\n                _l2MessageIndex,\n                l2ToL1Message,\n                _merkleProof\n            );\n            require(success, \"nq\");\n        }\n\n        isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _l2ToL1message)\n        internal\n        pure\n        returns (\n            address l1Receiver,\n            address l1Token,\n            uint256 amount\n        )\n    {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 = 76 (bytes).\n        require(_l2ToL1message.length == 76, \"kk\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, \"nt\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenFactory), \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2ProxyTokenBytecodeHash, constructorInputHash);\n    }\n}\n\n\n",
        "CodeNames": [
            "L1ERC20Bridge.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "5",
                "Location": [
                    "requestL",
                    "senderCanCallFunction",
                    "deposit"
                ],
                "Type": "",
                "Description": "\nIt is not needed to have modifier senderCanCallFunction for the function deposit in both L1ERC20Bridge and L1ETHBridge, because they call the function requestL2Transaction in the MailBox that has already such modifier.<br\nL1EthBridge.sol#L92(https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/bridge/L1EthBridge.sol#L92)<br\nMailbox.sol#L112(https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Mailbox.sol#L112)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "diff\n  function decodeString(bytes memory _input) external pure returns (string memory result) {\n+   function decodeString(bytes calldata _input) external pure returns (string memory result) {\n        (result) = abi.decode(_input, (string));\n    }\n"
                ],
                "Type": " Use  calldata  instead of  memory ",
                "Description": "\nSome methods are declared as external but the arguments are defined as memory instead of as calldata.\n\nBy marking the function as external it is possible to use calldata in the arguments shown below and save significant gas.\n\nRecommended change:\n\ndiff\n  function decodeString(bytes memory _input) external pure returns (string memory result) {\n+   function decodeString(bytes calldata _input) external pure returns (string memory result) {\n        (result) = abi.decode(_input, (string));\n    }\n\n\nAffected source code:\n\n*   ExternalDecoder.sol:10-12(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/ExternalDecoder.sol#L10-L12)\n*   ExternalDecoder.sol:15-17(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/ExternalDecoder.sol#L15-L17)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [
                    "immutable"
                ],
                "Type": " Gas saving using  immutable ",
                "Description": "\nIt's possible to avoid storage access a save gas using immutable keyword for the following variables:\n\nIt's also better to remove the initial values, because they will be set during the constructor.\n\nAffected source code:\n\n*   L2ERC20Bridge.sol:19(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L19)\n*   L2ERC20Bridge.sol:23(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L23)\n*   L2ERC20Bridge.sol:26(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L26)\n*   L2ETHBridge.sol:22(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ETHBridge.sol#L22)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"../../zksync/libraries/Diamond.sol\";\nimport \"../../zksync/facets/Getters.sol\";\n\ncontract DiamondCutTest is GettersFacet {\n    function diamondCut(Diamond.DiamondCutData memory _diamondCut) external {\n        Diamond.diamondCut(_diamondCut);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./interfaces/IExecutor.sol\";\nimport \"./libraries/Diamond.sol\";\nimport \"./facets/Base.sol\";\nimport \"./Config.sol\";\n\n/// @author Matter Labs\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is Base {\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice zkSync contract initialization\n    /// @param _verifier address of Verifier contract\n    /// @param _governor address who can manage the contract\n    /// @param _validator address who can make blocks\n    /// @param _genesisBlockHash Block hash of the genesis (initial) block\n    /// @param _genesisIndexRepeatedStorageChanges The serial number of the shortcut storage key for genesis block\n    /// @param _genesisBlockCommitment The zk-proof commitment for the genesis block\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy initializer\n    function initialize(\n        Verifier _verifier,\n        address _governor,\n        address _validator,\n        bytes32 _genesisBlockHash,\n        uint64 _genesisIndexRepeatedStorageChanges,\n        bytes32 _genesisBlockCommitment,\n        IAllowList _allowList,\n        VerifierParams calldata _verifierParams,\n        bool _zkPorterIsAvailable,\n        bytes32 _l2BootloaderBytecodeHash,\n        bytes32 _l2DefaultAccountBytecodeHash\n    ) external reentrancyGuardInitializer returns (bytes32) {\n        s.verifier = _verifier;\n        s.governor = _governor;\n        s.validators[_validator] = true;\n\n        // We need to initialize the state hash because it is used in the commitment of the next block\n        IExecutor.StoredBlockInfo memory storedBlockZero = IExecutor.StoredBlockInfo(\n            0,\n            _genesisBlockHash,\n            _genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _genesisBlockCommitment\n        );\n\n        s.storedBlockHashes[0] = keccak256(abi.encode(storedBlockZero));\n        s.allowList = _allowList;\n        s.verifierParams = _verifierParams;\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}\n\n\n",
        "CodeNames": [
            "DiamondCutTest.sol",
            "DiamondInit.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "7",
                "Location": [
                    "storedBlockHashes",
                    "GettersFacet"
                ],
                "Type": "",
                "Description": "\nWhen a block is committed, its hash will be stored in storedBlockHashes:<br\nExecutor.sol#L164(https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Executor.sol#L164)<br\n\nIf this block is reverted, it is not removed from storedBlockHashes:<br\nExecutor.sol#L336(https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Executor.sol#L336)<br\n\nThe vulnerability is that in the GettersFacet, the function storedBlockHash(...) will return the hash of a reverted block if this block number is given as its parameter, while it should return 0.<br\nGetters.sol#L86(https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Getters.sol#L86)<br\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1325835625):\n  The critical parameters in initialize(...) are not set safely:<br\n \n Logically equivalent to address(0) check, Low\n \n approveEmergencyDiamondCutAsSecurityCouncilMemberBySignature<br\n\n Not sure what this means, but if it means one caller gets to approve emerengency cuts, this is a glaring security risk.\n \n Better to have config facet, in case some update is needed in the config.sol<br\n\n Not convinced by this one either, ultimately it's called config but it's just a bunch of contact / base contract\n \n L2_LOG_BYTES is not correct, it should be L2_TO_L1_LOG_SERIALIZE_SIZE<br\n\n Non-Critical\n \n It is not needed to have modifier senderCanCallFunction for the function deposit in both L1ERC20Bridge and L1ETHBridge, because they call the function requestL2Transaction in the MailBox that has already such modifier.<br\n\n Not convinced in lack of detail, if you call contract X and contract X calls contract Y, then the check is necessary on both contracts\n \n For each deposit of an ERC20 token, the information<br\n\n Unclear what you'd do and where the savings would be.\n \n When a block is committed, its hash will be stored in storedBlockHashes:\n\n See #204(https://github.com/code-423n4/2022-10-zksync-findings/issues/204), Low\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1335920135):\n  2 Low, 1 Non-Critical\n\n  Report was pretty good, but the downgraded findings add a lot of points to this QA.\n \n While the Warden has sent a few false positives, I think the value they offered for this contest warrants them winning the best QA report.\n\n*(Note: please see warden's original submission(https://github.com/code-423n4/2022-10-zksync-findings/issues/49) for links to the referenced downgraded findings)*\n\nmiladpiri (zkSync) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1336268291):\n   Thanks, @Alex the Entreprenerd for your comment, that we are now looking at this report more seriously.<br\n\n IMO, No.2 \u201capproveEmergencyDiamondCutAsSecurityCouncilMemberBySignature\u201c can be a security issue. This is what we are now implementing to make security council members be able to approve the proposal by signature.<br\n\n The security issue is that in case the security council members do not have access to approve on-chain, the governor must wait for their approval to bypass the notice period. In case the proposal should be executed instantly (in case of a critical bug in our protocol), this delay can be dangerous to our protocol.<br\n\n By having approval by signature, the security members can approve a proposal off-chain, and the governor can execute the instant upgrade on behalf of them by using their signatures, so all-time access to the chain is not necessary for security council members.<br\n\n Moreover, in case a critical proposal should be executed silently, it is necessary to be able to approve by signature. Because, the governor, in one batch transaction, proposes the proposal, and approves the upgrade on behalf of the security council members by using their signatures, and then executes the proposal. Since all the above actions are done in one transaction, there is no security risk of vulnerability leak. But, in the current structure, when the governor proposes the proposal, should wait for security members\u2019 approval, this delay can be transparent to a malicious user to investigate the governor\u2019s proposal, and gets a clue what the vulnerability is and then exploits the protocol.<br\n\n This report worths to be upgraded in terms of severity!\n Thanks.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1340174006):\n Thank you for your insight, I have sent the contest to triage, took note of your feedback and am sharing with other Judges and Wardens.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1343557528):\n  Similarly to #48(https://github.com/code-423n4/2022-10-zksync-findings/issues/48), I have shared this finding with 2 Judges and a Top warden and we all agree that this is effectively the same finding, with similar impact.\n \n As such Low Severity is the most appropriate.\n\nmiladpiri (zkSync) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1343993682):\n  Thanks for the follow-up!\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 10 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-10-zksync-findings/issues/35) by 0x1f8b received the top score from the judge.\n\n*The following wardens also submitted reports: Aymen0909(https://github.com/code-423n4/2022-10-zksync-findings/issues/341), c3phas(https://github.com/code-423n4/2022-10-zksync-findings/issues/337), TomJ(https://github.com/code-423n4/2022-10-zksync-findings/issues/282), gogo(https://github.com/code-423n4/2022-10-zksync-findings/issues/233), IllIllI(https://github.com/code-423n4/2022-10-zksync-findings/issues/224), ReyAdmirado(https://github.com/code-423n4/2022-10-zksync-findings/issues/124), mcwildy(https://github.com/code-423n4/2022-10-zksync-findings/issues/117), Rolezn(https://github.com/code-423n4/2022-10-zksync-findings/issues/111), and HardlyCodeMan(https://github.com/code-423n4/2022-10-zksync-findings/issues/80).*\n\nDisclosure Note from 0x1f8b:\n\n*First of all, please note that there are \"known issues\" that were not referenced in the report(https://gist.github.com/Picodes/1f87a82e954cc749dea9d9961d5f4dff), these lines were included in this report because they were not present in the public one.*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/Diamond.sol\";\nimport \"../Config.sol\";\nimport \"./Base.sol\";\n\n/// @title DiamondCut contract responsible for the management of upgrades.\n/// @author Matter Labs\ncontract DiamondCutFacet is Base, IDiamondCut {\n    constructor() {\n        // Caution check for config value.\n        // Should be greater than 0, otherwise zero approvals will be enough to make an instant upgrade!\n        assert(SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE > 0);\n    }\n\n    /// @dev Starts the upgrade process. Only the current governor can propose an upgrade.\n    /// @param _facetCuts The set of proposed changes to the facets (adding/replacement/removing)\n    /// @param _initAddress Address of the fallback contract that will be called after the upgrade execution\n    function proposeDiamondCut(Diamond.FacetCut[] calldata _facetCuts, address _initAddress) external onlyGovernor {\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp == 0, \"a3\"); // proposal already exists\n\n        // NOTE: governor commits only to the `facetCuts` and `initAddress`, but not to the calldata on `initAddress` call.\n        // That means the governor can call `initAddress` with ANY calldata while executing the upgrade.\n        s.diamondCutStorage.proposedDiamondCutHash = keccak256(abi.encode(_facetCuts, _initAddress));\n        s.diamondCutStorage.proposedDiamondCutTimestamp = block.timestamp;\n        s.diamondCutStorage.currentProposalId += 1;\n\n        emit DiamondCutProposal(_facetCuts, _initAddress);\n    }\n\n    /// @notice Removes the upgrade proposal. Only current governor can remove proposal.\n    function cancelDiamondCutProposal() external onlyGovernor {\n        emit DiamondCutProposalCancelation(\n            s.diamondCutStorage.currentProposalId,\n            s.diamondCutStorage.proposedDiamondCutHash\n        );\n        require(_resetProposal(), \"g1\"); // failed cancel diamond cut\n    }\n\n    /// @notice Executes a proposed governor upgrade. Only the current governor can execute the upgrade.\n    /// NOTE: Governor can execute diamond cut ONLY with proposed `facetCuts` and `initAddress`.\n    /// `initCalldata` can be arbitrarily.\n    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        bool approvedBySecurityCouncil = s.diamondCutStorage.securityCouncilEmergencyApprovals >=\n            SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE;\n\n        bool upgradeNoticePeriodPassed = block.timestamp >=\n            s.diamondCutStorage.proposedDiamondCutTimestamp + UPGRADE_NOTICE_PERIOD;\n\n        require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n        require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n        // should not be frozen or should have enough security council approvals\n\n        require(\n            s.diamondCutStorage.proposedDiamondCutHash ==\n                keccak256(abi.encode(_diamondCut.facetCuts, _diamondCut.initAddress)),\n            \"a4\"\n        ); // proposal should be created\n\n        require(_resetProposal(), \"a5\"); // failed reset proposal\n\n        if (diamondStorage.isFrozen) {\n            diamondStorage.isFrozen = false;\n            emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n        }\n\n        Diamond.diamondCut(_diamondCut);\n\n        emit DiamondCutProposalExecution(_diamondCut);\n    }\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    function emergencyFreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        _resetProposal();\n\n        diamondStorage.isFrozen = true;\n        // Limited-time freezing feature will be added in the future upgrades, so keeping this variable for simplification\n        s.diamondCutStorage.lastDiamondFreezeTimestamp = block.timestamp;\n\n        emit EmergencyFreeze();\n    }\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    function unfreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n\n        _resetProposal();\n\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n    }\n\n    /// @notice Gives another approval for the instant upgrade (diamond cut) by the security council member\n    /// @param _diamondCutHash The hash of the diamond cut that security council members want to approve. Needed to prevent unintentional approvals, including reorg attacks\n    function approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32 _diamondCutHash) external {\n        require(s.diamondCutStorage.securityCouncilMembers[msg.sender], \"a9\"); // not a security council member\n        uint256 currentProposalId = s.diamondCutStorage.currentProposalId;\n        require(s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] < currentProposalId, \"ao\"); // already approved this proposal\n        s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] = currentProposalId;\n\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp != 0, \"f0\"); // there is no proposed diamond cut\n        require(s.diamondCutStorage.proposedDiamondCutHash == _diamondCutHash, \"f1\"); // proposed diamond cut do not match to the approved\n        uint256 securityCouncilEmergencyApprovals = s.diamondCutStorage.securityCouncilEmergencyApprovals;\n        s.diamondCutStorage.securityCouncilEmergencyApprovals = securityCouncilEmergencyApprovals + 1;\n\n        emit EmergencyDiamondCutApproved(\n            msg.sender,\n            currentProposalId,\n            securityCouncilEmergencyApprovals,\n            _diamondCutHash\n        );\n    }\n\n    /// @dev Set up the proposed diamond cut state to the default values\n    /// @return Whether the proposal is reset or it was already empty\n    function _resetProposal() private returns (bool) {\n        if (s.diamondCutStorage.proposedDiamondCutTimestamp == 0) {\n            return false;\n        }\n\n        delete s.diamondCutStorage.proposedDiamondCutHash;\n        delete s.diamondCutStorage.proposedDiamondCutTimestamp;\n        delete s.diamondCutStorage.securityCouncilEmergencyApprovals;\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/L2ContractHelper.sol\";\n\n/// @author Matter Labs\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to zkSync v2.0\n/// @dev It is standard implementation of ERC20 Bridge that can be used as a refference\n/// for any other custom token bridges.\ncontract L1ERC20Bridge is IL1Bridge, AllowListed, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList immutable allowList;\n\n    /// @dev zkSync smart contract that used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox immutable zkSyncMailbox;\n\n    /// @dev Ergs limit for requesting L2 deposit finalization transaction\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPOSIT_ERGS_LIMIT = 2097152;\n\n    /// @dev Ergs limit for requesting L1 -> L2 transaction of deploying L2 bridge instance\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT = 2097152;\n\n    /// @dev A mapping L2 block number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(address => mapping(bytes32 => uint256))) depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address of the factory that deploys proxy for L2 tokens\n    address public l2TokenFactory;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2ProxyTokenBytecodeHash;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _mailbox, IAllowList _allowList) reentrancyGuardInitializer {\n        zkSyncMailbox = _mailbox;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge\n    /// @notice _factoryDeps[1] == a raw bytecode of token proxy\n    /// @param _l2TokenFactory Pre-calculated address of L2 token beacon proxy\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2TokenFactory,\n        address _governor\n    ) external reentrancyGuardInitializer {\n        // We are expecting to see the exect two bytecodes that are needed to initiailize the bridge\n        require(_factoryDeps.length == 2, \"mk\");\n        l2ProxyTokenBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n        l2TokenFactory = _l2TokenFactory;\n\n        bytes32 create2Salt = bytes32(0);\n        bytes memory create2Input = abi.encode(address(this), l2ProxyTokenBytecodeHash, _governor);\n        bytes32 l2BridgeBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes memory deployL2BridgeCalldata = abi.encodeCall(\n            IContractDeployer.create2,\n            (create2Salt, l2BridgeBytecodeHash, create2Input)\n        );\n\n        l2Bridge = L2ContractHelper.computeCreate2Address(\n            address(this),\n            create2Salt,\n            l2BridgeBytecodeHash,\n            keccak256(create2Input)\n        );\n\n        zkSyncMailbox.requestL2Transaction(\n            DEPLOYER_SYSTEM_CONTRACT_ADDRESS,\n            0,\n            deployL2BridgeCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @return txHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) external payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 txHash) {\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount > 0, \"1T\"); // empty deposit amount\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount);\n        txHash = zkSyncMailbox.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            DEPOSIT_ERGS_LIMIT,\n            new bytes[](0)\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][txHash] = amount;\n\n        emit DepositInitiated(msg.sender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring funds\n    function _depositFunds(\n        address _from,\n        IERC20 _token,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n        );\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BlockNumber The L2 block number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the deposit (L1 -> L2 transaction) was included in the L2 block with failed status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 for fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBlock = number of transaction in the block\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(0)\n        });\n        bool success = zkSyncMailbox.proveL2LogInclusion(_l2BlockNumber, _l2MessageIndex, l2Log, _merkleProof);\n        require(success, \"yn\");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, \"y1\");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], \"pw\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSyncMailbox.proveL2MessageInclusion(\n                _l2BlockNumber,\n                _l2MessageIndex,\n                l2ToL1Message,\n                _merkleProof\n            );\n            require(success, \"nq\");\n        }\n\n        isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _l2ToL1message)\n        internal\n        pure\n        returns (\n            address l1Receiver,\n            address l1Token,\n            uint256 amount\n        )\n    {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 = 76 (bytes).\n        require(_l2ToL1message.length == 76, \"kk\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, \"nt\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenFactory), \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2ProxyTokenBytecodeHash, constructorInputHash);\n    }\n}\n\n\n",
        "CodeNames": [
            "DiamondCut.sol",
            "L1ERC20Bridge.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-01",
                "Location": [
                    "assert",
                    "assert()",
                    "require",
                    "require()"
                ],
                "Type": " Use  require  instead of  assert ",
                "Description": "\nThe assert() and require() functions are a part of the error handling aspect in Solidity. Solidity makes use of state-reverting error handling exceptions. This means all changes made to the contract on that call or any sub-calls are undone if an error is thrown. It also flags an error.\n\nThey are quite similar as both check for conditions and if they are not met, would throw an error.\n\nThe big difference between the two is that the assert() function when false, uses up all the remaining gas and reverts all the changes made.\n\nMeanwhile, a require() function when false, also reverts back all the changes made to the contract but does refund all the remaining gas fees we offered to pay. This is the most common Solidity function used by developers for debugging and error handling.\n\nAffected source code:\n\n*   DiamondCut.sol:16(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L16)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-09",
                "Location": [
                    "assert",
                    "assert()",
                    "require",
                    "require()"
                ],
                "Type": " Use  require  instead of  assert ",
                "Description": "\nThe assert() and require() functions are a part of the error handling aspect in Solidity. Solidity makes use of state-reverting error handling exceptions. This means all changes made to the contract on that call or any sub-calls are undone if an error is thrown. It also flags an error.\n\nThey are quite similar as both check for conditions and if they are not met, would throw an error.\n\nThe big difference between the two is that the assert() function when false, uses up all the remaining gas and reverts all the changes made.\n\nMeanwhile, a require() function when false, also reverts back all the changes made to the contract but does refund all the remaining gas fees we offered to pay. This is the most common Solidity function used by developers for debugging and error handling.\n\nAffected source code:\n\n*   DiamondCut.sol:16(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L16)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/35#issuecomment-1326853179):\n  G-01] Use require instead of assert<br\n Valid but will only run in constructor so ignoring\n \n G-02] Avoid compound assignment operator in state variables<br\n Awarding 34 as that's what I get when changing the in-scope tests\n \n G-03] Use calldata instead of memory<br\n Cannot test the benchmark, but it's roughly in the hundreds, let's say 200 gas\n \n G-04] Shift right or left instead of dividing or multiply by 2<br\n This mostly saves gas because of the unchecked, let's say 100 gas\n \n G-05] There's no need to set default values for variables<br\n Those are constants, will be inlined by the compiler\n \n G-06] Unnecessary cast in Mailbox.serializeL2Transaction<br\n The cast should be optimized away by the compiler as no supporting variable is declared\n \n G-07] Gas saving using immutable<br\n 2.1k per var<br\n 8.4k<br\n \n G-08] Reorder structure layout<br\n 2k each as it will save one extra cold Slot Load<br\n 4k\n \n Pretty good, but would benefit by using benchmarks from the codebase in-scope.\n\n  10734\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-zksync-findings/issues/35#issuecomment-1336220069):\n  Ultimately offered the strongest savings via immutables and did not offer false positives vs other reports, also found the packing refactoring which will offer great savings to end users.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./libraries/PairingsBn254.sol\";\nimport \"./libraries/TranscriptLib.sol\";\nimport \"../common/libraries/UncheckedMath.sol\";\n\nuint256 constant STATE_WIDTH = 4;\nuint256 constant NUM_G2_ELS = 2;\n\nstruct VerificationKey {\n    uint256 domain_size;\n    uint256 num_inputs;\n    PairingsBn254.Fr omega;\n    PairingsBn254.G1Point[2] gate_selectors_commitments;\n    PairingsBn254.G1Point[8] gate_setup_commitments;\n    PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;\n    PairingsBn254.G1Point lookup_selector_commitment;\n    PairingsBn254.G1Point[4] lookup_tables_commitments;\n    PairingsBn254.G1Point lookup_table_type_commitment;\n    PairingsBn254.Fr[STATE_WIDTH - 1] non_residues;\n    PairingsBn254.G2Point[NUM_G2_ELS] g2_elements;\n}\n\ncontract Plonk4VerifierWithAccessToDNext {\n    using PairingsBn254 for PairingsBn254.G1Point;\n    using PairingsBn254 for PairingsBn254.G2Point;\n    using PairingsBn254 for PairingsBn254.Fr;\n\n    using TranscriptLib for TranscriptLib.Transcript;\n\n    using UncheckedMath for uint256;\n\n    struct Proof {\n        uint256[] input_values;\n        // commitments\n        PairingsBn254.G1Point[STATE_WIDTH] state_polys_commitments;\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_parts_commitments;\n        // openings\n        PairingsBn254.Fr[STATE_WIDTH] state_polys_openings_at_z;\n        PairingsBn254.Fr[1] state_polys_openings_at_z_omega; // TODO: not use array while there is only D_next\n        PairingsBn254.Fr[1] gate_selectors_openings_at_z;\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_polys_openings_at_z;\n        PairingsBn254.Fr copy_permutation_grand_product_opening_at_z_omega;\n        PairingsBn254.Fr quotient_poly_opening_at_z;\n        PairingsBn254.Fr linearization_poly_opening_at_z;\n        // lookup commitments\n        PairingsBn254.G1Point lookup_s_poly_commitment;\n        PairingsBn254.G1Point lookup_grand_product_commitment;\n        // lookup openings\n        PairingsBn254.Fr lookup_s_poly_opening_at_z_omega;\n        PairingsBn254.Fr lookup_grand_product_opening_at_z_omega;\n        PairingsBn254.Fr lookup_t_poly_opening_at_z;\n        PairingsBn254.Fr lookup_t_poly_opening_at_z_omega;\n        PairingsBn254.Fr lookup_selector_poly_opening_at_z;\n        PairingsBn254.Fr lookup_table_type_poly_opening_at_z;\n        PairingsBn254.G1Point opening_proof_at_z;\n        PairingsBn254.G1Point opening_proof_at_z_omega;\n    }\n\n    struct PartialVerifierState {\n        PairingsBn254.Fr zero;\n        PairingsBn254.Fr alpha;\n        PairingsBn254.Fr beta;\n        PairingsBn254.Fr gamma;\n        PairingsBn254.Fr[9] alpha_values;\n        PairingsBn254.Fr eta;\n        PairingsBn254.Fr beta_lookup;\n        PairingsBn254.Fr gamma_lookup;\n        PairingsBn254.Fr beta_plus_one;\n        PairingsBn254.Fr beta_gamma;\n        PairingsBn254.Fr v;\n        PairingsBn254.Fr u;\n        PairingsBn254.Fr z;\n        PairingsBn254.Fr z_omega;\n        PairingsBn254.Fr z_minus_last_omega;\n        PairingsBn254.Fr l_0_at_z;\n        PairingsBn254.Fr l_n_minus_one_at_z;\n        PairingsBn254.Fr t;\n        PairingsBn254.G1Point tp;\n    }\n\n    function evaluate_l0_at_point(uint256 domain_size, PairingsBn254.Fr memory at)\n        internal\n        view\n        returns (PairingsBn254.Fr memory num)\n    {\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n\n        PairingsBn254.Fr memory size_fe = PairingsBn254.new_fr(domain_size);\n        PairingsBn254.Fr memory den = at.copy();\n        den.sub_assign(one);\n        den.mul_assign(size_fe);\n\n        den = den.inverse();\n\n        num = at.pow(domain_size);\n        num.sub_assign(one);\n        num.mul_assign(den);\n    }\n\n    function evaluate_lagrange_poly_out_of_domain(\n        uint256 poly_num,\n        uint256 domain_size,\n        PairingsBn254.Fr memory omega,\n        PairingsBn254.Fr memory at\n    ) internal view returns (PairingsBn254.Fr memory res) {\n        // (omega^i / N) / (X - omega^i) * (X^N - 1)\n        require(poly_num < domain_size);\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\n        res = at.pow(domain_size);\n        res.sub_assign(one);\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\n        res.mul_assign(omega_power);\n\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\n        den.sub_assign(omega_power);\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\n\n        den = den.inverse();\n\n        res.mul_assign(den);\n    }\n\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\n        internal\n        view\n        returns (PairingsBn254.Fr memory res)\n    {\n        res = at.pow(domain_size);\n        res.sub_assign(PairingsBn254.new_fr(1));\n    }\n\n    function initialize_transcript(Proof memory proof, VerificationKey memory vk)\n        internal\n        pure\n        returns (PartialVerifierState memory state)\n    {\n        TranscriptLib.Transcript memory transcript = TranscriptLib.new_transcript();\n\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\n            transcript.update_with_u256(proof.input_values[i]);\n        }\n\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\n            transcript.update_with_g1(proof.state_polys_commitments[i]);\n        }\n\n        state.eta = transcript.get_challenge();\n        transcript.update_with_g1(proof.lookup_s_poly_commitment);\n\n        state.beta = transcript.get_challenge();\n        state.gamma = transcript.get_challenge();\n\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\n        state.beta_lookup = transcript.get_challenge();\n        state.gamma_lookup = transcript.get_challenge();\n        transcript.update_with_g1(proof.lookup_grand_product_commitment);\n        state.alpha = transcript.get_challenge();\n\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\n            transcript.update_with_g1(proof.quotient_poly_parts_commitments[i]);\n        }\n        state.z = transcript.get_challenge();\n\n        transcript.update_with_fr(proof.quotient_poly_opening_at_z);\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.state_polys_openings_at_z[i]);\n        }\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.state_polys_openings_at_z_omega[i]);\n        }\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.gate_selectors_openings_at_z[i]);\n        }\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.copy_permutation_polys_openings_at_z[i]);\n        }\n\n        state.z_omega = state.z.copy();\n        state.z_omega.mul_assign(vk.omega);\n\n        transcript.update_with_fr(proof.copy_permutation_grand_product_opening_at_z_omega);\n\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_selector_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_table_type_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_s_poly_opening_at_z_omega);\n        transcript.update_with_fr(proof.lookup_grand_product_opening_at_z_omega);\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z_omega);\n        transcript.update_with_fr(proof.linearization_poly_opening_at_z);\n\n        state.v = transcript.get_challenge();\n\n        transcript.update_with_g1(proof.opening_proof_at_z);\n        transcript.update_with_g1(proof.opening_proof_at_z_omega);\n\n        state.u = transcript.get_challenge();\n    }\n\n    // compute some powers of challenge alpha([alpha^1, .. alpha^8])\n    function compute_powers_of_alpha(PartialVerifierState memory state) public pure {\n        require(state.alpha.value != 0);\n        state.alpha_values[0] = PairingsBn254.new_fr(1);\n        state.alpha_values[1] = state.alpha.copy();\n        PairingsBn254.Fr memory current_alpha = state.alpha.copy();\n        for (uint256 i = 2; i < state.alpha_values.length; i = i.uncheckedInc()) {\n            current_alpha.mul_assign(state.alpha);\n            state.alpha_values[i] = current_alpha.copy();\n        }\n    }\n\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\n        // we initialize all challenges beforehand, we can draw each challenge in its own place\n        PartialVerifierState memory state = initialize_transcript(proof, vk);\n        if (verify_quotient_evaluation(vk, proof, state) == false) {\n            return false;\n        }\n        require(proof.state_polys_openings_at_z_omega.length == 1); // TODO\n\n        PairingsBn254.G1Point memory quotient_result = proof.quotient_poly_parts_commitments[0].copy_g1();\n        {\n            // block scope\n            PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\n            PairingsBn254.Fr memory current_z = z_in_domain_size.copy();\n            PairingsBn254.G1Point memory tp;\n            // start from i =1\n            for (uint256 i = 1; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\n                tp = proof.quotient_poly_parts_commitments[i].copy_g1();\n                tp.point_mul_assign(current_z);\n                quotient_result.point_add_assign(tp);\n\n                current_z.mul_assign(z_in_domain_size);\n            }\n        }\n\n        Queries memory queries = prepare_queries(vk, proof, state);\n        queries.commitments_at_z[0] = quotient_result;\n        queries.values_at_z[0] = proof.quotient_poly_opening_at_z;\n        queries.commitments_at_z[1] = aggregated_linearization_commitment(vk, proof, state);\n        queries.values_at_z[1] = proof.linearization_poly_opening_at_z;\n\n        require(queries.commitments_at_z.length == queries.values_at_z.length);\n\n        PairingsBn254.G1Point memory aggregated_commitment_at_z = queries.commitments_at_z[0];\n\n        PairingsBn254.Fr memory aggregated_opening_at_z = queries.values_at_z[0];\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\n        PairingsBn254.G1Point memory scaled;\n        for (uint256 i = 1; i < queries.commitments_at_z.length; i = i.uncheckedInc()) {\n            aggregation_challenge.mul_assign(state.v);\n            scaled = queries.commitments_at_z[i].point_mul(aggregation_challenge);\n            aggregated_commitment_at_z.point_add_assign(scaled);\n\n            state.t = queries.values_at_z[i];\n            state.t.mul_assign(aggregation_challenge);\n            aggregated_opening_at_z.add_assign(state.t);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega = queries.commitments_at_z_omega[0].point_mul(\n            aggregation_challenge\n        );\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega = queries.values_at_z_omega[0];\n        aggregated_opening_at_z_omega.mul_assign(aggregation_challenge);\n        for (uint256 i = 1; i < queries.commitments_at_z_omega.length; i = i.uncheckedInc()) {\n            aggregation_challenge.mul_assign(state.v);\n\n            scaled = queries.commitments_at_z_omega[i].point_mul(aggregation_challenge);\n            aggregated_commitment_at_z_omega.point_add_assign(scaled);\n\n            state.t = queries.values_at_z_omega[i];\n            state.t.mul_assign(aggregation_challenge);\n            aggregated_opening_at_z_omega.add_assign(state.t);\n        }\n\n        return\n            final_pairing(\n                vk.g2_elements,\n                proof,\n                state,\n                aggregated_commitment_at_z,\n                aggregated_commitment_at_z_omega,\n                aggregated_opening_at_z,\n                aggregated_opening_at_z_omega\n            );\n    }\n\n    function verify_quotient_evaluation(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (bool) {\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i = i.uncheckedInc()) {\n            lagrange_poly_numbers[i] = i;\n        }\n        // require(vk.num_inputs > 0); // TODO\n\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\n            // TODO we may use batched lagrange compputation\n            state.t = evaluate_lagrange_poly_out_of_domain(i, vk.domain_size, vk.omega, state.z);\n            state.t.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\n            inputs_term.add_assign(state.t);\n        }\n        inputs_term.mul_assign(proof.gate_selectors_openings_at_z[0]);\n        PairingsBn254.Fr memory result = proof.linearization_poly_opening_at_z.copy();\n        result.add_assign(inputs_term);\n\n        // compute powers of alpha\n        compute_powers_of_alpha(state);\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\n\n        // - alpha_0 * (a + perm(z) * beta + gamma)*()*(d + gamma) * z(z*omega)\n        require(proof.copy_permutation_polys_openings_at_z.length == STATE_WIDTH - 1);\n        PairingsBn254.Fr memory t; // TMP;\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\n            t.mul_assign(state.beta);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n            t.add_assign(state.gamma);\n\n            factor.mul_assign(t);\n        }\n\n        t = proof.state_polys_openings_at_z[3].copy();\n        t.add_assign(state.gamma);\n        factor.mul_assign(t);\n        result.sub_assign(factor);\n\n        // - L_0(z) * alpha_1\n        PairingsBn254.Fr memory l_0_at_z = evaluate_l0_at_point(vk.domain_size, state.z);\n        l_0_at_z.mul_assign(state.alpha_values[4 + 1]);\n        result.sub_assign(l_0_at_z);\n\n        PairingsBn254.Fr memory lookup_quotient_contrib = lookup_quotient_contribution(vk, proof, state);\n        result.add_assign(lookup_quotient_contrib);\n\n        PairingsBn254.Fr memory lhs = proof.quotient_poly_opening_at_z.copy();\n        lhs.mul_assign(evaluate_vanishing(vk.domain_size, state.z));\n        return lhs.value == result.value;\n    }\n\n    function lookup_quotient_contribution(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (PairingsBn254.Fr memory result) {\n        PairingsBn254.Fr memory t;\n\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        state.beta_plus_one = state.beta_lookup.copy();\n        state.beta_plus_one.add_assign(one);\n        state.beta_gamma = state.beta_plus_one.copy();\n        state.beta_gamma.mul_assign(state.gamma_lookup);\n\n        // (s'*beta + gamma)*(zw')*alpha\n        t = proof.lookup_s_poly_opening_at_z_omega.copy();\n        t.mul_assign(state.beta_lookup);\n        t.add_assign(state.beta_gamma);\n        t.mul_assign(proof.lookup_grand_product_opening_at_z_omega);\n        t.mul_assign(state.alpha_values[6]);\n\n        // (z - omega^{n-1}) for this part\n        PairingsBn254.Fr memory last_omega = vk.omega.pow(vk.domain_size - 1);\n        state.z_minus_last_omega = state.z.copy();\n        state.z_minus_last_omega.sub_assign(last_omega);\n        t.mul_assign(state.z_minus_last_omega);\n        result.add_assign(t);\n\n        // - alpha_1 * L_{0}(z)\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\n        t = state.l_0_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 1]);\n        result.sub_assign(t);\n\n        // - alpha_2 * beta_gamma_powered L_{n-1}(z)\n        PairingsBn254.Fr memory beta_gamma_powered = state.beta_gamma.pow(vk.domain_size - 1);\n        state.l_n_minus_one_at_z = evaluate_lagrange_poly_out_of_domain(\n            vk.domain_size - 1,\n            vk.domain_size,\n            vk.omega,\n            state.z\n        );\n        t = state.l_n_minus_one_at_z.copy();\n        t.mul_assign(beta_gamma_powered);\n        t.mul_assign(state.alpha_values[6 + 2]);\n\n        result.sub_assign(t);\n    }\n\n    function aggregated_linearization_commitment(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (PairingsBn254.G1Point memory result) {\n        // qMain*(Q_a * A + Q_b * B + Q_c * C + Q_d * D + Q_m * A*B + Q_const + Q_dNext * D_next)\n        result = PairingsBn254.new_g1(0, 0);\n        // Q_a * A\n        PairingsBn254.G1Point memory scaled = vk.gate_setup_commitments[0].point_mul(\n            proof.state_polys_openings_at_z[0]\n        );\n        result.point_add_assign(scaled);\n        // Q_b * B\n        scaled = vk.gate_setup_commitments[1].point_mul(proof.state_polys_openings_at_z[1]);\n        result.point_add_assign(scaled);\n        // Q_c * C\n        scaled = vk.gate_setup_commitments[2].point_mul(proof.state_polys_openings_at_z[2]);\n        result.point_add_assign(scaled);\n        // Q_d * D\n        scaled = vk.gate_setup_commitments[3].point_mul(proof.state_polys_openings_at_z[3]);\n        result.point_add_assign(scaled);\n        // Q_m* A*B or Q_ab*A*B\n        PairingsBn254.Fr memory t = proof.state_polys_openings_at_z[0].copy();\n        t.mul_assign(proof.state_polys_openings_at_z[1]);\n        scaled = vk.gate_setup_commitments[4].point_mul(t);\n        result.point_add_assign(scaled);\n        // Q_AC* A*C\n        t = proof.state_polys_openings_at_z[0].copy();\n        t.mul_assign(proof.state_polys_openings_at_z[2]);\n        scaled = vk.gate_setup_commitments[5].point_mul(t);\n        result.point_add_assign(scaled);\n        // Q_const\n        result.point_add_assign(vk.gate_setup_commitments[6]);\n        // Q_dNext * D_next\n        scaled = vk.gate_setup_commitments[7].point_mul(proof.state_polys_openings_at_z_omega[0]);\n        result.point_add_assign(scaled);\n        result.point_mul_assign(proof.gate_selectors_openings_at_z[0]);\n\n        PairingsBn254.G1Point\n            memory rescue_custom_gate_linearization_contrib = rescue_custom_gate_linearization_contribution(\n                vk,\n                proof,\n                state\n            );\n        result.point_add_assign(rescue_custom_gate_linearization_contrib);\n        require(vk.non_residues.length == STATE_WIDTH - 1);\n\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; ) {\n            t = state.z.copy();\n            if (i == 0) {\n                t.mul_assign(one);\n            } else {\n                t.mul_assign(vk.non_residues[i - 1]); // TODO add one into non-residues during codegen?\n            }\n            t.mul_assign(state.beta);\n            t.add_assign(state.gamma);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n\n            factor.mul_assign(t);\n            unchecked {\n                ++i;\n            }\n        }\n\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\n        factor = state.alpha_values[4].copy();\n        factor.mul_assign(state.beta);\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\n            t.mul_assign(state.beta);\n            t.add_assign(state.gamma);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n\n            factor.mul_assign(t);\n        }\n        scaled = vk.permutation_commitments[3].point_mul(factor);\n        result.point_sub_assign(scaled);\n\n        // + L_0(z) * Z(x)\n        // TODO\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\n        require(state.l_0_at_z.value != 0);\n        factor = state.l_0_at_z.copy();\n        factor.mul_assign(state.alpha_values[4 + 1]);\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        PairingsBn254.G1Point memory lookup_linearization_contrib = lookup_linearization_contribution(proof, state);\n        result.point_add_assign(lookup_linearization_contrib);\n    }\n\n    function rescue_custom_gate_linearization_contribution(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) public view returns (PairingsBn254.G1Point memory result) {\n        PairingsBn254.Fr memory t;\n        PairingsBn254.Fr memory intermediate_result;\n\n        // a^2 - b = 0\n        t = proof.state_polys_openings_at_z[0].copy();\n        t.mul_assign(t);\n        t.sub_assign(proof.state_polys_openings_at_z[1]);\n        // t.mul_assign(challenge1);\n        t.mul_assign(state.alpha_values[1]);\n        intermediate_result.add_assign(t);\n\n        // b^2 - c = 0\n        t = proof.state_polys_openings_at_z[1].copy();\n        t.mul_assign(t);\n        t.sub_assign(proof.state_polys_openings_at_z[2]);\n        t.mul_assign(state.alpha_values[1 + 1]);\n        intermediate_result.add_assign(t);\n\n        // c*a - d = 0;\n        t = proof.state_polys_openings_at_z[2].copy();\n        t.mul_assign(proof.state_polys_openings_at_z[0]);\n        t.sub_assign(proof.state_polys_openings_at_z[3]);\n        t.mul_assign(state.alpha_values[1 + 2]);\n        intermediate_result.add_assign(t);\n\n        result = vk.gate_selectors_commitments[1].point_mul(intermediate_result);\n    }\n\n    function lookup_linearization_contribution(Proof memory proof, PartialVerifierState memory state)\n        internal\n        view\n        returns (PairingsBn254.G1Point memory result)\n    {\n        PairingsBn254.Fr memory zero = PairingsBn254.new_fr(0);\n\n        PairingsBn254.Fr memory t;\n        PairingsBn254.Fr memory factor;\n        // s(x) from the Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega)))\n        factor = proof.lookup_grand_product_opening_at_z_omega.copy();\n        factor.mul_assign(state.alpha_values[6]);\n        factor.mul_assign(state.z_minus_last_omega);\n\n        PairingsBn254.G1Point memory scaled = proof.lookup_s_poly_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        // Z(x) from - alpha_0 * Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega))\n        // + alpha_1 * Z(x) * L_{0}(z) + alpha_2 * Z(x) * L_{n-1}(z)\n\n        // accumulate coefficient\n        factor = proof.lookup_t_poly_opening_at_z_omega.copy();\n        factor.mul_assign(state.beta_lookup);\n        factor.add_assign(proof.lookup_t_poly_opening_at_z);\n        factor.add_assign(state.beta_gamma);\n\n        // (\\gamma + f(x))\n        PairingsBn254.Fr memory f_reconstructed;\n        PairingsBn254.Fr memory current = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory tmp0;\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            tmp0 = proof.state_polys_openings_at_z[i].copy();\n            tmp0.mul_assign(current);\n            f_reconstructed.add_assign(tmp0);\n\n            current.mul_assign(state.eta);\n        }\n\n        // add type of table\n        t = proof.lookup_table_type_poly_opening_at_z.copy();\n        t.mul_assign(current);\n        f_reconstructed.add_assign(t);\n\n        f_reconstructed.mul_assign(proof.lookup_selector_poly_opening_at_z);\n        f_reconstructed.add_assign(state.gamma_lookup);\n\n        // end of (\\gamma + f(x)) part\n        factor.mul_assign(f_reconstructed);\n        factor.mul_assign(state.beta_plus_one);\n        t = zero.copy();\n        t.sub_assign(factor);\n        factor = t;\n        factor.mul_assign(state.alpha_values[6]);\n\n        // Multiply by (z - omega^{n-1})\n        factor.mul_assign(state.z_minus_last_omega);\n\n        // L_{0}(z) in front of Z(x)\n        t = state.l_0_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 1]);\n        factor.add_assign(t);\n\n        // L_{n-1}(z) in front of Z(x)\n        t = state.l_n_minus_one_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 2]);\n        factor.add_assign(t);\n\n        scaled = proof.lookup_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n    }\n\n    struct Queries {\n        PairingsBn254.G1Point[13] commitments_at_z;\n        PairingsBn254.Fr[13] values_at_z;\n        PairingsBn254.G1Point[6] commitments_at_z_omega;\n        PairingsBn254.Fr[6] values_at_z_omega;\n    }\n\n    function prepare_queries(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) public view returns (Queries memory queries) {\n        // we set first two items in calee side so start idx from 2\n        uint256 idx = 2;\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\n            queries.commitments_at_z[idx] = proof.state_polys_commitments[i];\n            queries.values_at_z[idx] = proof.state_polys_openings_at_z[i];\n            idx = idx.uncheckedInc();\n        }\n        require(proof.gate_selectors_openings_at_z.length == 1);\n        queries.commitments_at_z[idx] = vk.gate_selectors_commitments[0];\n        queries.values_at_z[idx] = proof.gate_selectors_openings_at_z[0];\n        idx = idx.uncheckedInc();\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            queries.commitments_at_z[idx] = vk.permutation_commitments[i];\n            queries.values_at_z[idx] = proof.copy_permutation_polys_openings_at_z[i];\n            idx = idx.uncheckedInc();\n        }\n\n        queries.commitments_at_z_omega[0] = proof.copy_permutation_grand_product_commitment;\n        queries.commitments_at_z_omega[1] = proof.state_polys_commitments[STATE_WIDTH - 1];\n\n        queries.values_at_z_omega[0] = proof.copy_permutation_grand_product_opening_at_z_omega;\n        queries.values_at_z_omega[1] = proof.state_polys_openings_at_z_omega[0];\n\n        PairingsBn254.G1Point memory lookup_t_poly_commitment_aggregated = vk.lookup_tables_commitments[0];\n        PairingsBn254.Fr memory current_eta = state.eta.copy();\n        for (uint256 i = 1; i < vk.lookup_tables_commitments.length; i = i.uncheckedInc()) {\n            state.tp = vk.lookup_tables_commitments[i].point_mul(current_eta);\n            lookup_t_poly_commitment_aggregated.point_add_assign(state.tp);\n\n            current_eta.mul_assign(state.eta);\n        }\n        queries.commitments_at_z[idx] = lookup_t_poly_commitment_aggregated;\n        queries.values_at_z[idx] = proof.lookup_t_poly_opening_at_z;\n        idx = idx.uncheckedInc();\n        queries.commitments_at_z[idx] = vk.lookup_selector_commitment;\n        queries.values_at_z[idx] = proof.lookup_selector_poly_opening_at_z;\n        idx = idx.uncheckedInc();\n        queries.commitments_at_z[idx] = vk.lookup_table_type_commitment;\n        queries.values_at_z[idx] = proof.lookup_table_type_poly_opening_at_z;\n        queries.commitments_at_z_omega[2] = proof.lookup_s_poly_commitment;\n        queries.values_at_z_omega[2] = proof.lookup_s_poly_opening_at_z_omega;\n        queries.commitments_at_z_omega[3] = proof.lookup_grand_product_commitment;\n        queries.values_at_z_omega[3] = proof.lookup_grand_product_opening_at_z_omega;\n        queries.commitments_at_z_omega[4] = lookup_t_poly_commitment_aggregated;\n        queries.values_at_z_omega[4] = proof.lookup_t_poly_opening_at_z_omega;\n    }\n\n    function final_pairing(\n        // VerificationKey memory vk,\n        PairingsBn254.G2Point[NUM_G2_ELS] memory g2_elements,\n        Proof memory proof,\n        PartialVerifierState memory state,\n        PairingsBn254.G1Point memory aggregated_commitment_at_z,\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega,\n        PairingsBn254.Fr memory aggregated_opening_at_z,\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega\n    ) internal view returns (bool) {\n        // q(x) = f(x) - f(z) / (x - z)\n        // q(x) * (x-z)  = f(x) - f(z)\n\n        // f(x)\n        PairingsBn254.G1Point memory pair_with_generator = aggregated_commitment_at_z.copy_g1();\n        aggregated_commitment_at_z_omega.point_mul_assign(state.u);\n        pair_with_generator.point_add_assign(aggregated_commitment_at_z_omega);\n\n        // - f(z)*g\n        PairingsBn254.Fr memory aggregated_value = aggregated_opening_at_z_omega.copy();\n        aggregated_value.mul_assign(state.u);\n        aggregated_value.add_assign(aggregated_opening_at_z);\n        PairingsBn254.G1Point memory tp = PairingsBn254.P1().point_mul(aggregated_value);\n        pair_with_generator.point_sub_assign(tp);\n\n        // +z * q(x)\n        tp = proof.opening_proof_at_z.point_mul(state.z);\n        PairingsBn254.Fr memory t = state.z_omega.copy();\n        t.mul_assign(state.u);\n        PairingsBn254.G1Point memory t1 = proof.opening_proof_at_z_omega.point_mul(t);\n        tp.point_add_assign(t1);\n        pair_with_generator.point_add_assign(tp);\n\n        // rhs\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_proof_at_z_omega.point_mul(state.u);\n        pair_with_x.point_add_assign(proof.opening_proof_at_z);\n        pair_with_x.negate();\n        // Pairing precompile expects points to be in a `i*x[1] + x[0]` form instead of `x[0] + i*x[1]`\n        // so we handle it in code generation step\n        PairingsBn254.G2Point memory first_g2 = g2_elements[0];\n        PairingsBn254.G2Point memory second_g2 = g2_elements[1];\n        PairingsBn254.G2Point memory gen2 = PairingsBn254.P2();\n\n        return PairingsBn254.pairingProd2(pair_with_generator, first_g2, pair_with_x, second_g2);\n    }\n}\n\n\n",
        "CodeNames": [
            "Plonk4VerifierWithAccessToDNext.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-05",
                "Location": [
                    "javascript\npragma //solidity 0.8.15;\n\ncontract TesterA {\nfunction testInit() public view returns (uint) { uint a = 0; return a; }\n}\n\ncontract TesterB {\nfunction testNoInit() public view returns (uint) { uint a; return a; }\n}\n"
                ],
                "Type": " There's no need to set default values for variables",
                "Description": "\nIf a variable is not set/initialized, the default value is assumed (0, false, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.\n\nProof of concept (*without optimizations*):\n\njavascript\npragma solidity 0.8.15;\n\ncontract TesterA {\nfunction testInit() public view returns (uint) { uint a = 0; return a; }\n}\n\ncontract TesterB {\nfunction testNoInit() public view returns (uint) { uint a; return a; }\n}\n\n\nGas saving executing: 8 per entry\n\n    TesterA.testInit:   21392\n    TesterB.testNoInit: 21384\n\nAffected source code:\n\n*   L1EthBridge.sol:33(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/bridge/L1EthBridge.sol#L33)\n*   L2ETHBridge.sol:28(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ETHBridge.sol#L28)\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMailbox.sol\";\nimport \"../libraries/Merkle.sol\";\nimport \"../libraries/PriorityQueue.sol\";\nimport \"../Storage.sol\";\nimport \"../Config.sol\";\nimport \"../../common/libraries/UncheckedMath.sol\";\nimport \"../../common/L2ContractHelper.sol\";\nimport \"./Base.sol\";\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 block number\n    /// @param _blockNumber The executed L2 block number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 block where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 block\n    /// @param _blockNumber The executed L2 block number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    function proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _log, _proof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 block number\n    function _proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_blockNumber <= s.totalBlocksExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBlock, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n        // Check that the proof length is exactly the same as tree height, to prevent\n        // any shorter/longer paths attack on the Merkle path validation\n        require(_proof.length == L2_TO_L1_LOG_MERKLE_TREE_HEIGHT, \"rz\");\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_blockNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message calldata _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBlock: _message.txNumberInBlock,\n                sender: L2_TO_L1_MESSENGER,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @return The estimated ergs\n    function l2TransactionBaseCost(\n        uint256, // _gasPrice\n        uint256, // _ergsLimit\n        uint32 // _calldataLength\n    ) public pure returns (uint256) {\n        // TODO: estimate gas for L1 execute\n        return 0;\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2Transaction(msg.sender, _contractL2, _l2Value, _calldata, _ergsLimit, _factoryDeps);\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_ergsLimit <= PRIORITY_TX_MAX_ERGS_LIMIT, \"ui\");\n        uint64 expirationBlock = uint64(block.number + PRIORITY_EXPIRATION);\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n        // TODO: Restore after stable priority op fee modeling. (SMA-1230)\n        // uint256 baseCost = l2TransactionBaseCost(tx.gasprice, _ergsLimit, uint32(_calldata.length));\n        // uint256 layer2Tip = msg.value - baseCost;\n\n        canonicalTxHash = _writePriorityOp(\n            _sender,\n            txId,\n            _l2Value,\n            _contractL2,\n            _calldata,\n            expirationBlock,\n            _ergsLimit,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        address _sender,\n        uint256 _txId,\n        uint256 _l2Value,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint64 _expirationBlock,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = serializeL2Transaction(\n            _txId,\n            _l2Value,\n            _sender,\n            _contractAddressL2,\n            _calldata,\n            _ergsLimit,\n            _factoryDeps\n        );\n        canonicalTxHash = keccak256(abi.encode(transaction));\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationBlock: _expirationBlock,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that needed for operator to simulate priority queue offchain\n        emit NewPriorityRequest(_txId, canonicalTxHash, _expirationBlock, transaction, _factoryDeps);\n    }\n\n    /// @dev Accepts the parameters of the l2 transaction and converts it to the canonical form.\n    /// @param _txId Priority operation ID, used as a unique identifier so that transactions always have a different hash\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _sender The L2 address of the account that initiates the transaction\n    /// @param _contractAddressL2 The L2 receiver address\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return The canonical form of the l2 transaction parameters\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n                reserved: [uint256(_txId), _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] calldata _factoryDeps)\n        internal\n        pure\n        returns (uint256[] memory hashedFactoryDeps)\n    {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Mailbox.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-06",
                "Location": [
                    "diff\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n              reserved: uint256(_txId), _l2Value, 0, 0, 0, 0],\n+               reserved: _txId, _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n"
                ],
                "Type": " Unnecessary cast in  Mailbox.serializeL2Transaction ",
                "Description": "\nIt's possible to remove the following casts:\n\ndiff\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n              reserved: uint256(_txId), _l2Value, 0, 0, 0, 0],\n+               reserved: _txId, _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n\n\nAffected source code:\n\n*   Mailbox.sol:206(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/Mailbox.sol#L206)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./Verifier.sol\";\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./libraries/PriorityQueue.sol\";\n\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy upgrades and diamond cuts\n/// @param proposedDiamondCutHash The hash of diamond cut that was proposed in the current upgrade\n/// @param proposedDiamondCutTimestamp The timestamp when the diamond cut was proposed, zero if there are no active proposals\n/// @param lastDiamondFreezeTimestamp The timestamp when the diamond was frozen last time, zero if the diamond was never frozen\n/// @param currentProposalId The serial number of proposed diamond cuts, increments when proposing a new diamond cut\n/// @param securityCouncilMembers The set of the trusted\u00a0addresses that can instantly finish upgrade (diamond cut)\n/// @param securityCouncilMemberLastApprovedProposalId The mapping of the security council addresses and the last diamond cut that they approved\n/// @param securityCouncilEmergencyApprovals The number of received upgrade approvals from the security council\nstruct DiamondCutStorage {\n    bytes32 proposedDiamondCutHash;\n    uint256 proposedDiamondCutTimestamp;\n    uint256 lastDiamondFreezeTimestamp;\n    uint256 currentProposalId;\n    mapping(address => bool) securityCouncilMembers;\n    mapping(address => uint256) securityCouncilMemberLastApprovedProposalId;\n    uint256 securityCouncilEmergencyApprovals;\n}\n\n/// @dev The log passed from L2\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter. All other values are not used but are reserved for the future\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\n/// This field is required formally but does not have any special meaning.\n/// @param txNumberInBlock The L2 transaction number in a block, in which the log was sent\n/// @param sender The L2 address which sent the log. \n/// @param key The 32 bytes of information that was sent in the log\n/// @param value The 32 bytes of information that was sent in the log\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\n/// @dev The sender is an `address` type, although we are using `uint256` for addreses in `L2CanonicalTransaction`.\n/// It is made on purpose to make circuits easier, but changing the format of L2 -> L1 log format would be a non-breaking \n/// change for users and devs so it is fine.\nstruct L2Log {\n    uint8 l2ShardId;\n    bool isService;\n    uint16 txNumberInBlock;\n    address sender;\n    bytes32 key;\n    bytes32 value;\n}\n\n/// @dev An arbitrary length message passed from L2\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\n/// @param txNumberInBlock The L2 transaction number in a block, in which the message was sent\n/// @param sender The address of the L2 account from which the message was passed\n/// @param data An arbitrary length message\nstruct L2Message {\n    uint16 txNumberInBlock;\n    address sender;\n    bytes data;\n}\n\n/// @notice Part of the configuration parameters of ZKP circuits\nstruct VerifierParams {\n    bytes32 recursionNodeLevelVkHash;\n    bytes32 recursionLeafLevelVkHash;\n    bytes32 recursionCircuitsSetVksHash;\n}\n\n/// @dev storing all storage variables for zkSync facets\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\n/// NOTE: but NOT to modify already existing variables or change their order\nstruct AppStorage {\n    /// @dev Storage of variables needed for diamond cut facet\n    DiamondCutStorage diamondCutStorage;\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\n    address governor;\n    /// @notice Address that governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address => bool) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\n    Verifier verifier;\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint256 totalBlocksExecuted;\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\n    uint256 totalBlocksVerified;\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint256 totalBlocksCommitted;\n    /// @dev Stored hashed StoredBlock for block number\n    mapping(uint256 => bytes32) storedBlockHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 => bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n    bool zkPorterIsAvailable;\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./interfaces/IExecutor.sol\";\nimport \"./libraries/Diamond.sol\";\nimport \"./facets/Base.sol\";\nimport \"./Config.sol\";\n\n/// @author Matter Labs\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is Base {\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice zkSync contract initialization\n    /// @param _verifier address of Verifier contract\n    /// @param _governor address who can manage the contract\n    /// @param _validator address who can make blocks\n    /// @param _genesisBlockHash Block hash of the genesis (initial) block\n    /// @param _genesisIndexRepeatedStorageChanges The serial number of the shortcut storage key for genesis block\n    /// @param _genesisBlockCommitment The zk-proof commitment for the genesis block\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy initializer\n    function initialize(\n        Verifier _verifier,\n        address _governor,\n        address _validator,\n        bytes32 _genesisBlockHash,\n        uint64 _genesisIndexRepeatedStorageChanges,\n        bytes32 _genesisBlockCommitment,\n        IAllowList _allowList,\n        VerifierParams calldata _verifierParams,\n        bool _zkPorterIsAvailable,\n        bytes32 _l2BootloaderBytecodeHash,\n        bytes32 _l2DefaultAccountBytecodeHash\n    ) external reentrancyGuardInitializer returns (bytes32) {\n        s.verifier = _verifier;\n        s.governor = _governor;\n        s.validators[_validator] = true;\n\n        // We need to initialize the state hash because it is used in the commitment of the next block\n        IExecutor.StoredBlockInfo memory storedBlockZero = IExecutor.StoredBlockInfo(\n            0,\n            _genesisBlockHash,\n            _genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _genesisBlockCommitment\n        );\n\n        s.storedBlockHashes[0] = keccak256(abi.encode(storedBlockZero));\n        s.allowList = _allowList;\n        s.verifierParams = _verifierParams;\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}\n\n\n",
        "CodeNames": [
            "Storage.sol",
            "DiamondInit.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-08",
                "Location": [
                    "diff\n    struct StoredBlockInfo {\n        uint64 blockNumber;\n+       uint64 indexRepeatedStorageChanges;\n        bytes32 blockHash;\n      uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n",
                    "diff\nstruct AppStorage {\n    /// @dev Storage of variables needed for diamond cut facet\n    DiamondCutStorage diamondCutStorage;\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\n    address governor;\n+   bool zkPorterIsAvailable;\n    /// @notice Address that governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address = bool) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\n    Verifier verifier;\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint256 totalBlocksExecuted;\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\n    uint256 totalBlocksVerified;\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint256 totalBlocksCommitted;\n    /// @dev Stored hashed StoredBlock for block number\n    mapping(uint256 = bytes32) storedBlockHashes;\n    /// @dev Stored root hashes of L2 - L1 logs\n    mapping(uint256 = bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n  bool zkPorterIsAvailable;\n}\n"
                ],
                "Type": " Reorder structure layout",
                "Description": "\nThe following structs could be optimized moving the position of certains values in order to save slot storages:\n\nStoredBlockInfo in IExecutor.sol#L15-L24(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/interfaces/IExecutor.sol#L15-L24)\n\ndiff\n    struct StoredBlockInfo {\n        uint64 blockNumber;\n+       uint64 indexRepeatedStorageChanges;\n        bytes32 blockHash;\n      uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n\nAppStorage in Storage.sol:69-106(https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/Storage.sol#L69-L106)\n\ndiff\nstruct AppStorage {\n    /// @dev Storage of variables needed for diamond cut facet\n    DiamondCutStorage diamondCutStorage;\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\n    address governor;\n+   bool zkPorterIsAvailable;\n    /// @notice Address that governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address = bool) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\n    Verifier verifier;\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint256 totalBlocksExecuted;\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\n    uint256 totalBlocksVerified;\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint256 totalBlocksCommitted;\n    /// @dev Stored hashed StoredBlock for block number\n    mapping(uint256 = bytes32) storedBlockHashes;\n    /// @dev Stored root hashes of L2 - L1 logs\n    mapping(uint256 = bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n  bool zkPorterIsAvailable;\n}\n\n\n\n",
                "Repair": ""
            }
        ]
    }
]