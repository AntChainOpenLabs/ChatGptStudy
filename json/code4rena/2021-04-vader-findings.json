[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}\n\n",
        "CodeNames": [
            "Pools.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "transferFrom",
                    "transferOut()"
                ],
                "Type": " Unhandled return value of transfer in  transferOut()  of Pools.sol",
                "Description": "\nERC20 implementations are not always consistent. Some implementations of transfer\u00a0and transferFrom\u00a0could return \u2018false\u2019 on failure instead of reverting. It is safer to wrap such calls into\u00a0require()\u00a0statements to handle these failures.\n\nThe transfer call on L211(https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L211) of transferOut() could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.\n\nFor reference, see similar finding from Consensys Diligence Audit of AAVE Protocol V2\n\n",
                "Repair": "Recommend requirements to check the return value and revert on\u00a00/false\u00a0or use OpenZeppelin\u2019s SafeERC20 wrapper functions.\n\nstrictly-scarce (vader) disputed(https://github.com/code-423n4/2021-04-vader-findings/issues/128#issuecomment-830602601):\n  Not valid. Since the funds came in, and did not revert, they can leave. If the call passes, then the transferout is valid.\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "curatePool() function",
                    "getBaseAmount()",
                    "newToken",
                    "curatedPoolLimit",
                    "replacePool()",
                    "oldToken"
                ],
                "Type": " Lack of input validation in  replacePool()  allows curated pool limit bypass in  Router.sol ",
                "Description": "\nThere is no input validation in replacePool() function to check if oldToken exists and is curated. Using a non-existing oldToken (even 0 address) passes the check on L236 (because Pools.getBaseAmount() will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function.\n\n",
                "Repair": "Recommend checking if oldToken exists and is curated as part of input validation in replacePool() function.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/87#issuecomment-830613505):\n  Valid\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\ncontract USDV is iERC20 {\n\n    // ERC-20 Parameters\n    string public override name; string public override symbol;\n    uint public override decimals; uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Parameters\n    bool private inited;\n    uint public nextEraTime;\n    uint public blockDelay;\n\n    address public VADER;\n    address public VAULT;\n    address public ROUTER;\n\n    mapping(address => uint) public lastBlock;\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n    // Stop flash attacks\n    modifier flashProof() {\n        require(isMature(), \"No flash\");\n        _;\n    }\n    function isMature() public view returns(bool isMatured){\n        if(lastBlock[tx.origin] + blockDelay <= block.number){ // Stops an EOA doing a flash attack in same block\n            return true;\n        }\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n        name = 'VADER STABLE DOLLAR';\n        symbol = 'USDV';\n        decimals = 18;\n        totalSupply = 0;\n    }\n    function init(address _vader, address _vault, address _router) external {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        VAULT = _vault;\n        ROUTER = _router;\n        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();\n    }\n\n    //========================================iERC20=========================================//\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(sender != address(0), \"sender\");\n            _balances[sender] -= amount;\n            _balances[recipient] += amount;\n            emit Transfer(sender, recipient, amount);\n            _checkIncentives();\n        }\n    }\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(account != address(0), \"recipient\");\n            totalSupply += amount;\n            _balances[account] += amount;\n            emit Transfer(address(0), account, amount);\n        }\n    }\n    // Burn supply\n    function burn(uint amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) external virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender)- amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(account != address(0), \"address err\");\n            _balances[account] -= amount;\n            totalSupply -= amount;\n            emit Transfer(account, address(0), amount);\n        }\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newDelay) external onlyDAO {\n        blockDelay = newDelay;\n    }\n\n   //======================================INCENTIVES========================================//\n    // Internal - Update incentives function\n    function _checkIncentives() private {\n        if (block.timestamp >= nextEraTime && emitting()) {                 // If new Era\n            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _balance = iERC20(VADER).balanceOf(address(this));         // Get spare VADER\n            if(_balance > 4){\n                uint _USDVShare = _balance/2;                                   // Get 50%\n                _convert(address(this), _USDVShare);                            // Convert it\n                if(balanceOf(address(this)) > 2){\n                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              // Send half USDV to ROUTER\n                    _transfer(address(this), VAULT, balanceOf(address(this)));                   // Send rest to VAULT\n                }\n                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   // Send half VADER to ROUTER\n                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      // Send rest to VAULT\n            }\n        }\n    }\n    \n    //======================================ASSET MINTING========================================//\n    // Convert to USDV\n    function convert(uint amount) external returns(uint) {\n        return convertForMember(msg.sender, amount);\n    }\n    // Convert for members\n    function convertForMember(address member, uint amount) public returns(uint) {\n        getFunds(VADER, amount);\n        return _convert(member, amount);\n    }\n    // Internal convert\n    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){\n        if(minting()){\n            lastBlock[tx.origin] = block.number;                    // Record first\n            iERC20(VADER).burn(amount);\n            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); // Critical pricing functionality\n            _mint(_member, _convertAmount);\n        }\n    }\n    // Redeem to VADER\n    function redeem(uint amount) external returns(uint) {\n        return redeemForMember(msg.sender, amount);\n    }\n    // Contracts to redeem for members\n    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {\n        _transfer(msg.sender, VADER, amount);                   // Move funds\n        redeemAmount = iVADER(VADER).redeemToMember(member);    // Ask VADER to redeem\n        lastBlock[tx.origin] = block.number;                    // Must record block AFTER the tx\n    }\n\n    //============================== ASSETS ================================//\n\n    function getFunds(address token, uint amount) internal {\n        if(token == address(this)){\n            _transfer(msg.sender, address(this), amount);\n        } else {\n            if(tx.origin==msg.sender){\n                require(iERC20(token).transferTo(address(this), amount));\n            }else{\n                require(iERC20(token).transferFrom(msg.sender, address(this), amount));\n            }\n        }\n    }\n\n    //============================== HELPERS ================================//\n\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function minting() public view returns(bool){\n        return iVADER(VADER).minting();\n    }\n\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}\n\n",
        "CodeNames": [
            "USDV.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "lastBlock[tx.origin] + blockDelay <= block.number"
                ],
                "Type": " Flash attack mitigation does not work as intended in USDV.sol",
                "Description": "\nOne of the stated protocol (review) goals is to detect susceptibility to \u201cAny attack vectors using flash loans on Anchor price, synths or lending.\u201d As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number\n\nHowever, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to = 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0, which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41(https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142): \"// Stops an EOA from doing a flash attack in the same block\"\n\nEven if the DAO can call setParams() to change blockDelay to = 1, there is a big window of opportunity for flash attacks until the DAO votes, finalizes and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.\n\n",
                "Repair": "Recommend initalizing blockDelay to = 1 at declaration or in constructor.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/138#issuecomment-830606188):\n\n The actual issue is simply:\n\n  blockDelay state variable is not initialized\n\n It is intended to be initialised to 1, so this is a bug. Severity: 2\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\ncontract Vader is iERC20 {\n\n    // ERC-20 Parameters\n    string public override name; string public override symbol;\n    uint public override decimals; uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Parameters\n    bool private inited;\n    bool public emitting;\n    bool public minting;\n    uint _1m;\n    uint public baseline;\n    uint public emissionCurve;\n    uint public maxSupply;\n    uint public secondsPerEra;\n    uint public currentEra;\n    uint public nextEraTime;\n    uint public feeOnTransfer;\n\n    address public VETHER;\n    address public USDV;\n    address public UTILS;\n    address public burnAddress;\n    address public rewardAddress;\n    address public DAO;\n\n    event NewEra(uint currentEra, uint nextEraTime, uint emission);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO, \"Not DAO\");\n        _;\n    }\n    // Stop flash attacks\n    modifier flashProof() {\n        require(isMature(), \"No flash\");\n        _;\n    }\n    function isMature() public view returns(bool){\n        return iUSDV(USDV).isMature();\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n        name = 'VADER PROTOCOL TOKEN';\n        symbol = 'VADER';\n        decimals = 18;\n        _1m = 10**6 * 10 ** decimals; //1m\n        baseline = _1m;\n        totalSupply = 0;\n        maxSupply = 2 * _1m;\n        currentEra = 1;\n        secondsPerEra = 1; //86400;\n        nextEraTime = block.timestamp + secondsPerEra;\n        emissionCurve = 900;\n        DAO = msg.sender;\n        burnAddress = 0x0111011001100001011011000111010101100101;\n    }\n    // Can only be called once\n    function init(address _vether, address _USDV, address _utils) external {\n        require(inited == false);\n        inited = true;\n        VETHER = _vether;\n        USDV = _USDV;\n        UTILS = _utils;\n        rewardAddress = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function balanceOf(address account) external view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        require(sender != address(0), \"sender\");\n        require(recipient != address(this), \"recipient\");\n        _balances[sender] -= amount;\n        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  // Critical functionality\n        if(_fee >= 0 && _fee <= amount){                            // Stops reverts if UTILS corrupted\n            amount -= _fee;\n            _burn(msg.sender, _fee);\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        _checkEmission();\n    }\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint amount) internal virtual {\n        require(account != address(0), \"recipient\");\n        if((totalSupply + amount) >= maxSupply){\n            amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply\n        }\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n    // Burn supply\n    function burn(uint amount) public virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) external virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender) - amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        require(account != address(0), \"address err\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //=========================================DAO=========================================//\n    // Can start\n    function flipEmissions() external onlyDAO {\n        if(emitting){\n            emitting = false;\n        } else {\n            emitting = true;\n        }\n    }\n    // Can stop\n    function flipMinting() external onlyDAO {\n        if(minting){\n            minting = false;\n        } else {\n            minting = true;\n        }\n    }\n    // Can set params\n    function setParams(uint newEra, uint newCurve) external onlyDAO {\n        secondsPerEra = newEra;\n        emissionCurve = newCurve;\n    }\n    // Can set reward address\n    function setRewardAddress(address newAddress) external onlyDAO {\n        rewardAddress = newAddress;\n    }\n    // Can change UTILS\n    function changeUTILS(address newUTILS) external onlyDAO {\n        require(newUTILS != address(0), \"address err\");\n        UTILS = newUTILS;\n    }\n    // Can change DAO\n    function changeDAO(address newDAO) external onlyDAO {\n        require(newDAO != address(0), \"address err\");\n        DAO = newDAO;\n    }\n    // Can purge DAO\n    function purgeDAO() external onlyDAO{\n        DAO = address(0);\n    }\n\n   //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _checkEmission() private {\n        if ((block.timestamp >= nextEraTime) && emitting) {                                // If new Era and allowed to emit\n            currentEra += 1;                                                               // Increment Era\n            nextEraTime = block.timestamp + secondsPerEra;                                 // Set next Era time\n            uint _emission = getDailyEmission();                                           // Get Daily Dmission\n            _mint(rewardAddress, _emission);                                               // Mint to the Rewad Address\n            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        // UpdateFeeOnTransfer\n            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                // Max 10% if UTILS corrupted\n            emit NewEra(currentEra, nextEraTime, _emission);                               // Emit Event\n        }\n    }\n    // Calculate Daily Emission\n    function getDailyEmission() public view returns (uint) {\n        uint _adjustedMax;\n        if(totalSupply <= baseline){ // If less than 1m, then adjust cap down\n            _adjustedMax = (maxSupply * totalSupply) / baseline; // 2m * 0.5m / 1m = 2m * 50% = 1.5m\n        } else {\n            _adjustedMax = maxSupply;  // 2m\n        }\n        return (_adjustedMax - totalSupply) / (emissionCurve); // outstanding / curve \n    }\n\n    //======================================ASSET MINTING========================================//\n    // VETHER Owners to Upgrade\n    function upgrade(uint amount) external {\n        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));\n        _mint(msg.sender, amount);\n    }\n    // Directly redeem back to VADER (must have sent USDV first)\n    function redeem() external returns (uint redeemAmount){\n        return redeemToMember(msg.sender);\n    }\n    // Redeem on behalf of member (must have sent USDV first)\n    function redeemToMember(address member) public flashProof returns (uint redeemAmount){\n        if(minting){\n            uint _amount = iERC20(USDV).balanceOf(address(this)); \n            iERC20(USDV).burn(_amount);\n            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); // Critical pricing functionality\n            _mint(member, redeemAmount);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "Vader.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "changeDAO()"
                ],
                "Type": " Missing DAO functionality to call  changeDAO()  function in Vader.sol",
                "Description": "\nchangeDAO() is authorized to be called only from the DAO (per modifier) but DAO contract has no corresponding functionality to call changeDAO() function. As a result, DAO address cannot be changed ([L192-L196(https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196)).\n\n",
                "Repair": "Recommend adding functionality to DAO to be able to call changeDAO() of Vader.sol.\n\nstrictly-scarce (vader) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/161#issuecomment-830606766):\n #46(https://github.com/code-423n4/2021-04-vader-findings/issues/46)\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/161#issuecomment-847848752):\n  Unlike in issues #140, #157, #158, & #159; without this functionality, missing functionality in the DAO becomes a very serious issue. As a result, this one is very high risk were it to be overlooked.\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [],
                "Type": " Proposals can be cancelled",
                "Description": "Anyone can cancel any proposals by calling DAO.cancelProposal(id, id) with oldProposalID == newProposalID.\nThis always passes the minority check as the proposal was approved.\n\nAn attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.\n\n",
                "Repair": "Recommend checking that oldProposalID == newProposalID\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/227#issuecomment-828455719):\n  This is valid, can fix with a require()\n\n\nstrictly-scarce (vader) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/227#issuecomment-830634810):\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\n\n// Synth Contract\ncontract Synth is iERC20 {\n\n    address public FACTORY;\n    address public TOKEN;\n\n    // Coin Defaults\n    string public override name;\n    string public override symbol;\n    uint public override decimals  = 18;\n    uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    modifier onlyFACTORY() {\n        require(msg.sender == FACTORY, \"!FACTORY\");\n        _;\n    }\n    \n    // Minting event\n    constructor(address _token){\n        TOKEN = _token;\n        FACTORY = msg.sender;\n        string memory synthName = \" - vSynth\";\n        string memory synthSymbol = \".v\";\n        name = string(abi.encodePacked(iERC20(_token).name(), synthName));\n        symbol = string(abi.encodePacked(iERC20(_token).symbol(), synthSymbol));\n    }\n\n    \n    //========================================iERC20=========================================//\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        require(sender != address(0), \"sender\");\n        require(recipient != address(this), \"recipient\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n    // Only FACTORY can mint\n    function mint(address account, uint amount) external virtual onlyFACTORY {\n        require(account != address(0), \"recipient\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n    // Burn supply\n    function burn(uint amount) public virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) public virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender) - amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        require(account != address(0), \"address err\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract Attack {\n    bool private inited;\n    address public VADER;\n    address public USDV;\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    function init(address _vader, address _USDV) public {\n        require(inited == false);\ninited = true;\n        VADER = _vader;\n        USDV = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function attackUSDV(uint amount) public {\n        iERC20(VADER).approve(USDV, amount);\n        iERC20(USDV).approve(USDV, amount);\n        iERC20(VADER).transferTo(address(this), amount); // get VADER funds\n        iUSDV(USDV).convert(amount); // Convert to USDV back to this address\n        iUSDV(USDV).redeem(amount); // Burn USDV back to VADER to this address\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}\n\n",
        "CodeNames": [
            "Synth.sol",
            "Attack.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "transferTo()",
                    "_transfer",
                    "transfer()",
                    "_transfer()",
                    "transferFrom()",
                    "_burn()"
                ],
                "Type": " Incorrect burn address in Vader.sol",
                "Description": "\nThe internal _transfer() function is called from external facing transfer(), transferFrom(), and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo().\n\nThese different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.\n\nThis will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.\n\n",
                "Repair": "Recommend changing L129 to: _burn(sender, _fee);\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/202#issuecomment-830609535):\n  Valid, disagree with severity though. Funds-not-at-risk.\n Recommend: 2\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract Attack {\n    bool private inited;\n    address public VADER;\n    address public USDV;\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    function init(address _vader, address _USDV) public {\n        require(inited == false);\ninited = true;\n        VADER = _vader;\n        USDV = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function attackUSDV(uint amount) public {\n        iERC20(VADER).approve(USDV, amount);\n        iERC20(USDV).approve(USDV, amount);\n        iERC20(VADER).transferTo(address(this), amount); // get VADER funds\n        iUSDV(USDV).convert(amount); // Convert to USDV back to this address\n        iUSDV(USDV).redeem(amount); // Burn USDV back to VADER to this address\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract DAO {\n\n    struct GrantDetails{\n        address recipient;\n        uint amount;\n    }\n\n    bool private inited;\n    uint public proposalCount;\n    address public VADER;\n    address public USDV;\n    address public VAULT;\n    uint public coolOffPeriod;\n\n    mapping(uint => GrantDetails) public mapPID_grant;\n    mapping(uint => address) public mapPID_address;\n\n    mapping(uint => string) public mapPID_type;\n    mapping(uint => uint) public mapPID_votes;\n    mapping(uint => uint) public mapPID_timeStart;\n    mapping(uint => bool) public mapPID_finalising;\n    mapping(uint => bool) public mapPID_finalised;\n    mapping(uint => mapping(address => uint)) public mapPIDMember_votes;\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member,uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed oldProposalID, uint oldVotes, uint newVotes, uint totalWeight);\n    event FinalisedProposal(address indexed member,uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n    }\n    function init(address _vader, address _usdv, address _vault) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        VAULT = _vault;\n        coolOffPeriod = 1;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n    // Action with funding\n    function newGrantProposal(address recipient, uint amount) public {\n        string memory typeStr = \"GRANT\";\n        proposalCount += 1;\n        mapPID_type[proposalCount] = typeStr;\n        GrantDetails memory grant;\n        grant.recipient = recipient;\n        grant.amount = amount;\n        mapPID_grant[proposalCount] = grant;\n        emit NewProposal(msg.sender, proposalCount, typeStr);\n    }\n\n    // Action with address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) public {\n        proposalCount += 1;\n        mapPID_address[proposalCount] = proposedAddress;\n        mapPID_type[proposalCount] = typeStr;\n        emit NewProposal(msg.sender, proposalCount, typeStr);\n    }\n\n//============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal(uint proposalID) public returns (uint voteWeight) {\n        bytes memory _type = bytes(mapPID_type[proposalID]);\n        voteWeight = countMemberVotes(proposalID);\n        if(hasQuorum(proposalID) && mapPID_finalising[proposalID] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'REWARD')){\n                if(hasMajority(proposalID)){\n                    _finalise(proposalID);\n                }\n            } else {\n                _finalise(proposalID);\n            }\n        }\n        emit NewVote(msg.sender, proposalID, voteWeight, mapPID_votes[proposalID], string(_type));\n    }\n\n    function _finalise(uint _proposalID) internal {\n        bytes memory _type = bytes(mapPID_type[_proposalID]);\n        mapPID_finalising[_proposalID] = true;\n        mapPID_timeStart[_proposalID] = block.timestamp;\n        emit ProposalFinalising(msg.sender, _proposalID, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // If an existing proposal, allow a minority to cancel\n    function cancelProposal(uint oldProposalID, uint newProposalID) public {\n        require(mapPID_finalising[oldProposalID], \"Must be finalising\");\n        require(hasMinority(newProposalID), \"Must have minority\");\n        require(isEqual(bytes(mapPID_type[oldProposalID]), bytes(mapPID_type[newProposalID])), \"Must be same\");\n        mapPID_votes[oldProposalID] = 0;\n        emit CancelProposal(msg.sender, oldProposalID, mapPID_votes[oldProposalID], mapPID_votes[newProposalID], iVAULT(VAULT).totalWeight());\n    }\n\n    // Proposal with quorum can finalise after cool off period\n    function finaliseProposal(uint proposalID) public  {\n        require((block.timestamp - mapPID_timeStart[proposalID]) > coolOffPeriod, \"Must be after cool off\");\n        require(mapPID_finalising[proposalID] == true, \"Must be finalising\");\n        if(!hasQuorum(proposalID)){\n            _finalise(proposalID);\n        }\n        bytes memory _type = bytes(mapPID_type[proposalID]);\n        if (isEqual(_type, 'GRANT')){\n            grantFunds(proposalID);\n        } else if (isEqual(_type, 'UTILS')){\n            moveUtils(proposalID);\n        } else if (isEqual(_type, 'REWARD')){\n            moveRewardAddress(proposalID);\n        }\n    }\n\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID];\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], iVAULT(VAULT).totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0;\n        mapPID_finalised[_proposalID] = true;\n        mapPID_finalising[_proposalID] = false;\n    }\n\n//============================== BUSINESS LOGIC ================================//\n\n    function grantFunds(uint _proposalID) internal {\n        GrantDetails memory _grant = mapPID_grant[_proposalID];\n        require(_grant.amount <= iERC20(USDV).balanceOf(VAULT) / 10, \"Not more than 10%\");\n        completeProposal(_proposalID);\n        iVAULT(VAULT).grant(_grant.recipient, _grant.amount);\n    }\n\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID];\n        require(_proposedAddress != address(0), \"No address proposed\");\n        iVADER(VADER).changeUTILS(_proposedAddress);\n        completeProposal(_proposalID);\n    }\n    function moveRewardAddress(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID];\n        require(_proposedAddress != address(0), \"No address proposed\");\n        iVADER(VADER).setRewardAddress(_proposedAddress);\n        completeProposal(_proposalID);\n    }\n//============================== CONSENSUS ================================//\n\n    function countMemberVotes(uint _proposalID) internal returns (uint voteWeight){\n        mapPID_votes[_proposalID] -= mapPIDMember_votes[_proposalID][msg.sender];\n        voteWeight = iVAULT(VAULT).getMemberWeight(msg.sender);\n        mapPID_votes[_proposalID] += voteWeight;\n        mapPIDMember_votes[_proposalID][msg.sender] = voteWeight;\n    }\n\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 2; // >50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 3; // >33%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 6; // >16%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEqual(bytes memory part1, bytes memory part2) public pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    //====================================PRICING====================================//\n\n    function calcValueInBase(address token, uint amount) public view returns (uint value){\n       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n       if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _baseAmt) / _tokenAmt;\n       }\n    }\n\n    function calcValueInToken(address token, uint amount) public view returns (uint value){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _tokenAmt) / _baseAmt;\n       }\n    }\n    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){\n            return calcValueInToken(token2, calcValueInBase(token1, amount));\n    }\n\n    function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n    }\n    function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n    }\n\n    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {\n        uint _testingPrice = calcValueInBase(token, one);\n        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price\n        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price\n        if(inside){\n            require((_testingPrice >= _lower && _testingPrice <= _upper), \"Not inside\");\n        } else {\n            require((_testingPrice <= _lower || _testingPrice >= _upper), \"Not outside\");\n        }\n    }\n\n    //====================================INCENTIVES========================================//\n\n    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {\n        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){\n            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);\n            if (iPOOLS(POOLS).isAsset(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            } else if(iPOOLS(POOLS).isAnchor(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            }\n        }\n    }\n\n    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {\n        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n\n    // Actual protection with 100 day rule and Reserve balance\n    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {\n        uint _coverage = getCoverage(member, token);\n        if(iROUTER(ROUTER).isCurated(token)){\n            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);\n            if(_duration <= timeForFullProtection) {\n                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule\n            } else {\n                protection = _coverage;\n            }\n        }\n        return calcPart(basisPoints, protection);\n    }\n    // Theoretical coverage based on deposit/redemption values\n    function getCoverage(address member, address token) public view returns (uint) {\n        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);\n        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);\n        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));\n        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));\n        return calcCoverage(_B0, _T0, _B1, _T1);\n    }\n\n    //==================================== LENDING ====================================//\n\n    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n        if(isBase(collateralAsset)){\n            baseValue = _collateralAdjusted;\n        }else if(isPool(collateralAsset)){\n            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\n            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n        }\n        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output\n        return (debt, baseValue);\n    }\n\n    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {\n        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt\n        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral\n        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);\n        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);\n        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral\n        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); \n        return (_collateralUnlocked, _memberInterestShare);\n    }\n\n    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {\n        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year\n        if(isBase(collateralAsset)){\n            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base\n        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {\n            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)\n        }\n    }\n    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);\n        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; \n    }\n    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);\n        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);\n        return (_debtIssued * 10000) / _debtDepth; \n    }\n\n    //====================================CORE-MATH====================================//\n\n    function calcPart(uint bp, uint total) public pure returns (uint){\n        // 10,000 basis points = 100.00%\n        require((bp <= 10000) && (bp >= 0), \"Must be correct BP\");\n        return calcShare(bp, 10000, total);\n    }\n\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n        // share = amount * part/total\n        if(part > total){\n            part = total;\n        }\n        if(total > 0){\n            share = (amount * part) / total;\n        }\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = (x * X * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){\n        // fee = (x * x * Y) / (x + X)^2\n        uint numerator = (x * x * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n    function calcSwapSlip(uint x, uint X) external pure returns (uint){\n        // slip = (x) / (x + X)\n        return (x*10000) / (x + X);\n    }\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){\n        // (P * b)/(2*(b + B))\n        return (P * b) / (2 * (b + B));\n    }\n\n    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }\n    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n        if(B0 > 0 && T1 > 0){\n            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\n            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\n            if(_redemptionValue <= _depositValue){\n                coverage = (_depositValue - _redemptionValue);\n            }\n        }\n    }\n\n    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)\n    function sortArray(uint[] memory array) external pure returns (uint[] memory) {\n        uint l = array.length;\n        for(uint i = 0; i < l; i++){\n            for(uint j = i+1; j < l; j++){\n                if(array[i] > array[j]){\n                    uint temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        return array;\n    }\n\n}\n\n",
        "CodeNames": [
            "Attack.sol",
            "DAO.sol",
            "Utils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "calcAsymmetricShare",
                    "P * part1",
                    "(u * U * (",
                    "A^2",
                    "part2",
                    "(uA *"
                ],
                "Type": " Wrong  calcAsymmetricShare  calculation",
                "Description": "\nThe inline-comment defines the number of asymmetric shares as (u * U * (2 * A^2 2 * U * u + U^2))/U^3 but the Utils.calcAsymmetricShare function computes (uA * 2U^2 2uU + u^2) / U^3 which is not equivalent as can be seen from the A^2 term in the first term which does not occur in the second one.\n\nThe associativity on P * part1 is wrong, and part2 is not multiplied by P.\n\nThe math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up.\n\n",
                "Repair": "Recommend clarifying if the comment or the code is correct and fix them if not.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/214#issuecomment-828468071):\n  Valid\n\nstrictly-scarce (vader) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/214#issuecomment-830635568):\n  Whilst the math is incorrect, in the current implementation it is not yet implemented, so disagree with Severity (funds not lost), recommend: 2\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract Attack {\n    bool private inited;\n    address public VADER;\n    address public USDV;\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    function init(address _vader, address _USDV) public {\n        require(inited == false);\ninited = true;\n        VADER = _vader;\n        USDV = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function attackUSDV(uint amount) public {\n        iERC20(VADER).approve(USDV, amount);\n        iERC20(USDV).approve(USDV, amount);\n        iERC20(VADER).transferTo(address(this), amount); // get VADER funds\n        iUSDV(USDV).convert(amount); // Convert to USDV back to this address\n        iUSDV(USDV).redeem(amount); // Burn USDV back to VADER to this address\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract DAO {\n\n    struct GrantDetails{\n        address recipient;\n        uint amount;\n    }\n\n    bool private inited;\n    uint public proposalCount;\n    address public VADER;\n    address public USDV;\n    address public VAULT;\n    uint public coolOffPeriod;\n\n    mapping(uint => GrantDetails) public mapPID_grant;\n    mapping(uint => address) public mapPID_address;\n\n    mapping(uint => string) public mapPID_type;\n    mapping(uint => uint) public mapPID_votes;\n    mapping(uint => uint) public mapPID_timeStart;\n    mapping(uint => bool) public mapPID_finalising;\n    mapping(uint => bool) public mapPID_finalised;\n    mapping(uint => mapping(address => uint)) public mapPIDMember_votes;\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member,uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed oldProposalID, uint oldVotes, uint newVotes, uint totalWeight);\n    event FinalisedProposal(address indexed member,uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n    }\n    function init(address _vader, address _usdv, address _vault) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        VAULT = _vault;\n        coolOffPeriod = 1;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n    // Action with funding\n    function newGrantProposal(address recipient, uint amount) public {\n        string memory typeStr = \"GRANT\";\n        proposalCount += 1;\n        mapPID_type[proposalCount] = typeStr;\n        GrantDetails memory grant;\n        grant.recipient = recipient;\n        grant.amount = amount;\n        mapPID_grant[proposalCount] = grant;\n        emit NewProposal(msg.sender, proposalCount, typeStr);\n    }\n\n    // Action with address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) public {\n        proposalCount += 1;\n        mapPID_address[proposalCount] = proposedAddress;\n        mapPID_type[proposalCount] = typeStr;\n        emit NewProposal(msg.sender, proposalCount, typeStr);\n    }\n\n//============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal(uint proposalID) public returns (uint voteWeight) {\n        bytes memory _type = bytes(mapPID_type[proposalID]);\n        voteWeight = countMemberVotes(proposalID);\n        if(hasQuorum(proposalID) && mapPID_finalising[proposalID] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'REWARD')){\n                if(hasMajority(proposalID)){\n                    _finalise(proposalID);\n                }\n            } else {\n                _finalise(proposalID);\n            }\n        }\n        emit NewVote(msg.sender, proposalID, voteWeight, mapPID_votes[proposalID], string(_type));\n    }\n\n    function _finalise(uint _proposalID) internal {\n        bytes memory _type = bytes(mapPID_type[_proposalID]);\n        mapPID_finalising[_proposalID] = true;\n        mapPID_timeStart[_proposalID] = block.timestamp;\n        emit ProposalFinalising(msg.sender, _proposalID, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // If an existing proposal, allow a minority to cancel\n    function cancelProposal(uint oldProposalID, uint newProposalID) public {\n        require(mapPID_finalising[oldProposalID], \"Must be finalising\");\n        require(hasMinority(newProposalID), \"Must have minority\");\n        require(isEqual(bytes(mapPID_type[oldProposalID]), bytes(mapPID_type[newProposalID])), \"Must be same\");\n        mapPID_votes[oldProposalID] = 0;\n        emit CancelProposal(msg.sender, oldProposalID, mapPID_votes[oldProposalID], mapPID_votes[newProposalID], iVAULT(VAULT).totalWeight());\n    }\n\n    // Proposal with quorum can finalise after cool off period\n    function finaliseProposal(uint proposalID) public  {\n        require((block.timestamp - mapPID_timeStart[proposalID]) > coolOffPeriod, \"Must be after cool off\");\n        require(mapPID_finalising[proposalID] == true, \"Must be finalising\");\n        if(!hasQuorum(proposalID)){\n            _finalise(proposalID);\n        }\n        bytes memory _type = bytes(mapPID_type[proposalID]);\n        if (isEqual(_type, 'GRANT')){\n            grantFunds(proposalID);\n        } else if (isEqual(_type, 'UTILS')){\n            moveUtils(proposalID);\n        } else if (isEqual(_type, 'REWARD')){\n            moveRewardAddress(proposalID);\n        }\n    }\n\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID];\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], iVAULT(VAULT).totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0;\n        mapPID_finalised[_proposalID] = true;\n        mapPID_finalising[_proposalID] = false;\n    }\n\n//============================== BUSINESS LOGIC ================================//\n\n    function grantFunds(uint _proposalID) internal {\n        GrantDetails memory _grant = mapPID_grant[_proposalID];\n        require(_grant.amount <= iERC20(USDV).balanceOf(VAULT) / 10, \"Not more than 10%\");\n        completeProposal(_proposalID);\n        iVAULT(VAULT).grant(_grant.recipient, _grant.amount);\n    }\n\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID];\n        require(_proposedAddress != address(0), \"No address proposed\");\n        iVADER(VADER).changeUTILS(_proposedAddress);\n        completeProposal(_proposalID);\n    }\n    function moveRewardAddress(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID];\n        require(_proposedAddress != address(0), \"No address proposed\");\n        iVADER(VADER).setRewardAddress(_proposedAddress);\n        completeProposal(_proposalID);\n    }\n//============================== CONSENSUS ================================//\n\n    function countMemberVotes(uint _proposalID) internal returns (uint voteWeight){\n        mapPID_votes[_proposalID] -= mapPIDMember_votes[_proposalID][msg.sender];\n        voteWeight = iVAULT(VAULT).getMemberWeight(msg.sender);\n        mapPID_votes[_proposalID] += voteWeight;\n        mapPIDMember_votes[_proposalID][msg.sender] = voteWeight;\n    }\n\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 2; // >50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 3; // >33%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 6; // >16%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEqual(bytes memory part1, bytes memory part2) public pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    //====================================PRICING====================================//\n\n    function calcValueInBase(address token, uint amount) public view returns (uint value){\n       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n       if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _baseAmt) / _tokenAmt;\n       }\n    }\n\n    function calcValueInToken(address token, uint amount) public view returns (uint value){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _tokenAmt) / _baseAmt;\n       }\n    }\n    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){\n            return calcValueInToken(token2, calcValueInBase(token1, amount));\n    }\n\n    function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n    }\n    function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n    }\n\n    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {\n        uint _testingPrice = calcValueInBase(token, one);\n        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price\n        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price\n        if(inside){\n            require((_testingPrice >= _lower && _testingPrice <= _upper), \"Not inside\");\n        } else {\n            require((_testingPrice <= _lower || _testingPrice >= _upper), \"Not outside\");\n        }\n    }\n\n    //====================================INCENTIVES========================================//\n\n    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {\n        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){\n            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);\n            if (iPOOLS(POOLS).isAsset(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            } else if(iPOOLS(POOLS).isAnchor(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            }\n        }\n    }\n\n    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {\n        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n\n    // Actual protection with 100 day rule and Reserve balance\n    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {\n        uint _coverage = getCoverage(member, token);\n        if(iROUTER(ROUTER).isCurated(token)){\n            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);\n            if(_duration <= timeForFullProtection) {\n                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule\n            } else {\n                protection = _coverage;\n            }\n        }\n        return calcPart(basisPoints, protection);\n    }\n    // Theoretical coverage based on deposit/redemption values\n    function getCoverage(address member, address token) public view returns (uint) {\n        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);\n        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);\n        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));\n        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));\n        return calcCoverage(_B0, _T0, _B1, _T1);\n    }\n\n    //==================================== LENDING ====================================//\n\n    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n        if(isBase(collateralAsset)){\n            baseValue = _collateralAdjusted;\n        }else if(isPool(collateralAsset)){\n            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\n            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n        }\n        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output\n        return (debt, baseValue);\n    }\n\n    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {\n        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt\n        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral\n        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);\n        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);\n        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral\n        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); \n        return (_collateralUnlocked, _memberInterestShare);\n    }\n\n    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {\n        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year\n        if(isBase(collateralAsset)){\n            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base\n        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {\n            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)\n        }\n    }\n    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);\n        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; \n    }\n    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);\n        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);\n        return (_debtIssued * 10000) / _debtDepth; \n    }\n\n    //====================================CORE-MATH====================================//\n\n    function calcPart(uint bp, uint total) public pure returns (uint){\n        // 10,000 basis points = 100.00%\n        require((bp <= 10000) && (bp >= 0), \"Must be correct BP\");\n        return calcShare(bp, 10000, total);\n    }\n\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n        // share = amount * part/total\n        if(part > total){\n            part = total;\n        }\n        if(total > 0){\n            share = (amount * part) / total;\n        }\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = (x * X * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){\n        // fee = (x * x * Y) / (x + X)^2\n        uint numerator = (x * x * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n    function calcSwapSlip(uint x, uint X) external pure returns (uint){\n        // slip = (x) / (x + X)\n        return (x*10000) / (x + X);\n    }\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){\n        // (P * b)/(2*(b + B))\n        return (P * b) / (2 * (b + B));\n    }\n\n    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }\n    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n        if(B0 > 0 && T1 > 0){\n            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\n            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\n            if(_redemptionValue <= _depositValue){\n                coverage = (_depositValue - _redemptionValue);\n            }\n        }\n    }\n\n    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)\n    function sortArray(uint[] memory array) external pure returns (uint[] memory) {\n        uint l = array.length;\n        for(uint i = 0; i < l; i++){\n            for(uint j = i+1; j < l; j++){\n                if(array[i] > array[j]){\n                    uint temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        return array;\n    }\n\n}\n\n",
        "CodeNames": [
            "Pools.sol",
            "Attack.sol",
            "DAO.sol",
            "Utils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "((P * part",
                    "P * part1",
                    "units = (P (a B + A b))/(",
                    "calcLiquidityUnits",
                    "part2"
                ],
                "Type": " Wrong liquidity units calculation",
                "Description": "\nThe spec defines the number of LP units to be minted as units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments but the Utils.calcLiquidityUnits function computes ((P * part1) + part2) / part3 * slipAdjustments.\n\nThe associativity on P * part1 is wrong, and part2 is not multiplied by P.\n\nThe math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.\n\n",
                "Repair": "Recommend fixing the equation.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/204#issuecomment-830609695):\n Valid, but funds not at risk.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    //====================================PRICING====================================//\n\n    function calcValueInBase(address token, uint amount) public view returns (uint value){\n       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n       if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _baseAmt) / _tokenAmt;\n       }\n    }\n\n    function calcValueInToken(address token, uint amount) public view returns (uint value){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _tokenAmt) / _baseAmt;\n       }\n    }\n    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){\n            return calcValueInToken(token2, calcValueInBase(token1, amount));\n    }\n\n    function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n    }\n    function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n    }\n\n    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {\n        uint _testingPrice = calcValueInBase(token, one);\n        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price\n        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price\n        if(inside){\n            require((_testingPrice >= _lower && _testingPrice <= _upper), \"Not inside\");\n        } else {\n            require((_testingPrice <= _lower || _testingPrice >= _upper), \"Not outside\");\n        }\n    }\n\n    //====================================INCENTIVES========================================//\n\n    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {\n        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){\n            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);\n            if (iPOOLS(POOLS).isAsset(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            } else if(iPOOLS(POOLS).isAnchor(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            }\n        }\n    }\n\n    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {\n        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n\n    // Actual protection with 100 day rule and Reserve balance\n    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {\n        uint _coverage = getCoverage(member, token);\n        if(iROUTER(ROUTER).isCurated(token)){\n            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);\n            if(_duration <= timeForFullProtection) {\n                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule\n            } else {\n                protection = _coverage;\n            }\n        }\n        return calcPart(basisPoints, protection);\n    }\n    // Theoretical coverage based on deposit/redemption values\n    function getCoverage(address member, address token) public view returns (uint) {\n        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);\n        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);\n        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));\n        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));\n        return calcCoverage(_B0, _T0, _B1, _T1);\n    }\n\n    //==================================== LENDING ====================================//\n\n    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n        if(isBase(collateralAsset)){\n            baseValue = _collateralAdjusted;\n        }else if(isPool(collateralAsset)){\n            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\n            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n        }\n        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output\n        return (debt, baseValue);\n    }\n\n    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {\n        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt\n        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral\n        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);\n        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);\n        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral\n        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); \n        return (_collateralUnlocked, _memberInterestShare);\n    }\n\n    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {\n        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year\n        if(isBase(collateralAsset)){\n            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base\n        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {\n            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)\n        }\n    }\n    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);\n        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; \n    }\n    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);\n        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);\n        return (_debtIssued * 10000) / _debtDepth; \n    }\n\n    //====================================CORE-MATH====================================//\n\n    function calcPart(uint bp, uint total) public pure returns (uint){\n        // 10,000 basis points = 100.00%\n        require((bp <= 10000) && (bp >= 0), \"Must be correct BP\");\n        return calcShare(bp, 10000, total);\n    }\n\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n        // share = amount * part/total\n        if(part > total){\n            part = total;\n        }\n        if(total > 0){\n            share = (amount * part) / total;\n        }\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = (x * X * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){\n        // fee = (x * x * Y) / (x + X)^2\n        uint numerator = (x * x * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n    function calcSwapSlip(uint x, uint X) external pure returns (uint){\n        // slip = (x) / (x + X)\n        return (x*10000) / (x + X);\n    }\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){\n        // (P * b)/(2*(b + B))\n        return (P * b) / (2 * (b + B));\n    }\n\n    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }\n    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n        if(B0 > 0 && T1 > 0){\n            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\n            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\n            if(_redemptionValue <= _depositValue){\n                coverage = (_depositValue - _redemptionValue);\n            }\n        }\n    }\n\n    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)\n    function sortArray(uint[] memory array) external pure returns (uint[] memory) {\n        uint l = array.length;\n        for(uint i = 0; i < l; i++){\n            for(uint j = i+1; j < l; j++){\n                if(array[i] > array[j]){\n                    uint temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        return array;\n    }\n\n}\n\n",
        "CodeNames": [
            "Router.sol",
            "Utils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "timeForFullProtection",
                    "setParams()",
                    "getProtection()"
                ],
                "Type": " Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol",
                "Description": "\nIncorrect initialization of timeForFullProtection to 1 sec instead of 8640000 secs (100 days) as indicated in code comments, appears to be a test setting mistakenly carried over for deployment. Therefore, unless timeForFullProtection is reset to 100 days by setParams() (calling this function is a missing functionality in the DAO currently), the Impermanent Loss (IL) protection \"rule\" of 100 days will not apply in Utils.getProtection().\n\nThis breaks a key value proposition of the Vader protocol which is IL protection as indicated in the specification:\n \u201cImpermanent Loss Protection: The deposit value for each member is recorded when they deposit. When they go to withdraw, the redemption value is computed. If it is less than the deposit value, the member is paid the deficit from the reserve. The protection issued increases from 0 to 100% linearly for 100 days.\u201d\n\n",
                "Repair": "Recommend changing to \u201ctimeForFullProtection = 8640000; //100 days\u201d  on L84\n\nstrictly-scarce (vader) disputed(https://github.com/code-423n4/2021-04-vader-findings/issues/84#issuecomment-830597447):\n It's deliberately set to 1 second to conduct adequate testing.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}\n\n",
        "CodeNames": [
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "listAnchor",
                    "replaceAnchor",
                    "anchorLimit"
                ],
                "Type": " Anyone can list anchors / curate tokens",
                "Description": "\nThe Router.listAnchor function can be called by anyone and tokens can be added. The only check is that require(iPOOLS(POOLS).isAnchor(token)); but this can easily be set by calling Pools.addLiquidity(VADER, token, _) once even without actually sending any tokens to the contract. This makes it an essentially useless check.\n\nThis only works initially as long as the anchorLimit has not been reached yet.\nHowever, the replaceAnchor can be used in the same way and flash loans can be used to get around the liquidity restrictions and push another anchor token out of the price range as these checks use the current reserves.\n\nAnchored pools are automatically curated pools and determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.\n\nAfter a pool has been anchored through flash loans, liquidity can be withdrawn which could make the anchor price easy to manipulate in the next block and launch other attacks.\n\n",
                "Repair": "Recommend revisiting the _isAnchor[token] = true; statement in addLiquidity, it seems strange without any further checks.\nConsider making listAnchor / replaceAnchor DAO-only functions and make them flash-loan secure.\nOne should probably use time-weighted prices for these pools for the bounds check.\n\nstrictly-scarce (vader) disputed(https://github.com/code-423n4/2021-04-vader-findings/issues/211#issuecomment-828472672):\n  The protocol is intended to be launched with 5 anchors so it can only be attacked by using replaceAnchor(), in which case slip-based fees apply for attacks and thwart the attack path.\n\n\n"
            },
            {
                "Name": "H-15",
                "Location": [
                    "//solidity\nrequire(iUTILS(UTILS()).calcSwapSlip(\n    inputAmount, // should use outToken here from prev trade\n    iPOOLS(POOLS).getBaseAmount(outputToken)\n  ) <= slipLimit\n);\n"
                ],
                "Type": " Wrong slippage protection on Token -> Token trades",
                "Description": "The Router.swapWithSynthsWithLimit allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:\n\n1. token to base\n2. base to token\n\nThe slippage protection of the second trade (base to token) is computed wrong:\n\nsolidity\nrequire(iUTILS(UTILS()).calcSwapSlip(\n    inputAmount, // should use outToken here from prev trade\n    iPOOLS(POOLS).getBaseAmount(outputToken)\n  ) <= slipLimit\n);\n\n\nIt compares the token input amount (of the first trade) to the base reserve of the second pair.\n\nSlippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.\n\n",
                "Repair": "Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/209#issuecomment-828476313):\n  Valid, although disagree with severity, the wrongly compute slip amount would just fail the trade or allow the second trade to go thru with no protection.\n\nMervyn853 commented(https://github.com/code-423n4/2021-04-vader-findings/issues/209#issuecomment-830580592):\n  Our decision matrix for severity:\n\n 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n 1: Low Risk: UX, state handling, function incorrect as to spec\n 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n\n Recommended: 1\n\n\n"
            },
            {
                "Name": "H-23",
                "Location": [
                    "curatePool",
                    "replacePool"
                ],
                "Type": " Anyone can curate pools and steal rewards",
                "Description": "\nThe Router.curatePool and replacePool don't have any access restriction.\nAn attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools.\n\nCurated pools determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.\nThey can then go ahead and game the reward system by repeatedly swapping in their custom pool with useless tokens, withdraw liquidity, and in the end, pay back the base flashloan.\n\n",
                "Repair": "Recommend preventing the replacing of curations through flash loans. Also, consider making pool curations DAO-exclusive actions.\n\nstrictly-scarce (vader) disputed(https://github.com/code-423n4/2021-04-vader-findings/issues/210#issuecomment-828473380):\n  Slip-based pools cannot be attacked with flash loans.\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/210#issuecomment-849131582):\n  Further comment from @cmichelio:\n\n I can curate my custom token using curatePool without using a flashloan or using replacePool by temporarily providing liquidity to the pool without trading in it and getting slip-fee'd. I'm not trading in the pool, and don't think providing/removing liquidity comes with a fee. I think this is still an issue.\n\n\n"
            },
            {
                "Name": "H-25",
                "Location": [
                    "secondsPerEra"
                ],
                "Type": " Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol",
                "Description": "\nIncorrect initialization (perhaps testing parameterization mistakenly carried over to deployment) of secondsPerEra to 1 sec instead of 86400 secs (1 day) causes what should be the daily emission rate to be a secondly emission rate.\n\nThis causes inflation of VADER token and likely breaks VADER<USDV peg and other protocol invariants. Protocol will break and funds will be lost.\n\n",
                "Repair": "Recommend Initializing secondsPerEra to 86400 on L67.\n\nstrictly-scarce (vader) acknowledged(https://github.com/code-423n4/2021-04-vader-findings/issues/155#issuecomment-830606416):\n  This is purely for testing purposes.\n\n\n"
            },
            {
                "Name": "M-11",
                "Location": [
                    "listAnchor",
                    "getAnchorPrice"
                ],
                "Type": " Allowing duplicated anchors could cause bias on anchor price.",
                "Description": "\nIn Router.sol, the setup of the five anchors can be interrupted by anyone adding a new anchor due to the lack of access control of the listAnchor function. Also, duplicate anchors are allowed. If the same anchor is added three times, then this anchor biases the result of getAnchorPrice.\n\nReferenced code:\nRouter.sol#L245-L252(https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L245-L252)\n\nPoC: Link to PoC(https://drive.google.com/drive/folders/1W3jhlWIIh7FxTLZET3z49yA0DBvlbcPg?usp=sharing)\nSee the file 200_listAnchor.js for a PoC of this attack. To run it, use npx hardhat test 200_listAnchor.js.\n\n",
                "Repair": "Recommend only allowing listAnchor to be called from the deployer by adding a require statement. Also, check if an anchor is added before by require(_isCurated == false).\n\nstrictly-scarce (vader) acknowledged(https://github.com/code-423n4/2021-04-vader-findings/issues/314#issuecomment-830633778):\n  Deployer will list the anchors, seems highly unlikely they will get griefed in practice. Severity: 1\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\nimport \"./Synth.sol\"; \n\n// Factory Contract\ncontract Factory {\n\n    bool private inited;\n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    address[] public arraySynths;\n    mapping(address => address) public getSynth;\n    mapping(address => bool) public isSynth;\n\n    event CreateSynth(address indexed token, address indexed pool);\n\n    modifier onlyPOOLS() {\n        require(msg.sender == POOLS, \"!POOLS\");\n        _;\n    }\n    \n    constructor(){\n    }\n    function init(address _pool) public {\n        require(inited == false);\n        inited = true;\n        POOLS = _pool;\n    }\n\n    //Create a synth asset\n    function deploySynth(address token) external onlyPOOLS returns(address synth) {\n        require(getSynth[token] == address(0), \"CreateErr\");\n        Synth newSynth;\n        newSynth = new Synth(token);  \n        synth = address(newSynth);\n        _addSynth(token, synth);\n        emit CreateSynth(token, synth);\n    }\n\n    function mintSynth(address synth, address member, uint amount) external onlyPOOLS returns(bool) {\n         Synth(synth).mint(member, amount); \n        return true;\n    }\n\n    // function getSynth(address token) public view returns (address synth){\n    //     return mapToken_Synth[token];\n    // }\n    // function isSynth(address token) public view returns (bool _isSynth){\n    //     if(_isListedSynth[token] == true){\n    //         return true;\n    //     }\n    // }\n\n    function _addSynth(address _token, address _synth) internal {\n        getSynth[_token] = _synth;\n        arraySynths.push(_synth); \n        isSynth[_synth] = true;\n    }\n\n}\n\n",
        "CodeNames": [
            "Pools.sol",
            "Factory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "_actualInput = getAddedAmount(base, token);",
                    "base",
                    "token",
                    "calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount",
                    "swap(base=token, token, member, toBase=false)",
                    "swap",
                    "swap(token, token, member, toBase=false)"
                ],
                "Type": " Swap token can be traded as fake base token",
                "Description": "\nThe Pools.swap function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call swap(token, token, member, toBase=false)\n\nThe _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result.\n\nIt breaks the accounting for the pool as tokens are transferred in, but the base balance is increased (and token balance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.\n\nAnother example scenario is that the token pool amount can be stolen.\nSend tokenIn=baseAmount of tokens to the pool and call swap(base=token, token, member, toBase=false). Depending on the price of token relative to base this could be cheaper than trading with the base tokens.\n\n",
                "Repair": "Recommend checking that base is either USDV or VADER.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/205#issuecomment-830609893):\n  Valid, funds can be lost\n\n\n"
            },
            {
                "Name": "H-13",
                "Location": [
                    "_actualInput = getAddedAmount(base, token);",
                    "base",
                    "token",
                    "calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount",
                    "mintSynth(token, token, member)",
                    "mintSynth"
                ],
                "Type": " 4 Synths can be minted with fake base token",
                "Description": "\nThe Pools.mintSynth function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call mintSynth(token, token, member).\n\nThe _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result.\n\nIt breaks the accounting for the pool as tokens are transferred in, but the base balance is increased.\n\nThe amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if token is a high-precision token or worth less than base.\n\n",
                "Repair": "Recommend checking that base is either USDV or VADER in mintSynth.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/207#issuecomment-830610147):\n  Valid, funds can be lost.\n\nstrictly-scarce (vader) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/207#issuecomment-830610260):\n  would bundle this issue with:\n https://github.com/code-423n4/2021-04-vader-findings/issues/205\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract Attack {\n    bool private inited;\n    address public VADER;\n    address public USDV;\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    function init(address _vader, address _USDV) public {\n        require(inited == false);\ninited = true;\n        VADER = _vader;\n        USDV = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function attackUSDV(uint amount) public {\n        iERC20(VADER).approve(USDV, amount);\n        iERC20(USDV).approve(USDV, amount);\n        iERC20(VADER).transferTo(address(this), amount); // get VADER funds\n        iUSDV(USDV).convert(amount); // Convert to USDV back to this address\n        iUSDV(USDV).redeem(amount); // Burn USDV back to VADER to this address\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\nimport \"./Synth.sol\"; \n\n// Factory Contract\ncontract Factory {\n\n    bool private inited;\n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    address[] public arraySynths;\n    mapping(address => address) public getSynth;\n    mapping(address => bool) public isSynth;\n\n    event CreateSynth(address indexed token, address indexed pool);\n\n    modifier onlyPOOLS() {\n        require(msg.sender == POOLS, \"!POOLS\");\n        _;\n    }\n    \n    constructor(){\n    }\n    function init(address _pool) public {\n        require(inited == false);\n        inited = true;\n        POOLS = _pool;\n    }\n\n    //Create a synth asset\n    function deploySynth(address token) external onlyPOOLS returns(address synth) {\n        require(getSynth[token] == address(0), \"CreateErr\");\n        Synth newSynth;\n        newSynth = new Synth(token);  \n        synth = address(newSynth);\n        _addSynth(token, synth);\n        emit CreateSynth(token, synth);\n    }\n\n    function mintSynth(address synth, address member, uint amount) external onlyPOOLS returns(bool) {\n         Synth(synth).mint(member, amount); \n        return true;\n    }\n\n    // function getSynth(address token) public view returns (address synth){\n    //     return mapToken_Synth[token];\n    // }\n    // function isSynth(address token) public view returns (bool _isSynth){\n    //     if(_isListedSynth[token] == true){\n    //         return true;\n    //     }\n    // }\n\n    function _addSynth(address _token, address _synth) internal {\n        getSynth[_token] = _synth;\n        arraySynths.push(_synth); \n        isSynth[_synth] = true;\n    }\n\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    //====================================PRICING====================================//\n\n    function calcValueInBase(address token, uint amount) public view returns (uint value){\n       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n       if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _baseAmt) / _tokenAmt;\n       }\n    }\n\n    function calcValueInToken(address token, uint amount) public view returns (uint value){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _tokenAmt) / _baseAmt;\n       }\n    }\n    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){\n            return calcValueInToken(token2, calcValueInBase(token1, amount));\n    }\n\n    function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n    }\n    function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n    }\n\n    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {\n        uint _testingPrice = calcValueInBase(token, one);\n        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price\n        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price\n        if(inside){\n            require((_testingPrice >= _lower && _testingPrice <= _upper), \"Not inside\");\n        } else {\n            require((_testingPrice <= _lower || _testingPrice >= _upper), \"Not outside\");\n        }\n    }\n\n    //====================================INCENTIVES========================================//\n\n    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {\n        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){\n            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);\n            if (iPOOLS(POOLS).isAsset(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            } else if(iPOOLS(POOLS).isAnchor(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            }\n        }\n    }\n\n    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {\n        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n\n    // Actual protection with 100 day rule and Reserve balance\n    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {\n        uint _coverage = getCoverage(member, token);\n        if(iROUTER(ROUTER).isCurated(token)){\n            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);\n            if(_duration <= timeForFullProtection) {\n                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule\n            } else {\n                protection = _coverage;\n            }\n        }\n        return calcPart(basisPoints, protection);\n    }\n    // Theoretical coverage based on deposit/redemption values\n    function getCoverage(address member, address token) public view returns (uint) {\n        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);\n        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);\n        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));\n        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));\n        return calcCoverage(_B0, _T0, _B1, _T1);\n    }\n\n    //==================================== LENDING ====================================//\n\n    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n        if(isBase(collateralAsset)){\n            baseValue = _collateralAdjusted;\n        }else if(isPool(collateralAsset)){\n            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\n            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n        }\n        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output\n        return (debt, baseValue);\n    }\n\n    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {\n        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt\n        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral\n        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);\n        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);\n        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral\n        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); \n        return (_collateralUnlocked, _memberInterestShare);\n    }\n\n    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {\n        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year\n        if(isBase(collateralAsset)){\n            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base\n        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {\n            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)\n        }\n    }\n    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);\n        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; \n    }\n    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);\n        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);\n        return (_debtIssued * 10000) / _debtDepth; \n    }\n\n    //====================================CORE-MATH====================================//\n\n    function calcPart(uint bp, uint total) public pure returns (uint){\n        // 10,000 basis points = 100.00%\n        require((bp <= 10000) && (bp >= 0), \"Must be correct BP\");\n        return calcShare(bp, 10000, total);\n    }\n\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n        // share = amount * part/total\n        if(part > total){\n            part = total;\n        }\n        if(total > 0){\n            share = (amount * part) / total;\n        }\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = (x * X * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){\n        // fee = (x * x * Y) / (x + X)^2\n        uint numerator = (x * x * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n    function calcSwapSlip(uint x, uint X) external pure returns (uint){\n        // slip = (x) / (x + X)\n        return (x*10000) / (x + X);\n    }\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){\n        // (P * b)/(2*(b + B))\n        return (P * b) / (2 * (b + B));\n    }\n\n    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }\n    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n        if(B0 > 0 && T1 > 0){\n            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\n            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\n            if(_redemptionValue <= _depositValue){\n                coverage = (_depositValue - _redemptionValue);\n            }\n        }\n    }\n\n    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)\n    function sortArray(uint[] memory array) external pure returns (uint[] memory) {\n        uint l = array.length;\n        for(uint i = 0; i < l; i++){\n            for(uint j = i+1; j < l; j++){\n                if(array[i] > array[j]){\n                    uint temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        return array;\n    }\n\n}\n\n",
        "CodeNames": [
            "Pools.sol",
            "Attack.sol",
            "Factory.sol",
            "Utils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-12",
                "Location": [
                    "(VADER/USDV, pool)",
                    "token1",
                    "sync(token",
                    "token",
                    "getAddedAmount",
                    "mapToken_tokenAmount[_pool]",
                    "(pool, pool)",
                    "swap(token",
                    "mapToken_tokenAmount[token"
                ],
                "Type": "  getAddedAmount  can return wrong results",
                "Description": "\nThe getAddedAmount function only works correctly when called with (VADER/USDV, pool) or (pool, pool).\nHowever, when called with (token, pool) where token is neither VADER/USDV/pool, it returns the wrong results:\n\n1. It gets the token balance\n2. And subtracts it from the stored mapToken_tokenAmount[_pool] amount which can be that of a completely different token\n\nAnyone can break individual pairs by calling sync(token1, token2) where the token1 balance is less than mapToken_tokenAmount[token2]. This will add the difference to mapToken_tokenAmount[token2] and break the accounting and result in a wrong swap logic.\n\nFurthermore, this can also be used to swap tokens without having to pay anthing with swap(token1, token2, member, toBase=false).\n\n",
                "Repair": "Recommend adding a require statement in the else branch that checks that _token == _pool.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/206#issuecomment-830610039):\n  Valid, funds can be lost\n\nstrictly-scarce (vader) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/206#issuecomment-830610281):\n  Would bundle this issue with:\n https://github.com/code-423n4/2021-04-vader-findings/issues/205\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract DAO {\n\n    struct GrantDetails{\n        address recipient;\n        uint amount;\n    }\n\n    bool private inited;\n    uint public proposalCount;\n    address public VADER;\n    address public USDV;\n    address public VAULT;\n    uint public coolOffPeriod;\n\n    mapping(uint => GrantDetails) public mapPID_grant;\n    mapping(uint => address) public mapPID_address;\n\n    mapping(uint => string) public mapPID_type;\n    mapping(uint => uint) public mapPID_votes;\n    mapping(uint => uint) public mapPID_timeStart;\n    mapping(uint => bool) public mapPID_finalising;\n    mapping(uint => bool) public mapPID_finalised;\n    mapping(uint => mapping(address => uint)) public mapPIDMember_votes;\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member,uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed oldProposalID, uint oldVotes, uint newVotes, uint totalWeight);\n    event FinalisedProposal(address indexed member,uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n    }\n    function init(address _vader, address _usdv, address _vault) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        VAULT = _vault;\n        coolOffPeriod = 1;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n    // Action with funding\n    function newGrantProposal(address recipient, uint amount) public {\n        string memory typeStr = \"GRANT\";\n        proposalCount += 1;\n        mapPID_type[proposalCount] = typeStr;\n        GrantDetails memory grant;\n        grant.recipient = recipient;\n        grant.amount = amount;\n        mapPID_grant[proposalCount] = grant;\n        emit NewProposal(msg.sender, proposalCount, typeStr);\n    }\n\n    // Action with address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) public {\n        proposalCount += 1;\n        mapPID_address[proposalCount] = proposedAddress;\n        mapPID_type[proposalCount] = typeStr;\n        emit NewProposal(msg.sender, proposalCount, typeStr);\n    }\n\n//============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal(uint proposalID) public returns (uint voteWeight) {\n        bytes memory _type = bytes(mapPID_type[proposalID]);\n        voteWeight = countMemberVotes(proposalID);\n        if(hasQuorum(proposalID) && mapPID_finalising[proposalID] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'REWARD')){\n                if(hasMajority(proposalID)){\n                    _finalise(proposalID);\n                }\n            } else {\n                _finalise(proposalID);\n            }\n        }\n        emit NewVote(msg.sender, proposalID, voteWeight, mapPID_votes[proposalID], string(_type));\n    }\n\n    function _finalise(uint _proposalID) internal {\n        bytes memory _type = bytes(mapPID_type[_proposalID]);\n        mapPID_finalising[_proposalID] = true;\n        mapPID_timeStart[_proposalID] = block.timestamp;\n        emit ProposalFinalising(msg.sender, _proposalID, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // If an existing proposal, allow a minority to cancel\n    function cancelProposal(uint oldProposalID, uint newProposalID) public {\n        require(mapPID_finalising[oldProposalID], \"Must be finalising\");\n        require(hasMinority(newProposalID), \"Must have minority\");\n        require(isEqual(bytes(mapPID_type[oldProposalID]), bytes(mapPID_type[newProposalID])), \"Must be same\");\n        mapPID_votes[oldProposalID] = 0;\n        emit CancelProposal(msg.sender, oldProposalID, mapPID_votes[oldProposalID], mapPID_votes[newProposalID], iVAULT(VAULT).totalWeight());\n    }\n\n    // Proposal with quorum can finalise after cool off period\n    function finaliseProposal(uint proposalID) public  {\n        require((block.timestamp - mapPID_timeStart[proposalID]) > coolOffPeriod, \"Must be after cool off\");\n        require(mapPID_finalising[proposalID] == true, \"Must be finalising\");\n        if(!hasQuorum(proposalID)){\n            _finalise(proposalID);\n        }\n        bytes memory _type = bytes(mapPID_type[proposalID]);\n        if (isEqual(_type, 'GRANT')){\n            grantFunds(proposalID);\n        } else if (isEqual(_type, 'UTILS')){\n            moveUtils(proposalID);\n        } else if (isEqual(_type, 'REWARD')){\n            moveRewardAddress(proposalID);\n        }\n    }\n\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID];\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], iVAULT(VAULT).totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0;\n        mapPID_finalised[_proposalID] = true;\n        mapPID_finalising[_proposalID] = false;\n    }\n\n//============================== BUSINESS LOGIC ================================//\n\n    function grantFunds(uint _proposalID) internal {\n        GrantDetails memory _grant = mapPID_grant[_proposalID];\n        require(_grant.amount <= iERC20(USDV).balanceOf(VAULT) / 10, \"Not more than 10%\");\n        completeProposal(_proposalID);\n        iVAULT(VAULT).grant(_grant.recipient, _grant.amount);\n    }\n\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID];\n        require(_proposedAddress != address(0), \"No address proposed\");\n        iVADER(VADER).changeUTILS(_proposedAddress);\n        completeProposal(_proposalID);\n    }\n    function moveRewardAddress(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID];\n        require(_proposedAddress != address(0), \"No address proposed\");\n        iVADER(VADER).setRewardAddress(_proposedAddress);\n        completeProposal(_proposalID);\n    }\n//============================== CONSENSUS ================================//\n\n    function countMemberVotes(uint _proposalID) internal returns (uint voteWeight){\n        mapPID_votes[_proposalID] -= mapPIDMember_votes[_proposalID][msg.sender];\n        voteWeight = iVAULT(VAULT).getMemberWeight(msg.sender);\n        mapPID_votes[_proposalID] += voteWeight;\n        mapPIDMember_votes[_proposalID][msg.sender] = voteWeight;\n    }\n\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 2; // >50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 3; // >33%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID];\n        uint consensus = iVAULT(VAULT).totalWeight() / 6; // >16%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function isEqual(bytes memory part1, bytes memory part2) public pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n}\n\n",
        "CodeNames": [
            "DAO.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-14",
                "Location": [
                    "member"
                ],
                "Type": " Missing access restriction on  lockUnits/unlockUnits ",
                "Description": "\nThe Pool.lockUnits allows anyone to steal pool tokens from a member and assign them to msg.sender. Anyone can steal pool tokens from any other user.\n\n",
                "Repair": "Recommend adding access control and require that msg.sender is the router or another authorized party.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/208#issuecomment-828478127):\n Valid, although this is part of the partially-complete lending code.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "voteProposal()"
                ],
                "Type": " Undefined behavior for DAO and GRANT vote proposals in  DAO.sol ",
                "Description": "\nGiven that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if 'DAO' type checked in voteProposal() is a typographical error and should really be 'GRANT'. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%).\n\n",
                "Repair": "Recommend changing \u2018DAO\u2019 on L83 to \u2018GRANT\u2019 or if not, specify what DAO proposals are and how GRANT proposals should be handled with quorum or majority.\n\nAlso, check and enforce that mapPID_types are only these three actionable proposal types: GRANT, UTILS, REWARD.\n\nstrictly-scarce (vader) acknowledged(https://github.com/code-423n4/2021-04-vader-findings/issues/183#issuecomment-830615194):\n  DAO not yet fully implemented\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "mapPID_timeStart",
                    "mapPID_finalising",
                    "mapPID_votes",
                    "cancelProposal",
                    "finaliseProposal"
                ],
                "Type": " Canceled proposals can still be executed",
                "Description": "\nProposals that passed the threshold (\"finalized\") can be cancelled by a minority again using the cancelProposal functions.\nIt only sets mapPID_votes to zero but mapPID_timeStart and mapPID_finalising stay the same and pass the checks in finaliseProposal which queues them for execution.\n\nProposals cannot be cancelled.\n\n",
                "Repair": "Recommend setting a cancel flag and check for it in finaliseProposal and in execution.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/228#issuecomment-830616938):\n  Valid\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "FinalisedProposal"
                ],
                "Type": " Completed proposals can be voted on and executed again",
                "Description": "\nA proposal that is completed has its state reset, including the votes.\nUsers can just vote on it again and it can be executed again.\n\nCompleted proposals should most likely not be allowed to be voted on / executed again.\nThis could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the FinalisedProposal event has fired.\n\n",
                "Repair": "Recommend adding an executed flag to the proposals and disallow voting/finalising on already executed proposals.\n\nstrictly-scarce (vader) disputed(https://github.com/code-423n4/2021-04-vader-findings/issues/229#issuecomment-830617230):\n  It might be intended to have repeated proposals.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract Attack {\n    bool private inited;\n    address public VADER;\n    address public USDV;\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    function init(address _vader, address _USDV) public {\n        require(inited == false);\ninited = true;\n        VADER = _vader;\n        USDV = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function attackUSDV(uint amount) public {\n        iERC20(VADER).approve(USDV, amount);\n        iERC20(USDV).approve(USDV, amount);\n        iERC20(VADER).transferTo(address(this), amount); // get VADER funds\n        iUSDV(USDV).convert(amount); // Convert to USDV back to this address\n        iUSDV(USDV).redeem(amount); // Burn USDV back to VADER to this address\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\n\n// Synth Contract\ncontract Synth is iERC20 {\n\n    address public FACTORY;\n    address public TOKEN;\n\n    // Coin Defaults\n    string public override name;\n    string public override symbol;\n    uint public override decimals  = 18;\n    uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    modifier onlyFACTORY() {\n        require(msg.sender == FACTORY, \"!FACTORY\");\n        _;\n    }\n    \n    // Minting event\n    constructor(address _token){\n        TOKEN = _token;\n        FACTORY = msg.sender;\n        string memory synthName = \" - vSynth\";\n        string memory synthSymbol = \".v\";\n        name = string(abi.encodePacked(iERC20(_token).name(), synthName));\n        symbol = string(abi.encodePacked(iERC20(_token).symbol(), synthSymbol));\n    }\n\n    \n    //========================================iERC20=========================================//\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        require(sender != address(0), \"sender\");\n        require(recipient != address(this), \"recipient\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n    // Only FACTORY can mint\n    function mint(address account, uint amount) external virtual onlyFACTORY {\n        require(account != address(0), \"recipient\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n    // Burn supply\n    function burn(uint amount) public virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) public virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender) - amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        require(account != address(0), \"address err\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n}\n\n",
        "CodeNames": [
            "Pools.sol",
            "Attack.sol",
            "Synth.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-16",
                "Location": [
                    "transferTo",
                    "BASE",
                    "transferTo()",
                    "_transfer"
                ],
                "Type": " Tokens can be stolen through  transferTo ",
                "Description": "\nI know that it's stated that:\n\n VADER, USDV, SYNTHS all employ the transferTo() function, which interrogates for tx.origin and skips approvals. The author does not subscribe to the belief that this is dangerous\n\nIn my opinion, it can be very dangerous. Imagine the following scenario:\n\n1. I create a custom attacker ERC20 token that has a hook in the _transfer function that checks tx.origin for USDV/VADER/SYNTHS and calls transferTo to steal these funds.\n2. I set up a honeypot by providing liquidity to the BASE < ATTACKER pool.\n3. I target high-profile accounts holdinging VADER/USDV/SYNTHS and airdrop them free tokens.\n4. Block explorers / Vader swap websites could show that this token has value and can be traded for actual BASE tokens.\n5. User wants to sell the airdropped ATTACKER token to receive valuable tokens through the Vader swap and has all their tokens (that are even completely unrelated to the tokens being swapped) stolen.\n\nIn general, a holder of any of the core assets of the protocol risks all their funds being stolen if they ever interact with an unvetted external contract/token.\nThis could even be completely unrelated to the VADER protocol.\n\n",
                "Repair": "Recommend removing transferTo and use permit + transferFrom instead to move tokens from tx.origin.\n\nstrictly-scarce (vader) acknowledged(https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-828445128):\n  This attack path has already been assessed as the most likely, no new information is being presented here.\n\n Do not interact with attack contracts, interacting with an ERC20 is an attack contract.\n\n0xBrian commented(https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-829142947):\n  @strictly-scarce (vader) What would be the downside of adopting the suggested mitigation? Since we cannot communicate effectively with all users to tell them not to interact with certain kinds of contracts (and even if we could, they may not be able to discern which are OK and which aren't), we don't want to set up a thicket for fraudsters to operate. If the downside of the mitigation is not too bad, I think it could be worth it in order to deny fraudsters an opportunity to steal.\n\nMervyn853 commented(https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-830582387):\n  Our decision matrix for severity:\n\n 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n 1: Low Risk: UX, state handling, function incorrect as to spec\n 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n\n Recommended: 0\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\ncontract Vader is iERC20 {\n\n    // ERC-20 Parameters\n    string public override name; string public override symbol;\n    uint public override decimals; uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Parameters\n    bool private inited;\n    bool public emitting;\n    bool public minting;\n    uint _1m;\n    uint public baseline;\n    uint public emissionCurve;\n    uint public maxSupply;\n    uint public secondsPerEra;\n    uint public currentEra;\n    uint public nextEraTime;\n    uint public feeOnTransfer;\n\n    address public VETHER;\n    address public USDV;\n    address public UTILS;\n    address public burnAddress;\n    address public rewardAddress;\n    address public DAO;\n\n    event NewEra(uint currentEra, uint nextEraTime, uint emission);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO, \"Not DAO\");\n        _;\n    }\n    // Stop flash attacks\n    modifier flashProof() {\n        require(isMature(), \"No flash\");\n        _;\n    }\n    function isMature() public view returns(bool){\n        return iUSDV(USDV).isMature();\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n        name = 'VADER PROTOCOL TOKEN';\n        symbol = 'VADER';\n        decimals = 18;\n        _1m = 10**6 * 10 ** decimals; //1m\n        baseline = _1m;\n        totalSupply = 0;\n        maxSupply = 2 * _1m;\n        currentEra = 1;\n        secondsPerEra = 1; //86400;\n        nextEraTime = block.timestamp + secondsPerEra;\n        emissionCurve = 900;\n        DAO = msg.sender;\n        burnAddress = 0x0111011001100001011011000111010101100101;\n    }\n    // Can only be called once\n    function init(address _vether, address _USDV, address _utils) external {\n        require(inited == false);\n        inited = true;\n        VETHER = _vether;\n        USDV = _USDV;\n        UTILS = _utils;\n        rewardAddress = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function balanceOf(address account) external view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        require(sender != address(0), \"sender\");\n        require(recipient != address(this), \"recipient\");\n        _balances[sender] -= amount;\n        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  // Critical functionality\n        if(_fee >= 0 && _fee <= amount){                            // Stops reverts if UTILS corrupted\n            amount -= _fee;\n            _burn(msg.sender, _fee);\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        _checkEmission();\n    }\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint amount) internal virtual {\n        require(account != address(0), \"recipient\");\n        if((totalSupply + amount) >= maxSupply){\n            amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply\n        }\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n    // Burn supply\n    function burn(uint amount) public virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) external virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender) - amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        require(account != address(0), \"address err\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //=========================================DAO=========================================//\n    // Can start\n    function flipEmissions() external onlyDAO {\n        if(emitting){\n            emitting = false;\n        } else {\n            emitting = true;\n        }\n    }\n    // Can stop\n    function flipMinting() external onlyDAO {\n        if(minting){\n            minting = false;\n        } else {\n            minting = true;\n        }\n    }\n    // Can set params\n    function setParams(uint newEra, uint newCurve) external onlyDAO {\n        secondsPerEra = newEra;\n        emissionCurve = newCurve;\n    }\n    // Can set reward address\n    function setRewardAddress(address newAddress) external onlyDAO {\n        rewardAddress = newAddress;\n    }\n    // Can change UTILS\n    function changeUTILS(address newUTILS) external onlyDAO {\n        require(newUTILS != address(0), \"address err\");\n        UTILS = newUTILS;\n    }\n    // Can change DAO\n    function changeDAO(address newDAO) external onlyDAO {\n        require(newDAO != address(0), \"address err\");\n        DAO = newDAO;\n    }\n    // Can purge DAO\n    function purgeDAO() external onlyDAO{\n        DAO = address(0);\n    }\n\n   //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _checkEmission() private {\n        if ((block.timestamp >= nextEraTime) && emitting) {                                // If new Era and allowed to emit\n            currentEra += 1;                                                               // Increment Era\n            nextEraTime = block.timestamp + secondsPerEra;                                 // Set next Era time\n            uint _emission = getDailyEmission();                                           // Get Daily Dmission\n            _mint(rewardAddress, _emission);                                               // Mint to the Rewad Address\n            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        // UpdateFeeOnTransfer\n            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                // Max 10% if UTILS corrupted\n            emit NewEra(currentEra, nextEraTime, _emission);                               // Emit Event\n        }\n    }\n    // Calculate Daily Emission\n    function getDailyEmission() public view returns (uint) {\n        uint _adjustedMax;\n        if(totalSupply <= baseline){ // If less than 1m, then adjust cap down\n            _adjustedMax = (maxSupply * totalSupply) / baseline; // 2m * 0.5m / 1m = 2m * 50% = 1.5m\n        } else {\n            _adjustedMax = maxSupply;  // 2m\n        }\n        return (_adjustedMax - totalSupply) / (emissionCurve); // outstanding / curve \n    }\n\n    //======================================ASSET MINTING========================================//\n    // VETHER Owners to Upgrade\n    function upgrade(uint amount) external {\n        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));\n        _mint(msg.sender, amount);\n    }\n    // Directly redeem back to VADER (must have sent USDV first)\n    function redeem() external returns (uint redeemAmount){\n        return redeemToMember(msg.sender);\n    }\n    // Redeem on behalf of member (must have sent USDV first)\n    function redeemToMember(address member) public flashProof returns (uint redeemAmount){\n        if(minting){\n            uint _amount = iERC20(USDV).balanceOf(address(this)); \n            iERC20(USDV).burn(_amount);\n            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); // Critical pricing functionality\n            _mint(member, redeemAmount);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "Router.sol",
            "Vader.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-17",
                "Location": [
                    "transferFrom",
                    "_transfer"
                ],
                "Type": " Transfer fee is burned on wrong accounts",
                "Description": "\nThe Vader._transfer function burns the transfer fee on msg.sender but this address might not be involved in the transfer at all due to transferFrom.\n\nSmart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.\n\n",
                "Repair": "Recommend that It should first increase the balance of recipient by the full amount and then burn the fee on the recipient.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/220#issuecomment-828463080):\n  For composabilty with the rest of the ecosystem, this should be addressed, although disagree with the severity, no funds are lost, just the aggregrator cannot transfer unless they first transfer to themselves, which most often do.\n\nMervyn853 commented(https://github.com/code-423n4/2021-04-vader-findings/issues/220#issuecomment-830582199):\n  Our decision matrix for severity:\n\n 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n 1: Low Risk: UX, state handling, function incorrect as to spec\n 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n\n Recommended: 2\n\n\n"
            },
            {
                "Name": "M-15",
                "Location": [
                    "onlyDAO",
                    "changeDAO()",
                    "changeDAO"
                ],
                "Type": "  changeDAO  should be a two-step process in Vader.sol",
                "Description": "\nchangeDAO() updates\u00a0DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires\u00a0msg.sender\u00a0to be the incorrectly used\u00a0DAO\u00a0address (for which private keys may not be available to sign transactions). See finding #6 from Trail of Bits audit of Hermez Network(https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf).\n\n",
                "Repair": "Recommend using a two-step process where the old DAO address first proposes new ownership in one transaction; and then, accepts ownership from the newly proposed DAO address in a second transaction. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/162#issuecomment-830607270):\n  A lot has to go wrong to get to this point, so disagree with severity (funds not at risk).\n\n Two step-process seems wise though.\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/162#issuecomment-847850118):\n  Risk lowered because of the extremely low probability\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.3;\n\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\ncontract Vault {\n\n    bool private inited;\n    uint public erasToEarn;\n    uint public minGrantTime;\n    uint public lastGranted;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    uint public minimumDepositTime;\n    uint public totalWeight;\n\n    mapping(address => uint) private mapMember_weight;\n    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;\n    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;\n\n    // Events\n    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    constructor(){}\n\n    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {\n        require(inited == false);\n        inited = true;\n        POOLS = _pool;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n        POOLS = _pool;\n        erasToEarn = 100;\n        minimumDepositTime = 1;\n        minGrantTime = 2592000;     // 30 days\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {\n        erasToEarn = newEra;\n        minimumDepositTime = newDepositTime;\n        minGrantTime = newGrantTime;\n    }\n\n    // Can issue grants\n    function grant(address recipient, uint amount) public onlyDAO {\n        require((block.timestamp - lastGranted) >= minGrantTime, \"not too fast\");\n        lastGranted = block.timestamp;\n        iERC20(USDV).transfer(recipient, amount); \n    }\n\n    //======================================DEPOSITS========================================//\n\n    // Deposit USDV or SYNTHS\n    function deposit(address synth, uint amount) external {\n        depositForMember(synth, msg.sender, amount);\n    }\n    // Wrapper for contracts\n    function depositForMember(address synth, address member, uint amount) public {\n        require((iFACTORY(FACTORY).isSynth(synth)), \"Not Synth\"); // Only Synths\n        getFunds(synth, amount);\n        _deposit(synth, member, amount);\n    }\n    function _deposit(address _synth, address _member, uint _amount) internal {\n        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         // Time of deposit\n        mapMemberSynth_deposit[_member][_synth] += _amount;                 // Record deposit\n        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);\n        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){\n            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               // Price in USDV\n        }\n        mapMember_weight[_member] += _weight;                               // Total member weight \n        totalWeight += _weight;                                             // Total weight \n        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);\n    }\n\n    //====================================== HARVEST ========================================//\n\n    // Harvest, get payment, allocate, increase weight\n    function harvest(address synth) external returns(uint reward) {\n        address _member = msg.sender;\n        uint _weight;\n        address _token = iSYNTH(synth).TOKEN();\n        reward = calcCurrentReward(synth, _member);                     // In USDV\n        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      // Reset time\n        if(iPOOLS(POOLS).isAsset(_token)){\n            iERC20(USDV).transfer(POOLS, reward); \n            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));\n            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);\n        } else {\n            iERC20(VADER).transfer(POOLS, reward); \n            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));\n            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));\n        }\n        mapMemberSynth_deposit[_member][synth] += reward; \n        mapMember_weight[_member] += _weight;\n        totalWeight += _weight;\n        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);\n    }\n\n    // Get the payment owed for a member\n    function calcCurrentReward(address synth, address member) public view returns(uint reward) {\n        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        // Get time since last claim\n        uint _share = calcReward(synth, member);                                               // Get share of rewards for member\n        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         // Get owed amount, based on per-day rates\n        uint _reserve;\n        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){\n            _reserve = reserveUSDV();\n        } else {\n            _reserve = reserveVADER();\n        }\n        if(reward >= _reserve) {\n            reward = _reserve;                                                          // Send full reserve if the last\n        }\n    }\n\n    function calcReward(address synth, address member) public view returns(uint reward) {\n        uint _weight = mapMember_weight[member];  \n        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){\n            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      // Aggregrate reserves\n            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   // Get member's share of that\n        } else{\n            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();\n            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          \n        }\n    }\n\n    //====================================== WITHDRAW ========================================//\n\n    // Members to withdraw\n    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {\n        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          // Get amount to withdraw\n        sendFunds(synth, msg.sender, redeemedAmount);\n    }\n    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {\n        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, \"DepositTime\");    // stops attacks\n        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Share of deposits\n        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  // Reduce for member                             \n        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   // Find recorded weight to reduce\n        mapMember_weight[_member] -= _weight;                                   // Reduce for member \n        totalWeight -= _weight;                                                 // Reduce for total\n        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   // Event\n    }\n\n    //============================== ASSETS ================================//\n\n    function getFunds(address synth, uint amount) internal {\n        if(tx.origin==msg.sender){\n            require(iERC20(synth).transferTo(address(this), amount));\n        }else{\n            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));\n        }\n    }\n    function sendFunds(address synth, address member, uint amount) internal {\n        require(iERC20(synth).transfer(member, amount));\n    }\n\n    //============================== HELPERS ================================//\n\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this)); // Balance\n    }\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this)); // Balance\n    }\n\n    function getMemberDeposit(address synth, address member) external view returns(uint){\n        return mapMemberSynth_deposit[member][synth];\n    }\n    function getMemberWeight(address member) external view returns(uint){\n        return mapMember_weight[member];\n    }\n    function getMemberLastTime(address synth, address member) external view returns(uint){\n        return mapMemberSynth_lastTime[member][synth];\n    }\n\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\nimport \"./Synth.sol\"; \n\n// Factory Contract\ncontract Factory {\n\n    bool private inited;\n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    address[] public arraySynths;\n    mapping(address => address) public getSynth;\n    mapping(address => bool) public isSynth;\n\n    event CreateSynth(address indexed token, address indexed pool);\n\n    modifier onlyPOOLS() {\n        require(msg.sender == POOLS, \"!POOLS\");\n        _;\n    }\n    \n    constructor(){\n    }\n    function init(address _pool) public {\n        require(inited == false);\n        inited = true;\n        POOLS = _pool;\n    }\n\n    //Create a synth asset\n    function deploySynth(address token) external onlyPOOLS returns(address synth) {\n        require(getSynth[token] == address(0), \"CreateErr\");\n        Synth newSynth;\n        newSynth = new Synth(token);  \n        synth = address(newSynth);\n        _addSynth(token, synth);\n        emit CreateSynth(token, synth);\n    }\n\n    function mintSynth(address synth, address member, uint amount) external onlyPOOLS returns(bool) {\n         Synth(synth).mint(member, amount); \n        return true;\n    }\n\n    // function getSynth(address token) public view returns (address synth){\n    //     return mapToken_Synth[token];\n    // }\n    // function isSynth(address token) public view returns (bool _isSynth){\n    //     if(_isListedSynth[token] == true){\n    //         return true;\n    //     }\n    // }\n\n    function _addSynth(address _token, address _synth) internal {\n        getSynth[_token] = _synth;\n        arraySynths.push(_synth); \n        isSynth[_synth] = true;\n    }\n\n}\n\n",
        "CodeNames": [
            "Vault.sol",
            "Pools.sol",
            "Router.sol",
            "Factory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-18",
                "Location": [
                    "calcReward",
                    "TOKEN",
                    "_weight",
                    "synth",
                    "_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);",
                    "deploySynth(customToken)",
                    "_deposit",
                    "harvest(realSynth)"
                ],
                "Type": "  Vault rewards can be gamed",
                "Description": "\nThe _deposit function increases the member's _weight_ by _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount); which is the swap output amount when trading the deposited underlying synth amount.\n\nNotice that anyone can create synths of custom tokens by calling Pools.deploySynth(customToken).\n\nTherefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:\n\n1. Create a custom token and issue lots of tokens to the attacker\n2. Create synth of this token\n3. Add liquidity for the TOKEN < BASE pair by providing a single wei of TOKEN and 10^18 BASE tokens. This makes the TOKEN price very expensive.\n4. Mint some synths by paying BASE to the pool\n5. Deposit the fake synth, _weight will be very high because the token pool price is so high.\n\nCall harvest(realSynth) with a synth with actual value. This will increase the synth balance and it can be withdrawn later.\n\nAnyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling harvest(realSynth) with a valuable \"real\" synth.\nThe rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.\n\nThe calcReward function completely disregards the synth parameter which seems odd.\n",
                "Repair": "Recommend thinking about making the rewards based on the actual synths deposited instead of a \"global\" weight tracker.\nAlternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/222#issuecomment-828453323):\n  This is a valid attack path.\n\n The counter is two fold:\n\n 1) In the vault, require(isCurated(token)) this will only allow synths of curated tokens to be deposited for rewards. The curation logic (https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L234) does a check for liquidity depth, so only deep pools can become synths. Thus an attacker would need to deposit a lot of BASE.\n\n 2) In the vaults, use _weight = iUTILS(UTILS()).calcSwapValueInBase(iSYNTH(_synth).TOKEN(), _amount);, which computes the weight with respect to slip, so a small manipulated pool cannot be eligible. The pool would need to be deep.\n\n ---\n\n The Vault converts all synths back to common accounting asset USDV, so member weight can be tracked.\n\nstrictly-scarce (vader) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/222#issuecomment-830635200):\n  Disagree with severity, since the daily rewards can be claimed by anyone in a fee-bidding war but no actual extra inflation occurs.\n\n Severity: 2\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.3;\n\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\ncontract Vault {\n\n    bool private inited;\n    uint public erasToEarn;\n    uint public minGrantTime;\n    uint public lastGranted;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    uint public minimumDepositTime;\n    uint public totalWeight;\n\n    mapping(address => uint) private mapMember_weight;\n    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;\n    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;\n\n    // Events\n    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    constructor(){}\n\n    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {\n        require(inited == false);\n        inited = true;\n        POOLS = _pool;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n        POOLS = _pool;\n        erasToEarn = 100;\n        minimumDepositTime = 1;\n        minGrantTime = 2592000;     // 30 days\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {\n        erasToEarn = newEra;\n        minimumDepositTime = newDepositTime;\n        minGrantTime = newGrantTime;\n    }\n\n    // Can issue grants\n    function grant(address recipient, uint amount) public onlyDAO {\n        require((block.timestamp - lastGranted) >= minGrantTime, \"not too fast\");\n        lastGranted = block.timestamp;\n        iERC20(USDV).transfer(recipient, amount); \n    }\n\n    //======================================DEPOSITS========================================//\n\n    // Deposit USDV or SYNTHS\n    function deposit(address synth, uint amount) external {\n        depositForMember(synth, msg.sender, amount);\n    }\n    // Wrapper for contracts\n    function depositForMember(address synth, address member, uint amount) public {\n        require((iFACTORY(FACTORY).isSynth(synth)), \"Not Synth\"); // Only Synths\n        getFunds(synth, amount);\n        _deposit(synth, member, amount);\n    }\n    function _deposit(address _synth, address _member, uint _amount) internal {\n        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         // Time of deposit\n        mapMemberSynth_deposit[_member][_synth] += _amount;                 // Record deposit\n        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);\n        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){\n            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               // Price in USDV\n        }\n        mapMember_weight[_member] += _weight;                               // Total member weight \n        totalWeight += _weight;                                             // Total weight \n        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);\n    }\n\n    //====================================== HARVEST ========================================//\n\n    // Harvest, get payment, allocate, increase weight\n    function harvest(address synth) external returns(uint reward) {\n        address _member = msg.sender;\n        uint _weight;\n        address _token = iSYNTH(synth).TOKEN();\n        reward = calcCurrentReward(synth, _member);                     // In USDV\n        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      // Reset time\n        if(iPOOLS(POOLS).isAsset(_token)){\n            iERC20(USDV).transfer(POOLS, reward); \n            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));\n            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);\n        } else {\n            iERC20(VADER).transfer(POOLS, reward); \n            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));\n            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));\n        }\n        mapMemberSynth_deposit[_member][synth] += reward; \n        mapMember_weight[_member] += _weight;\n        totalWeight += _weight;\n        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);\n    }\n\n    // Get the payment owed for a member\n    function calcCurrentReward(address synth, address member) public view returns(uint reward) {\n        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        // Get time since last claim\n        uint _share = calcReward(synth, member);                                               // Get share of rewards for member\n        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         // Get owed amount, based on per-day rates\n        uint _reserve;\n        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){\n            _reserve = reserveUSDV();\n        } else {\n            _reserve = reserveVADER();\n        }\n        if(reward >= _reserve) {\n            reward = _reserve;                                                          // Send full reserve if the last\n        }\n    }\n\n    function calcReward(address synth, address member) public view returns(uint reward) {\n        uint _weight = mapMember_weight[member];  \n        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){\n            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      // Aggregrate reserves\n            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   // Get member's share of that\n        } else{\n            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();\n            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          \n        }\n    }\n\n    //====================================== WITHDRAW ========================================//\n\n    // Members to withdraw\n    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {\n        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          // Get amount to withdraw\n        sendFunds(synth, msg.sender, redeemedAmount);\n    }\n    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {\n        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, \"DepositTime\");    // stops attacks\n        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Share of deposits\n        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  // Reduce for member                             \n        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   // Find recorded weight to reduce\n        mapMember_weight[_member] -= _weight;                                   // Reduce for member \n        totalWeight -= _weight;                                                 // Reduce for total\n        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   // Event\n    }\n\n    //============================== ASSETS ================================//\n\n    function getFunds(address synth, uint amount) internal {\n        if(tx.origin==msg.sender){\n            require(iERC20(synth).transferTo(address(this), amount));\n        }else{\n            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));\n        }\n    }\n    function sendFunds(address synth, address member, uint amount) internal {\n        require(iERC20(synth).transfer(member, amount));\n    }\n\n    //============================== HELPERS ================================//\n\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this)); // Balance\n    }\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this)); // Balance\n    }\n\n    function getMemberDeposit(address synth, address member) external view returns(uint){\n        return mapMemberSynth_deposit[member][synth];\n    }\n    function getMemberWeight(address member) external view returns(uint){\n        return mapMember_weight[member];\n    }\n    function getMemberLastTime(address synth, address member) external view returns(uint){\n        return mapMemberSynth_lastTime[member][synth];\n    }\n\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n\n}\n\n",
        "CodeNames": [
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-19",
                "Location": [
                    "calcCurrentReward",
                    "_secondsSinceClaim",
                    "mapMemberSynth_lastTime[member][synth]",
                    "harvest"
                ],
                "Type": " Vault rewards last claim time not always initialized",
                "Description": "\nThe harvest calls calcCurrentReward which computes _secondsSinceClaim = block.timestamp mapMemberSynth_lastTime[member][synth];.  As one can claim different synths than the synths that they deposited, mapMemberSynth_lastTime[member][synth] might still be uninitialized and the _secondsSinceClaim becomes the current block timestamp.\n\nThe larger the _secondsSinceClaim the larger the rewards.\nThis bug allows claiming a huge chunk of the rewards.\n\n",
                "Repair": "Recommend letting users only harvest synths that they deposited.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/223#issuecomment-828461277):\n  This is valid.\n\n The member should only claim against synths they have deposited, where the time would be initialised.\n\n\nstrictly-scarce (vader) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/223#issuecomment-830635006):\n  Would place this as severity: 2, since the anyone can participate in claiming rewards, but no extra inflation occurs.\n\n\n\n"
            },
            {
                "Name": "H-20",
                "Location": [
                    "_processWithdraw(synth, member, basisPoints=",
                    "mapMember_weight[_member]"
                ],
                "Type": " Vault Weight accounting is wrong for withdrawals",
                "Description": "\n\nWhen depositing two different synths, their weight is added to the same mapMember_weight[_member] storage variable.\nWhen withdrawing the full amount of one synth with _processWithdraw(synth, member, basisPoints=10000 the full weight is decreased.\n\nThe second deposited synth is now essentially weightless.\n\nUsers that deposited more than one synth can not claim their fair share of rewards after a withdrawal.\n\nRecommed that the weight should be indexed by the synth as well.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-828457510):\n  This is valid.\n\n The weight should be reduced only as applied to a specific synth\n\n There is no loss of funds, just less rewards for that member, disputing severity level.\n\nMervyn853 commented(https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-830578796):\n  Our decision matrix for severity:\n\n 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n 1: Low Risk: UX, state handling, function incorrect as to spec\n 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n\n Recommended: 2\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-849037439):\n  My viewpoint on this and the last several reward based high risk issues is that loss of rewards is loss of funds. High risk is appropriate.\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iVETHER.sol\";\n\n// Token Contract\ncontract Vether is iVETHER {\n\n    // Coin Defaults\n    string public override name;                                         // Name of Coin\n    string public override symbol;                                       // Symbol of Coin\n    uint public override decimals  = 18;                              // Decimals\n    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   // 1,000,000 Total\n\n    uint public totalFees;\n    mapping(address=>bool) public mapAddress_Excluded;  \n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    \n    // Minting event\n    constructor() {\n        name = \"Vether\";\n        symbol  = \"VETH\";\n        _balances[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"iERC20: approve from the zero address\");\n        require(spender != address(0), \"iERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n       // Internal transfer function which includes the Fee\n    function _transfer(address _from, address _to, uint _value) private {\n        require(_balances[_from] >= _value, 'Must not send more than balance');\n        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');\n        _balances[_from] -= _value;\n        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount\n        _balances[_to] += (_value - _fee);                                               // Add to receiver\n        _balances[address(this)] += _fee;                                                   // Add fee to self\n        totalFees += _fee;                                                                  // Track fees collected\n        emit Transfer(_from, _to, (_value - _fee));                                      // Transfer event\n        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {\n            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event\n        }\n    }\n    \n    // Calculate Fee amount\n    function _getFee(address _from, address _to, uint _value) private view returns (uint) {\n        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {\n           return 0;                                                                        // No fee if excluded\n        } else {\n            return (_value / 1000);                                                         // Fee amount = 0.1%\n        }\n    }\n\n    function addExcluded(address excluded) public {\n        mapAddress_Excluded[excluded] = true;\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract Attack {\n    bool private inited;\n    address public VADER;\n    address public USDV;\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    function init(address _vader, address _USDV) public {\n        require(inited == false);\ninited = true;\n        VADER = _vader;\n        USDV = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function attackUSDV(uint amount) public {\n        iERC20(VADER).approve(USDV, amount);\n        iERC20(USDV).approve(USDV, amount);\n        iERC20(VADER).transferTo(address(this), amount); // get VADER funds\n        iUSDV(USDV).convert(amount); // Convert to USDV back to this address\n        iUSDV(USDV).redeem(amount); // Burn USDV back to VADER to this address\n    }\n}\n\n",
        "CodeNames": [
            "Vether.sol",
            "Attack.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-21",
                "Location": [
                    "Vether.addExcluded(aliceAddress)"
                ],
                "Type": " Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether  ExcludedAddresses  List.",
                "Description": "\nVether.sol implements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses (mapAddress_Excluded). However, the addExcluded() function in Vether.sol has no restrictions on who can call it.\nSo any user can call addExcluded with their own address as the argument, and bypass all transfer fees.\n\nAlice calls:\n\n(1) Vether.addExcluded(aliceAddress), which adds Alice's address to mapAddress_Excluded.\n(2) Alice can now freely transfer Vether with no fees.\n\n",
                "Repair": "Recommend adding restrictions to who can call addExcluded, perhaps by restricting it to a caller set by DAO.sol\n\nstrictly-scarce (vader) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/189#issuecomment-830609051):\n  Vether contract is outside of contest\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/189#issuecomment-849162113):\n  https://github.com/code-423n4/2021-04-vader-findings/issues/3#issuecomment-849043144\n\n  The warden should be paid out on this issue, in my opinion, because the code was included in the repo to be reviewed. The work to review the contract was done despite the fact that the team has addressed the issue and has already deployed vether.sol. I do not think that any issues related to Vether.sol should be included in the final report generated by @code423n4.\n\n It was unclear to me (and obviously most of the wardens) that Vether.sol was considered out of scope.\n\nmoneylegobatman (C4 Editor) commented:\n Leaving report and discussion in for transparency, since finding was awarded.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n",
        "CodeNames": [
            "Pools.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-22",
                "Location": [
                    "removeLiquidity"
                ],
                "Type": " Users may unintentionally remove liquidity under a phishing attack.",
                "Description": "The removeLiquidity function in Pools.sol uses tx.origin to determine the person who wants to remove liquidity. However, such a design is dangerous since the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack, and he could unintentionally remove liquidity.\n\nReferenced code: Pool.sol#L77-L79(https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L77-L79)\n\n",
                "Repair": "Recommend consider making the function _removeLiquidity external, which can be utilized by the router, providing information of which person removes his liquidity.\n\nstrictly-scarce (vader) acknowledged(https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-830571343):\n  If a user has been phished, consider all their funds already stolen.\n\n Vader's security assumption is a user is not phished.\n\nMervyn853 commented(https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-830578243):\n  Our decision matrix for severity:\n\n 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n 1: Low Risk: UX, state handling, function incorrect as to spec\n 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n\n Recommended: 0\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-849061196):\n  This is reasonably easy to mitigate as an issue and failure to do so does leave an attack vector open. If exploited it will result in a loss of user funds.\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "removeLiquidityDirectly()",
                    "removeLiquidity()"
                ],
                "Type": " User may not get IL protection if certain functions are called directly in  Pools.sol ",
                "Description": "\nFunctions removeLiquidity() and removeLiquidityDirectly() when called directly, do not provide the the user with IL protection unlike when calling the corresponding removeLiquidity() function in Router.sol. This should be prevented, at least for removeLiquidity() or highlighted in the specification and user documentation.\n\n",
                "Repair": "Recommend adding access control (e.g. via a modifier onlyRouter) so removeLiquidity() function of Pools contract can be called only from corresponding Router contract\u2019s removeLiquidity() function which provides IL protection. Alternatively, highlight in the specification and user documentation about which contract interfaces provide IL protection to users.\n\nstrictly-scarce (vader) acknowledged(https://github.com/code-423n4/2021-04-vader-findings/issues/120#issuecomment-830613596):\n  User should use the Router, as designed.\n\n\n"
            },
            {
                "Name": "M-14",
                "Location": [],
                "Type": " Pool functions can be called before initialization in _ init_()  of Pools.sol",
                "Description": "\nAll the external/public functions of Pools.sol can be called by other contracts even before Pools.solcontract is initialized. This can lead to exceptions, state corruption or incorrect accounting in other contracts, which may require redeployment of said contract.\n\n",
                "Repair": "Recommend using a factory pattern that will deploy and initialize atomically to prevent front-running of the initialization,\n\nOR\n\nGiven that contracts are not using delegatecall proxy pattern, it is not required to use a separate init() function to initialize parameters when the same can be done in a constructor. If the reason for doing so is to get the deployment addresses of the various contracts, which may not all be available at the same time, then consider rearchitecting to create a \u201cglobals\u201d contract which can hold all the globally required addresses of various contracts. see Maple protocol\u2019s(https://github.com/maple-labs/maple-core/blob/develop/contracts/MapleGlobals.sol) for example.\n\nOR\n\nPrevent external/public functions from being called until after initialization is done by checking initialization state tracked by the inited variable.\n\nstrictly-scarce (vader) dipsuted(https://github.com/code-423n4/2021-04-vader-findings/issues/114#issuecomment-830598388):\n  https://github.com/code-423n4/2021-04-vader-findings/issues/39\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/114#issuecomment-847769580):\n  Same general comments apply to this issue as with issue #18, but it is a separate type of exploit that would be slightly less detectable. This increase in risk is balanced against the exploit being much harder to effect and the likely impact being lower.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\ncontract USDV is iERC20 {\n\n    // ERC-20 Parameters\n    string public override name; string public override symbol;\n    uint public override decimals; uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Parameters\n    bool private inited;\n    uint public nextEraTime;\n    uint public blockDelay;\n\n    address public VADER;\n    address public VAULT;\n    address public ROUTER;\n\n    mapping(address => uint) public lastBlock;\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n    // Stop flash attacks\n    modifier flashProof() {\n        require(isMature(), \"No flash\");\n        _;\n    }\n    function isMature() public view returns(bool isMatured){\n        if(lastBlock[tx.origin] + blockDelay <= block.number){ // Stops an EOA doing a flash attack in same block\n            return true;\n        }\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n        name = 'VADER STABLE DOLLAR';\n        symbol = 'USDV';\n        decimals = 18;\n        totalSupply = 0;\n    }\n    function init(address _vader, address _vault, address _router) external {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        VAULT = _vault;\n        ROUTER = _router;\n        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();\n    }\n\n    //========================================iERC20=========================================//\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(sender != address(0), \"sender\");\n            _balances[sender] -= amount;\n            _balances[recipient] += amount;\n            emit Transfer(sender, recipient, amount);\n            _checkIncentives();\n        }\n    }\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(account != address(0), \"recipient\");\n            totalSupply += amount;\n            _balances[account] += amount;\n            emit Transfer(address(0), account, amount);\n        }\n    }\n    // Burn supply\n    function burn(uint amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) external virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender)- amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(account != address(0), \"address err\");\n            _balances[account] -= amount;\n            totalSupply -= amount;\n            emit Transfer(account, address(0), amount);\n        }\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newDelay) external onlyDAO {\n        blockDelay = newDelay;\n    }\n\n   //======================================INCENTIVES========================================//\n    // Internal - Update incentives function\n    function _checkIncentives() private {\n        if (block.timestamp >= nextEraTime && emitting()) {                 // If new Era\n            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _balance = iERC20(VADER).balanceOf(address(this));         // Get spare VADER\n            if(_balance > 4){\n                uint _USDVShare = _balance/2;                                   // Get 50%\n                _convert(address(this), _USDVShare);                            // Convert it\n                if(balanceOf(address(this)) > 2){\n                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              // Send half USDV to ROUTER\n                    _transfer(address(this), VAULT, balanceOf(address(this)));                   // Send rest to VAULT\n                }\n                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   // Send half VADER to ROUTER\n                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      // Send rest to VAULT\n            }\n        }\n    }\n    \n    //======================================ASSET MINTING========================================//\n    // Convert to USDV\n    function convert(uint amount) external returns(uint) {\n        return convertForMember(msg.sender, amount);\n    }\n    // Convert for members\n    function convertForMember(address member, uint amount) public returns(uint) {\n        getFunds(VADER, amount);\n        return _convert(member, amount);\n    }\n    // Internal convert\n    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){\n        if(minting()){\n            lastBlock[tx.origin] = block.number;                    // Record first\n            iERC20(VADER).burn(amount);\n            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); // Critical pricing functionality\n            _mint(_member, _convertAmount);\n        }\n    }\n    // Redeem to VADER\n    function redeem(uint amount) external returns(uint) {\n        return redeemForMember(msg.sender, amount);\n    }\n    // Contracts to redeem for members\n    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {\n        _transfer(msg.sender, VADER, amount);                   // Move funds\n        redeemAmount = iVADER(VADER).redeemToMember(member);    // Ask VADER to redeem\n        lastBlock[tx.origin] = block.number;                    // Must record block AFTER the tx\n    }\n\n    //============================== ASSETS ================================//\n\n    function getFunds(address token, uint amount) internal {\n        if(token == address(this)){\n            _transfer(msg.sender, address(this), amount);\n        } else {\n            if(tx.origin==msg.sender){\n                require(iERC20(token).transferTo(address(this), amount));\n            }else{\n                require(iERC20(token).transferFrom(msg.sender, address(this), amount));\n            }\n        }\n    }\n\n    //============================== HELPERS ================================//\n\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function minting() public view returns(bool){\n        return iVADER(VADER).minting();\n    }\n\n}\n\n",
        "CodeNames": [
            "USDV.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "flashProof"
                ],
                "Type": "  flashProof  is not flash-proof",
                "Description": "\nThe flashProof modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.\n\nHowever, it performs this check on tx.origin and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.\n\nBut flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction _bundles_ similar to flashbot bundles that most mining pools currently offer.)\n\nA miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the tx.origin restriction.\n\nThe flashProof modifier does not serve its purpose.\n\n",
                "Repair": "Recommend trying to apply the modifier to individual addresses that interact with the protocol instead of tx.origin.\n\nFurthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/218#issuecomment-830616044):\n  Flash loans with the help of miners *was not intended to be countered*, although a check for msg.sender AND tx.origin will be applied.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    //====================================PRICING====================================//\n\n    function calcValueInBase(address token, uint amount) public view returns (uint value){\n       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n       if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _baseAmt) / _tokenAmt;\n       }\n    }\n\n    function calcValueInToken(address token, uint amount) public view returns (uint value){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _tokenAmt) / _baseAmt;\n       }\n    }\n    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){\n            return calcValueInToken(token2, calcValueInBase(token1, amount));\n    }\n\n    function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n    }\n    function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n    }\n\n    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {\n        uint _testingPrice = calcValueInBase(token, one);\n        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price\n        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price\n        if(inside){\n            require((_testingPrice >= _lower && _testingPrice <= _upper), \"Not inside\");\n        } else {\n            require((_testingPrice <= _lower || _testingPrice >= _upper), \"Not outside\");\n        }\n    }\n\n    //====================================INCENTIVES========================================//\n\n    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {\n        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){\n            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);\n            if (iPOOLS(POOLS).isAsset(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            } else if(iPOOLS(POOLS).isAnchor(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            }\n        }\n    }\n\n    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {\n        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n\n    // Actual protection with 100 day rule and Reserve balance\n    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {\n        uint _coverage = getCoverage(member, token);\n        if(iROUTER(ROUTER).isCurated(token)){\n            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);\n            if(_duration <= timeForFullProtection) {\n                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule\n            } else {\n                protection = _coverage;\n            }\n        }\n        return calcPart(basisPoints, protection);\n    }\n    // Theoretical coverage based on deposit/redemption values\n    function getCoverage(address member, address token) public view returns (uint) {\n        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);\n        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);\n        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));\n        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));\n        return calcCoverage(_B0, _T0, _B1, _T1);\n    }\n\n    //==================================== LENDING ====================================//\n\n    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n        if(isBase(collateralAsset)){\n            baseValue = _collateralAdjusted;\n        }else if(isPool(collateralAsset)){\n            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\n            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n        }\n        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output\n        return (debt, baseValue);\n    }\n\n    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {\n        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt\n        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral\n        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);\n        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);\n        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral\n        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); \n        return (_collateralUnlocked, _memberInterestShare);\n    }\n\n    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {\n        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year\n        if(isBase(collateralAsset)){\n            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base\n        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {\n            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)\n        }\n    }\n    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);\n        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; \n    }\n    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);\n        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);\n        return (_debtIssued * 10000) / _debtDepth; \n    }\n\n    //====================================CORE-MATH====================================//\n\n    function calcPart(uint bp, uint total) public pure returns (uint){\n        // 10,000 basis points = 100.00%\n        require((bp <= 10000) && (bp >= 0), \"Must be correct BP\");\n        return calcShare(bp, 10000, total);\n    }\n\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n        // share = amount * part/total\n        if(part > total){\n            part = total;\n        }\n        if(total > 0){\n            share = (amount * part) / total;\n        }\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = (x * X * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){\n        // fee = (x * x * Y) / (x + X)^2\n        uint numerator = (x * x * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n    function calcSwapSlip(uint x, uint X) external pure returns (uint){\n        // slip = (x) / (x + X)\n        return (x*10000) / (x + X);\n    }\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){\n        // (P * b)/(2*(b + B))\n        return (P * b) / (2 * (b + B));\n    }\n\n    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }\n    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n        if(B0 > 0 && T1 > 0){\n            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\n            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\n            if(_redemptionValue <= _depositValue){\n                coverage = (_depositValue - _redemptionValue);\n            }\n        }\n    }\n\n    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)\n    function sortArray(uint[] memory array) external pure returns (uint[] memory) {\n        uint l = array.length;\n        for(uint i = 0; i < l; i++){\n            for(uint j = i+1; j < l; j++){\n                if(array[i] > array[j]){\n                    uint temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        return array;\n    }\n\n}\n\n",
        "CodeNames": [
            "Pools.sol",
            "Utils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nuint256 _interestPayment =\n  calcShare(\n      timeElapsed,\n      _year,\n      getInterestPayment(collateralAsset, debtAsset)\n  ); // Share of the payment over 1 year\n"
                ],
                "Type": " Interest debt is capped after a year",
                "Description": "\nThe Utils.getInterestOwed function computes the _interestPayment as:\n\nsolidity\nuint256 _interestPayment =\n  calcShare(\n      timeElapsed,\n      _year,\n      getInterestPayment(collateralAsset, debtAsset)\n  ); // Share of the payment over 1 year\n\n\nHowever, calcShare caps timeElpased to _year and therefore the owed interest does not grow after a year has elapsed.\n\nThe impact is probably small because the only call so far computes the elapsed time as block.timestamp mapCollateralAsset_NextEra[collateralAsset][debtAsset]; which most likely will never go beyond a year.\n\nIt's still recommended to fix the logic bug in case more functions will be added that use the broken function.\n\n",
                "Repair": "Recommend using a different function than calcShare that does not cap.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/219#issuecomment-830616264):\n  A member who doesn't interact with the contract for more than a year misses out on some rewards, so severity:1\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [
                    "\n uint _units = (((P * part1) + part2) / part3);\n     return (_units * slipAdjustment) / one;  // Divide by 1018\n  ",
                    "\n  // returns 0\n   return (0 * 1018) / 1018;\n   return (2256 * 0) / 1018;\n  return (<109 * <109) / 1018;\n    // returns  non-zero\n   return (=109 * =109) / 1018;\n  "
                ],
                "Type": " Divide before multiply",
                "Description": "\nHere you have more information: https://gist.github.com/alexon1234/e5038a9f66136ae210be692f8803d874\n\nstrictly-scarce (vader) questioned(https://github.com/code-423n4/2021-04-vader-findings/issues/255#issuecomment-830631408):\n  Can't quite understand the assertion that a division is made before a multiply in the code outlined\n\n \n uint _units = (((P * part1) + part2) / part3);\n     return (_units * slipAdjustment) / one;  // Divide by 1018\n  \n\n  _units will be 0 - 2256.\n  slipAdjustment will be 0 - 1018\n  one is 1018\n  \n  // returns 0\n   return (0 * 1018) / 1018;\n   return (2256 * 0) / 1018;\n  return (<109 * <109) / 1018;\n    // returns  non-zero\n   return (=109 * =109) / 1018;\n  \n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract Attack {\n    bool private inited;\n    address public VADER;\n    address public USDV;\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    function init(address _vader, address _USDV) public {\n        require(inited == false);\ninited = true;\n        VADER = _vader;\n        USDV = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function attackUSDV(uint amount) public {\n        iERC20(VADER).approve(USDV, amount);\n        iERC20(USDV).approve(USDV, amount);\n        iERC20(VADER).transferTo(address(this), amount); // get VADER funds\n        iUSDV(USDV).convert(amount); // Convert to USDV back to this address\n        iUSDV(USDV).redeem(amount); // Burn USDV back to VADER to this address\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\nimport \"./Synth.sol\"; \n\n// Factory Contract\ncontract Factory {\n\n    bool private inited;\n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    address[] public arraySynths;\n    mapping(address => address) public getSynth;\n    mapping(address => bool) public isSynth;\n\n    event CreateSynth(address indexed token, address indexed pool);\n\n    modifier onlyPOOLS() {\n        require(msg.sender == POOLS, \"!POOLS\");\n        _;\n    }\n    \n    constructor(){\n    }\n    function init(address _pool) public {\n        require(inited == false);\n        inited = true;\n        POOLS = _pool;\n    }\n\n    //Create a synth asset\n    function deploySynth(address token) external onlyPOOLS returns(address synth) {\n        require(getSynth[token] == address(0), \"CreateErr\");\n        Synth newSynth;\n        newSynth = new Synth(token);  \n        synth = address(newSynth);\n        _addSynth(token, synth);\n        emit CreateSynth(token, synth);\n    }\n\n    function mintSynth(address synth, address member, uint amount) external onlyPOOLS returns(bool) {\n         Synth(synth).mint(member, amount); \n        return true;\n    }\n\n    // function getSynth(address token) public view returns (address synth){\n    //     return mapToken_Synth[token];\n    // }\n    // function isSynth(address token) public view returns (bool _isSynth){\n    //     if(_isListedSynth[token] == true){\n    //         return true;\n    //     }\n    // }\n\n    function _addSynth(address _token, address _synth) internal {\n        getSynth[_token] = _synth;\n        arraySynths.push(_synth); \n        isSynth[_synth] = true;\n    }\n\n}\n\n",
        "CodeNames": [
            "Attack.sol",
            "Factory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-10",
                "Location": [
                    "require()",
                    "deploySynth()"
                ],
                "Type": " Incorrect operator used in  deploySynth()  of  Pools.sol ",
                "Description": "\nThe deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory\u2019s deploySynth() function.\n\nHowever, the require() incorrectly uses the \u2018||\u2019 operator instead of \u2018&&\u2019 which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.\n\n",
                "Repair": "Recommend changing \u2018||\u2019 operator to \u2018&&\u2019 in the require statement:\nrequire(token != VADER && token != USDV);\n\nstrictly-scarce (vader) addressed(https://github.com/code-423n4/2021-04-vader-findings/issues/124#issuecomment-830601704):\n  Duplicate\n https://github.com/code-423n4/2021-04-vader-findings/issues/21\n\n0xBrian commented(https://github.com/code-423n4/2021-04-vader-findings/issues/124#issuecomment-837805692):\n  https://github.com/vetherasset/vaderprotocol-contracts/pull/159/commits/2f69f8317ce98846fbe227a3bf6ca1b644d01ff2#diff-5de3130299a0ddc914d7a906802a4cc093ed18d7a89c52a4aafefc8a11ac3f54R193\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iVETHER.sol\";\n\n// Token Contract\ncontract Vether is iVETHER {\n\n    // Coin Defaults\n    string public override name;                                         // Name of Coin\n    string public override symbol;                                       // Symbol of Coin\n    uint public override decimals  = 18;                              // Decimals\n    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   // 1,000,000 Total\n\n    uint public totalFees;\n    mapping(address=>bool) public mapAddress_Excluded;  \n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    \n    // Minting event\n    constructor() {\n        name = \"Vether\";\n        symbol  = \"VETH\";\n        _balances[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"iERC20: approve from the zero address\");\n        require(spender != address(0), \"iERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n       // Internal transfer function which includes the Fee\n    function _transfer(address _from, address _to, uint _value) private {\n        require(_balances[_from] >= _value, 'Must not send more than balance');\n        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');\n        _balances[_from] -= _value;\n        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount\n        _balances[_to] += (_value - _fee);                                               // Add to receiver\n        _balances[address(this)] += _fee;                                                   // Add fee to self\n        totalFees += _fee;                                                                  // Track fees collected\n        emit Transfer(_from, _to, (_value - _fee));                                      // Transfer event\n        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {\n            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event\n        }\n    }\n    \n    // Calculate Fee amount\n    function _getFee(address _from, address _to, uint _value) private view returns (uint) {\n        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {\n           return 0;                                                                        // No fee if excluded\n        } else {\n            return (_value / 1000);                                                         // Fee amount = 0.1%\n        }\n    }\n\n    function addExcluded(address excluded) public {\n        mapAddress_Excluded[excluded] = true;\n    }\n}\n\n",
        "CodeNames": [
            "Vether.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [],
                "Type": " Transfer fee avoidance ",
                "Description": "\nThe Vether4.addExcluded() function on mainnet (0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279) allows a user to exclude an address from transfer fees for a cost of 128 VETH. By exploiting the conditions in which fees are taken, it is possible to set up a contract for a once-off cost in which all users can use to avoid transfer fees.\n\n#All transfer fees can be avoided by routing transfers through an excluded contract. An estimated $140k of transfer fees was accumulated at the time of writing. These fees can be avoided in future, causing an indirect loss of funds for the contract.\n\n",
                "Repair": "Recommend that the _transfer() function should be updated to only exclude transfer fees if the sender has been excluded, not both the sender and the recipient. This would prevent any user from being able to set up a central transfer forwarder as demonstrated. Moreover, the Transfer(_from, address(this), _fee); event should only be emitted if the sender has been excluded from transfer fees.\n\nstrictly-scarce (vader) disputed(https://github.com/code-423n4/2021-04-vader-findings/issues/33)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\n    //======================================VADER=========================================//\ncontract Attack {\n    bool private inited;\n    address public VADER;\n    address public USDV;\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    function init(address _vader, address _USDV) public {\n        require(inited == false);\ninited = true;\n        VADER = _vader;\n        USDV = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function attackUSDV(uint amount) public {\n        iERC20(VADER).approve(USDV, amount);\n        iERC20(USDV).approve(USDV, amount);\n        iERC20(VADER).transferTo(address(this), amount); // get VADER funds\n        iUSDV(USDV).convert(amount); // Convert to USDV back to this address\n        iUSDV(USDV).redeem(amount); // Burn USDV back to VADER to this address\n    }\n}\n\n",
        "CodeNames": [
            "Attack.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-13",
                "Location": [
                    "\nDAO.sol:    function init(address _vader, address _usdv, address _vault) public {\nFactory.sol:    function init(address _pool) public {\nPools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public {\nRouter.sol:    function init(address _vader, address _usdv, address _pool) public {\nUSDV.sol:    function init(address _vader, address _vault, address _router) external {\nUtils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\nVader.sol:    function init(address _vether, address _USDV, address _utils) external {\nVault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {\n"
                ],
                "Type": " Init function can be called by everyone",
                "Description": "\nMost of the solidity contracts have an init function that everyone can call.\nThis could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.\n\n\nDAO.sol:    function init(address _vader, address _usdv, address _vault) public {\nFactory.sol:    function init(address _pool) public {\nPools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public {\nRouter.sol:    function init(address _vader, address _usdv, address _pool) public {\nUSDV.sol:    function init(address _vader, address _vault, address _router) external {\nUtils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\nVader.sol:    function init(address _vether, address _USDV, address _utils) external {\nVault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {\n\n\n",
                "Repair": "Recommend adding a check to the init function, for example that only the deployer can call the function.\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/18#issuecomment-826910451):\n  Yes, but only once. Could add a deployer check tho\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-04-vader-findings/issues/18#issuecomment-847760153):\n  After considerable evaluation and seeing the wide range of threat factors that were put forward by wardens related to this issue, I've decided that the potential threat here does extend beyond gas.\n\n A worst case scenario could cause significant damage.\n\n It is extremely unlikely that an attacker could successfully time this type of attack.\n\n An attacker would have to successfully intercept more than one init due to the highly coupled nature of the contract. If they did so incorrectly, the entire system would not function. Presuming they succeeded, the team would also have to overlook the failure of or forget to make multiple critical transaction calls in their deployment scripts. To realize significant financial gains, the attacker would have to leave their exploit code in place for an extended period of time.\n\n The likelihood is extremely low, but the impact would be critical. For this reason, I'm normalizing all of these reports to a Medium Risk.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.3;\n\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\ncontract Vault {\n\n    bool private inited;\n    uint public erasToEarn;\n    uint public minGrantTime;\n    uint public lastGranted;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    uint public minimumDepositTime;\n    uint public totalWeight;\n\n    mapping(address => uint) private mapMember_weight;\n    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;\n    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;\n\n    // Events\n    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    constructor(){}\n\n    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {\n        require(inited == false);\n        inited = true;\n        POOLS = _pool;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n        POOLS = _pool;\n        erasToEarn = 100;\n        minimumDepositTime = 1;\n        minGrantTime = 2592000;     // 30 days\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {\n        erasToEarn = newEra;\n        minimumDepositTime = newDepositTime;\n        minGrantTime = newGrantTime;\n    }\n\n    // Can issue grants\n    function grant(address recipient, uint amount) public onlyDAO {\n        require((block.timestamp - lastGranted) >= minGrantTime, \"not too fast\");\n        lastGranted = block.timestamp;\n        iERC20(USDV).transfer(recipient, amount); \n    }\n\n    //======================================DEPOSITS========================================//\n\n    // Deposit USDV or SYNTHS\n    function deposit(address synth, uint amount) external {\n        depositForMember(synth, msg.sender, amount);\n    }\n    // Wrapper for contracts\n    function depositForMember(address synth, address member, uint amount) public {\n        require((iFACTORY(FACTORY).isSynth(synth)), \"Not Synth\"); // Only Synths\n        getFunds(synth, amount);\n        _deposit(synth, member, amount);\n    }\n    function _deposit(address _synth, address _member, uint _amount) internal {\n        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         // Time of deposit\n        mapMemberSynth_deposit[_member][_synth] += _amount;                 // Record deposit\n        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);\n        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){\n            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               // Price in USDV\n        }\n        mapMember_weight[_member] += _weight;                               // Total member weight \n        totalWeight += _weight;                                             // Total weight \n        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);\n    }\n\n    //====================================== HARVEST ========================================//\n\n    // Harvest, get payment, allocate, increase weight\n    function harvest(address synth) external returns(uint reward) {\n        address _member = msg.sender;\n        uint _weight;\n        address _token = iSYNTH(synth).TOKEN();\n        reward = calcCurrentReward(synth, _member);                     // In USDV\n        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      // Reset time\n        if(iPOOLS(POOLS).isAsset(_token)){\n            iERC20(USDV).transfer(POOLS, reward); \n            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));\n            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);\n        } else {\n            iERC20(VADER).transfer(POOLS, reward); \n            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));\n            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));\n        }\n        mapMemberSynth_deposit[_member][synth] += reward; \n        mapMember_weight[_member] += _weight;\n        totalWeight += _weight;\n        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);\n    }\n\n    // Get the payment owed for a member\n    function calcCurrentReward(address synth, address member) public view returns(uint reward) {\n        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        // Get time since last claim\n        uint _share = calcReward(synth, member);                                               // Get share of rewards for member\n        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         // Get owed amount, based on per-day rates\n        uint _reserve;\n        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){\n            _reserve = reserveUSDV();\n        } else {\n            _reserve = reserveVADER();\n        }\n        if(reward >= _reserve) {\n            reward = _reserve;                                                          // Send full reserve if the last\n        }\n    }\n\n    function calcReward(address synth, address member) public view returns(uint reward) {\n        uint _weight = mapMember_weight[member];  \n        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){\n            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      // Aggregrate reserves\n            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   // Get member's share of that\n        } else{\n            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();\n            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          \n        }\n    }\n\n    //====================================== WITHDRAW ========================================//\n\n    // Members to withdraw\n    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {\n        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          // Get amount to withdraw\n        sendFunds(synth, msg.sender, redeemedAmount);\n    }\n    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {\n        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, \"DepositTime\");    // stops attacks\n        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Share of deposits\n        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  // Reduce for member                             \n        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   // Find recorded weight to reduce\n        mapMember_weight[_member] -= _weight;                                   // Reduce for member \n        totalWeight -= _weight;                                                 // Reduce for total\n        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   // Event\n    }\n\n    //============================== ASSETS ================================//\n\n    function getFunds(address synth, uint amount) internal {\n        if(tx.origin==msg.sender){\n            require(iERC20(synth).transferTo(address(this), amount));\n        }else{\n            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));\n        }\n    }\n    function sendFunds(address synth, address member, uint amount) internal {\n        require(iERC20(synth).transfer(member, amount));\n    }\n\n    //============================== HELPERS ================================//\n\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this)); // Balance\n    }\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this)); // Balance\n    }\n\n    function getMemberDeposit(address synth, address member) external view returns(uint){\n        return mapMemberSynth_deposit[member][synth];\n    }\n    function getMemberWeight(address member) external view returns(uint){\n        return mapMember_weight[member];\n    }\n    function getMemberLastTime(address synth, address member) external view returns(uint){\n        return mapMemberSynth_lastTime[member][synth];\n    }\n\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}\n\n",
        "CodeNames": [
            "Vault.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-16",
                "Location": [
                    "getUSDVAmount",
                    "reserveUSDV",
                    "_adjustedReserve",
                    "reserveVADER",
                    "calcReward()"
                ],
                "Type": " Copy-paste bug leading to incorrect harvest rewards in Vault.sol",
                "Description": "\nThe conditional in calcReward() function uses the same code in both if/else parts with repeated use of reserveUSDV, reserveVADER and getUSDVAmount leading to incorrect computed value of _adjustedReserve in the else part.\n\nThis will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.\n\n",
                "Repair": "Recommend changing variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER. L144 should be changed to:\nuint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();\n\nstrictly-scarce (vader) confirmed(https://github.com/code-423n4/2021-04-vader-findings/issues/51#issuecomment-830576589):\n  Funds are not at-risk, just that some users will get less rewards, some will get more.\n\n Recommend: 2\n\nMervyn853 commented(https://github.com/code-423n4/2021-04-vader-findings/issues/51#issuecomment-830582964):\n  Our decision matrix for severity:\n\n 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n 1: Low Risk: UX, state handling, function incorrect as to spec\n 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n\n Recommended: 2\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\ncontract USDV is iERC20 {\n\n    // ERC-20 Parameters\n    string public override name; string public override symbol;\n    uint public override decimals; uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Parameters\n    bool private inited;\n    uint public nextEraTime;\n    uint public blockDelay;\n\n    address public VADER;\n    address public VAULT;\n    address public ROUTER;\n\n    mapping(address => uint) public lastBlock;\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n    // Stop flash attacks\n    modifier flashProof() {\n        require(isMature(), \"No flash\");\n        _;\n    }\n    function isMature() public view returns(bool isMatured){\n        if(lastBlock[tx.origin] + blockDelay <= block.number){ // Stops an EOA doing a flash attack in same block\n            return true;\n        }\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n        name = 'VADER STABLE DOLLAR';\n        symbol = 'USDV';\n        decimals = 18;\n        totalSupply = 0;\n    }\n    function init(address _vader, address _vault, address _router) external {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        VAULT = _vault;\n        ROUTER = _router;\n        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();\n    }\n\n    //========================================iERC20=========================================//\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(sender != address(0), \"sender\");\n            _balances[sender] -= amount;\n            _balances[recipient] += amount;\n            emit Transfer(sender, recipient, amount);\n            _checkIncentives();\n        }\n    }\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(account != address(0), \"recipient\");\n            totalSupply += amount;\n            _balances[account] += amount;\n            emit Transfer(address(0), account, amount);\n        }\n    }\n    // Burn supply\n    function burn(uint amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) external virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender)- amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(account != address(0), \"address err\");\n            _balances[account] -= amount;\n            totalSupply -= amount;\n            emit Transfer(account, address(0), amount);\n        }\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newDelay) external onlyDAO {\n        blockDelay = newDelay;\n    }\n\n   //======================================INCENTIVES========================================//\n    // Internal - Update incentives function\n    function _checkIncentives() private {\n        if (block.timestamp >= nextEraTime && emitting()) {                 // If new Era\n            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _balance = iERC20(VADER).balanceOf(address(this));         // Get spare VADER\n            if(_balance > 4){\n                uint _USDVShare = _balance/2;                                   // Get 50%\n                _convert(address(this), _USDVShare);                            // Convert it\n                if(balanceOf(address(this)) > 2){\n                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              // Send half USDV to ROUTER\n                    _transfer(address(this), VAULT, balanceOf(address(this)));                   // Send rest to VAULT\n                }\n                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   // Send half VADER to ROUTER\n                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      // Send rest to VAULT\n            }\n        }\n    }\n    \n    //======================================ASSET MINTING========================================//\n    // Convert to USDV\n    function convert(uint amount) external returns(uint) {\n        return convertForMember(msg.sender, amount);\n    }\n    // Convert for members\n    function convertForMember(address member, uint amount) public returns(uint) {\n        getFunds(VADER, amount);\n        return _convert(member, amount);\n    }\n    // Internal convert\n    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){\n        if(minting()){\n            lastBlock[tx.origin] = block.number;                    // Record first\n            iERC20(VADER).burn(amount);\n            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); // Critical pricing functionality\n            _mint(_member, _convertAmount);\n        }\n    }\n    // Redeem to VADER\n    function redeem(uint amount) external returns(uint) {\n        return redeemForMember(msg.sender, amount);\n    }\n    // Contracts to redeem for members\n    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {\n        _transfer(msg.sender, VADER, amount);                   // Move funds\n        redeemAmount = iVADER(VADER).redeemToMember(member);    // Ask VADER to redeem\n        lastBlock[tx.origin] = block.number;                    // Must record block AFTER the tx\n    }\n\n    //============================== ASSETS ================================//\n\n    function getFunds(address token, uint amount) internal {\n        if(token == address(this)){\n            _transfer(msg.sender, address(this), amount);\n        } else {\n            if(tx.origin==msg.sender){\n                require(iERC20(token).transferTo(address(this), amount));\n            }else{\n                require(iERC20(token).transferFrom(msg.sender, address(this), amount));\n            }\n        }\n    }\n\n    //============================== HELPERS ================================//\n\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function minting() public view returns(bool){\n        return iVADER(VADER).minting();\n    }\n\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iUSDV.sol\";\nimport \"./interfaces/iROUTER.sol\";\n\ncontract Vader is iERC20 {\n\n    // ERC-20 Parameters\n    string public override name; string public override symbol;\n    uint public override decimals; uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Parameters\n    bool private inited;\n    bool public emitting;\n    bool public minting;\n    uint _1m;\n    uint public baseline;\n    uint public emissionCurve;\n    uint public maxSupply;\n    uint public secondsPerEra;\n    uint public currentEra;\n    uint public nextEraTime;\n    uint public feeOnTransfer;\n\n    address public VETHER;\n    address public USDV;\n    address public UTILS;\n    address public burnAddress;\n    address public rewardAddress;\n    address public DAO;\n\n    event NewEra(uint currentEra, uint nextEraTime, uint emission);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO, \"Not DAO\");\n        _;\n    }\n    // Stop flash attacks\n    modifier flashProof() {\n        require(isMature(), \"No flash\");\n        _;\n    }\n    function isMature() public view returns(bool){\n        return iUSDV(USDV).isMature();\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n        name = 'VADER PROTOCOL TOKEN';\n        symbol = 'VADER';\n        decimals = 18;\n        _1m = 10**6 * 10 ** decimals; //1m\n        baseline = _1m;\n        totalSupply = 0;\n        maxSupply = 2 * _1m;\n        currentEra = 1;\n        secondsPerEra = 1; //86400;\n        nextEraTime = block.timestamp + secondsPerEra;\n        emissionCurve = 900;\n        DAO = msg.sender;\n        burnAddress = 0x0111011001100001011011000111010101100101;\n    }\n    // Can only be called once\n    function init(address _vether, address _USDV, address _utils) external {\n        require(inited == false);\n        inited = true;\n        VETHER = _vether;\n        USDV = _USDV;\n        UTILS = _utils;\n        rewardAddress = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function balanceOf(address account) external view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        require(sender != address(0), \"sender\");\n        require(recipient != address(this), \"recipient\");\n        _balances[sender] -= amount;\n        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  // Critical functionality\n        if(_fee >= 0 && _fee <= amount){                            // Stops reverts if UTILS corrupted\n            amount -= _fee;\n            _burn(msg.sender, _fee);\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        _checkEmission();\n    }\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint amount) internal virtual {\n        require(account != address(0), \"recipient\");\n        if((totalSupply + amount) >= maxSupply){\n            amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply\n        }\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n    // Burn supply\n    function burn(uint amount) public virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) external virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender) - amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        require(account != address(0), \"address err\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //=========================================DAO=========================================//\n    // Can start\n    function flipEmissions() external onlyDAO {\n        if(emitting){\n            emitting = false;\n        } else {\n            emitting = true;\n        }\n    }\n    // Can stop\n    function flipMinting() external onlyDAO {\n        if(minting){\n            minting = false;\n        } else {\n            minting = true;\n        }\n    }\n    // Can set params\n    function setParams(uint newEra, uint newCurve) external onlyDAO {\n        secondsPerEra = newEra;\n        emissionCurve = newCurve;\n    }\n    // Can set reward address\n    function setRewardAddress(address newAddress) external onlyDAO {\n        rewardAddress = newAddress;\n    }\n    // Can change UTILS\n    function changeUTILS(address newUTILS) external onlyDAO {\n        require(newUTILS != address(0), \"address err\");\n        UTILS = newUTILS;\n    }\n    // Can change DAO\n    function changeDAO(address newDAO) external onlyDAO {\n        require(newDAO != address(0), \"address err\");\n        DAO = newDAO;\n    }\n    // Can purge DAO\n    function purgeDAO() external onlyDAO{\n        DAO = address(0);\n    }\n\n   //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _checkEmission() private {\n        if ((block.timestamp >= nextEraTime) && emitting) {                                // If new Era and allowed to emit\n            currentEra += 1;                                                               // Increment Era\n            nextEraTime = block.timestamp + secondsPerEra;                                 // Set next Era time\n            uint _emission = getDailyEmission();                                           // Get Daily Dmission\n            _mint(rewardAddress, _emission);                                               // Mint to the Rewad Address\n            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        // UpdateFeeOnTransfer\n            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                // Max 10% if UTILS corrupted\n            emit NewEra(currentEra, nextEraTime, _emission);                               // Emit Event\n        }\n    }\n    // Calculate Daily Emission\n    function getDailyEmission() public view returns (uint) {\n        uint _adjustedMax;\n        if(totalSupply <= baseline){ // If less than 1m, then adjust cap down\n            _adjustedMax = (maxSupply * totalSupply) / baseline; // 2m * 0.5m / 1m = 2m * 50% = 1.5m\n        } else {\n            _adjustedMax = maxSupply;  // 2m\n        }\n        return (_adjustedMax - totalSupply) / (emissionCurve); // outstanding / curve \n    }\n\n    //======================================ASSET MINTING========================================//\n    // VETHER Owners to Upgrade\n    function upgrade(uint amount) external {\n        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));\n        _mint(msg.sender, amount);\n    }\n    // Directly redeem back to VADER (must have sent USDV first)\n    function redeem() external returns (uint redeemAmount){\n        return redeemToMember(msg.sender);\n    }\n    // Redeem on behalf of member (must have sent USDV first)\n    function redeemToMember(address member) public flashProof returns (uint redeemAmount){\n        if(minting){\n            uint _amount = iERC20(USDV).balanceOf(address(this)); \n            iERC20(USDV).burn(_amount);\n            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); // Critical pricing functionality\n            _mint(member, redeemAmount);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "USDV.sol",
            "Vader.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-17",
                "Location": [
                    "redeemForMember()",
                    "redeemToMember()"
                ],
                "Type": "  Vader.redeemToMember()  vulnerable to front running",
                "Description": "\nThe USDV balance of the Vader contract is vulnerable to theft through the Vader.redeemToMember() function. A particular case is through USDV redemption front-running. Users can redeem USDV for Vader through the USDV.redeemForMember() function or the Vader.redeemToMember() function. In the case of Vader.redeemToMember(), a user would need to send their USDV to the contract before redemption. However, as this process does not happen in a single call, the victim's call is vulnerable to front running and could have their redeemed USDV stolen by an attacker.\n\nUser's redeem USDV could be stolen by an attacker front running their Vader.redeemToMember() call.\n\nThe steps are as follows:\n\n1) User sends USDV to Vader contract to be redeemed\n2) User calls Vader.redeemToMember()\n3) The Vader.redeemToMember() call is detected by an attacker, who front-runs the call by calling Vader.redeemToMember() specifying their own address as the member parameter.\n4) The full USDV balance of the Vader contract is redeemed and sent to the attacker.\n\nNote that while this particular case is front running a redemption call, any USDV balance could be stolen in this manner. Please find the POC showing the above steps here: https://gist.github.com/toastedsteaksandwich/39bfed78b21d7e6c02fe13ea5b2023c3\n\n\n",
                "Repair": "Recommend that the Vader.redeemToMember() function should be restricted so that only the USDV contract can call it. Moreover, the amount parameter from USDV.redeem() or USDV.redeemForMember() should also be passed to Vader.redeemToMember() to avoid the need to sweep the entire USDV balance. In this way, the member's redemption happens in a single tx, and would only be allocated as much Vader as redeemed in USDV.\n\nstrictly-scarce (vader) disputed(https://github.com/code-423n4/2021-04-vader-findings/issues/36#issuecomment-827577253):\n  Vader complies with a monetary security policy of \"money in, money out\". Contracts will only send out funds if they are first sent funds.\n\n This is the case for the entire system, not just Vader.redeemToMember(), such as swaps and adding liquidity. Vader is not designed to be interacted with directly, it should be wrapped. In this case, users should convert and redeem only thru the USDV contract, which first sends funds.\n\n Incidentally this is the same mechanism that uniswap employs for withdrawing liquidity, or syncing funds to balances. You can also get front-runned if you do it in two tx, it should be wrapped in 1 tx.\n\nMervyn853 commented(https://github.com/code-423n4/2021-04-vader-findings/issues/36#issuecomment-830582247):\n  Our decision matrix for severity:\n\n 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n 1: Low Risk: UX, state handling, function incorrect as to spec\n 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n\n Recommended: 0\n\n\n"
            }
        ]
    }
]