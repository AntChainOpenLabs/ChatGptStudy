[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Unsafe handling of underlying tokens",
                "Description": "\n\nNot every ERC20 token follows OpenZeppelin's recommendation. It's possible (inside ERC20 standard) that a transferFrom doesn't revert upon failure but returns false.\n\nThe code doesn't check these return values. For example uToken.transferFrom(msg.sender, o.maker, a); in initiateVaultFillingZcTokenInitiate can be exploited by the msg.sender to initiate a trade without sending any underlying.\n\n\ngrep 'transfer' Swivel.sol\n\n\neditor\n\n",
                "Repair": "\nConsider using OpenZeppelin's library(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) with *safe* versions of transfer functions.\n\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [],
                "Type": " Swivel: Taker is charged fees twice in exitVaultFillingVaultInitiate",
                "Description": "\n\nTaker is charged fees twice in exitVaultFillingVaultInitiate() . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker's net balance is premiumFilled 2*fee\n\n",
                "Repair": "\njsx\nfunction exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n  bytes32 hash = validOrderHash(o, c);\n\n  require(a <= (o.principal filled[hash]), 'taker amount  available volume');\n  \n  filled[hash] += a;\n      \n  uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n  uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;\n\n  Erc20 uToken = Erc20(o.underlying);\n  // transfer premium from maker to sender\n  uToken.transferFrom(o.maker, msg.sender, premiumFilled);\n\n  // transfer fee in underlying to swivel from sender\n  uToken.transferFrom(msg.sender, address(this), fee);\n\n  // transfer <a vault.notional (nTokens) from sender to maker\n  require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');\n\n  emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n}\n\n\nJTraversa (Swivel) confirmed(https://github.com/code-423n4/2021-09-swivel-findings/issues/39)\n\n0xean (judge) commented(https://github.com/code-423n4/2021-09-swivel-findings/issues/39#issuecomment-945017326):\n  Based on \n \n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n \n This is being upgraded to a high risk. The duplicate of it was at that level by the submitting warden and considering that fees are being incorrectly taken from the taker and not the maker, the maker ends up with a higher balance than expected and the taker has no way to recoup these fees (assets are now lost). \n\nJTraversa (Swivel) commented(https://github.com/code-423n4/2021-09-swivel-findings/issues/39#issuecomment-945019164):\n  Is that how it is interpreted? I'd assume that high risk would imply a valid attack path that a user could use to drain deposited funds based on that description.\n \n I won't fight this one obviously, just think there's a *clear* differentiation between this and the other high risk issue.\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n  function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {\n  Vault memory from = vaults[f];\n  Vault memory to = vaults[t];\n  ...\n  vaults[f] = from;\n  ...\n  vaults[t] = to;    // if f==t then this will overwrite vaults[f]\n",
                    "//solidity\n  function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {\n  require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');\n"
                ],
                "Type": "  transferNotionalFrom  doesn't check  from != to ",
                "Description": "\n\nThe function transferNotionalFrom of VaultTracker.sol uses temporary variables to store the balances.\nIf the \"from\" and \"to\" address are the same then the balance of \"from\" is overwritten by the balance of \"to\".\nThis means the balance of \"from\" and \"to\" are increased and no balances are decreased, effectively printing money.\n\nNote: transferNotionalFrom can be called via transferVaultNotional by everyone.\n\n\n<https://github.com/Swivel-Finance/gost/blob/v2/test/vaulttracker/VaultTracker.sol#L144-L196\nsolidity\n  function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {\n  Vault memory from = vaults[f];\n  Vault memory to = vaults[t];\n  ...\n  vaults[f] = from;\n  ...\n  vaults[t] = to;    // if f==t then this will overwrite vaults[f]\n\n\n<https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L234-L238\nsolidity\n  function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {\n  require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');\n\n\n\n",
                "Repair": "\nAdd something like the following:\nrequire (f != t,\"Same\");\n\nJTraversa (Swivel) confirmed(https://github.com/code-423n4/2021-09-swivel-findings/issues/65)\n\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\n  ...\n  require(o.maker == Sig.recover(Hash.message(domain, hash), c), 'invalid signature');\n  return hash;\n  }\n",
                    "//solidity\n  function recover(bytes32 h, Components calldata c) internal pure returns (address) {\n  ...\n  return ecrecover(h, c.v, c.r, c.s);\n"
                ],
                "Type": " return value of 0 from ecrecover not checked",
                "Description": "\n\nThe solidity function ecrecover is used, however the error result of 0 is not checked for.\nSee documentation:\n<https://docs.soliditylang.org/en/v0.8.9/units-and-global-variables.html?highlight=ecrecover#mathematical-and-cryptographic-functions\n\"recover the address associated with the public key from elliptic curve signature or return zero on error. \"\n\nNow you can supply invalid input parameters to the Sig.recover function, which will then result 0.\nIf you also set o.maker to be 0 then this will match and an invalid signature is not detected.\n\nSo you can do all kinds of illegal & unexpected transactions.\n\n\n<https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Swivel.sol#L476-L484\nsolidity\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\n  ...\n  require(o.maker == Sig.recover(Hash.message(domain, hash), c), 'invalid signature');\n  return hash;\n  }\n\n\n<https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Sig.sol#L16-L23\nsolidity\n  function recover(bytes32 h, Components calldata c) internal pure returns (address) {\n  ...\n  return ecrecover(h, c.v, c.r, c.s);\n\n\n\n",
                "Repair": "\nVerify that the result from ecrecover isn't 0\n\nJTraversa (Swivel) acknowledged(https://github.com/code-423n4/2021-09-swivel-findings/issues/61)\nJTraversa (Swivel) commented(https://github.com/code-423n4/2021-09-swivel-findings/issues/61#issuecomment-961456683):\n Id say this is noteable, but because all actions require approvals from o.maker, having 0x00 as o.maker with an \"invalid\" but valid signature should not be impactful.\n The suggestion would be to filter 0x00 makers from the orderbook? (which we do)\n\n \n\n"
            },
            {
                "Name": "M-01",
                "Location": [],
                "Type": " Admin is a single-point of failure without any mitigations",
                "Description": "\n\nAdmin role has absolute power across Swivel, Marketplace and VaultTracker contracts with several onlyOwner functions. There is no ability to change admin to a new address or renounce it which is helpful for lost/compromised admin keys or to delegate control to a different governance/DAO address in future.\n\nThe project does not use the widely used OpenZeppelin Ownable library which provides transfer/renounce functions to mitigate such compromised/accidental situations with admin keys. This makes admin role/key a single-point of failure.\n\n\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L38\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L43\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L27\n\n\nManual Analysis\n\n",
                "Repair": "\nEnsure admins are reasonably redundant/independent (3/7 or 5/9) multisigs and add transfer/renounce functionality for admin. Consider using OpenZeppelin\u2019s Ownable library.\n\nJTraversa (Swivel) acknowledged(https://github.com/code-423n4/2021-09-swivel-findings/issues/95#issuecomment-938053890):\n  Similar to some other suggestions, i'm personally not sure if this is within the scope of the competition / an \"issue\". We have immediate plans to add admin transfer functionality however left it out of the scope of this audit as not having a transferAdmin function doesn't seem to be any more dangerous than the admin having the functionality it currently has.\n \n That said, in production the admin will both be a multisig and there is also basic admin timelock/transfer functionality, with on-chain governance as opposed to centralized-ish multisigs coming Q1.\n\n\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [],
                "Type": " Missing event & timelock for critical  onlyAdmin  functions",
                "Description": "\n\nonlyAdmin functions that change critical contract parameters/addresses/state should emit events and consider adding timelocks so that users and other privileged roles can detect upcoming changes (by offchain monitoring of events) and have the time to react to them.\n\nPrivileged functions in all contracts, for e.g. VaultTracker onlyAdmin, have direct financial or trust impact on users who should be given an opportunity to react to them by exiting/engaging without being surprised when changes initiated by such functions are made effective opaquely (without events) and/or immediately (without timelocks).\n\nSee similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (<https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing)\n\n\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L36-L59\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L70-L98\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L102-L129\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L132-L138\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L144-L196\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L201-L239\n\nand others\n\n\nManual Analysis\n\n",
                "Repair": "\nAdd events to all possible flows (some flows emit events in callers) and consider adding timelocks to such onlyAdmin functions.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-09-swivel-findings/issues/101#issuecomment-943884529):\n  removing duplicate mark since the (valid) suggestion to emit events on the changes made by admin calls\n\n\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": " Previously created markets can be overwritten",
                "Description": "\n\nThe createMarket function allows accidental overwriting of previously created markets for the same combination of underlying and maturity timestamp (u, m) because there is no zero-address check to see if a previously created market exists for that combination.\n\n\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L65\n<https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L53-L70\n\n\nManual Analysis\n\n",
                "Repair": "\nAdd a zero-address check for markets[u][m] in createMarket before writing to it\n\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "js\n  require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');\n  // transfer underlying back to msg.sender\n  Erc20(u).transfer(msg.sender, redeemed);\n"
                ],
                "Type": " fee-on-transfer underlying can cause problems",
                "Description": "\n\nThe current implementation doesn't work with fee-on-transfer underlying tokens. Considering that Compound can have these kind of tokens (ex. USDT can activate fees), this issue can affect the protocol.\n\nThe problem arises when transferring tokens, basically blocking all functions in Swivel.sol for that particular token, since the contract wrongly assumes balances values.\nThis becomes particularly problematic in the following scenario: a market for USDT is running without problems, then they activate the fee: this effectively blocks users from redeeming the underlying.\n\n\ngrep 'transfer' Swivel.sol for a complete list of affected lines (basically every tranfer or transferFrom of underlying tokens). Also grep 'redeemUnderlying' Swivel.sol.\n\nFor example:\n\njs\n  require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');\n  // transfer underlying back to msg.sender\n  Erc20(u).transfer(msg.sender, redeemed);\n\n\nThis would fail (revert) since the contract would have received less than redeemed tokens.\n\n\neditor\n\n",
                "Repair": "\nIf the protocol wants to use all possible Compound tokens, a way to handle these tokens must be implemented. A possible way to do it is to check the balance of the contract before and after every time a token is transferred to see the effective quantity. To help keeping the code clear, a function like Compound's doTransferIn(https://github.com/compound-finance/compound-protocol/blob/master/contracts/CErc20.sol#L156) can be implemented.\n\nJTraversa (Swivel) acknowledged(https://github.com/code-423n4/2021-09-swivel-findings/issues/156#issuecomment-938359220):\n Will review further. I dont believe that any tokens on compound currently have fees. Although it *is* news to me that USDT has toggle-able fees, whoops.\n \n That said, given we have admin control over added assets, I'd probably also lower this to a low-risk if accepted. \n\n0xean (judge) commented(https://github.com/code-423n4/2021-09-swivel-findings/issues/156#issuecomment-943885544):\n  \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n based on this \"leaking value\" I would say it qualifies as a med-severity. \n\nJTraversa (Swivel) commented(https://github.com/code-423n4/2021-09-swivel-findings/issues/156#issuecomment-950403433):\n  We can account for the transfers in with a similar balance before transferFrom, and balance after check, in order to prevent additional deposits after a fee has been turned on.\n \n That said, Im not sure we can account for redeemUnderlying easily because should a fee be turned on, all funds would just be stuck in our contract if we added a similar check? (a != balance2-balance1)\n \n If a fee is turned on for USDT markets, there would be lost fee value, so if adding a check wouldn't work, the most reasonable response is just to make sure the market is pausable. \n\n\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [],
                "Type": " Swivel: implementation for initiateZcTokenFillingZcTokenExit is incorrect",
                "Description": "\n\nIn initiateZcTokenFillingZcTokenExit() , this comment // transfer underlying tokens the premium paid + fee in underlying to swivel (from sender)  is incorrect because you are actually transferring the underlying tokens premium paid to the maker (from sender) AND you have to pay fee separately to swivel.\n\ninitiateZCTokenFillingZcTokenExit means I want to sell my nTokens so that means a is the amount of principal I want to fill. Let's use a hypothetical example where I (taker) wants to fill 10 units of ZcTokenExit for maker.\n\n1.  I transfer 10 units of underlying to Swivel. The net balances are: me (-a), swivel (+a)\n2.  I transfer fee (in underlying) to Swivel. The net balances are: me (-a-fee), swivel (+a+fee)\n3.  Swivel initiates my position, sends me the ZcToken and sends Maker the nTokens\n4.  Maker pays me premiumFilled for the nTokens. The net balances are: me (-a-fee+premiumsFilled), swivel (+a+fee), maker (-premiumsFilled)\n5.  Maker closes position. The net balances are: me (-a-fee+premiumsFilled), swivel (+fee), maker (-premiumsFilled+a)\n\nSo effectively, I (taker) should be paying a-premium to maker and fee to swivel.\n\n",
                "Repair": "\njsx\nfunction initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n  bytes32 hash = validOrderHash(o, c);\n\n  require(a <= o.principal filled[hash]), 'taker amount  available volume'); // Note: you don't need to wrap these in brackets because if you look at the https://docs.soliditylang.org/en/latest/cheatsheet.html#order-of-precedence-of-operators, subtraction will always go before comparison \n\n  filled[hash] += a;\n\n  uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n  uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;\n\n  // transfer underlying tokens the premium paid in underlying to maker (from sender)\n  Erc20(o.underlying).transferFrom(msg.sender, o.maker, a premiumFilled);\n  Erc20(o.underlying).transferFrom(msg.sender, swivel, fee);\n  // transfer <a zcTokens between users in marketplace\n  require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');\n          \n  emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n}\n\n\nJTraversa (Swivel) confirmed(https://github.com/code-423n4/2021-09-swivel-findings/issues/38#issuecomment-937980208):\n  Really good eye. \n \n We had o.maker send the fee after receiving it (same # of transfers as suggested mitigation) and actually accidentally lost that in a larger organizational commit \ud83d\ude05 .\n\n \n\n"
            }
        ]
    }
]