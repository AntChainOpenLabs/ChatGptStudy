[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"./ConvexStakingWrapper.sol\";\n\n/// @title Convex staking wrapper for Yield platform\n/// @notice Enables use of convex LP positions as collateral while still receiving rewards\ncontract ConvexYieldWrapper is ConvexStakingWrapper {\n    using TransferHelper for IERC20;\n\n    /// @notice Mapping to keep track of the user & their vaults\n    mapping(address => bytes12[]) public vaults;\n\n    ICauldron public cauldron;\n\n    /// @notice Event called when a vault is added for a user\n    /// @param account The account for which vault is added\n    /// @param vaultId The vaultId to be added\n    event VaultAdded(address indexed account, bytes12 indexed vaultId);\n\n    /// @notice Event called when a vault is removed for a user\n    /// @param account The account for which vault is removed\n    /// @param vaultId The vaultId to be removed\n    event VaultRemoved(address indexed account, bytes12 indexed vaultId);\n\n    /// @notice Event called when tokens are rescued from the contract\n    /// @param token Address of the token being rescued\n    /// @param amount Amount of the token being rescued\n    /// @param destination Address to which the rescued tokens have been sent\n    event Recovered(address indexed token, uint256 amount, address indexed destination);\n\n    constructor(\n        address curveToken_,\n        address convexToken_,\n        address convexPool_,\n        uint256 poolId_,\n        address join_,\n        ICauldron cauldron_,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ConvexStakingWrapper(curveToken_, convexToken_, convexPool_, poolId_, join_, name, symbol, decimals) {\n        cauldron = cauldron_;\n    }\n\n    /// @notice Points the collateral vault to the join storing the wrappedConvex\n    /// @param join_ Join which will store the wrappedConvex of the user\n    function point(address join_) external auth {\n        collateralVault = join_;\n    }\n\n    /// @notice Adds a vault to the user's vault list\n    /// @param vaultId The id of the vault being added\n    function addVault(bytes12 vaultId) external {\n        address account = cauldron.vaults(vaultId).owner;\n        require(account != address(0), \"No owner for the vault\");\n        bytes12[] storage vaults_ = vaults[account];\n        uint256 vaultsLength = vaults_.length;\n\n        for (uint256 i = 0; i < vaultsLength; i++) {\n            require(vaults_[i] != vaultId, \"Vault already added\");\n        }\n        vaults_.push(vaultId);\n        vaults[account] = vaults_;\n        emit VaultAdded(account, vaultId);\n    }\n\n    /// @notice Remove a vault from the user's vault list\n    /// @param vaultId The id of the vault being removed\n    /// @param account The user from whom the vault needs to be removed\n    function removeVault(bytes12 vaultId, address account) public {\n        address owner = cauldron.vaults(vaultId).owner;\n        if (account != owner) {\n            bytes12[] storage vaults_ = vaults[account];\n            uint256 vaultsLength = vaults_.length;\n            bool found;\n            for (uint256 i = 0; i < vaultsLength; i++) {\n                if (vaults_[i] == vaultId) {\n                    bool isLast = i == vaultsLength - 1;\n                    if (!isLast) {\n                        vaults_[i] = vaults_[vaultsLength - 1];\n                    }\n                    vaults_.pop();\n                    found = true;\n                    emit VaultRemoved(account, vaultId);\n                    break;\n                }\n            }\n            require(found, \"Vault not found\");\n            vaults[account] = vaults_;\n        }\n    }\n\n    /// @notice Get user's balance of collateral deposited in various vaults\n    /// @param account_ User's address for which balance is requested\n    /// @return User's balance of collateral\n    function _getDepositedBalance(address account_) internal view override returns (uint256) {\n        if (account_ == address(0) || account_ == collateralVault) {\n            return 0;\n        }\n\n        bytes12[] memory userVault = vaults[account_];\n\n        //add up all balances of all vaults registered in the wrapper and owned by the account\n        uint256 collateral;\n        DataTypes.Balances memory balance;\n        uint256 userVaultLength = userVault.length;\n        for (uint256 i = 0; i < userVaultLength; i++) {\n            if (cauldron.vaults(userVault[i]).owner == account_) {\n                balance = cauldron.balances(userVault[i]);\n                collateral = collateral + balance.ink;\n            }\n        }\n\n        //add to balance of this token\n        return _balanceOf[account_] + collateral;\n    }\n\n    /// @dev Wrap convex token held by this contract and forward it to the `to` address\n    /// @param to_ Address to send the wrapped token to\n    /// @param from_ Address of the user whose token is being wrapped\n    function wrap(address to_, address from_) external {\n        require(!isShutdown, \"shutdown\");\n        uint256 amount_ = IERC20(convexToken).balanceOf(address(this));\n        require(amount_ > 0, \"No convex token to wrap\");\n\n        _checkpoint([address(0), from_]);\n        _mint(to_, amount_);\n        IRewardStaking(convexPool).stake(amount_);\n\n        emit Deposited(msg.sender, to_, amount_, false);\n    }\n\n    /// @dev Unwrap Wrapped convex token held by this contract, and send the unwrapped convex token to the `to` address\n    /// @param to_ Address to send the unwrapped convex token to\n    function unwrap(address to_) external {\n        require(!isShutdown, \"shutdown\");\n        uint256 amount_ = _balanceOf[address(this)];\n        require(amount_ > 0, \"No wrapped convex token\");\n\n        _checkpoint([address(0), to_]);\n        _burn(address(this), amount_);\n        IRewardStaking(convexPool).withdraw(amount_, false);\n        IERC20(convexToken).safeTransfer(to_, amount_);\n\n        emit Withdrawn(to_, amount_, false);\n    }\n\n    /// @notice A simple function to recover any ERC20 tokens\n    /// @param token_ Address of the token being rescued\n    /// @param amount_ Amount of the token being rescued\n    /// @param destination_ Address to which the rescued tokens have been sent\n    function recoverERC20(\n        address token_,\n        uint256 amount_,\n        address destination_\n    ) external auth {\n        require(amount_ != 0, \"amount is 0\");\n        IERC20(token_).safeTransfer(destination_, amount_);\n        emit Recovered(token_, amount_, destination_);\n    }\n\n    /// @notice A function to shutdown the contract & withdraw the staked convex tokens & transfer rewards\n    /// @param rescueAddress_ Address to which the rescued tokens would be sent to\n    function shutdownAndRescue(address rescueAddress_) external auth {\n        uint256 balance_ = IRewardStaking(convexPool).balanceOf(address(this));\n\n        if (balance_ != 0) {\n            // Withdraw the convex tokens from the convex pool\n            IRewardStaking(convexPool).withdraw(balance_, true);\n\n            // Transfer the withdrawn convex tokens to rescue address\n            IERC20(convexToken).safeTransfer(rescueAddress_, balance_);\n        }\n        // Shutdown the contract\n        isShutdown = true;\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"./interfaces/IConvexYieldWrapper.sol\";\nimport \"../../LadleStorage.sol\";\n\n/// @title Convex Ladle Module to handle vault addition\ncontract ConvexModule is LadleStorage {\n    constructor(ICauldron cauldron_, IWETH9 weth_) LadleStorage(cauldron_, weth_) {}\n\n    /// @notice Adds a vault to the user's vault list in the convex wrapper\n    /// @param convexStakingWrapper The address of the convex wrapper to which the vault will be added\n    /// @param vaultId The vaulId to be added\n    function addVault(IConvexYieldWrapper convexStakingWrapper, bytes12 vaultId) external {\n        if (vaultId == bytes12(0)) {\n            convexStakingWrapper.addVault(cachedVaultId);\n        } else {\n            convexStakingWrapper.addVault(vaultId);\n        }\n    }\n\n    /// @notice Removes a vault from the user's vault list in the convex wrapper\n    /// @param convexStakingWrapper The address of the convex wrapper from which the vault will be removed\n    /// @param vaultId The vaulId to be removed\n    /// @param account The address of the user from whose list the vault is to be removed\n    function removeVault(\n        IConvexYieldWrapper convexStakingWrapper,\n        bytes12 vaultId,\n        address account\n    ) external {\n        convexStakingWrapper.removeVault(vaultId, account);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// Original contract: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/ERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\";\nimport \"./interfaces/IRewardStaking.sol\";\nimport \"./interfaces/IConvexDeposits.sol\";\nimport \"./interfaces/ICvx.sol\";\nimport \"./CvxMining.sol\";\n\n/// @notice Wrapper used to manage staking of Convex tokens\ncontract ConvexStakingWrapper is ERC20, AccessControl {\n    using TransferHelper for IERC20;\n\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n\n    struct RewardType {\n        address reward_token;\n        address reward_pool;\n        uint128 reward_integral;\n        uint128 reward_remaining;\n        mapping(address => uint256) reward_integral_for;\n        mapping(address => uint256) claimable_reward;\n    }\n\n    uint256 public cvx_reward_integral;\n    uint256 public cvx_reward_remaining;\n    mapping(address => uint256) public cvx_reward_integral_for;\n    mapping(address => uint256) public cvx_claimable_reward;\n\n    //constants/immutables\n    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public curveToken;\n    address public convexToken;\n    address public convexPool;\n    address public collateralVault;\n    uint256 public convexPoolId;\n\n    //rewards\n    RewardType[] public rewards;\n\n    //management\n    bool public isShutdown;\n    bool private _status;\n\n    bool private constant _NOT_ENTERED = false;\n    bool private constant _ENTERED = true;\n\n    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);\n\n    constructor(\n        address _curveToken,\n        address _convexToken,\n        address _convexPool,\n        uint256 _poolId,\n        address _vault,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20(name, symbol, decimals) {\n        curveToken = _curveToken;\n        convexToken = _convexToken;\n        convexPool = _convexPool;\n        convexPoolId = _poolId;\n        collateralVault = _vault;\n\n        //add rewards\n        addRewards();\n        setApprovals();\n    }\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /// @notice Give maximum approval to the pool & convex booster contract to transfer funds from wrapper\n    function setApprovals() public {\n        IERC20(curveToken).approve(convexBooster, 0);\n        IERC20(curveToken).approve(convexBooster, type(uint256).max);\n        IERC20(convexToken).approve(convexPool, type(uint256).max);\n    }\n\n    /// @notice Adds reward tokens by reading the available rewards from the RewardStaking pool\n    /// @dev CRV token is added as a reward by default\n    function addRewards() public {\n        address mainPool = convexPool;\n\n        uint256 rewardsLength = rewards.length;\n\n        if (rewardsLength == 0) {\n            RewardType storage reward = rewards.push();\n            reward.reward_token = crv;\n            reward.reward_pool = mainPool;\n            rewardsLength += 1;\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        uint256 startIndex = rewardsLength - 1;\n        for (uint256 i = startIndex; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            RewardType storage reward = rewards.push();\n            reward.reward_token = IRewardStaking(extraPool).rewardToken();\n            reward.reward_pool = extraPool;\n        }\n    }\n\n    /// @notice Returns the length of the reward tokens added\n    /// @return The count of reward tokens\n    function rewardLength() external view returns (uint256) {\n        return rewards.length;\n    }\n\n    /// @notice Get user's balance\n    /// @param _account User's address for which balance is requested\n    /// @return User's balance of collateral\n    /// @dev Included here to allow inheriting contracts to override.\n    function _getDepositedBalance(address _account) internal view virtual returns (uint256) {\n        if (_account == address(0) || _account == collateralVault) {\n            return 0;\n        }\n        //get balance from collateralVault\n\n        return _balanceOf[_account];\n    }\n\n    /// @notice TotalSupply of wrapped token\n    /// @return The total supply of wrapped token\n    /// @dev This function is provided and marked virtual as convenience to future development\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Calculates & upgrades the integral for distributing the CVX rewards\n    /// @param _accounts Accounts for which the CvxIntegral has to be calculated\n    /// @param _balances Balances of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcCvxIntegral(\n        address[2] memory _accounts,\n        uint256[2] memory _balances,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        uint256 bal = IERC20(cvx).balanceOf(address(this));\n        uint256 cvxRewardRemaining = cvx_reward_remaining;\n        uint256 d_cvxreward = bal - cvxRewardRemaining;\n        uint256 cvxRewardIntegral = cvx_reward_integral;\n\n        if (_supply > 0 && d_cvxreward > 0) {\n            cvxRewardIntegral = cvxRewardIntegral + (d_cvxreward * 1e20) / (_supply);\n            cvx_reward_integral = cvxRewardIntegral;\n        }\n\n        //update user integrals for cvx\n        uint256 accountsLength = _accounts.length;\n        for (uint256 u = 0; u < accountsLength; u++) {\n            //do not give rewards to address 0\n            if (_accounts[u] == address(0)) continue;\n            if (_accounts[u] == collateralVault) continue;\n\n            uint256 userI = cvx_reward_integral_for[_accounts[u]];\n            if (_isClaim || userI < cvxRewardIntegral) {\n                uint256 receiveable = cvx_claimable_reward[_accounts[u]] +\n                    ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);\n                if (_isClaim) {\n                    if (receiveable > 0) {\n                        cvx_claimable_reward[_accounts[u]] = 0;\n                        IERC20(cvx).safeTransfer(_accounts[u], receiveable);\n                        bal = bal - (receiveable);\n                    }\n                } else {\n                    cvx_claimable_reward[_accounts[u]] = receiveable;\n                }\n                cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral;\n            }\n        }\n\n        //update reward total\n        if (bal != cvxRewardRemaining) {\n            cvx_reward_remaining = bal;\n        }\n    }\n\n    /// @notice Calculates & upgrades the integral for distributing the reward token\n    /// @param _index The index of the reward token for which the calculations are to be done\n    /// @param _accounts Accounts for which the CvxIntegral has to be calculated\n    /// @param _balances Balances of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcRewardIntegral(\n        uint256 _index,\n        address[2] memory _accounts,\n        uint256[2] memory _balances,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        RewardType storage reward = rewards[_index];\n\n        uint256 rewardIntegral = reward.reward_integral;\n        uint256 rewardRemaining = reward.reward_remaining;\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n        if (_supply > 0 && (bal - rewardRemaining) > 0) {\n            rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);\n            reward.reward_integral = uint128(rewardIntegral);\n        }\n        //update user integrals\n        uint256 accountsLength = _accounts.length;\n        for (uint256 u = 0; u < accountsLength; u++) {\n            //do not give rewards to address 0\n            if (_accounts[u] == address(0)) continue;\n            if (_accounts[u] == collateralVault) continue;\n\n            uint256 userI = reward.reward_integral_for[_accounts[u]];\n            if (_isClaim || userI < rewardIntegral) {\n                if (_isClaim) {\n                    uint256 receiveable = reward.claimable_reward[_accounts[u]] +\n                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);\n                    if (receiveable > 0) {\n                        reward.claimable_reward[_accounts[u]] = 0;\n                        IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);\n                        bal = bal - receiveable;\n                    }\n                } else {\n                    reward.claimable_reward[_accounts[u]] =\n                        reward.claimable_reward[_accounts[u]] +\n                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);\n                }\n                reward.reward_integral_for[_accounts[u]] = rewardIntegral;\n            }\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != rewardRemaining) {\n            reward.reward_remaining = uint128(bal);\n        }\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function _checkpoint(address[2] memory _accounts) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (isShutdown) return;\n\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]);\n        depositedBalance[1] = _getDepositedBalance(_accounts[1]);\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);\n        }\n        _calcCvxIntegral(_accounts, depositedBalance, supply, false);\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them & claims the rewards\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function _checkpointAndClaim(address[2] memory _accounts) internal {\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]); //only do first slot\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, true);\n        }\n        _calcCvxIntegral(_accounts, depositedBalance, supply, true);\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function user_checkpoint(address[2] calldata _accounts) external returns (bool) {\n        _checkpoint([_accounts[0], _accounts[1]]);\n        return true;\n    }\n\n    /// @notice Get the balance of the user\n    /// @param _account Address whose balance is to be checked\n    /// @return The balance of the supplied address\n    function totalBalanceOf(address _account) external view returns (uint256) {\n        return _getDepositedBalance(_account);\n    }\n\n    /// @notice Get the amount of tokens the user has earned\n    /// @param _account Address whose balance is to be checked\n    /// @return claimable Array of earned tokens and their amount\n    function earned(address _account) external view returns (EarnedData[] memory claimable) {\n        uint256 supply = _getTotalSupply();\n        uint256 rewardCount = rewards.length;\n        claimable = new EarnedData[](rewardCount + 1);\n\n        for (uint256 i = 0; i < rewardCount; i++) {\n            RewardType storage reward = rewards[i];\n            address rewardToken = reward.reward_token;\n\n            //change in reward is current balance - remaining reward + earned\n            uint256 bal = IERC20(rewardToken).balanceOf(address(this));\n            uint256 d_reward = bal - reward.reward_remaining;\n            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));\n\n            uint256 I = reward.reward_integral;\n            if (supply > 0) {\n                I = I + (d_reward * 1e20) / supply;\n            }\n\n            uint256 newlyClaimable = (_getDepositedBalance(_account) * (I - reward.reward_integral_for[_account])) /\n                1e20;\n            claimable[i].amount = reward.claimable_reward[_account] + newlyClaimable;\n            claimable[i].token = rewardToken;\n\n            //calc cvx here\n            if (rewardToken == crv) {\n                claimable[rewardCount].amount =\n                    cvx_claimable_reward[_account] +\n                    CvxMining.ConvertCrvToCvx(newlyClaimable);\n                claimable[rewardCount].token = cvx;\n            }\n        }\n        return claimable;\n    }\n\n    /// @notice Claim reward for the supplied account\n    /// @param _account Address whose reward is to be claimed\n    function getReward(address _account) external {\n        //claim directly in checkpoint logic to save a bit of gas\n        _checkpointAndClaim([_account, address(0)]);\n    }\n}\n\n\n",
        "CodeNames": [
            "ConvexYieldWrapper.sol",
            "ConvexModule.sol",
            "ConvexStakingWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "from_",
                    "unwrap()",
                    "_getDepositedBalance()",
                    "to_",
                    "user_checkpoint()",
                    "getReward()",
                    "_checkpoint()",
                    "wrap()"
                ],
                "Type": " Malicious Users Can Duplicate Protocol Earned Yield By Transferring  wCVX  Tokens To Another Account",
                "Description": "\nConvexYieldWrapper.sol is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the Ladle.sol contract's batch() function which:\n\n*   Approves Ladle to move the tokens.\n*   Transfers the tokens to ConvexYieldWrapper.sol.\n*   Wraps/stakes these tokens.\n*   Updates accounting and produces debt tokens within Ladle.sol.\n\nDuring wrap() and unwrap() actions, _checkpoint() is used to update the rewards for the from_ and to_ accounts. However, the reference(https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract implements a _beforeTokenTransfer() function which has been removed from Yield Protocol's custom implementation.\n\nAs a result, it is possible to transfer wCVX tokens to another account after an initial checkpoint has been made. By manually calling user_checkpoint() on the new account, this user is able to update its deposited balance of the new account while the sender's balance is not updated. This can be repeated to effectively replicate a user's deposited balance over any number of accounts. To claim yield generated by the protocol, the user must only make sure that the account calling getReward() holds the tokens for the duration of the call.\n\n\nThe exploit can be outlined through the following steps:\n\n*   Alice receives 100 wCVX tokens from the protocol after wrapping their convex tokens.\n*   At that point in time, _getDepositedBalance() returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards.\n*   Alice transfers her tokens to her friend Bob who then manually calls user_checkpoint() to update his balance.\n*   Now from the perspective of the protocol, both Alice and Bob have 100 wCVX tokens as calculated by the _getDepositedBalance() function.\n*   If either Alice or Bob wants to claim rewards, all they need to do is make sure the 100 wCVX tokens are in their account upon calling getReward(). Afterwards, the tokens can be transferred out.\n\n\nManual code review.\nDiscussion/confirmation with the Yield Protocol team.\n\n",
                "Repair": "\nConsider implementing the _beforeTokenTransfer() function as shown in the reference(https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract. However, it is important to ensure the wrapper contract and collateral vaults are excluded from the checkpointing so they are not considered in the rewards calculations.\n\nalcueca (Yield) confirmed and commented(https://github.com/code-423n4/2022-01-yield-findings/issues/86#issuecomment-1027876525):\n  Confirmed. The fact that rewards can be drained also means that users lose on their expected rewards, so I think that Sev 3 is right.\n\n iamsahu (Yield) resolved(https://github.com/code-423n4/2022-01-yield-findings/issues/86)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-01-yield-findings/issues/86#issuecomment-1039662424):\n  In systems that track growing rewards, anytime a user balances changes, it's important to recalculate their balances as to properly distribute pending rewards and to influence the future-rate at which rewards will be distributed (process generally called accruing)\n \n In the case of the ConvexYieldWrapper, the warden has shown that because the wCVX token doesn't perform a _checkpoint on each transfer, a malicious attacker could repeatedly transfer their tokens in order to reuse the same balance in multiple accounts, effectively sybil attacking the protocol.\n \n The fix seems to be straightforward, however the impact of the finding breaks the accounting of the protocol, as such I believe High Severity to be appropraite\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-01-yield-findings/issues/86#issuecomment-1039663556):\n  The sponsor has mitigated in a subsequent PR by overriding the _transfer function\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"./ConvexStakingWrapper.sol\";\n\n/// @title Convex staking wrapper for Yield platform\n/// @notice Enables use of convex LP positions as collateral while still receiving rewards\ncontract ConvexYieldWrapper is ConvexStakingWrapper {\n    using TransferHelper for IERC20;\n\n    /// @notice Mapping to keep track of the user & their vaults\n    mapping(address => bytes12[]) public vaults;\n\n    ICauldron public cauldron;\n\n    /// @notice Event called when a vault is added for a user\n    /// @param account The account for which vault is added\n    /// @param vaultId The vaultId to be added\n    event VaultAdded(address indexed account, bytes12 indexed vaultId);\n\n    /// @notice Event called when a vault is removed for a user\n    /// @param account The account for which vault is removed\n    /// @param vaultId The vaultId to be removed\n    event VaultRemoved(address indexed account, bytes12 indexed vaultId);\n\n    /// @notice Event called when tokens are rescued from the contract\n    /// @param token Address of the token being rescued\n    /// @param amount Amount of the token being rescued\n    /// @param destination Address to which the rescued tokens have been sent\n    event Recovered(address indexed token, uint256 amount, address indexed destination);\n\n    constructor(\n        address curveToken_,\n        address convexToken_,\n        address convexPool_,\n        uint256 poolId_,\n        address join_,\n        ICauldron cauldron_,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ConvexStakingWrapper(curveToken_, convexToken_, convexPool_, poolId_, join_, name, symbol, decimals) {\n        cauldron = cauldron_;\n    }\n\n    /// @notice Points the collateral vault to the join storing the wrappedConvex\n    /// @param join_ Join which will store the wrappedConvex of the user\n    function point(address join_) external auth {\n        collateralVault = join_;\n    }\n\n    /// @notice Adds a vault to the user's vault list\n    /// @param vaultId The id of the vault being added\n    function addVault(bytes12 vaultId) external {\n        address account = cauldron.vaults(vaultId).owner;\n        require(account != address(0), \"No owner for the vault\");\n        bytes12[] storage vaults_ = vaults[account];\n        uint256 vaultsLength = vaults_.length;\n\n        for (uint256 i = 0; i < vaultsLength; i++) {\n            require(vaults_[i] != vaultId, \"Vault already added\");\n        }\n        vaults_.push(vaultId);\n        vaults[account] = vaults_;\n        emit VaultAdded(account, vaultId);\n    }\n\n    /// @notice Remove a vault from the user's vault list\n    /// @param vaultId The id of the vault being removed\n    /// @param account The user from whom the vault needs to be removed\n    function removeVault(bytes12 vaultId, address account) public {\n        address owner = cauldron.vaults(vaultId).owner;\n        if (account != owner) {\n            bytes12[] storage vaults_ = vaults[account];\n            uint256 vaultsLength = vaults_.length;\n            bool found;\n            for (uint256 i = 0; i < vaultsLength; i++) {\n                if (vaults_[i] == vaultId) {\n                    bool isLast = i == vaultsLength - 1;\n                    if (!isLast) {\n                        vaults_[i] = vaults_[vaultsLength - 1];\n                    }\n                    vaults_.pop();\n                    found = true;\n                    emit VaultRemoved(account, vaultId);\n                    break;\n                }\n            }\n            require(found, \"Vault not found\");\n            vaults[account] = vaults_;\n        }\n    }\n\n    /// @notice Get user's balance of collateral deposited in various vaults\n    /// @param account_ User's address for which balance is requested\n    /// @return User's balance of collateral\n    function _getDepositedBalance(address account_) internal view override returns (uint256) {\n        if (account_ == address(0) || account_ == collateralVault) {\n            return 0;\n        }\n\n        bytes12[] memory userVault = vaults[account_];\n\n        //add up all balances of all vaults registered in the wrapper and owned by the account\n        uint256 collateral;\n        DataTypes.Balances memory balance;\n        uint256 userVaultLength = userVault.length;\n        for (uint256 i = 0; i < userVaultLength; i++) {\n            if (cauldron.vaults(userVault[i]).owner == account_) {\n                balance = cauldron.balances(userVault[i]);\n                collateral = collateral + balance.ink;\n            }\n        }\n\n        //add to balance of this token\n        return _balanceOf[account_] + collateral;\n    }\n\n    /// @dev Wrap convex token held by this contract and forward it to the `to` address\n    /// @param to_ Address to send the wrapped token to\n    /// @param from_ Address of the user whose token is being wrapped\n    function wrap(address to_, address from_) external {\n        require(!isShutdown, \"shutdown\");\n        uint256 amount_ = IERC20(convexToken).balanceOf(address(this));\n        require(amount_ > 0, \"No convex token to wrap\");\n\n        _checkpoint([address(0), from_]);\n        _mint(to_, amount_);\n        IRewardStaking(convexPool).stake(amount_);\n\n        emit Deposited(msg.sender, to_, amount_, false);\n    }\n\n    /// @dev Unwrap Wrapped convex token held by this contract, and send the unwrapped convex token to the `to` address\n    /// @param to_ Address to send the unwrapped convex token to\n    function unwrap(address to_) external {\n        require(!isShutdown, \"shutdown\");\n        uint256 amount_ = _balanceOf[address(this)];\n        require(amount_ > 0, \"No wrapped convex token\");\n\n        _checkpoint([address(0), to_]);\n        _burn(address(this), amount_);\n        IRewardStaking(convexPool).withdraw(amount_, false);\n        IERC20(convexToken).safeTransfer(to_, amount_);\n\n        emit Withdrawn(to_, amount_, false);\n    }\n\n    /// @notice A simple function to recover any ERC20 tokens\n    /// @param token_ Address of the token being rescued\n    /// @param amount_ Amount of the token being rescued\n    /// @param destination_ Address to which the rescued tokens have been sent\n    function recoverERC20(\n        address token_,\n        uint256 amount_,\n        address destination_\n    ) external auth {\n        require(amount_ != 0, \"amount is 0\");\n        IERC20(token_).safeTransfer(destination_, amount_);\n        emit Recovered(token_, amount_, destination_);\n    }\n\n    /// @notice A function to shutdown the contract & withdraw the staked convex tokens & transfer rewards\n    /// @param rescueAddress_ Address to which the rescued tokens would be sent to\n    function shutdownAndRescue(address rescueAddress_) external auth {\n        uint256 balance_ = IRewardStaking(convexPool).balanceOf(address(this));\n\n        if (balance_ != 0) {\n            // Withdraw the convex tokens from the convex pool\n            IRewardStaking(convexPool).withdraw(balance_, true);\n\n            // Transfer the withdrawn convex tokens to rescue address\n            IERC20(convexToken).safeTransfer(rescueAddress_, balance_);\n        }\n        // Shutdown the contract\n        isShutdown = true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// Original contract: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/ERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\";\nimport \"./interfaces/IRewardStaking.sol\";\nimport \"./interfaces/IConvexDeposits.sol\";\nimport \"./interfaces/ICvx.sol\";\nimport \"./CvxMining.sol\";\n\n/// @notice Wrapper used to manage staking of Convex tokens\ncontract ConvexStakingWrapper is ERC20, AccessControl {\n    using TransferHelper for IERC20;\n\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n\n    struct RewardType {\n        address reward_token;\n        address reward_pool;\n        uint128 reward_integral;\n        uint128 reward_remaining;\n        mapping(address => uint256) reward_integral_for;\n        mapping(address => uint256) claimable_reward;\n    }\n\n    uint256 public cvx_reward_integral;\n    uint256 public cvx_reward_remaining;\n    mapping(address => uint256) public cvx_reward_integral_for;\n    mapping(address => uint256) public cvx_claimable_reward;\n\n    //constants/immutables\n    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public curveToken;\n    address public convexToken;\n    address public convexPool;\n    address public collateralVault;\n    uint256 public convexPoolId;\n\n    //rewards\n    RewardType[] public rewards;\n\n    //management\n    bool public isShutdown;\n    bool private _status;\n\n    bool private constant _NOT_ENTERED = false;\n    bool private constant _ENTERED = true;\n\n    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);\n\n    constructor(\n        address _curveToken,\n        address _convexToken,\n        address _convexPool,\n        uint256 _poolId,\n        address _vault,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20(name, symbol, decimals) {\n        curveToken = _curveToken;\n        convexToken = _convexToken;\n        convexPool = _convexPool;\n        convexPoolId = _poolId;\n        collateralVault = _vault;\n\n        //add rewards\n        addRewards();\n        setApprovals();\n    }\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /// @notice Give maximum approval to the pool & convex booster contract to transfer funds from wrapper\n    function setApprovals() public {\n        IERC20(curveToken).approve(convexBooster, 0);\n        IERC20(curveToken).approve(convexBooster, type(uint256).max);\n        IERC20(convexToken).approve(convexPool, type(uint256).max);\n    }\n\n    /// @notice Adds reward tokens by reading the available rewards from the RewardStaking pool\n    /// @dev CRV token is added as a reward by default\n    function addRewards() public {\n        address mainPool = convexPool;\n\n        uint256 rewardsLength = rewards.length;\n\n        if (rewardsLength == 0) {\n            RewardType storage reward = rewards.push();\n            reward.reward_token = crv;\n            reward.reward_pool = mainPool;\n            rewardsLength += 1;\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        uint256 startIndex = rewardsLength - 1;\n        for (uint256 i = startIndex; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            RewardType storage reward = rewards.push();\n            reward.reward_token = IRewardStaking(extraPool).rewardToken();\n            reward.reward_pool = extraPool;\n        }\n    }\n\n    /// @notice Returns the length of the reward tokens added\n    /// @return The count of reward tokens\n    function rewardLength() external view returns (uint256) {\n        return rewards.length;\n    }\n\n    /// @notice Get user's balance\n    /// @param _account User's address for which balance is requested\n    /// @return User's balance of collateral\n    /// @dev Included here to allow inheriting contracts to override.\n    function _getDepositedBalance(address _account) internal view virtual returns (uint256) {\n        if (_account == address(0) || _account == collateralVault) {\n            return 0;\n        }\n        //get balance from collateralVault\n\n        return _balanceOf[_account];\n    }\n\n    /// @notice TotalSupply of wrapped token\n    /// @return The total supply of wrapped token\n    /// @dev This function is provided and marked virtual as convenience to future development\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Calculates & upgrades the integral for distributing the CVX rewards\n    /// @param _accounts Accounts for which the CvxIntegral has to be calculated\n    /// @param _balances Balances of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcCvxIntegral(\n        address[2] memory _accounts,\n        uint256[2] memory _balances,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        uint256 bal = IERC20(cvx).balanceOf(address(this));\n        uint256 cvxRewardRemaining = cvx_reward_remaining;\n        uint256 d_cvxreward = bal - cvxRewardRemaining;\n        uint256 cvxRewardIntegral = cvx_reward_integral;\n\n        if (_supply > 0 && d_cvxreward > 0) {\n            cvxRewardIntegral = cvxRewardIntegral + (d_cvxreward * 1e20) / (_supply);\n            cvx_reward_integral = cvxRewardIntegral;\n        }\n\n        //update user integrals for cvx\n        uint256 accountsLength = _accounts.length;\n        for (uint256 u = 0; u < accountsLength; u++) {\n            //do not give rewards to address 0\n            if (_accounts[u] == address(0)) continue;\n            if (_accounts[u] == collateralVault) continue;\n\n            uint256 userI = cvx_reward_integral_for[_accounts[u]];\n            if (_isClaim || userI < cvxRewardIntegral) {\n                uint256 receiveable = cvx_claimable_reward[_accounts[u]] +\n                    ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);\n                if (_isClaim) {\n                    if (receiveable > 0) {\n                        cvx_claimable_reward[_accounts[u]] = 0;\n                        IERC20(cvx).safeTransfer(_accounts[u], receiveable);\n                        bal = bal - (receiveable);\n                    }\n                } else {\n                    cvx_claimable_reward[_accounts[u]] = receiveable;\n                }\n                cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral;\n            }\n        }\n\n        //update reward total\n        if (bal != cvxRewardRemaining) {\n            cvx_reward_remaining = bal;\n        }\n    }\n\n    /// @notice Calculates & upgrades the integral for distributing the reward token\n    /// @param _index The index of the reward token for which the calculations are to be done\n    /// @param _accounts Accounts for which the CvxIntegral has to be calculated\n    /// @param _balances Balances of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcRewardIntegral(\n        uint256 _index,\n        address[2] memory _accounts,\n        uint256[2] memory _balances,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        RewardType storage reward = rewards[_index];\n\n        uint256 rewardIntegral = reward.reward_integral;\n        uint256 rewardRemaining = reward.reward_remaining;\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n        if (_supply > 0 && (bal - rewardRemaining) > 0) {\n            rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);\n            reward.reward_integral = uint128(rewardIntegral);\n        }\n        //update user integrals\n        uint256 accountsLength = _accounts.length;\n        for (uint256 u = 0; u < accountsLength; u++) {\n            //do not give rewards to address 0\n            if (_accounts[u] == address(0)) continue;\n            if (_accounts[u] == collateralVault) continue;\n\n            uint256 userI = reward.reward_integral_for[_accounts[u]];\n            if (_isClaim || userI < rewardIntegral) {\n                if (_isClaim) {\n                    uint256 receiveable = reward.claimable_reward[_accounts[u]] +\n                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);\n                    if (receiveable > 0) {\n                        reward.claimable_reward[_accounts[u]] = 0;\n                        IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);\n                        bal = bal - receiveable;\n                    }\n                } else {\n                    reward.claimable_reward[_accounts[u]] =\n                        reward.claimable_reward[_accounts[u]] +\n                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);\n                }\n                reward.reward_integral_for[_accounts[u]] = rewardIntegral;\n            }\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != rewardRemaining) {\n            reward.reward_remaining = uint128(bal);\n        }\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function _checkpoint(address[2] memory _accounts) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (isShutdown) return;\n\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]);\n        depositedBalance[1] = _getDepositedBalance(_accounts[1]);\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);\n        }\n        _calcCvxIntegral(_accounts, depositedBalance, supply, false);\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them & claims the rewards\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function _checkpointAndClaim(address[2] memory _accounts) internal {\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]); //only do first slot\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, true);\n        }\n        _calcCvxIntegral(_accounts, depositedBalance, supply, true);\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function user_checkpoint(address[2] calldata _accounts) external returns (bool) {\n        _checkpoint([_accounts[0], _accounts[1]]);\n        return true;\n    }\n\n    /// @notice Get the balance of the user\n    /// @param _account Address whose balance is to be checked\n    /// @return The balance of the supplied address\n    function totalBalanceOf(address _account) external view returns (uint256) {\n        return _getDepositedBalance(_account);\n    }\n\n    /// @notice Get the amount of tokens the user has earned\n    /// @param _account Address whose balance is to be checked\n    /// @return claimable Array of earned tokens and their amount\n    function earned(address _account) external view returns (EarnedData[] memory claimable) {\n        uint256 supply = _getTotalSupply();\n        uint256 rewardCount = rewards.length;\n        claimable = new EarnedData[](rewardCount + 1);\n\n        for (uint256 i = 0; i < rewardCount; i++) {\n            RewardType storage reward = rewards[i];\n            address rewardToken = reward.reward_token;\n\n            //change in reward is current balance - remaining reward + earned\n            uint256 bal = IERC20(rewardToken).balanceOf(address(this));\n            uint256 d_reward = bal - reward.reward_remaining;\n            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));\n\n            uint256 I = reward.reward_integral;\n            if (supply > 0) {\n                I = I + (d_reward * 1e20) / supply;\n            }\n\n            uint256 newlyClaimable = (_getDepositedBalance(_account) * (I - reward.reward_integral_for[_account])) /\n                1e20;\n            claimable[i].amount = reward.claimable_reward[_account] + newlyClaimable;\n            claimable[i].token = rewardToken;\n\n            //calc cvx here\n            if (rewardToken == crv) {\n                claimable[rewardCount].amount =\n                    cvx_claimable_reward[_account] +\n                    CvxMining.ConvertCrvToCvx(newlyClaimable);\n                claimable[rewardCount].token = cvx;\n            }\n        }\n        return claimable;\n    }\n\n    /// @notice Claim reward for the supplied account\n    /// @param _account Address whose reward is to be claimed\n    function getReward(address _account) external {\n        //claim directly in checkpoint logic to save a bit of gas\n        _checkpointAndClaim([_account, address(0)]);\n    }\n}\n\n\n",
        "CodeNames": [
            "ConvexYieldWrapper.sol",
            "ConvexStakingWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction _getDepositedBalance(address account_) internal view override returns (uint256) {\n    if (account_ == address(0) || account_ == collateralVault) {\n        return 0;\n    }\n\n    bytes12[] memory userVault = vaults[account_];\n\n    //add up all balances of all vaults registered in the wrapper and owned by the account\n    uint256 collateral;\n    DataTypes.Balances memory balance;\n    uint256 userVaultLength = userVault.length;\n    for (uint256 i = 0; i < userVaultLength; i++) {\n        if (cauldron.vaults(userVault[i]).owner == account_) {\n            balance = cauldron.balances(userVault[i]);\n            collateral = collateral + balance.ink;\n        }\n    }\n\n    //add to balance of this token\n    return _balanceOf[account_] + collateral;\n}\n"
                ],
                "Type": " Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol",
                "Description": "\nConvexYieldWrapper.sol is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the Ladle.sol contract's batch() function which:\n\n*   Approves Ladle to move the tokens.\n*   Transfers the tokens to ConvexYieldWrapper.sol.\n*   Wraps/stakes these tokens.\n*   Updates accounting and produces debt tokens within Ladle.sol.\n\n_getDepositedBalance() takes into consideration the user's total collateral stored in all of their owned vaults. However, as a vault owner, you are allowed to give the vault to another user, move collateral between vaults and add/remove collateral. Therefore, it is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then create a new checkpoint with this user.\n\nAs a result, a user is able to generate protocol yield multiple times over on a single collateral amount. This can be abused to effectively extract all protocol yield.\n\n\nConsider the following exploit scenario:\n\n*   Alice owns a vault which has 100 tokens worth of collateral.\n*   At that point in time, _getDepositedBalance() returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards.\n*   Alice then calls Ladle.give(), transferring the ownership of the vault to Bob and calls ConvexYieldWrapper.addVault().\n*   Bob is able to call user_checkpoint() and effectively update their checkpointed balance.\n*   At this point in time, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.\n\n<https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexYieldWrapper.sol#L100-L120\nsolidity\nfunction _getDepositedBalance(address account_) internal view override returns (uint256) {\n    if (account_ == address(0) || account_ == collateralVault) {\n        return 0;\n    }\n\n    bytes12[] memory userVault = vaults[account_];\n\n    //add up all balances of all vaults registered in the wrapper and owned by the account\n    uint256 collateral;\n    DataTypes.Balances memory balance;\n    uint256 userVaultLength = userVault.length;\n    for (uint256 i = 0; i < userVaultLength; i++) {\n        if (cauldron.vaults(userVault[i]).owner == account_) {\n            balance = cauldron.balances(userVault[i]);\n            collateral = collateral + balance.ink;\n        }\n    }\n\n    //add to balance of this token\n    return _balanceOf[account_] + collateral;\n}\n\n\n\nManual code review.\nDiscussion/confirmation with the Yield Protocol team.\n\n",
                "Repair": "\nEnsure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.\n\niamsahu (Yield) confirmed(https://github.com/code-423n4/2022-01-yield-findings/issues/89)\n\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-01-yield-findings/issues/89#issuecomment-1044656259):\n  The warden identified a way to sidestep the accounting in the ConvexYieldWrapper.\n \n Because ConvexYieldWrapper takes lazy accounting, transferring vaults at the Ladle level allows to effectively register the same vault under multiple accounts, which ultimately allow to steal more yield than expected.\n \n While the loss of yield can be classified as a medium severity, the fact that the warden was able to break the accounting invariants of the ConvexYieldWrapper leads me to raise the severity to high\n \n Ultimately mitigation will require to _checkpoint also when vault operations happen (especially transfer), this may require a rethinking at the Ladle level as the reason why the warden was able to sidestep the checkpoint is because the Ladle doesn't notify the Wrapper of any vault transfers\n\nalcueca (Yield) commented(https://github.com/code-423n4/2022-01-yield-findings/issues/89#issuecomment-1046642319):\n  Yes, that's right. To fix this issue we will deploy a separate Ladle to deal specifically with convex tokens. The fix will probably involve removing stir and give instead of notifying the wrapper, but we'll see.\n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\";\n\nimport \"./interfaces/ICurvePool.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\n\n// Oracle Code Inspiration: https://github.com/Abracadabra-money/magic-internet-money/blob/main/contracts/oracles/3CrvOracle.sol\n/**\n *@title  Cvx3CrvOracle\n *@notice Provides current values for Cvx3Crv\n *@dev    Both peek() (view) and get() (transactional) are provided for convenience\n */\ncontract Cvx3CrvOracle is IOracle, AccessControl {\n    using CastBytes32Bytes6 for bytes32;\n    ICurvePool public threecrv;\n    AggregatorV3Interface public DAI;\n    AggregatorV3Interface public USDC;\n    AggregatorV3Interface public USDT;\n\n    bytes32 public cvx3CrvId;\n    bytes32 public ethId;\n\n    /**\n     *@notice Set threecrv pool and the chainlink sources\n     *@param  cvx3CrvId_ cvx3crv Id\n     *@param  ethId_ ETH ID\n     *@param  threecrv_ The 3CRV pool address\n     *@param  DAI_ DAI/ETH chainlink price feed address\n     *@param  USDC_ USDC/ETH chainlink price feed address\n     *@param  USDT_ USDT/ETH chainlink price feed address\n     */\n    function setSource(\n        bytes32 cvx3CrvId_,\n        bytes32 ethId_,\n        ICurvePool threecrv_,\n        AggregatorV3Interface DAI_,\n        AggregatorV3Interface USDC_,\n        AggregatorV3Interface USDT_\n    ) external auth {\n        cvx3CrvId = cvx3CrvId_;\n        ethId = ethId_;\n        threecrv = threecrv_;\n        DAI = DAI_;\n        USDC = USDC_;\n        USDT = USDT_;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.\n     * @param base Id of base token\n     * @param quote Id of quoted token\n     * @return quoteAmount Total amount in terms of quoted token\n     * @return updateTime Time quote was last updated\n     */\n    function peek(\n        bytes32 base,\n        bytes32 quote,\n        uint256 baseAmount\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256 quoteAmount, uint256 updateTime)\n    {\n        return _peek(base.b6(), quote.b6(), baseAmount);\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.\n     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.\n     * @param base Id of base token\n     * @param quote Id of quoted token\n     * @return quoteAmount Total amount in terms of quoted token\n     * @return updateTime Time quote was last updated\n     */\n    function get(\n        bytes32 base,\n        bytes32 quote,\n        uint256 baseAmount\n    )\n        external\n        virtual\n        override\n        returns (uint256 quoteAmount, uint256 updateTime)\n    {\n        return _peek(base.b6(), quote.b6(), baseAmount);\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.\n     * @param base Id of base token\n     * @param quote Id of quoted token\n     * @return quoteAmount Total amount in terms of quoted token\n     * @return updateTime Time quote was last updated\n     */\n    function _peek(\n        bytes6 base,\n        bytes6 quote,\n        uint256 baseAmount\n    ) private view returns (uint256 quoteAmount, uint256 updateTime) {\n        require(\n            (base == ethId && quote == cvx3CrvId) ||\n                (base == cvx3CrvId && quote == ethId),\n            \"Invalid quote or base\"\n        );\n        (, int256 daiPrice, , , ) = DAI.latestRoundData();\n        (, int256 usdcPrice, , , ) = USDC.latestRoundData();\n        (, int256 usdtPrice, , , ) = USDT.latestRoundData();\n\n        require(\n            daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0,\n            \"Chainlink pricefeed reporting 0\"\n        );\n\n        // This won't overflow as the max value for int256 is less than the max value for uint256\n        uint256 minStable = min(\n            uint256(daiPrice),\n            min(uint256(usdcPrice), uint256(usdtPrice))\n        );\n\n        uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18;\n\n        if (base == cvx3CrvId && quote == ethId) {\n            quoteAmount = (baseAmount * price) / 1e18;\n        } else {\n            quoteAmount = (baseAmount * 1e18) / price;\n        }\n\n        updateTime = block.timestamp;\n    }\n}\n\n\n",
        "CodeNames": [
            "Cvx3CrvOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "javascript\nfunction _peek(\n    bytes6 base,\n    bytes6 quote,\n    uint256 baseAmount\n) private view returns (uint256 quoteAmount, uint256 updateTime) {\n    ...\n\n    (, int256 daiPrice, , , ) = DAI.latestRoundData();\n    (, int256 usdcPrice, , , ) = USDC.latestRoundData();\n    (, int256 usdtPrice, , , ) = USDT.latestRoundData();\n\n    require(\n        daiPrice  0 && usdcPrice  0 && usdtPrice  0,\n        \"Chainlink pricefeed reporting 0\"\n    );\n\n    ...\n}\n"
                ],
                "Type": " Oracle data feed is insufficiently validated",
                "Description": "\nPrice can be stale and can lead to wrong quoteAmount return value\n\n\nOracle data feed is insufficiently validated. There is no check for stale price and round completeness.\nPrice can be stale and can lead to wrong quoteAmount return value\n\njavascript\nfunction _peek(\n    bytes6 base,\n    bytes6 quote,\n    uint256 baseAmount\n) private view returns (uint256 quoteAmount, uint256 updateTime) {\n    ...\n\n    (, int256 daiPrice, , , ) = DAI.latestRoundData();\n    (, int256 usdcPrice, , , ) = USDC.latestRoundData();\n    (, int256 usdtPrice, , , ) = USDT.latestRoundData();\n\n    require(\n        daiPrice  0 && usdcPrice  0 && usdtPrice  0,\n        \"Chainlink pricefeed reporting 0\"\n    );\n\n    ...\n}\n\n\n",
                "Repair": "\nValidate data feed\n\njavascript\nfunction _peek(\n    bytes6 base,\n    bytes6 quote,\n    uint256 baseAmount\n) private view returns (uint256 quoteAmount, uint256 updateTime) {\n    ...\n    (uint80 roundID, int256 daiPrice, , uint256 timestamp, uint80 answeredInRound) = DAI.latestRoundData();\n    require(daiPrice  0, \"ChainLink: DAI price <= 0\");\n    require(answeredInRound = roundID, \"ChainLink: Stale price\");\n    require(timestamp  0, \"ChainLink: Round not complete\");\n\n    (roundID, int256 usdcPrice, , timestamp, answeredInRound) = USDC.latestRoundData();\n    require(usdcPrice  0, \"ChainLink: USDC price <= 0\");\n    require(answeredInRound = roundID, \"ChainLink: Stale USDC price\");\n    require(timestamp  0, \"ChainLink: USDC round not complete\");\n\n    (roundID, int256 usdtPrice, , timestamp, answeredInRound) = USDT.latestRoundData();\n    require(usdtPrice  0, \"ChainLink: USDT price <= 0\");\n    require(answeredInRound = roundID, \"ChainLink: Stale USDT price\");\n    require(timestamp  0, \"ChainLink: USDT round not complete\");\n\n    ...\n}\n\n\niamsahu (Yield) confirmed and resolved(https://github.com/code-423n4/2022-01-yield-findings/issues/136)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-01-yield-findings/issues/136#issuecomment-1039639929):\n  When using Chainlink Price feeds it is important to ensure the price feed data was updated recently.\n While getting started with chainlink requires just one line of code, it is best to add additional checks for in production environments.\n \n I believe the finding to be valid and Medium severity to be appropriate.\n \n The sponsor has mitigated in a subsequent PR.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// Original contract: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/ERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\";\nimport \"./interfaces/IRewardStaking.sol\";\nimport \"./interfaces/IConvexDeposits.sol\";\nimport \"./interfaces/ICvx.sol\";\nimport \"./CvxMining.sol\";\n\n/// @notice Wrapper used to manage staking of Convex tokens\ncontract ConvexStakingWrapper is ERC20, AccessControl {\n    using TransferHelper for IERC20;\n\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n\n    struct RewardType {\n        address reward_token;\n        address reward_pool;\n        uint128 reward_integral;\n        uint128 reward_remaining;\n        mapping(address => uint256) reward_integral_for;\n        mapping(address => uint256) claimable_reward;\n    }\n\n    uint256 public cvx_reward_integral;\n    uint256 public cvx_reward_remaining;\n    mapping(address => uint256) public cvx_reward_integral_for;\n    mapping(address => uint256) public cvx_claimable_reward;\n\n    //constants/immutables\n    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public curveToken;\n    address public convexToken;\n    address public convexPool;\n    address public collateralVault;\n    uint256 public convexPoolId;\n\n    //rewards\n    RewardType[] public rewards;\n\n    //management\n    bool public isShutdown;\n    bool private _status;\n\n    bool private constant _NOT_ENTERED = false;\n    bool private constant _ENTERED = true;\n\n    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);\n\n    constructor(\n        address _curveToken,\n        address _convexToken,\n        address _convexPool,\n        uint256 _poolId,\n        address _vault,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20(name, symbol, decimals) {\n        curveToken = _curveToken;\n        convexToken = _convexToken;\n        convexPool = _convexPool;\n        convexPoolId = _poolId;\n        collateralVault = _vault;\n\n        //add rewards\n        addRewards();\n        setApprovals();\n    }\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /// @notice Give maximum approval to the pool & convex booster contract to transfer funds from wrapper\n    function setApprovals() public {\n        IERC20(curveToken).approve(convexBooster, 0);\n        IERC20(curveToken).approve(convexBooster, type(uint256).max);\n        IERC20(convexToken).approve(convexPool, type(uint256).max);\n    }\n\n    /// @notice Adds reward tokens by reading the available rewards from the RewardStaking pool\n    /// @dev CRV token is added as a reward by default\n    function addRewards() public {\n        address mainPool = convexPool;\n\n        uint256 rewardsLength = rewards.length;\n\n        if (rewardsLength == 0) {\n            RewardType storage reward = rewards.push();\n            reward.reward_token = crv;\n            reward.reward_pool = mainPool;\n            rewardsLength += 1;\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        uint256 startIndex = rewardsLength - 1;\n        for (uint256 i = startIndex; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            RewardType storage reward = rewards.push();\n            reward.reward_token = IRewardStaking(extraPool).rewardToken();\n            reward.reward_pool = extraPool;\n        }\n    }\n\n    /// @notice Returns the length of the reward tokens added\n    /// @return The count of reward tokens\n    function rewardLength() external view returns (uint256) {\n        return rewards.length;\n    }\n\n    /// @notice Get user's balance\n    /// @param _account User's address for which balance is requested\n    /// @return User's balance of collateral\n    /// @dev Included here to allow inheriting contracts to override.\n    function _getDepositedBalance(address _account) internal view virtual returns (uint256) {\n        if (_account == address(0) || _account == collateralVault) {\n            return 0;\n        }\n        //get balance from collateralVault\n\n        return _balanceOf[_account];\n    }\n\n    /// @notice TotalSupply of wrapped token\n    /// @return The total supply of wrapped token\n    /// @dev This function is provided and marked virtual as convenience to future development\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Calculates & upgrades the integral for distributing the CVX rewards\n    /// @param _accounts Accounts for which the CvxIntegral has to be calculated\n    /// @param _balances Balances of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcCvxIntegral(\n        address[2] memory _accounts,\n        uint256[2] memory _balances,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        uint256 bal = IERC20(cvx).balanceOf(address(this));\n        uint256 cvxRewardRemaining = cvx_reward_remaining;\n        uint256 d_cvxreward = bal - cvxRewardRemaining;\n        uint256 cvxRewardIntegral = cvx_reward_integral;\n\n        if (_supply > 0 && d_cvxreward > 0) {\n            cvxRewardIntegral = cvxRewardIntegral + (d_cvxreward * 1e20) / (_supply);\n            cvx_reward_integral = cvxRewardIntegral;\n        }\n\n        //update user integrals for cvx\n        uint256 accountsLength = _accounts.length;\n        for (uint256 u = 0; u < accountsLength; u++) {\n            //do not give rewards to address 0\n            if (_accounts[u] == address(0)) continue;\n            if (_accounts[u] == collateralVault) continue;\n\n            uint256 userI = cvx_reward_integral_for[_accounts[u]];\n            if (_isClaim || userI < cvxRewardIntegral) {\n                uint256 receiveable = cvx_claimable_reward[_accounts[u]] +\n                    ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);\n                if (_isClaim) {\n                    if (receiveable > 0) {\n                        cvx_claimable_reward[_accounts[u]] = 0;\n                        IERC20(cvx).safeTransfer(_accounts[u], receiveable);\n                        bal = bal - (receiveable);\n                    }\n                } else {\n                    cvx_claimable_reward[_accounts[u]] = receiveable;\n                }\n                cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral;\n            }\n        }\n\n        //update reward total\n        if (bal != cvxRewardRemaining) {\n            cvx_reward_remaining = bal;\n        }\n    }\n\n    /// @notice Calculates & upgrades the integral for distributing the reward token\n    /// @param _index The index of the reward token for which the calculations are to be done\n    /// @param _accounts Accounts for which the CvxIntegral has to be calculated\n    /// @param _balances Balances of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcRewardIntegral(\n        uint256 _index,\n        address[2] memory _accounts,\n        uint256[2] memory _balances,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        RewardType storage reward = rewards[_index];\n\n        uint256 rewardIntegral = reward.reward_integral;\n        uint256 rewardRemaining = reward.reward_remaining;\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n        if (_supply > 0 && (bal - rewardRemaining) > 0) {\n            rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);\n            reward.reward_integral = uint128(rewardIntegral);\n        }\n        //update user integrals\n        uint256 accountsLength = _accounts.length;\n        for (uint256 u = 0; u < accountsLength; u++) {\n            //do not give rewards to address 0\n            if (_accounts[u] == address(0)) continue;\n            if (_accounts[u] == collateralVault) continue;\n\n            uint256 userI = reward.reward_integral_for[_accounts[u]];\n            if (_isClaim || userI < rewardIntegral) {\n                if (_isClaim) {\n                    uint256 receiveable = reward.claimable_reward[_accounts[u]] +\n                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);\n                    if (receiveable > 0) {\n                        reward.claimable_reward[_accounts[u]] = 0;\n                        IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);\n                        bal = bal - receiveable;\n                    }\n                } else {\n                    reward.claimable_reward[_accounts[u]] =\n                        reward.claimable_reward[_accounts[u]] +\n                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);\n                }\n                reward.reward_integral_for[_accounts[u]] = rewardIntegral;\n            }\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != rewardRemaining) {\n            reward.reward_remaining = uint128(bal);\n        }\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function _checkpoint(address[2] memory _accounts) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (isShutdown) return;\n\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]);\n        depositedBalance[1] = _getDepositedBalance(_accounts[1]);\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);\n        }\n        _calcCvxIntegral(_accounts, depositedBalance, supply, false);\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them & claims the rewards\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function _checkpointAndClaim(address[2] memory _accounts) internal {\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]); //only do first slot\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, true);\n        }\n        _calcCvxIntegral(_accounts, depositedBalance, supply, true);\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function user_checkpoint(address[2] calldata _accounts) external returns (bool) {\n        _checkpoint([_accounts[0], _accounts[1]]);\n        return true;\n    }\n\n    /// @notice Get the balance of the user\n    /// @param _account Address whose balance is to be checked\n    /// @return The balance of the supplied address\n    function totalBalanceOf(address _account) external view returns (uint256) {\n        return _getDepositedBalance(_account);\n    }\n\n    /// @notice Get the amount of tokens the user has earned\n    /// @param _account Address whose balance is to be checked\n    /// @return claimable Array of earned tokens and their amount\n    function earned(address _account) external view returns (EarnedData[] memory claimable) {\n        uint256 supply = _getTotalSupply();\n        uint256 rewardCount = rewards.length;\n        claimable = new EarnedData[](rewardCount + 1);\n\n        for (uint256 i = 0; i < rewardCount; i++) {\n            RewardType storage reward = rewards[i];\n            address rewardToken = reward.reward_token;\n\n            //change in reward is current balance - remaining reward + earned\n            uint256 bal = IERC20(rewardToken).balanceOf(address(this));\n            uint256 d_reward = bal - reward.reward_remaining;\n            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));\n\n            uint256 I = reward.reward_integral;\n            if (supply > 0) {\n                I = I + (d_reward * 1e20) / supply;\n            }\n\n            uint256 newlyClaimable = (_getDepositedBalance(_account) * (I - reward.reward_integral_for[_account])) /\n                1e20;\n            claimable[i].amount = reward.claimable_reward[_account] + newlyClaimable;\n            claimable[i].token = rewardToken;\n\n            //calc cvx here\n            if (rewardToken == crv) {\n                claimable[rewardCount].amount =\n                    cvx_claimable_reward[_account] +\n                    CvxMining.ConvertCrvToCvx(newlyClaimable);\n                claimable[rewardCount].token = cvx;\n            }\n        }\n        return claimable;\n    }\n\n    /// @notice Claim reward for the supplied account\n    /// @param _account Address whose reward is to be claimed\n    function getReward(address _account) external {\n        //claim directly in checkpoint logic to save a bit of gas\n        _checkpointAndClaim([_account, address(0)]);\n    }\n}\n\n\n",
        "CodeNames": [
            "ConvexStakingWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nfunction _calcRewardIntegral(\n    uint256 _index,\n    address[2] memory _accounts,\n    uint256[2] memory _balances,\n    uint256 _supply,\n    bool _isClaim\n) internal {\n    RewardType storage reward = rewards[_index];\n\n    uint256 rewardIntegral = reward.reward_integral;\n    uint256 rewardRemaining = reward.reward_remaining;\n\n    //get difference in balance and remaining rewards\n    //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed\n    uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n    if (_supply  0 && (bal rewardRemaining)  0) {\n        rewardIntegral = uint128(rewardIntegral) + uint128(((bal rewardRemaining) * 1e20) / _supply);\n        reward.reward_integral = uint128(rewardIntegral);\n    }\n"
                ],
                "Type": " Rewards distribution can be disrupted by a early user",
                "Description": "\n<https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206-L224\n\nsolidity\nfunction _calcRewardIntegral(\n    uint256 _index,\n    address[2] memory _accounts,\n    uint256[2] memory _balances,\n    uint256 _supply,\n    bool _isClaim\n) internal {\n    RewardType storage reward = rewards[_index];\n\n    uint256 rewardIntegral = reward.reward_integral;\n    uint256 rewardRemaining = reward.reward_remaining;\n\n    //get difference in balance and remaining rewards\n    //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed\n    uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n    if (_supply  0 && (bal rewardRemaining)  0) {\n        rewardIntegral = uint128(rewardIntegral) + uint128(((bal rewardRemaining) * 1e20) / _supply);\n        reward.reward_integral = uint128(rewardIntegral);\n    }\n\n\nreward.reward_integral is uint128, if a early user mint (wrap) just 1 Wei of convexToken, and make _supply == 1, and then tranferring 5e18 of reward_token to the contract.\n\nAs a result, reward.reward_integral can exceed type(uint128).max and overflow, causing the rewards distribution to be disrupted.\n\n",
                "Repair": "\nConsider wrap a certain amount of initial totalSupply, e.g. 1e8, and never burn it. And consider using uint256 instead of uint128 for reward.reward_integral. Also, consdier lower 1e20 down to 1e12.\n\nalcueca (Yield) confirmed but disagreed with severity and commented(https://github.com/code-423n4/2022-01-yield-findings/issues/116#issuecomment-1028062625):\n  Assets are not a direct risk if it is the first user disrupting the contract. We would need to redeploy better code, but that's it. I suggest this is reported as medium, as merits for a DoS attack.\n \n As suggested elsewhere, the right solution if uint128 is to be used in storage, is to cast up to uint256 for calculations, and then back to uint128 to store again.\n\niamsahu (Yield) resolved(https://github.com/code-423n4/2022-01-yield-findings/issues/116)\n\nAlex the Entreprenerd (judge) changed severity from High to Medium and commented(https://github.com/code-423n4/2022-01-yield-findings/issues/116#issuecomment-1043687140):\n  The warden identified a way an early depositor can grief the system, I believe the finding to be valid, and because:\n It would conditionally disrupt the system\n It would \"brick the contract\" at the loss of the griefer\n No additional funds would be at risk\n \n I believe medium severity to be appropriate\n\n\n\n*\n\n\n"
            }
        ]
    }
]