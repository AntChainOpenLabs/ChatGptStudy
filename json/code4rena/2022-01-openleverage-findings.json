[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2 ;\n\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Airdrop is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    event TrancheAdded (uint256 tranchId, bytes32 merkleRoot, uint64 startTime, uint64 endTime, uint256 totalAmount);\n    event Claimed(uint256 tranchId, address account, uint256 balance);\n    event TrancheExpired (uint256 tranchId, uint expireAmount);\n    struct Tranche {\n        bytes32 merkleRoot;\n        uint64 startTime;\n        uint64 endTime;\n        uint256 totalAmount;\n        uint256 claimedAmount;\n    }\n\n    IERC20 public token;\n    mapping(uint256 => Tranche) public tranches;\n    mapping(uint256 => mapping(address => bool)) public claimed;\n    uint256 public trancheIdx;\n\n    constructor (IERC20 _token){\n        token = _token;\n    }\n\n    function newTranche(bytes32 merkleRoot, uint64 startTime, uint64 endTime, uint256 totalAmount) external onlyOwner\n    {\n        require(endTime > block.timestamp, 'Incorrect endtime');\n        uint trancheId = trancheIdx;\n        tranches[trancheId] = Tranche(merkleRoot, startTime, endTime, totalAmount, 0);\n        trancheIdx = trancheIdx.add(1);\n        emit TrancheAdded(trancheId, merkleRoot, startTime, endTime, totalAmount);\n    }\n\n    function expireTranche(uint256 _trancheId) external onlyOwner {\n        Tranche memory tranche = tranches[_trancheId];\n        require(block.timestamp > tranche.endTime, 'Not End');\n        uint expireAmount = tranche.totalAmount.sub(tranche.claimedAmount);\n        if (expireAmount > 0) {\n            token.safeTransfer(owner(), expireAmount);\n        }\n        delete tranches[_trancheId];\n        emit TrancheExpired(_trancheId, expireAmount);\n    }\n\n    function claim(address account, uint256 _trancheId, uint256 _balance, bytes32[] calldata _merkleProof) external\n    {\n        _claim(account, _trancheId, _balance, _merkleProof);\n        _disburse(account, _balance);\n    }\n\n    function claims(address account, uint256[] calldata _trancheIds, uint256[] calldata _balances, bytes32[][] calldata _merkleProofs) external {\n        uint256 len = _trancheIds.length;\n        require(len == _balances.length && len == _merkleProofs.length, \"Mismatching inputs\");\n        uint256 totalBalance = 0;\n        for (uint256 i = 0; i < len; i ++) {\n            _claim(account, _trancheIds[i], _balances[i], _merkleProofs[i]);\n            totalBalance = totalBalance.add(_balances[i]);\n        }\n        _disburse(account, totalBalance);\n    }\n\n    function verifyClaim(address account, uint256 _trancheId, uint256 _balance, bytes32[] calldata _merkleProof) external view returns (bool valid) {\n        return _verifyClaim(account, tranches[_trancheId].merkleRoot, _balance, _merkleProof);\n    }\n\n    function _claim(address account, uint256 _trancheId, uint256 _balance, bytes32[] memory _merkleProof) private {\n        require(_trancheId < trancheIdx, \"Incorrect trancheId\");\n        require(tranches[_trancheId].startTime < block.timestamp, \"Not Start\");\n        require(tranches[_trancheId].endTime > block.timestamp, \"Expire\");\n        require(!claimed[_trancheId][account], \"Already claimed\");\n        require(_verifyClaim(account, tranches[_trancheId].merkleRoot, _balance, _merkleProof), \"Incorrect merkle proof\");\n        claimed[_trancheId][account] = true;\n        tranches[_trancheId].claimedAmount = tranches[_trancheId].claimedAmount.add(_balance);\n        emit Claimed(_trancheId, account, _balance);\n    }\n\n    function _verifyClaim(address account, bytes32 root, uint256 _balance, bytes32[] memory _merkleProof) private pure returns (bool valid) {\n        bytes32 leaf = keccak256(abi.encodePacked(account, _balance));\n        return MerkleProof.verify(_merkleProof, root, leaf);\n    }\n\n    function _disburse(address account, uint256 _balance) private {\n        if (_balance > 0) {\n            token.safeTransfer(account, _balance);\n        } else {\n            revert(\"No balance would be transferred\");\n        }\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OpenLevInterface.sol\";\nimport \"./Types.sol\";\nimport \"./Adminable.sol\";\nimport \"./DelegateInterface.sol\";\nimport \"./ControllerInterface.sol\";\nimport \"./IWETH.sol\";\nimport \"./XOLEInterface.sol\";\nimport \"./Types.sol\";\nimport \"./OpenLevV1Lib.sol\";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param _controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, \"NAD\");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i < _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow > 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, \"MAM\");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed > 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), \"PNH\");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, \"ISR\");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, \"ISR\");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, \"ISB\");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), \"IRP\");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), \"PIH\");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty > 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, \"PH\");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance >= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance >= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount > 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount > 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on \"to\" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    /*** Admin Functions ***/\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld <= trade.held, \"CBH\");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), \"HI0\");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), \"UDX\");\n        _;\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport \"./Types.sol\";\nimport \"./liquidity/LPoolInterface.sol\";\nimport \"./ControllerInterface.sol\";\nimport \"./dex/DexAggregatorInterface.sol\";\nimport \"./OpenLevInterface.sol\";\nimport \"./lib/DexData.sol\";\nimport \"./lib/TransferHelper.sol\";\nimport \"./lib/Utils.sol\";\n\nabstract contract OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n\n    struct CalculateConfig {\n        uint16 defaultFeesRate; // 30 =>0.003\n        uint8 insuranceRatio; // 33=>33%\n        uint16 defaultMarginLimit; // 3000=>30%\n        uint16 priceDiffientRatio; //10=>10%\n        uint16 updatePriceDiscount;//25=>25%\n        uint16 feesDiscount; // 25=>25%\n        uint128 feesDiscountThreshold; //  30 * (10 ** 18) minimal holding of xOLE to enjoy fees discount\n        uint16 penaltyRatio;//100=>1%\n        uint8 maxLiquidationPriceDiffientRatio;//30=>30%\n        uint16 twapDuration;//28=>28s\n    }\n\n    struct AddressConfig {\n        DexAggregatorInterface dexAggregator;\n        address controller;\n        address wETH;\n        address xOLE;\n    }\n\n    // number of markets\n    uint16 public numPairs;\n\n    // marketId => Pair\n    mapping(uint16 => Types.Market) public markets;\n\n    // owner => marketId => long0(true)/long1(false) => Trades\n    mapping(address => mapping(uint16 => mapping(bool => Types.Trade))) public activeTrades;\n\n    //useless\n    mapping(address => bool) public allowedDepositTokens;\n\n    CalculateConfig public calculateConfig;\n\n    AddressConfig public addressConfig;\n\n    mapping(uint8 => bool) public supportDexs;\n\n    mapping(address => uint) public totalHelds;\n\n    // map(marketId, tokenAddress, index) => taxRate)\n    mapping(uint16 => mapping(address => mapping(uint => uint24))) public taxes;\n\n    event MarginTrade(\n        address trader,\n        uint16 marketId,\n        bool longToken, // 0 => long token 0; 1 => long token 1;\n        bool depositToken,\n        uint deposited,\n        uint borrowed,\n        uint held,\n        uint fees,\n        uint token0Price,\n        uint32 dex\n    );\n\n    event TradeClosed(\n        address owner,\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint closeAmount,\n        uint depositDecrease,\n        uint depositReturn,\n        uint fees,\n        uint token0Price,\n        uint32 dex\n    );\n\n    event Liquidation(\n        address owner,\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint liquidationAmount,\n        uint outstandingAmount,\n        address liquidator,\n        uint depositDecrease,\n        uint depositReturn,\n        uint fees,\n        uint token0Price,\n        uint penalty,\n        uint32 dex\n    );\n\n    event NewAddressConfig(address controller, address dexAggregator);\n\n    event NewCalculateConfig(\n        uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration);\n\n    event NewMarketConfig(uint16 marketId, uint16 feesRate, uint32 marginLimit, uint16 priceDiffientRatio, uint32[] dexs);\n\n    event ChangeAllowedDepositTokens(address[] token, bool allowed);\n\n}\n\n/**\n  * @title OpenLevInterface\n  * @author OpenLeverage\n  */\ninterface OpenLevInterface {\n\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external returns (uint16);\n\n\n    function marginTrade(uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, uint minBuyAmount, bytes memory dexData) external payable;\n\n    function closeTrade(uint16 marketId, bool longToken, uint closeAmount, uint minOrMaxAmount, bytes memory dexData) external;\n\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxAmount, bytes memory dexData) external;\n\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external view returns (uint current, uint cAvg, uint hAvg, uint32 limit);\n\n    function updatePrice(uint16 marketId, bytes memory dexData) external;\n\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external view returns (bool);\n\n    function getMarketSupportDexs(uint16 marketId) external view returns (uint32[] memory);\n\n    // function getCalculateConfig() external view returns (OpenLevStorage.CalculateConfig memory);\n\n    /*** Admin Functions ***/\n    function setCalculateConfig(uint16 defaultFeesRate, uint8 insuranceRatio, uint16 defaultMarginLimit, uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount, uint16 feesDiscount, uint128 feesDiscountThreshold, uint16 penaltyRatio, uint8 maxLiquidationPriceDiffientRatio, uint16 twapDuration) external;\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external;\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external;\n\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external;\n\n    function setSupportDex(uint8 dex, bool support) external;\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external;\n\n}\n\n\n",
        "CodeNames": [
            "Airdrop.sol",
            "OpenLevV1.sol",
            "OpenLevInterface.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "doTransferOut",
                    "transfer",
                    "transfer()",
                    "closeTrade"
                ],
                "Type": " OpenLevV1Lib's and LPool's  doTransferOut  functions call native  payable.transfer , which can be unusable for smart contract calls",
                "Description": "\nWhen OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a payable.transfer() call.\n\nThis is unsafe as transfer has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.\n\nWhenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.\n\nAs OpenLevV1 closeTrade is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.\n\n\nOpenLevV1Lib and LPool have doTransferOut function that calls native token payable.transfer:\n\nOpenLevV1Lib.doTransferOut\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253\n\nLPool.doTransferOut\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297\n\nLPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:\n\ncloseTrade\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215\n\nliquidate\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304\n\n\nThe issues with transfer() are outlined here:\n\n<https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n\n",
                "Repair": "\nOpenLevV1's closeTrade and liquidate as well as LPool's redeem, redeemUnderlying, borrowBehalf, repayBorrowBehalf, repayBorrowEndByOpenLev are all nonReentrant, so reentrancy isn't an issue and transfer() can be just replaced.\n\nUsing low-level call.value(amount) with the corresponding result check or using the OpenZeppelin Address.sendValue is advised:\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60\n\nColaM12 (OpenLeverage) confirmed and resolved(https://github.com/code-423n4/2022-01-openleverage-findings/issues/75)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/75#issuecomment-1045627508):\n  Awesome find! Completely agree with the warden here. This would prevent users from calling sensitive functions which withdraw their funds in some way. \n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport \"./Types.sol\";\nimport \"./liquidity/LPoolInterface.sol\";\nimport \"./ControllerInterface.sol\";\nimport \"./dex/DexAggregatorInterface.sol\";\nimport \"./OpenLevInterface.sol\";\nimport \"./lib/DexData.sol\";\nimport \"./lib/TransferHelper.sol\";\nimport \"./lib/Utils.sol\";\n\nabstract contract OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n\n    struct CalculateConfig {\n        uint16 defaultFeesRate; // 30 =>0.003\n        uint8 insuranceRatio; // 33=>33%\n        uint16 defaultMarginLimit; // 3000=>30%\n        uint16 priceDiffientRatio; //10=>10%\n        uint16 updatePriceDiscount;//25=>25%\n        uint16 feesDiscount; // 25=>25%\n        uint128 feesDiscountThreshold; //  30 * (10 ** 18) minimal holding of xOLE to enjoy fees discount\n        uint16 penaltyRatio;//100=>1%\n        uint8 maxLiquidationPriceDiffientRatio;//30=>30%\n        uint16 twapDuration;//28=>28s\n    }\n\n    struct AddressConfig {\n        DexAggregatorInterface dexAggregator;\n        address controller;\n        address wETH;\n        address xOLE;\n    }\n\n    // number of markets\n    uint16 public numPairs;\n\n    // marketId => Pair\n    mapping(uint16 => Types.Market) public markets;\n\n    // owner => marketId => long0(true)/long1(false) => Trades\n    mapping(address => mapping(uint16 => mapping(bool => Types.Trade))) public activeTrades;\n\n    //useless\n    mapping(address => bool) public allowedDepositTokens;\n\n    CalculateConfig public calculateConfig;\n\n    AddressConfig public addressConfig;\n\n    mapping(uint8 => bool) public supportDexs;\n\n    mapping(address => uint) public totalHelds;\n\n    // map(marketId, tokenAddress, index) => taxRate)\n    mapping(uint16 => mapping(address => mapping(uint => uint24))) public taxes;\n\n    event MarginTrade(\n        address trader,\n        uint16 marketId,\n        bool longToken, // 0 => long token 0; 1 => long token 1;\n        bool depositToken,\n        uint deposited,\n        uint borrowed,\n        uint held,\n        uint fees,\n        uint token0Price,\n        uint32 dex\n    );\n\n    event TradeClosed(\n        address owner,\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint closeAmount,\n        uint depositDecrease,\n        uint depositReturn,\n        uint fees,\n        uint token0Price,\n        uint32 dex\n    );\n\n    event Liquidation(\n        address owner,\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint liquidationAmount,\n        uint outstandingAmount,\n        address liquidator,\n        uint depositDecrease,\n        uint depositReturn,\n        uint fees,\n        uint token0Price,\n        uint penalty,\n        uint32 dex\n    );\n\n    event NewAddressConfig(address controller, address dexAggregator);\n\n    event NewCalculateConfig(\n        uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration);\n\n    event NewMarketConfig(uint16 marketId, uint16 feesRate, uint32 marginLimit, uint16 priceDiffientRatio, uint32[] dexs);\n\n    event ChangeAllowedDepositTokens(address[] token, bool allowed);\n\n}\n\n/**\n  * @title OpenLevInterface\n  * @author OpenLeverage\n  */\ninterface OpenLevInterface {\n\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external returns (uint16);\n\n\n    function marginTrade(uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, uint minBuyAmount, bytes memory dexData) external payable;\n\n    function closeTrade(uint16 marketId, bool longToken, uint closeAmount, uint minOrMaxAmount, bytes memory dexData) external;\n\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxAmount, bytes memory dexData) external;\n\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external view returns (uint current, uint cAvg, uint hAvg, uint32 limit);\n\n    function updatePrice(uint16 marketId, bytes memory dexData) external;\n\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external view returns (bool);\n\n    function getMarketSupportDexs(uint16 marketId) external view returns (uint32[] memory);\n\n    // function getCalculateConfig() external view returns (OpenLevStorage.CalculateConfig memory);\n\n    /*** Admin Functions ***/\n    function setCalculateConfig(uint16 defaultFeesRate, uint8 insuranceRatio, uint16 defaultMarginLimit, uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount, uint16 feesDiscount, uint128 feesDiscountThreshold, uint16 penaltyRatio, uint8 maxLiquidationPriceDiffientRatio, uint16 twapDuration) external;\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external;\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external;\n\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external;\n\n    function setSupportDex(uint8 dex, bool support) external;\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external;\n\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./UniV2ClassDex.sol\";\nimport \"../DexAggregatorInterface.sol\";\nimport \"../../lib/DexData.sol\";\nimport \"../../lib/Utils.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../DelegateInterface.sol\";\nimport \"../../Adminable.sol\";\n\n/// @title Swap logic on BSC\n/// @author OpenLeverage\n/// @notice Use this contract to swap tokens.\n/// @dev Routers for different swap requests.\ncontract BscDexAggregatorV1 is DelegateInterface, Adminable, DexAggregatorInterface, UniV2ClassDex {\n    using DexData for bytes;\n    using SafeMath for uint;\n\n    mapping(IUniswapV2Pair => V2PriceOracle) public uniV2PriceOracle;\n    IUniswapV2Factory public pancakeFactory;\n    address public openLev;\n    uint8 private constant priceDecimals = 18;\n\n    mapping(uint8 => DexInfo) public dexInfo;\n\n    //pancakeFactory: 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\n    function initialize(\n        IUniswapV2Factory _pancakeFactory,\n        address _unsedFactory\n    ) public {\n        require(msg.sender == admin, \"Not admin\");\n        // Shh - currently unused\n        _unsedFactory;\n        pancakeFactory = _pancakeFactory;\n        dexInfo[DexData.DEX_PANCAKE] = DexInfo(_pancakeFactory, 25);\n    }\n\n    /// @notice Save factories of the dex.\n    /// @param dexName Index of Dex. find list of dex in contracts/lib/DexData.sol.\n    /// @param factoryAddr Factory address of Different dex forked from uniswap.\n    /// @param fees Swap fee collects by dex.\n    function setDexInfo(uint8[] memory dexName, IUniswapV2Factory[] memory factoryAddr, uint16[] memory fees) external override onlyAdmin {\n        require(dexName.length == factoryAddr.length && dexName.length == fees.length, 'EOR');\n        for (uint i = 0; i < dexName.length; i++) {\n            DexInfo memory info = DexInfo(factoryAddr[i], fees[i]);\n            dexInfo[dexName[i]] = info;\n        }\n    }\n\n    /// @dev SetOpenlev address to update dex price\n    function setOpenLev(address _openLev) external onlyAdmin {\n        require(address(0) != _openLev, '0x');\n        openLev = _openLev;\n    }\n\n    /// @notice Sell tokens \n    /// @dev Sell exact amount of token with tax applied\n    /// @param buyToken Address of token transfer from Dex pair\n    /// @param sellToken Address of token transfer into Dex pair\n    /// @param buyTax Tax applyed by buyToken while transfer from Dex pair\n    /// @param sellTax Tax applyed by SellToken while transfer into Dex pair\n    /// @param sellAmount Exact amount to sell\n    /// @param minBuyAmount minmum amount of token to receive.\n    /// @param data Dex to use for swap\n    /// @return buyAmount Exact Amount bought\n    function sell(address buyToken, address sellToken, uint24 buyTax, uint24 sellTax, uint sellAmount, uint minBuyAmount, bytes memory data) external override returns (uint buyAmount){\n        buyTax;\n        sellTax;\n        address payer = msg.sender;\n        buyAmount = uniClassSell(dexInfo[data.toDex()], buyToken, sellToken, sellAmount, minBuyAmount, payer, payer);\n    }\n\n    /// @notice Sell tokens \n    /// @dev Sell exact amount of token through path\n    /// @param sellAmount Exact amount to sell\n    /// @param minBuyAmount minmum amount of token to receive.\n    /// @param data Dex to use for swap and path of the swap\n    /// @return buyAmount Exact amount bought\n    function sellMul(uint sellAmount, uint minBuyAmount, bytes memory data) external override returns (uint buyAmount){\n        buyAmount = uniClassSellMul(dexInfo[data.toDex()], sellAmount, minBuyAmount, data.toUniV2Path());\n    }\n\n    /// @notice Buy tokens \n    /// @dev Buy exact amount of token with tax applied\n    /// @param buyToken Address of token transfer from Dex pair\n    /// @param sellToken Address of token transfer into Dex pair\n    /// @param buyTax Tax applyed by buyToken while transfer from Dex pair\n    /// @param sellTax Tax applyed by sellToken while transfer into Dex pair\n    /// @param buyAmount Exact amount to buy\n    /// @param maxSellAmount maximum amount of token to receive.\n    /// @param data Dex to use for swap\n    /// @return sellAmount Exact amount sold\n    function buy(address buyToken, address sellToken, uint24 buyTax, uint24 sellTax, uint buyAmount, uint maxSellAmount, bytes memory data) external override returns (uint sellAmount){\n        sellAmount = uniClassBuy(dexInfo[data.toDex()], buyToken, sellToken, buyAmount, maxSellAmount, buyTax, sellTax);\n    }\n\n    /// @notice Calculate amount of token to buy \n    /// @dev Calculate exact amount of token to buy with tax applied\n    /// @param buyToken Address of token transfer from Dex pair\n    /// @param sellToken Address of token transfer into Dex pair\n    /// @param buyTax Tax applyed by buyToken while transfer from Dex pair\n    /// @param sellTax Tax applyed by sellToken while transfer into Dex pair\n    /// @param sellAmount Exact amount to sell\n    /// @param data Dex to use for swap\n    /// @return buyAmount Amount of buyToken would bought\n    function calBuyAmount(address buyToken, address sellToken, uint24 buyTax, uint24 sellTax, uint sellAmount, bytes memory data) external view override returns (uint buyAmount) {\n        sellAmount = Utils.toAmountAfterTax(sellAmount, sellTax);\n        buyAmount = uniClassCalBuyAmount(dexInfo[data.toDex()], buyToken, sellToken, sellAmount);\n        buyAmount = Utils.toAmountAfterTax(buyAmount, buyTax);\n    }\n\n    /// @notice Calculate amount of token to sell \n    /// @dev Calculate exact amount of token to sell with tax applied\n    /// @param buyToken Address of token transfer from Dex pair\n    /// @param sellToken Address of token transfer into Dex pair\n    /// @param buyTax Tax applyed by buyToken while transfer from Dex pair\n    /// @param sellTax Tax applyed by SellToken while transfer into Dex pair\n    /// @param buyAmount Exact amount to buy\n    /// @param data Dex to use for swap\n    /// @return sellAmount Amount of sellToken would sold\n    function calSellAmount(address buyToken, address sellToken, uint24 buyTax, uint24 sellTax, uint buyAmount, bytes memory data) external view override returns (uint sellAmount){\n        sellAmount = uniClassCalSellAmount(dexInfo[data.toDex()], buyToken, sellToken, buyAmount, buyTax, sellTax);\n    }\n\n    /// @notice Get price \n    /// @dev Get current price of desToken / quoteToken\n    /// @param desToken Token to be priced\n    /// @param quoteToken Token used for pricing\n    /// @param data Dex to use for swap\n    function getPrice(address desToken, address quoteToken, bytes memory data) external view override returns (uint256 price, uint8 decimals){\n        decimals = priceDecimals;\n        price = uniClassGetPrice(dexInfo[data.toDex()].factory, desToken, quoteToken, decimals);\n    }\n\n    /// @dev Get average price of desToken / quoteToken in the last period of time\n    /// @param desToken Token to be priced\n    /// @param quoteToken Token used for pricing\n    /// @param secondsAgo Time period of the average\n    /// @param data Dex to use for swap\n    function getAvgPrice(address desToken, address quoteToken, uint32 secondsAgo, bytes memory data) external view override returns (uint256 price, uint8 decimals, uint256 timestamp){\n        // Shh - currently unused\n        secondsAgo;\n        decimals = priceDecimals;\n        address pair = getUniClassPair(desToken, quoteToken, dexInfo[data.toDex()].factory);\n        V2PriceOracle memory priceOracle = uniV2PriceOracle[IUniswapV2Pair(pair)];\n        (price, timestamp) = uniClassGetAvgPrice(desToken, quoteToken, priceOracle);\n    }\n\n    /// @notice Fet current and history price\n    /// @param desToken Token to be priced\n    /// @param quoteToken Token used for pricing\n    /// @param secondsAgo not used on BSC\n    /// @param dexData dex parameters\n    /// @return price Real-time price\n    /// @return cAvgPrice Current TWAP price\n    /// @return hAvgPrice Historical TWAP price\n    /// @return decimals Token price decimal\n    /// @return timestamp Last TWAP price update timestamp \n    function getPriceCAvgPriceHAvgPrice(\n        address desToken,\n        address quoteToken,\n        uint32 secondsAgo,\n        bytes memory dexData\n    ) external view override returns (uint price, uint cAvgPrice, uint256 hAvgPrice, uint8 decimals, uint256 timestamp){\n        secondsAgo;\n        decimals = priceDecimals;\n        address pair = getUniClassPair(desToken, quoteToken, dexInfo[dexData.toDex()].factory);\n        V2PriceOracle memory priceOracle = uniV2PriceOracle[IUniswapV2Pair(pair)];\n        (price, cAvgPrice, hAvgPrice, timestamp) = uniClassGetPriceCAvgPriceHAvgPrice(pair, priceOracle, desToken, quoteToken, decimals);\n    }\n\n    /// @dev Update Dex price if not updated over time window\n    /// @param desToken Token to be priced\n    /// @param quoteToken Token used for pricing\n    /// @param timeWindow minmum time gap between two updates\n    /// @param data dex parameters\n    /// @return If updated\n    function updatePriceOracle(address desToken, address quoteToken, uint32 timeWindow, bytes memory data) external override returns (bool){\n        require(msg.sender == openLev, \"Only openLev can update price\");\n        address pair = getUniClassPair(desToken, quoteToken, dexInfo[data.toDex()].factory);\n        V2PriceOracle memory priceOracle = uniV2PriceOracle[IUniswapV2Pair(pair)];\n        (V2PriceOracle memory updatedPriceOracle, bool updated) = uniClassUpdatePriceOracle(pair, priceOracle, timeWindow, priceDecimals);\n        if (updated) {\n            uniV2PriceOracle[IUniswapV2Pair(pair)] = updatedPriceOracle;\n        }\n        return updated;\n    }\n\n    /// @dev Update UniV3 observations\n    /// @param desToken Token to be priced\n    /// @param quoteToken Token used for pricing\n    /// @param data Dex parameters\n    function updateV3Observation(address desToken, address quoteToken, bytes memory data) external pure override {\n        // Shh - currently unused\n        (desToken,quoteToken, data);\n        revert(\"Not implemented\");\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OpenLevInterface.sol\";\nimport \"./Types.sol\";\nimport \"./Adminable.sol\";\nimport \"./DelegateInterface.sol\";\nimport \"./ControllerInterface.sol\";\nimport \"./IWETH.sol\";\nimport \"./XOLEInterface.sol\";\nimport \"./Types.sol\";\nimport \"./OpenLevV1Lib.sol\";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param _controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, \"NAD\");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i < _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow > 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, \"MAM\");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed > 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), \"PNH\");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, \"ISR\");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, \"ISR\");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, \"ISB\");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), \"IRP\");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), \"PIH\");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty > 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, \"PH\");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance >= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance >= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount > 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount > 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on \"to\" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    /*** Admin Functions ***/\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld <= trade.held, \"CBH\");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), \"HI0\");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), \"UDX\");\n        _;\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"../../lib/TransferHelper.sol\";\nimport \"../../lib/DexData.sol\";\nimport \"../../lib/Utils.sol\";\n\ncontract UniV2ClassDex {\n    using SafeMath for uint;\n    using Utils for uint;\n    using TransferHelper for IERC20;\n\n    struct V2PriceOracle {\n        uint32 blockTimestampLast;  // Last block timestamp when price updated\n        uint price0; // recorded price for token0\n        uint price1; // recorded price for token1\n        uint price0CumulativeLast; // Cumulative TWAP for token0\n        uint price1CumulativeLast; // Cumulative TWAP for token1\n    }\n\n    struct DexInfo {\n        IUniswapV2Factory factory;\n        uint16 fees;//30->0.3%\n    }\n\n    function uniClassSell(DexInfo memory dexInfo,\n        address buyToken,\n        address sellToken,\n        uint sellAmount,\n        uint minBuyAmount,\n        address payer,\n        address payee\n    ) internal returns (uint buyAmount){\n        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n        IUniswapV2Pair(pair).sync();\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n        uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n        dexInfo.fees = getPairFees(dexInfo, pair);\n        if (buyToken < sellToken) {\n            buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n            IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n        } else {\n            buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n            IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n        }\n\n        require(buyAmount >= minBuyAmount, 'buy amount less than min');\n        uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n        return bought;\n    }\n\n    function uniClassSellMul(DexInfo memory dexInfo, uint sellAmount, uint minBuyAmount, address[] memory tokens)\n    internal returns (uint buyAmount){\n        for (uint i = 1; i < tokens.length; i++) {\n            address sellToken = tokens[i - 1];\n            address buyToken = tokens[i];\n            bool isLast = i == tokens.length - 1;\n            address payer = i == 1 ? msg.sender : address(this);\n            address payee = isLast ? msg.sender : address(this);\n            buyAmount = uniClassSell(dexInfo, buyToken, sellToken, sellAmount, 0, payer, payee);\n            if (!isLast) {\n                sellAmount = buyAmount;\n            }\n        }\n        require(buyAmount >= minBuyAmount, 'buy amount less than min');\n    }\n\n    function uniClassBuy(\n        DexInfo memory dexInfo,\n        address buyToken,\n        address sellToken,\n        uint buyAmount,\n        uint maxSellAmount,\n        uint24 buyTokenFeeRate,\n        uint24 sellTokenFeeRate) internal returns (uint sellAmount){\n        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n        IUniswapV2Pair(pair).sync();\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        uint balanceBefore = IERC20(buyToken).balanceOf(msg.sender);\n        dexInfo.fees = getPairFees(dexInfo, pair);\n        if (buyToken < sellToken) {\n            sellAmount = getAmountIn(buyAmount.toAmountBeforeTax(buyTokenFeeRate), token1Reserves, token0Reserves, dexInfo.fees);\n            sellAmount = sellAmount.toAmountBeforeTax(sellTokenFeeRate);\n            require(sellAmount <= maxSellAmount, 'sell amount not enough');\n            transferOut(IERC20(sellToken), msg.sender, pair, sellAmount);\n            IUniswapV2Pair(pair).swap(buyAmount.toAmountBeforeTax(buyTokenFeeRate), 0, msg.sender, \"\");\n        } else {\n            sellAmount = getAmountIn(buyAmount.toAmountBeforeTax(buyTokenFeeRate), token0Reserves, token1Reserves, dexInfo.fees);\n            sellAmount = sellAmount.toAmountBeforeTax(sellTokenFeeRate);\n            require(sellAmount <= maxSellAmount, 'sell amount not enough');\n            transferOut(IERC20(sellToken), msg.sender, pair, sellAmount);\n            IUniswapV2Pair(pair).swap(0, buyAmount.toAmountBeforeTax(buyTokenFeeRate), msg.sender, \"\");\n        }\n\n        uint balanceAfter = IERC20(buyToken).balanceOf(msg.sender);\n        require(buyAmount <= balanceAfter.sub(balanceBefore), \"wrong amount bought\");\n    }\n\n    function uniClassCalBuyAmount(DexInfo memory dexInfo, address buyToken, address sellToken, uint sellAmount) internal view returns (uint) {\n        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        if (buyToken < sellToken) {\n            return getAmountOut(sellAmount, token1Reserves, token0Reserves, getPairFees(dexInfo, pair));\n        } else {\n            return getAmountOut(sellAmount, token0Reserves, token1Reserves, getPairFees(dexInfo, pair));\n        }\n    }\n\n    function uniClassCalSellAmount(\n        DexInfo memory dexInfo,\n        address buyToken,\n        address sellToken,\n        uint buyAmount,\n        uint24 buyTokenFeeRate,\n        uint24 sellTokenFeeRate) internal view returns (uint sellAmount) {\n        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        sellAmount = buyToken < sellToken ?\n        getAmountIn(buyAmount.toAmountBeforeTax(buyTokenFeeRate), token1Reserves, token0Reserves, getPairFees(dexInfo, pair)) :\n        getAmountIn(buyAmount.toAmountBeforeTax(buyTokenFeeRate), token0Reserves, token1Reserves, getPairFees(dexInfo, pair));\n\n        return sellAmount.toAmountBeforeTax(sellTokenFeeRate);\n    }\n\n    function uniClassGetPrice(IUniswapV2Factory factory, address desToken, address quoteToken, uint8 decimals) internal view returns (uint256){\n        address pair = getUniClassPair(desToken, quoteToken, factory);\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        return desToken == IUniswapV2Pair(pair).token0() ?\n        token1Reserves.mul(10 ** decimals).div(token0Reserves) :\n        token0Reserves.mul(10 ** decimals).div(token1Reserves);\n    }\n\n    function uniClassGetAvgPrice(address desToken, address quoteToken, V2PriceOracle memory priceOracle) internal pure returns (uint256 price, uint256 timestamp){\n        timestamp = priceOracle.blockTimestampLast;\n        price = desToken < quoteToken ? uint(priceOracle.price0) : uint(priceOracle.price1);\n    }\n\n\n    function uniClassGetPriceCAvgPriceHAvgPrice(address pair, V2PriceOracle memory priceOracle, address desToken, address quoteToken, uint8 decimals)\n    internal view returns (uint price, uint cAvgPrice, uint256 hAvgPrice, uint256 timestamp){\n        bool isToken0 = desToken < quoteToken;\n        (uint256 token0Reserves, uint256 token1Reserves, uint32 uniBlockTimeLast) = IUniswapV2Pair(pair).getReserves();\n        price = isToken0 ?\n        token1Reserves.mul(10 ** decimals).div(token0Reserves) :\n        token0Reserves.mul(10 ** decimals).div(token1Reserves);\n\n        hAvgPrice = isToken0 ? uint(priceOracle.price0) : uint(priceOracle.price1);\n        timestamp = priceOracle.blockTimestampLast;\n\n        if (uniBlockTimeLast <= priceOracle.blockTimestampLast) {\n            cAvgPrice = hAvgPrice;\n        } else {\n            uint32 timeElapsed = uniBlockTimeLast - priceOracle.blockTimestampLast;\n            cAvgPrice = uint256(isToken0 ?\n                calTPrice(IUniswapV2Pair(pair).price0CumulativeLast(), priceOracle.price0CumulativeLast, timeElapsed, decimals) :\n                calTPrice(IUniswapV2Pair(pair).price1CumulativeLast(), priceOracle.price1CumulativeLast, timeElapsed, decimals));\n        }\n    }\n\n    function uniClassUpdatePriceOracle(address pair, V2PriceOracle memory priceOracle, uint32 timeWindow, uint8 decimals) internal returns (V2PriceOracle memory, bool updated) {\n        uint32 currentBlockTime = toUint32(block.timestamp);\n        if (currentBlockTime < (priceOracle.blockTimestampLast + timeWindow)) {\n            return (priceOracle, false);\n        }\n        (,,uint32 uniBlockTimeLast) = IUniswapV2Pair(pair).getReserves();\n        if (uniBlockTimeLast != currentBlockTime) {\n            IUniswapV2Pair(pair).sync();\n        }\n        uint32 timeElapsed = currentBlockTime - priceOracle.blockTimestampLast;\n        uint currentPrice0CumulativeLast = IUniswapV2Pair(pair).price0CumulativeLast();\n        uint currentPrice1CumulativeLast = IUniswapV2Pair(pair).price1CumulativeLast();\n        if (priceOracle.blockTimestampLast != 0) {\n            priceOracle.price0 = calTPrice(currentPrice0CumulativeLast, priceOracle.price0CumulativeLast, timeElapsed, decimals);\n            priceOracle.price1 = calTPrice(currentPrice1CumulativeLast, priceOracle.price1CumulativeLast, timeElapsed, decimals);\n        }\n        priceOracle.price0CumulativeLast = currentPrice0CumulativeLast;\n        priceOracle.price1CumulativeLast = currentPrice1CumulativeLast;\n        priceOracle.blockTimestampLast = currentBlockTime;\n        return (priceOracle, true);\n    }\n\n    function calTPrice(uint currentPriceCumulativeLast, uint historyPriceCumulativeLast, uint32 timeElapsed, uint8 decimals)\n    internal pure returns (uint){\n        return ((currentPriceCumulativeLast.sub(historyPriceCumulativeLast).mul(10 ** decimals)) >> 112).div(timeElapsed);\n    }\n\n    function toUint32(uint256 y) internal pure returns (uint32 z) {\n        require((z = uint32(y)) == y);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint16 fees) private pure returns (uint amountOut)\n    {\n        require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(uint(10000).sub(fees));\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint16 fees) private pure returns (uint amountIn) {\n        require(amountOut > 0, 'INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\n        uint denominator = reserveOut.sub(amountOut).mul(uint(10000).sub(fees));\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    function transferOut(IERC20 token, address payer, address to, uint amount) private returns (uint256 amountReceived) {\n        if (payer == address(this)) {\n            amountReceived = token.safeTransfer(to, amount);\n        } else {\n            amountReceived = token.safeTransferFrom(payer, to, amount);\n        }\n    }\n\n    function getUniClassPair(address tokenA, address tokenB, IUniswapV2Factory factory) internal view returns (address pair){\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        if (address(factory) == 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73) {\n            return address(uint(keccak256(abi.encodePacked(\n                    hex'ff',\n                    address(factory),\n                    keccak256(abi.encodePacked(token0, token1)),\n                    hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n                ))));\n        } else {\n            return factory.getPair(tokenA, tokenB);\n        }\n    }\n\n    function getPairFees(DexInfo memory dexInfo, address pair) private view returns (uint16){\n        //mdex\n        if (address(dexInfo.factory) == 0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8) {\n            return toUint16((IMdexFactory)(address(dexInfo.factory)).getPairFees(pair));\n        } else {\n            return dexInfo.fees;\n        }\n    }\n\n    function toUint16(uint256 y) internal pure returns (uint16 z) {\n        require((z = uint16(y)) == y);\n    }\n}\n\ninterface IMdexFactory {\n    function getPairFees(address) external view returns (uint256);\n}\n\n",
        "CodeNames": [
            "OpenLevInterface.sol",
            "BscDexAggregatorV1.sol",
            "OpenLevV1.sol",
            "UniV2ClassDex.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint buyAmount){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n\n    require(buyAmount = minBuyAmount, 'buy amount less than min');\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    return bought;\n}\n"
                ],
                "Type": "  UniV2ClassDex.sol#uniClassSell()  Tokens with fee on transfer are not fully supported",
                "Description": "\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56\n\nsolidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint buyAmount){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n\n    require(buyAmount = minBuyAmount, 'buy amount less than min');\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    return bought;\n}\n\n\nWhile uniClassBuy() correctly checks the actually received amount by comparing the before and after the balance of the receiver, uniClassSell() trusted the result given by getAmountOut(). This makes uniClassSell() can result in an output amount fewer than minBuyAmount.\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint bought){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    require(bought = minBuyAmount, 'buy amount less than min');\n}\n\n\nColaM12 (OpenLeverage) confirmed and resolved(https://github.com/code-423n4/2022-01-openleverage-findings/issues/208)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/208#issuecomment-1050844620):\n  Agree with this finding! Uniswap token swaps are meant to support all types of tokens. It does seem possible for there to be payer to experience increased slippage because the check operates on getAmountOut() and not the bought output.\n \n  It's fair to say that this will lead to value leakage, so I think medium severity is justified.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n\npragma solidity 0.7.6;\n\nabstract contract Adminable {\n    address payable public admin;\n    address payable public pendingAdmin;\n    address payable public developer;\n\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    event NewAdmin(address oldAdmin, address newAdmin);\n    constructor () {\n        developer = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"caller must be admin\");\n        _;\n    }\n    modifier onlyAdminOrDeveloper() {\n        require(msg.sender == admin || msg.sender == developer, \"caller must be admin or developer\");\n        _;\n    }\n\n    function setPendingAdmin(address payable newPendingAdmin) external virtual onlyAdmin {\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    function acceptAdmin() external virtual {\n        require(msg.sender == pendingAdmin, \"only pendingAdmin can accept admin\");\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = address(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n}\n\n\n",
        "CodeNames": [
            "Adminable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "payable"
                ],
                "Type": " Missing payable",
                "Description": "\nThe following functions are not payable but uses msg.value therefore the function must be payable.\nThis can lead to undesired behavior.\n\n        LPool.sol, addReserves should be payable since using msg.value\n\nColaM12 (OpenLeverage) confirmed and resolved(https://github.com/code-423n4/2022-01-openleverage-findings/issues/61)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/61#issuecomment-1045990204):\n  Nice find! The warden has identified a function which is missing the payable keyword. Preventing any users from adding reserves using native ether.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "js\nawait proxy.propose(\n    signers[3].address],\n    ethers.utils.parseEther(\"0.1\")],\n    \"\"],\n    ethers.BigNumber.from(0)],\n    \"Send funds to 3rd signer\"\n);\n",
                    "js\nawait proxy.execute(2);  // this fails\n    await proxy.execute(2, {value: ethers.utils.parseEther(\"0.1\")})  // this would work\n    0.1 eth will be sent out, but it is sent from the msg.sender not from the timelock contract.\n"
                ],
                "Type": " Eth sent to Timelock will be locked in current implementation",
                "Description": "\nEth sent to Timelock will be locked in current implementation. I came across this problem while playing around with the governance contract.\n\n\n*   Setup the governance contracts (GovernanceAlpha, Timelock)\n*   Send eth to timelock contract\n*   Setup a proposal to send 0.1 eth out. Code snippet in ether.js below. proxy refers to GovernorAlpha.\n\njs\nawait proxy.propose(\n    signers[3].address],\n    ethers.utils.parseEther(\"0.1\")],\n    \"\"],\n    ethers.BigNumber.from(0)],\n    \"Send funds to 3rd signer\"\n);\n\n*   Vote and have the proposal succeed.\n*   Execute the proposal, the proposal number here is arbitrary.\n\njs\nawait proxy.execute(2);  // this fails\n    await proxy.execute(2, {value: ethers.utils.parseEther(\"0.1\")})  // this would work\n    0.1 eth will be sent out, but it is sent from the msg.sender not from the timelock contract.\n\n\n",
                "Repair": "\nConsider implementing the following code.\nsolidity\n\nfunction execute(uint proposalId) external {\n    require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint i = 0; i < proposal.targets.length; i++) {\n        timelock.executeTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n    }\n    emit ProposalExecuted(proposalId);\n}\n\n\n#### Reference\n\n<https://github.com/compound-finance/compound-protocol/pull/177/files\n\nColaM12 (OpenLeverage) acknowledged(https://github.com/code-423n4/2022-01-openleverage-findings/issues/80)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/80#issuecomment-1045994865):\n  I agree with this finding!\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\n// Avoid flash loan\nif (prices.price < prices.cAvgPrice) {\n    uint differencePriceRatio = prices.cAvgPrice.mul(100).div(prices.price);\n    require(differencePriceRatio 100 < maxLiquidationPriceDiffientRatio, 'MPT');\n}\n"
                ],
                "Type": " anti-flashloan mechanism may lead to protocol default",
                "Description": "\nThere is a price check to avoid flash loan attacks which significantly moved the price. If current price is 5% lower than the stored twap price, the liquidation will fail. This design can be dangerous as it is to openleverage's benefit to close under-collateralized position ASAP when there is a huge market drawdown. When the market keep trading downward, it is possible that the spot price keep trading 5% lower than the twap, which prevent any liquidation from happening and causing the protocol to be under-collateralized.\n\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L191\n\nsolidity\n// Avoid flash loan\nif (prices.price < prices.cAvgPrice) {\n    uint differencePriceRatio = prices.cAvgPrice.mul(100).div(prices.price);\n    require(differencePriceRatio 100 < maxLiquidationPriceDiffientRatio, 'MPT');\n}\n \n\n",
                "Repair": "\nInstead of revert with maxLiquidationPriceDiffientRatio, use the twap price to determine if the position is healthy.\n\nColaM12 (OpenLeverage) disputed(https://github.com/code-423n4/2022-01-openleverage-findings/issues/233)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1045995096):\n  From first impression, this finding seems legitimate. Can I get some more details on why it was disputed? @ColaM12 \n\nColaM12 (OpenLeverage) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046409471):\n  There is always a chance to front run a flash loan transaction before trading in OpenLev. Also, see in line 196( https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L196), position is considered not healthy only if all three price check failed including the twap price.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046517723):\n  It looks like only one condition would need to be satisfied for isPositionHealthy to return false as it uses || and not &&.\n\nColaM12 (OpenLeverage) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046560642):\n  Do you mean return true? All 3 price checks should fail when liquidating. But the position may still hold funds to pay off debt. by using maxLiquidationPriceDiffientRatio, under-priced-swaps can be limited . Otherwise, all remaining funds in the position could be drained from a flash loan attack which directly leads to a bad debt to lender.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046580257):\n  Ahh sorry my mistake. I misinterpreted that.\n \n  I agree with the sponsor here. The issue outlined by the warden seems to be safeguarded by the two other checks in isPositionHealthy()\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046623163):\n  Actually thinking about this more, I think the warden raised an issue related to the liquidations continuing to fail if the price keeps trending downward at an accelerated pace. I don't think the protocol would be able to respond to such events if this(https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L194) reverts.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046665362):\n  After discussion with the sponsor, we have agreed that this issue is valid. It is expected that the TWAP is only valid for 1 min. By removing this condition, there is potential for even larger security issues. So the sponsor has decided to make this a wont-fix but I'll keep the issue open as it is valid.\n \n  This was an awesome find!\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OpenLevInterface.sol\";\nimport \"./Types.sol\";\nimport \"./Adminable.sol\";\nimport \"./DelegateInterface.sol\";\nimport \"./ControllerInterface.sol\";\nimport \"./IWETH.sol\";\nimport \"./XOLEInterface.sol\";\nimport \"./Types.sol\";\nimport \"./OpenLevV1Lib.sol\";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param _controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, \"NAD\");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i < _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow > 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, \"MAM\");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed > 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), \"PNH\");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, \"ISR\");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, \"ISR\");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, \"ISB\");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), \"IRP\");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), \"PIH\");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty > 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, \"PH\");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance >= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance >= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount > 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount > 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on \"to\" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    /*** Admin Functions ***/\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld <= trade.held, \"CBH\");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), \"HI0\");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), \"UDX\");\n        _;\n    }\n}\n\n",
        "CodeNames": [
            "OpenLevV1.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "doTransferOut",
                    "trade.depositToken != longToken",
                    "flashSell"
                ],
                "Type": " OpenLevV1.closeTrade with V3 DEX doesn't correctly accounts fee on transfer tokens for repayments",
                "Description": "\nThe amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.\n\nThis way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.\n\nIn the trade.depositToken != longToken case when flashSell is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.\n\n\ntrade.depositToken != longToken case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned closeTradeVars.receiveAmount.\n\nAs a side effect, doTransferOut is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204\n\nI.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.\n\nV3 sell function doesn't check for balance change, using DEX returned amount as is:\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70\n\n",
                "Repair": "\nIf fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.\n\nColaM12 (OpenLeverage) confirmed and resolved(https://github.com/code-423n4/2022-01-openleverage-findings/issues/104)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-openleverage-findings/issues/104#issuecomment-1045996325):\n  Awesome find. I was able to confirm that UniV3Dex.uniV3Sell() does not properly handle fee-on-transfer tokens by treating the amount received as the difference between before balance and after balance.\n\n\n\n*\n\n\n"
            }
        ]
    }
]