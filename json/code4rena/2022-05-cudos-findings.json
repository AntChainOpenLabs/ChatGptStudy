[
    {
        "Code": "pragma solidity ^0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CosmosToken.sol\";\nimport \"./CudosAccessControls.sol\";\n\npragma experimental ABIEncoderV2;\n\n// This is being used purely to avoid stack too deep errors\nstruct LogicCallArgs {\n\t// Transfers out to the logic contract\n\tuint256[] transferAmounts;\n\taddress[] transferTokenContracts;\n\t// The fees (transferred to msg.sender)\n\tuint256[] feeAmounts;\n\taddress[] feeTokenContracts;\n\t// The arbitrary logic call\n\taddress logicContractAddress;\n\tbytes payload;\n\t// Invalidation metadata\n\tuint256 timeOut;\n\tbytes32 invalidationId;\n\tuint256 invalidationNonce;\n}\n\n// This is used purely to avoid stack too deep errors\n// represents everything about a given validator set\nstruct ValsetArgs {\n\t// the validators in this set, represented by an Ethereum address\n\taddress[] validators;\n\t// the powers of the given validators in the same order as above\n\tuint256[] powers;\n\t// the nonce of this validator set\n\tuint256 valsetNonce;\n\t// the reward amount denominated in the below reward token, can be\n\t// set to zero\n\tuint256 rewardAmount;\n\t// the reward token, should be set to the zero address if not being used\n\taddress rewardToken;\n}\n\ncontract Gravity is ReentrancyGuard {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t// These are updated often\n\tbytes32 public state_lastValsetCheckpoint;\n\tmapping(address => uint256) public state_lastBatchNonces;\n\tmapping(bytes32 => uint256) public state_invalidationMapping;\n\tuint256 public state_lastValsetNonce = 0;\n\t// event nonce zero is reserved by the Cosmos module as a special\n\t// value indicating that no events have yet been submitted\n\tuint256 public state_lastEventNonce = 1;\n\n\t// These are set once at initialization\n\tbytes32 public state_gravityId;\n\tuint256 public state_powerThreshold;\n\n\tCudosAccessControls public cudosAccessControls;\n\n\tmapping(address => bool) public whitelisted;\n\n\t// TransactionBatchExecutedEvent and SendToCosmosEvent both include the field _eventNonce.\n\t// This is incremented every time one of these events is emitted. It is checked by the\n\t// Cosmos module to ensure that all events are received in order, and that none are lost.\n\t//\n\t// ValsetUpdatedEvent does not include the field _eventNonce because it is never submitted to the Cosmos\n\t// module. It is purely for the use of relayers to allow them to successfully submit batches.\n\tevent TransactionBatchExecutedEvent(\n\t\tuint256 indexed _batchNonce,\n\t\taddress indexed _token,\n\t\tuint256 _eventNonce\n\t);\n\tevent SendToCosmosEvent(\n\t\taddress indexed _tokenContract,\n\t\taddress indexed _sender,\n\t\tbytes32 indexed _destination,\n\t\tuint256 _amount,\n\t\tuint256 _eventNonce\n\t);\n\tevent ERC20DeployedEvent(\n\t\t// FYI: Can't index on a string without doing a bunch of weird stuff\n\t\tstring _cosmosDenom,\n\t\taddress indexed _tokenContract,\n\t\tstring _name,\n\t\tstring _symbol,\n\t\tuint8 _decimals,\n\t\tuint256 _eventNonce\n\t);\n\tevent ValsetUpdatedEvent(\n\t\tuint256 indexed _newValsetNonce,\n\t\tuint256 _eventNonce,\n\t\tuint256 _rewardAmount,\n\t\taddress _rewardToken,\n\t\taddress[] _validators,\n\t\tuint256[] _powers\n\t);\n\tevent LogicCallEvent(\n\t\tbytes32 _invalidationId,\n\t\tuint256 _invalidationNonce,\n\t\tbytes _returnData,\n\t\tuint256 _eventNonce\n\t);\n\n\tevent WhitelistedStatusModified(\n\t\taddress _sender,\n\t\taddress[] _users,\n\t\tbool _isWhitelisted\n\t);\n\n\n\tmodifier onlyWhitelisted() {\n\t\t require(\n            whitelisted[msg.sender] || cudosAccessControls.hasAdminRole(msg.sender) ,\n            \"The caller is not whitelisted for this operation\"\n        );\n\t\t_;\n\t}\n\n\tfunction manageWhitelist(\n\t\taddress[] memory _users,\n\t\tbool _isWhitelisted\n\t\t) public onlyWhitelisted {\n\t\t for (uint256 i = 0; i < _users.length; i++) {\n            require(\n                _users[i] != address(0),\n                \"User is the zero address\"\n            );\n            whitelisted[_users[i]] = _isWhitelisted;\n        }\n        emit WhitelistedStatusModified(msg.sender, _users, _isWhitelisted);\n\t}\n\n\t// TEST FIXTURES\n\t// These are here to make it easier to measure gas usage. They should be removed before production\n\tfunction testMakeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId) public pure {\n\t\tmakeCheckpoint(_valsetArgs, _gravityId);\n\t}\n\n\tfunction testCheckValidatorSignatures(\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) public pure {\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValidators,\n\t\t\t_currentPowers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\t_theHash,\n\t\t\t_powerThreshold\n\t\t);\n\t}\n\n\t// END TEST FIXTURES\n\n\tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\n\t\treturn state_lastBatchNonces[_erc20Address];\n\t}\n\n\tfunction lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {\n\t\treturn state_invalidationMapping[_invalidation_id];\n\t}\n\n\t// Utility function to verify geth style signatures\n\tfunction verifySig(\n\t\taddress _signer,\n\t\tbytes32 _theHash,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) private pure returns (bool) {\n\t\tbytes32 messageDigest = keccak256(\n\t\t\tabi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _theHash)\n\t\t);\n\t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n\t}\n\n\t// Make a new checkpoint from the supplied validator set\n\t// A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\n\t// instead of storing the information directly. This saves on storage and gas.\n\t// The format of the checkpoint is:\n\t// h(gravityId, \"checkpoint\", valsetNonce, validators[], powers[])\n\t// Where h is the keccak256 hash function.\n\t// The validator powers must be decreasing or equal. This is important for checking the signatures on the\n\t// next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\n\tfunction makeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId)\n\t\tprivate\n\t\tpure\n\t\treturns (bytes32)\n\t{\n\t\t// bytes32 encoding of the string \"checkpoint\"\n\t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n\n\t\tbytes32 checkpoint = keccak256(\n\t\t\tabi.encode(\n\t\t\t\t_gravityId,\n\t\t\t\tmethodName,\n\t\t\t\t_valsetArgs.valsetNonce,\n\t\t\t\t_valsetArgs.validators,\n\t\t\t\t_valsetArgs.powers,\n\t\t\t\t_valsetArgs.rewardAmount,\n\t\t\t\t_valsetArgs.rewardToken\n\t\t\t)\n\t\t);\n\n\t\treturn checkpoint;\n\t}\n\n\tfunction checkValidatorSignatures(\n\t\t// The current validator set and their powers\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\t// The current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// This is what we are checking they have signed\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) private pure {\n\t\tuint256 cumulativePower = 0;\n\n\t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\n\t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\n\t\t\t// (In a valid signature, it is either 27 or 28)\n\t\t\tif (_v[i] != 0) {\n\t\t\t\t// Check that the current validator has signed off on the hash\n\t\t\t\trequire(\n\t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\n\t\t\t\t\t\"Validator signature does not match.\"\n\t\t\t\t);\n\n\t\t\t\t// Sum up cumulative power\n\t\t\t\tcumulativePower = cumulativePower + _currentPowers[i];\n\n\t\t\t\t// Break early to avoid wasting gas\n\t\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that there was enough power\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\t\t// Success\n\t}\n\n\tfunction isOrchestrator(ValsetArgs memory _newValset, address _sender) private pure returns(bool) {\n\n\t\tfor (uint256 i = 0; i < _newValset.validators.length; i++) {\n\t\t\tif(_newValset.validators[i] == _sender) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// This updates the valset by checking that the validators in the current valset have signed off on the\n\t// new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\n\t// generated from the new valset.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the new valset.\n\tfunction updateValset(\n\t\t// The new version of the validator set\n\t\tValsetArgs memory _newValset,\n\t\t// The current validators that approve the change\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s\n\t) public nonReentrant {\n\t\t// CHECKS\n\n\t\t// Check that the valset nonce is greater than the old one\n\t\trequire(\n\t\t\t_newValset.valsetNonce > _currentValset.valsetNonce,\n\t\t\t\"New valset nonce must be greater than the current nonce\"\n\t\t);\n\n\t\t// Check that new validators and powers set is well-formed\n\t\trequire(\n\t\t\t_newValset.validators.length == _newValset.powers.length,\n\t\t\t\"Malformed new validator set\"\n\t\t);\n\n\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(\n\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\"Malformed current validator set\"\n\t\t);\n\n\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\trequire(\n\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t);\n\n\t\trequire(\n\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t);\n\n\t\t// Check that enough current validators have signed off on the new validator set\n\t\tbytes32 newCheckpoint = makeCheckpoint(_newValset, state_gravityId);\n\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValset.validators,\n\t\t\t_currentValset.powers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\tnewCheckpoint,\n\t\t\tstate_powerThreshold\n\t\t);\n\n\t\t// ACTIONS\n\n\t\t// Stored to be used next time to validate that the valset\n\t\t// supplied by the caller is correct.\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\t// Store new nonce\n\t\tstate_lastValsetNonce = _newValset.valsetNonce;\n\n\t\t// Send submission reward to msg.sender if reward token is a valid value\n\t\tif (_newValset.rewardToken != address(0) && _newValset.rewardAmount != 0) {\n\t\t\tIERC20(_newValset.rewardToken).safeTransfer(msg.sender, _newValset.rewardAmount);\n\t\t}\n\n\t\t// LOGS\n\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ValsetUpdatedEvent(\n\t\t\t_newValset.valsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t_newValset.rewardAmount,\n\t\t\t_newValset.rewardToken,\n\t\t\t_newValset.validators,\n\t\t\t_newValset.powers\n\t\t);\n\t}\n\n\t// submitBatch processes a batch of Cosmos -> Ethereum transactions by sending the tokens in the transactions\n\t// to the destination addresses. It is approved by the current Cosmos validator set.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the batch.\n\tfunction submitBatch (\n\t\t// The validators that approve the batch\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// The batch of transactions\n\t\tuint256[] memory _amounts,\n\t\taddress[] memory _destinations,\n\t\tuint256[] memory _fees,\n\t\tuint256 _batchNonce,\n\t\taddress _tokenContract,\n\t\t// a block height beyond which this batch is not valid\n\t\t// used to provide a fee-free timeout\n\t\tuint256 _batchTimeout\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the batch nonce is higher than the last nonce for this token\n\t\t\trequire(\n\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\n\t\t\t\t\"New batch nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that the block height is less than the timeout height\n\t\t\trequire(\n\t\t\t\tblock.number < _batchTimeout,\n\t\t\t\t\"Batch timeout must be greater than the current block height\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the transaction batch is well-formed\n\t\t\trequire(\n\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,\n\t\t\t\t\"Malformed batch of transactions\"\n\t\t\t);\n\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"\n\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n\t\t\t\t\t\t_amounts,\n\t\t\t\t\t\t_destinations,\n\t\t\t\t\t\t_fees,\n\t\t\t\t\t\t_batchNonce,\n\t\t\t\t\t\t_tokenContract,\n\t\t\t\t\t\t_batchTimeout\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\n\t\t\t// ACTIONS\n\n\t\t\t// Store batch nonce\n\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\n\n\t\t\t{\n\t\t\t\t// Send transaction amounts to destinations\n\t\t\t\tuint256 totalFee;\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\n\t\t\t\t\ttotalFee = totalFee.add(_fees[i]);\n\t\t\t\t}\n\n\t\t\t\t// Send transaction fees to msg.sender\n\t\t\t\tIERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n\t\t\t}\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);\n\t\t}\n\t}\n\n\t// This makes calls to contracts that execute arbitrary logic\n\t// First, it gives the logic contract some tokens\n\t// Then, it gives msg.senders tokens for fees\n\t// Then, it calls an arbitrary function on the logic contract\n\t// invalidationId and invalidationNonce are used for replay prevention.\n\t// They can be used to implement a per-token nonce by setting the token\n\t// address as the invalidationId and incrementing the nonce each call.\n\t// They can be used for nonce-free replay prevention by using a different invalidationId\n\t// for each call.\n\tfunction submitLogicCall(\n\t\t// The validators that approve the call\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tLogicCallArgs memory _args\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\trequire(block.number < _args.timeOut, \"Timed out\");\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\trequire(\n\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,\n\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the token transfer list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,\n\t\t\t\t\"Malformed list of token transfers\"\n\t\t\t);\n\n\t\t\t// Check that the fee list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,\n\t\t\t\t\"Malformed list of fees\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 argsHash = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tstate_gravityId,\n\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t_args.transferAmounts,\n\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t_args.feeAmounts,\n\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.payload,\n\t\t\t\t_args.timeOut,\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce\n\t\t\t)\n\t\t);\n\n\t\t{\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\treturnData,\n\t\t\t\tstate_lastEventNonce\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\t_amount,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction deployERC20(\n\t\tstring memory _cosmosDenom,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tuint8 _decimals\n\t) public {\n\t\t// Deploy an ERC20 with entire supply granted to Gravity.sol\n\t\tCosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n\n\t\t// Fire an event to let the Cosmos module know\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ERC20DeployedEvent(\n\t\t\t_cosmosDenom,\n\t\t\taddress(erc20),\n\t\t\t_name,\n\t\t\t_symbol,\n\t\t\t_decimals,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction withdrawERC20(\n\t\taddress _tokenAddress) \n\t\texternal {\n\t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n\t}\n\n\tconstructor(\n\t\t// A unique identifier for this gravity instance to use in signatures\n\t\tbytes32 _gravityId,\n\t\t// How much voting power is needed to approve operations\n\t\tuint256 _powerThreshold,\n\t\t// The validator set, not in valset args format since many of it's\n\t\t// arguments would never be used in this case\n\t\taddress[] memory _validators,\n    uint256[] memory _powers,\n\t\tCudosAccessControls _cudosAccessControls\n\t) public {\n\t\t// CHECKS\n\n\t\t// Check that validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(_validators.length == _powers.length, \"Malformed current validator set\");\n\t\trequire(address(_cudosAccessControls) != address(0), \"Access control contract address is incorrect\");\n\n\t\t// Check cumulative power to ensure the contract has sufficient power to actually\n\t\t// pass a vote\n\t\tuint256 cumulativePower = 0;\n\t\tfor (uint256 i = 0; i < _powers.length; i++) {\n\t\t\tcumulativePower = cumulativePower + _powers[i];\n\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\n\t\tValsetArgs memory _valset;\n\t\t_valset = ValsetArgs(_validators, _powers, 0, 0, address(0));\n\n\t\tbytes32 newCheckpoint = makeCheckpoint(_valset, _gravityId);\n\n\t\t// ACTIONS\n\n\t\tstate_gravityId = _gravityId;\n\t\tstate_powerThreshold = _powerThreshold;\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\tcudosAccessControls = _cudosAccessControls;\n\n\t\t// LOGS\n\n\t\temit ValsetUpdatedEvent(\n\t\t\tstate_lastValsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t0,\n\t\t\taddress(0),\n\t\t\t_validators,\n\t\t\t_powers\n\t\t);\n\t}\n}\n\n\n",
        "CodeNames": [
            "Gravity.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "state_powerThreshold",
                    "updateValset",
                    "_powerThreshold ="
                ],
                "Type": " Missing check in the  updateValset  function",
                "Description": "*Submitted by CertoraInc, also found by 0x1337, cccz, danb, dipp, dirk_y, hubble, jah, and WatchPug*\n\nGravity.sol#L276-L358(https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L276-L358)<br\n\nThe updateValset function don't check that the sum of the powers of the new validators in the new valset is greater than the threshold, which can lead to unwanted behavior.\n\nThere are 2 main problems that can occur in that situation:\n\n1.  The sum of the new validators' powers will be lower than the state_powerThreshold\n2.  The sum of the new validators' power will overflow and become lower than the state_powerThreshold\n\nThe second case is less dangerous, because it won't stuck the system in every case (only in specific cases where every sum of validators' power is less than the threshold). The first case is very dangerous though. It can lead to the system becoming stuck and to all of the tokens on the cudos chain to become locked for users, because the validators won't have enough power to approve any operation whether it is transferring tokens or updating the valset.\n\n\nFor the first case, consider the current validators set containing 100 validators with each ones power being equal to 10, and the threshold is 900 (91+ validators are needed for approvement). Now the updateValset function is being called with 100 validators with each ones power being equal to 1. This will lead to a state where no matter how much validators have signed a message, the sum of the powers won't pass the threshold and the action won't be able to be executed. This will cause all the tokens in the cudos blockchain become locked, and will DoS all the actions of the gravity contract including updating the valset.\n\nFor the second case, consider the new validators set will have 128 validators, each validator's power is equal to 2249 and _powerThreshold = 2256 1. In this case the system will be stuck too, because every sum of validators' power won't pass the threshold.\n\n\nRemix and VS Code\n\n",
                "Repair": "\nAdd a check in the updateValset to assure that the sum of the new powers is greater than the threshold.\n\nV-Staykov (Cudos) disputed and commented(https://github.com/code-423n4/2022-05-cudos-findings/issues/123#issuecomment-1123596915):\n  This check is done on the Gravity module side and since the message is also signed there by the validators, we can consider it to be always as per the module, unless there are malicious validators with more voting power than the threshold.\n \n If the message is considered correct this means that the values of the power are normalized which is in the core of the power threshold calculation. When they are normalized this means that the sum of the validator set will always equal 100% of the power which is more than the threshold.\n \n Here is a link(https://github.com/code-423n4/2022-05-cudos/blob/main/module/x/gravity/keeper/keeper_valset.go#L206) to the power normalization in the Gravity module side.\n\nAlbert Chon (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-05-cudos-findings/issues/123#issuecomment-1128642000):\n  Agreed with @V-Staykov this would only fail if 2/3+ of the validator stake weight were controlled by malicious validators, at which point all bets are off.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "\n               require(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n"
                ],
                "Type": " Admin drains all ERC based user funds using  withdrawERC20() ",
                "Description": "*Submitted by p_crypt0, also found by 0x1337, AmitN, csanuragjain, danb, dirk_y, GermanKuber, IllIllI, kirk-baird, and WatchPug*\n\nGravity.sol#L632-L638(https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L632-L638)<br\nGravity.sol#L595-L609(https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L609)\n\nAbility for admin to drain all ERC20 funds stored in contract at will, meaning all ERC20 based Cudos tokens (and any other ERC20 tokens stored in the contract) could be extracted by anyone with admin role and later sold, leaving users funds bridged on Cudos Cosmos chain with no ERC20 representation stored across the bridge similar in impact as the wormhole hack.\n\nThis issue ought to fall within the limits the team allocated on assessing the governance role setups, since it describes a full-fledged security risk regarding users' funds. Crucially, this function is not in the original Gravity Bridge contract for Gravity.sol(https://github.com/Gravity-Bridge/Gravity-Bridge/blob/f65d9da692c1af76f8188bd17b55dea58c1d8723/solidity/contracts/Gravity.sol).\n\nFurthermore, the function has not been commented and does not appear in the documentation, suggesting that it has perhaps not yet been reasoned through by the development team and it's critical this is flagged in the security audit.\n\n\nFirstly, User with admin role granted waits until CUDOS bridge has decent TVL from users bridging their CUDOS tokens from Ethereum to the CUDOS Cosmos chain,\n\nSecondly, User manually calls withdrawERC20(address _tokenAddress) with the ERC token address of the CUDOS token\n\n     function withdrawERC20(\n    \t\t\taddress _tokenAddress) \n    \t\t\texternal {\n    \t\t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n    \t\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n    \t\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n    } \n\nThirdly, withdrawERC20() function checks if user has admin role and if so withdraws all the tokens of a given token address straight to the admin's personal wallet\n\n\n               require(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n\n\nFourth, user exchanges CUDOS on DEX and then sends funds to tornado cash, leaving all user funds at risk.\n\n\nMy own logical reasoning and discussion with team on Discord for confirmation of admin roles and function's logic.\n\n",
                "Repair": "\nDelete the function or alternatively, send all funds to the '0' address to burn rather than give them to the admin.\n\nChange withdrawERC20 to:\n\n    function burnERC20(\n    \taddress _tokenAddress) \n    \texternal {\n    \trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n    \tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(0));\n    \tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n         +   IERC20(_tokenAddress).safeTransfer(address(0) , totalBalance);\n    }\n\nmaptuhec (Cudos) acknowledged and commented(https://github.com/code-423n4/2022-05-cudos-findings/issues/14#issuecomment-1123247894):\n  The reason we have created this functions is that, if the bridge stop working, the funds for the users would be locked, and there is no chance to withdraw them. CUDOS have no intention and incentive to maliciously withdraw the ERC20 tokes, because that would lead to losing the trust in its clients and thus killing their own network. The best way for handling this is to communicate this with the community so they can be aware.\n\nAlbert Chon (judge) decreased severity to Medium(https://github.com/code-423n4/2022-05-cudos-findings/issues/14)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": " The  Gravity.sol  should have pause/unpause functionality",
                "Description": "\nIn case a hack is occuring or an exploit is discovered, the team (or validators in this case) should be able to pause\nfunctionality until the necessary changes are made to the system. Additionally, the gravity.sol contract should be manged by proxy so that upgrades can be made by the validators.\n\nBecause an attack would probably span a number of blocks, a method for pausing the contract would be able to interrupt any such attack if discovered.\n\nTo use a thorchain example again, the team behind thorchain noticed an attack was going to occur well before\nthe system transferred funds to the hacker. However, they were not able to shut the system down fast enough.\n(According to the incidence report here(https://github.com/HalbornSecurity/PublicReports/blob/master/Incident%20Reports/Thorchain_Incident_Analysis_July_23_2021.pdf)).\n\n\nGravity.sol#L175(https://github.com/code-423n4/2022-05-cudos/blob/main/solidity/contracts/Gravity.sol#L175)<br\n\n",
                "Repair": "\nPause functionality on the contract would have helped secure the funds quickly.\n\nmlukanova (Cudos) confirmed(https://github.com/code-423n4/2022-05-cudos-findings/issues/139)\n\nV-Staykov (Cudos) resolved and commented(https://github.com/code-423n4/2022-05-cudos-findings/issues/139#issuecomment-1128537997):\n  PR: CudoVentures/cosmos-gravity-bridge#18(https://github.com/CudoVentures/cosmos-gravity-bridge/pull/18)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "_tokenContract"
                ],
                "Type": " Protocol doesn't handle fee on transfer tokens",
                "Description": "\nGravity.sol#L600(https://github.com/code-423n4/2022-05-cudos/blob/main/solidity/contracts/Gravity.sol#L600)<br\n\nSince the _tokenContract can be any token, it is possible that loans will be created with tokens that support fee on transfer. If a fee on transfer asset token is chosen, other user's funds might be drained.\n\n\n1.  Assume transfer fee to be 5% and Gravity.sol has 200 token.\n2.  Alice sendToCosmos 100 token. Now, Gravity.sol has 295 token.\n3.  Alice calls the send-to-eth method to withdraw 100 token.\n4.  Gravity.sol ends up having 195 token.\n\n",
                "Repair": "\nChange to\n\nsolidity\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n                uint256 oldBalance = IERC20(_tokenContract).balanceOf(address(this));\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n                uint256 receivedAmout = IERC20(_tokenContract).balanceOf(address(this)) oldBalance;\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\treceivedAmout,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\nmlukanova (Cudos) acknowledged and commented(https://github.com/code-423n4/2022-05-cudos-findings/issues/3#issuecomment-1123721942):\n  Token transfers are restricted to the Cudos token which doesn't support fee on transfer. Will be fixed with issue #58(https://github.com/code-423n4/2022-05-cudos-findings/issues/58).\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "\n\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\t_amount,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n",
                    "\n\n\tfunction withdrawERC20(\n\t\taddress _tokenAddress) \n\t\texternal {\n\t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n\t}\n\n"
                ],
                "Type": " Non-Cudos Erc20 funds sent through  sendToCosmos()  will be lost.",
                "Description": "*Submitted by p_crypt0, also found by CertoraInc*\n\nNo checks for non-Cudos tokens mean that non-Cudos ERC20 tokens will be lost to the contract, with the user not having any chance of retrieving them.\n\nHowever, the admin can retrieve them through withdrawERC20.\n\nImpact is that users lose their funds, but admins gain them.\n\nThe mistakes could be mitigated on the contract, by checking against a list of supported tokens, so that users don't get the bad experience of losing funds and CUDOS doesn't have to manually refund users\n\n\nUser sends 100 ETH through sendToCosmos, hoping to retrieve 100 synthetic ETH on Cudos chain but finds that funds never appear.\n\n\n\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\t_amount,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\n\nGravity.sol#L595-L609(https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L609)<br\n\nAdmin can retrieve these funds should they wish, but user never gets them back because the contract does not check whether the token is supported.\n\n\n\n\tfunction withdrawERC20(\n\t\taddress _tokenAddress) \n\t\texternal {\n\t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n\t}\n\n\n\nGravity.sol#L632-L638(https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L632-L638)<br\n\n\nLogic and discussion with @germanimp (Cudos)\n\n",
                "Repair": "\nAdd checks in sendToCosmos to check the incoming tokenAddress against a supported token list, so that user funds don't get lost and admin don't need to bother refunding.\n\nmlukanova (Cudos) confirmed(https://github.com/code-423n4/2022-05-cudos-findings/issues/58)\n\nV-Staykov (Cudos) resolved and commented(https://github.com/code-423n4/2022-05-cudos-findings/issues/58#issuecomment-1128525099):\n  PR: CudoVentures/cosmos-gravity-bridge#21(https://github.com/CudoVentures/cosmos-gravity-bridge/pull/21)\n\n<br\n\n*Note: there were originally 7 items judged as Medium severity. After judging was finalized, further input from the sponsor was provided to the judge for reconsideration. Ultimately, the judge decreased issue #143(https://github.com/code-423n4/2022-05-cudos-findings/issues/143#issuecomment-1231179143) to non-critical.*\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 41 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-05-cudos-findings/issues/145) by IllIllI received the top score from the judge.\n\n*The following wardens also submitted reports: 0x1337(https://github.com/code-423n4/2022-05-cudos-findings/issues/51), jayjonah8(https://github.com/code-423n4/2022-05-cudos-findings/issues/18), GimelSec(https://github.com/code-423n4/2022-05-cudos-findings/issues/74), dirk_y(https://github.com/code-423n4/2022-05-cudos-findings/issues/105), GermanKuber(https://github.com/code-423n4/2022-05-cudos-findings/issues/153), CertoraInc(https://github.com/code-423n4/2022-05-cudos-findings/issues/118), ch13fd357r0y3r(https://github.com/code-423n4/2022-05-cudos-findings/issues/29), kirk-baird(https://github.com/code-423n4/2022-05-cudos-findings/issues/59), MaratCerby(https://github.com/code-423n4/2022-05-cudos-findings/issues/90), gzeon(https://github.com/code-423n4/2022-05-cudos-findings/issues/112), dipp(https://github.com/code-423n4/2022-05-cudos-findings/issues/129), robee(https://github.com/code-423n4/2022-05-cudos-findings/issues/40), 0xkatana(https://github.com/code-423n4/2022-05-cudos-findings/issues/55), Hawkeye(https://github.com/code-423n4/2022-05-cudos-findings/issues/164), sorrynotsorry(https://github.com/code-423n4/2022-05-cudos-findings/issues/124), orion(https://github.com/code-423n4/2022-05-cudos-findings/issues/1), hubble(https://github.com/code-423n4/2022-05-cudos-findings/issues/130), jah(https://github.com/code-423n4/2022-05-cudos-findings/issues/17), defsec(https://github.com/code-423n4/2022-05-cudos-findings/issues/149), Waze(https://github.com/code-423n4/2022-05-cudos-findings/issues/91), ilan(https://github.com/code-423n4/2022-05-cudos-findings/issues/135), m9800(https://github.com/code-423n4/2022-05-cudos-findings/issues/168), hake(https://github.com/code-423n4/2022-05-cudos-findings/issues/80), shenwilly(https://github.com/code-423n4/2022-05-cudos-findings/issues/25), AmitN(https://github.com/code-423n4/2022-05-cudos-findings/issues/116), danb(https://github.com/code-423n4/2022-05-cudos-findings/issues/39), Dravee(https://github.com/code-423n4/2022-05-cudos-findings/issues/152), cccz(https://github.com/code-423n4/2022-05-cudos-findings/issues/35), cryptphi(https://github.com/code-423n4/2022-05-cudos-findings/issues/136), 0x1f8b(https://github.com/code-423n4/2022-05-cudos-findings/issues/20), broccolirob(https://github.com/code-423n4/2022-05-cudos-findings/issues/175), ellahi(https://github.com/code-423n4/2022-05-cudos-findings/issues/133), Funen(https://github.com/code-423n4/2022-05-cudos-findings/issues/93), 0xDjango(https://github.com/code-423n4/2022-05-cudos-findings/issues/88), WatchPug(https://github.com/code-423n4/2022-05-cudos-findings/issues/104), kebabsec(https://github.com/code-423n4/2022-05-cudos-findings/issues/57), simon135(https://github.com/code-423n4/2022-05-cudos-findings/issues/30), JC(https://github.com/code-423n4/2022-05-cudos-findings/issues/110), oyc_109(https://github.com/code-423n4/2022-05-cudos-findings/issues/27), and delfin454000(https://github.com/code-423n4/2022-05-cudos-findings/issues/87).*\n\n## Low Risk Issues\n\n|   | Title                                                                                                                       | Instances |\n| | :-------------------------------------------------------------------------------------------------------------------------| :-------: |\n| 1 | Validator signing address of zero not rejected, allowing anyone to sign                                                     |     1     |\n| 2 | Unbounded loops may run out of gas                                                                                          |     1     |\n| 3 | deployERC20() does not have a reentrancy guard                                                                            |     1     |\n| 4 | Comment does not match the behavior of the code                                                                             |     2     |\n| 5 | abi.encodePacked() should not be used with dynamic types when passing the result to a hash function such as keccak256() |     1     |\n\nTotal: 6 instances over 5 classes<br\n(see lower down in this report for the summary table of the Non-critical findings)\n\n\n"
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n185  \t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n"
                ],
                "Type": " Validator signing address of zero not rejected, allowing anyone to sign",
                "Description": "\necrecover() returns 0 when the signature does not match. If the validators approve a valset including an address of 0, then anyone will be able to sign messages for that signer, since invalid sigatures will return zero, and will match the zero address.\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n185  \t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L185\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n219  \tfunction checkValidatorSignatures(\n220  \t\t// The current validator set and their powers\n221  \t\taddress[] memory _currentValidators,\n222  \t\tuint256[] memory _currentPowers,\n223  \t\t// The current validator's signatures\n224  \t\tuint8[] memory _v,\n225  \t\tbytes32[] memory _r,\n226  \t\tbytes32[] memory _s,\n227  \t\t// This is what we are checking they have signed\n228  \t\tbytes32 _theHash,\n229  \t\tuint256 _powerThreshold\n230  \t) private pure {\n231  \t\tuint256 cumulativePower = 0;\n232  \n233  \t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\n234  \t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\n235  \t\t\t// (In a valid signature, it is either 27 or 28)\n236  \t\t\tif (_v[i] != 0) {\n237  \t\t\t\t// Check that the current validator has signed off on the hash\n238  \t\t\t\trequire(\n239  \t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\n"
                ],
                "Type": " Unbounded loops may run out of gas",
                "Description": "\nThe call to ecrecover() costs 3000 gas per call, and if there are too many validators, the update of the validator set may pass, but large batches will fail\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n219  \tfunction checkValidatorSignatures(\n220  \t\t// The current validator set and their powers\n221  \t\taddress[] memory _currentValidators,\n222  \t\tuint256[] memory _currentPowers,\n223  \t\t// The current validator's signatures\n224  \t\tuint8[] memory _v,\n225  \t\tbytes32[] memory _r,\n226  \t\tbytes32[] memory _s,\n227  \t\t// This is what we are checking they have signed\n228  \t\tbytes32 _theHash,\n229  \t\tuint256 _powerThreshold\n230  \t) private pure {\n231  \t\tuint256 cumulativePower = 0;\n232  \n233  \t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\n234  \t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\n235  \t\t\t// (In a valid signature, it is either 27 or 28)\n236  \t\t\tif (_v[i] != 0) {\n237  \t\t\t\t// Check that the current validator has signed off on the hash\n238  \t\t\t\trequire(\n239  \t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L219-L239\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n611  \tfunction deployERC20(\n612  \t\tstring memory _cosmosDenom,\n613  \t\tstring memory _name,\n614  \t\tstring memory _symbol,\n615  \t\tuint8 _decimals\n616  \t) public {\n617  \t\t// Deploy an ERC20 with entire supply granted to Gravity.sol\n618  \t\tCosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n619  \n620  \t\t// Fire an event to let the Cosmos module know\n621  \t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n"
                ],
                "Type": "  deployERC20()  does not have a reentrancy guard",
                "Description": "\ndeployERC20() increments the state_lastEventNonce so it's possible for the nonce to be incremented by a transfer hook. I don't see a way to exploit this given the code in scope, but perhaps some other area relies on event nonces happening in a specific order in relation to the other events.\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n611  \tfunction deployERC20(\n612  \t\tstring memory _cosmosDenom,\n613  \t\tstring memory _name,\n614  \t\tstring memory _symbol,\n615  \t\tuint8 _decimals\n616  \t) public {\n617  \t\t// Deploy an ERC20 with entire supply granted to Gravity.sol\n618  \t\tCosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n619  \n620  \t\t// Fire an event to let the Cosmos module know\n621  \t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L611-L621\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n182  \t\tbytes32 messageDigest = keccak256(\n183  \t\t\tabi.encodePacked(\"x19Ethereum Signed Message:\n32\", _theHash)\n184  \t\t);\n185  \t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n"
                ],
                "Type": " Best practice is to prevent signature malleability",
                "Description": "\nUse OpenZeppelin's ECDSA contract rather than calling ecrecover() directly\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n182  \t\tbytes32 messageDigest = keccak256(\n183  \t\t\tabi.encodePacked(\"x19Ethereum Signed Message:\n32\", _theHash)\n184  \t\t);\n185  \t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L182-L185\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n63  \tCudosAccessControls public cudosAccessControls;\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n65  \tmapping(address = bool) public whitelisted;\n"
                ],
                "Type": " Inconsistent variable naming convention",
                "Description": "\nMost state variables use the state_ prefix in their variable name. There are some that don't. Use the prefix everywhere, and manually add public getters where necessary\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n63  \tCudosAccessControls public cudosAccessControls;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L63\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n65  \tmapping(address = bool) public whitelisted;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L65\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n116  \tmodifier onlyWhitelisted() {\n"
                ],
                "Type": " Misleading function name",
                "Description": "\nonlyWhitelisted() should be onlyWhitelistedOrAdmin()\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n116  \tmodifier onlyWhitelisted() {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L116\n\n\n",
                "Repair": ""
            },
            {
                "Name": "7",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n632  \tfunction withdrawERC20(\n633  \t\taddress _tokenAddress) \n634  \t\texternal {\n635  \t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n636  \t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n637  \t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n638  \t}\n"
                ],
                "Type": " Consider making the bridge 'pausable'",
                "Description": "\nHaving this ability would help to mitigate attacks and would ameleorate the need for this withdrawERC20() to be all-or-nothing\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n632  \tfunction withdrawERC20(\n633  \t\taddress _tokenAddress) \n634  \t\texternal {\n635  \t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n636  \t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n637  \t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n638  \t}\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L632-L638\n\nV-Staykov (Cudos) commented(https://github.com/code-423n4/2022-05-cudos-findings/issues/145#issuecomment-1122538703):\n  This is particularly high quality.\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 33 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-05-cudos-findings/issues/156) by GermanKuber received the top score from the judge.\n\n*The following wardens also submitted reports: IllIllI(https://github.com/code-423n4/2022-05-cudos-findings/issues/147), defsec(https://github.com/code-423n4/2022-05-cudos-findings/issues/141), 0xkatana(https://github.com/code-423n4/2022-05-cudos-findings/issues/54), Dravee(https://github.com/code-423n4/2022-05-cudos-findings/issues/96), 0x1f8b(https://github.com/code-423n4/2022-05-cudos-findings/issues/23), Funen(https://github.com/code-423n4/2022-05-cudos-findings/issues/86), 0xNazgul(https://github.com/code-423n4/2022-05-cudos-findings/issues/66), CertoraInc(https://github.com/code-423n4/2022-05-cudos-findings/issues/121), AlleyCat(https://github.com/code-423n4/2022-05-cudos-findings/issues/38), slywaters(https://github.com/code-423n4/2022-05-cudos-findings/issues/12), 0xf15ers(https://github.com/code-423n4/2022-05-cudos-findings/issues/82), oyc_109(https://github.com/code-423n4/2022-05-cudos-findings/issues/26), robee(https://github.com/code-423n4/2022-05-cudos-findings/issues/41), 0xDjango(https://github.com/code-423n4/2022-05-cudos-findings/issues/92), rfa(https://github.com/code-423n4/2022-05-cudos-findings/issues/148), peritoflores(https://github.com/code-423n4/2022-05-cudos-findings/issues/169), 0v3rf10w(https://github.com/code-423n4/2022-05-cudos-findings/issues/151), WatchPug(https://github.com/code-423n4/2022-05-cudos-findings/issues/103), ellahi(https://github.com/code-423n4/2022-05-cudos-findings/issues/132), MaratCerby(https://github.com/code-423n4/2022-05-cudos-findings/issues/89), simon135(https://github.com/code-423n4/2022-05-cudos-findings/issues/31), GimelSec(https://github.com/code-423n4/2022-05-cudos-findings/issues/76), hake(https://github.com/code-423n4/2022-05-cudos-findings/issues/81), gzeon(https://github.com/code-423n4/2022-05-cudos-findings/issues/111), delfin454000(https://github.com/code-423n4/2022-05-cudos-findings/issues/113), ilan(https://github.com/code-423n4/2022-05-cudos-findings/issues/134), JC(https://github.com/code-423n4/2022-05-cudos-findings/issues/109), sorrynotsorry(https://github.com/code-423n4/2022-05-cudos-findings/issues/125), hansfriese(https://github.com/code-423n4/2022-05-cudos-findings/issues/117), Waze(https://github.com/code-423n4/2022-05-cudos-findings/issues/84), nahnah(https://github.com/code-423n4/2022-05-cudos-findings/issues/166), and jonatascm(https://github.com/code-423n4/2022-05-cudos-findings/issues/46).*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "sendToCosmos()"
                ],
                "Type": "",
                "Description": "In the sendToCosmos() function it is not validated that _amount != 0, therefore the state_lastEventNonce could be made to grow only by spending gas.\nIf they go up to type(uint256).max could it cause an overflow and DoS system wide?\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n362  \t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n363  \t// the batch.\n364  \tfunction submitBatch (\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n274  \t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n275  \t// the new valset.\n276  \tfunction updateValset(\n"
                ],
                "Type": " Comment does not match the behavior of the code",
                "Description": "\nBoth of the functions below have require(isOrchestrator(msg.sender)), and orchestrators are the first signer, so not just anyone can call these\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n362  \t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n363  \t// the batch.\n364  \tfunction submitBatch (\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L362-L364\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n274  \t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n275  \t// the new valset.\n276  \tfunction updateValset(\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L274-L276\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n128  \t\t for (uint256 i = 0; i < _users.length; i++) {\n129              require(\n130                  _users[i] != address(0),\n131                  \"User is the zero address\"\n132              );\n133              whitelisted[_users[i]] = _isWhitelisted;\n134          }\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n117  \t\t require(\n118              whitelisted[msg.sender] || cudosAccessControls.hasAdminRole(msg.sender) ,\n119              \"The caller is not whitelisted for this operation\"\n120          );\n121  \t\t_;\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #3\n\n647  \t\taddress[] memory _validators,\n648      uint256[] memory _powers,\n649  \t\tCudosAccessControls _cudosAccessControls\n"
                ],
                "Type": " Inconsistent tabs vs spaces",
                "Description": "\nMost lines use tabs, but some use spaces, which leads to alignment issues\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n128  \t\t for (uint256 i = 0; i < _users.length; i++) {\n129              require(\n130                  _users[i] != address(0),\n131                  \"User is the zero address\"\n132              );\n133              whitelisted[_users[i]] = _isWhitelisted;\n134          }\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L128-L134\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n117  \t\t require(\n118              whitelisted[msg.sender] || cudosAccessControls.hasAdminRole(msg.sender) ,\n119              \"The caller is not whitelisted for this operation\"\n120          );\n121  \t\t_;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L117-L121\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #3\n\n647  \t\taddress[] memory _validators,\n648      uint256[] memory _powers,\n649  \t\tCudosAccessControls _cudosAccessControls\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L647-L649\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n116  \tmodifier onlyWhitelisted() {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n65  \tmapping(address = bool) public whitelisted;\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #3\n\n109  \tevent WhitelistedStatusModified(\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #4\n\n124  \tfunction manageWhitelist(\n"
                ],
                "Type": " Avoid the use of sensitive terms in favor of neutral ones",
                "Description": "\nUse allowlist rather than whitelist\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n116  \tmodifier onlyWhitelisted() {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L116\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n65  \tmapping(address = bool) public whitelisted;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L65\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #3\n\n109  \tevent WhitelistedStatusModified(\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L109\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #4\n\n124  \tfunction manageWhitelist(\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L124\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/CosmosToken.sol   #1\n\n5   \tuint256 MAX_UINT = 2256 1;\n"
                ],
                "Type": "  2<n> - 1  should be re-written as  type(uint<n>).max ",
                "Description": "\nEarlier versions of solidity can use uint<n(-1) instead. Expressions not including the 1 can often be re-written to accomodate the change (e.g. by using a  rather than a =, which will also save some gas)\n\nsolidity\nFile: solidity/contracts/CosmosToken.sol   #1\n\n5   \tuint256 MAX_UINT = 2256 1;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/CosmosToken.sol#L5\n\n\n",
                "Repair": ""
            },
            {
                "Name": "0",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n1   pragma //solidity ^0.6.6;\n"
                ],
                "Type": " Use a more recent version of solidity",
                "Description": "\nUse a solidity version of at least 0.8.4 to get bytes.concat() instead of abi.encodePacked(<bytes,<bytes)\nUse a solidity version of at least 0.8.12 to get string.concat() instead of abi.encodePacked(<str,<str)\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n1   pragma solidity ^0.6.6;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L1\n\n\n",
                "Repair": ""
            },
            {
                "Name": "2",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/CosmosToken.sol   #1\n\n1   pragma //solidity ^0.6.6;\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n1   pragma //solidity ^0.6.6;\n"
                ],
                "Type": " Non-library/interface files should use fixed compiler versions, not floating ones",
                "Description": "\nsolidity\nFile: solidity/contracts/CosmosToken.sol   #1\n\n1   pragma solidity ^0.6.6;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/CosmosToken.sol#L1\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n1   pragma solidity ^0.6.6;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L1\n\n\n",
                "Repair": ""
            },
            {
                "Name": "3",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n564   \t\t// Update invaldiation nonce\n"
                ],
                "Type": " Typos",
                "Description": "\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n564   \t\t// Update invaldiation nonce\n\n\ninvaldiation\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L564\n\n\n",
                "Repair": ""
            },
            {
                "Name": "4",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/CosmosToken.sol   #1\n\n0   pragma //solidity ^0.6.6;\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n0   pragma //solidity ^0.6.6;\n"
                ],
                "Type": " File does not contain an SPDX Identifier",
                "Description": "\nsolidity\nFile: solidity/contracts/CosmosToken.sol   #1\n\n0   pragma solidity ^0.6.6;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/CosmosToken.sol#L0\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n0   pragma solidity ^0.6.6;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L0\n\n\n",
                "Repair": ""
            },
            {
                "Name": "5",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/CosmosToken.sol (various lines)   #1\n\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol (various lines)   #2\n\n"
                ],
                "Type": " File is missing NatSpec",
                "Description": "\nsolidity\nFile: solidity/contracts/CosmosToken.sol (various lines)   #1\n\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/CosmosToken.sol\n\nsolidity\nFile: solidity/contracts/Gravity.sol (various lines)   #2\n\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CosmosToken.sol\";\nimport \"./CudosAccessControls.sol\";\n\npragma experimental ABIEncoderV2;\n\n// This is being used purely to avoid stack too deep errors\nstruct LogicCallArgs {\n\t// Transfers out to the logic contract\n\tuint256[] transferAmounts;\n\taddress[] transferTokenContracts;\n\t// The fees (transferred to msg.sender)\n\tuint256[] feeAmounts;\n\taddress[] feeTokenContracts;\n\t// The arbitrary logic call\n\taddress logicContractAddress;\n\tbytes payload;\n\t// Invalidation metadata\n\tuint256 timeOut;\n\tbytes32 invalidationId;\n\tuint256 invalidationNonce;\n}\n\n// This is used purely to avoid stack too deep errors\n// represents everything about a given validator set\nstruct ValsetArgs {\n\t// the validators in this set, represented by an Ethereum address\n\taddress[] validators;\n\t// the powers of the given validators in the same order as above\n\tuint256[] powers;\n\t// the nonce of this validator set\n\tuint256 valsetNonce;\n\t// the reward amount denominated in the below reward token, can be\n\t// set to zero\n\tuint256 rewardAmount;\n\t// the reward token, should be set to the zero address if not being used\n\taddress rewardToken;\n}\n\ncontract Gravity is ReentrancyGuard {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t// These are updated often\n\tbytes32 public state_lastValsetCheckpoint;\n\tmapping(address => uint256) public state_lastBatchNonces;\n\tmapping(bytes32 => uint256) public state_invalidationMapping;\n\tuint256 public state_lastValsetNonce = 0;\n\t// event nonce zero is reserved by the Cosmos module as a special\n\t// value indicating that no events have yet been submitted\n\tuint256 public state_lastEventNonce = 1;\n\n\t// These are set once at initialization\n\tbytes32 public state_gravityId;\n\tuint256 public state_powerThreshold;\n\n\tCudosAccessControls public cudosAccessControls;\n\n\tmapping(address => bool) public whitelisted;\n\n\t// TransactionBatchExecutedEvent and SendToCosmosEvent both include the field _eventNonce.\n\t// This is incremented every time one of these events is emitted. It is checked by the\n\t// Cosmos module to ensure that all events are received in order, and that none are lost.\n\t//\n\t// ValsetUpdatedEvent does not include the field _eventNonce because it is never submitted to the Cosmos\n\t// module. It is purely for the use of relayers to allow them to successfully submit batches.\n\tevent TransactionBatchExecutedEvent(\n\t\tuint256 indexed _batchNonce,\n\t\taddress indexed _token,\n\t\tuint256 _eventNonce\n\t);\n\tevent SendToCosmosEvent(\n\t\taddress indexed _tokenContract,\n\t\taddress indexed _sender,\n\t\tbytes32 indexed _destination,\n\t\tuint256 _amount,\n\t\tuint256 _eventNonce\n\t);\n\tevent ERC20DeployedEvent(\n\t\t// FYI: Can't index on a string without doing a bunch of weird stuff\n\t\tstring _cosmosDenom,\n\t\taddress indexed _tokenContract,\n\t\tstring _name,\n\t\tstring _symbol,\n\t\tuint8 _decimals,\n\t\tuint256 _eventNonce\n\t);\n\tevent ValsetUpdatedEvent(\n\t\tuint256 indexed _newValsetNonce,\n\t\tuint256 _eventNonce,\n\t\tuint256 _rewardAmount,\n\t\taddress _rewardToken,\n\t\taddress[] _validators,\n\t\tuint256[] _powers\n\t);\n\tevent LogicCallEvent(\n\t\tbytes32 _invalidationId,\n\t\tuint256 _invalidationNonce,\n\t\tbytes _returnData,\n\t\tuint256 _eventNonce\n\t);\n\n\tevent WhitelistedStatusModified(\n\t\taddress _sender,\n\t\taddress[] _users,\n\t\tbool _isWhitelisted\n\t);\n\n\n\tmodifier onlyWhitelisted() {\n\t\t require(\n            whitelisted[msg.sender] || cudosAccessControls.hasAdminRole(msg.sender) ,\n            \"The caller is not whitelisted for this operation\"\n        );\n\t\t_;\n\t}\n\n\tfunction manageWhitelist(\n\t\taddress[] memory _users,\n\t\tbool _isWhitelisted\n\t\t) public onlyWhitelisted {\n\t\t for (uint256 i = 0; i < _users.length; i++) {\n            require(\n                _users[i] != address(0),\n                \"User is the zero address\"\n            );\n            whitelisted[_users[i]] = _isWhitelisted;\n        }\n        emit WhitelistedStatusModified(msg.sender, _users, _isWhitelisted);\n\t}\n\n\t// TEST FIXTURES\n\t// These are here to make it easier to measure gas usage. They should be removed before production\n\tfunction testMakeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId) public pure {\n\t\tmakeCheckpoint(_valsetArgs, _gravityId);\n\t}\n\n\tfunction testCheckValidatorSignatures(\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) public pure {\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValidators,\n\t\t\t_currentPowers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\t_theHash,\n\t\t\t_powerThreshold\n\t\t);\n\t}\n\n\t// END TEST FIXTURES\n\n\tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\n\t\treturn state_lastBatchNonces[_erc20Address];\n\t}\n\n\tfunction lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {\n\t\treturn state_invalidationMapping[_invalidation_id];\n\t}\n\n\t// Utility function to verify geth style signatures\n\tfunction verifySig(\n\t\taddress _signer,\n\t\tbytes32 _theHash,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) private pure returns (bool) {\n\t\tbytes32 messageDigest = keccak256(\n\t\t\tabi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _theHash)\n\t\t);\n\t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n\t}\n\n\t// Make a new checkpoint from the supplied validator set\n\t// A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\n\t// instead of storing the information directly. This saves on storage and gas.\n\t// The format of the checkpoint is:\n\t// h(gravityId, \"checkpoint\", valsetNonce, validators[], powers[])\n\t// Where h is the keccak256 hash function.\n\t// The validator powers must be decreasing or equal. This is important for checking the signatures on the\n\t// next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\n\tfunction makeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId)\n\t\tprivate\n\t\tpure\n\t\treturns (bytes32)\n\t{\n\t\t// bytes32 encoding of the string \"checkpoint\"\n\t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n\n\t\tbytes32 checkpoint = keccak256(\n\t\t\tabi.encode(\n\t\t\t\t_gravityId,\n\t\t\t\tmethodName,\n\t\t\t\t_valsetArgs.valsetNonce,\n\t\t\t\t_valsetArgs.validators,\n\t\t\t\t_valsetArgs.powers,\n\t\t\t\t_valsetArgs.rewardAmount,\n\t\t\t\t_valsetArgs.rewardToken\n\t\t\t)\n\t\t);\n\n\t\treturn checkpoint;\n\t}\n\n\tfunction checkValidatorSignatures(\n\t\t// The current validator set and their powers\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\t// The current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// This is what we are checking they have signed\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) private pure {\n\t\tuint256 cumulativePower = 0;\n\n\t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\n\t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\n\t\t\t// (In a valid signature, it is either 27 or 28)\n\t\t\tif (_v[i] != 0) {\n\t\t\t\t// Check that the current validator has signed off on the hash\n\t\t\t\trequire(\n\t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\n\t\t\t\t\t\"Validator signature does not match.\"\n\t\t\t\t);\n\n\t\t\t\t// Sum up cumulative power\n\t\t\t\tcumulativePower = cumulativePower + _currentPowers[i];\n\n\t\t\t\t// Break early to avoid wasting gas\n\t\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that there was enough power\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\t\t// Success\n\t}\n\n\tfunction isOrchestrator(ValsetArgs memory _newValset, address _sender) private pure returns(bool) {\n\n\t\tfor (uint256 i = 0; i < _newValset.validators.length; i++) {\n\t\t\tif(_newValset.validators[i] == _sender) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// This updates the valset by checking that the validators in the current valset have signed off on the\n\t// new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\n\t// generated from the new valset.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the new valset.\n\tfunction updateValset(\n\t\t// The new version of the validator set\n\t\tValsetArgs memory _newValset,\n\t\t// The current validators that approve the change\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s\n\t) public nonReentrant {\n\t\t// CHECKS\n\n\t\t// Check that the valset nonce is greater than the old one\n\t\trequire(\n\t\t\t_newValset.valsetNonce > _currentValset.valsetNonce,\n\t\t\t\"New valset nonce must be greater than the current nonce\"\n\t\t);\n\n\t\t// Check that new validators and powers set is well-formed\n\t\trequire(\n\t\t\t_newValset.validators.length == _newValset.powers.length,\n\t\t\t\"Malformed new validator set\"\n\t\t);\n\n\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(\n\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\"Malformed current validator set\"\n\t\t);\n\n\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\trequire(\n\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t);\n\n\t\trequire(\n\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t);\n\n\t\t// Check that enough current validators have signed off on the new validator set\n\t\tbytes32 newCheckpoint = makeCheckpoint(_newValset, state_gravityId);\n\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValset.validators,\n\t\t\t_currentValset.powers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\tnewCheckpoint,\n\t\t\tstate_powerThreshold\n\t\t);\n\n\t\t// ACTIONS\n\n\t\t// Stored to be used next time to validate that the valset\n\t\t// supplied by the caller is correct.\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\t// Store new nonce\n\t\tstate_lastValsetNonce = _newValset.valsetNonce;\n\n\t\t// Send submission reward to msg.sender if reward token is a valid value\n\t\tif (_newValset.rewardToken != address(0) && _newValset.rewardAmount != 0) {\n\t\t\tIERC20(_newValset.rewardToken).safeTransfer(msg.sender, _newValset.rewardAmount);\n\t\t}\n\n\t\t// LOGS\n\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ValsetUpdatedEvent(\n\t\t\t_newValset.valsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t_newValset.rewardAmount,\n\t\t\t_newValset.rewardToken,\n\t\t\t_newValset.validators,\n\t\t\t_newValset.powers\n\t\t);\n\t}\n\n\t// submitBatch processes a batch of Cosmos -> Ethereum transactions by sending the tokens in the transactions\n\t// to the destination addresses. It is approved by the current Cosmos validator set.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the batch.\n\tfunction submitBatch (\n\t\t// The validators that approve the batch\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// The batch of transactions\n\t\tuint256[] memory _amounts,\n\t\taddress[] memory _destinations,\n\t\tuint256[] memory _fees,\n\t\tuint256 _batchNonce,\n\t\taddress _tokenContract,\n\t\t// a block height beyond which this batch is not valid\n\t\t// used to provide a fee-free timeout\n\t\tuint256 _batchTimeout\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the batch nonce is higher than the last nonce for this token\n\t\t\trequire(\n\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\n\t\t\t\t\"New batch nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that the block height is less than the timeout height\n\t\t\trequire(\n\t\t\t\tblock.number < _batchTimeout,\n\t\t\t\t\"Batch timeout must be greater than the current block height\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the transaction batch is well-formed\n\t\t\trequire(\n\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,\n\t\t\t\t\"Malformed batch of transactions\"\n\t\t\t);\n\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"\n\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n\t\t\t\t\t\t_amounts,\n\t\t\t\t\t\t_destinations,\n\t\t\t\t\t\t_fees,\n\t\t\t\t\t\t_batchNonce,\n\t\t\t\t\t\t_tokenContract,\n\t\t\t\t\t\t_batchTimeout\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\n\t\t\t// ACTIONS\n\n\t\t\t// Store batch nonce\n\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\n\n\t\t\t{\n\t\t\t\t// Send transaction amounts to destinations\n\t\t\t\tuint256 totalFee;\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\n\t\t\t\t\ttotalFee = totalFee.add(_fees[i]);\n\t\t\t\t}\n\n\t\t\t\t// Send transaction fees to msg.sender\n\t\t\t\tIERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n\t\t\t}\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);\n\t\t}\n\t}\n\n\t// This makes calls to contracts that execute arbitrary logic\n\t// First, it gives the logic contract some tokens\n\t// Then, it gives msg.senders tokens for fees\n\t// Then, it calls an arbitrary function on the logic contract\n\t// invalidationId and invalidationNonce are used for replay prevention.\n\t// They can be used to implement a per-token nonce by setting the token\n\t// address as the invalidationId and incrementing the nonce each call.\n\t// They can be used for nonce-free replay prevention by using a different invalidationId\n\t// for each call.\n\tfunction submitLogicCall(\n\t\t// The validators that approve the call\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tLogicCallArgs memory _args\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\trequire(block.number < _args.timeOut, \"Timed out\");\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\trequire(\n\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,\n\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the token transfer list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,\n\t\t\t\t\"Malformed list of token transfers\"\n\t\t\t);\n\n\t\t\t// Check that the fee list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,\n\t\t\t\t\"Malformed list of fees\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 argsHash = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tstate_gravityId,\n\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t_args.transferAmounts,\n\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t_args.feeAmounts,\n\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.payload,\n\t\t\t\t_args.timeOut,\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce\n\t\t\t)\n\t\t);\n\n\t\t{\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\treturnData,\n\t\t\t\tstate_lastEventNonce\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\t_amount,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction deployERC20(\n\t\tstring memory _cosmosDenom,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tuint8 _decimals\n\t) public {\n\t\t// Deploy an ERC20 with entire supply granted to Gravity.sol\n\t\tCosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n\n\t\t// Fire an event to let the Cosmos module know\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ERC20DeployedEvent(\n\t\t\t_cosmosDenom,\n\t\t\taddress(erc20),\n\t\t\t_name,\n\t\t\t_symbol,\n\t\t\t_decimals,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction withdrawERC20(\n\t\taddress _tokenAddress) \n\t\texternal {\n\t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n\t}\n\n\tconstructor(\n\t\t// A unique identifier for this gravity instance to use in signatures\n\t\tbytes32 _gravityId,\n\t\t// How much voting power is needed to approve operations\n\t\tuint256 _powerThreshold,\n\t\t// The validator set, not in valset args format since many of it's\n\t\t// arguments would never be used in this case\n\t\taddress[] memory _validators,\n    uint256[] memory _powers,\n\t\tCudosAccessControls _cudosAccessControls\n\t) public {\n\t\t// CHECKS\n\n\t\t// Check that validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(_validators.length == _powers.length, \"Malformed current validator set\");\n\t\trequire(address(_cudosAccessControls) != address(0), \"Access control contract address is incorrect\");\n\n\t\t// Check cumulative power to ensure the contract has sufficient power to actually\n\t\t// pass a vote\n\t\tuint256 cumulativePower = 0;\n\t\tfor (uint256 i = 0; i < _powers.length; i++) {\n\t\t\tcumulativePower = cumulativePower + _powers[i];\n\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\n\t\tValsetArgs memory _valset;\n\t\t_valset = ValsetArgs(_validators, _powers, 0, 0, address(0));\n\n\t\tbytes32 newCheckpoint = makeCheckpoint(_valset, _gravityId);\n\n\t\t// ACTIONS\n\n\t\tstate_gravityId = _gravityId;\n\t\tstate_powerThreshold = _powerThreshold;\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\tcudosAccessControls = _cudosAccessControls;\n\n\t\t// LOGS\n\n\t\temit ValsetUpdatedEvent(\n\t\t\tstate_lastValsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t0,\n\t\t\taddress(0),\n\t\t\t_validators,\n\t\t\t_powers\n\t\t);\n\t}\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract CudosAccessControls is AccessControl {\n    // Role definitions\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(\"SMART_CONTRACT_ROLE\");\n    // Events\n    event AdminRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event AdminRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event WhitelistRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event WhitelistRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event SmartContractRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event SmartContractRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    modifier onlyAdminRole() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"CudosAccessControls: sender must be an admin\");\n        _;\n    }\n\n    constructor() public {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /////////////\n    // Lookups //\n    /////////////\n    function hasAdminRole(address _address) external view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _address);\n    }\n    function hasWhitelistRole(address _address) external view returns (bool) {\n        return hasRole(WHITELISTED_ROLE, _address);\n    }\n    function hasSmartContractRole(address _address) external view returns (bool) {\n        return hasRole(SMART_CONTRACT_ROLE, _address);\n    }\n    ///////////////\n    // Modifiers //\n    ///////////////\n    function addAdminRole(address _address) external onlyAdminRole {\n        _setupRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleGranted(_address, _msgSender());\n    }\n    function removeAdminRole(address _address) external onlyAdminRole {\n        revokeRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleRemoved(_address, _msgSender());\n    }\n    function addWhitelistRole(address _address) external onlyAdminRole {\n        _setupRole(WHITELISTED_ROLE, _address);\n        emit WhitelistRoleGranted(_address, _msgSender());\n    }\n    function removeWhitelistRole(address _address) external onlyAdminRole {\n        revokeRole(WHITELISTED_ROLE, _address);\n        emit WhitelistRoleRemoved(_address, _msgSender());\n    }\n    function addSmartContractRole(address _address) external onlyAdminRole {\n        _setupRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleGranted(_address, _msgSender());\n    }\n    function removeSmartContractRole(address _address) external onlyAdminRole {\n        revokeRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleRemoved(_address, _msgSender());\n    }\n}\n\npragma solidity ^0.6.6;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract CosmosERC20 is ERC20 {\n\tuint256 MAX_UINT = 2**256 - 1;\n\n\tconstructor(\n\t\taddress _gravityAddress,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tuint8 _decimals\n\t) public ERC20(_name, _symbol) {\n\t\t_setupDecimals(_decimals);\n\t\t_mint(_gravityAddress, MAX_UINT);\n\t}\n}\n\n\n",
        "CodeNames": [
            "Gravity.sol",
            "CudosAccessControls.sol",
            "CosmosToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n182   \t\tbytes32 messageDigest = keccak256(\n183   \t\t\tabi.encodePacked(\"x19Ethereum Signed Message:n32\", _theHash)\n184   \t\t);\n"
                ],
                "Type": "  abi.encodePacked()  should not be used with dynamic types when passing the result to a hash function such as  keccak256() ",
                "Description": "\nUse abi.encode() instead which will pad items to 32 bytes, which will prevent hash collisions(https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. abi.encodePacked(0x123,0x456) = 0x123456 = abi.encodePacked(0x1,0x23456), but abi.encode(0x123,0x456) = 0x0...1230...456). \"Unless there is a compelling reason, abi.encode should be preferred\". If there is only one argument to abi.encodePacked() it can often be cast to bytes() or bytes32() instead(https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n182   \t\tbytes32 messageDigest = keccak256(\n183   \t\t\tabi.encodePacked(\"x19Ethereum Signed Message:n32\", _theHash)\n184   \t\t);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L182-L184\n\n## Non-critical Issues\n\n|    | Title                                                                                                   | Instances |\n| -| :-----------------------------------------------------------------------------------------------------| :-------: |\n| 1  | Best practice is to prevent signature malleability                                                      |     1     |\n| 2  | Inconsistent variable naming convention                                                                 |     2     |\n| 3  | Inconsistent tabs vs spaces                                                                             |     3     |\n| 4  | if( should be if ( to match other lines in the file                                                 |     1     |\n| 5  | Misleading function name                                                                                |     1     |\n| 6  | Avoid the use of sensitive terms in favor of neutral ones                                               |     4     |\n| 7  | public functions not called by the contract should be declared external instead                     |     10    |\n| 8  | 2<n 1 should be re-written as type(uint<n).max                                                |     1     |\n| 9  | constants should be defined rather than using magic numbers                                           |     3     |\n| 10 | Use a more recent version of solidity                                                                   |     1     |\n| 11 | Variable names that consist of all capital letters should be reserved for const/immutable variables |     1     |\n| 12 | Non-library/interface files should use fixed compiler versions, not floating ones                       |     2     |\n| 13 | Typos                                                                                                   |     1     |\n| 14 | File does not contain an SPDX Identifier                                                                |     2     |\n| 15 | File is missing NatSpec                                                                                 |     2     |\n| 16 | Event is missing indexed fields                                                                       |     5     |\n| 17 | Consider making the bridge 'pausable'                                                                   |     1     |\n\nTotal: 41 instances over 17 classes\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CosmosToken.sol\";\nimport \"./CudosAccessControls.sol\";\n\npragma experimental ABIEncoderV2;\n\n// This is being used purely to avoid stack too deep errors\nstruct LogicCallArgs {\n\t// Transfers out to the logic contract\n\tuint256[] transferAmounts;\n\taddress[] transferTokenContracts;\n\t// The fees (transferred to msg.sender)\n\tuint256[] feeAmounts;\n\taddress[] feeTokenContracts;\n\t// The arbitrary logic call\n\taddress logicContractAddress;\n\tbytes payload;\n\t// Invalidation metadata\n\tuint256 timeOut;\n\tbytes32 invalidationId;\n\tuint256 invalidationNonce;\n}\n\n// This is used purely to avoid stack too deep errors\n// represents everything about a given validator set\nstruct ValsetArgs {\n\t// the validators in this set, represented by an Ethereum address\n\taddress[] validators;\n\t// the powers of the given validators in the same order as above\n\tuint256[] powers;\n\t// the nonce of this validator set\n\tuint256 valsetNonce;\n\t// the reward amount denominated in the below reward token, can be\n\t// set to zero\n\tuint256 rewardAmount;\n\t// the reward token, should be set to the zero address if not being used\n\taddress rewardToken;\n}\n\ncontract Gravity is ReentrancyGuard {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t// These are updated often\n\tbytes32 public state_lastValsetCheckpoint;\n\tmapping(address => uint256) public state_lastBatchNonces;\n\tmapping(bytes32 => uint256) public state_invalidationMapping;\n\tuint256 public state_lastValsetNonce = 0;\n\t// event nonce zero is reserved by the Cosmos module as a special\n\t// value indicating that no events have yet been submitted\n\tuint256 public state_lastEventNonce = 1;\n\n\t// These are set once at initialization\n\tbytes32 public state_gravityId;\n\tuint256 public state_powerThreshold;\n\n\tCudosAccessControls public cudosAccessControls;\n\n\tmapping(address => bool) public whitelisted;\n\n\t// TransactionBatchExecutedEvent and SendToCosmosEvent both include the field _eventNonce.\n\t// This is incremented every time one of these events is emitted. It is checked by the\n\t// Cosmos module to ensure that all events are received in order, and that none are lost.\n\t//\n\t// ValsetUpdatedEvent does not include the field _eventNonce because it is never submitted to the Cosmos\n\t// module. It is purely for the use of relayers to allow them to successfully submit batches.\n\tevent TransactionBatchExecutedEvent(\n\t\tuint256 indexed _batchNonce,\n\t\taddress indexed _token,\n\t\tuint256 _eventNonce\n\t);\n\tevent SendToCosmosEvent(\n\t\taddress indexed _tokenContract,\n\t\taddress indexed _sender,\n\t\tbytes32 indexed _destination,\n\t\tuint256 _amount,\n\t\tuint256 _eventNonce\n\t);\n\tevent ERC20DeployedEvent(\n\t\t// FYI: Can't index on a string without doing a bunch of weird stuff\n\t\tstring _cosmosDenom,\n\t\taddress indexed _tokenContract,\n\t\tstring _name,\n\t\tstring _symbol,\n\t\tuint8 _decimals,\n\t\tuint256 _eventNonce\n\t);\n\tevent ValsetUpdatedEvent(\n\t\tuint256 indexed _newValsetNonce,\n\t\tuint256 _eventNonce,\n\t\tuint256 _rewardAmount,\n\t\taddress _rewardToken,\n\t\taddress[] _validators,\n\t\tuint256[] _powers\n\t);\n\tevent LogicCallEvent(\n\t\tbytes32 _invalidationId,\n\t\tuint256 _invalidationNonce,\n\t\tbytes _returnData,\n\t\tuint256 _eventNonce\n\t);\n\n\tevent WhitelistedStatusModified(\n\t\taddress _sender,\n\t\taddress[] _users,\n\t\tbool _isWhitelisted\n\t);\n\n\n\tmodifier onlyWhitelisted() {\n\t\t require(\n            whitelisted[msg.sender] || cudosAccessControls.hasAdminRole(msg.sender) ,\n            \"The caller is not whitelisted for this operation\"\n        );\n\t\t_;\n\t}\n\n\tfunction manageWhitelist(\n\t\taddress[] memory _users,\n\t\tbool _isWhitelisted\n\t\t) public onlyWhitelisted {\n\t\t for (uint256 i = 0; i < _users.length; i++) {\n            require(\n                _users[i] != address(0),\n                \"User is the zero address\"\n            );\n            whitelisted[_users[i]] = _isWhitelisted;\n        }\n        emit WhitelistedStatusModified(msg.sender, _users, _isWhitelisted);\n\t}\n\n\t// TEST FIXTURES\n\t// These are here to make it easier to measure gas usage. They should be removed before production\n\tfunction testMakeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId) public pure {\n\t\tmakeCheckpoint(_valsetArgs, _gravityId);\n\t}\n\n\tfunction testCheckValidatorSignatures(\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) public pure {\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValidators,\n\t\t\t_currentPowers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\t_theHash,\n\t\t\t_powerThreshold\n\t\t);\n\t}\n\n\t// END TEST FIXTURES\n\n\tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\n\t\treturn state_lastBatchNonces[_erc20Address];\n\t}\n\n\tfunction lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {\n\t\treturn state_invalidationMapping[_invalidation_id];\n\t}\n\n\t// Utility function to verify geth style signatures\n\tfunction verifySig(\n\t\taddress _signer,\n\t\tbytes32 _theHash,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) private pure returns (bool) {\n\t\tbytes32 messageDigest = keccak256(\n\t\t\tabi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _theHash)\n\t\t);\n\t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n\t}\n\n\t// Make a new checkpoint from the supplied validator set\n\t// A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\n\t// instead of storing the information directly. This saves on storage and gas.\n\t// The format of the checkpoint is:\n\t// h(gravityId, \"checkpoint\", valsetNonce, validators[], powers[])\n\t// Where h is the keccak256 hash function.\n\t// The validator powers must be decreasing or equal. This is important for checking the signatures on the\n\t// next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\n\tfunction makeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId)\n\t\tprivate\n\t\tpure\n\t\treturns (bytes32)\n\t{\n\t\t// bytes32 encoding of the string \"checkpoint\"\n\t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n\n\t\tbytes32 checkpoint = keccak256(\n\t\t\tabi.encode(\n\t\t\t\t_gravityId,\n\t\t\t\tmethodName,\n\t\t\t\t_valsetArgs.valsetNonce,\n\t\t\t\t_valsetArgs.validators,\n\t\t\t\t_valsetArgs.powers,\n\t\t\t\t_valsetArgs.rewardAmount,\n\t\t\t\t_valsetArgs.rewardToken\n\t\t\t)\n\t\t);\n\n\t\treturn checkpoint;\n\t}\n\n\tfunction checkValidatorSignatures(\n\t\t// The current validator set and their powers\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\t// The current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// This is what we are checking they have signed\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) private pure {\n\t\tuint256 cumulativePower = 0;\n\n\t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\n\t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\n\t\t\t// (In a valid signature, it is either 27 or 28)\n\t\t\tif (_v[i] != 0) {\n\t\t\t\t// Check that the current validator has signed off on the hash\n\t\t\t\trequire(\n\t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\n\t\t\t\t\t\"Validator signature does not match.\"\n\t\t\t\t);\n\n\t\t\t\t// Sum up cumulative power\n\t\t\t\tcumulativePower = cumulativePower + _currentPowers[i];\n\n\t\t\t\t// Break early to avoid wasting gas\n\t\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that there was enough power\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\t\t// Success\n\t}\n\n\tfunction isOrchestrator(ValsetArgs memory _newValset, address _sender) private pure returns(bool) {\n\n\t\tfor (uint256 i = 0; i < _newValset.validators.length; i++) {\n\t\t\tif(_newValset.validators[i] == _sender) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// This updates the valset by checking that the validators in the current valset have signed off on the\n\t// new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\n\t// generated from the new valset.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the new valset.\n\tfunction updateValset(\n\t\t// The new version of the validator set\n\t\tValsetArgs memory _newValset,\n\t\t// The current validators that approve the change\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s\n\t) public nonReentrant {\n\t\t// CHECKS\n\n\t\t// Check that the valset nonce is greater than the old one\n\t\trequire(\n\t\t\t_newValset.valsetNonce > _currentValset.valsetNonce,\n\t\t\t\"New valset nonce must be greater than the current nonce\"\n\t\t);\n\n\t\t// Check that new validators and powers set is well-formed\n\t\trequire(\n\t\t\t_newValset.validators.length == _newValset.powers.length,\n\t\t\t\"Malformed new validator set\"\n\t\t);\n\n\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(\n\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\"Malformed current validator set\"\n\t\t);\n\n\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\trequire(\n\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t);\n\n\t\trequire(\n\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t);\n\n\t\t// Check that enough current validators have signed off on the new validator set\n\t\tbytes32 newCheckpoint = makeCheckpoint(_newValset, state_gravityId);\n\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValset.validators,\n\t\t\t_currentValset.powers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\tnewCheckpoint,\n\t\t\tstate_powerThreshold\n\t\t);\n\n\t\t// ACTIONS\n\n\t\t// Stored to be used next time to validate that the valset\n\t\t// supplied by the caller is correct.\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\t// Store new nonce\n\t\tstate_lastValsetNonce = _newValset.valsetNonce;\n\n\t\t// Send submission reward to msg.sender if reward token is a valid value\n\t\tif (_newValset.rewardToken != address(0) && _newValset.rewardAmount != 0) {\n\t\t\tIERC20(_newValset.rewardToken).safeTransfer(msg.sender, _newValset.rewardAmount);\n\t\t}\n\n\t\t// LOGS\n\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ValsetUpdatedEvent(\n\t\t\t_newValset.valsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t_newValset.rewardAmount,\n\t\t\t_newValset.rewardToken,\n\t\t\t_newValset.validators,\n\t\t\t_newValset.powers\n\t\t);\n\t}\n\n\t// submitBatch processes a batch of Cosmos -> Ethereum transactions by sending the tokens in the transactions\n\t// to the destination addresses. It is approved by the current Cosmos validator set.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the batch.\n\tfunction submitBatch (\n\t\t// The validators that approve the batch\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// The batch of transactions\n\t\tuint256[] memory _amounts,\n\t\taddress[] memory _destinations,\n\t\tuint256[] memory _fees,\n\t\tuint256 _batchNonce,\n\t\taddress _tokenContract,\n\t\t// a block height beyond which this batch is not valid\n\t\t// used to provide a fee-free timeout\n\t\tuint256 _batchTimeout\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the batch nonce is higher than the last nonce for this token\n\t\t\trequire(\n\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\n\t\t\t\t\"New batch nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that the block height is less than the timeout height\n\t\t\trequire(\n\t\t\t\tblock.number < _batchTimeout,\n\t\t\t\t\"Batch timeout must be greater than the current block height\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the transaction batch is well-formed\n\t\t\trequire(\n\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,\n\t\t\t\t\"Malformed batch of transactions\"\n\t\t\t);\n\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"\n\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n\t\t\t\t\t\t_amounts,\n\t\t\t\t\t\t_destinations,\n\t\t\t\t\t\t_fees,\n\t\t\t\t\t\t_batchNonce,\n\t\t\t\t\t\t_tokenContract,\n\t\t\t\t\t\t_batchTimeout\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\n\t\t\t// ACTIONS\n\n\t\t\t// Store batch nonce\n\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\n\n\t\t\t{\n\t\t\t\t// Send transaction amounts to destinations\n\t\t\t\tuint256 totalFee;\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\n\t\t\t\t\ttotalFee = totalFee.add(_fees[i]);\n\t\t\t\t}\n\n\t\t\t\t// Send transaction fees to msg.sender\n\t\t\t\tIERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n\t\t\t}\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);\n\t\t}\n\t}\n\n\t// This makes calls to contracts that execute arbitrary logic\n\t// First, it gives the logic contract some tokens\n\t// Then, it gives msg.senders tokens for fees\n\t// Then, it calls an arbitrary function on the logic contract\n\t// invalidationId and invalidationNonce are used for replay prevention.\n\t// They can be used to implement a per-token nonce by setting the token\n\t// address as the invalidationId and incrementing the nonce each call.\n\t// They can be used for nonce-free replay prevention by using a different invalidationId\n\t// for each call.\n\tfunction submitLogicCall(\n\t\t// The validators that approve the call\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tLogicCallArgs memory _args\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\trequire(block.number < _args.timeOut, \"Timed out\");\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\trequire(\n\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,\n\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the token transfer list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,\n\t\t\t\t\"Malformed list of token transfers\"\n\t\t\t);\n\n\t\t\t// Check that the fee list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,\n\t\t\t\t\"Malformed list of fees\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 argsHash = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tstate_gravityId,\n\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t_args.transferAmounts,\n\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t_args.feeAmounts,\n\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.payload,\n\t\t\t\t_args.timeOut,\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce\n\t\t\t)\n\t\t);\n\n\t\t{\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\treturnData,\n\t\t\t\tstate_lastEventNonce\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\t_amount,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction deployERC20(\n\t\tstring memory _cosmosDenom,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tuint8 _decimals\n\t) public {\n\t\t// Deploy an ERC20 with entire supply granted to Gravity.sol\n\t\tCosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n\n\t\t// Fire an event to let the Cosmos module know\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ERC20DeployedEvent(\n\t\t\t_cosmosDenom,\n\t\t\taddress(erc20),\n\t\t\t_name,\n\t\t\t_symbol,\n\t\t\t_decimals,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction withdrawERC20(\n\t\taddress _tokenAddress) \n\t\texternal {\n\t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n\t}\n\n\tconstructor(\n\t\t// A unique identifier for this gravity instance to use in signatures\n\t\tbytes32 _gravityId,\n\t\t// How much voting power is needed to approve operations\n\t\tuint256 _powerThreshold,\n\t\t// The validator set, not in valset args format since many of it's\n\t\t// arguments would never be used in this case\n\t\taddress[] memory _validators,\n    uint256[] memory _powers,\n\t\tCudosAccessControls _cudosAccessControls\n\t) public {\n\t\t// CHECKS\n\n\t\t// Check that validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(_validators.length == _powers.length, \"Malformed current validator set\");\n\t\trequire(address(_cudosAccessControls) != address(0), \"Access control contract address is incorrect\");\n\n\t\t// Check cumulative power to ensure the contract has sufficient power to actually\n\t\t// pass a vote\n\t\tuint256 cumulativePower = 0;\n\t\tfor (uint256 i = 0; i < _powers.length; i++) {\n\t\t\tcumulativePower = cumulativePower + _powers[i];\n\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\n\t\tValsetArgs memory _valset;\n\t\t_valset = ValsetArgs(_validators, _powers, 0, 0, address(0));\n\n\t\tbytes32 newCheckpoint = makeCheckpoint(_valset, _gravityId);\n\n\t\t// ACTIONS\n\n\t\tstate_gravityId = _gravityId;\n\t\tstate_powerThreshold = _powerThreshold;\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\tcudosAccessControls = _cudosAccessControls;\n\n\t\t// LOGS\n\n\t\temit ValsetUpdatedEvent(\n\t\t\tstate_lastValsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t0,\n\t\t\taddress(0),\n\t\t\t_validators,\n\t\t\t_powers\n\t\t);\n\t}\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract CudosAccessControls is AccessControl {\n    // Role definitions\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(\"SMART_CONTRACT_ROLE\");\n    // Events\n    event AdminRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event AdminRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event WhitelistRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event WhitelistRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event SmartContractRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event SmartContractRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    modifier onlyAdminRole() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"CudosAccessControls: sender must be an admin\");\n        _;\n    }\n\n    constructor() public {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /////////////\n    // Lookups //\n    /////////////\n    function hasAdminRole(address _address) external view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _address);\n    }\n    function hasWhitelistRole(address _address) external view returns (bool) {\n        return hasRole(WHITELISTED_ROLE, _address);\n    }\n    function hasSmartContractRole(address _address) external view returns (bool) {\n        return hasRole(SMART_CONTRACT_ROLE, _address);\n    }\n    ///////////////\n    // Modifiers //\n    ///////////////\n    function addAdminRole(address _address) external onlyAdminRole {\n        _setupRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleGranted(_address, _msgSender());\n    }\n    function removeAdminRole(address _address) external onlyAdminRole {\n        revokeRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleRemoved(_address, _msgSender());\n    }\n    function addWhitelistRole(address _address) external onlyAdminRole {\n        _setupRole(WHITELISTED_ROLE, _address);\n        emit WhitelistRoleGranted(_address, _msgSender());\n    }\n    function removeWhitelistRole(address _address) external onlyAdminRole {\n        revokeRole(WHITELISTED_ROLE, _address);\n        emit WhitelistRoleRemoved(_address, _msgSender());\n    }\n    function addSmartContractRole(address _address) external onlyAdminRole {\n        _setupRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleGranted(_address, _msgSender());\n    }\n    function removeSmartContractRole(address _address) external onlyAdminRole {\n        revokeRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleRemoved(_address, _msgSender());\n    }\n}\n\n",
        "CodeNames": [
            "Gravity.sol",
            "CudosAccessControls.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n264  \t\t\tif(_newValset.validators[i] == _sender) {\n"
                ],
                "Type": "  if(  should be  if (  to match other lines in the file",
                "Description": "\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n264  \t\t\tif(_newValset.validators[i] == _sender) {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L264\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract CudosAccessControls is AccessControl {\n    // Role definitions\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(\"SMART_CONTRACT_ROLE\");\n    // Events\n    event AdminRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event AdminRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event WhitelistRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event WhitelistRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event SmartContractRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event SmartContractRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    modifier onlyAdminRole() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"CudosAccessControls: sender must be an admin\");\n        _;\n    }\n\n    constructor() public {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /////////////\n    // Lookups //\n    /////////////\n    function hasAdminRole(address _address) external view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _address);\n    }\n    function hasWhitelistRole(address _address) external view returns (bool) {\n        return hasRole(WHITELISTED_ROLE, _address);\n    }\n    function hasSmartContractRole(address _address) external view returns (bool) {\n        return hasRole(SMART_CONTRACT_ROLE, _address);\n    }\n    ///////////////\n    // Modifiers //\n    ///////////////\n    function addAdminRole(address _address) external onlyAdminRole {\n        _setupRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleGranted(_address, _msgSender());\n    }\n    function removeAdminRole(address _address) external onlyAdminRole {\n        revokeRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleRemoved(_address, _msgSender());\n    }\n    function addWhitelistRole(address _address) external onlyAdminRole {\n        _setupRole(WHITELISTED_ROLE, _address);\n        emit WhitelistRoleGranted(_address, _msgSender());\n    }\n    function removeWhitelistRole(address _address) external onlyAdminRole {\n        revokeRole(WHITELISTED_ROLE, _address);\n        emit WhitelistRoleRemoved(_address, _msgSender());\n    }\n    function addSmartContractRole(address _address) external onlyAdminRole {\n        _setupRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleGranted(_address, _msgSender());\n    }\n    function removeSmartContractRole(address _address) external onlyAdminRole {\n        revokeRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleRemoved(_address, _msgSender());\n    }\n}\n\npragma solidity ^0.6.6;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract CosmosERC20 is ERC20 {\n\tuint256 MAX_UINT = 2**256 - 1;\n\n\tconstructor(\n\t\taddress _gravityAddress,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tuint8 _decimals\n\t) public ERC20(_name, _symbol) {\n\t\t_setupDecimals(_decimals);\n\t\t_mint(_gravityAddress, MAX_UINT);\n\t}\n}\n\n\n",
        "CodeNames": [
            "CudosAccessControls.sol",
            "CosmosToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n124   \tfunction manageWhitelist(\n125   \t\taddress[] memory _users,\n126   \t\tbool _isWhitelisted\n127   \t\t) public onlyWhitelisted {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n140   \tfunction testMakeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId) public pure {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #3\n\n144   \tfunction testCheckValidatorSignatures(\n145   \t\taddress[] memory _currentValidators,\n146   \t\tuint256[] memory _currentPowers,\n147   \t\tuint8[] memory _v,\n148   \t\tbytes32[] memory _r,\n149   \t\tbytes32[] memory _s,\n150   \t\tbytes32 _theHash,\n151   \t\tuint256 _powerThreshold\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #4\n\n166   \tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #5\n\n170   \tfunction lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #6\n\n276   \tfunction updateValset(\n277   \t\t// The new version of the validator set\n278   \t\tValsetArgs memory _newValset,\n279   \t\t// The current validators that approve the change\n280   \t\tValsetArgs memory _currentValset,\n281   \t\t// These are arrays of the parts of the current validator's signatures\n282   \t\tuint8[] memory _v,\n283   \t\tbytes32[] memory _r,\n284   \t\tbytes32[] memory _s\n285   \t) public nonReentrant {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #7\n\n364   \tfunction submitBatch (\n365   \t\t// The validators that approve the batch\n366   \t\tValsetArgs memory _currentValset,\n367   \t\t// These are arrays of the parts of the validators signatures\n368   \t\tuint8[] memory _v,\n369   \t\tbytes32[] memory _r,\n370   \t\tbytes32[] memory _s,\n371   \t\t// The batch of transactions\n372   \t\tuint256[] memory _amounts,\n373   \t\taddress[] memory _destinations,\n374   \t\tuint256[] memory _fees,\n375   \t\tuint256 _batchNonce,\n376   \t\taddress _tokenContract,\n377   \t\t// a block height beyond which this batch is not valid\n378   \t\t// used to provide a fee-free timeout\n379   \t\tuint256 _batchTimeout\n380   \t) public nonReentrant {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #8\n\n479   \tfunction submitLogicCall(\n480   \t\t// The validators that approve the call\n481   \t\tValsetArgs memory _currentValset,\n482   \t\t// These are arrays of the parts of the validators signatures\n483   \t\tuint8[] memory _v,\n484   \t\tbytes32[] memory _r,\n485   \t\tbytes32[] memory _s,\n486   \t\tLogicCallArgs memory _args\n487   \t) public nonReentrant {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #9\n\n595   \tfunction sendToCosmos(\n596   \t\taddress _tokenContract,\n597   \t\tbytes32 _destination,\n598   \t\tuint256 _amount\n599   \t) public nonReentrant  {\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #10\n\n611   \tfunction deployERC20(\n612   \t\tstring memory _cosmosDenom,\n613   \t\tstring memory _name,\n614   \t\tstring memory _symbol,\n615   \t\tuint8 _decimals\n"
                ],
                "Type": "  public  functions not called by the contract should be declared  external  instead",
                "Description": "\nContracts are allowed(https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from external to public.\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n124   \tfunction manageWhitelist(\n125   \t\taddress[] memory _users,\n126   \t\tbool _isWhitelisted\n127   \t\t) public onlyWhitelisted {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L124-L127\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n140   \tfunction testMakeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId) public pure {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L140\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #3\n\n144   \tfunction testCheckValidatorSignatures(\n145   \t\taddress[] memory _currentValidators,\n146   \t\tuint256[] memory _currentPowers,\n147   \t\tuint8[] memory _v,\n148   \t\tbytes32[] memory _r,\n149   \t\tbytes32[] memory _s,\n150   \t\tbytes32 _theHash,\n151   \t\tuint256 _powerThreshold\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L144-L151\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #4\n\n166   \tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L166\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #5\n\n170   \tfunction lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L170\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #6\n\n276   \tfunction updateValset(\n277   \t\t// The new version of the validator set\n278   \t\tValsetArgs memory _newValset,\n279   \t\t// The current validators that approve the change\n280   \t\tValsetArgs memory _currentValset,\n281   \t\t// These are arrays of the parts of the current validator's signatures\n282   \t\tuint8[] memory _v,\n283   \t\tbytes32[] memory _r,\n284   \t\tbytes32[] memory _s\n285   \t) public nonReentrant {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L276-L285\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #7\n\n364   \tfunction submitBatch (\n365   \t\t// The validators that approve the batch\n366   \t\tValsetArgs memory _currentValset,\n367   \t\t// These are arrays of the parts of the validators signatures\n368   \t\tuint8[] memory _v,\n369   \t\tbytes32[] memory _r,\n370   \t\tbytes32[] memory _s,\n371   \t\t// The batch of transactions\n372   \t\tuint256[] memory _amounts,\n373   \t\taddress[] memory _destinations,\n374   \t\tuint256[] memory _fees,\n375   \t\tuint256 _batchNonce,\n376   \t\taddress _tokenContract,\n377   \t\t// a block height beyond which this batch is not valid\n378   \t\t// used to provide a fee-free timeout\n379   \t\tuint256 _batchTimeout\n380   \t) public nonReentrant {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L364-L380\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #8\n\n479   \tfunction submitLogicCall(\n480   \t\t// The validators that approve the call\n481   \t\tValsetArgs memory _currentValset,\n482   \t\t// These are arrays of the parts of the validators signatures\n483   \t\tuint8[] memory _v,\n484   \t\tbytes32[] memory _r,\n485   \t\tbytes32[] memory _s,\n486   \t\tLogicCallArgs memory _args\n487   \t) public nonReentrant {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L479-L487\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #9\n\n595   \tfunction sendToCosmos(\n596   \t\taddress _tokenContract,\n597   \t\tbytes32 _destination,\n598   \t\tuint256 _amount\n599   \t) public nonReentrant  {\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L599\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #10\n\n611   \tfunction deployERC20(\n612   \t\tstring memory _cosmosDenom,\n613   \t\tstring memory _name,\n614   \t\tstring memory _symbol,\n615   \t\tuint8 _decimals\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L611-L615\n\n\n",
                "Repair": ""
            },
            {
                "Name": "1",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/CosmosToken.sol   #1\n\n5   \tuint256 MAX_UINT = 2256 1;\n"
                ],
                "Type": " Variable names that consist of all capital letters should be reserved for  const / immutable  variables",
                "Description": "\nIf the variable needs to be different based on which class it comes from, a view/pure *function* should be used instead (e.g. like this(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/76eee35971c2541585e05cbf258510dda7b2fbc6/contracts/token/ERC20/extensions/draft-IERC20Permit.sol#L59)).\n\nsolidity\nFile: solidity/contracts/CosmosToken.sol   #1\n\n5   \tuint256 MAX_UINT = 2256 1;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/CosmosToken.sol#L5\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract CudosAccessControls is AccessControl {\n    // Role definitions\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(\"SMART_CONTRACT_ROLE\");\n    // Events\n    event AdminRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event AdminRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event WhitelistRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event WhitelistRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event SmartContractRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    event SmartContractRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n    modifier onlyAdminRole() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"CudosAccessControls: sender must be an admin\");\n        _;\n    }\n\n    constructor() public {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /////////////\n    // Lookups //\n    /////////////\n    function hasAdminRole(address _address) external view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _address);\n    }\n    function hasWhitelistRole(address _address) external view returns (bool) {\n        return hasRole(WHITELISTED_ROLE, _address);\n    }\n    function hasSmartContractRole(address _address) external view returns (bool) {\n        return hasRole(SMART_CONTRACT_ROLE, _address);\n    }\n    ///////////////\n    // Modifiers //\n    ///////////////\n    function addAdminRole(address _address) external onlyAdminRole {\n        _setupRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleGranted(_address, _msgSender());\n    }\n    function removeAdminRole(address _address) external onlyAdminRole {\n        revokeRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleRemoved(_address, _msgSender());\n    }\n    function addWhitelistRole(address _address) external onlyAdminRole {\n        _setupRole(WHITELISTED_ROLE, _address);\n        emit WhitelistRoleGranted(_address, _msgSender());\n    }\n    function removeWhitelistRole(address _address) external onlyAdminRole {\n        revokeRole(WHITELISTED_ROLE, _address);\n        emit WhitelistRoleRemoved(_address, _msgSender());\n    }\n    function addSmartContractRole(address _address) external onlyAdminRole {\n        _setupRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleGranted(_address, _msgSender());\n    }\n    function removeSmartContractRole(address _address) external onlyAdminRole {\n        revokeRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleRemoved(_address, _msgSender());\n    }\n}\n\n",
        "CodeNames": [
            "CudosAccessControls.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n202   \t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n433   \t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #3\n\n535   \t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n"
                ],
                "Type": "  constant s should be defined rather than using magic numbers",
                "Description": "\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n202   \t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L202\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n433   \t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L433\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #3\n\n535   \t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L535\n\n\n",
                "Repair": ""
            },
            {
                "Name": "6",
                "Location": [
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #1\n\n73   \tevent TransactionBatchExecutedEvent(\n74   \t\tuint256 indexed _batchNonce,\n75   \t\taddress indexed _token,\n76   \t\tuint256 _eventNonce\n77   \t);\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #2\n\n85   \tevent ERC20DeployedEvent(\n86   \t\t// FYI: Can't index on a string without doing a bunch of weird stuff\n87   \t\tstring _cosmosDenom,\n88   \t\taddress indexed _tokenContract,\n89   \t\tstring _name,\n90   \t\tstring _symbol,\n91   \t\tuint8 _decimals,\n92   \t\tuint256 _eventNonce\n93   \t);\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #3\n\n94   \tevent ValsetUpdatedEvent(\n95   \t\tuint256 indexed _newValsetNonce,\n96   \t\tuint256 _eventNonce,\n97   \t\tuint256 _rewardAmount,\n98   \t\taddress _rewardToken,\n99   \t\taddress[] _validators,\n100   \t\tuint256[] _powers\n101   \t);\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #4\n\n102   \tevent LogicCallEvent(\n103   \t\tbytes32 _invalidationId,\n104   \t\tuint256 _invalidationNonce,\n105   \t\tbytes _returnData,\n106   \t\tuint256 _eventNonce\n107   \t);\n",
                    "//solidity\nFile: //solidity/contracts/Gravity.sol   #5\n\n109   \tevent WhitelistedStatusModified(\n110   \t\taddress _sender,\n111   \t\taddress[] _users,\n112   \t\tbool _isWhitelisted\n113   \t);\n"
                ],
                "Type": " Event is missing  indexed  fields",
                "Description": "\nEach event should use three indexed fields if there are three or more fields\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #1\n\n73   \tevent TransactionBatchExecutedEvent(\n74   \t\tuint256 indexed _batchNonce,\n75   \t\taddress indexed _token,\n76   \t\tuint256 _eventNonce\n77   \t);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L73-L77\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #2\n\n85   \tevent ERC20DeployedEvent(\n86   \t\t// FYI: Can't index on a string without doing a bunch of weird stuff\n87   \t\tstring _cosmosDenom,\n88   \t\taddress indexed _tokenContract,\n89   \t\tstring _name,\n90   \t\tstring _symbol,\n91   \t\tuint8 _decimals,\n92   \t\tuint256 _eventNonce\n93   \t);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L85-L93\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #3\n\n94   \tevent ValsetUpdatedEvent(\n95   \t\tuint256 indexed _newValsetNonce,\n96   \t\tuint256 _eventNonce,\n97   \t\tuint256 _rewardAmount,\n98   \t\taddress _rewardToken,\n99   \t\taddress[] _validators,\n100   \t\tuint256[] _powers\n101   \t);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L94-L101\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #4\n\n102   \tevent LogicCallEvent(\n103   \t\tbytes32 _invalidationId,\n104   \t\tuint256 _invalidationNonce,\n105   \t\tbytes _returnData,\n106   \t\tuint256 _eventNonce\n107   \t);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L102-L107\n\nsolidity\nFile: solidity/contracts/Gravity.sol   #5\n\n109   \tevent WhitelistedStatusModified(\n110   \t\taddress _sender,\n111   \t\taddress[] _users,\n112   \t\tbool _isWhitelisted\n113   \t);\n\n\n<https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L109-L113\n\n\n",
                "Repair": ""
            }
        ]
    }
]