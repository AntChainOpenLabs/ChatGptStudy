[
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CoreCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "transferFrom()",
                    "transfer()",
                    "false"
                ],
                "Type": " ERC20 transferFrom return values not checked",
                "Description": "\nThe transferFrom() function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, transfer() function calls were checked.\n\nSome tokens like EURS(https://etherscan.io/address/0xdb25f211ab05b1c97d595516f45794528a807ad8#code) and BAT(https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code) will not revert if the transfer failed but return false instead. Tokens that don't actually perform the transfer and return false are still counted as a correct transfer.\n\n\nUsers would be able to mint NFTs for free regardless of mint fee if tokens that don\u2019t revert on failed transfers were used.\n\n",
                "Repair": "\nCheck the success boolean of all transferFrom() calls. Alternatively, use OZ\u2019s SafeERC20\u2019s safeTransferFrom() function.\n\nsofianeOuafir (Joyn) confirmed, disagreed with severity and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/52#issuecomment-1099284756):\n  In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)\n \n This is clearly an issue that needs to be fixed and represents a high risk. Currently, the current state of the code would allow users to mint tokens even if the payment isn't successful.\n \n\ndeluca-mike (judge) increased severity to High and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/52#issuecomment-1105345001):\n  payableToken seems to be defined by whomever defines the Collection in createProject, so it would be possible for that person to define a payable token that, unbeknownst to them, behaves unexpectedly. I agree with high risk (unless there is some person/committee that is curates and validates the paybaleTokens ahead of time). Need to handle return from transfer and transferFrom, as well as erc20s that do not return anything from from transfer and transferFrom.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "payableToken",
                    "initialize",
                    "onlyOwner",
                    "initialized"
                ],
                "Type": " CoreCollection can be reinitialized",
                "Description": "\nReinitialization is possible for CoreCollection as initialize function sets initialized flag, but doesn't control for it, so the function can be rerun multiple times.\n\nSuch types of issues tend to be critical as all core variables can be reset this way, for example payableToken, which provides a way to retrieve all the contract funds.\n\nHowever, setting priority to be medium as initialize is onlyOwner. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.\n\n\ninitialize doesn't control for repetitive runs:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87\n\n",
                "Repair": "\nAdd onlyUnInitialized modifier to the initialize function:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49\n\n\nsofianeOuafir (Joyn) confirmed, disagreed with severity and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/4#issuecomment-1099562776):\n  This is a high severity issue and we intend to fix it. The mitigation step looks great and will be considered to fix the issue.\n \n In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)\n\ndeluca-mike (judge) increased severity to High and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/4#issuecomment-1105941622):\n  ~~Not convinced this is a high severity issue, since erroneously changing payableToken via a re-initialization can simply be corrected by a re-re-initialization to set it back correctly. Further, as the warden mentioned, the initialize function is behind onlyOwner.~~\n \n ~~However, if it can be shown that users other than the owner can end up losing value due to the owner abusing or erroneously using initialize, then it can be promoted to High Severity.~~\n \n And just as I say that, #17 points that out clearly. So, yes, agreed, this is a High Severity issue.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [
                    "tokenId",
                    "ERC",
                    "totalSupply() % maxSupply = 0",
                    "totalSupply() = maxSupply",
                    "mintToken()",
                    "totalSupply() + amount <= maxSupply",
                    "totalSupply()",
                    "payableToken",
                    "((startingIndex + totalSupply()) % maxSupply) + 1",
                    "maxSupply ="
                ],
                "Type": " Duplicate NFTs Can Be Minted if  payableToken  Has a Callback Attached to it",
                "Description": "\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L139-L167\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50-L56\n\n\nThe mintToken() function is called to mint unique tokens from an ERC721 collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a payableToken. However, because the payableToken is paid before a token is minted, it may be possible to reenter the mintToken() function if there is a callback attached before or after the token transfer. Because totalSupply() has not been updated for the new token, a user is able to bypass the totalSupply() + amount <= maxSupply check. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way tokenId is generated will wrap around to the start again.\n\n\nFor the sake of this example, let's say startingIndex = 0 and maxSupply = 100. tokenId is minted according to ((startingIndex + totalSupply()) % maxSupply) + 1. If we see that a user mints a token where totalSupply() = maxSupply 1 = 99 and they reenter the function, then the next token to mint will actually be of index 1 as totalSupply() % maxSupply = 0. Calculating the first tokenId, we get ((0 + 0) % maxSupply) + 1 = 1 which is a duplicate of our example.\n\n",
                "Repair": "\nConsider adding reentrancy protections to prevent users from abusing this behaviour. It may also be useful to follow the checks-effects pattern such that all external/state changing calls are made at the end.\n\n\nsofianeOuafir (Joyn) confirmed and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/121#issuecomment-1099689645):\n  This is an issue we intend to investigate and fix if indeed it is an issue\n\ndeluca-mike (judge) commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/121#issuecomment-1106037774):\n  This is a valid high risk issue. Also, for reference, the checks-effects-interactions (CEI) pattern suggests you, in this order:\n perform checks that something can be done\n perform the effects (update storage and emit events)\n interact with other functions/contracts (since you may not be sure they will call out and re-enter)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-08",
                "Location": [
                    "payableToken.transferFrom(address(this), msg.sender, amount)",
                    "withdraw",
                    "transferFrom"
                ],
                "Type": " Funds cannot be withdrawn in  CoreCollection.withdraw ",
                "Description": "\nThe CoreCollection.withdraw function uses payableToken.transferFrom(address(this), msg.sender, amount) to transfer tokens from the CoreCollection contract to the msg.sender ( who is the owner of the contract). The usage of transferFrom can result in serious issues. In fact, many ERC20 always require that in transferFrom allowance[from][msg.sender] = amount, so in this case the call to the withdraw function will revert as the allowance[CoreCollection][CoreCollection] == 0 and therefore the funds cannot ben withdrawn and will be locked forever in the contract.\n\n",
                "Repair": "Replace transferFrom with transfer\n\n\nsofianeOuafir (Joyn) confirmed and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/80#issuecomment-1100089878):\n  duplicate of #52 \n\ndeluca-mike (judge) commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/80#issuecomment-1153003850):\n  This is not a duplicate, as it pertains to the wrong use of transfer vs transferFrom, which can have implications regarding required allowances.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title SplitStorage\n * @author MirrorXYZ\n */\ncontract SplitStorage {\n    bytes32 public merkleRoot;\n    uint256 public currentWindow;\n    address internal splitAsset;\n    address internal _splitter;\n    uint256[] public balanceForWindow;\n    mapping(bytes32 => bool) internal claimed;\n    uint256 internal depositedInWindow;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Splitter\n * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team\n */\ncontract Splitter is SplitStorage {\n    /**** Mutable variables ****/\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n\n    // The TransferETH event is emitted after each eth transfer in the split is attempted.\n    event TransferETH(\n        // The account to which the transfer was attempted.\n        address account,\n        // The amount for transfer that was attempted.\n        uint256 amount,\n        // Whether or not the transfer succeeded.\n        bool success\n    );\n\n    // Emits when a window is incremented.\n    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);\n\n    /**\n     * @dev Claim the funds from the all windows.\n     * @param percentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claimForAllWindows(\n        uint256 percentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Make sure that the user has this allocation granted.\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, percentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < currentWindow; i++) {\n            if (!isClaimed(msg.sender, i)) {\n                setClaimed(msg.sender, i);\n\n                amount += scaleAmountByPercentage(\n                    balanceForWindow[i],\n                    percentageAllocation\n                );\n            }\n        }\n\n        transferSplitAsset(msg.sender, amount);\n    }\n\n    /**\n     * @dev get Node hash of given data.\n     * @param who {address} whitelisted user address\n     * @param percentageAllocation {uint256} percentage of allocation\n     * @return {bytes32} node hash\n     */\n    function getNode(\n        address who,\n        uint256 percentageAllocation\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    who,\n                    percentageAllocation\n                )\n            );\n    }\n\n    /**\n     * @dev get scaled amount from given amount and percentage.\n     * @param amount {uint256} amount\n     * @param scaledPercent {uint256} scaled percentage\n     * @return scaledAmount {uint256} scaled amount\n     */\n    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        public\n        pure\n        returns (uint256 scaledAmount)\n    {\n        /*\n            Example:\n                If there is 100 ETH in the account, and someone has \n                an allocation of 2%, we call this with 100 as the amount, and 200\n                as the scaled percent.\n\n                To find out the amount we use, for example: (100 * 200) / (100 * 100)\n                which returns 2 -- i.e. 2% of the 100 ETH balance.\n         */\n        scaledAmount = (amount * scaledPercent) / (10000);\n    }\n\n    /**\n     * @dev claim for the given window.\n     * @param window {uint256} Window to claim\n     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claim(\n        uint256 window,\n        uint256 scaledPercentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(currentWindow > window, \"cannot claim for a future window\");\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n\n        setClaimed(msg.sender, window);\n\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, scaledPercentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        transferSplitAsset(\n            msg.sender,\n            // The absolute amount that's claimable.\n            scaleAmountByPercentage(\n                balanceForWindow[window],\n                scaledPercentageAllocation\n            )\n        );\n    }\n\n    /**\n     * @dev Function which handles increment window and puts amount to current window\n     * @param royaltyAmount {uint256} Amount needs to be added in window.\n     * @return {bool} Whether or not the window was incremented.\n     */\n    function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n        uint256 wethBalance;\n\n        require(\n            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n            \"Royalty Vault not supported\"\n        );\n        require(\n            IRoyaltyVault(msg.sender).getSplitter() == address(this),\n            \"Unauthorised to increment window\"\n        );\n\n        wethBalance = IERC20(splitAsset).balanceOf(address(this));\n        require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n        require(royaltyAmount > 0, \"No additional funds for window\");\n        balanceForWindow.push(royaltyAmount);\n        currentWindow += 1;\n        emit WindowIncremented(currentWindow, royaltyAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bool} Whether or not the window has been claimed.\n     */\n    function isClaimed(\n        address who,\n        uint256 window\n    ) public view returns (bool) {\n        return claimed[getClaimHash(who, window)];\n    }\n\n    /**** Private Functions ****/\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     */\n    function setClaimed(\n        address who,\n        uint256 window\n    ) private {\n        claimed[getClaimHash(who, window)] = true;\n    }\n\n    /**\n     * @dev Function which returns the hash of the given window, tokenId and membershipContract.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bytes32} Hash of the given window, tokenId and membershipContract.\n     */\n    function getClaimHash(\n        address who,\n        uint256 window\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(who, window));\n    }\n\n    /**\n     * @dev Function to convert output amount from percentages.\n     * @param amount {uint256} Amount for which percentage is to be calculated.\n     * @param percent {uint256} Percentage\n     * @return {uint256} Output amount.\n     */\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n    {\n        // Solidity 0.8.0 lets us do this without SafeMath.\n        return (amount * percent) / 100;\n    }\n\n    /**\n     * @dev Function to transfer split asset to the given address.\n     * @param to {address} Address to transfer the split asset to.\n     * @param value {uint256} Amount to transfer.\n     */\n    function transferSplitAsset(address to, uint256 value)\n        private\n        returns (bool didSucceed)\n    {\n        // Try to transfer ETH to the given recipient.\n        didSucceed = IERC20(splitAsset).transfer(to, value);\n        require(didSucceed, \"Failed to transfer ETH\");\n\n        emit TransferETH(to, value, didSucceed);\n    }\n\n    /**\n     * @dev transfer given amount of ETH in contract to the given address.\n     * @param to {address} Address to transfer asset\n     * @param value {uint256} Amount to transfer\n     * @return {bool} Whether or not the transfer was successful.\n     */\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\n    /**\n     * @dev Function to verify the given proof.\n     * @param proof {bytes32[]} Proof to verify\n     * @param root {bytes32} Root of the Merkle tree\n     * @param leaf {bytes32} Leaf to verify\n     * @return {bool} Whether or not the proof is valid.\n     */\n    function verifyProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) private pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n\n\n",
        "CodeNames": [
            "RoyaltyVault.sol",
            "SplitStorage.sol",
            "Splitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "currentWindow",
                    "incrementWindow()",
                    "claimForAllWindows()"
                ],
                "Type": " DoS:  claimForAllWindows()  May Be Made Unusable By An Attacker",
                "Description": "\nWhen the value of currentWindow is raised sufficiently high Splitter.claimForAllWindows() will not be able to be called due to the block gas limit.\n\ncurrentWindow can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.\n\nFurthermore, an attacker can continually increment currentWindow by calling incrementWindow(). An attacker can impersonate a IRoyaltyVault and send 1 WEI worth of WETH to pass the required checks.\n\n\nExcerpt from Splitter.claimForAllWindows() demonstrating the for loop over currentWindow that will grow indefinitely.\n\n            for (uint256 i = 0; i < currentWindow; i++) {\n                if (!isClaimed(msg.sender, i)) {\n                    setClaimed(msg.sender, i);\n\n                    amount += scaleAmountByPercentage(\n                        balanceForWindow[i],\n                        percentageAllocation\n                    );\n                }\n            }\n\nSplitter.incrementWindow() may be called by an attacker increasing currentWindow.\n\n        function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n            uint256 wethBalance;\n\n            require(\n                IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n                \"Royalty Vault not supported\"\n            );\n            require(\n                IRoyaltyVault(msg.sender).getSplitter() == address(this),\n                \"Unauthorised to increment window\"\n            );\n\n            wethBalance = IERC20(splitAsset).balanceOf(address(this));\n            require(wethBalance = royaltyAmount, \"Insufficient funds\");\n\n            require(royaltyAmount  0, \"No additional funds for window\");\n            balanceForWindow.push(royaltyAmount);\n            currentWindow += 1;\n            emit WindowIncremented(currentWindow, royaltyAmount);\n            return true;\n        }\n\n",
                "Repair": "\nConsider modifying the function claimForAllWindows() to instead claim for range of windows. Pass the function a startWindow and endWindow and only iterate through windows in that range. Ensure that endWindow < currentWindow.\n\n\nsofianeOuafir (Joyn) confirmed, disagreed with severity and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/6#issuecomment-1099542295):\n  In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)\n duplicate of #3 \n\ndeluca-mike (judge) increased severity to High and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/6#issuecomment-1105926348):\n  While similar, I believe these issues are separate.\n \n Issue 3 indicates that the check that msg.sender is an authorized RoyaltyVault is faulty, since any contract can implement the interface and return the Splitter from getSplitter. While this should be fixed, as the warden suggested in the Recommended Mitigation Steps in #3, the issue raised in this issue can still occur when enough authorized RoyaltyVault contracts call incrementWindow.\n \n claimForAllWindows can remain, but as this warden suggests, a claimForWindows(uint256 startWindow, uint256 endWindow, uint256 percentageAllocation, bytes32[] calldata merkleProof) should exist, in case claimForAllWindows becomes prohibitively expensive, even organically (i.e. currentWindow is made very high due to sufficient authorized incrementWindow calls).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}\n\n\n",
        "CodeNames": [
            "RoyaltyVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "platformFeeRecipient",
                    "_platformFee"
                ],
                "Type": " Centralisation RIsk: Owner Of  RoyaltyVault  Can Take All Funds",
                "Description": "\nThe owner of RoyaltyVault can set _platformFee to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the platformFeeRecipient (which is in the owners control) rather than the splitter contract.\n\nAs a result the owner can steal the entire contract balance and any future balances avoiding the splitter.\n\n\n        function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n            platformFee = _platformFee;\n            emit NewRoyaltyVaultPlatformFee(_platformFee);\n        }\n\n",
                "Repair": "\nThis issue may be mitigated by add a maximum value for the _platformFee say 5% (or some reasonable value based on the needs of the platform).\n\nAlso consider calling sendToSplitter() before adjusting the platformFee. This will only allow the owner to change the fee for future value excluding the current contract balance.\n\nConsider the following code.\n\n        function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n            require(_platformFee < MAX_FEE);\n            sendToSplitter(); // @audit this will need to be public rather than external\n            platformFee = _platformFee;\n            emit NewRoyaltyVaultPlatformFee(_platformFee);\n        }\n\n\nsofianeOuafir (Joyn) confirmed and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1099594175):\n  This is an issue and we intend to fix it. The recommended mitigation looks good and will be considered.\n \n We also agree that this is a med risk as this can currently only be done by the contract owner which is us at Joyn\n\ndeluca-mike (judge) commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1105957959):\n  Instead of having to come up with a \"reasonable\" MAX_FEE, consider instead just preventing the fee from ever being raised, and only allowing it to be lowered.\n\ndeluca-mike (judge) increased severity to High and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1105964175):\n  While I was originally leaning Medium Risk, after taking the arguments made by the duplicate issues into account, I am now leaning High Risk. The rationale is that, a DOS of sendToSplitter via a high platformFee not only harms stakeholders of the RoyaltyVault that would get the remainder of the balance, split, but may also prevent all NFT transfers if sendToSplitter is hooked into as part of all token transfer, via royalty payments. A malicious or disgruntled RoyaltyVault owner can hold all the NFTs hostage that call sendToSplitter atomically on transfers.\n \n So there are 2 issues that need to be solved here:\n protect NFT holders by ensuring platformFee (or any other values) cannot be set to a value that would cause sendToSplitter to fail (splitterShare = 0 or platformShare  balanceOfVault), or don't have sendToSplitter be called on NFT transfers\n protect royalty split recipients by putting an arbitrary max to the fee, or only allowing the fee to be reduced\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {ICoreFactory} from \"../interfaces/ICoreFactory.sol\";\n\ncontract CoreProxy is Ownable {\n    address private immutable _implement;\n\n    constructor(address _imp) {\n        _implement = _imp;\n    }\n\n    fallback() external {\n        address _impl = implement();\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    function implement() public view returns (address) {\n        return _implement;\n    }\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CoreProxy.sol",
            "CoreCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "impl",
                    "bytes",
                    "Ownable"
                ],
                "Type": " STORAGE COLLISION BETWEEN PROXY AND IMPLEMENTATION (LACK EIP 1967)",
                "Description": "\nStorage collision because of lack of EIP1967 could cause conflicts and override sensible variables\n\n\n    contract CoreProxy is Ownable {\n           address private immutable _implement;\n\nWhen you implement proxies, logic and implementation share the same storage layout.    In order to avoid storage conflicts  EIP1967 was proposed.(<https://eips.ethereum.org/EIPS/eip-1967)   The idea is to set proxy variables at fixed positions (like  impl and admin ).\n\nFor example, according to the standard,  the slot for for logic address should be\n\n0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc (obtained as bytes32(uint256(keccak256('eip1967.proxy.implementation')) 1)  ).\n\nIn this case, for example, as you inherits from Ownable the variable _owner is at the first slot and can be overwritten in the implementation.   There is a table at OZ site that explains this scenario more in detail\n\n<https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies\n\nsection  \"Unstructured Storaged Proxies\"\n\n\n",
                "Repair": "\nConsider using EIP1967\n\n\nsofianeOuafir (Joyn) confirmed and commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/108#issuecomment-1099710973):\n  This is an issue we want to investigate and fix if our investigation suggests we indeed need to make improvement on that end.\n \n At the same time, I have little idea of what is the impact of this issue. I'm not sure if it's a high risk item\n\ndeluca-mike (judge) commented(https://github.com/code-423n4/2022-03-joyn-findings/issues/108#issuecomment-1106035099):\n  Impact would be that an upgrade could brick a contract by simply rearranging inheritance order, or adding variables to an inherited contract, since the implantation slot will not be where it is expected. As the warden suggests, its critical that the implementation slot be fixed at an explicit location, and not an implicit location derived purely from inheritance and declaration order.\n\n\n\n*\n\n\n"
            }
        ]
    }
]