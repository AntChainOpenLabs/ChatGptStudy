[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {TurboMaster} from \"./TurboMaster.sol\";\nimport {TurboSafe} from \"./TurboSafe.sol\";\n\nimport {ENSReverseRecord} from \"ERC4626/ens/ENSReverseRecord.sol\";\nimport {IERC4626, ERC4626RouterBase, IWETH9, PeripheryPayments} from \"ERC4626/ERC4626RouterBase.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\n/**\n @title a router which can perform multiple Turbo actions between Master and the Safes\n @notice routes custom users flows between actions on the master and safes.\n\n Extends the ERC4626RouterBase to allow for flexible combinations of actions involving ERC4626 and permit, weth, and Turbo specific actions.\n\n Safe Creation has functions bundled with deposit (and optionally boost) because a newly created Safe address can only be known at runtime. \n The caller is always atomically given the owner role of a new safe.\n\n Authentication requires the caller to be the owner of the Safe to perform any ERC4626 method or TurboSafe requiresAuth method. \n Assumes the Safe's authority gives permission to call these functions to the TurboRouter.\n */\ncontract TurboRouter is ERC4626RouterBase, ENSReverseRecord {\n    using SafeTransferLib for ERC20;\n\n    TurboMaster public immutable master;\n\n    constructor (TurboMaster _master, string memory name, IWETH9 weth) ENSReverseRecord(name) PeripheryPayments(weth) {\n        master = _master;\n    }\n\n    modifier authenticate(address target) {\n        require(msg.sender == Auth(target).owner(), \"NOT_AUTHED\");\n\n        _;\n    }\n\n    function createSafe(ERC20 underlying) external {\n        (TurboSafe safe, ) = master.createSafe(underlying);\n\n        safe.setOwner(msg.sender);\n    }\n\n    function createSafeAndDeposit(ERC20 underlying, address to, uint256 amount, uint256 minSharesOut) external {\n        (TurboSafe safe, ) = master.createSafe(underlying);\n\n        super.deposit(IERC4626(address(safe)), to, amount, minSharesOut);\n\n        safe.setOwner(msg.sender);\n    }\n\n    function createSafeAndDepositAndBoost(\n        ERC20 underlying, \n        address to, \n        uint256 amount, \n        uint256 minSharesOut, \n        ERC4626 boostedVault, \n        uint256 boostedFeiAmount\n    ) public {\n        (TurboSafe safe, ) = master.createSafe(underlying);\n\n        super.deposit(IERC4626(address(safe)), to, amount, minSharesOut);\n\n        safe.boost(boostedVault, boostedFeiAmount);\n\n        safe.setOwner(msg.sender);\n    }\n\n    function deposit(IERC4626 safe, address to, uint256 amount, uint256 minSharesOut) \n        public \n        payable \n        override \n        authenticate(address(safe)) \n        returns (uint256) \n    {\n        return super.deposit(safe, to, amount, minSharesOut);\n    }\n\n    function mint(IERC4626 safe, address to, uint256 shares, uint256 maxAmountIn) \n        public \n        payable \n        override \n        authenticate(address(safe)) \n        returns (uint256) \n    {\n        return super.mint(safe, to, shares, maxAmountIn);\n    }\n\n    function withdraw(IERC4626 safe, address to, uint256 amount, uint256 minSharesOut) \n        public \n        payable \n        override \n        authenticate(address(safe)) \n        returns (uint256) \n    {\n        return super.withdraw(safe, to, amount, minSharesOut);\n    }\n\n    function redeem(IERC4626 safe, address to, uint256 shares, uint256 minAmountOut) \n        public \n        payable \n        override \n        authenticate(address(safe)) \n        returns (uint256) \n    {\n        return super.redeem(safe, to, shares, minAmountOut);\n    }\n\n    function slurp(TurboSafe safe, ERC4626 vault) external authenticate(address(safe)) {\n        safe.slurp(vault);\n    }\n\n    function boost(TurboSafe safe, ERC4626 vault, uint256 feiAmount) public authenticate(address(safe)) {\n        safe.boost(vault, feiAmount);\n    }\n\n    function less(TurboSafe safe, ERC4626 vault, uint256 feiAmount) external authenticate(address(safe)) {\n        safe.less(vault, feiAmount);\n    }\n\n    function sweep(TurboSafe safe, address to, ERC20 token, uint256 amount) external authenticate(address(safe)) {\n        safe.sweep(to, token, amount);\n    }\n\n    function slurpAndLess(TurboSafe safe, ERC4626 vault, uint256 feiAmount) external authenticate(address(safe)) {\n        safe.slurp(vault);\n        safe.less(vault, feiAmount);\n    }\n}\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {FuseAdmin} from \"./interfaces/FuseAdmin.sol\";\nimport {Comptroller} from \"./interfaces/Comptroller.sol\";\n\nimport {TurboClerk} from \"./modules/TurboClerk.sol\";\nimport {TurboGibber} from \"./modules/TurboGibber.sol\";\nimport {TurboBooster} from \"./modules/TurboBooster.sol\";\n\nimport {TurboSafe} from \"./TurboSafe.sol\";\n\n/// @title Turbo Master\n/// @author Transmissions11\n/// @notice Factory for creating and managing Turbo Safes.\n/// @dev Must be authorized to call the Turbo Fuse Pool's FuseAdmin.\ncontract TurboMaster is Auth {\n    using SafeTransferLib for ERC20;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The Turbo Fuse Pool the Safes will interact with.\n    Comptroller public immutable pool;\n\n    /// @notice The Fei token on the network.\n    ERC20 public immutable fei;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new Turbo Master contract.\n    /// @param _pool The Turbo Fuse Pool the Master will use.\n    /// @param _fei The Fei token on the network.\n    /// @param _owner The owner of the Master.\n    /// @param _authority The Authority of the Master.\n    constructor(\n        Comptroller _pool,\n        ERC20 _fei,\n        address _owner,\n        Authority _authority\n    ) Auth(_owner, _authority) {\n        pool = _pool;\n\n        fei = _fei;\n\n        // Prevent the first safe from getting id 0.\n        safes.push(TurboSafe(address(0)));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            BOOSTER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The Booster module used by the Master and its Safes.\n    TurboBooster public booster;\n\n    /// @notice Emitted when the Booster is updated.\n    /// @param user The user who triggered the update of the Booster.\n    /// @param newBooster The new Booster contract used by the Master.\n    event BoosterUpdated(address indexed user, TurboBooster newBooster);\n\n    /// @notice Update the Booster used by the Master.\n    /// @param newBooster The new Booster contract to be used by the Master.\n    function setBooster(TurboBooster newBooster) external requiresAuth {\n        booster = newBooster;\n\n        emit BoosterUpdated(msg.sender, newBooster);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             CLERK STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The Clerk module used by the Master and its Safes.\n    TurboClerk public clerk;\n\n    /// @notice Emitted when the Clerk is updated.\n    /// @param user The user who triggered the update of the Clerk.\n    /// @param newClerk The new Clerk contract used by the Master.\n    event ClerkUpdated(address indexed user, TurboClerk newClerk);\n\n    /// @notice Update the Clerk used by the Master.\n    /// @param newClerk The new Clerk contract to be used by the Master.\n    function setClerk(TurboClerk newClerk) external requiresAuth {\n        clerk = newClerk;\n\n        emit ClerkUpdated(msg.sender, newClerk);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                  DEFAULT SAFE AUTHORITY CONFIGURATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The default authority to be used by created Safes.\n    Authority public defaultSafeAuthority;\n\n    /// @notice Emitted when the default safe authority is updated.\n    /// @param user The user who triggered the update of the default safe authority.\n    /// @param newDefaultSafeAuthority The new default authority to be used by created Safes.\n    event DefaultSafeAuthorityUpdated(address indexed user, Authority newDefaultSafeAuthority);\n\n    /// @notice Set the default authority to be used by created Safes.\n    /// @param newDefaultSafeAuthority The new default safe authority.\n    function setDefaultSafeAuthority(Authority newDefaultSafeAuthority) external requiresAuth {\n        // Update the default safe authority.\n        defaultSafeAuthority = newDefaultSafeAuthority;\n\n        emit DefaultSafeAuthorityUpdated(msg.sender, newDefaultSafeAuthority);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             SAFE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The total Fei currently boosting Vaults.\n    uint256 public totalBoosted;\n\n    /// @notice Maps Safe addresses to the id they are stored under in the Safes array.\n    mapping(TurboSafe => uint256) public getSafeId;\n\n    /// @notice Maps Vault addresses to the total amount of Fei they've being boosted with.\n    mapping(ERC4626 => uint256) public getTotalBoostedForVault;\n\n    /// @notice Maps collateral types to the total amount of Fei boosted by Safes using it as collateral.\n    mapping(ERC20 => uint256) public getTotalBoostedAgainstCollateral;\n\n    /// @notice An array of all Safes created by the Master.\n    /// @dev The first Safe is purposely invalid to prevent any Safes from having an id of 0.\n    TurboSafe[] public safes;\n\n    /// @notice Returns all Safes created by the Master.\n    /// @return An array of all Safes created by the Master.\n    /// @dev This is provided because Solidity converts public arrays into index getters,\n    /// but we need a way to allow external contracts and users to access the whole array.\n    function getAllSafes() external view returns (TurboSafe[] memory) {\n        return safes;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          SAFE CREATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a new Safe is created.\n    /// @param user The user who created the Safe.\n    /// @param asset The asset of the Safe.\n    /// @param safe The newly deployed Safe contract.\n    /// @param id The index of the Safe in the safes array.\n    event TurboSafeCreated(address indexed user, ERC20 indexed asset, TurboSafe safe, uint256 id);\n\n    /// @notice Creates a new Turbo Safe which supports a specific asset.\n    /// @param asset The ERC20 token that the Safe should accept.\n    /// @return safe The newly deployed Turbo Safe which accepts the provided asset.\n    function createSafe(ERC20 asset) external requiresAuth returns (TurboSafe safe, uint256 id) {\n        // Create a new Safe using the default authority and provided asset.\n        safe = new TurboSafe(msg.sender, defaultSafeAuthority, asset);\n\n        // Add the safe to the list of Safes.\n        safes.push(safe);\n\n        unchecked {\n            // Get the index/id of the new Safe.\n            // Cannot underflow, we just pushed to it.\n            id = safes.length - 1;\n        }\n\n        // Store the id/index of the new Safe.\n        getSafeId[safe] = id;\n\n        emit TurboSafeCreated(msg.sender, asset, safe, id);\n\n        // Prepare a users array to whitelist the Safe.\n        address[] memory users = new address[](1);\n        users[0] = address(safe);\n\n        // Prepare an enabled array to whitelist the Safe.\n        bool[] memory enabled = new bool[](1);\n        enabled[0] = true;\n\n        // Whitelist the Safe to access the Turbo Fuse Pool.\n        FuseAdmin(pool.admin())._setWhitelistStatuses(users, enabled);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          SAFE CALLBACK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Callback triggered whenever a Safe boosts a Vault.\n    /// @param asset The asset of the Safe.\n    /// @param vault The Vault that was boosted.\n    /// @param feiAmount The amount of Fei used to boost the Vault.\n    function onSafeBoost(\n        ERC20 asset,\n        ERC4626 vault,\n        uint256 feiAmount\n    ) external {\n        // Get the caller as a Safe instance.\n        TurboSafe safe = TurboSafe(msg.sender);\n\n        // Ensure the Safe was created by this Master.\n        require(getSafeId[safe] != 0, \"INVALID_SAFE\");\n\n        // Update the total amount of Fei being using to boost Vaults.\n        totalBoosted += feiAmount;\n\n        // Cache the new total boosted for the Vault.\n        uint256 newTotalBoostedForVault;\n\n        // Cache the new total boosted against the Vault's collateral.\n        uint256 newTotalBoostedAgainstCollateral;\n\n        unchecked {\n            // Update the total amount of Fei being using to boost the Vault.\n            // Cannot overflow because a Safe's total will never be greater than global total.\n            getTotalBoostedForVault[vault] = (newTotalBoostedForVault = getTotalBoostedForVault[vault] + feiAmount);\n\n            // Update the total amount of Fei boosted against the collateral type.\n            // Cannot overflow because a collateral type's total will never be greater than global total.\n            getTotalBoostedAgainstCollateral[asset] = (newTotalBoostedAgainstCollateral =\n                getTotalBoostedAgainstCollateral[asset] +\n                feiAmount);\n        }\n\n        // Check with the booster that the Safe is allowed to boost the Vault using this amount of Fei.\n        require(\n            booster.canSafeBoostVault(\n                safe,\n                asset,\n                vault,\n                feiAmount,\n                newTotalBoostedForVault,\n                newTotalBoostedAgainstCollateral\n            ),\n            \"BOOSTER_REJECTED\"\n        );\n    }\n\n    /// @notice Callback triggered whenever a Safe withdraws from a Vault.\n    /// @param asset The asset of the Safe.\n    /// @param vault The Vault that was withdrawn from.\n    /// @param feiAmount The amount of Fei withdrawn from the Vault.\n    function onSafeLess(\n        ERC20 asset,\n        ERC4626 vault,\n        uint256 feiAmount\n    ) external {\n        // Get the caller as a Safe instance.\n        TurboSafe safe = TurboSafe(msg.sender);\n\n        // Ensure the Safe was created by this Master.\n        require(getSafeId[safe] != 0, \"INVALID_SAFE\");\n\n        unchecked {\n            // Update the total amount of Fei being using to boost the Vault.\n            // Cannot underflow as the Safe validated the withdrawal amount before.\n            getTotalBoostedForVault[vault] -= feiAmount;\n\n            // Update the total amount of Fei being using to boost Vaults.\n            // Cannot underflow as the Safe validated the withdrawal amount earlier.\n            totalBoosted -= feiAmount;\n\n            // Update the total amount of Fei boosted against the collateral type.\n            // Cannot underflow as the Safe validated the withdrawal amount previously.\n            getTotalBoostedAgainstCollateral[asset] -= feiAmount;\n        }\n    }\n\n    /// @notice Callback triggered whenever a Safe harvests from a Vault.\n    /// @param asset The asset of the Safe.\n    /// @param vault The Vault that was harvested from.\n    /// @param feiAmount The amount of Fei accrued as interest to the Safe.\n    function onSafeSlurp(\n        ERC20 asset,\n        ERC4626 vault,\n        uint256 feiAmount\n    ) external {\n        // Get the caller as a Safe instance.\n        TurboSafe safe = TurboSafe(msg.sender);\n\n        // Ensure the Safe was created by this Master.\n        require(getSafeId[safe] != 0, \"INVALID_SAFE\");\n\n        // Update the total amount of Fei being using to boost Vaults.\n        totalBoosted += feiAmount;\n\n        unchecked {\n            // Update the total amount of Fei being using to boost the Vault.\n            // Cannot overflow because a Safe's total will never be greater than global total.\n            getTotalBoostedForVault[vault] += feiAmount;\n\n            // Update the total amount of Fei boosted against the collateral type.\n            // Cannot overflow because a collateral type's total will never be greater than global total.\n            getTotalBoostedAgainstCollateral[asset] += feiAmount;\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              SWEEP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted a token is sweeped from the Master.\n    /// @param user The user who sweeped the token from the Master.\n    /// @param to The recipient of the sweeped tokens.\n    /// @param amount The amount of the token that was sweeped.\n    event TokenSweeped(address indexed user, address indexed to, ERC20 indexed token, uint256 amount);\n\n    /// @notice Claim tokens sitting idly in the Master.\n    /// @param to The recipient of the sweeped tokens.\n    /// @param token The token to sweep and send.\n    /// @param amount The amount of the token to sweep.\n    function sweep(\n        address to,\n        ERC20 token,\n        uint256 amount\n    ) external requiresAuth {\n        emit TokenSweeped(msg.sender, to, token, amount);\n\n        // Transfer the sweeped tokens to the recipient.\n        token.safeTransfer(to, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "TurboRouter.sol",
            "TurboMaster.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n    amount = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    _mint(to, amount);\n\n    emit Deposit(msg.sender, to, amount, shares);\n\n    afterDeposit(amount, shares);\n}\n"
                ],
                "Type": " ERC4626 mint uses wrong  amount ",
                "Description": "\n The docs/video say ERC4626.sol is in scope as its part of TurboSafe\n\nThe ERC4626.mint function mints amount instead of shares.\nThis will lead to issues when the asset < shares are not 1-to-1 as will be the case for most vaults over time.\nUsually, the asset amount is larger than the share amount as vaults receive asset yield.\nTherefore, when minting, shares should be less than amount.\nUsers receive a larger share amount here which can be exploited to drain the vault assets.\n\nsolidity\nfunction mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n    amount = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    _mint(to, amount);\n\n    emit Deposit(msg.sender, to, amount, shares);\n\n    afterDeposit(amount, shares);\n}\n\n\n\nAssume vault.totalSupply() = 1000, totalAssets = 1500\n\n*   call mint(shares=1000). Only need to pay 1000 asset amount but receive 1000 shares = vault.totalSupply() = 2000, totalAssets = 2500.\n*   call redeem(shares=1000). Receive (1000 / 2000) * 2500 = 1250 amounts. Make a profit of 250 asset tokens.\n*   repeat until shares < assets are 1-to-1\n\n",
                "Repair": "\nIn deposit:\n\ndiff\nfunction mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n   _mint(to, amount);\n+    _mint(to, shares);\n}\n\n\nAlex the Entreprenerd (judge)(https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/27#issuecomment-1065919880):\n  The warden has identified what is most likely a small oversight, which would have drastic consequences in the internal accounting of the Vault.\n Because of impact, I agree with high severity.\n \n The sponsor has mitigated.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {TurboMaster} from \"./TurboMaster.sol\";\nimport {TurboSafe} from \"./TurboSafe.sol\";\n\nimport {ENSReverseRecord} from \"ERC4626/ens/ENSReverseRecord.sol\";\nimport {IERC4626, ERC4626RouterBase, IWETH9, PeripheryPayments} from \"ERC4626/ERC4626RouterBase.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\n/**\n @title a router which can perform multiple Turbo actions between Master and the Safes\n @notice routes custom users flows between actions on the master and safes.\n\n Extends the ERC4626RouterBase to allow for flexible combinations of actions involving ERC4626 and permit, weth, and Turbo specific actions.\n\n Safe Creation has functions bundled with deposit (and optionally boost) because a newly created Safe address can only be known at runtime. \n The caller is always atomically given the owner role of a new safe.\n\n Authentication requires the caller to be the owner of the Safe to perform any ERC4626 method or TurboSafe requiresAuth method. \n Assumes the Safe's authority gives permission to call these functions to the TurboRouter.\n */\ncontract TurboRouter is ERC4626RouterBase, ENSReverseRecord {\n    using SafeTransferLib for ERC20;\n\n    TurboMaster public immutable master;\n\n    constructor (TurboMaster _master, string memory name, IWETH9 weth) ENSReverseRecord(name) PeripheryPayments(weth) {\n        master = _master;\n    }\n\n    modifier authenticate(address target) {\n        require(msg.sender == Auth(target).owner(), \"NOT_AUTHED\");\n\n        _;\n    }\n\n    function createSafe(ERC20 underlying) external {\n        (TurboSafe safe, ) = master.createSafe(underlying);\n\n        safe.setOwner(msg.sender);\n    }\n\n    function createSafeAndDeposit(ERC20 underlying, address to, uint256 amount, uint256 minSharesOut) external {\n        (TurboSafe safe, ) = master.createSafe(underlying);\n\n        super.deposit(IERC4626(address(safe)), to, amount, minSharesOut);\n\n        safe.setOwner(msg.sender);\n    }\n\n    function createSafeAndDepositAndBoost(\n        ERC20 underlying, \n        address to, \n        uint256 amount, \n        uint256 minSharesOut, \n        ERC4626 boostedVault, \n        uint256 boostedFeiAmount\n    ) public {\n        (TurboSafe safe, ) = master.createSafe(underlying);\n\n        super.deposit(IERC4626(address(safe)), to, amount, minSharesOut);\n\n        safe.boost(boostedVault, boostedFeiAmount);\n\n        safe.setOwner(msg.sender);\n    }\n\n    function deposit(IERC4626 safe, address to, uint256 amount, uint256 minSharesOut) \n        public \n        payable \n        override \n        authenticate(address(safe)) \n        returns (uint256) \n    {\n        return super.deposit(safe, to, amount, minSharesOut);\n    }\n\n    function mint(IERC4626 safe, address to, uint256 shares, uint256 maxAmountIn) \n        public \n        payable \n        override \n        authenticate(address(safe)) \n        returns (uint256) \n    {\n        return super.mint(safe, to, shares, maxAmountIn);\n    }\n\n    function withdraw(IERC4626 safe, address to, uint256 amount, uint256 minSharesOut) \n        public \n        payable \n        override \n        authenticate(address(safe)) \n        returns (uint256) \n    {\n        return super.withdraw(safe, to, amount, minSharesOut);\n    }\n\n    function redeem(IERC4626 safe, address to, uint256 shares, uint256 minAmountOut) \n        public \n        payable \n        override \n        authenticate(address(safe)) \n        returns (uint256) \n    {\n        return super.redeem(safe, to, shares, minAmountOut);\n    }\n\n    function slurp(TurboSafe safe, ERC4626 vault) external authenticate(address(safe)) {\n        safe.slurp(vault);\n    }\n\n    function boost(TurboSafe safe, ERC4626 vault, uint256 feiAmount) public authenticate(address(safe)) {\n        safe.boost(vault, feiAmount);\n    }\n\n    function less(TurboSafe safe, ERC4626 vault, uint256 feiAmount) external authenticate(address(safe)) {\n        safe.less(vault, feiAmount);\n    }\n\n    function sweep(TurboSafe safe, address to, ERC20 token, uint256 amount) external authenticate(address(safe)) {\n        safe.sweep(to, token, amount);\n    }\n\n    function slurpAndLess(TurboSafe safe, ERC4626 vault, uint256 feiAmount) external authenticate(address(safe)) {\n        safe.slurp(vault);\n        safe.less(vault, feiAmount);\n    }\n}\n\n",
        "CodeNames": [
            "TurboRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction deposit(IERC4626 safe, address to, uint256 amount, uint256 minSharesOut) \n    public \n    payable \n    override \n    authenticate(address(safe)) \n    returns (uint256) \n{\n    return super.deposit(safe, to, amount, minSharesOut);\n}\n...\nfunction deposit(\n    IERC4626 vault, \n    address to,\n    uint256 amount,\n    uint256 minSharesOut\n) public payable virtual override returns (uint256 sharesOut) {\n    if ((sharesOut = vault.deposit(amount, to)) < minSharesOut) {\n        revert MinAmountError();\n    }\n}\n",
                    "//solidity\nfunction deposit(uint256 amount, address to) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(amount)) != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    _mint(to, shares);\n\n    emit Deposit(msg.sender, to, amount, shares);\n\n    afterDeposit(amount, shares);\n}\n"
                ],
                "Type": " TurboRouter:  deposit() ,  mint() ,  createSafeAndDeposit()  and  createSafeAndDepositAndBoost()  functions do not work",
                "Description": "\nThe TurboRouter contract inherits from the ERC4626RouterBase contract. When the user calls the deposit, mint, createSafeAndDeposit and createSafeAndDepositAndBoost functions of the TurboRouter contract, the deposit and mint functions of the ERC4626RouterBase contract are called.\nsolidity\nfunction deposit(IERC4626 safe, address to, uint256 amount, uint256 minSharesOut) \n    public \n    payable \n    override \n    authenticate(address(safe)) \n    returns (uint256) \n{\n    return super.deposit(safe, to, amount, minSharesOut);\n}\n...\nfunction deposit(\n    IERC4626 vault, \n    address to,\n    uint256 amount,\n    uint256 minSharesOut\n) public payable virtual override returns (uint256 sharesOut) {\n    if ((sharesOut = vault.deposit(amount, to)) < minSharesOut) {\n        revert MinAmountError();\n    }\n}\n\n\nThe deposit and mint functions of the ERC4626RouterBase contract will call the deposit and mint functions of the TurboSafe contract. The TurboSafe contract inherits from the ERC4626 contract, that is, the deposit and mint functions of the ERC4626 contract will be called.\n\nThe deposit and mint functions of the ERC4626 contract will call the safeTransferFrom function. Since the caller is the TurboRouter contract, msg.sender will be the TurboRouter contract. And because the user calls the deposit, mint, createSafeAndDeposit, and createSafeAndDepositAndBoost functions of the TurboRouter contract without transferring tokens to the TurboRouter contract and approving the TurboSafe contract to use the tokens, the call will fail.\nsolidity\nfunction deposit(uint256 amount, address to) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(amount)) != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    _mint(to, shares);\n\n    emit Deposit(msg.sender, to, amount, shares);\n\n    afterDeposit(amount, shares);\n}\n\n\n\nTurboRouter.sol(https://github.com/code-423n4/2022-02-tribe-turbo/blob/main/src/TurboRouter.sol)\n\n",
                "Repair": "\nIn the deposit, mint, createSafeAndDeposit, and createSafeAndDepositAndBoost functions of the TurboRouter contract, add code for the user to transfer tokens and approve the use of tokens in the TurboSafe contract.\nFor example:\n\nTurboRouter.sol\nsolidity\n+        IERC20(safe.asset).safeTransferFrom(msg.sender,address(this),amount);\n+        IERC20(safe.asset).safeApprove(safe,amount);\n    super.deposit(IERC4626(address(safe)), to, amount, minSharesOut);\n\n...\n\n+        IERC20(safe.asset).safeTransferFrom(msg.sender,address(this),amount);\n+        IERC20(safe.asset).safeApprove(safe,amount);\n    super.mint(safe, to, shares, maxAmountIn);\n\n\nJoeysantoro (Tribe Turbo) disputed and commented(https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/16#issuecomment-1050172199):\n  Router uses Multicall and PeripheryPayments which can be combined to achieve the desired behaviors.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/16#issuecomment-1065915261):\n  @Joeysantoro I don't quite understand your counter argument here for createSafeAnd.... type functions.\n \n For Deposit and Mint, yes, you can create the safe, and then multicall the approvals, I agree with your counter, the functions don't need the extra approve calls.\n \n However for the functions that deploy a new safe, am not quite sure where the approval happens, see createSafeAndDeposit below:\n \n solidity\n     function createSafeAndDeposit(ERC20 underlying, address to, uint256 amount, uint256 minSharesOut) external {\n         (TurboSafe safe, ) = master.createSafe(underlying);\n \n         super.deposit(IERC4626(address(safe)), to, amount, minSharesOut);\n \n         safe.setOwner(msg.sender);\n     }\n \n \n I believe your counter argument could apply if you were deploying new vaults via Create2 so you could deterministically pre-approve the new safe, however in this case you are deploying a new safe, to an unpredictable address and then calling deposit on it. \n deposit will safeTransferFrom from the router to the vault and I can't quite see how this call won't fail since the router never gave allowance to the safe.\n \n Can you please clarify your counter argument for this specific function?\n \n\nJoeysantoro (Tribe Turbo) commented(https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/16#issuecomment-1065927852):\n  I was wrong, this issue is valid.\n\nAlex the Entreprenerd (judge) increased severity to High and commented(https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/16#issuecomment-1066142520):\n  Per the sponsor reply, I believe the finding to be valid. Impact is that the code doesn't work so I believe High Severity to be appropriate.\n \n Mitigation seems to be straightforward.\n\nPlease note: the following additional discussions took place approximately 3 weeks after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.\n\nJoeysantoro (Tribe Turbo) commented(https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/16#issuecomment-1098525075):\n imo this is not high risk because the router is a periphery contract. Its medium at best from a security perspective, but an important find within the context of the correctness of the code.\n \n To clarify, the issue only exists for createSafe... not deposit or mint for the reason I stated.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/16#issuecomment-1100093539):\n @Joeysantoro I think your perspective is valid and perhaps with more context, I would have indeed rated at a lower severity.\n \n My reasoning at the time was that because the code is broken, the severity should be high.\n On the other hand, we can also argue that the impact is minimal, as any call to those functions simply reverts, no safes with \"wrong allowance\" are set, and ultimately the impact is just some wasted gas.\n \n The bug doesn't cause a loss of funds nor bricks the protocol in any meaningful way (because this is just a periphery contract).\n \n I think you're right in your logic, at the time of judging I simply focused on how the code didn't work and thought that was reason to raise the severity\n\n\n\n*\n \n\n"
            }
        ]
    }
]