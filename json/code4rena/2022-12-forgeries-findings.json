[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {OwnableUpgradeable} from \"./ownable/OwnableUpgradeable.sol\";\nimport {IERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2, VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/VRFCoordinatorV2.sol\";\n\nimport {IVRFNFTRandomDraw} from \"./interfaces/IVRFNFTRandomDraw.sol\";\nimport {Version} from \"./utils/Version.sol\";\n\n/// @notice VRFNFTRandom Draw with NFT Tickets\n/// @author @isiain\ncontract VRFNFTRandomDraw is\n    IVRFNFTRandomDraw,\n    VRFConsumerBaseV2,\n    OwnableUpgradeable,\n    Version(1)\n{\n    /// @notice Our callback is just setting a few variables, 200k should be more than enough gas.\n    uint32 immutable callbackGasLimit = 200_000;\n    /// @notice Chainlink request confirmations, left at the default\n    uint16 immutable minimumRequestConfirmations = 3;\n    /// @notice Number of words requested in a drawing\n    uint16 immutable wordsRequested = 1;\n\n    /// @dev 60 seconds in a min, 60 mins in an hour\n    uint256 immutable HOUR_IN_SECONDS = 60 * 60;\n    /// @dev 24 hours in a day 7 days in a week\n    uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7);\n    // @dev about 30 days in a month\n    uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n\n\n    /// @notice Reference to chain-specific coordinator contract\n    VRFCoordinatorV2Interface immutable coordinator;\n\n    /// @notice Settings used for the contract.\n    IVRFNFTRandomDraw.Settings public settings;\n\n    /// @notice Details about the current request to chainlink\n    IVRFNFTRandomDraw.CurrentRequest public request;\n\n    /// @dev Save the coordinator to the contract\n    /// @param _coordinator Address for VRF Coordinator V2 Interface\n    constructor(VRFCoordinatorV2Interface _coordinator)\n        VRFConsumerBaseV2(address(_coordinator))\n        initializer\n    {\n        coordinator = _coordinator;\n    }\n\n    /// @notice Getter for request details, does not include picked tokenID\n    /// @return currentChainlinkRequestId Current Chainlink Request ID\n    /// @return hasChosenRandomNumber If the random number for the drawing has been chosen\n    /// @return drawTimelock block.timestamp when a redraw can be issued\n    function getRequestDetails()\n        external\n        view\n        returns (\n            uint256 currentChainlinkRequestId,\n            bool hasChosenRandomNumber,\n            uint256 drawTimelock\n        )\n    {\n        currentChainlinkRequestId = request.currentChainlinkRequestId;\n        hasChosenRandomNumber = request.hasChosenRandomNumber;\n        drawTimelock = request.drawTimelock;\n    }\n\n    /// @notice Initialize the contract with settings and an admin\n    /// @param admin initial admin user\n    /// @param _settings initial settings for draw\n    function initialize(address admin, Settings memory _settings)\n        public\n        initializer\n    {\n        // Set new settings\n        settings = _settings;\n\n        // Check values in memory:\n        if (_settings.drawBufferTime < HOUR_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n        }\n        if (_settings.drawBufferTime > MONTH_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n        }\n\n        if (_settings.recoverTimelock < block.timestamp + WEEK_IN_SECONDS) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n        }\n        if (\n            _settings.recoverTimelock >\n            block.timestamp + (MONTH_IN_SECONDS * 12)\n        ) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n        }\n\n        // If NFT contract address is not a contract\n        if (_settings.token.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.token);\n        }\n\n        // If drawing token is not a contract\n        if (_settings.drawingToken.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.drawingToken);\n        }\n\n        // Validate token range: end needs to be greater than start\n        // and the size of the range needs to be at least 2 (end is exclusive)\n        if (\n            _settings.drawingTokenEndId < _settings.drawingTokenStartId ||\n            _settings.drawingTokenEndId - _settings.drawingTokenStartId < 2\n        ) {\n            revert DRAWING_TOKEN_RANGE_INVALID();\n        }\n\n        // Setup owner as admin\n        __Ownable_init(admin);\n\n        // Emit initialized event for indexing\n        emit InitializedDraw(msg.sender, settings);\n\n        // Get owner of raffled tokenId and ensure the current owner is the admin\n        try\n            IERC721EnumerableUpgradeable(_settings.token).ownerOf(\n                _settings.tokenId\n            )\n        returns (address nftOwner) {\n            // Check if address is the admin address\n            if (nftOwner != admin) {\n                revert DOES_NOT_OWN_NFT();\n            }\n        } catch {\n            revert TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n        }\n    }\n\n    /// @notice Internal function to request entropy\n    function _requestRoll() internal {\n        // Chainlink request cannot be currently in flight.\n        // Request is cleared in re-roll if conditions are correct.\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // If the number has been drawn and\n        if (\n            request.hasChosenRandomNumber &&\n            // Draw timelock not yet used\n            request.drawTimelock != 0 &&\n            request.drawTimelock > block.timestamp\n        ) {\n            revert STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n        }\n\n        // Setup re-draw timelock\n        request.drawTimelock = block.timestamp + settings.drawBufferTime;\n\n        // Request first random round\n        request.currentChainlinkRequestId = coordinator.requestRandomWords({\n            keyHash: settings.keyHash,\n            subId: settings.subscriptionId,\n            minimumRequestConfirmations: minimumRequestConfirmations,\n            callbackGasLimit: callbackGasLimit,\n            numWords: wordsRequested\n        });\n    }\n\n    /// @notice Call this to start the raffle drawing\n    /// @return chainlink request id\n    function startDraw() external onlyOwner returns (uint256) {\n        // Only can be called on first drawing\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // Emit setup draw user event\n        emit SetupDraw(msg.sender, settings);\n\n        // Request initial roll\n        _requestRoll();\n\n        // Attempt to transfer token into this address\n        try\n            IERC721EnumerableUpgradeable(settings.token).transferFrom(\n                msg.sender,\n                address(this),\n                settings.tokenId\n            )\n        {} catch {\n            revert TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n        }\n\n        // Return the current chainlink request id\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Call this to re-draw the raffle\n    /// @return chainlink request ID\n    /// @dev Only callable by the owner\n    function redraw() external onlyOwner returns (uint256) {\n        if (request.drawTimelock >= block.timestamp) {\n            revert TOO_SOON_TO_REDRAW();\n        }\n\n        // Reset request\n        delete request;\n\n        // Re-roll\n        _requestRoll();\n\n        // Owner of token to raffle needs to be this contract\n        if (\n            IERC721EnumerableUpgradeable(settings.token).ownerOf(\n                settings.tokenId\n            ) != address(this)\n        ) {\n            revert DOES_NOT_OWN_NFT();\n        }\n\n        // Return current chainlink request ID\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Function called by chainlink to resolve random words\n    /// @param _requestId ID of request sent to chainlink VRF\n    /// @param _randomWords List of uint256 words of random entropy\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        // Validate request ID\n        if (_requestId != request.currentChainlinkRequestId) {\n            revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n        }\n\n        // Validate number of words returned\n        // Words requested is an immutable set to 1\n        if (_randomWords.length != wordsRequested) {\n            revert WRONG_LENGTH_FOR_RANDOM_WORDS();\n        }\n\n        // Set request details\n        request.hasChosenRandomNumber = true;\n\n        // Get total token range\n        uint256 tokenRange = settings.drawingTokenEndId -\n            settings.drawingTokenStartId;\n\n        // Store a number from it here (reduce number here to reduce gas usage)\n        // We know there will only be 1 word sent at this point.\n        request.currentChosenTokenId =\n            (_randomWords[0] % tokenRange) +\n            settings.drawingTokenStartId;\n\n        // Emit completed event.\n        emit DiceRollComplete(msg.sender, request);\n    }\n\n    /// @notice Function to determine if the user has won in the current drawing\n    /// @param user address for the user to check if they have won in the current drawing\n    function hasUserWon(address user) public view returns (bool) {\n        if (!request.hasChosenRandomNumber) {\n            revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n        }\n\n        return\n            user ==\n            IERC721EnumerableUpgradeable(settings.drawingToken).ownerOf(\n                request.currentChosenTokenId\n            );\n    }\n\n    /// @notice Function for the winner to call to retrieve their NFT\n    function winnerClaimNFT() external {\n        // Assume (potential) winner calls this fn, cache.\n        address user = msg.sender;\n\n        // Check if this user has indeed won.\n        if (!hasUserWon(user)) {\n            revert USER_HAS_NOT_WON();\n        }\n\n        // Emit a celebratory event\n        emit WinnerSentNFT(\n            user,\n            address(settings.token),\n            settings.tokenId,\n            settings\n        );\n\n        // Transfer token to the winter.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            msg.sender,\n            settings.tokenId\n        );\n    }\n\n    /// @notice Optional last resort admin reclaim nft function\n    /// @dev Only callable by the owner\n    function lastResortTimelockOwnerClaimNFT() external onlyOwner {\n        // If recoverTimelock is not setup, or if not yet occurred\n        if (settings.recoverTimelock > block.timestamp) {\n            // Stop the withdraw\n            revert RECOVERY_IS_NOT_YET_POSSIBLE();\n        }\n\n        // Send event for indexing that the owner reclaimed the NFT\n        emit OwnerReclaimedNFT(owner());\n\n        // Transfer token to the admin/owner.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            owner(),\n            settings.tokenId\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "VRFNFTRandomDraw.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "recoverTimelock",
                    "drawTimelock",
                    "lastResortTimelockOwnerClaimNFT()",
                    "startDraw()",
                    "redraw()"
                ],
                "Type": " Admin does not have to wait to call  lastResortTimelockOwnerClaimNFT() ",
                "Description": "*Submitted by Soosh(https://github.com/code-423n4/2022-12-forgeries-findings/issues/146), also found by dipp(https://github.com/code-423n4/2022-12-forgeries-findings/issues/346), indijanc(https://github.com/code-423n4/2022-12-forgeries-findings/issues/343), maks(https://github.com/code-423n4/2022-12-forgeries-findings/issues/331), jadezti(https://github.com/code-423n4/2022-12-forgeries-findings/issues/329), gz627(https://github.com/code-423n4/2022-12-forgeries-findings/issues/325), sces60107(https://github.com/code-423n4/2022-12-forgeries-findings/issues/300), Zarf(https://github.com/code-423n4/2022-12-forgeries-findings/issues/298), neumo(https://github.com/code-423n4/2022-12-forgeries-findings/issues/288), Ch_301(https://github.com/code-423n4/2022-12-forgeries-findings/issues/284), imare(https://github.com/code-423n4/2022-12-forgeries-findings/issues/282), Trust(https://github.com/code-423n4/2022-12-forgeries-findings/issues/271), btk(https://github.com/code-423n4/2022-12-forgeries-findings/issues/246), kuldeep(https://github.com/code-423n4/2022-12-forgeries-findings/issues/226), bin2chen(https://github.com/code-423n4/2022-12-forgeries-findings/issues/218), immeas(https://github.com/code-423n4/2022-12-forgeries-findings/issues/214), obront(https://github.com/code-423n4/2022-12-forgeries-findings/issues/203), hansfriese(https://github.com/code-423n4/2022-12-forgeries-findings/issues/191), Koolex(https://github.com/code-423n4/2022-12-forgeries-findings/issues/181), Apocalypto(https://github.com/code-423n4/2022-12-forgeries-findings/issues/171), carrotsmuggler(https://github.com/code-423n4/2022-12-forgeries-findings/issues/166), hihen(https://github.com/code-423n4/2022-12-forgeries-findings/issues/154), HE1M(https://github.com/code-423n4/2022-12-forgeries-findings/issues/139), rvierdiiev(https://github.com/code-423n4/2022-12-forgeries-findings/issues/132), SmartSek(https://github.com/code-423n4/2022-12-forgeries-findings/issues/107), 9svR6w(https://github.com/code-423n4/2022-12-forgeries-findings/issues/100), sk8erboy(https://github.com/code-423n4/2022-12-forgeries-findings/issues/85), ladboy233(https://github.com/code-423n4/2022-12-forgeries-findings/issues/76), Titi(https://github.com/code-423n4/2022-12-forgeries-findings/issues/65), dic0de(https://github.com/code-423n4/2022-12-forgeries-findings/issues/46), and csanuragjain(https://github.com/code-423n4/2022-12-forgeries-findings/issues/6)*\n\nOn contest page:\n\"If no users ultimately claim the NFT, the admin specifies a timelock period after which they can retrieve the raffled NFT.\"\n\nLet's assume a recoverTimelock of 1 week.\n\nThe specification suggests that 1 week from the winner not having claimed the NFT. Meaning that the admin should only be able to call lastResortTimelockOwnerClaimNFT() only after <block.timestamp at fulfillRandomWords() + request.drawTimelock + 1 weeks.\n\nSpecification:\n\n             drawTimelock                recoverTimelock\n                 \u2502                              \u2502\n                 \u25bc                              \u25bc\n            \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502    \u2502           1 week             \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u25b2\n            \u2502\n    fulfillRandomWords()\n\n*   The winner should have up to drawTimelock to claim before an admin can call redraw() and pick a new winner.\n*   The winner should have up to recoverTimelock to claim before an admin can call lastResortTimelockOwnerClaimNFT() to cancel the raffle.\n\nBut this is not the case.\n\nrecoverTimelock is set in the initialize(...) function and nowhere else. That means 1 week from initialization, the admin can call lastResortTimelockOwnerClaimNFT(). redraw() also does not update recoverTimelock.\n\nIn fact, startDraw() does not have to be called at the same time as initialize(...). That means that if the draw was started after having been initialized for 1 week, the admin can withdraw at any time after that.\n\n\nProtocol does not work as intended.\n\n",
                "Repair": "\nJust like for drawTimelock, recoverTimelock should also be updated for each dice roll.\n<block.timestamp at fulfillRandomWords() + request.drawTimelock + <recoverBufferTime. Where <recoverBufferTime is essentially the drawBufferTime currently used, but for recoverTimelock.\n\nNote: currently, drawTimelock is updated in the _requestRoll() function. This is \"technically less correct\" as chainlink will take some time before fulfillRandomWords(...) callback. So the timelock is actually set before the winner has been chosen.  This should be insignificant under normal network conditions (Chainlink VRF shouldn't take  1min) but both timelocks should be updated in the same function either _requestRoll() or fulfillRandomWords(...).\n\niainnash (Forgeries) confirmed and commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/146#issuecomment-1358257045):\n  This seems to be a dupe of a previous issue where the timelock is not passed. \n \n Give this timelock is validated from the end of the auction the risk here seems Low.\n\ngzeon (judge) increased severity to High and commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/146#issuecomment-1383516964):\n  #359 (comment)(https://github.com/code-423n4/2022-12-forgeries-findings/discussions/359#discussioncomment-4693679)\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "minimumRequestConfirmations",
                    "_requestRoll",
                    "requestRandomWords()",
                    "startDraw()",
                    "fulfillRandomWords()",
                    "redraw()"
                ],
                "Type": " Draw organizer can rig the draw to favor certain participants such as their own account.",
                "Description": "*Submitted by Trust(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272)*\n\nIn RandomDraw, the host initiates a draw using startDraw() or redraw() if the redraw draw expiry has passed. Actual use of Chainlink oracle is done in _requestRoll:\n\n    request.currentChainlinkRequestId = coordinator.requestRandomWords({\n        keyHash: settings.keyHash,\n        subId: settings.subscriptionId,\n        minimumRequestConfirmations: minimumRequestConfirmations,\n        callbackGasLimit: callbackGasLimit,\n        numWords: wordsRequested\n    });\n\nUse of subscription API is explained well here(https://docs.chain.link/vrf/v2/subscription). Chainlink VRFCoordinatorV2 is called with requestRandomWords() and emits a random request. After minimumRequestConfirmations blocks, an oracle VRF node replies to the coordinator with a provable random, which supplies the random to the requesting contract via fulfillRandomWords()  call. It is important to note the role of subscription ID. This ID maps to the subscription charged for the request, in LINK tokens. In our contract, the raffle host supplies their subscription ID as a parameter. Sufficient balance check of the request ID is not checked(https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L370) at request-time, but rather checked in Chainlink node(https://github.com/smartcontractkit/chainlink/blob/806ee17236ba70926a1f07d1141808b634db48b6/core/services/vrf/listener_v2.go#L346) code as well as on-chain by VRFCoordinator(https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L594) when the request is satisfied. In the scenario where the subscriptionID lacks funds, there will be a period of 24 hours when user can top up the account and random response will be sent(https://docs.chain.link/vrf/v2/subscription):\n\n\"Each subscription must maintain a minimum balance to fund requests from consuming contracts. If your balance is below that minimum, your requests remain pending for up to 24 hours before they expire. After you add sufficient LINK to a subscription, pending requests automatically process as long as they have not expired.\"\n\nThe reason this is extremely interesting is because as soon as redraws are possible, the random response can no longer be treated as fair. Indeed, Draw host can wait until redraw cooldown passed (e.g. 1 hour), and only then fund the subscriptionID. At this point, Chainlink node will send a TX with the random response. If host likes the response (i.e. the draw winner), they will not interfere. If they don't like the response, they can simply frontrun the Chainlink TX with a redraw() call. A redraw will create a new random request and discard the old requestId so the previous request will never be accepted.\n\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        // Validate request ID\n    \t  // <---------------swap currentChainlinkRequestId ---\n        if (_requestId != request.currentChainlinkRequestId) {\n            revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n        }\n    \t...\n    }\n\n<!----\n\n    //<-----redraw swaps currentChainlinkRequestId ---\n    request.currentChainlinkRequestId = coordinator.requestRandomWords({\n        keyHash: settings.keyHash,\n        subId: settings.subscriptionId,\n        minimumRequestConfirmations: minimumRequestConfirmations,\n        callbackGasLimit: callbackGasLimit,\n        numWords: wordsRequested\n    });\n\nChainlink docs warn(https://docs.chain.link/vrf/v2/security) against this usage pattern of the VRF -\"Don\u2019t accept bids/bets/inputs after you have made a randomness request\". In this instance, a low subscription balance allows the host to invalidate the assumption that 1 hour redraw cooldown is enough to guarantee Chainlink answer has been received.\n\n\nDraw organizer can rig the draw to favor certain participants such as their own account.\n\n\nOwner offers a BAYC NFT for holders of their NFT collection X. Out of 10,000 tokenIDs, owner has 5,000 Xs. Rest belongs to retail users.\n\n1.  Owner subscriptionID is left with 0 LINK balance in coordinator\n2.  Redraw time is set to 2 hours\n3.  Owner calls startDraw() which will initiate a Chainlink request\n4.  Owner waits for 2 hours and then tops up their subscriptionID with sufficient LINK\n5.  Owner scans the mempool for fulfillRandomWords()\n6.  If the raffle winner is tokenID < 5000, it is owner's token\n    1.  Let fulfill execute and pick up the reward\n7.  If tokenID = 5000\n    1.  Call redraw()\n    2.  fulfill will revert because of requestId mismatch\n8.  Owner has 75% of claiming the NFT instead of 50%\n\nNote that Forgeries draws are presumably intended as incentives for speculators to buy NFTs from specific collections. Without having a fair shot at receiving rewards from raffles, these NFTs user buys could be worthless. Another way to look at it is that the impact is theft of yield, as host can freely decrease the probability that a token will be chosen for rewards with this method.\n\nAlso, I did not categorize it as centralization risk as the counterparty is not Forgeries but rather some unknown third-party host which offers an NFT incentive program. It is a similar situation to the distinction made between 1st party and 3rd party projects here(https://github.com/code-423n4/2022-10-juicebox-findings/issues/191).\n\n\nChainlink docs(https://docs.chain.link/vrf/v2/subscription)\n\nChainlink co-ordinator code(https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFCoordinatorV2.sol)\n\n",
                "Repair": "\nThe root cause is that Chainlink response can arrive up to 24 hours from the most request is dispatched, while redraw cooldown can be 1 hour+. The best fix would be to enforce minimum cooldown of 24 hours.\n\niainnash (Forgeries) confirmed(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272)\n\ngzeon (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1374550568):\n  This issue weaponized 133(https://github.com/code-423n4/2022-12-forgeries-findings/issues/133) and 194(https://github.com/code-423n4/2022-12-forgeries-findings/issues/194) to violate the fairness requirement of the protocol. Downgrading this to Medium because the \n 1. Difficulty of attack is high; you need to \n a) front-run the fulfillRandomWords call and \n b) own a meaningful % of the collection \n \n 2. Require to use an underfunded subscription\n This will flag the raffle is fishy, since the owner might as well never fund the subscription.\n \n 3. 3rd party can mitigate this by funding the subscription.\n \n There is another case where the chainlink node waits almost 24 hours before fulfilling the request, but I don't think that is the normal behavior and is out of the attacker's control.\n\nTrust (warden) commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376205733):\n  Would like to respectfully state my case and why this finding is clearly HIGH impact. \n Manipulation of RNG is an extremely serious impact as it undermines assumption of fairness which is the main selling point of raffles, lotteries etc. As proof one can view Chainlink's (https://immunefi.com/bounty/chainlink/) BBP which lists \"Predictable or manipulable RNG that results in abuse of downstream services\" as a critical impact, payable up to $3M.\n \n I would like to relate to the conditions stated by the judge:\n  1. Difficulty of attack is high; you need to\n     a) front-run the fulfillRandomWords call and\n     b) own a meaningful % of the collection\n \n frontrunning is done in practically every block by MEV bots proving it's practical and easy to do on mainnet, where the protocol is deployed. Owning a meaningful % of the collection is not necessary, as:\n 1. Even with 1 / 10,000 NFTs, owner is still multiplying their chances which is a breach of fair random.\n 2. The exploit can be repeated in every single raffle, exponentially multiplying their edge across time. This also highlights that the frontrunning does not have to be work every time (even though it's high %) in order for the exploitation to work.\n 3. The draw is chosen by ownership of _settings.drawingToken, which is a project-provided token which is already likely they have a large amount of. It is unrelated to the BAYC collection / high value NFT being given out.\n 4. It is easy to see attacker can easily half the chances of any unwanted recipient to win the raffle they would have to have the winning ticket in both rounds. Putting the subscriber's boosted win chances aside, it's a clear theft of user's potential high value prize.\n \n  * Require to use an underfunded subscription\n    This will flag the raffle is fishy, since the owner might as well never fund the subscription.\n  * 3rd party can mitigate this by funding the subscription\n \n It is unrealistic to expect users of the protocol to be savvy on-chain detectives and also anticipate this specific attack vector. Even so, the topping-up of the subscription is done directly subscriber - ChainlinkVRFCoordinator, so it's not visible by looking at the raffle contract. \n \n To summarize, the characteristics of this finding are much more aligned to those of High severity, than those of Medium severity.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376267492):\n The difficulty arises when only the raffle creator can perform the front running, not any interested MEV searcher. For sure, this is only 1 of the reason I think the risk of this issue is not High.\n\n As the project seems to be fine with a raffle being created, but never actually started; I think when the attack require a chainlink subscription to be underfunded to begin with also kinda fall in to the \"creator decided not to start raffle\" category.\n\n The argument of judging this apart from that is the raffle would looks like it completed but might not be fair, which I think is a very valid issue. However, I don't see this as High risk given the relative difficulty as said and we seems to agree that it is fine if the raffle creator decided not to start the raffle. The end state would basically be the same.\n\nTrust (warden) commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376282150):\n  The end states are in my opinion very different. In order to understand the full impact of the vulnerability we need to understand the context in which those raffles take place. The drawing tokens are shilled to give users a chance to win a high valued item. Their worth is correlated to the fair chance users think they have in winning the raffle. The \"fake raffle\" on display allows the attacker to keep profiting from ticket sales while not giving away high value. I think this is why \n @iainnash agreed this to be a high risk find. \n \n I've also listed several other justifications including theft of user's chances of winning which is high impact. I'd be happy to provide additional proof of why frontrunning is easily high enough % if that is the source of difficulty observed.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376307513):\n   The drawing tokens are shilled to give users a chance to win a high valued item. Their worth is correlated to the fair chance users think they have in winning the raffle. \n\n That's my original thought, but you and the sponsor tried to convince me the raffle is permissioned by design considering startDraw. \n\nIf we think we need to guarantee the raffle token can get something fairly, we will also need to guarantee the raffle will, well, start. So I would say these are very similar since the ticket would be already sold anyway.\n\nI think I might either keep everything as-is, or I am going to reinstate those other issues that I invalidated due to assuming the permissioned design, and upgrading this to High. Would love to hear more from the sponsor before making the final call.\n\nTrust (warden) commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1379859299):\n Regarding your smart observation @gzeon , I think the idea is clearly to make the draw methods decentralized in the future, but owner controlled as a first step. However they were not aware of this exploit, which from day 1 allows to put on a show and drive draw token prices up.\n\ngzeon (judge) increased severity to High and commented(https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1383501062):\n  #359 (comment)(https://github.com/code-423n4/2022-12-forgeries-findings/discussions/359#discussioncomment-4693679)\n\n\n*\n\n \n\n"
            }
        ]
    }
]