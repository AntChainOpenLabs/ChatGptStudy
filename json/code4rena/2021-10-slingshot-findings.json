[
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity 0.8.7;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interface/SlingshotI.sol\";\nimport \"./interface/IWrappedNATIVE.sol\";\nimport \"./Adminable.sol\";\nimport \"./ModuleRegistry.sol\";\nimport \"./ApprovalHandler.sol\";\nimport \"./Executioner.sol\";\n\n/// @title   Slingshot Trading Contract\n/// @author  DEXAG, Inc.\n/// @notice  This contract serves as the entrypoint for executing\n///          a Slingshot transaction on-chain.\n/// @dev     The specific logic for each DEX/AMM is defined within its\n///          own corresponding module that is stored in the module registry.\n///          Slingshot.sol references these modules to appropriately execute a trade.\n///          Slingshot.sol also performs some safety checks to account for slippage\n///          and security. Slingshot.sol depends on the Slingshot backend to provide\n///          the details of how a given transaction will be executed within a\n///          particular market.\ncontract Slingshot is SlingshotI, Adminable, ConcatStrings, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWrappedNATIVE;\n\n    /// @dev address of native token, if you are trading ETH on Ethereum,\n    ///      matic on Matic etc you should use this address as token from\n    address public immutable nativeToken;\n    /// @dev address of wrapped native token, for Ethereum it's WETH, for Matic is wmatic etc\n    IWrappedNATIVE public immutable wrappedNativeToken;\n    Executioner public immutable executioner;\n\n    ModuleRegistry public moduleRegistry;\n    ApprovalHandler public approvalHandler;\n\n    event Trade(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address indexed recipient\n    );\n    event NewModuleRegistry(address oldRegistry, address newRegistry);\n    event NewApprovalHandler(address oldApprovalHandler, address approvalHandler);\n\n    constructor (address _admin, address _nativeToken, address _wrappedNativeToken) {\n        executioner = new Executioner(_nativeToken, _wrappedNativeToken);\n        _setupAdmin(_admin);\n        nativeToken = _nativeToken;\n        wrappedNativeToken = IWrappedNATIVE(_wrappedNativeToken);\n    }\n\n    /// @notice Executes multi-hop trades to get the best result\n    ///         It's up to BE to whitelist tokens\n    /// @param fromToken Start token address\n    /// @param toToken Target token address\n    /// @param fromAmount The initial amount of fromToken to start trading with\n    /// @param trades Array of encoded trades that are atomically executed\n    /// @param finalAmountMin The minimum expected output after all trades have been executed\n    /// @param depricated to be removed\n    function executeTrades(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        TradeFormat[] calldata trades,\n        uint256 finalAmountMin,\n        address depricated\n    ) external nonReentrant payable {\n        depricated;\n        require(finalAmountMin > 0, \"Slingshot: finalAmountMin cannot be zero\");\n        require(trades.length > 0, \"Slingshot: trades cannot be empty\");\n        for(uint256 i = 0; i < trades.length; i++) {\n            // Checks to make sure that module exists and is correct\n            require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\");\n        }\n\n        uint256 initialBalance = _getTokenBalance(toToken);\n        _transferFromOrWrap(fromToken, _msgSender(), fromAmount);\n\n        executioner.executeTrades(trades);\n\n        uint finalBalance;\n        if (toToken == nativeToken) {\n            finalBalance = _getTokenBalance(address(wrappedNativeToken));\n        } else {\n            finalBalance = _getTokenBalance(toToken);\n        }\n        uint finalOutputAmount = finalBalance - initialBalance;\n        require(finalOutputAmount >= finalAmountMin, \"Slingshot: result is lower than required min\");\n\n        emit Trade(fromToken, toToken, fromAmount, finalOutputAmount, _msgSender());\n\n        // Send to msg.sender.\n        executioner.sendFunds(toToken, _msgSender(), finalOutputAmount);\n    }\n\n    /// @notice Sets ApprovalHandler that is used to transfer token from users\n    /// @param _approvalHandler The address of ApprovalHandler\n    function setApprovalHandler(address _approvalHandler) external onlyAdmin {\n        emit NewApprovalHandler(address(approvalHandler), _approvalHandler);\n        approvalHandler = ApprovalHandler(_approvalHandler);\n    }\n\n    /// @notice Sets module registry used to verify modules\n    /// @param _moduleRegistry The address of module registry\n    function setModuleRegistry(address _moduleRegistry) external onlyAdmin {\n        address oldRegistry = address(moduleRegistry);\n        moduleRegistry = ModuleRegistry(_moduleRegistry);\n        emit NewModuleRegistry(oldRegistry, _moduleRegistry);\n    }\n\n    /// @notice In an unlikely scenario of tokens being send to this contract\n    ///         allow admin to rescue them.\n    /// @param token The address of the token to rescue\n    /// @param to The address of recipient\n    /// @param amount The amount of the token to rescue\n    function rescueTokens(address token, address to, uint256 amount) external onlyAdmin {\n        if (token == nativeToken) {\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"Slingshot: ETH rescue failed.\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    /// @notice In an unlikely scenario of tokens being send to this contract\n    ///         allow admin to rescue them.\n    /// @param token The address of the token to rescue\n    /// @param to The address of recipient\n    /// @param amount The amount of the token to rescue\n    function rescueTokensFromExecutioner(address token, address to, uint256 amount) external onlyAdmin {\n        executioner.rescueTokens(token, to, amount);\n    }\n\n    /// @notice Transfer tokens from sender to this contract or wraps ETH\n    /// @param fromToken The address of the token\n    /// @param from The address of sender that provides token\n    /// @param amount The amount of the token to transfer\n    function _transferFromOrWrap(address fromToken, address from, uint256 amount) internal {\n        // transfer tokens or wrap ETH\n        if (fromToken == nativeToken) {\n            require(msg.value == amount, \"Slingshot: incorrect ETH value\");\n            wrappedNativeToken.deposit{value: amount}();\n            wrappedNativeToken.safeTransfer(address(executioner), amount);\n        } else {\n            approvalHandler.transferFrom(fromToken, from, address(executioner), amount);\n        }\n    }\n\n    /// @notice Returns balance of the token\n    /// @param token The address of the token\n    /// @return balance of the token (ERC20 and native)\n    function _getTokenBalance(address token) internal view returns (uint256) {\n        if (token == nativeToken) {\n            return address(executioner).balance;\n        } else {\n            return IERC20(token).balanceOf(address(executioner));\n        }\n    }\n\n    /// @notice Sends token funds. For native token, it unwraps wrappedNativeToken\n    /// @param token The address of the token to send\n    /// @param to The address of recipient\n    /// @param amount The amount of the token to send\n    function _sendFunds(address token, address to, uint256 amount) internal {\n        executioner.sendFunds(token, to, amount);\n        if (token == nativeToken) {\n            wrappedNativeToken.withdraw(amount);\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"Slingshot: ETH Transfer failed.\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity 0.8.7;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interface/SlingshotI.sol\";\nimport \"./interface/IWrappedNATIVE.sol\";\nimport \"./lib/ConcatStrings.sol\";\n\n/// @title   Slingshot Execution Contract\n/// @author  DEXAG, Inc.\n/// @notice  This contract serves as the isolated execution space for trading contract\n///          a Slingshot transaction on-chain.\ncontract Executioner is SlingshotI, Ownable, ConcatStrings {\n    using SafeERC20 for IERC20;\n\n    /// @dev address of native token, if you are trading ETH on Ethereum,\n    ///      matic on Matic etc you should use this address as token from\n    address public immutable nativeToken;\n    /// @dev address of wrapped native token, for Ethereum it's WETH, for Matic is wmatic etc\n    IWrappedNATIVE public immutable wrappedNativeToken;\n\n    constructor (address _nativeToken, address _wrappedNativeToken) {\n        nativeToken = _nativeToken;\n        wrappedNativeToken = IWrappedNATIVE(_wrappedNativeToken);\n    }\n\n    /// @notice Executes multi-hop trades to get the best result\n    ///         It's up to BE to whitelist tokens\n    /// @param trades Array of encoded trades that are atomically executed\n    function executeTrades(TradeFormat[] calldata trades) external onlyOwner {\n        for(uint256 i = 0; i < trades.length; i++) {\n            // delegatecall message is made on module contract, which is trusted\n            (bool success, bytes memory data) = trades[i].moduleAddress.delegatecall(trades[i].encodedCalldata);\n\n            require(success, appendString(string(data), appendUint(string(\"Executioner: swap failed: \"), i)));\n        }\n    }\n\n    /// @notice In an unlikely scenario of tokens being send to this contract\n    ///         allow admin to rescue them.\n    /// @param token The address of the token to rescue\n    /// @param to The address of recipient\n    /// @param amount The amount of the token to rescue\n    function rescueTokens(address token, address to, uint256 amount) external onlyOwner {\n        if (token == nativeToken) {\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"Executioner: ETH rescue failed.\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    /// @notice Sends token funds. For native token, it unwraps wrappedNativeToken\n    /// @param token The address of the token to send\n    /// @param to The address of recipient\n    /// @param amount The amount of the token to send\n    function sendFunds(address token, address to, uint256 amount) external onlyOwner {\n        if (token == nativeToken) {\n            wrappedNativeToken.withdraw(amount);\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"Executioner: ETH Transfer failed.\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "Slingshot.sol",
            "Executioner.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction executeTrades(\n    address fromToken,\n    address toToken,\n    uint256 fromAmount,\n    TradeFormat[] calldata trades,\n    uint256 finalAmountMin,\n    address depricated\n) external nonReentrant payable {\n    depricated;\n    require(finalAmountMin  0, \"Slingshot: finalAmountMin cannot be zero\");\n    require(trades.length  0, \"Slingshot: trades cannot be empty\");\n    for(uint256 i = 0; i < trades.length; i++) {\n        // Checks to make sure that module exists and is correct\n        require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\");\n    }\n\n    uint256 initialBalance = _getTokenBalance(toToken);\n    _transferFromOrWrap(fromToken, _msgSender(), fromAmount);\n\n    executioner.executeTrades(trades);\n\n    uint finalBalance;\n    if (toToken == nativeToken) {\n        finalBalance = _getTokenBalance(address(wrappedNativeToken));\n    } else {\n        finalBalance = _getTokenBalance(toToken);\n    }\n    uint finalOutputAmount = finalBalance initialBalance;\n    ...\n",
                    "//solidity\nfunction _getTokenBalance(address token) internal view returns (uint256) {\n    if (token == nativeToken) {\n        return address(executioner).balance;\n    } else {\n        return IERC20(token).balanceOf(address(executioner));\n    }\n}\n"
                ],
                "Type": "  initialBalance  for native token is wrong",
                "Description": "\n<https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L65-L92\n\nsolidity\nfunction executeTrades(\n    address fromToken,\n    address toToken,\n    uint256 fromAmount,\n    TradeFormat[] calldata trades,\n    uint256 finalAmountMin,\n    address depricated\n) external nonReentrant payable {\n    depricated;\n    require(finalAmountMin  0, \"Slingshot: finalAmountMin cannot be zero\");\n    require(trades.length  0, \"Slingshot: trades cannot be empty\");\n    for(uint256 i = 0; i < trades.length; i++) {\n        // Checks to make sure that module exists and is correct\n        require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\");\n    }\n\n    uint256 initialBalance = _getTokenBalance(toToken);\n    _transferFromOrWrap(fromToken, _msgSender(), fromAmount);\n\n    executioner.executeTrades(trades);\n\n    uint finalBalance;\n    if (toToken == nativeToken) {\n        finalBalance = _getTokenBalance(address(wrappedNativeToken));\n    } else {\n        finalBalance = _getTokenBalance(toToken);\n    }\n    uint finalOutputAmount = finalBalance initialBalance;\n    ...\n\n\n<https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L157-L163\n\nsolidity\nfunction _getTokenBalance(address token) internal view returns (uint256) {\n    if (token == nativeToken) {\n        return address(executioner).balance;\n    } else {\n        return IERC20(token).balanceOf(address(executioner));\n    }\n}\n\n\nWhen users swap to native token (ETH), the initialBalance should use the balance of wrappedNativeToken instead of native token balance, because finalBalance is the balance of wrappedNativeToken.\n\nIn the current implementation, when the toToken is the native token, initialBalance will be the ether balance of executioner contract. Therefore, when the ether balance of executioner is not 0, finalOutputAmount will be wrong.\n\nThe attacker can transfer a certain amount of ETH to the executioner contract and malfunction the protocol. Causing fund loss to users because finalOutputAmount is lower than the actual swapped amount, or DoS due to finalAmountMin cant be met.\n\n\nGiven:\n\n*   The attacker send 0.25 ETH to the executioner contract;\n*   The price of ETH in USDC is: 4000\n\n1.  Alice swaps 5000 USDC to 1.25 ETH with finalAmountMin set to 1 ETH;\n2.  Alice will get 1 ETH out and lose 0.25 ETH;\n3.  Bob swaps 1000 USDC to 0.25 ETH with finalAmountMin set to 1 wei;\n4.  Bob's transaction fails due to finalAmountMin cant being met.\n\n",
                "Repair": "\nConsider updating _getTokenBalance() and return IERC20(wrappedNativeToken).balanceOf(address(executioner)); when token == nativeToken.\n\ntommyz7 (Slingshot) disagreed with severity(https://github.com/code-423n4/2021-10-slingshot-findings/issues/59#issuecomment-959279936):\n  \"Alice swaps 5000 USDC to 1.25 ETH with finalAmountMin set to 1 ETH;\" this assumption is wrong because it's based on huge slippage assumption. There is no way a Slingshot transaction accepts 20% slippage so funds loss scenario is incorrect.\n \n duplicate of #18, medium risk since no user funds are at risk.\n\n\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "finalAmountMin",
                    "finalOutputAmount",
                    "executeTrades"
                ],
                "Type": " Trades where toToken is feeOnTransferToken might send user less tokens than finalAmountMin",
                "Description": "\nSlingshot's executeTrades checks that the trade result amount (to be sent to the user) is bigger than finalAmountMin, and *after that* sends the user the amount. But if the token charges fee on transfer, the final transfer to the user will decrease the amount the user is getting, maybe below finalAmountMin.\n\n\nSlingshot requires finalOutputAmount = finalAmountMin *before* sending the funds to the user:\n<https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L93:#L98\nSo if the token charges fees on transfer, the user will get less tokens than finalOutputAmount . The check of finalOutputAmount against finalAmountMin is premature.\n\n\nManual analysis\n\n",
                "Repair": "\nSave the user's (not Executioner's) toToken balance in the beginning of executeTrades after _transferFromOrWrap(fromToken, _msgSender(), fromAmount), and also in the very end, after executioner.sendFunds(toToken, _msgSender(), finalOutputAmount) has been called. The subtraction of user's initial balance from ending balance should be bigger than finalAmountMin.\n<https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L65:#L99\n\ntommyz7 (Slingshot) disagreed with severity(https://github.com/code-423n4/2021-10-slingshot-findings/issues/77#issuecomment-959385967):\n  Slingshot concern is to execute the trade as promised and make sure we are sending to the user what has been promised in trade estimation. If the token adds additional taxation on transfer, it is on the user side and users understand and accept this. We have seen this play out on production for the previous version of the contracts and we decided not to make that check. It seems the most practical decision.\n \n Personally, I think this is non-critical.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-10-slingshot-findings/issues/77#issuecomment-962400182):\n  The severity for the issue is right. The sponsor should add documentation to the fact that some tokens might not conform to common expectations.\n\n\n"
            }
        ]
    }
]