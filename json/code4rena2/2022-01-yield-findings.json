[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"./ConvexStakingWrapper.sol\";\n\n/// @title Convex staking wrapper for Yield platform\n/// @notice Enables use of convex LP positions as collateral while still receiving rewards\ncontract ConvexYieldWrapper is ConvexStakingWrapper {\n    using TransferHelper for IERC20;\n\n    /// @notice Mapping to keep track of the user & their vaults\n    mapping(address => bytes12[]) public vaults;\n\n    ICauldron public cauldron;\n\n    /// @notice Event called when a vault is added for a user\n    /// @param account The account for which vault is added\n    /// @param vaultId The vaultId to be added\n    event VaultAdded(address indexed account, bytes12 indexed vaultId);\n\n    /// @notice Event called when a vault is removed for a user\n    /// @param account The account for which vault is removed\n    /// @param vaultId The vaultId to be removed\n    event VaultRemoved(address indexed account, bytes12 indexed vaultId);\n\n    /// @notice Event called when tokens are rescued from the contract\n    /// @param token Address of the token being rescued\n    /// @param amount Amount of the token being rescued\n    /// @param destination Address to which the rescued tokens have been sent\n    event Recovered(address indexed token, uint256 amount, address indexed destination);\n\n    constructor(\n        address curveToken_,\n        address convexToken_,\n        address convexPool_,\n        uint256 poolId_,\n        address join_,\n        ICauldron cauldron_,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ConvexStakingWrapper(curveToken_, convexToken_, convexPool_, poolId_, join_, name, symbol, decimals) {\n        cauldron = cauldron_;\n    }\n\n    /// @notice Points the collateral vault to the join storing the wrappedConvex\n    /// @param join_ Join which will store the wrappedConvex of the user\n    function point(address join_) external auth {\n        collateralVault = join_;\n    }\n\n    /// @notice Adds a vault to the user's vault list\n    /// @param vaultId The id of the vault being added\n    function addVault(bytes12 vaultId) external {\n        address account = cauldron.vaults(vaultId).owner;\n        require(account != address(0), \"No owner for the vault\");\n        bytes12[] storage vaults_ = vaults[account];\n        uint256 vaultsLength = vaults_.length;\n\n        for (uint256 i = 0; i < vaultsLength; i++) {\n            require(vaults_[i] != vaultId, \"Vault already added\");\n        }\n        vaults_.push(vaultId);\n        vaults[account] = vaults_;\n        emit VaultAdded(account, vaultId);\n    }\n\n    /// @notice Remove a vault from the user's vault list\n    /// @param vaultId The id of the vault being removed\n    /// @param account The user from whom the vault needs to be removed\n    function removeVault(bytes12 vaultId, address account) public {\n        address owner = cauldron.vaults(vaultId).owner;\n        if (account != owner) {\n            bytes12[] storage vaults_ = vaults[account];\n            uint256 vaultsLength = vaults_.length;\n            bool found;\n            for (uint256 i = 0; i < vaultsLength; i++) {\n                if (vaults_[i] == vaultId) {\n                    bool isLast = i == vaultsLength - 1;\n                    if (!isLast) {\n                        vaults_[i] = vaults_[vaultsLength - 1];\n                    }\n                    vaults_.pop();\n                    found = true;\n                    emit VaultRemoved(account, vaultId);\n                    break;\n                }\n            }\n            require(found, \"Vault not found\");\n            vaults[account] = vaults_;\n        }\n    }\n\n    /// @notice Get user's balance of collateral deposited in various vaults\n    /// @param account_ User's address for which balance is requested\n    /// @return User's balance of collateral\n    function _getDepositedBalance(address account_) internal view override returns (uint256) {\n        if (account_ == address(0) || account_ == collateralVault) {\n            return 0;\n        }\n\n        bytes12[] memory userVault = vaults[account_];\n\n        //add up all balances of all vaults registered in the wrapper and owned by the account\n        uint256 collateral;\n        DataTypes.Balances memory balance;\n        uint256 userVaultLength = userVault.length;\n        for (uint256 i = 0; i < userVaultLength; i++) {\n            if (cauldron.vaults(userVault[i]).owner == account_) {\n                balance = cauldron.balances(userVault[i]);\n                collateral = collateral + balance.ink;\n            }\n        }\n\n        //add to balance of this token\n        return _balanceOf[account_] + collateral;\n    }\n\n    /// @dev Wrap convex token held by this contract and forward it to the `to` address\n    /// @param to_ Address to send the wrapped token to\n    /// @param from_ Address of the user whose token is being wrapped\n    function wrap(address to_, address from_) external {\n        require(!isShutdown, \"shutdown\");\n        uint256 amount_ = IERC20(convexToken).balanceOf(address(this));\n        require(amount_ > 0, \"No convex token to wrap\");\n\n        _checkpoint([address(0), from_]);\n        _mint(to_, amount_);\n        IRewardStaking(convexPool).stake(amount_);\n\n        emit Deposited(msg.sender, to_, amount_, false);\n    }\n\n    /// @dev Unwrap Wrapped convex token held by this contract, and send the unwrapped convex token to the `to` address\n    /// @param to_ Address to send the unwrapped convex token to\n    function unwrap(address to_) external {\n        require(!isShutdown, \"shutdown\");\n        uint256 amount_ = _balanceOf[address(this)];\n        require(amount_ > 0, \"No wrapped convex token\");\n\n        _checkpoint([address(0), to_]);\n        _burn(address(this), amount_);\n        IRewardStaking(convexPool).withdraw(amount_, false);\n        IERC20(convexToken).safeTransfer(to_, amount_);\n\n        emit Withdrawn(to_, amount_, false);\n    }\n\n    /// @notice A simple function to recover any ERC20 tokens\n    /// @param token_ Address of the token being rescued\n    /// @param amount_ Amount of the token being rescued\n    /// @param destination_ Address to which the rescued tokens have been sent\n    function recoverERC20(\n        address token_,\n        uint256 amount_,\n        address destination_\n    ) external auth {\n        require(amount_ != 0, \"amount is 0\");\n        IERC20(token_).safeTransfer(destination_, amount_);\n        emit Recovered(token_, amount_, destination_);\n    }\n\n    /// @notice A function to shutdown the contract & withdraw the staked convex tokens & transfer rewards\n    /// @param rescueAddress_ Address to which the rescued tokens would be sent to\n    function shutdownAndRescue(address rescueAddress_) external auth {\n        uint256 balance_ = IRewardStaking(convexPool).balanceOf(address(this));\n\n        if (balance_ != 0) {\n            // Withdraw the convex tokens from the convex pool\n            IRewardStaking(convexPool).withdraw(balance_, true);\n\n            // Transfer the withdrawn convex tokens to rescue address\n            IERC20(convexToken).safeTransfer(rescueAddress_, balance_);\n        }\n        // Shutdown the contract\n        isShutdown = true;\n    }\n}\n\n\n",
        "CodeNames": [
            "ConvexYieldWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ConvexYieldWrapper.sol",
                "Type": "Malicious token duplication",
                "Description": "It is possible to transfer wCVX tokens to another account after an initial checkpoint has been made, allowing a user to replicate their deposited balance over any number of accounts.",
                "Repair": "Implement the _beforeTokenTransfer() function and exclude wrapper contract and collateral vaults from checkpointing"
            },
            {
                "Location": "ConvexYieldWrapper.sol",
                "Type": "Checkpoint Manipulation",
                "Description": "A user is able to generate protocol yield multiple times over on a single collateral amount by manipulating the result of the _getDepositedBalance() function through checkpoint manipulation.",
                "Repair": "Ensure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// Original contract: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/ERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\";\nimport \"./interfaces/IRewardStaking.sol\";\nimport \"./interfaces/IConvexDeposits.sol\";\nimport \"./interfaces/ICvx.sol\";\nimport \"./CvxMining.sol\";\n\n/// @notice Wrapper used to manage staking of Convex tokens\ncontract ConvexStakingWrapper is ERC20, AccessControl {\n    using TransferHelper for IERC20;\n\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n\n    struct RewardType {\n        address reward_token;\n        address reward_pool;\n        uint128 reward_integral;\n        uint128 reward_remaining;\n        mapping(address => uint256) reward_integral_for;\n        mapping(address => uint256) claimable_reward;\n    }\n\n    uint256 public cvx_reward_integral;\n    uint256 public cvx_reward_remaining;\n    mapping(address => uint256) public cvx_reward_integral_for;\n    mapping(address => uint256) public cvx_claimable_reward;\n\n    //constants/immutables\n    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public curveToken;\n    address public convexToken;\n    address public convexPool;\n    address public collateralVault;\n    uint256 public convexPoolId;\n\n    //rewards\n    RewardType[] public rewards;\n\n    //management\n    bool public isShutdown;\n    bool private _status;\n\n    bool private constant _NOT_ENTERED = false;\n    bool private constant _ENTERED = true;\n\n    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);\n\n    constructor(\n        address _curveToken,\n        address _convexToken,\n        address _convexPool,\n        uint256 _poolId,\n        address _vault,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20(name, symbol, decimals) {\n        curveToken = _curveToken;\n        convexToken = _convexToken;\n        convexPool = _convexPool;\n        convexPoolId = _poolId;\n        collateralVault = _vault;\n\n        //add rewards\n        addRewards();\n        setApprovals();\n    }\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /// @notice Give maximum approval to the pool & convex booster contract to transfer funds from wrapper\n    function setApprovals() public {\n        IERC20(curveToken).approve(convexBooster, 0);\n        IERC20(curveToken).approve(convexBooster, type(uint256).max);\n        IERC20(convexToken).approve(convexPool, type(uint256).max);\n    }\n\n    /// @notice Adds reward tokens by reading the available rewards from the RewardStaking pool\n    /// @dev CRV token is added as a reward by default\n    function addRewards() public {\n        address mainPool = convexPool;\n\n        uint256 rewardsLength = rewards.length;\n\n        if (rewardsLength == 0) {\n            RewardType storage reward = rewards.push();\n            reward.reward_token = crv;\n            reward.reward_pool = mainPool;\n            rewardsLength += 1;\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        uint256 startIndex = rewardsLength - 1;\n        for (uint256 i = startIndex; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            RewardType storage reward = rewards.push();\n            reward.reward_token = IRewardStaking(extraPool).rewardToken();\n            reward.reward_pool = extraPool;\n        }\n    }\n\n    /// @notice Returns the length of the reward tokens added\n    /// @return The count of reward tokens\n    function rewardLength() external view returns (uint256) {\n        return rewards.length;\n    }\n\n    /// @notice Get user's balance\n    /// @param _account User's address for which balance is requested\n    /// @return User's balance of collateral\n    /// @dev Included here to allow inheriting contracts to override.\n    function _getDepositedBalance(address _account) internal view virtual returns (uint256) {\n        if (_account == address(0) || _account == collateralVault) {\n            return 0;\n        }\n        //get balance from collateralVault\n\n        return _balanceOf[_account];\n    }\n\n    /// @notice TotalSupply of wrapped token\n    /// @return The total supply of wrapped token\n    /// @dev This function is provided and marked virtual as convenience to future development\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Calculates & upgrades the integral for distributing the CVX rewards\n    /// @param _accounts Accounts for which the CvxIntegral has to be calculated\n    /// @param _balances Balances of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcCvxIntegral(\n        address[2] memory _accounts,\n        uint256[2] memory _balances,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        uint256 bal = IERC20(cvx).balanceOf(address(this));\n        uint256 cvxRewardRemaining = cvx_reward_remaining;\n        uint256 d_cvxreward = bal - cvxRewardRemaining;\n        uint256 cvxRewardIntegral = cvx_reward_integral;\n\n        if (_supply > 0 && d_cvxreward > 0) {\n            cvxRewardIntegral = cvxRewardIntegral + (d_cvxreward * 1e20) / (_supply);\n            cvx_reward_integral = cvxRewardIntegral;\n        }\n\n        //update user integrals for cvx\n        uint256 accountsLength = _accounts.length;\n        for (uint256 u = 0; u < accountsLength; u++) {\n            //do not give rewards to address 0\n            if (_accounts[u] == address(0)) continue;\n            if (_accounts[u] == collateralVault) continue;\n\n            uint256 userI = cvx_reward_integral_for[_accounts[u]];\n            if (_isClaim || userI < cvxRewardIntegral) {\n                uint256 receiveable = cvx_claimable_reward[_accounts[u]] +\n                    ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);\n                if (_isClaim) {\n                    if (receiveable > 0) {\n                        cvx_claimable_reward[_accounts[u]] = 0;\n                        IERC20(cvx).safeTransfer(_accounts[u], receiveable);\n                        bal = bal - (receiveable);\n                    }\n                } else {\n                    cvx_claimable_reward[_accounts[u]] = receiveable;\n                }\n                cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral;\n            }\n        }\n\n        //update reward total\n        if (bal != cvxRewardRemaining) {\n            cvx_reward_remaining = bal;\n        }\n    }\n\n    /// @notice Calculates & upgrades the integral for distributing the reward token\n    /// @param _index The index of the reward token for which the calculations are to be done\n    /// @param _accounts Accounts for which the CvxIntegral has to be calculated\n    /// @param _balances Balances of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcRewardIntegral(\n        uint256 _index,\n        address[2] memory _accounts,\n        uint256[2] memory _balances,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        RewardType storage reward = rewards[_index];\n\n        uint256 rewardIntegral = reward.reward_integral;\n        uint256 rewardRemaining = reward.reward_remaining;\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n        if (_supply > 0 && (bal - rewardRemaining) > 0) {\n            rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);\n            reward.reward_integral = uint128(rewardIntegral);\n        }\n        //update user integrals\n        uint256 accountsLength = _accounts.length;\n        for (uint256 u = 0; u < accountsLength; u++) {\n            //do not give rewards to address 0\n            if (_accounts[u] == address(0)) continue;\n            if (_accounts[u] == collateralVault) continue;\n\n            uint256 userI = reward.reward_integral_for[_accounts[u]];\n            if (_isClaim || userI < rewardIntegral) {\n                if (_isClaim) {\n                    uint256 receiveable = reward.claimable_reward[_accounts[u]] +\n                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);\n                    if (receiveable > 0) {\n                        reward.claimable_reward[_accounts[u]] = 0;\n                        IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);\n                        bal = bal - receiveable;\n                    }\n                } else {\n                    reward.claimable_reward[_accounts[u]] =\n                        reward.claimable_reward[_accounts[u]] +\n                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);\n                }\n                reward.reward_integral_for[_accounts[u]] = rewardIntegral;\n            }\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != rewardRemaining) {\n            reward.reward_remaining = uint128(bal);\n        }\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function _checkpoint(address[2] memory _accounts) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (isShutdown) return;\n\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]);\n        depositedBalance[1] = _getDepositedBalance(_accounts[1]);\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);\n        }\n        _calcCvxIntegral(_accounts, depositedBalance, supply, false);\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them & claims the rewards\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function _checkpointAndClaim(address[2] memory _accounts) internal {\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]); //only do first slot\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, true);\n        }\n        _calcCvxIntegral(_accounts, depositedBalance, supply, true);\n    }\n\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _accounts The accounts for which checkpoints have to be calculated\n    function user_checkpoint(address[2] calldata _accounts) external returns (bool) {\n        _checkpoint([_accounts[0], _accounts[1]]);\n        return true;\n    }\n\n    /// @notice Get the balance of the user\n    /// @param _account Address whose balance is to be checked\n    /// @return The balance of the supplied address\n    function totalBalanceOf(address _account) external view returns (uint256) {\n        return _getDepositedBalance(_account);\n    }\n\n    /// @notice Get the amount of tokens the user has earned\n    /// @param _account Address whose balance is to be checked\n    /// @return claimable Array of earned tokens and their amount\n    function earned(address _account) external view returns (EarnedData[] memory claimable) {\n        uint256 supply = _getTotalSupply();\n        uint256 rewardCount = rewards.length;\n        claimable = new EarnedData[](rewardCount + 1);\n\n        for (uint256 i = 0; i < rewardCount; i++) {\n            RewardType storage reward = rewards[i];\n            address rewardToken = reward.reward_token;\n\n            //change in reward is current balance - remaining reward + earned\n            uint256 bal = IERC20(rewardToken).balanceOf(address(this));\n            uint256 d_reward = bal - reward.reward_remaining;\n            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));\n\n            uint256 I = reward.reward_integral;\n            if (supply > 0) {\n                I = I + (d_reward * 1e20) / supply;\n            }\n\n            uint256 newlyClaimable = (_getDepositedBalance(_account) * (I - reward.reward_integral_for[_account])) /\n                1e20;\n            claimable[i].amount = reward.claimable_reward[_account] + newlyClaimable;\n            claimable[i].token = rewardToken;\n\n            //calc cvx here\n            if (rewardToken == crv) {\n                claimable[rewardCount].amount =\n                    cvx_claimable_reward[_account] +\n                    CvxMining.ConvertCrvToCvx(newlyClaimable);\n                claimable[rewardCount].token = cvx;\n            }\n        }\n        return claimable;\n    }\n\n    /// @notice Claim reward for the supplied account\n    /// @param _account Address whose reward is to be claimed\n    function getReward(address _account) external {\n        //claim directly in checkpoint logic to save a bit of gas\n        _checkpointAndClaim([_account, address(0)]);\n    }\n}\n\n\n",
        "CodeNames": [
            "ConvexStakingWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ConvexStakingWrapper.sol",
                "Type": "Rewards distribution disruption",
                "Description": "An early user can cause the rewards distribution to be disrupted by exceeding type(uint128).max and causing an overflow.",
                "Repair": "Wrap a certain amount of initial totalSupply and never burn it, use uint256 instead of uint128 for reward.reward_integral, and lower 1e20 down to 1e12"
            },
            {
                "Location": "_peek() function in ConvexStakingWrapper.sol",
                "Type": "Insufficient validation of oracle data feed",
                "Description": "The oracle data feed is insufficiently validated, allowing for stale prices to be used and leading to incorrect quoteAmount return values.",
                "Repair": "Validate data feed by checking for stale price and round completeness"
            }
        ]
    }
]