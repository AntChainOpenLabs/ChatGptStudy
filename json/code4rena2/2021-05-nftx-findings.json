[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.8;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXEligibility.sol\";\nimport \"./interface/INFTXEligibilityManager.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/IPrevNftxContract.sol\";\nimport \"./interface/IRewardDistributionToken.sol\";\nimport \"./token/ERC20BurnableUpgradeable.sol\";\nimport \"./token/ERC20FlashMintUpgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./token/IERC721Upgradeable.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/SafeMathUpgradeable.sol\";\nimport \"./util/ReentrancyGuardUpgradeable.sol\";\nimport \"./util/EnumerableSetUpgradeable.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract NFTXVaultUpgradeable is\n    PausableUpgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20FlashMintUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721HolderUpgradeable,\n    ERC1155HolderUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    uint256 constant base = 10**18;\n\n    uint256 public vaultId;\n    address public manager;\n    address public assetAddress;\n    INFTXVaultFactory public vaultFactory;\n    INFTXEligibility public eligibilityStorage;\n\n    uint256 randNonce;\n    uint256 public mintFee;\n    uint256 public redeemFee;\n    uint256 public directRedeemFee;\n    uint256 public swapFee;\n\n    // Purposely putting these on a new slot to make sure they're together.\n    bool public is1155;\n    bool public allowAllItems;\n    bool public enableMint;\n    bool public enableRedeem;\n    bool public enableDirectRedeem;\n    bool public enableSwap;\n    bool[20] _bool_gap;\n\n    string public description;\n\n    EnumerableSetUpgradeable.UintSet holdings;\n    mapping(uint256 => uint256) quantity1155;\n\n    event VaultInit(\n        uint256 indexed vaultId,\n        address assetAddress,\n        bool is1155,\n        bool allowAllItems\n    );\n\n    event ManagerSet(address manager);\n    event EligibilityDeployed(address eligibilityAddr);\n\n    event EnableMintUpdated(bool enabled);\n    event EnableRedeemUpdated(bool enabled);\n    event EnableDirectRedeemUpdated(bool enabled);\n    event EnableSwapUpdated(bool enabled);\n\n    event MintFeeUpdated(uint256 mintFee);\n    event RedeemFeeUpdated(uint256 redeemFee);\n    event DirectRedeemFeeUpdated(uint256 directRedeemFee);\n    event SwapFeeUpdated(uint256 swapFee);\n\n    event Minted(uint256[] nftIds, uint256[] amounts, address sender);\n    event Redeemed(uint256[] nftIds, address sender);\n    event Swapped(\n        uint256[] nftIds,\n        uint256[] amounts,\n        uint256[] specificIds,\n        address sender\n    );\n\n    constructor() public {\n        __Pausable_init();\n        __ERC20_init(\"\", \"\");\n        __ERC20Burnable_init_unchained();\n        __ERC20FlashMint_init();\n    }\n\n    function __NFTXVault_init(\n        string memory _name,\n        string memory _symbol,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) public initializer {\n        __Pausable_init();\n        __ERC20_init(_name, _symbol);\n        __ERC20Burnable_init_unchained();\n        __ERC20FlashMint_init();\n        assetAddress = _assetAddress;\n        vaultFactory = INFTXVaultFactory(msg.sender);\n        vaultId = vaultFactory.numVaults();\n        is1155 = _is1155;\n        allowAllItems = _allowAllItems;\n        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);\n    }\n\n    function finalizeFund() external virtual {\n        setManager(address(0));\n    }\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRedeem,\n        bool _enableDirectRedeem,\n        bool _enableSwap\n    ) external virtual {\n        onlyPrivileged();\n        enableMint = _enableMint;\n        enableRedeem = _enableRedeem;\n        enableDirectRedeem = _enableDirectRedeem;\n        enableSwap = _enableSwap;\n\n        emit EnableMintUpdated(enableMint);\n        emit EnableRedeemUpdated(enableRedeem);\n        emit EnableDirectRedeemUpdated(enableDirectRedeem);\n        emit EnableSwapUpdated(enableSwap);\n    }\n\n    // Should we do defaults?\n    function setFees(\n        uint256 _mintFee,\n        uint256 _redeemFee,\n        uint256 _directRedeemFee,\n        uint256 _swapFee\n    ) external virtual {\n        onlyPrivileged();\n        mintFee = _mintFee;\n        redeemFee = _redeemFee;\n        directRedeemFee = _directRedeemFee;\n        swapFee = _swapFee;\n\n        emit MintFeeUpdated(_mintFee);\n        emit RedeemFeeUpdated(_redeemFee);\n        emit DirectRedeemFeeUpdated(_directRedeemFee);\n        emit SwapFeeUpdated(_swapFee);\n    }\n\n    // This function alls for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow \n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external virtual returns (address) {\n        onlyPrivileged();\n        INFTXEligibilityManager eligManager = INFTXEligibilityManager(\n            vaultFactory.eligibilityManager()\n        );\n        address _eligibility = eligManager.deployEligibility(\n            moduleIndex,\n            initData\n        );\n        setEligibilityStorage(_eligibility);\n        return _eligibility;\n    }\n\n    // This function allows for the manager to set their own arbitrary eligibility contract.\n    // Once eligiblity is set, it cannot be unset or changed.\n    function setEligibilityStorage(address _newEligibility) public virtual {\n        onlyPrivileged();\n        require(\n            address(eligibilityStorage) == address(0),\n            \"NFTXVault: eligibility already set\"\n        );\n        eligibilityStorage = INFTXEligibility(_newEligibility);\n        // Toggle this to let the contract know to check eligibility now.\n        allowAllItems = false;\n        emit EligibilityDeployed(address(_newEligibility));\n    }\n\n    // The manager has control over options like fees and features\n    function setManager(address _manager) public virtual {\n        onlyPrivileged();\n        manager = _manager;\n        emit ManagerSet(_manager);\n    }\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external virtual returns (uint256) {\n        return mintTo(tokenIds, amounts, msg.sender);\n    }\n\n    function mintTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        address to\n    ) public virtual nonReentrant returns (uint256) {\n        onlyOwnerIfPaused(1);\n        require(enableMint, \"Minting not enabled\");\n        require(allValidNFTs(tokenIds), \"NFTXVault: not eligible\");\n        uint256 count = receiveNFTs(tokenIds, amounts);\n\n        uint256 fee = mintFee.mul(count);\n        _mint(to, base.mul(count).sub(fee));\n        _distributeFees(fee);\n\n        emit Minted(tokenIds, amounts, to);\n        return count;\n    }\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        virtual\n        returns (uint256[] memory)\n    {\n        return redeemTo(amount, specificIds, msg.sender);\n    }\n\n    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        onlyOwnerIfPaused(2);\n        require(enableRedeem, \"Redeeming not enabled\");\n        require(\n            specificIds.length == 0 || enableDirectRedeem,\n            \"Direct redeem not enabled\"\n        );\n        uint256 fee = directRedeemFee.mul(specificIds.length).add(\n            redeemFee.mul(amount.sub(specificIds.length))\n        );\n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burnFrom(msg.sender, base.mul(amount).add(fee));\n        _distributeFees(fee);\n\n        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);\n        afterRedeemHook(redeemedIds);\n\n        emit Redeemed(redeemedIds, to);\n        return redeemedIds;\n    }\n\n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external virtual nonReentrant returns (uint256[] memory) {\n        return swapTo(tokenIds, amounts, specificIds, msg.sender);\n    }\n\n    function swapTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        uint256[] memory specificIds,\n        address to\n    ) public virtual returns (uint256[] memory) {\n        onlyOwnerIfPaused(3);\n        require(enableSwap, \"Swapping not enabled\");\n        require(\n            specificIds.length == 0 || enableDirectRedeem,\n            \"Direct redeem not enabled\"\n        );\n        uint256 count = receiveNFTs(tokenIds, amounts);\n        uint256 fee = directRedeemFee.mul(specificIds.length).add(\n            swapFee.mul(count.sub(specificIds.length))\n        );\n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burnFrom(msg.sender, fee);\n        _distributeFees(fee);\n        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);\n        emit Swapped(tokenIds, amounts, specificIds, to);\n        return ids;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override returns (bool) {\n        onlyOwnerIfPaused(4);\n        super.flashLoan(receiver, token, amount, data);\n    }\n\n    function allValidNFTs(uint256[] memory tokenIds)\n        public\n        view\n        returns (bool)\n    {\n        // add allow all check here\n        if (allowAllItems) {\n            return true;\n        }\n\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return false;\n        }\n        return _eligibilityStorage.checkAllEligible(tokenIds);\n    }\n\n    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.\n    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return;\n        }\n        _eligibilityStorage.afterRedeemHook(tokenIds);\n    }\n\n    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)\n        internal\n        virtual\n        returns (uint256)\n    {\n        if (is1155) {\n            // This is technically a check, so placing it before the effect.\n            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds,\n                amounts,\n                \"\"\n            );\n\n            uint256 count;\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                uint256 amount = amounts[i];\n                if (quantity1155[tokenId] == 0) {\n                    holdings.add(tokenId);\n                }\n                quantity1155[tokenId] = quantity1155[tokenId].add(amount);\n                count = count.add(amount);\n            }\n            return count;\n        } else {\n            IERC721Upgradeable erc721 = IERC721Upgradeable(assetAddress);\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                erc721.safeTransferFrom(msg.sender, address(this), tokenId);\n                holdings.add(tokenId);\n            }\n            return tokenIds.length;\n        }\n    }\n\n    function withdrawNFTsTo(\n        uint256 amount,\n        uint256[] memory specificIds,\n        address to\n    ) internal virtual returns (uint256[] memory) {\n        bool _is1155 = is1155;\n        address _assetAddress = assetAddress;\n        uint256[] memory redeemedIds = new uint256[](amount);\n\n        for (uint256 i = 0; i < amount; i++) {\n            uint256 tokenId = i < specificIds.length\n                ? specificIds[i]\n                : getRandomTokenIdFromFund();\n            redeemedIds[i] = tokenId;\n\n            if (_is1155) {\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    to,\n                    tokenId,\n                    1,\n                    \"\"\n                );\n\n                quantity1155[tokenId] = quantity1155[tokenId].sub(1);\n                if (quantity1155[tokenId] == 0) {\n                    holdings.remove(tokenId);\n                }\n            } else {\n                IERC721Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    to,\n                    tokenId\n                );\n                holdings.remove(tokenId);\n            }\n        }\n        return redeemedIds;\n    }\n\n    function _distributeFees(uint256 amount) internal virtual {\n        // Mint fees directly to the distributor and distribute.\n        if (amount > 0) {\n            address feeReceiver = vaultFactory.feeReceiver();\n            _mint(feeReceiver, amount);\n            INFTXFeeDistributor(feeReceiver).distribute(vaultId);\n        }\n    }\n\n    function getRandomTokenIdFromFund() internal virtual returns (uint256) {\n        uint256 randomIndex = getPseudoRand(holdings.length());\n        return holdings.at(randomIndex);\n    }\n\n    function getPseudoRand(uint256 modulus) internal virtual returns (uint256) {\n        randNonce += 1;\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(blockhash(block.number - 1), randNonce)\n                )\n            ) %\n            modulus;\n    }\n\n    function onlyPrivileged() internal view {\n        if (manager == address(0)) {\n            require(msg.sender == owner(), \"Not owner\");\n        } else {\n            require(msg.sender == manager, \"Not manager\");\n        }\n    }\n\n    // TODO: recount this.\n    uint256[25] ___gap;\n}\n\n\n",
        "CodeNames": [
            "NFTXVaultUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXVaultUpgradeable.sol",
                "Type": "Circumvention of direct redeem fee",
                "Description": "A malicious actor can revert a transaction if they did not get the NFT they wanted. Combined with utilizing Flashbots miners which do not publish transactions which revert with FlashbotsCheckAndSend, there would be no cost to constantly attempting this every block or after the nonce is updated from getPseudoRand(). The directReedemFee can be avoided and users may lose out on potential earnings.",
                "Repair": "Use a commit-reveal pattern for NFT swaps and redemptions"
            },
            {
                "Location": "NFTXVaultUpgradeable.sol",
                "Type": "Brute-forcing of randomization",
                "Description": "A user can brute-forced the on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest.",
                "Repair": "Consider only EOA (external only account) for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, make the user commit to pseudo-random IDs before revealing them."
            },
            {
                "Location": "NFTXVaultUpgradeable.getRandomTokenIdFromFund",
                "Type": "Wrong probabilities for ERC1155",
                "Description": "NFTXVaultUpgradeable.getRandomTokenIdFromFund does not work with ERC1155 as it does not take the deposited quantity1155 into account. This might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.",
                "Repair": "Take the quantities of each token into account (quantity1155) which probably requires a design change as it is currently hard to do without iterating over all tokens."
            },
            {
                "Location": "NFTXVaultUpgradeable.setFees",
                "Type": "Arbitrary fee setting",
                "Description": "The fees in NFTXVaultUpgradeable can be set arbitrarily high. The manager can front-run mints and set a huge fee which transfers user's NFTs to the vault but doesn't mint any pool share tokens in return for the user.",
                "Repair": "Check for a max fee as a percentage of base whenever setting fees"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/SafeMathUpgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract NFTXFeeDistributor is INFTXFeeDistributor, PausableUpgradeable {\n\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  bool public distributionPaused;\n\n  address public override nftxVaultFactory;\n  address public override lpStaking;\n  address public override treasury;\n  uint256 public override defaultTreasuryAlloc;\n  uint256 public override defaultLPAlloc;\n\n  mapping(uint256 => uint256) public override allocTotal;\n  mapping(uint256 => uint256) public override specificTreasuryAlloc;\n  mapping(uint256 => FeeReceiver[]) feeReceivers;\n\n  event AddFeeReceiver(uint256 vaultId, address receiver, uint256 allocPoint);\n  event FeeReceiverAllocChange(uint256 vaultId, address receiver, uint256 allocPoint);\n  event RemoveFeeReceiver(uint256 vaultId, address receiver);\n  \n  function __FeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {\n    __Pausable_init();\n    lpStaking = _lpStaking;\n    treasury = _treasury; \n    defaultTreasuryAlloc = 0.2 ether;\n    defaultLPAlloc = 0.5 ether;\n  }\n\n  function rescue(address token) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n    IERC20Upgradeable(token).transfer(msg.sender, balance);\n  }\n\n  function distribute(uint256 vaultId) external override {\n    require(nftxVaultFactory != address(0));\n    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    if (tokenBalance <= 10**9) {\n      return;\n    }\n    // Leave some balance for dust since we know we have more than 10**9.\n    tokenBalance -= 1000;\n    \n    uint256 _treasuryAlloc = specificTreasuryAlloc[vaultId];\n    if (_treasuryAlloc == 0) {\n      _treasuryAlloc = defaultTreasuryAlloc;\n    }\n\n    uint256 _allocTotal = allocTotal[vaultId] + _treasuryAlloc;\n    uint256 amountToSend = tokenBalance * _treasuryAlloc / _allocTotal;\n    amountToSend = amountToSend > tokenBalance ? tokenBalance : amountToSend;\n    IERC20Upgradeable(_vault).safeTransfer(treasury, amountToSend);\n\n    if (distributionPaused) {\n      return;\n    } \n\n    FeeReceiver[] memory _feeReceivers = feeReceivers[vaultId];\n    for (uint256 i = 0; i < _feeReceivers.length; i++) {\n      _sendForReceiver(_feeReceivers[i], vaultId, _vault, tokenBalance, _allocTotal);\n    } \n  }\n\n  function addReceiver(uint256 _vaultId, uint256 _allocPoint, address _receiver, bool _isContract) external override onlyOwner  {\n    _addReceiver(_vaultId, _allocPoint, _receiver, _isContract);\n  }\n\n  function initializeVaultReceivers(uint256 _vaultId) external override {\n    require(msg.sender == nftxVaultFactory, \"FeeReceiver: not factory\");\n    _addReceiver(_vaultId, defaultLPAlloc, lpStaking, true);\n    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);\n  }\n\n  function changeReceiverAlloc(uint256 _vaultId, uint256 _receiverIdx, uint256 _allocPoint) external override onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_vaultId][_receiverIdx];\n    allocTotal[_vaultId] -= feeReceiver.allocPoint;\n    feeReceiver.allocPoint = _allocPoint;\n    allocTotal[_vaultId] += _allocPoint;\n    emit FeeReceiverAllocChange(_vaultId, feeReceiver.receiver, _allocPoint);\n  }\n\n  function changeReceiverAddress(uint256 _vaultId, uint256 _receiverIdx, address _address, bool _isContract) external override onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_vaultId][_receiverIdx];\n    feeReceiver.receiver = _address;\n    feeReceiver.isContract = _isContract;\n  }\n\n  function removeReceiver(uint256 _vaultId, uint256 _receiverIdx) external override onlyOwner {\n    FeeReceiver[] storage feeReceiversForVault = feeReceivers[_vaultId];\n    uint256 arrLength = feeReceiversForVault.length;\n    require(_receiverIdx < arrLength, \"FeeDistributor: Out of bounds\");\n    emit RemoveFeeReceiver(_vaultId, feeReceiversForVault[_receiverIdx].receiver);\n    allocTotal[_vaultId] -= feeReceiversForVault[_receiverIdx].allocPoint;\n    feeReceiversForVault[_receiverIdx] = feeReceiversForVault[arrLength-1];\n    feeReceiversForVault.pop();\n  }\n\n  function setTreasuryAddress(address _treasury) external override onlyOwner {\n    treasury = _treasury;\n  }\n\n  function setDefaultTreasuryAlloc(uint256 _allocPoint) external override onlyOwner {\n    defaultTreasuryAlloc = _allocPoint;\n  }\n\n  function setSpecificTreasuryAlloc(uint256 vaultId, uint256 _allocPoint) external override onlyOwner {\n    specificTreasuryAlloc[vaultId] = _allocPoint;\n  }\n\n  function setLPStakingAddress(address _lpStaking) external override onlyOwner {\n    lpStaking = _lpStaking;\n  }\n\n  function setNFTXVaultFactory(address _factory) external override onlyOwner {\n    nftxVaultFactory = _factory;\n  }\n\n  function setDefaultLPAlloc(uint256 _allocPoint) external override onlyOwner {\n    defaultLPAlloc = _allocPoint;\n  }\n\n  function pauseFeeDistribution(bool pause) external onlyOwner {\n    distributionPaused = pause;\n  }\n\n  function rescueTokens(uint256 _address) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\n    IERC20Upgradeable(_address).transfer(msg.sender, balance);\n  }\n\n  function _addReceiver(uint256 _vaultId, uint256 _allocPoint, address _receiver, bool _isContract) internal  {\n    allocTotal[_vaultId] += _allocPoint;\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\n    feeReceivers[_vaultId].push(_feeReceiver);\n    emit AddFeeReceiver(_vaultId, _receiver, _allocPoint);\n  }\n\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 _tokenBalance, uint256 _allocTotal) internal {\n    uint256 amountToSend = _tokenBalance * _receiver.allocPoint / _allocTotal;\n    // If we're at this point we know we have more than enough to perform this safely.\n    uint256 balance = IERC20Upgradeable(_vault).balanceOf(address(this)) - 1000;\n    amountToSend = amountToSend > balance ? balance : amountToSend;\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n      // If the receive is not properly processed, send it to the treasury instead.\n       \n      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);\n      bool tokensReceived = abi.decode(returnData, (bool));\n      if (!success || !tokensReceived) {\n        console.log(\"treasury fallback\");\n        IERC20Upgradeable(_vault).safeTransfer(treasury, amountToSend);\n      }\n    } else {\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    }\n  }\n} \n\n",
        "CodeNames": [
            "NFTXFeeDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXFeeDistributor",
                "Type": "Fee distribution re-entrancy",
                "Description": "A smart contract with a malicious receiveRewards function can re-enter the distribute function with the same vault ID, thereby causing the exploit.",
                "Repair": "Incorporate re-entrancy protection into the distribute function"
            },
            {
                "Location": "NFTXFeeDistributor.sol",
                "Type": "Malicious receiver causing loss of distributed fees",
                "Description": "A malicious receiver can cause another receiver to lose out on distributed fees by returning false for tokensReceived when receiveRewards is called on their receiver contract. This causes the fee distributor to double spend the amountToSend because the contract incorrectly assumes the returned data is truthful.",
                "Repair": "Don't trust return data from externally called contracts. Only utilize whether the transaction succeeds to determine if the treasury fallback should be called."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Withdrawal of staking token and rescue of arbitrary tokens sent to the FeeDistributor contract",
                "Type": "Inconsistent use of safeTransfer/safeTransferFrom",
                "Description": "It is good to add a require() statement that checks the return value of token transfers, or to use something like\u00a0OpenZeppelin\u2019s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure.",
                "Repair": "Use safeTransfer/safeTransferFrom or require() consistently."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.8;\n\nimport \"../interface/IERC3156Upgradeable.sol\";\nimport \"./ERC20Upgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n */\nabstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLenderUpgradeable {\n    function __ERC20FlashMint_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20FlashMint_init_unchained();\n    }\n\n    function __ERC20FlashMint_init_unchained() internal initializer {\n    }\n    bytes32 constant private RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amont of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view override returns (uint256) {\n        return token == address(this) ? type(uint256).max - ERC20Upgradeable.totalSupply() : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @param token The token to be flash loaned.\n     * @param amount The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        // silence warning about unused variable without the addition of bytecode.\n        amount;\n        return 0;\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * amount + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower.onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param amount The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` is the flash loan was successfull.\n     */\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes memory data\n    )\n        public virtual override returns (bool)\n    {\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, fee, data) == RETURN_VALUE, \"ERC20FlashMint: invalid return value\");\n        uint256 currentAllowance = allowance(address(receiver), address(this));\n        require(currentAllowance >= amount + fee, \"ERC20FlashMint: allowance does not allow refund\");\n        _approve(address(receiver), address(this), currentAllowance - amount - fee);\n        _burn(address(receiver), amount + fee);\n        return true;\n    }\n    uint256[50] private __gap;\n}\n\n",
        "CodeNames": [
            "ERC20FlashMintUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ERC20FlashMintUpgradeable.flashLoan",
                "Type": "Missing overflow check in flashLoan",
                "Description": "ERC20FlashMintUpgradeable.flashLoan does not check for an overflow when adding the fees to the flashloan amount. This leads to an issue where the attacker does not need to pay back the flashloan as they will burn 0 tokens.",
                "Repair": "Use SafeMath."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.8;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\nimport \"./proxy/ClonesUpgradeable.sol\";\nimport \"./proxy/Initializable.sol\";\nimport \"./StakingTokenProvider.sol\";\nimport \"./token/RewardDistributionTokenUpgradeable.sol\";\n\n// Author: 0xKiwi.\n\ncontract NFTXLPStaking is OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    INFTXVaultFactory public nftxVaultFactory;\n    INFTXFeeDistributor public feeDistributor;\n    RewardDistributionTokenUpgradeable public rewardDistTokenImpl;\n    StakingTokenProvider public stakingTokenProvider;\n\n    event PoolCreated(uint256 vaultId, address pool);\n    event PoolUpdated(uint256 vaultId, address pool);\n    event FeesReceived(uint256 vaultId, uint256 amount);\n\n    struct StakingPool {\n        address stakingToken;\n        address rewardToken;\n    }\n    mapping(uint256 => StakingPool) public vaultStakingInfo;\n\n    function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer {\n        __Ownable_init();\n        rewardDistTokenImpl = new RewardDistributionTokenUpgradeable();\n        rewardDistTokenImpl.__RewardDistributionToken_init(IERC20Upgradeable(address(0)), \"\", \"\");\n        stakingTokenProvider = StakingTokenProvider(_stakingTokenProvider);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == address(feeDistributor), \"LPStaking: Not authorized\");\n        _;\n    }\n\n    function setNFTXVaultFactory(address newFactory) external onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function setFeeDistributor(address newDistributor) external onlyOwner {\n        require(newDistributor != address(0));\n        feeDistributor = INFTXFeeDistributor(newDistributor);\n    }\n\n    function setStakingTokenProvider(address newProvider) external onlyOwner {\n        require(newProvider != address(0));\n        stakingTokenProvider = StakingTokenProvider(newProvider);\n    }\n\n    // Consider changing LP staking to take vault id into consideration, and access data from there.\n    function addPoolForVault(uint256 vaultId) external onlyAdmin {\n        require(vaultStakingInfo[vaultId].stakingToken == address(0), \"LPStaking: Pool already exists\");\n        address _rewardToken = nftxVaultFactory.vault(vaultId);\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(_rewardToken);\n        StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);\n        vaultStakingInfo[vaultId] = pool;\n        address newRewardDistToken = _deployDividendToken(pool);\n        emit PoolCreated(vaultId, newRewardDistToken);\n    }\n\n    function updatePoolForVaults(uint256[] calldata vaultIds) external {\n        for (uint256 i = 0; i < vaultIds.length; i++) {\n            updatePoolForVault(vaultIds[i]);\n        }\n    }\n\n    // TODO: REDUCE DUPLICATION HERE\n    // In case the provider changes, this lets the pool be updated.\n    function updatePoolForVault(uint256 vaultId) public {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        require(pool.stakingToken != address(0), \"LPStaking: Pool doesn't exist\");\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(pool.rewardToken);\n        if (_stakingToken == pool.stakingToken) {\n            return;\n        }\n        StakingPool memory newPool = StakingPool(_stakingToken, pool.rewardToken);\n        vaultStakingInfo[vaultId] = newPool;\n        address newRewardDistToken = _deployDividendToken(newPool);\n        emit PoolUpdated(vaultId, newRewardDistToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external onlyAdmin returns (bool) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            // In case the pair is updated, but not yet \n            return false;\n        }\n        \n        RewardDistributionTokenUpgradeable rewardDistToken = _rewardDistributionTokenAddr(pool);\n        // Don't distribute rewards unless there are people to distribute to.\n        if (rewardDistToken.totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the vault only needs to approve this contract.\n        IERC20Upgradeable(pool.rewardToken).transferFrom(msg.sender, address(rewardDistToken), amount);\n        rewardDistToken.distributeRewards(amount);\n        emit FeesReceived(vaultId, amount);\n        return true;\n    }\n\n    function deposit(uint256 vaultId, uint256 amount) external {\n        // Check the pool in case its been updated.\n        updatePoolForVault(vaultId);\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        require(IERC20Upgradeable(pool.stakingToken).transferFrom(msg.sender, address(this), amount));\n        _rewardDistributionTokenAddr(pool).mint(msg.sender, amount);\n    }\n\n    function exit(uint256 vaultId) external {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        _claimRewards(pool, msg.sender);\n        _withdraw(pool, balanceOf(vaultId, msg.sender), msg.sender);\n    }\n\n    function emergencyExitAndClaim(address _stakingToken, address _rewardToken) external {\n        StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);\n        _claimRewards(pool, msg.sender);\n        RewardDistributionTokenUpgradeable dist = _rewardDistributionTokenAddr(pool);\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\n    }\n\n    function emergencyExit(address _stakingToken, address _rewardToken) external {\n        StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);\n        RewardDistributionTokenUpgradeable dist = _rewardDistributionTokenAddr(pool);\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\n    }\n\n    function withdraw(uint256 vaultId, uint256 amount) external {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        _withdraw(pool, amount, msg.sender);\n    }\n\n    function claimRewards(uint256 vaultId) external {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        _claimRewards(pool, msg.sender);\n    }\n\n    function rewardDistributionToken(uint256 vaultId) external view returns (RewardDistributionTokenUpgradeable) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            return RewardDistributionTokenUpgradeable(address(0));\n        }\n        return _rewardDistributionTokenAddr(pool);\n    }\n\n    function safeRewardDistributionToken(uint256 vaultId) external view returns (address) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        return address(_rewardDistributionTokenAddr(pool));\n    }\n\n    function balanceOf(uint256 vaultId, address addr) public view returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        RewardDistributionTokenUpgradeable dist = _rewardDistributionTokenAddr(pool);\n        return dist.balanceOf(addr);\n    }\n\n    function _deployDividendToken(StakingPool memory pool) internal returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.rewardToken));\n        address rewardDistToken = ClonesUpgradeable.cloneDeterministic(address(rewardDistTokenImpl), salt);\n        string memory name = stakingTokenProvider.nameForStakingToken(pool.rewardToken);\n        RewardDistributionTokenUpgradeable(rewardDistToken).__RewardDistributionToken_init(IERC20Upgradeable(pool.rewardToken), name, name);\n        return rewardDistToken;\n    }\n\n    function _claimRewards(StakingPool memory pool, address account) internal {\n        _rewardDistributionTokenAddr(pool).withdrawReward(account);\n    }\n\n    function _withdraw(StakingPool memory pool, uint256 amount, address account) internal {\n        _rewardDistributionTokenAddr(pool).burnFrom(account, amount);\n        IERC20Upgradeable(pool.stakingToken).transfer(account, amount);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function _rewardDistributionTokenAddr(StakingPool memory pool) internal view returns (RewardDistributionTokenUpgradeable) {\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.rewardToken));\n        address tokenAddr = ClonesUpgradeable.predictDeterministicAddress(address(rewardDistTokenImpl), salt);\n        return RewardDistributionTokenUpgradeable(tokenAddr);\n    }\n}\n\n",
        "CodeNames": [
            "NFTXLPStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXLPStaking",
                "Type": "Flash loan attack on NFTXLPStaking",
                "Description": "The LPStaking contract does not require that a stake be locked for any period of time. An attacker can stake, claim rewards, and unstake, all in one transaction. If the attacker utilizes a flash loan, then they can claim nearly all of the rewards for themselves, leaving very little left for the legitimate stakers.",
                "Repair": "Require that staked LP tokens be staked for a particular period of time before they can be removed. Alternatively, only allow rewards to be claimed for stakes that have been staked for a certain period of time."
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.8;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXEligibility.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\nimport \"./proxy/ClonesUpgradeable.sol\";\n\ncontract NFTXEligibilityManager is OwnableUpgradeable {\n  INFTXVaultFactory public nftxVaultFactory;\n\n  struct EligibilityModule {\n    address impl;\n  }\n  EligibilityModule[] public modules;\n\n  function __NFTXEligibilityManager_init() public initializer {\n    __Ownable_init();\n  }\n\n  function addModule(address implementation) public onlyOwner {\n    EligibilityModule memory module = EligibilityModule(implementation);\n    modules.push(module);\n  }\n\n  function updateModule(uint256 index, address implementation) public onlyOwner {\n    modules[index].impl = implementation;\n  }\n\n  function deployEligibility(uint256 moduleIndex, bytes calldata configData) external virtual returns (address) {\n    address eligImpl = modules[moduleIndex].impl;\n    address eligibilityClone = ClonesUpgradeable.clone(eligImpl);\n    INFTXEligibility(eligibilityClone).__NFTXEligibility_init_bytes(configData);\n    return eligibilityClone;\n  }\n\n  function allModules() external view returns (EligibilityModule[] memory) {\n    return modules;\n  }\n}\n\n",
        "CodeNames": [
            "NFTXEligiblityManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXEligiblityManager._sendForReceiver",
                "Type": "DoS",
                "Description": "A single poorly implemented feeReceiver can break the whole distribute function and allow a denial of service by reverting the transaction.",
                "Repair": "Check returnData.length == 1 before decoding"
            },
            {
                "Location": "NFTXEligiblityManager.distribute",
                "Type": "Unbounded iteration",
                "Description": "NFTXEligiblityManager.distribute iterates over all _feeReceivers. If the number of _feeReceivers gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call distribute at all.",
                "Repair": "Keep the number of _feeReceivers small"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.8;\n\nimport \"../interface/INFTXVault.sol\";\nimport \"../token/IERC721Upgradeable.sol\";\nimport \"../token/IERC1155Upgradeable.sol\";\nimport \"../token/ERC721HolderUpgradeable.sol\";\nimport \"../token/ERC1155HolderUpgradeable.sol\";\nimport \"../util/PausableUpgradeable.sol\";\nimport \"../util/SafeMathUpgradeable.sol\";\nimport \"./UniqueEligibility.sol\";\nimport \"./NFTXEligibility.sol\";\n\ncontract NFTXMintRequestEligibility is\n    PausableUpgradeable,\n    UniqueEligibility,\n    NFTXEligibility,\n    ERC721HolderUpgradeable,\n    ERC1155HolderUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n\n    function name() public view override virtual returns (string memory) {\n        return \"MintRequest\";\n    }\n\n    address public manager;\n    INFTXVault public vault;\n    bool public is1155;\n    bool public reverseEligOnRedeem;\n    bool public allowTrustedApprovals;\n\n    mapping(address => mapping(uint256 => bool)) approvedMints;\n    mapping(address => mapping(uint256 => uint256)) mintRequests;\n\n    struct Config {\n        address owner;\n        address vaultAddress;\n        bool reverseEligOnRedeem;\n        uint256[] tokenIds;\n    }\n\n    event CanApproveMintRequestsSet(address[] addresses, bool canApprove);\n    event NFTXEligibilityInit(address owner, uint256[] tokenIds);\n\n    event AllowTrustedApprovalsSet(bool allow);\n\n    event Request(address sender, uint256[] nftIds, uint256[] amounts);\n    event Reject(uint256[] nftIds);\n    event Approve(uint256[] nftIds);\n\n    /* constructor() public {\n        __Ownable_init();\n        renounceOwnership();\n    } */\n\n    function __NFTXEligibility_init_bytes(bytes memory _configData)\n        public\n        override\n        virtual\n        initializer\n    {\n        __Ownable_init();\n        (address _owner, address _vault, bool _reverseElig, uint256[] memory _ids) = abi\n            .decode(_configData, (address, address, bool, uint256[]));\n        __NFTXEligibility_init(_owner, _vault, _reverseElig, _ids);\n    }\n\n    function __NFTXEligibility_init(\n        address _owner,\n        address vaultAddress,\n        bool _reverseEligOnRedeem,\n        uint256[] memory tokenIds\n    ) public initializer {\n        __Ownable_init();\n        _setUniqueEligibilities(tokenIds, true);\n        transferOwnership(_owner);\n        // Approve for future usage.\n        // Same function on both 721 and 1155.\n        vault = INFTXVault(vaultAddress);\n        reverseEligOnRedeem = _reverseEligOnRedeem;\n        is1155 = INFTXVault(vaultAddress).is1155();\n        address _assetAddress = INFTXVault(vaultAddress).assetAddress();\n        IERC1155Upgradeable(_assetAddress).setApprovalForAll(\n            address(vault),\n            true\n        );\n        emit NFTXEligibilityInit(_owner, tokenIds);\n    }\n\n    function finalizeEligibility() external virtual onlyOwner {\n        // Maybe add a bool here to pause verything.\n        renounceOwnership();\n    }\n\n    function setEligibilityPreferences(bool _allowTrustedApprovals)\n        external\n        virtual\n        onlyOwner\n    {\n        allowTrustedApprovals = _allowTrustedApprovals;\n        emit AllowTrustedApprovalsSet(_allowTrustedApprovals);\n    }\n\n    function requestMint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external virtual {\n        require(!finalized(), \"Finalized\");\n        address _assetAddress = vault.assetAddress();\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            uint256 amount = amounts[i];\n            require(\n                mintRequests[msg.sender][tokenId] == 0,\n                \"No existing request\"\n            );\n            mintRequests[msg.sender][tokenId] = amount;\n            if (is1155) {\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    tokenId,\n                    amount,\n                    \"\"\n                );\n            } else {\n                IERC721Upgradeable(_assetAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    tokenId\n                );\n            }\n        }\n        emit Request(msg.sender, tokenIds, amounts);\n    }\n\n    function approveMintRequests(\n        uint256[] calldata tokenIds,\n        address[] calldata addresses,\n        bool mint\n    ) external virtual {\n        // Add here? Allow approval if finalized?\n        require(!finalized(), \"Finalized\");\n        if (!allowTrustedApprovals || !isGuardian[msg.sender]) {\n            onlyPrivileged();\n        }\n        require(tokenIds.length == addresses.length);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            uint256 amount = mintRequests[addresses[i]][tokenId];\n            require(amount > 0, \"No requests\");\n            if (mint) {\n                approvedMints[addresses[i]][tokenId] = false;\n                mintRequests[addresses[i]][tokenId] = 0;\n                uint256[] memory _tokenIds;\n                uint256[] memory _amounts;\n                _tokenIds[0] = tokenId;\n                _amounts[0] = amount;\n                vault.mintTo(_tokenIds, _amounts, addresses[i]);\n            } else {\n                approvedMints[addresses[i]][tokenId] = true;\n            }\n        }\n        return;\n    }\n\n    function claimUnminted(\n        uint256[] calldata tokenIds,\n        address[] calldata addresses\n    ) external virtual {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            uint256 amount = mintRequests[addresses[i]][tokenId];\n            require(amount > 0, \"No requests\");\n            require(approvedMints[addresses[i]][tokenId], \"Not approved\");\n            approvedMints[addresses[i]][tokenId] = false;\n            mintRequests[addresses[i]][tokenId] = 0;\n            uint256[] memory _tokenIds;\n            uint256[] memory _amounts;\n            _tokenIds[0] = tokenId;\n            _amounts[0] = amount;\n            vault.mintTo(_tokenIds, _amounts, addresses[i]);\n        }\n    }\n\n    function reclaimRequestedMint(uint256[] calldata tokenIds)\n        external\n        virtual\n    {\n        address _assetAddress = vault.assetAddress();\n        bool _is1155 = is1155;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            uint256 amount = mintRequests[msg.sender][tokenId];\n            require(amount > 0, \"NFTXVault: nothing to reclaim\");\n            mintRequests[msg.sender][tokenId] = 0;\n            approvedMints[msg.sender][tokenId] = false;\n            if (_is1155) {\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    tokenId,\n                    amount,\n                    \"\"\n                );\n            } else {\n                IERC721Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    tokenId\n                );\n            }\n        }\n    }\n\n    function setUniqueEligibilities(uint256[] memory tokenIds, bool _isEligible)\n        public\n        virtual\n    {\n        if (!allowTrustedApprovals || !isGuardian[msg.sender]) {\n            onlyPrivileged();\n        }\n        _setUniqueEligibilities(tokenIds, _isEligible);\n    }\n\n    function finalized() public view override virtual returns (bool) {\n        return owner() == address(0);\n    }\n\n    function _checkIfEligible(uint256 _tokenId)\n        internal\n        view\n        override\n        virtual\n        returns (bool)\n    {\n        return isUniqueEligible(_tokenId);\n    }\n\n    function onlyPrivileged() internal view {\n        require(msg.sender == owner(), \"Not owner\");\n    }\n}\n\n\n",
        "CodeNames": [
            "NFTXMintRequestEligibility.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXMintRequestEligibility.requestMint",
                "Type": "Tokens getting stuck",
                "Description": "User can call NFTXMintRequestEligibility.requestMint for an ERC721 with amounts[i] = 0. The ERC721.transferFrom is still executed but user cannot reclaimRequestedMint later and the NFT is stuck as it checks (amounts[i] > 0).",
                "Repair": "Check amounts[i] == 1 in ERC721 case, amounts[i] > 0 in 1155 case"
            }
        ]
    }
]