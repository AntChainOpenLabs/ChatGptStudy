[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "onlyAdmin functions that change critical contract parameters/addresses/state",
                "Type": "Missing event & timelock",
                "Description": "Privileged functions in all contracts, for e.g. VaultTracker onlyAdmin, have direct financial or trust impact on users who should be given an opportunity to react to them by exiting/engaging without being surprised when changes initiated by such functions are made effective opaquely (without events) and/or immediately (without timelocks)",
                "Repair": "Add events to all possible flows and consider adding timelocks to such onlyAdmin functions"
            },
            {
                "Location": "function recover(bytes32 h, Components calldata c) internal pure returns (address)",
                "Type": "Unchecked return value",
                "Description": "The solidity function ecrecover is used, however the error result of 0 is not checked for",
                "Repair": "Verify that the result from ecrecover isn't 0"
            },
            {
                "Location": "createMarket function",
                "Type": "Overwriting previously created markets",
                "Description": "The createMarket function allows accidental overwriting of previously created markets for the same combination of underlying and maturity timestamp (u, m) because there is no zero-address check to see if a previously created market exists for that combination",
                "Repair": "Add a zero-address check for markets[u][m] in createMarket before writing to it"
            },
            {
                "Location": "Swivel.sol",
                "Type": "Fee-on-transfer underlying",
                "Description": "The current implementation doesn't work with fee-on-transfer underlying tokens. This becomes particularly problematic in the following scenario: a market for USDT is running without problems, then they activate the fee: this effectively blocks users from redeeming the underlying",
                "Repair": "Implement a way to handle these tokens. A possible way to do it is to check the balance of the contract before and after every time a token is transferred to see the effective quantity. To help keeping the code clear, a function like Compound's doTransferIn can be implemented"
            },
            {
                "Location": "Swivel.sol",
                "Type": "Unsafe handling of underlying tokens",
                "Description": "Not every ERC20 token follows OpenZeppelin's recommendation. It's possible (inside ERC20 standard) that a transferFrom doesn't revert upon failure but returns false.The code doesn't check these return values",
                "Repair": "Consider using OpenZeppelin's library with *safe* versions of transfer functions"
            },
            {
                "Location": "exitVaultFillingVaultInitiate() function",
                "Type": "Double charging fees",
                "Description": "Taker is charged fees twice in exitVaultFillingVaultInitiate() . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker's net balance is premiumFilled 2*fee",
                "Repair": "Charge fees only once to the maker instead of charging the taker twice"
            },
            {
                "Location": "transferNotionalFrom function in VaultTracker.sol",
                "Type": "Balance Manipulation",
                "Description": "The transferNotionalFrom function in VaultTracker.sol can manipulate the balances if the 'from' and 'to' addresses are the same.",
                "Repair": "Add a check to ensure that the 'from' and 'to' addresses are not the same before updating the balances"
            },
            {
                "Location": "initiateZcTokenFillingZcTokenExit function in Swivel.sol",
                "Type": "Incorrect Implementation",
                "Description": "The initiateZcTokenFillingZcTokenExit function in Swivel.sol incorrectly transfers the underlying tokens to the maker instead of only transferring the premium paid and separately transferring the fee to Swivel.",
                "Repair": "Change the transfer of underlying tokens to the maker to only transfer the premium paid and add a separate transfer for the fee to Swivel"
            },
            {
                "Location": "Admin role in Swivel.sol, MarketPlace.sol, and VaultTracker.sol",
                "Type": "Single Point of Failure",
                "Description": "The admin role/key in Swivel.sol, MarketPlace.sol, and VaultTracker.sol is a single point of failure without any mitigations.",
                "Repair": "Add transfer/renounce functionality for admin and consider using OpenZeppelin's Ownable library"
            }
        ]
    }
]