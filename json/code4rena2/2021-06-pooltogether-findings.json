[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./IBadgerSett.sol\";\nimport \"./IBadger.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title A pooltogether yield source for badger sett\n/// @author Steffel Fenix, 0xkarl\ncontract BadgerYieldSource is IYieldSource {\n    using SafeMath for uint256;\n    IBadgerSett private immutable badgerSett;\n    IBadger private immutable badger;\n    mapping(address => uint256) private balances;\n\n    constructor(address badgerSettAddr, address badgerAddr) public {\n        badgerSett = IBadgerSett(badgerSettAddr);\n        badger = IBadger(badgerAddr);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return (address(badger));\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = badgerSett.totalSupply();\n        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));\n        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));\n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        badger.transferFrom(msg.sender, address(this), amount);\n        badger.approve(address(badgerSett), amount);\n\n        uint256 beforeBalance = badgerSett.balanceOf(address(this));\n        badgerSett.deposit(amount);\n        uint256 afterBalance = badgerSett.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @return The actual amount of tokens that were redeemed.\n    function redeemToken(uint256 amount) public override returns (uint256) {\n        uint256 totalShares = badgerSett.totalSupply();\n        if (totalShares == 0) return 0;\n\n        uint256 badgerSettBadgerBalance = badgerSett.balance();\n        if (badgerSettBadgerBalance == 0) return 0;\n\n        uint256 badgerBeforeBalance = badger.balanceOf(address(this));\n\n        uint256 requiredShares =\n            ((amount.mul(totalShares) + totalShares)).div(\n                badgerSettBadgerBalance\n            );\n        if (requiredShares == 0) return 0;\n\n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        badgerSett.withdraw(requiredSharesBalance);\n\n        uint256 badgerAfterBalance = badger.balanceOf(address(this));\n        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        badger.transfer(msg.sender, badgerBalanceDiff);\n        return (badgerBalanceDiff);\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ISushiBar.sol\";\nimport \"./ISushi.sol\";\n\n/// @title A pooltogether yield source for sushi token\n/// @author Steffel Fenix\ncontract SushiYieldSource is IYieldSource {\n    \n    using SafeMath for uint256;\n    \n    ISushiBar public immutable sushiBar;\n    ISushi public immutable sushiAddr;\n    \n    mapping(address => uint256) public balances;\n\n    constructor(ISushiBar _sushiBar, ISushi _sushiAddr) public {\n        sushiBar = _sushiBar;\n        sushiAddr = _sushiAddr;\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return address(sushiAddr);\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = sushiBar.totalSupply();\n        uint256 barSushiBalance = sushiAddr.balanceOf(address(sushiBar));\n\n        return balances[addr].mul(barSushiBalance).div(totalShares);       \n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        sushiAddr.transferFrom(msg.sender, address(this), amount);\n        sushiAddr.approve(address(sushiBar), amount);\n\n        ISushiBar bar = sushiBar;\n        uint256 beforeBalance = bar.balanceOf(address(this));\n        \n        bar.enter(amount);\n        \n        uint256 afterBalance = bar.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        \n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @dev The maxiumum that can be called for token() is calculated by balanceOfToken() above.\n    /// @return The actual amount of tokens that were redeemed. This may be different from the amount passed due to the fractional math involved. \n    function redeemToken(uint256 amount) public override returns (uint256) {\n        ISushiBar bar = sushiBar;\n        ISushi sushi = sushiAddr;\n\n        uint256 totalShares = bar.totalSupply();\n        if(totalShares == 0) return 0; \n\n        uint256 barSushiBalance = sushi.balanceOf(address(bar));\n        if(barSushiBalance == 0) return 0;\n\n        uint256 sushiBeforeBalance = sushi.balanceOf(address(this));\n\n        uint256 requiredShares = ((amount.mul(totalShares) + totalShares)).div(barSushiBalance);\n        if(requiredShares == 0) return 0;\n        \n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        bar.leave(requiredSharesBalance);\n\n        uint256 sushiAfterBalance = sushi.balanceOf(address(this));\n        \n        uint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        sushi.transfer(msg.sender, sushiBalanceDiff);\n        \n        return (sushiBalanceDiff);\n    }\n\n}\n\n",
        "CodeNames": [
            "BadgerYieldSource.sol",
            "SushiYieldSource.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "contracts BadgerYieldSource and SushiYieldSource",
                "Type": "Unchecked return value",
                "Description": "The return values of ERC20 transfer and transferFrom are not checked to be true, which could be false if the transferred tokens are not ERC20-compliant.",
                "Repair": "Use the SafeERC20 library implementation from Openzeppelin and call safeTransfer or safeTransferFrom when transferring ERC20 tokens."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@pooltogether/fixed-point/contracts/FixedPoint.sol\";\n\nimport \"../external/compound/ICompLike.sol\";\nimport \"../reserve/RegistryInterface.sol\";\nimport \"../reserve/ReserveInterface.sol\";\nimport \"../token/TokenListenerInterface.sol\";\nimport \"../token/TokenListenerLibrary.sol\";\nimport \"../token/ControlledToken.sol\";\nimport \"../token/TokenControllerInterface.sol\";\nimport \"../utils/MappedSinglyLinkedList.sol\";\nimport \"./PrizePoolInterface.sol\";\n\n/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.\n/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\nabstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {\n  using SafeMathUpgradeable for uint256;\n  using SafeCastUpgradeable for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;\n  using ERC165CheckerUpgradeable for address;\n\n  /// @dev Emitted when an instance is initialized\n  event Initialized(\n    address reserveRegistry,\n    uint256 maxExitFeeMantissa,\n    uint256 maxTimelockDuration\n  );\n\n  /// @dev Event emitted when controlled token is added\n  event ControlledTokenAdded(\n    ControlledTokenInterface indexed token\n  );\n\n  /// @dev Emitted when reserve is captured.\n  event ReserveFeeCaptured(\n    uint256 amount\n  );\n\n  event AwardCaptured(\n    uint256 amount\n  );\n\n  /// @dev Event emitted when assets are deposited\n  event Deposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount,\n    address referrer\n  );\n\n  /// @dev Event emitted when timelocked funds are re-deposited\n  event TimelockDeposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when interest is awarded to a winner\n  event Awarded(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC20s are awarded to a winner\n  event AwardedExternalERC20(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC20s are transferred out\n  event TransferredExternalERC20(\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC721s are awarded to a winner\n  event AwardedExternalERC721(\n    address indexed winner,\n    address indexed token,\n    uint256[] tokenIds\n  );\n\n  /// @dev Event emitted when assets are withdrawn instantly\n  event InstantWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 redeemed,\n    uint256 exitFee\n  );\n\n  /// @dev Event emitted upon a withdrawal with timelock\n  event TimelockedWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 unlockTimestamp\n  );\n\n  event ReserveWithdrawal(\n    address indexed to,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when timelocked funds are swept back to a user\n  event TimelockedWithdrawalSwept(\n    address indexed operator,\n    address indexed from,\n    uint256 amount,\n    uint256 redeemed\n  );\n\n  /// @dev Event emitted when the Liquidity Cap is set\n  event LiquidityCapSet(\n    uint256 liquidityCap\n  );\n\n  /// @dev Event emitted when the Credit plan is set\n  event CreditPlanSet(\n    address token,\n    uint128 creditLimitMantissa,\n    uint128 creditRateMantissa\n  );\n\n  /// @dev Event emitted when the Prize Strategy is set\n  event PrizeStrategySet(\n    address indexed prizeStrategy\n  );\n\n  /// @dev Emitted when credit is minted\n  event CreditMinted(\n    address indexed user,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Emitted when credit is burned\n  event CreditBurned(\n    address indexed user,\n    address indexed token,\n    uint256 amount\n  );\n\n  struct CreditPlan {\n    uint128 creditLimitMantissa;\n    uint128 creditRateMantissa;\n  }\n\n  struct CreditBalance {\n    uint192 balance;\n    uint32 timestamp;\n    bool initialized;\n  }\n\n  /// @dev Reserve to which reserve fees are sent\n  RegistryInterface public reserveRegistry;\n\n  /// @dev A linked list of all the controlled tokens\n  MappedSinglyLinkedList.Mapping internal _tokens;\n\n  /// @dev The Prize Strategy that this Prize Pool is bound to.\n  TokenListenerInterface public prizeStrategy;\n\n  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.\n  /// For example, if the maxExitFeeMantissa is \"0.1 ether\", then the maximum exit fee for a withdrawal of 100 Dai will be 10 Dai\n  uint256 public maxExitFeeMantissa;\n\n  /// @dev The maximum possible timelock duration for a timelocked withdrawal (in seconds).\n  uint256 public maxTimelockDuration;\n\n  /// @dev The total funds that are timelocked.\n  uint256 public timelockTotalSupply;\n\n  /// @dev The total funds that have been allocated to the reserve\n  uint256 public reserveTotalSupply;\n\n  /// @dev The total amount of funds that the prize pool can hold.\n  uint256 public liquidityCap;\n\n  /// @dev the The awardable balance\n  uint256 internal _currentAwardBalance;\n\n  /// @dev The timelocked balances for each user\n  mapping(address => uint256) internal _timelockBalances;\n\n  /// @dev The unlock timestamps for each user\n  mapping(address => uint256) internal _unlockTimestamps;\n\n  /// @dev Stores the credit plan for each token.\n  mapping(address => CreditPlan) internal _tokenCreditPlans;\n\n  /// @dev Stores each users balance of credit per token.\n  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;\n\n  /// @notice Initializes the Prize Pool\n  /// @param _controlledTokens Array of ControlledTokens that are controlled by this Prize Pool.\n  /// @param _maxExitFeeMantissa The maximum exit fee size\n  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock\n  function initialize (\n    RegistryInterface _reserveRegistry,\n    ControlledTokenInterface[] memory _controlledTokens,\n    uint256 _maxExitFeeMantissa,\n    uint256 _maxTimelockDuration\n  )\n    public\n    initializer\n  {\n    require(address(_reserveRegistry) != address(0), \"PrizePool/reserveRegistry-not-zero\");\n    _tokens.initialize();\n    for (uint256 i = 0; i < _controlledTokens.length; i++) {\n      _addControlledToken(_controlledTokens[i]);\n    }\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    _setLiquidityCap(uint256(-1));\n\n    reserveRegistry = _reserveRegistry;\n    maxExitFeeMantissa = _maxExitFeeMantissa;\n    maxTimelockDuration = _maxTimelockDuration;\n\n    emit Initialized(\n      address(_reserveRegistry),\n      maxExitFeeMantissa,\n      maxTimelockDuration\n    );\n  }\n\n  /// @dev Returns the address of the underlying ERC20 asset\n  /// @return The address of the asset\n  function token() external override view returns (address) {\n    return address(_token());\n  }\n\n  /// @dev Returns the total underlying balance of all assets. This includes both principal and interest.\n  /// @return The underlying balance of assets\n  function balance() external returns (uint256) {\n    return _balance();\n  }\n\n  /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize\n  /// @param _externalToken The address of the token to check\n  /// @return True if the token may be awarded, false otherwise\n  function canAwardExternal(address _externalToken) external view returns (bool) {\n    return _canAwardExternal(_externalToken);\n  }\n\n  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.\n  /// @param to The address receiving the tokens\n  /// @param amount The amount of timelocked assets to re-deposit\n  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)\n  function timelockDepositTo(\n    address to,\n    uint256 amount,\n    address controlledToken\n  )\n    external\n    onlyControlledToken(controlledToken)\n    canAddLiquidity(amount)\n    nonReentrant\n  {\n    address operator = _msgSender();\n    _mint(to, amount, controlledToken, address(0));\n    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);\n    timelockTotalSupply = timelockTotalSupply.sub(amount);\n\n    emit TimelockDeposited(operator, to, controlledToken, amount);\n  }\n\n  /// @notice Deposit assets into the Prize Pool in exchange for tokens\n  /// @param to The address receiving the newly minted tokens\n  /// @param amount The amount of assets to deposit\n  /// @param controlledToken The address of the type of token the user is minting\n  /// @param referrer The referrer of the deposit\n  function depositTo(\n    address to,\n    uint256 amount,\n    address controlledToken,\n    address referrer\n  )\n    external override\n    onlyControlledToken(controlledToken)\n    canAddLiquidity(amount)\n    nonReentrant\n  {\n    address operator = _msgSender();\n\n    _mint(to, amount, controlledToken, referrer);\n\n    _token().safeTransferFrom(operator, address(this), amount);\n    _supply(amount);\n\n    emit Deposited(operator, to, controlledToken, amount, referrer);\n  }\n\n  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.\n  /// @param from The address to redeem tokens from.\n  /// @param amount The amount of tokens to redeem for assets.\n  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)\n  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.\n  /// @return The actual exit fee paid\n  function withdrawInstantlyFrom(\n    address from,\n    uint256 amount,\n    address controlledToken,\n    uint256 maximumExitFee\n  )\n    external override\n    nonReentrant\n    onlyControlledToken(controlledToken)\n    returns (uint256)\n  {\n    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n    require(exitFee <= maximumExitFee, \"PrizePool/exit-fee-exceeds-user-maximum\");\n\n    // burn the credit\n    _burnCredit(from, controlledToken, burnedCredit);\n\n    // burn the tickets\n    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);\n\n    // redeem the tickets less the fee\n    uint256 amountLessFee = amount.sub(exitFee);\n    uint256 redeemed = _redeem(amountLessFee);\n\n    _token().safeTransfer(from, redeemed);\n\n    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);\n\n    return exitFee;\n  }\n\n  /// @notice Limits the exit fee to the maximum as hard-coded into the contract\n  /// @param withdrawalAmount The amount that is attempting to be withdrawn\n  /// @param exitFee The exit fee to check against the limit\n  /// @return The passed exit fee if it is less than the maximum, otherwise the maximum fee is returned.\n  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {\n    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);\n    if (exitFee > maxFee) {\n      exitFee = maxFee;\n    }\n    return exitFee;\n  }\n\n  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.\n  /// The timelock is used to ensure that the tickets have contributed their fair share of the prize.\n  /// @dev Note that if the user has previously timelocked funds then this contract will try to sweep them.\n  /// If the existing timelocked funds are still locked, then the incoming\n  /// balance is added to their existing balance and the new timelock unlock timestamp will overwrite the old one.\n  /// @param from The address to withdraw from\n  /// @param amount The amount to withdraw\n  /// @param controlledToken The type of token being withdrawn\n  /// @return The timestamp from which the funds can be swept\n  function withdrawWithTimelockFrom(\n    address from,\n    uint256 amount,\n    address controlledToken\n  )\n    external override\n    nonReentrant\n    onlyControlledToken(controlledToken)\n    returns (uint256)\n  {\n    uint256 blockTime = _currentTime();\n    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);\n    uint256 unlockTimestamp = blockTime.add(lockDuration);\n    _burnCredit(from, controlledToken, burnedCredit);\n    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);\n    _mintTimelock(from, amount, unlockTimestamp);\n    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);\n\n    // return the block at which the funds will be available\n    return unlockTimestamp;\n  }\n\n  /// @notice Adds to a user's timelock balance.  It will attempt to sweep before updating the balance.\n  /// Note that this will overwrite the previous unlock timestamp.\n  /// @param user The user whose timelock balance should increase\n  /// @param amount The amount to increase by\n  /// @param timestamp The new unlock timestamp\n  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {\n    // Sweep the old balance, if any\n    address[] memory users = new address[](1);\n    users[0] = user;\n    _sweepTimelockBalances(users);\n\n    timelockTotalSupply = timelockTotalSupply.add(amount);\n    _timelockBalances[user] = _timelockBalances[user].add(amount);\n    _unlockTimestamps[user] = timestamp;\n\n    // if the funds should already be unlocked\n    if (timestamp <= _currentTime()) {\n      _sweepTimelockBalances(users);\n    }\n  }\n\n  /// @notice Updates the Prize Strategy when tokens are transferred between holders.\n  /// @param from The address the tokens are being transferred from (0 if minting)\n  /// @param to The address the tokens are being transferred to (0 if burning)\n  /// @param amount The amount of tokens being trasferred\n  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {\n    if (from != address(0)) {\n      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);\n      // first accrue credit for their old balance\n      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);\n\n      if (from != to) {\n        // if they are sending funds to someone else, we need to limit their accrued credit to their new balance\n        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);\n      }\n\n      _updateCreditBalance(from, msg.sender, newCreditBalance);\n    }\n    if (to != address(0) && to != from) {\n      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);\n    }\n    // if we aren't minting\n    if (from != address(0) && address(prizeStrategy) != address(0)) {\n      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);\n    }\n  }\n\n  /// @notice Returns the balance that is available to award.\n  /// @dev captureAwardBalance() should be called first\n  /// @return The total amount of assets to be awarded for the current prize\n  function awardBalance() external override view returns (uint256) {\n    return _currentAwardBalance;\n  }\n\n  /// @notice Captures any available interest as award balance.\n  /// @dev This function also captures the reserve fees.\n  /// @return The total amount of assets to be awarded for the current prize\n  function captureAwardBalance() external override nonReentrant returns (uint256) {\n    uint256 tokenTotalSupply = _tokenTotalSupply();\n\n    // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source\n    uint256 currentBalance = _balance();\n    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;\n    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;\n\n    if (unaccountedPrizeBalance > 0) {\n      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);\n      if (reserveFee > 0) {\n        reserveTotalSupply = reserveTotalSupply.add(reserveFee);\n        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);\n        emit ReserveFeeCaptured(reserveFee);\n      }\n      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);\n\n      emit AwardCaptured(unaccountedPrizeBalance);\n    }\n\n    return _currentAwardBalance;\n  }\n\n  function withdrawReserve(address to) external override onlyReserve returns (uint256) {\n\n    uint256 amount = reserveTotalSupply;\n    reserveTotalSupply = 0;\n    uint256 redeemed = _redeem(amount);\n\n    _token().safeTransfer(address(to), redeemed);\n\n    emit ReserveWithdrawal(to, amount);\n\n    return redeemed;\n  }\n\n  /// @notice Called by the prize strategy to award prizes.\n  /// @dev The amount awarded must be less than the awardBalance()\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of assets to be awarded\n  /// @param controlledToken The address of the asset token being awarded\n  function award(\n    address to,\n    uint256 amount,\n    address controlledToken\n  )\n    external override\n    onlyPrizeStrategy\n    onlyControlledToken(controlledToken)\n  {\n    if (amount == 0) {\n      return;\n    }\n\n    require(amount <= _currentAwardBalance, \"PrizePool/award-exceeds-avail\");\n    _currentAwardBalance = _currentAwardBalance.sub(amount);\n\n    _mint(to, amount, controlledToken, address(0));\n\n    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);\n    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);\n\n    emit Awarded(to, controlledToken, amount);\n  }\n\n  /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens\n  /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of external assets to be awarded\n  /// @param externalToken The address of the external asset token being awarded\n  function transferExternalERC20(\n    address to,\n    address externalToken,\n    uint256 amount\n  )\n    external override\n    onlyPrizeStrategy\n  {\n    if (_transferOut(to, externalToken, amount)) {\n      emit TransferredExternalERC20(to, externalToken, amount);\n    }\n  }\n\n  /// @notice Called by the Prize-Strategy to award external ERC20 prizes\n  /// @dev Used to award any arbitrary tokens held by the Prize Pool\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of external assets to be awarded\n  /// @param externalToken The address of the external asset token being awarded\n  function awardExternalERC20(\n    address to,\n    address externalToken,\n    uint256 amount\n  )\n    external override\n    onlyPrizeStrategy\n  {\n    if (_transferOut(to, externalToken, amount)) {\n      emit AwardedExternalERC20(to, externalToken, amount);\n    }\n  }\n\n  function _transferOut(\n    address to,\n    address externalToken,\n    uint256 amount\n  )\n    internal\n    returns (bool)\n  {\n    require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");\n\n    if (amount == 0) {\n      return false;\n    }\n\n    IERC20Upgradeable(externalToken).safeTransfer(to, amount);\n\n    return true;\n  }\n\n  /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.\n  /// @param to The user who is receiving the tokens\n  /// @param amount The amount of tokens they are receiving\n  /// @param controlledToken The token that is going to be minted\n  /// @param referrer The user who referred the minting\n  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {\n    if (address(prizeStrategy) != address(0)) {\n      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);\n    }\n    ControlledToken(controlledToken).controllerMint(to, amount);\n  }\n\n  /// @notice Called by the prize strategy to award external ERC721 prizes\n  /// @dev Used to award any arbitrary NFTs held by the Prize Pool\n  /// @param to The address of the winner that receives the award\n  /// @param externalToken The address of the external NFT token being awarded\n  /// @param tokenIds An array of NFT Token IDs to be transferred\n  function awardExternalERC721(\n    address to,\n    address externalToken,\n    uint256[] calldata tokenIds\n  )\n    external override\n    onlyPrizeStrategy\n  {\n    require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");\n\n    if (tokenIds.length == 0) {\n      return;\n    }\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);\n    }\n\n    emit AwardedExternalERC721(to, externalToken, tokenIds);\n  }\n\n  /// @notice Calculates the reserve portion of the given amount of funds.  If there is no reserve address, the portion will be zero.\n  /// @param amount The prize amount\n  /// @return The size of the reserve portion of the prize\n  function calculateReserveFee(uint256 amount) public view returns (uint256) {\n    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());\n    if (address(reserve) == address(0)) {\n      return 0;\n    }\n    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));\n    if (reserveRateMantissa == 0) {\n      return 0;\n    }\n    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);\n  }\n\n  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts\n  /// @param users An array of account addresses to sweep balances for\n  /// @return The total amount of assets swept from the Prize Pool\n  function sweepTimelockBalances(\n    address[] calldata users\n  )\n    external override\n    nonReentrant\n    returns (uint256)\n  {\n    return _sweepTimelockBalances(users);\n  }\n\n  /// @notice Sweep available timelocked balances to their owners.  The full balances will be swept to the owners.\n  /// @param users An array of owner addresses\n  /// @return The total amount of assets swept from the Prize Pool\n  function _sweepTimelockBalances(\n    address[] memory users\n  )\n    internal\n    returns (uint256)\n  {\n    address operator = _msgSender();\n\n    uint256[] memory balances = new uint256[](users.length);\n\n    uint256 totalWithdrawal;\n\n    uint256 i;\n    for (i = 0; i < users.length; i++) {\n      address user = users[i];\n      if (_unlockTimestamps[user] <= _currentTime()) {\n        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n        balances[i] = _timelockBalances[user];\n        delete _timelockBalances[user];\n      }\n    }\n\n    // if there is nothing to do, just quit\n    if (totalWithdrawal == 0) {\n      return 0;\n    }\n\n    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);\n\n    uint256 redeemed = _redeem(totalWithdrawal);\n\n    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());\n\n    for (i = 0; i < users.length; i++) {\n      if (balances[i] > 0) {\n        delete _unlockTimestamps[users[i]];\n        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n        underlyingToken.safeTransfer(users[i], transferAmount);\n        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n      }\n    }\n\n    return totalWithdrawal;\n  }\n\n  /// @notice Calculates a timelocked withdrawal duration and credit consumption.\n  /// @param from The user who is withdrawing\n  /// @param amount The amount the user is withdrawing\n  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)\n  /// @return durationSeconds The duration of the timelock in seconds\n  function calculateTimelockDuration(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    external override\n    returns (\n      uint256 durationSeconds,\n      uint256 burnedCredit\n    )\n  {\n    return _calculateTimelockDuration(from, controlledToken, amount);\n  }\n\n  /// @dev Calculates a timelocked withdrawal duration and credit consumption.\n  /// @param from The user who is withdrawing\n  /// @param amount The amount the user is withdrawing\n  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)\n  /// @return durationSeconds The duration of the timelock in seconds\n  /// @return burnedCredit The credit that was burned\n  function _calculateTimelockDuration(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    internal\n    returns (\n      uint256 durationSeconds,\n      uint256 burnedCredit\n    )\n  {\n    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);\n    if (duration > maxTimelockDuration) {\n      duration = maxTimelockDuration;\n    }\n    return (duration, _burnedCredit);\n  }\n\n  /// @notice Calculates the early exit fee for the given amount\n  /// @param from The user who is withdrawing\n  /// @param controlledToken The type of collateral being withdrawn\n  /// @param amount The amount of collateral to be withdrawn\n  /// @return exitFee The exit fee\n  /// @return burnedCredit The user's credit that was burned\n  function calculateEarlyExitFee(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    external override\n    returns (\n      uint256 exitFee,\n      uint256 burnedCredit\n    )\n  {\n    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n  }\n\n  /// @dev Calculates the early exit fee for the given amount\n  /// @param amount The amount of collateral to be withdrawn\n  /// @return Exit fee\n  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {\n    return _limitExitFee(\n      amount,\n      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)\n    );\n  }\n\n  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.\n  /// @param _principal The principal amount on which interest is accruing\n  /// @param _interest The amount of interest that must accrue\n  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.\n  function estimateCreditAccrualTime(\n    address _controlledToken,\n    uint256 _principal,\n    uint256 _interest\n  )\n    external override\n    view\n    returns (uint256 durationSeconds)\n  {\n    return _estimateCreditAccrualTime(\n      _controlledToken,\n      _principal,\n      _interest\n    );\n  }\n\n  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit\n  /// @param _principal The principal amount on which interest is accruing\n  /// @param _interest The amount of interest that must accrue\n  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.\n  function _estimateCreditAccrualTime(\n    address _controlledToken,\n    uint256 _principal,\n    uint256 _interest\n  )\n    internal\n    view\n    returns (uint256 durationSeconds)\n  {\n    // interest = credit rate * principal * time\n    // => time = interest / (credit rate * principal)\n    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);\n    if (accruedPerSecond == 0) {\n      return 0;\n    }\n    return _interest.div(accruedPerSecond);\n  }\n\n  /// @notice Burns a users credit.\n  /// @param user The user whose credit should be burned\n  /// @param credit The amount of credit to burn\n  function _burnCredit(address user, address controlledToken, uint256 credit) internal {\n    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();\n\n    emit CreditBurned(user, controlledToken, credit);\n  }\n\n  /// @notice Accrues ticket credit for a user assuming their current balance is the passed balance.  May burn credit if they exceed their limit.\n  /// @param user The user for whom to accrue credit\n  /// @param controlledToken The controlled token whose balance we are checking\n  /// @param controlledTokenBalance The balance to use for the user\n  /// @param extra Additional credit to be added\n  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {\n    _updateCreditBalance(\n      user,\n      controlledToken,\n      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)\n    );\n  }\n\n  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {\n    uint256 newBalance;\n    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];\n    if (!creditBalance.initialized) {\n      newBalance = 0;\n    } else {\n      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);\n      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));\n    }\n    return newBalance;\n  }\n\n  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {\n    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;\n\n    _tokenCreditBalances[controlledToken][user] = CreditBalance({\n      balance: newBalance.toUint128(),\n      timestamp: _currentTime().toUint32(),\n      initialized: true\n    });\n\n    if (oldBalance < newBalance) {\n      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));\n    } else {\n      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));\n    }\n  }\n\n  /// @notice Applies the credit limit to a credit balance.  The balance cannot exceed the credit limit.\n  /// @param controlledToken The controlled token that the user holds\n  /// @param controlledTokenBalance The users ticket balance (used to calculate credit limit)\n  /// @param creditBalance The new credit balance to be checked\n  /// @return The users new credit balance.  Will not exceed the credit limit.\n  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {\n    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(\n      controlledTokenBalance,\n      _tokenCreditPlans[controlledToken].creditLimitMantissa\n    );\n    if (creditBalance > creditLimit) {\n      creditBalance = creditLimit;\n    }\n\n    return creditBalance;\n  }\n\n  /// @notice Calculates the accrued interest for a user\n  /// @param user The user whose credit should be calculated.\n  /// @param controlledToken The controlled token that the user holds\n  /// @param controlledTokenBalance The user's current balance of the controlled tokens.\n  /// @return The credit that has accrued since the last credit update.\n  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {\n    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;\n\n    if (!_tokenCreditBalances[controlledToken][user].initialized) {\n      return 0;\n    }\n\n    uint256 deltaTime = _currentTime().sub(userTimestamp);\n    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);\n    return deltaTime.mul(creditPerSecond);\n  }\n\n  /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.\n  /// @param user The user whose credit balance should be returned\n  /// @return The balance of the users credit\n  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {\n    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);\n    return _tokenCreditBalances[controlledToken][user].balance;\n  }\n\n  /// @notice Sets the rate at which credit accrues per second.  The credit rate is a fixed point 18 number (like Ether).\n  /// @param _controlledToken The controlled token for whom to set the credit plan\n  /// @param _creditRateMantissa The credit rate to set.  Is a fixed point 18 decimal (like Ether).\n  /// @param _creditLimitMantissa The credit limit to set.  Is a fixed point 18 decimal (like Ether).\n  function setCreditPlanOf(\n    address _controlledToken,\n    uint128 _creditRateMantissa,\n    uint128 _creditLimitMantissa\n  )\n    external override\n    onlyControlledToken(_controlledToken)\n    onlyOwner\n  {\n    _tokenCreditPlans[_controlledToken] = CreditPlan({\n      creditLimitMantissa: _creditLimitMantissa,\n      creditRateMantissa: _creditRateMantissa\n    });\n\n    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);\n  }\n\n  /// @notice Returns the credit rate of a controlled token\n  /// @param controlledToken The controlled token to retrieve the credit rates for\n  /// @return creditLimitMantissa The credit limit fraction.  This number is used to calculate both the credit limit and early exit fee.\n  /// @return creditRateMantissa The credit rate. This is the amount of tokens that accrue per second.\n  function creditPlanOf(\n    address controlledToken\n  )\n    external override\n    view\n    returns (\n      uint128 creditLimitMantissa,\n      uint128 creditRateMantissa\n    )\n  {\n    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;\n    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;\n  }\n\n  /// @notice Calculate the early exit for a user given a withdrawal amount.  The user's credit is taken into account.\n  /// @param from The user who is withdrawing\n  /// @param controlledToken The token they are withdrawing\n  /// @param amount The amount of funds they are withdrawing\n  /// @return earlyExitFee The additional exit fee that should be charged.\n  /// @return creditBurned The amount of credit that will be burned\n  function _calculateEarlyExitFeeLessBurnedCredit(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    internal\n    returns (\n      uint256 earlyExitFee,\n      uint256 creditBurned\n    )\n  {\n    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);\n    require(controlledTokenBalance >= amount, \"PrizePool/insuff-funds\");\n    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);\n    /*\n    The credit is used *last*.  Always charge the fees up-front.\n\n    How to calculate:\n\n    Calculate their remaining exit fee.  I.e. full exit fee of their balance less their credit.\n\n    If the exit fee on their withdrawal is greater than the remaining exit fee, then they'll have to pay the difference.\n    */\n\n    // Determine available usable credit based on withdraw amount\n    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));\n\n    uint256 availableCredit;\n    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {\n      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);\n    }\n\n    // Determine amount of credit to burn and amount of fees required\n    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);\n    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;\n    earlyExitFee = totalExitFee.sub(creditBurned);\n    return (earlyExitFee, creditBurned);\n  }\n\n  /// @notice Allows the Governor to set a cap on the amount of liquidity that he pool can hold\n  /// @param _liquidityCap The new liquidity cap for the prize pool\n  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {\n    _setLiquidityCap(_liquidityCap);\n  }\n\n  function _setLiquidityCap(uint256 _liquidityCap) internal {\n    liquidityCap = _liquidityCap;\n    emit LiquidityCapSet(_liquidityCap);\n  }\n\n  /// @notice Adds a new controlled token\n  /// @param _controlledToken The controlled token to add.  Cannot be a duplicate.\n  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {\n    require(_controlledToken.controller() == this, \"PrizePool/token-ctrlr-mismatch\");\n    _tokens.addAddress(address(_controlledToken));\n\n    emit ControlledTokenAdded(_controlledToken);\n  }\n\n  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.\n  /// @param _prizeStrategy The new prize strategy\n  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {\n    _setPrizeStrategy(_prizeStrategy);\n  }\n\n  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.\n  /// @param _prizeStrategy The new prize strategy\n  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {\n    require(address(_prizeStrategy) != address(0), \"PrizePool/prizeStrategy-not-zero\");\n    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), \"PrizePool/prizeStrategy-invalid\");\n    prizeStrategy = _prizeStrategy;\n\n    emit PrizeStrategySet(address(_prizeStrategy));\n  }\n\n  /// @notice An array of the Tokens controlled by the Prize Pool (ie. Tickets, Sponsorship)\n  /// @return An array of controlled token addresses\n  function tokens() external override view returns (address[] memory) {\n    return _tokens.addressArray();\n  }\n\n  /// @dev Gets the current time as represented by the current block\n  /// @return The timestamp of the current block\n  function _currentTime() internal virtual view returns (uint256) {\n    return block.timestamp;\n  }\n\n  /// @notice The timestamp at which an account's timelocked balance will be made available to sweep\n  /// @param user The address of an account with timelocked assets\n  /// @return The timestamp at which the locked assets will be made available\n  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {\n    return _unlockTimestamps[user];\n  }\n\n  /// @notice The balance of timelocked assets for an account\n  /// @param user The address of an account with timelocked assets\n  /// @return The amount of assets that have been timelocked\n  function timelockBalanceOf(address user) external override view returns (uint256) {\n    return _timelockBalances[user];\n  }\n\n  /// @notice The total of all controlled tokens and timelock.\n  /// @return The current total of all tokens and timelock.\n  function accountedBalance() external override view returns (uint256) {\n    return _tokenTotalSupply();\n  }\n\n  /// @notice Delegate the votes for a Compound COMP-like token held by the prize pool\n  /// @param compLike The COMP-like token held by the prize pool that should be delegated\n  /// @param to The address to delegate to \n  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {\n    if (compLike.balanceOf(address(this)) > 0) {\n      compLike.delegate(to);\n    }\n  }\n\n  /// @notice The total of all controlled tokens and timelock.\n  /// @return The current total of all tokens and timelock.\n  function _tokenTotalSupply() internal view returns (uint256) {\n    uint256 total = timelockTotalSupply.add(reserveTotalSupply);\n    address currentToken = _tokens.start();\n    while (currentToken != address(0) && currentToken != _tokens.end()) {\n      total = total.add(IERC20Upgradeable(currentToken).totalSupply());\n      currentToken = _tokens.next(currentToken);\n    }\n    return total;\n  }\n\n  /// @dev Checks if the Prize Pool can receive liquidity based on the current cap\n  /// @param _amount The amount of liquidity to be added to the Prize Pool\n  /// @return True if the Prize Pool can receive the specified amount of liquidity\n  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {\n    uint256 tokenTotalSupply = _tokenTotalSupply();\n    return (tokenTotalSupply.add(_amount) <= liquidityCap);\n  }\n\n  /// @dev Checks if a specific token is controlled by the Prize Pool\n  /// @param controlledToken The address of the token to check\n  /// @return True if the token is a controlled token, false otherwise\n  function _isControlled(address controlledToken) internal view returns (bool) {\n    return _tokens.contains(controlledToken);\n  }\n\n  /// @notice Determines whether the passed token can be transferred out as an external award.\n  /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The\n  /// prize strategy should not be allowed to move those tokens.\n  /// @param _externalToken The address of the token to check\n  /// @return True if the token may be awarded, false otherwise\n  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);\n\n  /// @notice Returns the ERC20 asset token used for deposits.\n  /// @return The ERC20 asset token\n  function _token() internal virtual view returns (IERC20Upgradeable);\n\n  /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n  /// @return The underlying balance of asset tokens\n  function _balance() internal virtual returns (uint256);\n\n  /// @notice Supplies asset tokens to the yield source.\n  /// @param mintAmount The amount of asset tokens to be supplied\n  function _supply(uint256 mintAmount) internal virtual;\n\n  /// @notice Redeems asset tokens from the yield source.\n  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed\n  /// @return The actual amount of tokens that were redeemed.\n  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);\n\n  /// @dev Function modifier to ensure usage of tokens controlled by the Prize Pool\n  /// @param controlledToken The address of the token to check\n  modifier onlyControlledToken(address controlledToken) {\n    require(_isControlled(controlledToken), \"PrizePool/unknown-token\");\n    _;\n  }\n\n  /// @dev Function modifier to ensure caller is the prize-strategy\n  modifier onlyPrizeStrategy() {\n    require(_msgSender() == address(prizeStrategy), \"PrizePool/only-prizeStrategy\");\n    _;\n  }\n\n  /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)\n  modifier canAddLiquidity(uint256 _amount) {\n    require(_canAddLiquidity(_amount), \"PrizePool/exceeds-liquidity-cap\");\n    _;\n  }\n\n  modifier onlyReserve() {\n    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());\n    require(address(reserve) == msg.sender, \"PrizePool/only-reserve\");\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "PrizePool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function awardExternalERC721 of contract PrizePool",
                "Type": "Use of transferFrom on ERC721 tokens",
                "Description": "If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.",
                "Repair": "Consider changing transferFrom to safeTransferFrom."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/pooltogether/IProtocolYieldSource.sol\";\nimport \"./interfaces/idle/IIdleToken.sol\";\nimport \"./access/AssetManager.sol\";\n\n/// @title An pooltogether yield source for Idle token\n/// @author Sunny Radadiya\ncontract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public idleToken;\n    address public underlyingAsset;\n    uint256 public constant ONE_IDLE_TOKEN = 10**18;\n\n    /// @notice Emitted when the yield source is initialized\n    event IdleYieldSourceInitialized(address indexed idleToken);\n\n    /// @notice Emitted when asset tokens are redeemed from the yield source\n    event RedeemedToken(\n        address indexed from,\n        uint256 shares,\n        uint256 amount\n    );\n\n    /// @notice Emitted when asset tokens are supplied to the yield source\n    event SuppliedTokenTo(\n        address indexed from,\n        uint256 shares,\n        uint256 amount,\n        address indexed to\n    );\n\n    /// @notice Emitted when asset tokens are supplied to sponsor the yield source\n    event Sponsored(\n        address indexed from,\n        uint256 amount\n    );\n\n    /// @notice Emitted when ERC20 tokens other than yield source's idleToken are withdrawn from the yield source\n    event TransferredERC20(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        address indexed token\n    );\n\n    /// @notice Initializes the yield source with Idle Token\n    /// @param _idleToken Idle Token address\n    function initialize(\n        address _idleToken\n    ) public initializer {\n\n        __Ownable_init();\n\n        idleToken = _idleToken;\n        underlyingAsset = IIdleToken(idleToken).token();\n\n        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);\n        emit IdleYieldSourceInitialized(idleToken);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() external view override returns (address) {\n        return underlyingAsset;\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) external view override returns (uint256) {\n        return _sharesToToken(balanceOf(addr));\n    }\n\n    /// @notice Calculates the balance of Total idle Tokens Contract hasv\n    /// @return balance of Idle Tokens\n    function _totalShare() internal view returns(uint256) {\n        return IIdleToken(idleToken).balanceOf(address(this));\n    }\n\n    /// @notice Calculates the number of shares that should be mint or burned when a user deposit or withdraw\n    /// @param tokens Amount of tokens\n    /// return Number of shares\n    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {\n        shares = (tokens * ONE_IDLE_TOKEN) / _price();\n    }\n\n    /// @notice Calculates the number of tokens a user has in the yield source\n    /// @param shares Amount of shares\n    /// return Number of tokens\n    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { \n        tokens = (shares * _price()) / ONE_IDLE_TOKEN;\n    }\n\n    /// @notice Calculates the current price per share\n    /// @return avg idleToken price for this contract\n    function _price() internal view returns (uint256) {\n      return IIdleToken(idleToken).tokenPriceWithFee(address(this));\n    }\n\n    /// @notice Deposit asset tokens to Idle\n    /// @param mintAmount The amount of asset tokens to be deposited\n    /// @return number of minted tokens\n    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {\n        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);\n        return IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));\n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param mintAmount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 mintAmount, address to) external nonReentrant override {\n        uint256 mintedTokenShares = _tokenToShares(mintAmount);\n        _depositToIdle(mintAmount);\n        _mint(to, mintedTokenShares);\n        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);\n    }\n\n    /// @notice Redeems tokens from the yield source from the msg.sender, it burn yield bearing tokens and return token to the sender.\n    /// @param redeemAmount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @return redeemedUnderlyingAsset The actual amount of tokens that were redeemed.\n    function redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256 redeemedUnderlyingAsset) {\n        uint256 redeemedShare = _tokenToShares(redeemAmount);\n        _burn(msg.sender, redeemedShare);\n        redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(redeemedShare);        \n        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);\n        emit RedeemedToken(msg.sender, redeemedShare, redeemAmount);\n    }\n\n    /// @notice Transfer ERC20 tokens other than the idleTokens held by this contract to the recipient address\n    /// @dev This function is only callable by the owner or asset manager\n    /// @param erc20Token The ERC20 token to transfer\n    /// @param to The recipient of the tokens\n    /// @param amount The amount of tokens to transfer\n    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {\n        require(erc20Token != idleToken, \"IdleYieldSource/idleDai-transfer-not-allowed\");\n        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);\n        emit TransferredERC20(msg.sender, to, amount, erc20Token);\n    }\n\n    /// @notice Allows someone to deposit into the yield source without receiving any shares\n    /// @dev This allows anyone to distribute tokens among the share holders\n    /// @param amount The amount of tokens to deposit\n    function sponsor(uint256 amount) external override {\n        _depositToIdle(amount);\n        emit Sponsored(msg.sender, amount);\n    }\n}\n\n",
        "CodeNames": [
            "IdleYieldSource.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "redeemToken function in IdleYieldSource",
                "Type": "Loss of underlying tokens",
                "Description": "Users could get fewer underlying tokens than they should.",
                "Repair": "Change redeemedShare to redeemAmount."
            },
            {
                "Location": "IdleYieldSource contract",
                "Type": "High Severity",
                "Description": "Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.",
                "Repair": "Implement mantissa calculations like in the contract for the AAVE yield"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_yieldSource prior to the depositToken function existence hack for determining yield source contract",
                "Type": "Actual yield source check on address will succeed for non-existent contract",
                "Description": "The staticcall here will return True even if the _yieldSource contract doesn't exist at any incorrect-but-not-zero address.",
                "Repair": "Perform a contract existence check on _yieldSource prior to the depositToken function existence hack for determining yield source contract."
            },
            {
                "Location": "_depositInVault() function for Yearn yield source",
                "Type": "Use of safeApprove()",
                "Description": "The\u00a0safeApprove function\u00a0prevents changing an allowance between non-zero values\u00a0to mitigate a\u00a0possible front-running attack.",
                "Repair": "Use safeIncreaseAllowance() function instead of safeApprove()."
            },
            {
                "Location": "yield source contracts",
                "Type": "Incomplete use of SafeMath",
                "Description": "SafeMath is not completely used at some lines of yield source contracts, which could potentially cause arithmetic underflow and overflow.",
                "Repair": "Use the SafeMath library functions in the lines mentioned."
            },
            {
                "Location": "YieldSourcePrizePool_canAwardExternal function",
                "Type": "Medium Severity",
                "Description": "The _canAwardExternal function does not work as expected. It might be possible to award the interest-bearing token which would lead to errors and loss of funds when trying to redeem underlying.",
                "Repair": "Add a function to return the interest-bearing token similar to depositToken() function"
            },
            {
                "Location": "withdrawWithTimelockFrom function",
                "Type": "High Severity",
                "Description": "One can withdraw the entire PrizePool deposit by circumventing the timelock, leading to significant issues for the protocol. The unlock timestamp should be increased by duration each time, instead of being reset to the duration.",
                "Repair": "Increase the unlock timestamp by duration each time instead of resetting it to the duration"
            },
            {
                "Location": "timelockDepositTo function",
                "Type": "Medium Severity",
                "Description": "The timelock deposits and withdrawals are made to/from different addresses in the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, and so the deposits of timelocked tokens will fail because the operator\u2019s address does not have the required amount of _timelockBalances.",
                "Repair": "Change operator to from on L281 of timelockDepositTo function and specify the scenarios where the role of the operator is applicable and document/implement those accordingly"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\nimport \"../interfaces/IYieldSource.sol\";\nimport \"../external/yearn/IYVaultV2.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\n\n/// @title Yield source for a PoolTogether prize pool that generates yield by depositing into Yearn Vaults.\n/// @dev This contract inherits from the ERC20 implementation to keep track of users deposits\n/// @dev This is a generic contract that will work with main Yearn Vaults. Vaults using v0.3.2 to v0.3.4 included\n/// @dev are not compatible, as they had dips in shareValue due to a small miscalculation\n/// @notice Yield Source Prize Pools subclasses need to implement this interface so that yield can be generated.\ncontract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMathUpgradeable for uint;\n    \n    /// @notice Yearn Vault which manages `token` to generate yield\n    IYVaultV2 public vault;\n    /// @dev Deposit Token contract address\n    IERC20Upgradeable internal token; \n    /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS\n    uint256 public maxLosses = 0; // 100% would be 10_000\n\n    /// @notice Emitted when asset tokens are supplied to sponsor the yield source\n    event Sponsored(\n        address indexed user,\n        uint256 amount\n    );\n    \n    /// @notice Emitted when the yield source is initialized\n    event YieldSourceYearnV2Initialized(\n        IYVaultV2 vault,\n        IERC20Upgradeable token\n    );\n\n    /// @notice Emitted when the Max Losses accepted when withdrawing from yVault are changed\n    event MaxLossesChanged(\n        uint256 newMaxLosses\n    );\n\n    /// @notice Emitted when asset tokens are supplied to the yield source\n    event SuppliedTokenTo(\n        address indexed from,\n        uint256 shares,\n        uint256 amount,\n        address indexed to\n    );\n\n    /// @notice Emitted when asset tokens are redeemed from the yield source\n    event RedeemedToken(\n        address indexed from,\n        uint256 shares,\n        uint256 amount\n    );\n\n    /// @notice Initializes the yield source with \n    /// @param _vault YearnV2 Vault in which the Yield Source will deposit `token` to generate Yield\n    /// @param _token Underlying Token / Deposit Token\n    function initialize(\n        IYVaultV2 _vault,\n        IERC20Upgradeable _token\n    ) \n        public \n        initializer\n    {\n        require(address(vault) == address(0), \"YearnV2YieldSource:: already initialized\");\n        require(_vault.token() == address(_token), \"YearnV2YieldSource:: incorrect vault\");\n        require(_vault.activation() != uint256(0), \"YearnV2YieldSource:: vault not initialized\");\n        // NOTE: Vaults from 0.3.2 to 0.3.4 have dips in shareValue\n        require(!areEqualStrings(_vault.apiVersion(), \"0.3.2\"), \"YearnV2YieldSource:: vault not compatible\");\n        require(!areEqualStrings(_vault.apiVersion(), \"0.3.3\"), \"YearnV2YieldSource:: vault not compatible\");\n        require(!areEqualStrings(_vault.apiVersion(), \"0.3.4\"), \"YearnV2YieldSource:: vault not compatible\");\n\n        vault = _vault;\n        token = _token;\n\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        _token.safeApprove(address(vault), type(uint256).max);\n\n        emit YieldSourceYearnV2Initialized(\n            _vault,\n            _token\n        );\n    }\n\n    function setMaxLosses(uint256 _maxLosses) external onlyOwner {\n        require(_maxLosses <= 10_000, \"YearnV2YieldSource:: losses set too high\");\n\n        maxLosses = _maxLosses;\n\n        emit MaxLossesChanged(_maxLosses);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits\n    /// @return The ERC20 asset token address\n    function depositToken() external view override returns (address) {\n        return address(token);\n    }\n\n    /// @notice Returns user total balance (in asset tokens). This includes the deposits and interest.\n    /// @param addr User address\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) external override returns (uint256) {\n        return _sharesToToken(balanceOf(addr));\n    }\n\n    /// @notice Supplies asset tokens to the yield source\n    /// @dev Shares corresponding to the number of tokens supplied are mint to the user's balance\n    /// @dev Asset tokens are supplied to the yield source, then deposited into Aave\n    /// @param _amount The amount of asset tokens to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {\n        uint256 shares = _tokenToShares(_amount);\n\n        _mint(to, shares);\n\n        // NOTE: we have to deposit after calculating shares to mint\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        _depositInVault();\n\n        emit SuppliedTokenTo(msg.sender, shares, _amount, to);\n    }\n\n    /// @notice Redeems asset tokens from the yield source\n    /// @dev Shares corresponding to the number of tokens withdrawn are burnt from the user's balance\n    /// @dev Asset tokens are withdrawn from Yearn's Vault, then transferred from the yield source to the user's wallet\n    /// @param amount The amount of asset tokens to be redeemed\n    /// @return The actual amount of tokens that were redeemed\n    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {\n        uint256 shares = _tokenToShares(amount);\n\n        uint256 withdrawnAmount = _withdrawFromVault(amount);\n\n        _burn(msg.sender, shares);\n\n        token.safeTransfer(msg.sender, withdrawnAmount);\n\n        emit RedeemedToken(msg.sender, shares, amount);\n        return withdrawnAmount;\n    }\n\n    /// @notice Allows someone to deposit into the yield source without receiving any shares\n    /// @dev This allows anyone to distribute tokens among the share holders\n    /// @param amount The amount of tokens to deposit\n    function sponsor(uint256 amount) external nonReentrant {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        _depositInVault();\n\n        emit Sponsored(msg.sender, amount);\n    }\n\n    // ************************ INTERNAL FUNCTIONS ************************\n\n    /// @notice Deposits full balance (or max available deposit) into Yearn's Vault\n    /// @dev if deposit limit is reached, tokens will remain in the Yield Source and\n    /// @dev they will be queued for retries in subsequent deposits\n    /// @return The actual amount of shares that were received for the deposited tokens\n    function _depositInVault() internal returns (uint256) {\n        IYVaultV2 v = vault; // NOTE: for gas usage\n        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {\n            token.safeApprove(address(v), type(uint256).max);\n        }\n        // this will deposit full balance (for cases like not enough room in Vault)\n        return v.deposit();\n    }\n\n    /// @notice Withdraws requested amount from Vault\n    /// @dev Vault withdrawal function required amount of shares to be redeemed\n    /// @dev Losses are accepted by the Yield Source to avoid funds being locked in the Vault if something happened\n    /// @param amount amount of asset tokens to be redeemed\n    /// @return Tokens received from the Vault\n    function _withdrawFromVault(uint amount) internal returns (uint256) {\n        uint256 yShares = _tokenToYShares(amount);\n        uint256 previousBalance = token.balanceOf(address(this));\n        // we accept losses to avoid being locked in the Vault (if losses happened for some reason)\n        if(maxLosses != 0) {\n            vault.withdraw(yShares, address(this), maxLosses);\n        } else {\n            vault.withdraw(yShares);\n        }\n        uint256 currentBalance = token.balanceOf(address(this));\n\n        return previousBalance.sub(currentBalance);\n    }\n\n    /// @notice Returns the amount of shares of yearn's vault that the Yield Source holds\n    /// @return Balance of vault's shares holded by Yield Source\n    function _balanceOfYShares() internal view returns (uint256) {\n        return vault.balanceOf(address(this));\n    }\n\n    /// @notice Ratio between yShares and underlying token\n    /// @dev use this to convert from shares to deposit tokens and viceversa\n    /// @dev (see _tokenToYShares & _ySharesToToken)\n    /// @return Price per vault's share\n    function _pricePerYShare() internal view returns (uint256) {\n        return vault.pricePerShare();\n    }\n\n    /// @notice Balance of deposit token held in the Yield Source\n    /// @return balance of deposit token\n    function _balanceOfToken() internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Total Assets under Management by Yield Source, denominated in Deposit Token\n    /// @dev amount of deposit token held in Yield Source + investment (amount held in Yearn's Vault)\n    /// @return Total AUM denominated in deposit Token\n    function _totalAssetsInToken() internal view returns (uint256) {\n        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));\n    }\n\n    /// @notice Support function to retrieve used by Vault\n    /// @dev used to correctly scale prices \n    /// @return decimals of vault's shares (and underlying token)\n    function _vaultDecimals() internal view returns (uint256) {\n        return vault.decimals();\n    }\n\n    // ************************ CALCS ************************\n\n    /// @notice Converter from deposit token to yShares (yearn vault's shares)\n    /// @param tokens Amount of tokens to be converted\n    /// @return yShares to redeem to receive `tokens` deposit token\n    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {\n        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());\n    }\n\n    /// @notice Converter from deposit yShares (yearn vault's shares) to token \n    /// @param yShares Vault's shares to be converted\n    /// @return tokens that will be received if yShares shares are redeemed\n    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {\n        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());\n    }\n\n    /// @notice Function to calculate the amount of Yield Source shares equivalent to a deposit tokens amount\n    /// @param tokens amount of tokens to be converted\n    /// @return shares number of shares equivalent to the amount of tokens\n    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {\n        if(totalSupply() == 0) {\n            shares = tokens;\n        } else {\n            uint256 _totalTokens = _totalAssetsInToken();\n            shares = tokens.mul(totalSupply()).div(_totalTokens);\n        }\n    }\n\n    /// @notice Function to calculate the amount of Deposit Tokens equivalent to a Yield Source shares amount\n    /// @param shares amount of Yield Source shares to be converted\n    /// @dev used to calculate how many shares to mint / burn when depositing / withdrawing\n    /// @return tokens number of tokens equivalent (in value) to the amount of Yield Source shares\n    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {\n        if(totalSupply() == 0) {\n            tokens = shares;\n        } else {\n            uint256 _totalTokens = _totalAssetsInToken();\n            tokens = shares.mul(_totalTokens).div(totalSupply());\n        }\n    }\n\n    /// @notice Pure support function to compare strings\n    /// @param a One string\n    /// @param b Another string\n    /// @return Whether or not the strings are the same or not\n    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n}\n\n",
        "CodeNames": [
            "YearnV2YieldSource.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "YearnV2YieldSource wrong subtraction in withdraw",
                "Type": "Wrong subtraction",
                "Description": "All vault withdrawals fail due to the integer underflow as the previousBalance is less than currentBalance.",
                "Repair": "Return currentBalance - previousBalance instead of previousBalance.sub(currentBalance)."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./IBadgerSett.sol\";\nimport \"./IBadger.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title A pooltogether yield source for badger sett\n/// @author Steffel Fenix, 0xkarl\ncontract BadgerYieldSource is IYieldSource {\n    using SafeMath for uint256;\n    IBadgerSett private immutable badgerSett;\n    IBadger private immutable badger;\n    mapping(address => uint256) private balances;\n\n    constructor(address badgerSettAddr, address badgerAddr) public {\n        badgerSett = IBadgerSett(badgerSettAddr);\n        badger = IBadger(badgerAddr);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return (address(badger));\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = badgerSett.totalSupply();\n        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));\n        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));\n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        badger.transferFrom(msg.sender, address(this), amount);\n        badger.approve(address(badgerSett), amount);\n\n        uint256 beforeBalance = badgerSett.balanceOf(address(this));\n        badgerSett.deposit(amount);\n        uint256 afterBalance = badgerSett.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @return The actual amount of tokens that were redeemed.\n    function redeemToken(uint256 amount) public override returns (uint256) {\n        uint256 totalShares = badgerSett.totalSupply();\n        if (totalShares == 0) return 0;\n\n        uint256 badgerSettBadgerBalance = badgerSett.balance();\n        if (badgerSettBadgerBalance == 0) return 0;\n\n        uint256 badgerBeforeBalance = badger.balanceOf(address(this));\n\n        uint256 requiredShares =\n            ((amount.mul(totalShares) + totalShares)).div(\n                badgerSettBadgerBalance\n            );\n        if (requiredShares == 0) return 0;\n\n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        badgerSett.withdraw(requiredSharesBalance);\n\n        uint256 badgerAfterBalance = badger.balanceOf(address(this));\n        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        badger.transfer(msg.sender, badgerBalanceDiff);\n        return (badgerBalanceDiff);\n    }\n}\n\n",
        "CodeNames": [
            "BadgerYieldSource.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BadgerYieldSource balanceOfToken function",
                "Type": "High Severity",
                "Description": "The balanceOfToken function computes the redeemable balance in badger for the user's badgerSett balance, but it under-reports the actual balance due to not accounting for the balance in the Sett, the Controller, and the Strategy.",
                "Repair": "Use badgerSett.balance() instead of badger.balanceOf(address(badgerSett)) to account for the balance in the Sett, the Controller, and the Strategy"
            }
        ]
    }
]