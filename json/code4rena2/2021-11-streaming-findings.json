[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC20.sol\";\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\nabstract contract LockeERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    uint32 public immutable transferStartTime;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                           EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address depositToken,\n        uint256 streamId,\n        uint32 endStream\n    ) {\n\n        // locke + depositTokenName + streamId = lockeUSD Coin-1\n        name = string(abi.encodePacked(\"locke\", ERC20(depositToken).name(), \": \", toString(streamId)));\n        // locke + Symbol + streamId = lockeUSDC1\n        // TODO: we could have start_time+stream_duration+depositlocktime as maturity-date\n        // i.e. lockeETH8-AUG-14-2022\n        symbol = string(abi.encodePacked(\"locke\", ERC20(depositToken).symbol(), toString(streamId)));\n        decimals = 18;\n\n        transferStartTime = endStream;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    modifier transferabilityDelay {\n        // ensure the time is after start time\n        require(block.timestamp >= transferStartTime, \"stream\");\n        _;\n    }\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) transferabilityDelay public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) transferabilityDelay public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= amount;\n        }\n\n        balanceOf[from] -= amount;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // This is safe because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_PERMIT_SIGNATURE\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // This is safe because a user won't ever\n        // have a balance larger than totalSupply!\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n\n    // Helpers\n    function toString(uint _i)\n        internal\n        pure\n        returns (string memory) \n    {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\n\n",
        "CodeNames": [
            "LockeERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LockeERC20 contract's approve() function",
                "Type": "frontrun attack",
                "Description": "A user can steal another user's tokens if he frontrun before he changes the allowance.",
                "Repair": "Change the approve function to either accept the old amount of allowance and require the current allowance to be equal to that, or change to two different functions that increase and decrease the allowance instead of straight on changing it."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Streaming contract's recoverTokens() function",
                "Type": "logic issue",
                "Description": "recoverTokens doesn't work when isSale is true.",
                "Repair": "Set redeemedDepositTokens to be depositTokenAmount in the function creatorClaimSoldTokens, since claiming the sold tokens is like 'redeeming' them in a sense. This would fix the logic issue in recoverTokens."
            },
            {
                "Location": "Streaming contract's recoverTokens() function",
                "Type": "token theft",
                "Description": "Tokens can be stolen when depositToken == rewardToken.",
                "Repair": "Add a special case for recoverTokens when token == depositToken == rewardToken and then the excess should be ERC20(token).balanceOf(address(this)) - (depositTokenAmount + redeemedDepositTokens + rewardTokenAmount + rewardTokenFeeAmount);"
            },
            {
                "Location": "Streaming contract's recoverTokens() function",
                "Type": "token theft",
                "Description": "Reward token not correctly recovered.",
                "Repair": "Track the claimed rewards as well, just like the claimed deposits are tracked. Decrease rewardTokenAmount in claimReward because at this point rewardTokenAmount is not used to update the cumulativeRewardPerToken anymore."
            },
            {
                "Location": "Streaming contract's arbitraryCall() and recoverTokens() functions",
                "Type": "token theft",
                "Description": "Any arbitraryCall gathered airdrop can be stolen with recoverTokens.",
                "Repair": "Add airdrop tokens balance mapping, record what is gathered in arbitraryCall and prohibit their free withdrawal in recoverTokens similarly to incentives[]."
            },
            {
                "Location": "Creating rewardTokens without streaming depositTokens",
                "Type": "High Severity",
                "Description": "Attackers can create loss of funds for (honest) stakers.",
                "Repair": "Make the line dependable on a positive amount 0 of the tokens"
            },
            {
                "Location": "Wrong calculation of excess depositToken allows stream creator to retrieve depositTokenFlashloanFeeAmount",
                "Type": "High Severity",
                "Description": "Part of users' funds (depositToken) will be transferred to the protocol governance as fees, causing some users unable to withdraw or can only withdraw part of their deposits.",
                "Repair": "Exclude depositTokenFlashloanFeeAmount when calculating excess depositToken"
            },
            {
                "Location": "arbitraryCall() can get blocked by an attacker",
                "Type": "Medium Severity",
                "Description": "If the address 'who' is a token that could be send as an incentive by an attacker via createIncentive() then such claim can be made unusable.",
                "Repair": "Accept the risk but clearly communicate to users that this can happen"
            },
            {
                "Location": "__abdicate() function - 2 Bugs",
                "Type": "High Severity",
                "Description": "The __abdicate() functionality can be used as a backdoor using emergency governor or leaving a pending governor to claim later.",
                "Repair": "Set emergency_gov and pendingGov to zero address in __abdicate() function"
            },
            {
                "Location": "This protocol doesn't support all fee on transfer tokens",
                "Type": "Medium Severity",
                "Description": "Some fee on transfer tokens, do not reduce the fee directly from the transferred amount, but subtracts it from remaining balance of sender.",
                "Repair": "Make it clear for stream creators that the contract only supports fee on transfer tokens if they reduce the fee from the transfer amount"
            },
            {
                "Location": "function exit() public lock updateStream(msg.sender)",
                "Type": "DOS",
                "Description": "The function reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when the user calls exit or withdraw function it will revert and that user will not be able to withdraw funds permanently.",
                "Repair": "Do arithmetic operations in two steps or upcast to uint256 and then downcast. Alternatively, find a threshold where it breaks and add a require condition to not allow total stake per user greater than the threshold."
            },
            {
                "Location": "public uint112 unstreamed;",
                "Type": "Storage variable manipulation",
                "Description": "unstreamed is incremented on calls to stake, but it is not being decremented on calls to withdraw. As a result, a malicious user could simply stake, immediately withdraw their staked amount, and they will have increased unstreamed. They could do this repeatedly or with large amounts to intentionally inflate unstreamed to be as large as they want.",
                "Repair": "Add the following line to withdraw to fix this issue: unstreamed -= amount;"
            },
            {
                "Location": "function arbitraryCall(address who, bytes memory data) public lock externallyGoverned",
                "Type": "Improper implementation of function",
                "Description": "The Locke.arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping. However, the token can still be called prior to any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive(). In summary: 1. If some possible incentive tokens are known prior to being provided, the arbitraryCall() function can be used to pre-approve a token allowance for a malicious recipient. 2. Once a user calls createIncentive() and provides one of the pre-approved tokens, the malicious recipient can call transferFrom on the provided incentive token and withdraw the tokens.",
                "Repair": "Consider adding a mapping: isIncentiveToken, setting isIncentiveToken[incentiveToken] = true in createIncentive(), and require(!isIncentiveToken[who], ...) in arbitraryCall()."
            },
            {
                "Location": "function updateStreamInternal(address who) internal {...",
                "Type": "Improper implementation of function",
                "Description": "Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0. Now after some time he stakes some tokens again. At the second stake updateStream() is called and the following if condition is false because ts.tokens==0. Thus ts.lastUpdate is not updated and stays at the value from the first withdraw. Now he does a second withdraw. updateStream() is called and calculates the updated value of ts.tokens. However, it uses ts.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value of ts.token is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.",
                "Repair": "Change the code in updateStream() to: if (acctTimeDelta > 0 ) {    // some time has passed since this user last interacted    // update ts not yet streamed    if (ts.tokens > 0)             ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));    ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)}"
            }
        ]
    }
]