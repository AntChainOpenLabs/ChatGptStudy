[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function recoverTokens",
                "Type": "Logic Issue",
                "Description": "recoverTokens function doesn't work when isSale is true",
                "Repair": "Set redeemedDepositTokens to depositTokenAmount in creatorClaimSoldTokens function"
            },
            {
                "Location": "function approve",
                "Type": "Frontrun Attack",
                "Description": "LockeERC20 is vulnerable to frontrun attack",
                "Repair": "Change the approve function to either accept the old amount of allowance and require the current allowance to be equal to that, or change to two different functions that increase and decrease the allowance instead of straight on changing it"
            },
            {
                "Location": "function recoverTokens",
                "Type": "Token Theft",
                "Description": "Any arbitraryCall gathered airdrop can be stolen with recoverTokens",
                "Repair": "Add airdrop tokens balance mapping, record what is gathered in arbitraryCall and prohibit their free withdrawal in recoverTokens similarly to incentives[]"
            },
            {
                "Location": "function recoverTokens",
                "Type": "Token Theft",
                "Description": "Tokens can be stolen when depositToken == rewardToken",
                "Repair": "Add a special case for recoverTokens when token == depositToken == rewardToken and then the excess should be ERC20(token).balanceOf(address(this)) - (depositTokenAmount + redeemedDepositTokens + rewardTokenAmount + rewardTokenFeeAmount)"
            },
            {
                "Location": "function recoverTokens(address token, address recipient) public lock {",
                "Type": "Reward token not correctly recovered",
                "Description": "The excess amount is computed incorrectly as ERC20(token).balanceOf(address(this)) (rewardTokenAmount + rewardTokenFeeAmount), and rewardTokenAmount only ever increases (when calling fundStream) but it never decreases when claiming the rewards through claimReward.",
                "Repair": "Track the claimed rewards as well, just like the claimed deposits are tracked. Decrease rewardTokenAmount in claimReward because at this point rewardTokenAmount is not used to update the cumulativeRewardPerToken anymore."
            },
            {
                "Location": "function earned(TS storage ts, uint256 cumulativeRewardPerToken) internal view returns (uint256) {",
                "Type": "Creating rewardTokens without streaming depositTokens",
                "Description": "Stake and withdraws can generate rewardTokens without streaming depositTokens, allowing attackers to create loss of funds for honest stakers.",
                "Repair": "Ensure staked tokens cannot generate reward tokens without streaming deposit tokens. Make the line cumulativeRewardPerToken = rewardPerToken(); dependable on a positive amount > 0 of ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));"
            },
            {
                "Location": "uint256 excess = ERC20(token).balanceOf(address(this)) * (depositTokenAmount - redeemedDepositTokens);",
                "Type": "Wrong calculation of excess depositToken allows stream creator to retrieve depositTokenFlashloanFeeAmount, which may cause fund loss to users",
                "Description": "The stream creator can retrieve depositTokenFlashloanFeeAmount, causing fund loss to users.",
                "Repair": "Change excess calculation to uint256 excess = ERC20(token).balanceOf(address(this)) * (depositTokenAmount - redeemedDepositTokens - depositTokenFlashloanFeeAmount);"
            },
            {
                "Location": "function arbitraryCall(address who, bytes calldata data) external onlyGov {",
                "Type": "arbitraryCall() can get blocked by an attacker",
                "Description": "If the address 'who' is a token that could be sent as an incentive by an attacker via createIncentive(), then such claim can be made unusable, because on L735 there is a require(incentives[who] == 0, 'inc'); that reverts if a 'who' token was received as an incentive.",
                "Repair": "Accept the risk but clearly communicate to users that this can happen."
            },
            {
                "Location": "__abdicate() function at https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L46-L50",
                "Type": "Business logic bug",
                "Description": "Leaving a pending governor or using emergency governor can be used as a backdoor to renounce governance.",
                "Repair": "Set emergency_gov and pendingGov to zero address in the __abdicate() function"
            },
            {
                "Location": "This protocol doesn't support all fee on transfer tokens",
                "Type": "Unsupported feature",
                "Description": "The contract does not fully support fee on transfer tokens, which can result in user funds getting lost after transfers.",
                "Repair": "Make it clear for stream creators that the contract only supports fee on transfer tokens if they reduce the fee from the transfer amount"
            },
            {
                "Location": "DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max at https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L229",
                "Type": "Denial of Service (DoS)",
                "Description": "The contract reverts due to overflow for higher values (but strictly less than type(uint112).max), resulting in users not being able to withdraw funds permanently.",
                "Repair": "Do arithmetic operations in two steps or upcast to u256 and then downcast, or add a require condition to not allow total stake per user greater than a threshold"
            },
            {
                "Location": "ts.tokens sometimes calculated incorrectly at https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417-L447",
                "Type": "Business logic bug",
                "Description": "The value of ts.tokens can be calculated incorrectly, resulting in more tokens being withdrawn than intended.",
                "Repair": "Change the code in updateStream() to always update ts.lastUpdate (if time has elapsed)"
            },
            {
                "Location": "arbitraryCall() function",
                "Type": "Improper implementation",
                "Description": "Improper implementation of arbitraryCall() allows protocol gov to steal funds from users' wallets.",
                "Repair": "Consider adding a mapping: isIncentiveToken, setting isIncentiveToken[incentiveToken] = true in createIncentive(), and require(!isIncentiveToken[who], ...) in arbitraryCall()."
            },
            {
                "Location": "unstreamed variable",
                "Type": "Storage variable manipulation",
                "Description": "Storage variable unstreamed can be artificially inflated.",
                "Repair": "Add the following line to withdraw to fix this issue: unstreamed -= amount;"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/LockeTest.sol\";\n\n\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint112 amt = 1337;\n        emit log_named_uint(\"blocktime\", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint(\"nextStream\", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n\n            // === Failures ===\n            bytes4 sig = sigs(\"fundStream(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                \"amt\"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                \"time\"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n\n            \n\n\n            // === No Fees ===\n\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint(\"gas_usage_no_fee\", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint(\"nextStream2\", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint(\"gas_usage_w_fee\", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n\n        alice.doExit(stream); \n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        testTokenB.approve(address(stream), type(uint256).max);\n\n        {\n            // Failures\n            bytes4 sig = sigs(\"stake(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                \"amt\"\n            );\n\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                \"!stream\"\n            );\n            hevm.warp(startTime - minStreamDuration);\n\n            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                \"erc\"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n\n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n\n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        bytes4 sig = sigs(\"createIncentive(address,uint112)\");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            \"inc\"\n        );\n\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"claimDepositTokens(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                \"sale\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"claimDepositTokens(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                \"amt\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"claimDepositTokens(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                \"lock\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs(\"claimDepositTokens(uint112)\");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"creatorClaimSoldTokens(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"!sale\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs(\"creatorClaimSoldTokens(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"claimed\"\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"creatorClaimSoldTokens(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"!creator\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"creatorClaimSoldTokens(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"stream\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_claimFees() public {\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n\n            bob.failClaimFees(stream);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs(\"claimFees(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"stream\"\n            );\n        }\n\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000*100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs(\"flashloan(address,address,uint112,bytes)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, \"\"),\n                \"erc\"\n            );\n            \n\n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                \"f4\"\n            );\n\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                \"f1\"\n            );\n\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs(\"recoverTokens(address,address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                \"time\"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs(\"recoverTokens(address,address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                \"time\"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs(\"recoverTokens(address,address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                \"stream\"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs(\"arbitraryCall(address,bytes)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), \"\"),\n                \"inc\"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), \"\"),\n                \"erc\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs(\"transfer(address,uint256)\"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs(\"transfer(address,uint256)\"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes memory data = abi.encodePacked(sigs(\"manualBurn(address,address)\"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs(\"arbitraryCall(address,bytes)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                \"erc\"\n            );\n        }\n    }\n\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\n\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        {\n            // Fails\n            bytes4 sig = sigs(\"createStream(address,address,uint32,uint32,uint32,uint32,bool)\");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                \"past\"\n            );\n\n            if (minStreamDuration > 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    \"stream\"\n                );\n            }\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                \"stream\"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                \"lock\"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                \"reward\"\n            );\n        }\n        // ===   ===\n        \n\n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 0);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n\n            // token\n            assertEq(stream.name(), \"lockeTest Token B: 0\");\n            assertEq(stream.symbol(), \"lockeTTB0\");\n\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 1);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n\n            // token\n            assertEq(stream.name(), \"lockeTest Token B: 1\");\n            assertEq(stream.symbol(), \"lockeTTB1\");\n\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), \"gov()\", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs(\"updateStreamParams((uint32,uint32,uint32,uint32))\"),\n            abi.encode(newParams),\n            \"!gov\"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), \"gov()\", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), \"gov()\", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs(\"updateFeeParams((uint16,bool))\"),\n            abi.encode(newParams),\n            \"!gov\"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), \"gov()\", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs(\"updateFeeParams((uint16,bool))\"),\n            abi.encode(newParams),\n            \"fee\"\n        );\n\n        newParams.feePercent = 137;\n\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n",
        "CodeNames": [
            "Locke.t.sol",
            "Locke.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Locke.arbitraryCall() function",
                "Type": "Possible incentive theft",
                "Description": "The arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping.",
                "Repair": "Limit the types of incentive tokens so it can be checked that it's not the target contract for the arbitraryCall(). Validate that the allowance of the target contract (if available) has not changed."
            }
        ]
    }
]