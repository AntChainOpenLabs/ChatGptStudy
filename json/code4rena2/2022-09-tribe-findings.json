[
    {
        "Code": "pragma solidity ^0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {Vm} from \"../../../utils/Vm.sol\";\nimport {DSTest} from \"../../../utils/DSTest.sol\";\nimport {TribeRedeemer} from \"../../../../shutdown/redeem/TribeRedeemer.sol\";\nimport {MockERC20} from \"../../../../mock/MockERC20.sol\";\nimport {getAddresses, FeiTestAddresses} from \"../../../utils/Fixtures.sol\";\n\ncontract TribeRedeemerTest is DSTest {\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    uint256 private constant REDEEM_BASE = 250000000 ether; // 250M\n\n    TribeRedeemer private redeemer;\n\n    Vm public constant vm = Vm(HEVM_ADDRESS);\n    FeiTestAddresses public addresses = getAddresses();\n\n    MockERC20 private redeemToken;\n    MockERC20 private token1;\n    MockERC20 private token2;\n    MockERC20 private token3;\n\n    address payable owner = payable(address(42));\n\n    function setUp() public {\n        redeemToken = new MockERC20();\n\n        token1 = new MockERC20();\n        token2 = new MockERC20();\n        token3 = new MockERC20();\n\n        address[] memory tokensReceived = new address[](3);\n        tokensReceived[0] = address(token1);\n        tokensReceived[1] = address(token2);\n        tokensReceived[2] = address(token3);\n\n        redeemer = new TribeRedeemer(address(redeemToken), tokensReceived, REDEEM_BASE);\n\n        token1.mint(address(redeemer), 50000 ether); // 50k\n        token2.mint(address(redeemer), 20000 ether); // 20k\n        token3.mint(address(redeemer), 30000000 ether); // 30M\n        redeemToken.mint(address(owner), REDEEM_BASE); // 250M\n    }\n\n    /// @notice Validate initiate state when deployed\n    function testInitialState() public {\n        assertEq(redeemer.redeemedToken(), address(redeemToken));\n        assertEq(redeemer.redeemBase(), REDEEM_BASE);\n        assertEq(redeemer.tokensReceivedOnRedeem().length, 3);\n        assertEq(redeemer.tokensReceivedOnRedeem()[0], address(token1));\n        assertEq(redeemer.tokensReceivedOnRedeem()[1], address(token2));\n        assertEq(redeemer.tokensReceivedOnRedeem()[2], address(token3));\n    }\n\n    ///////////////////// previewRedeem() /////////////////////////\n    function testPreviewRedeem() public {\n        (address[] memory tokensRedeemed, uint256[] memory amountsRedeemAll) = redeemer.previewRedeem(REDEEM_BASE);\n\n        assertEq(tokensRedeemed.length, 3);\n        assertEq(tokensRedeemed[0], address(token1));\n        assertEq(tokensRedeemed[1], address(token2));\n        assertEq(tokensRedeemed[2], address(token3));\n        assertEq(amountsRedeemAll.length, 3);\n        assertEq(amountsRedeemAll[0], 50000 ether); // 50k\n        assertEq(amountsRedeemAll[1], 20000 ether); // 20k\n        assertEq(amountsRedeemAll[2], 30000000 ether); // 30M\n\n        (, uint256[] memory amountsRedeemHalf) = redeemer.previewRedeem(REDEEM_BASE / 2);\n        assertEq(amountsRedeemHalf[0], 25000 ether); // 25k\n        assertEq(amountsRedeemHalf[1], 10000 ether); // 10k\n        assertEq(amountsRedeemHalf[2], 15000000 ether); // 15M\n    }\n\n    //////////////////////// redeem() /////////////////////////////\n    function testRedeemForSelf() public {\n        // redeem for self\n        vm.startPrank(owner);\n        redeemToken.approve(address(redeemer), REDEEM_BASE);\n        vm.expectEmit(true, true, true, true);\n        emit Redeemed(owner, owner, REDEEM_BASE, REDEEM_BASE);\n        redeemer.redeem(owner, REDEEM_BASE);\n        vm.stopPrank();\n\n        // check tokens spent & received by the redeemer\n        assertEq(redeemToken.balanceOf(owner), 0);\n        assertEq(redeemToken.balanceOf(address(redeemer)), REDEEM_BASE);\n        // check received balances & sent by the redeemer\n        assertEq(token1.balanceOf(owner), 50000 ether);\n        assertEq(token2.balanceOf(owner), 20000 ether);\n        assertEq(token3.balanceOf(owner), 30000000 ether);\n        assertEq(token1.balanceOf(address(redeemer)), 0);\n        assertEq(token2.balanceOf(address(redeemer)), 0);\n        assertEq(token3.balanceOf(address(redeemer)), 0);\n    }\n\n    function testRedeemTwoUsers() public {\n        address payable otherOwner = payable(address(43));\n\n        // send half of the redeem tokens to a 2nd user\n        vm.prank(owner);\n        redeemToken.transfer(otherOwner, REDEEM_BASE / 2);\n\n        // first user redeems\n        vm.startPrank(owner);\n        redeemToken.approve(address(redeemer), REDEEM_BASE / 2);\n        redeemer.redeem(owner, REDEEM_BASE / 2);\n        vm.stopPrank();\n\n        // check tokens spent & received by the redeemer\n        assertEq(redeemToken.balanceOf(owner), 0);\n        assertEq(redeemToken.balanceOf(otherOwner), REDEEM_BASE / 2);\n        assertEq(redeemToken.balanceOf(address(redeemer)), REDEEM_BASE / 2);\n\n        // check received balances & sent by the redeemer\n        assertEq(token1.balanceOf(owner), 25000 ether);\n        assertEq(token2.balanceOf(owner), 10000 ether);\n        assertEq(token3.balanceOf(owner), 15000000 ether);\n        assertEq(token1.balanceOf(address(redeemer)), 25000 ether);\n        assertEq(token2.balanceOf(address(redeemer)), 10000 ether);\n        assertEq(token3.balanceOf(address(redeemer)), 15000000 ether);\n\n        // second user redeems\n        vm.startPrank(otherOwner);\n        redeemToken.approve(address(redeemer), REDEEM_BASE / 2);\n        redeemer.redeem(otherOwner, REDEEM_BASE / 2);\n        vm.stopPrank();\n\n        // check tokens spent & received by the redeemer\n        assertEq(redeemToken.balanceOf(owner), 0);\n        assertEq(redeemToken.balanceOf(otherOwner), 0);\n        assertEq(redeemToken.balanceOf(address(redeemer)), REDEEM_BASE);\n\n        // check received balances & sent by the redeemer\n        assertEq(token1.balanceOf(otherOwner), 25000 ether);\n        assertEq(token2.balanceOf(otherOwner), 10000 ether);\n        assertEq(token3.balanceOf(otherOwner), 15000000 ether);\n        assertEq(token1.balanceOf(address(redeemer)), 0);\n        assertEq(token2.balanceOf(address(redeemer)), 0);\n        assertEq(token3.balanceOf(address(redeemer)), 0);\n    }\n\n    function testRedeemSendAway() public {\n        // owner redeems and sends to receiver\n        vm.startPrank(owner);\n        redeemToken.approve(address(redeemer), REDEEM_BASE);\n        vm.expectEmit(true, true, true, true);\n        emit Redeemed(owner, address(this), REDEEM_BASE, REDEEM_BASE);\n        redeemer.redeem(address(this), REDEEM_BASE);\n        vm.stopPrank();\n\n        // check tokens spent & received by the redeemer\n        assertEq(redeemToken.balanceOf(owner), 0);\n        assertEq(redeemToken.balanceOf(address(redeemer)), REDEEM_BASE);\n        // check received balances & sent by the redeemer\n        assertEq(token1.balanceOf(address(this)), 50000 ether);\n        assertEq(token2.balanceOf(address(this)), 20000 ether);\n        assertEq(token3.balanceOf(address(this)), 30000000 ether);\n        assertEq(token1.balanceOf(address(redeemer)), 0);\n        assertEq(token2.balanceOf(address(redeemer)), 0);\n        assertEq(token3.balanceOf(address(redeemer)), 0);\n    }\n\n    function testRedeemRevertNoBalance() public {\n        // empty tokens from the redeemer\n        vm.startPrank(address(redeemer));\n        token1.transfer(address(this), token1.balanceOf(address(redeemer)));\n        token2.transfer(address(this), token2.balanceOf(address(redeemer)));\n        token3.transfer(address(this), token3.balanceOf(address(redeemer)));\n        vm.stopPrank();\n\n        // redeem for self\n        vm.startPrank(owner);\n        redeemToken.approve(address(redeemer), REDEEM_BASE);\n        vm.expectRevert(bytes(\"ZERO_BALANCE\"));\n        redeemer.redeem(owner, REDEEM_BASE);\n        vm.stopPrank();\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}\n\n\n",
        "CodeNames": [
            "TribeRedeemer.t.sol",
            "TribeRedeemer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TribeRedeemer contract",
                "Type": "Loss of Funds",
                "Description": "A malicious user can send tokens to the TribeRedeemer contract to make the redeem function work, and other users may lose assets as a result. The vulnerability can be exploited by sending tokens to the contract in advance, tricking naive users into redeeming early and losing out on the tokens they would have otherwise received after the full redemption token amounts have been sent to the contract.",
                "Repair": "Inherit the Pausable contract and allow users to redeem when a sufficient number of tokens have been sent to the contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}\n\n\n",
        "CodeNames": [
            "TribeRedeemer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TribeRedeemer.sol#L58, TribeRedeemer.sol#L70",
                "Type": "Incorrect Calculation",
                "Description": "If someone transfers tokens directly to the TribeRedeemer contract, the redeemBase value will not be decreased, and the exchange ratio will not be 1:1. This results in the next users receiving less than they should. Additionally, tokens sent directly to the contract are locked and effectively burned, resulting in unequal claims for users.",
                "Repair": "Use IERC20(_redeemedToken).totalSupply() instead of redeemBase for calculating the amount of tokens left for redeeming. Consider initializing TribeRedeemer with an exchangeTokensPerRedeemToken array to provide a fixed amount of tokens to pay for redeemed tokens."
            }
        ]
    }
]