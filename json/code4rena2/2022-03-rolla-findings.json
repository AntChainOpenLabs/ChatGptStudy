[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./QuantConfig.sol\";\nimport \"./utils/EIP712MetaTransaction.sol\";\nimport \"./utils/OperateProxy.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IOracleRegistry.sol\";\nimport \"./interfaces/ICollateralToken.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IOperateProxy.sol\";\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./libraries/ProtocolValue.sol\";\nimport \"./libraries/QuantMath.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/Actions.sol\";\n\n/// @title The main entry point in the Quant Protocol\n/// @author Rolla\n/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.\n/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.\n/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.\n/// @dev This contract is an upgradeable proxy, and it supports meta transactions.\n/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the\n/// OptionsFactory first.\ncontract Controller is\n    IController,\n    EIP712MetaTransaction,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using QuantMath for QuantMath.FixedPointInt;\n    using Actions for ActionArgs;\n\n    /// @inheritdoc IController\n    address public override optionsFactory;\n\n    /// @inheritdoc IController\n    address public override operateProxy;\n\n    /// @inheritdoc IController\n    address public override quantCalculator;\n\n    /// @inheritdoc IController\n    function operate(ActionArgs[] memory _actions)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        uint256 length = _actions.length;\n        for (uint256 i = 0; i < length; ) {\n            ActionArgs memory action = _actions[i];\n\n            if (action.actionType == ActionType.MintOption) {\n                (address to, address qToken, uint256 amount) = action\n                    .parseMintOptionArgs();\n                _mintOptionsPosition(to, qToken, amount);\n            } else if (action.actionType == ActionType.MintSpread) {\n                (\n                    address qTokenToMint,\n                    address qTokenForCollateral,\n                    uint256 amount\n                ) = action.parseMintSpreadArgs();\n                _mintSpread(qTokenToMint, qTokenForCollateral, amount);\n            } else if (action.actionType == ActionType.Exercise) {\n                (address qToken, uint256 amount) = action.parseExerciseArgs();\n                _exercise(qToken, amount);\n            } else if (action.actionType == ActionType.ClaimCollateral) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseClaimCollateralArgs();\n                _claimCollateral(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.Neutralize) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseNeutralizeArgs();\n                _neutralizePosition(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.QTokenPermit) {\n                (\n                    address qToken,\n                    address owner,\n                    address spender,\n                    uint256 value,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseQTokenPermitArgs();\n                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);\n            } else if (\n                action.actionType == ActionType.CollateralTokenApproval\n            ) {\n                (\n                    address owner,\n                    address operator,\n                    bool approved,\n                    uint256 nonce,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseCollateralTokenApprovalArgs();\n                _collateralTokenApproval(\n                    owner,\n                    operator,\n                    approved,\n                    nonce,\n                    deadline,\n                    v,\n                    r,\n                    s\n                );\n            } else {\n                require(\n                    action.actionType == ActionType.Call,\n                    \"Controller: Invalid action type\"\n                );\n                (address callee, bytes memory data) = action.parseCallArgs();\n                _call(callee, data);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n\n    // @inheritdoc IController\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _optionsFactory,\n        address _quantCalculator\n    ) public override initializer {\n        require(\n            _optionsFactory != address(0),\n            \"Controller: invalid OptionsFactory address\"\n        );\n        require(\n            _quantCalculator != address(0),\n            \"Controller: invalid QuantCalculator address\"\n        );\n\n        __ReentrancyGuard_init();\n        EIP712MetaTransaction.initializeEIP712(_name, _version);\n        optionsFactory = _optionsFactory;\n\n        /// @dev Unless this line is removed, a new OperateProxy will be created\n        /// during each upgrade. So make sure any application that requires approving\n        /// the OperateProxy to spend funds is aware of this.\n        operateProxy = address(new OperateProxy());\n\n        quantCalculator = _quantCalculator;\n    }\n\n    /// @notice Mints options for a given QToken, which must have been previously created in\n    /// the configured OptionsFactory.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset, and then this function can be called, pulling the collateral\n    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.\n    /// Note that QTokens represent a long position, giving holders the ability to exercise options\n    /// after expiry, while CollateralTokens represent a short position, giving holders the ability\n    /// to claim the collateral after expiry.\n    /// @param _to The address to which the QTokens and CollateralTokens will be minted.\n    /// @param _qToken The QToken that represents the long position for the option to be minted.\n    /// @param _amount The amount of options to be minted.\n    function _mintOptionsPosition(\n        address _to,\n        address _qToken,\n        uint256 _amount\n    ) internal returns (uint256) {\n        IQToken qToken = IQToken(_qToken);\n\n        // get the collateral required to mint the specified amount of options\n        // the zero address is passed as the second argument as it's only used\n        // for spreads\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(_qToken, address(0), _amount);\n\n        _checkIfUnexpiredQToken(_qToken);\n\n        // check if the oracle set during the option's creation through the OptionsFactory\n        // is an active oracle in the OracleRegistry\n        require(\n            IOracleRegistry(\n                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(\n                    ProtocolValue.encode(\"oracleRegistry\")\n                )\n            ).isOracleActive(qToken.oracle()),\n            \"Controller: Can't mint an options position as the oracle is inactive\"\n        );\n\n        // pull the required collateral from the caller/signer\n        IERC20(collateral).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            collateralAmount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Mint the options to the sender's address\n        qToken.mint(_to, _amount);\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qToken,\n            address(0)\n        );\n\n        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,\n        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory\n        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);\n\n        emit OptionsPositionMinted(\n            _to,\n            _msgSender(),\n            _qToken,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Creates a spread position from an option to long and another option to short.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset in cases of a debit spread.\n    /// @param _qTokenToMint The QToken for the option to be long.\n    /// @param _qTokenForCollateral The QToken for the option to be short.\n    /// @param _amount The amount of long options to be minted.\n    function _mintSpread(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    ) internal returns (uint256) {\n        require(\n            _qTokenToMint != _qTokenForCollateral,\n            \"Controller: Can only create a spread with different tokens\"\n        );\n\n        IQToken qTokenToMint = IQToken(_qTokenToMint);\n        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);\n\n        // Calculate the extra collateral required to create the spread.\n        // A positive value for debit spreads and zero for credit spreads.\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount\n            );\n\n        _checkIfUnexpiredQToken(_qTokenToMint);\n        _checkIfUnexpiredQToken(_qTokenForCollateral);\n\n        // Burn the QToken being shorted\n        qTokenForCollateral.burn(_msgSender(), _amount);\n\n        // Transfer in any collateral required for the spread\n        if (collateralAmount > 0) {\n            IERC20(collateral).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                collateralAmount\n            );\n        }\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Check if the CollateralToken representing this specific spread has already been created\n        // Create it if it hasn't\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qTokenToMint,\n            _qTokenForCollateral\n        );\n        (, address qTokenAsCollateral) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n        if (qTokenAsCollateral == address(0)) {\n            require(\n                collateralTokenId ==\n                    collateralToken.createCollateralToken(\n                        _qTokenToMint,\n                        _qTokenForCollateral\n                    ),\n                \"Controller: failed creating the collateral token to represent the spread\"\n            );\n        }\n\n        // Mint the tokens for the new spread position\n        collateralToken.mintCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            _amount\n        );\n        qTokenToMint.mint(_msgSender(), _amount);\n\n        emit SpreadMinted(\n            _msgSender(),\n            _qTokenToMint,\n            _qTokenForCollateral,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Closes a long position after the option's expiry.\n    /// @dev Pass an `_amount` of 0 to close the entire position.\n    /// @param _qToken The QToken representing the long position to be closed.\n    /// @param _amount The amount of options to exercise.\n    function _exercise(address _qToken, uint256 _amount) internal {\n        IQToken qToken = IQToken(_qToken);\n        require(\n            block.timestamp > qToken.expiryTime(),\n            \"Controller: Can not exercise options before their expiry\"\n        );\n\n        uint256 amountToExercise = _amount;\n        // if the amount is 0, the entire position will be exercised\n        if (amountToExercise == 0) {\n            amountToExercise = qToken.balanceOf(_msgSender());\n        }\n\n        // Use the QuantCalculator to check how much the sender/signer is due.\n        // Will only be a positive value for options that expired In The Money.\n        (\n            bool isSettled,\n            address payoutToken,\n            uint256 exerciseTotal\n        ) = IQuantCalculator(quantCalculator).getExercisePayout(\n                address(qToken),\n                amountToExercise\n            );\n\n        require(isSettled, \"Controller: Cannot exercise unsettled options\");\n\n        // Burn the long tokens\n        qToken.burn(_msgSender(), amountToExercise);\n\n        // Transfer any profit due after expiration\n        if (exerciseTotal > 0) {\n            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);\n        }\n\n        emit OptionsExercised(\n            _msgSender(),\n            address(qToken),\n            amountToExercise,\n            exerciseTotal,\n            payoutToken\n        );\n    }\n\n    /// @notice Closes a short position after the option's expiry.\n    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.\n    /// @param _amount The size of the position to close.\n    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        uint256 collateralTokenId = _collateralTokenId;\n\n        // Use the QuantCalculator to check how much collateral the sender/signer is due.\n        (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(\n                collateralTokenId,\n                _amount,\n                _msgSender()\n            );\n\n        // Burn the short tokens\n        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim\n        );\n\n        // Transfer any collateral due after expiration\n        if (returnableCollateral > 0) {\n            IERC20(collateralAsset).safeTransfer(\n                _msgSender(),\n                returnableCollateral\n            );\n        }\n\n        emit CollateralClaimed(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim,\n            returnableCollateral,\n            collateralAsset\n        );\n    }\n\n    /// @notice Closes a neutral position, claiming all the collateral required to create it.\n    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.\n    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.\n    /// @param _amount The size of the position to close.\n    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        /// @dev Put these values in the stack to save gas from having to read\n        /// from calldata\n        (uint256 collateralTokenId, uint256 amount) = (\n            _collateralTokenId,\n            _amount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n\n        //get the amount of CollateralTokens owned\n        uint256 collateralTokensOwned = collateralToken.balanceOf(\n            _msgSender(),\n            collateralTokenId\n        );\n\n        //get the amount of QTokens owned\n        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());\n\n        // the size of the position that can be neutralized\n        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned\n            ? qTokensOwned\n            : collateralTokensOwned;\n\n        // make sure that the amount passed is not greater than the amount that can be neutralized\n        uint256 amountToNeutralize;\n        if (amount != 0) {\n            require(\n                amount <= maxNeutralizable,\n                \"Controller: Tried to neutralize more than balance\"\n            );\n            amountToNeutralize = amount;\n        } else {\n            amountToNeutralize = maxNeutralizable;\n        }\n\n        // use the QuantCalculator to check how much collateral the sender/signer is due\n        // for closing the neutral position\n        (address collateralType, uint256 collateralOwed) = IQuantCalculator(\n            quantCalculator\n        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);\n\n        // burn the short tokens\n        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);\n\n        // burn the long tokens\n        collateralToken.burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToNeutralize\n        );\n\n        // tranfer the collateral owed\n        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);\n\n        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)\n        if (qTokenLong != address(0)) {\n            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);\n        }\n\n        emit NeutralizePosition(\n            _msgSender(),\n            qTokenShort,\n            amountToNeutralize,\n            collateralOwed,\n            collateralType,\n            qTokenLong\n        );\n    }\n\n    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.\n    /// @param _qToken The QToken to be approved.\n    /// @param _spender The address of the spender.\n    /// @param _value The amount of tokens to be approved for spending.\n    /// @param _deadline Timestamp at which the permit signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _qTokenPermit(\n        address _qToken,\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IQToken(_qToken).permit(\n            _owner,\n            _spender,\n            _value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice Allows a CollateralToken owner to either approve an operator address\n    /// to spend all of their tokens on their behalf, or to remove a prior approval.\n    /// @param _owner The address of the owner of the CollateralToken.\n    /// @param _operator The address of the operator to be approved or removed.\n    /// @param _approved Whether the operator is being approved or removed.\n    /// @param _nonce The nonce for the approval through a meta transaction.\n    /// @param _deadline Timestamp at which the approval signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _collateralTokenApproval(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _nonce,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(\n                _owner,\n                _operator,\n                _approved,\n                _nonce,\n                _deadline,\n                _v,\n                _r,\n                _s\n            );\n    }\n\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n\n    /// @notice Checks if the given QToken has not expired yet, reverting otherwise\n    /// @param _qToken The address of the QToken to check.\n    function _checkIfUnexpiredQToken(address _qToken) internal view {\n        require(\n            IQToken(_qToken).expiryTime() > block.timestamp,\n            \"Controller: Cannot mint expired options\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Controller.sol#L22-L34",
                "Type": "Admin can rug users",
                "Description": "Admin of the upgradeable proxy contract of Controller.sol can rug users.",
                "Repair": "Use non-upgradeable CollateralToken contract to hold user's allowances instead"
            },
            {
                "Location": "Controller.sol#L5",
                "Type": "No use of upgradeable SafeERC20 contract",
                "Description": "Controller.sol makes use of Open Zeppelin's ReentrancyGuardUpgradeable.sol in the file but does not use an upgradeable version of SafeERC20.sol.",
                "Repair": "Make use of Open Zeppelin's upgradeable version of the SafeERC20.sol contract"
            },
            {
                "Location": "Controller.sol#L497-L516",
                "Type": "Arbitrary code execution",
                "Description": "A malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented.",
                "Repair": "Probe for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\nimport \"../interfaces/IAssetsRegistry.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../libraries/ProtocolValue.sol\";\n\nabstract contract QTokenStringUtils {\n    /// @notice get the ERC20 token symbol from the AssetsRegistry\n    /// @dev the asset is assumed to be in the AssetsRegistry since QTokens\n    /// must be created through the OptionsFactory, which performs that check\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _asset address of the asset in the AssetsRegistry\n    /// @return assetSymbol string stored as the ERC20 token symbol\n    function _assetSymbol(address _quantConfig, address _asset)\n        internal\n        view\n        virtual\n        returns (string memory assetSymbol)\n    {\n        (, assetSymbol, ) = IAssetsRegistry(\n            IQuantConfig(_quantConfig).protocolAddresses(\n                ProtocolValue.encode(\"assetsRegistry\")\n            )\n        ).assetProperties(_asset);\n    }\n\n    /// @notice generates the name for an option\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _underlyingAsset asset that the option references\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenName name string for the QToken\n    function _qTokenName(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenName) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (, string memory typeFull) = _getOptionType(_isCall);\n\n        // get option month string\n        (, string memory monthFull) = _getMonth(month);\n\n        /// concatenated name string\n        tokenName = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \" \",\n                underlying,\n                \" \",\n                _uintToChars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                \" \",\n                typeFull\n            )\n        );\n    }\n\n    /// @notice generates the symbol for an option\n    /// @param _underlyingAsset asset that the option references\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenSymbol symbol string for the QToken\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n\n    /// @dev convert the option strike price scaled to a human readable value\n    /// @param _strikePrice the option strike price scaled by 1e20\n    /// @return strike price string\n    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n        uint256 strikePriceScale = 10**strikePriceDigits;\n        uint256 remainder = _strikePrice % strikePriceScale;\n        uint256 quotient = _strikePrice / strikePriceScale;\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) {\n            return quotientStr;\n        }\n\n        uint256 trailingZeroes;\n        while (remainder % 10 == 0) {\n            remainder /= 10;\n            trailingZeroes++;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(strikePriceDigits - trailingZeroes);\n\n        string memory tmp = Strings.toString(remainder);\n        tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);\n\n        return string(abi.encodePacked(quotientStr, \".\", tmp));\n    }\n\n    /// @dev get the string representation of the option type\n    /// @return a 1 character representation of the option type\n    /// @return a full length string of the option type\n    function _getOptionType(bool _isCall)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        return _isCall ? (\"C\", \"Call\") : (\"P\", \"Put\");\n    }\n\n    /// @dev get the representation of a number using 2 characters, adding a leading 0 if it's one digit,\n    /// and two trailing digits if it's a 3 digit number\n    /// @return 2 characters that correspond to a number\n    function _uintToChars(uint256 _number)\n        internal\n        pure\n        virtual\n        returns (string memory)\n    {\n        if (_number > 99) {\n            _number %= 100;\n        }\n\n        string memory str = Strings.toString(_number);\n\n        if (_number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n\n        return str;\n    }\n\n    /// @dev cut a string into string[start:end]\n    /// @param _s string to cut\n    /// @param _start the starting index\n    /// @param _end the ending index (not inclusive)\n    /// @return the indexed string\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure virtual returns (string memory) {\n        uint256 range = _end - _start;\n        bytes memory slice = new bytes(range);\n        for (uint256 i = 0; i < range; ) {\n            slice[i] = bytes(_s)[_start + 1];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return string(slice);\n    }\n\n    /// @dev get the string representations of a month\n    /// @return a 3 character representation\n    /// @return a full length string representation\n    function _getMonth(uint256 _month)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "QTokenStringUtils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "QTokenStringUtils.sol#L115-L130, L181-L199",
                "Type": "QTokens with the same symbol will lead to mistakes",
                "Description": "QTokens with the same symbol will lead to mistakes.",
                "Repair": "Include the full year in the token's symbol"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "options/QTokenStringUtils.sol#L38, L90, L136, L206",
                "Type": "Incorrect strike price displayed in name/symbol of qToken",
                "Description": "Incorrect strike price displayed in name/symbol of qToken.",
                "Repair": "Fix the bug in the _slice() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IPriceRegistry.sol\";\nimport \"./libraries/FundsCalculator.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/QuantMath.sol\";\n\n/// @title For calculating collateral requirements and payouts for options and spreads\n/// @author Rolla\n/// @dev Uses fixed point arithmetic from the QuantMath library.\ncontract QuantCalculator is IQuantCalculator {\n    using QuantMath for uint256;\n    using QuantMath for int256;\n    using QuantMath for QuantMath.FixedPointInt;\n\n    /// @inheritdoc IQuantCalculator\n    uint8 public constant override OPTIONS_DECIMALS = 18;\n\n    /// @inheritdoc IQuantCalculator\n    uint8 public immutable override strikeAssetDecimals;\n\n    /// @inheritdoc IQuantCalculator\n    address public immutable override optionsFactory;\n\n    /// @notice Checks that the QToken was created through the configured OptionsFactory\n    modifier validQToken(address _qToken) {\n        require(\n            IOptionsFactory(optionsFactory).isQToken(_qToken),\n            \"QuantCalculator: Invalid QToken address\"\n        );\n\n        _;\n    }\n\n    /// @notice Checks that the QToken used as collateral for a spread is either the zero address\n    /// or a QToken created through the configured OptionsFactory\n    modifier validQTokenAsCollateral(address _qTokenAsCollateral) {\n        if (_qTokenAsCollateral != address(0)) {\n            // it could be the zero address for the qTokenAsCollateral for non-spreads\n            require(\n                IOptionsFactory(optionsFactory).isQToken(_qTokenAsCollateral),\n                \"QuantCalculator: Invalid QToken address\"\n            );\n        }\n\n        _;\n    }\n\n    /// @param _strikeAssetDecimals the number of decimals used to denominate strike prices\n    /// @param _optionsFactory the address of the OptionsFactory contract\n    constructor(uint8 _strikeAssetDecimals, address _optionsFactory) {\n        strikeAssetDecimals = _strikeAssetDecimals;\n        optionsFactory = _optionsFactory;\n    }\n\n    /// @inheritdoc IQuantCalculator\n    function calculateClaimableCollateral(\n        uint256 _collateralTokenId,\n        uint256 _amount,\n        address _msgSender\n    )\n        external\n        view\n        override\n        returns (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        )\n    {\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        (address _qTokenShort, address qTokenAsCollateral) = collateralToken\n            .idToInfo(_collateralTokenId);\n\n        require(\n            _qTokenShort != address(0),\n            \"Can not claim collateral from non-existing option\"\n        );\n\n        IQToken qTokenShort = IQToken(_qTokenShort);\n\n        require(\n            block.timestamp > qTokenShort.expiryTime(),\n            \"Can not claim collateral from options before their expiry\"\n        );\n        require(\n            qTokenShort.getOptionPriceStatus() == PriceStatus.SETTLED,\n            \"Can not claim collateral before option is settled\"\n        );\n\n        amountToClaim = _amount == 0\n            ? collateralToken.balanceOf(_msgSender, _collateralTokenId)\n            : _amount;\n\n        IQuantConfig quantConfig = IOptionsFactory(optionsFactory)\n            .quantConfig();\n\n        IPriceRegistry priceRegistry = IPriceRegistry(\n            quantConfig.protocolAddresses(ProtocolValue.encode(\"priceRegistry\"))\n        );\n\n        IPriceRegistry.PriceWithDecimals memory expiryPrice = priceRegistry\n            .getSettlementPriceWithDecimals(\n                qTokenShort.oracle(),\n                qTokenShort.underlyingAsset(),\n                qTokenShort.expiryTime()\n            );\n\n        address qTokenLong;\n        QuantMath.FixedPointInt memory payoutFromLong;\n\n        if (qTokenAsCollateral != address(0)) {\n            qTokenLong = qTokenAsCollateral;\n\n            (, payoutFromLong) = FundsCalculator.getPayout(\n                qTokenLong,\n                amountToClaim,\n                OPTIONS_DECIMALS,\n                strikeAssetDecimals,\n                expiryPrice\n            );\n        } else {\n            qTokenLong = address(0);\n            payoutFromLong = int256(0).fromUnscaledInt();\n        }\n\n        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(\n            strikeAssetDecimals,\n            qTokenShort,\n            quantConfig\n        );\n\n        QuantMath.FixedPointInt memory collateralRequirement;\n        (collateralAsset, collateralRequirement) = FundsCalculator\n            .getCollateralRequirement(\n                _qTokenShort,\n                qTokenLong,\n                amountToClaim,\n                OPTIONS_DECIMALS,\n                payoutDecimals,\n                strikeAssetDecimals\n            );\n\n        (, QuantMath.FixedPointInt memory payoutFromShort) = FundsCalculator\n            .getPayout(\n                _qTokenShort,\n                amountToClaim,\n                OPTIONS_DECIMALS,\n                strikeAssetDecimals,\n                expiryPrice\n            );\n\n        returnableCollateral = payoutFromLong\n            .add(collateralRequirement)\n            .sub(payoutFromShort)\n            .toScaledUint(payoutDecimals, true);\n    }\n\n    /// @inheritdoc IQuantCalculator\n    function getNeutralizationPayout(\n        address _qTokenShort,\n        address _qTokenLong,\n        uint256 _amountToNeutralize\n    )\n        external\n        view\n        override\n        returns (address collateralType, uint256 collateralOwed)\n    {\n        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(\n            strikeAssetDecimals,\n            IQToken(_qTokenShort),\n            IOptionsFactory(optionsFactory).quantConfig()\n        );\n\n        QuantMath.FixedPointInt memory collateralOwedFP;\n        (collateralType, collateralOwedFP) = FundsCalculator\n            .getCollateralRequirement(\n                _qTokenShort,\n                _qTokenLong,\n                _amountToNeutralize,\n                OPTIONS_DECIMALS,\n                payoutDecimals,\n                strikeAssetDecimals\n            );\n\n        collateralOwed = collateralOwedFP.toScaledUint(payoutDecimals, true);\n    }\n\n    /// @inheritdoc IQuantCalculator\n    function getCollateralRequirement(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    )\n        external\n        view\n        override\n        validQToken(_qTokenToMint)\n        validQTokenAsCollateral(_qTokenForCollateral)\n        returns (address collateral, uint256 collateralAmount)\n    {\n        QuantMath.FixedPointInt memory collateralAmountFP;\n        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(\n            strikeAssetDecimals,\n            IQToken(_qTokenToMint),\n            IOptionsFactory(optionsFactory).quantConfig()\n        );\n\n        (collateral, collateralAmountFP) = FundsCalculator\n            .getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount,\n                OPTIONS_DECIMALS,\n                payoutDecimals,\n                strikeAssetDecimals\n            );\n\n        collateralAmount = collateralAmountFP.toScaledUint(\n            payoutDecimals,\n            false\n        );\n    }\n\n    /// @inheritdoc IQuantCalculator\n    function getExercisePayout(address _qToken, uint256 _amount)\n        external\n        view\n        override\n        validQToken(_qToken)\n        returns (\n            bool isSettled,\n            address payoutToken,\n            uint256 payoutAmount\n        )\n    {\n        IQToken qToken = IQToken(_qToken);\n        isSettled = qToken.getOptionPriceStatus() == PriceStatus.SETTLED;\n        if (!isSettled) {\n            return (false, address(0), 0);\n        } else {\n            isSettled = true;\n        }\n\n        QuantMath.FixedPointInt memory payout;\n\n        IQuantConfig quantConfig = IOptionsFactory(optionsFactory)\n            .quantConfig();\n\n        IPriceRegistry priceRegistry = IPriceRegistry(\n            quantConfig.protocolAddresses(ProtocolValue.encode(\"priceRegistry\"))\n        );\n\n        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(\n            strikeAssetDecimals,\n            qToken,\n            quantConfig\n        );\n\n        address underlyingAsset = qToken.underlyingAsset();\n\n        IPriceRegistry.PriceWithDecimals memory expiryPrice = priceRegistry\n            .getSettlementPriceWithDecimals(\n                qToken.oracle(),\n                underlyingAsset,\n                qToken.expiryTime()\n            );\n\n        (payoutToken, payout) = FundsCalculator.getPayout(\n            _qToken,\n            _amount,\n            OPTIONS_DECIMALS,\n            strikeAssetDecimals,\n            expiryPrice\n        );\n\n        payoutAmount = payout.toScaledUint(payoutDecimals, true);\n    }\n}\n\n\n",
        "CodeNames": [
            "QuantCalculator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "QuantCalculator.calculateClaimableCollateral",
                "Type": "Arithmetic",
                "Description": "The vulnerability allows minting spread collateral-less and conjuring collateral claims out of thin air with implicit arithmetic rounding and flawed int to uint conversion.",
                "Repair": "Add explicit rounding on fixed-point multiplication and division operations"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"../external/openzeppelin/ERC1155.sol\";\nimport \"../interfaces/ICollateralToken.sol\";\n\n/// @title Tokens representing a Quant user's short positions\n/// @author Rolla\n/// @notice Can be used by owners to claim their collateral\n/// @dev This is a multi-token contract that implements the ERC1155 token standard:\n/// https://eips.ethereum.org/EIPS/eip-1155\ncontract CollateralToken is ERC1155, ICollateralToken, EIP712 {\n    /// @dev stores metadata for a CollateralToken with an specific id\n    /// @param qTokenAddress address of the corresponding QToken\n    /// @param qTokenAsCollateral QToken address of an option used as collateral in a spread\n    struct CollateralTokenInfo {\n        address qTokenAddress;\n        address qTokenAsCollateral;\n    }\n\n    /// @inheritdoc ICollateralToken\n    IQuantConfig public override quantConfig;\n\n    /// @inheritdoc ICollateralToken\n    mapping(uint256 => CollateralTokenInfo) public override idToInfo;\n\n    /// @inheritdoc ICollateralToken\n    uint256[] public override collateralTokenIds;\n\n    // Signature nonce per address\n    mapping(address => uint256) public nonces;\n\n    // keccak256(\n    //     \"metaSetApprovalForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\"\n    // );\n    bytes32 private constant _META_APPROVAL_TYPEHASH =\n        0xf8f9aaf28cf20cd45b21061d07505fa1da285124284441ea655b9eb837ed89b7;\n\n    /// @notice Initializes a new ERC1155 multi-token contract for representing\n    /// users' short positions\n    /// @param _quantConfig the address of the Quant system configuration contract\n    /// @param _name name for the domain typehash in EIP712 meta transactions\n    /// @param _version version for the domain typehash in EIP712 meta transactions\n    /// @param uri_ URI for ERC1155 tokens metadata\n    constructor(\n        address _quantConfig,\n        string memory _name,\n        string memory _version,\n        string memory uri_\n    ) ERC1155(uri_) EIP712(_name, _version) {\n        require(\n            _quantConfig != address(0),\n            \"CollateralToken: invalid QuantConfig address\"\n        );\n\n        quantConfig = IQuantConfig(_quantConfig);\n    }\n\n    /// @inheritdoc ICollateralToken\n    function createCollateralToken(\n        address _qTokenAddress,\n        address _qTokenAsCollateral\n    ) external override returns (uint256 id) {\n        id = getCollateralTokenId(_qTokenAddress, _qTokenAsCollateral);\n\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_CREATOR_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral creator can create new CollateralTokens\"\n        );\n\n        require(\n            _qTokenAddress != _qTokenAsCollateral,\n            \"CollateralToken: Can only create a collateral token with different tokens\"\n        );\n\n        require(\n            idToInfo[id].qTokenAddress == address(0),\n            \"CollateralToken: this token has already been created\"\n        );\n\n        idToInfo[id] = CollateralTokenInfo({\n            qTokenAddress: _qTokenAddress,\n            qTokenAsCollateral: _qTokenAsCollateral\n        });\n\n        collateralTokenIds.push(id);\n\n        emit CollateralTokenCreated(\n            _qTokenAddress,\n            _qTokenAsCollateral,\n            id,\n            collateralTokenIds.length\n        );\n    }\n\n    /// @inheritdoc ICollateralToken\n    function mintCollateralToken(\n        address recipient,\n        uint256 collateralTokenId,\n        uint256 amount\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_MINTER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral minter can mint CollateralTokens\"\n        );\n\n        emit CollateralTokenMinted(recipient, collateralTokenId, amount);\n\n        _mint(recipient, collateralTokenId, amount, \"\");\n    }\n\n    /// @inheritdoc ICollateralToken\n    function burnCollateralToken(\n        address owner,\n        uint256 collateralTokenId,\n        uint256 amount\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_BURNER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral burner can burn CollateralTokens\"\n        );\n        _burn(owner, collateralTokenId, amount);\n\n        emit CollateralTokenBurned(owner, collateralTokenId, amount);\n    }\n\n    /// @inheritdoc ICollateralToken\n    function mintCollateralTokenBatch(\n        address recipient,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_MINTER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral minter can mint CollateralTokens\"\n        );\n\n        uint256 length = ids.length;\n        for (uint256 i = 0; i < length; ) {\n            emit CollateralTokenMinted(recipient, ids[i], amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        _mintBatch(recipient, ids, amounts, \"\");\n    }\n\n    /// @inheritdoc ICollateralToken\n    function burnCollateralTokenBatch(\n        address owner,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_BURNER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral burner can burn CollateralTokens\"\n        );\n        _burnBatch(owner, ids, amounts);\n\n        uint256 length = ids.length;\n        for (uint256 i = 0; i < length; ) {\n            emit CollateralTokenBurned(owner, ids[i], amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc ICollateralToken\n    function metaSetApprovalForAll(\n        address owner,\n        address operator,\n        bool approved,\n        uint256 nonce,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        // solhint-disable-next-line not-rely-on-time\n        require(\n            block.timestamp <= deadline,\n            \"CollateralToken: expired deadline\"\n        );\n\n        require(nonce == nonces[owner], \"CollateralToken: invalid nonce\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _META_APPROVAL_TYPEHASH,\n                owner,\n                operator,\n                approved,\n                nonce,\n                deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ecrecover(hash, v, r, s);\n        require(signer == owner, \"CollateralToken: invalid signature\");\n\n        nonces[owner]++;\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /// @inheritdoc ICollateralToken\n    function getCollateralTokensLength()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return collateralTokenIds.length;\n    }\n\n    /// @inheritdoc ICollateralToken\n    function getCollateralTokenInfo(uint256 id)\n        external\n        view\n        override\n        returns (QTokensDetails memory qTokensDetails)\n    {\n        CollateralTokenInfo memory info = idToInfo[id];\n\n        require(\n            info.qTokenAddress != address(0),\n            \"CollateralToken: Invalid id\"\n        );\n\n        IQToken.QTokenInfo memory shortDetails = IQToken(info.qTokenAddress)\n            .getQTokenInfo();\n\n        qTokensDetails.underlyingAsset = shortDetails.underlyingAsset;\n        qTokensDetails.strikeAsset = shortDetails.strikeAsset;\n        qTokensDetails.oracle = shortDetails.oracle;\n        qTokensDetails.shortStrikePrice = shortDetails.strikePrice;\n        qTokensDetails.expiryTime = shortDetails.expiryTime;\n        qTokensDetails.isCall = shortDetails.isCall;\n\n        if (info.qTokenAsCollateral != address(0)) {\n            // the given id is for a CollateralToken representing a spread\n            qTokensDetails.longStrikePrice = IQToken(info.qTokenAsCollateral)\n                .strikePrice();\n        }\n    }\n\n    /// @inheritdoc ICollateralToken\n    function getCollateralTokenId(address _qToken, address _qTokenAsCollateral)\n        public\n        pure\n        override\n        returns (uint256 id)\n    {\n        id = uint256(keccak256(abi.encodePacked(_qToken, _qTokenAsCollateral)));\n    }\n}\n\n\n",
        "CodeNames": [
            "CollateralToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CollateralToken.sol",
                "Type": "Arbitrary Token Minting",
                "Description": "An address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens, posing a serious centralization risk.",
                "Repair": "Remove the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./TimelockController.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../libraries/ProtocolValue.sol\";\n\n/// @title Timelock controller contract for setting values in the QuantConfig and scheduling calls\n/// to external contracts.\n/// @author Rolla\n/// @dev Built on top of OpenZeppelin's TimelockController.\ncontract ConfigTimelockController is TimelockController {\n    mapping(bytes32 => uint256) public delays;\n\n    mapping(bytes32 => uint256) private _timestamps;\n\n    /// @notice The minimum delay for scheduled executions\n    uint256 public minDelay;\n\n    constructor(\n        uint256 _minDelay,\n        address[] memory _proposers,\n        address[] memory _executors\n    )\n        TimelockController(_minDelay, _proposers, _executors)\n    // solhint-disable-next-line no-empty-blocks\n    {\n        minDelay = _minDelay;\n    }\n\n    /// @notice Sets the delay for a specific protocol value\n    /// @param _protocolValue the bytes32 encoded representation of the protocol value\n    /// @param _newDelay the delay in seconds\n    function setDelay(bytes32 _protocolValue, uint256 _newDelay)\n        external\n        onlyRole(EXECUTOR_ROLE)\n    {\n        // Delays must be greater than or equal to the minimum delay\n        delays[_protocolValue] = _newDelay >= minDelay ? _newDelay : minDelay;\n    }\n\n    /// @inheritdoc TimelockController\n    function schedule(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay,\n        bool\n    ) public virtual override onlyRole(PROPOSER_ROLE) {\n        require(\n            !_isProtocoValueSetter(data),\n            \"ConfigTimelockController: Can not schedule changes to a protocol value with an arbitrary delay\"\n        );\n\n        super.schedule(target, value, data, predecessor, salt, delay, false);\n    }\n\n    /// @notice Schedule a call to set a protocol address in the QuantConfig contract\n    /// @param protocolAddress the encoded name of the protocol address variable to set in the config\n    /// @param newAddress the new address value to set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function scheduleSetProtocolAddress(\n        bytes32 protocolAddress,\n        address newAddress,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        bytes memory data = _encodeSetProtocolAddress(\n            protocolAddress,\n            newAddress,\n            quantConfig\n        );\n\n        uint256 delay = _getProtocolValueDelay(\n            quantConfig,\n            protocolAddress,\n            ProtocolValue.Type.Address\n        );\n\n        require(\n            eta >= delay + block.timestamp,\n            \"ConfigTimelockController: Estimated execution block must satisfy delay\"\n        );\n\n        super.schedule(\n            quantConfig,\n            0,\n            data,\n            bytes32(0),\n            bytes32(eta),\n            delay,\n            true\n        );\n    }\n\n    /// @notice Schedule a call to set a protocol uint256 in the QuantConfig contract\n    /// @param protocolUint256 the encoded name of the protocol uint256 variable to set in the config\n    /// @param newUint256 the new uint256 value to set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function scheduleSetProtocolUint256(\n        bytes32 protocolUint256,\n        uint256 newUint256,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        bytes memory data = _encodeSetProtocolUint256(\n            protocolUint256,\n            newUint256,\n            quantConfig\n        );\n\n        uint256 delay = _getProtocolValueDelay(\n            quantConfig,\n            protocolUint256,\n            ProtocolValue.Type.Uint256\n        );\n\n        require(\n            eta >= delay + block.timestamp,\n            \"ConfigTimelockController: Estimated execution block must satisfy delay\"\n        );\n\n        super.schedule(\n            quantConfig,\n            0,\n            data,\n            bytes32(0),\n            bytes32(eta),\n            delay,\n            true\n        );\n    }\n\n    /// @notice Schedule a call to set a protocol boolean in the QuantConfig contract\n    /// @param protocolBoolean the encoded name of the protocol boolean variable to set in the config\n    /// @param newBoolean the new boolean value to set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function scheduleSetProtocolBoolean(\n        bytes32 protocolBoolean,\n        bool newBoolean,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        bytes memory data = _encodeSetProtocolBoolean(\n            protocolBoolean,\n            newBoolean,\n            quantConfig\n        );\n\n        uint256 delay = _getProtocolValueDelay(\n            quantConfig,\n            protocolBoolean,\n            ProtocolValue.Type.Bool\n        );\n\n        require(\n            eta >= delay + block.timestamp,\n            \"ConfigTimelockController: Estimated execution block must satisfy delay\"\n        );\n        super.schedule(\n            quantConfig,\n            0,\n            data,\n            bytes32(0),\n            bytes32(eta),\n            delay,\n            true\n        );\n    }\n\n    /// @notice Schedule a call to set a protocol role in the QuantConfig contract\n    /// @param protocolRole the name of the protocol role variable to set in the config\n    /// @param roleAdmin address to be the role admin\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function scheduleSetProtocolRole(\n        string calldata protocolRole,\n        address roleAdmin,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        bytes memory data = _encodeSetProtocolRole(\n            protocolRole,\n            roleAdmin,\n            quantConfig\n        );\n\n        uint256 delay = _getProtocolValueDelay(\n            quantConfig,\n            keccak256(abi.encodePacked(protocolRole)),\n            ProtocolValue.Type.Role\n        );\n\n        require(\n            eta >= delay + block.timestamp,\n            \"ConfigTimelockController: Estimated execution block must satisfy delay\"\n        );\n\n        super.schedule(\n            quantConfig,\n            0,\n            data,\n            bytes32(0),\n            bytes32(eta),\n            delay,\n            true\n        );\n    }\n\n    /// @notice Schedule multiple contract calls\n    /// @dev Cannot schedule calls to set protocol values in the QuantConfig\n    /// @param targets array of contracts to receive the scheduled calls\n    /// @param values array of values to be sent to the contracts\n    /// @param datas array of data to be sent to the contracts\n    /// @param predecessor extra 32 bytes to be used when hashing the operation batch\n    /// @param salt salt to be used when hashing the operation batch\n    /// @param delay execution delay in seconds\n    function scheduleBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual override onlyRole(PROPOSER_ROLE) {\n        uint256 length = targets.length;\n        for (uint256 i = 0; i < length; ) {\n            require(\n                !_isProtocoValueSetter(datas[i]),\n                \"ConfigTimelockController: Can not schedule changes to a protocol value with an arbitrary delay\"\n            );\n            unchecked {\n                ++i;\n            }\n        }\n\n        super.scheduleBatch(targets, values, datas, predecessor, salt, delay);\n    }\n\n    /// @notice Schedule multiple calls to set protocol address values in the QuantConfig\n    /// @param protocolValues array of protocol address values to be set\n    /// @param newAddresses array of new addresses to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function scheduleBatchSetProtocolAddress(\n        bytes32[] calldata protocolValues,\n        address[] calldata newAddresses,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newAddresses.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            scheduleSetProtocolAddress(\n                protocolValues[i],\n                newAddresses[i],\n                quantConfig,\n                eta\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Schedule multiple calls to set protocol uint256 values in the QuantConfig\n    /// @param protocolValues array of protocol uint256 values to be set\n    /// @param newUints array of new uints to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function scheduleBatchSetProtocolUints(\n        bytes32[] calldata protocolValues,\n        uint256[] calldata newUints,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newUints.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            scheduleSetProtocolUint256(\n                protocolValues[i],\n                newUints[i],\n                quantConfig,\n                eta\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Schedule multiple calls to set protocol boolean values in the QuantConfig\n    /// @param protocolValues array of protocol boolean values to be set\n    /// @param newBooleans array of new booleans to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function scheduleBatchSetProtocolBooleans(\n        bytes32[] calldata protocolValues,\n        bool[] calldata newBooleans,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newBooleans.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            scheduleSetProtocolBoolean(\n                protocolValues[i],\n                newBooleans[i],\n                quantConfig,\n                eta\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Schedule multiple calls to set protocol roles in the QuantConfig\n    /// @param protocolRoles array of protocol roles to be set\n    /// @param roleAdmins array of role admins to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function scheduleBatchSetProtocolRoles(\n        string[] calldata protocolRoles,\n        address[] calldata roleAdmins,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        uint256 length = protocolRoles.length;\n\n        require(\n            length == roleAdmins.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            scheduleSetProtocolRole(\n                protocolRoles[i],\n                roleAdmins[i],\n                quantConfig,\n                eta\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Execute a scheduled call to set a protocol address value in the QuantConfig\n    /// @param protocolAddress the protocol address value to be set\n    /// @param newAddress the new address to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function executeSetProtocolAddress(\n        bytes32 protocolAddress,\n        address newAddress,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        execute(\n            quantConfig,\n            0,\n            _encodeSetProtocolAddress(protocolAddress, newAddress, quantConfig),\n            bytes32(0),\n            bytes32(eta)\n        );\n    }\n\n    /// @notice Execute a scheduled call to set a protocol uint256 value in the QuantConfig\n    /// @param protocolUint256 the protocol uint256 value to be set\n    /// @param newUint256 the new uint to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function executeSetProtocolUint256(\n        bytes32 protocolUint256,\n        uint256 newUint256,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        execute(\n            quantConfig,\n            0,\n            _encodeSetProtocolUint256(protocolUint256, newUint256, quantConfig),\n            bytes32(0),\n            bytes32(eta)\n        );\n    }\n\n    /// @notice Execute a scheduled call to set a protocol boolean value in the QuantConfig\n    /// @param protocolBoolean the protocol boolean value to be set\n    /// @param newBoolean the new boolean to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function executeSetProtocolBoolean(\n        bytes32 protocolBoolean,\n        bool newBoolean,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        execute(\n            quantConfig,\n            0,\n            _encodeSetProtocolBoolean(protocolBoolean, newBoolean, quantConfig),\n            bytes32(0),\n            bytes32(eta)\n        );\n    }\n\n    /// @notice Execute a scheduled call to set a protocol role in the QuantConfig\n    /// @param protocolRole the protocol role to be set\n    /// @param roleAdmin the role admin to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function executeSetProtocolRole(\n        string calldata protocolRole,\n        address roleAdmin,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        execute(\n            quantConfig,\n            0,\n            _encodeSetProtocolRole(protocolRole, roleAdmin, quantConfig),\n            bytes32(0),\n            bytes32(eta)\n        );\n    }\n\n    /// @notice Execute multiple scheduled calls to set protocol address values in the QuantConfig\n    /// @param protocolValues array of protocol address values to be set\n    /// @param newAddresses array of new addresses to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function executeBatchSetProtocolAddress(\n        bytes32[] calldata protocolValues,\n        address[] calldata newAddresses,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newAddresses.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            execute(\n                quantConfig,\n                0,\n                _encodeSetProtocolAddress(\n                    protocolValues[i],\n                    newAddresses[i],\n                    quantConfig\n                ),\n                bytes32(0),\n                bytes32(eta)\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Execute multiple scheduled calls to set protocol uint256 values in the QuantConfig\n    /// @param protocolValues array of protocol uint256 values to be set\n    /// @param newUints array of new uints to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function executeBatchSetProtocolUint256(\n        bytes32[] calldata protocolValues,\n        uint256[] calldata newUints,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newUints.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            execute(\n                quantConfig,\n                0,\n                _encodeSetProtocolUint256(\n                    protocolValues[i],\n                    newUints[i],\n                    quantConfig\n                ),\n                bytes32(0),\n                bytes32(eta)\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Execute multiple scheduled calls to set protocol boolean values in the QuantConfig\n    /// @param protocolValues array of protocol boolean values to be set\n    /// @param newBooleans array of new booleans to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function executeBatchSetProtocolBoolean(\n        bytes32[] calldata protocolValues,\n        bool[] calldata newBooleans,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newBooleans.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            execute(\n                quantConfig,\n                0,\n                _encodeSetProtocolBoolean(\n                    protocolValues[i],\n                    newBooleans[i],\n                    quantConfig\n                ),\n                bytes32(0),\n                bytes32(eta)\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Execute multiple scheduled calls to set protocol roles in the QuantConfig\n    /// @param protocolRoles array of protocol roles to be set\n    /// @param roleAdmins array of role admins to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function executeBatchSetProtocolRoles(\n        string[] calldata protocolRoles,\n        address[] calldata roleAdmins,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        uint256 length = protocolRoles.length;\n\n        require(\n            length == roleAdmins.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            execute(\n                quantConfig,\n                0,\n                _encodeSetProtocolRole(\n                    protocolRoles[i],\n                    roleAdmins[i],\n                    quantConfig\n                ),\n                bytes32(0),\n                bytes32(eta)\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the delay to set a specific protocol value using the timelock\n    /// @param quantConfig  the address of the QuantConfig contract\n    /// @param protocolValue the protocol value to get the delay for\n    /// @return the delay required to set the protocol value\n    function _getProtocolValueDelay(\n        address quantConfig,\n        bytes32 protocolValue,\n        ProtocolValue.Type protocolValueType\n    ) internal view returns (uint256) {\n        // There shouldn't be a delay when setting a protocol value for the first time\n        if (\n            !IQuantConfig(quantConfig).isProtocolValueSet(\n                protocolValue,\n                protocolValueType\n            )\n        ) {\n            return 0;\n        }\n\n        uint256 storedDelay = delays[protocolValue];\n        return storedDelay != 0 ? storedDelay : minDelay;\n    }\n\n    /// @notice Checks if a given calldata is for setting a protocol value, which could be used\n    /// to bypass the minimum delay required to set a protocol value of a specific type\n    /// @param data the calldata to check\n    /// @return true if the calldata is for setting a protocol value, false otherwise\n    /// @dev There could be a clash between the 4-byte selector for `setProtocolValue` functions\n    /// and other external functions. That's unlikely to happen, but if it does, scheduling calls\n    /// to those functions will always revert.\n    function _isProtocoValueSetter(bytes memory data)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes4 selector;\n\n        assembly {\n            selector := mload(add(data, 32))\n        }\n\n        return\n            selector == IQuantConfig(address(0)).setProtocolAddress.selector ||\n            selector == IQuantConfig(address(0)).setProtocolUint256.selector ||\n            selector == IQuantConfig(address(0)).setProtocolBoolean.selector;\n    }\n\n    /// @notice Encodes the calldata for setting a protocol address value\n    /// @param _protocolAddress the protocol address value to be set\n    /// @param _newAddress the new address to be set\n    /// @param _quantConfig the address of the QuantConfig contract\n    function _encodeSetProtocolAddress(\n        bytes32 _protocolAddress,\n        address _newAddress,\n        address _quantConfig\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                IQuantConfig(_quantConfig).setProtocolAddress.selector,\n                _protocolAddress,\n                _newAddress\n            );\n    }\n\n    /// @notice Encodes the calldata for setting a protocol uint256 value\n    /// @param _protocolUint256 the protocol uint256 value to be set\n    /// @param _newUint256 the new uint to be set\n    /// @param _quantConfig the address of the QuantConfig contract\n    function _encodeSetProtocolUint256(\n        bytes32 _protocolUint256,\n        uint256 _newUint256,\n        address _quantConfig\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                IQuantConfig(_quantConfig).setProtocolUint256.selector,\n                _protocolUint256,\n                _newUint256\n            );\n    }\n\n    /// @notice Encodes the calldata for setting a protocol boolean value\n    /// @param _protocolBoolean the protocol boolean value to be set\n    /// @param _newBoolean the new boolean to be set\n    /// @param _quantConfig the address of the QuantConfig contract\n    function _encodeSetProtocolBoolean(\n        bytes32 _protocolBoolean,\n        bool _newBoolean,\n        address _quantConfig\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                IQuantConfig(_quantConfig).setProtocolBoolean.selector,\n                _protocolBoolean,\n                _newBoolean\n            );\n    }\n\n    /// @notice Encodes the calldata for setting a protocol role\n    /// @param _protocolRole the protocol role to be set\n    /// @param _roleAdmin the role admin to be set\n    /// @param _quantConfig the address of the QuantConfig contract\n    function _encodeSetProtocolRole(\n        string memory _protocolRole,\n        address _roleAdmin,\n        address _quantConfig\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                IQuantConfig(_quantConfig).setProtocolRole.selector,\n                _protocolRole,\n                _roleAdmin\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "ConfigTimelockController.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ConfigTimelockController.sol",
                "Type": "Timelock Stalemate",
                "Description": "The state variable minimum delay can be set to an arbitrary value, up to type(uint256).max, and could potentially render the QuantConfig contract unusable.",
                "Repair": "Declare a constant with a MAXIMUM_DELAY and set the minimum delay below this value. Add a check to require sufficient gas to be paid."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IEIP712MetaTransaction.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../libraries/Actions.sol\";\nimport {ActionArgs} from \"../libraries/Actions.sol\";\n\n/// @title Contract to be inherited by contracts that want to support meta transactions.\n/// @author Rolla\ncontract EIP712MetaTransaction is EIP712Upgradeable {\n    using ECDSA for bytes32;\n\n    struct MetaAction {\n        uint256 nonce;\n        uint256 deadline;\n        address from;\n        ActionArgs[] actions;\n    }\n\n    bytes32 private constant _META_ACTION_TYPEHASH =\n        keccak256(\n            // solhint-disable-next-line max-line-length\n            \"MetaAction(uint256 nonce,uint256 deadline,address from,ActionArgs[] actions)ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)\"\n        );\n    bytes32 private constant _ACTION_TYPEHASH =\n        keccak256(\n            // solhint-disable-next-line max-line-length\n            \"ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)\"\n        );\n\n    mapping(address => uint256) private _nonces;\n\n    /// @notice user readable name of signing domain for EIP712 (the protocol name)\n    string public name;\n\n    /// @notice the current major version of the signing domain for EIP712\n    string public version;\n\n    /// @notice emitted when a meta transaction is executed\n    event MetaTransactionExecuted(\n        address indexed userAddress,\n        address payable indexed relayerAddress,\n        uint256 nonce\n    );\n\n    /// @notice Given an encoded action and a signature, executes the action on behalf of the signer.\n    /// @param metaAction The encoded action to be executed.\n    /// @param r The r-value of the signature.\n    /// @param s The s-value of the signature.\n    /// @param v The v-value of the signature.\n    /// @return The returned data from the low-level call.\n    function executeMetaTransaction(\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external payable returns (bytes memory) {\n        require(\n            _verify(metaAction.from, metaAction, r, s, v),\n            \"signer and signature don't match\"\n        );\n\n        uint256 currentNonce = _nonces[metaAction.from];\n\n        // intentionally allow this to overflow to save gas,\n        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs\n        unchecked {\n            _nonces[metaAction.from] = currentNonce + 1;\n        }\n\n        // Append the metaAction.from at the end so that it can be extracted later\n        // from the calling context (see _msgSender() below)\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    IController(address(this)).operate.selector,\n                    metaAction.actions\n                ),\n                metaAction.from\n            )\n        );\n\n        require(success, \"unsuccessful function call\");\n        emit MetaTransactionExecuted(\n            metaAction.from,\n            payable(msg.sender),\n            currentNonce\n        );\n        return returnData;\n    }\n\n    /// @notice Returns the current nonce for a user.\n    /// @param user the address of the user to get the nonce for.\n    /// @return nonce the current nonce for the user.\n    function getNonce(address user) external view returns (uint256 nonce) {\n        nonce = _nonces[user];\n    }\n\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n\n    /// @notice Returns the address of the signer when called from this contract,\n    /// otherwise returns the msg.sender\n    /// @return sender the address of the signer or msg.sender\n    function _msgSender() internal view returns (address sender) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender = msg.sender;\n        }\n        return sender;\n    }\n\n    /// @notice Verifies that the signature is valid for a given user and action.\n    /// @param user the address to check as the signer.\n    /// @param metaAction the action struct to check.\n    /// @param r the r-value of the signature.\n    /// @param s the s-value of the signature.\n    /// @param v the v-value of the signature.\n    function _verify(\n        address user,\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal view returns (bool) {\n        require(metaAction.nonce == _nonces[user], \"invalid nonce\");\n\n        require(metaAction.deadline >= block.timestamp, \"expired deadline\");\n\n        address signer = _hashTypedDataV4(_hashMetaAction(metaAction)).recover(\n            v,\n            r,\n            s\n        );\n\n        return signer == user;\n    }\n\n    /// @notice Hashes a given ActionArgs struct to be used with EIP712.\n    /// @param action the ActionArgs struct to hash.\n    /// @return the hash of the ActionArgs struct.\n    function _hashAction(ActionArgs memory action)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _ACTION_TYPEHASH,\n                    action.actionType,\n                    action.qToken,\n                    action.secondaryAddress,\n                    action.receiver,\n                    action.amount,\n                    action.collateralTokenId,\n                    keccak256(action.data)\n                )\n            );\n    }\n\n    /// @notice Hashes an array of ActionArgs structs to be used with EIP712.\n    /// @param actions the array of ActionArgs structs to hash.\n    /// @return the array of hashes for the ActionArgs structs.\n    function _hashActions(ActionArgs[] memory actions)\n        private\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory hashedActions = new bytes32[](actions.length);\n        uint256 length = actions.length;\n        for (uint256 i = 0; i < length; ) {\n            hashedActions[i] = _hashAction(actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return hashedActions;\n    }\n\n    /// @notice Hashes a MetaAction struct to be used with EIP712.\n    /// @param metaAction the MetaAction struct to hash.\n    /// @return the hash of the MetaAction struct.\n    function _hashMetaAction(MetaAction memory metaAction)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _META_ACTION_TYPEHASH,\n                    metaAction.nonce,\n                    metaAction.deadline,\n                    metaAction.from,\n                    keccak256(\n                        abi.encodePacked(_hashActions(metaAction.actions))\n                    )\n                )\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "EIP712MetaTransaction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "EIP712MetaTransaction.sol",
                "Type": "Replay Attack",
                "Description": "Once the low-level call fails, the whole transaction will be reverted, and the same transaction can be replayed by anyone using the same signature.",
                "Repair": "Failed transactions should still increase the nonce. Add a check to require sufficient gas to be paid."
            },
            {
                "Location": "EIP712MetaTransaction.sol",
                "Type": "Wrong Implementation",
                "Description": "EIP712MetaTransaction's initializer function uses the initializer modifier instead of onlyInitializing modifier, and the contract is not declared as abstract.",
                "Repair": "Use onlyInitializing modifier instead of initializer modifier in the initializer function. Declare the contract as abstract and the initializer function as internal."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"../../interfaces/external/chainlink/IEACAggregatorProxy.sol\";\nimport \"../PriceRegistry.sol\";\nimport \"./ProviderOracleManager.sol\";\nimport \"../../libraries/ProtocolValue.sol\";\nimport \"../../libraries/QuantMath.sol\";\nimport \"../../interfaces/IChainlinkOracleManager.sol\";\n\n/// @title For managing chainlink oracles for assets and submitting chainlink prices to the registry\n/// @author Rolla\n/// @notice Once an oracle is added for an asset it can't be changed!\ncontract ChainlinkOracleManager is\n    ProviderOracleManager,\n    IChainlinkOracleManager\n{\n    using QuantMath for uint256;\n    using QuantMath for QuantMath.FixedPointInt;\n\n    struct BinarySearchResult {\n        uint80 firstRound;\n        uint80 lastRound;\n        uint80 firstRoundProxy;\n        uint80 lastRoundProxy;\n    }\n\n    uint256 public immutable override fallbackPeriodSeconds;\n    uint8 public immutable override strikeAssetDecimals;\n    uint8 public constant CHAINLINK_ORACLE_DECIMALS = 8;\n\n    /// @param _config address of quant central configuration\n    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit\n    constructor(\n        address _config,\n        uint8 _strikeAssetDecimals,\n        uint256 _fallbackPeriodSeconds\n    ) ProviderOracleManager(_config) {\n        fallbackPeriodSeconds = _fallbackPeriodSeconds;\n        strikeAssetDecimals = _strikeAssetDecimals;\n    }\n\n    /// @inheritdoc IChainlinkOracleManager\n    function setExpiryPriceInRegistryByRound(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _roundIdAfterExpiry\n    ) external override {\n        _setExpiryPriceInRegistryByRound(\n            _asset,\n            _expiryTimestamp,\n            _roundIdAfterExpiry\n        );\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function setExpiryPriceInRegistry(\n        address _asset,\n        uint256 _expiryTimestamp,\n        bytes memory\n    ) external override(ProviderOracleManager, IProviderOracleManager) {\n        //search and get round\n        uint80 roundAfterExpiry = searchRoundToSubmit(_asset, _expiryTimestamp);\n\n        //submit price to registry\n        _setExpiryPriceInRegistryByRound(\n            _asset,\n            _expiryTimestamp,\n            roundAfterExpiry\n        );\n    }\n\n    /// @inheritdoc IOracleFallbackMechanism\n    function setExpiryPriceInRegistryFallback(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external override {\n        require(\n            config.hasRole(\n                config.quantRoles(\"FALLBACK_PRICE_ROLE\"),\n                msg.sender\n            ),\n            \"ChainlinkOracleManager: Only the fallback price submitter can submit a fallback price\"\n        );\n\n        require(\n            block.timestamp >= _expiryTimestamp + fallbackPeriodSeconds,\n            \"ChainlinkOracleManager: The fallback price period has not passed since the timestamp\"\n        );\n\n        emit PriceRegistrySubmission(\n            _asset,\n            _expiryTimestamp,\n            _price,\n            0,\n            msg.sender,\n            true\n        );\n\n        PriceRegistry(\n            config.protocolAddresses(ProtocolValue.encode(\"priceRegistry\"))\n        ).setSettlementPrice(\n                _asset,\n                _expiryTimestamp,\n                _price,\n                CHAINLINK_ORACLE_DECIMALS\n            );\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function getCurrentPrice(address _asset)\n        external\n        view\n        override(ProviderOracleManager, IProviderOracleManager)\n        returns (uint256)\n    {\n        address assetOracle = getAssetOracle(_asset);\n        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);\n        int256 answer = aggregator.latestAnswer();\n        require(\n            answer > 0,\n            \"ChainlinkOracleManager: No pricing data available\"\n        );\n\n        return\n            uint256(answer)\n                .fromScaledUint(CHAINLINK_ORACLE_DECIMALS)\n                .toScaledUint(strikeAssetDecimals, true);\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function isValidOption(\n        address,\n        uint256,\n        uint256\n    )\n        public\n        view\n        virtual\n        override(ProviderOracleManager, IProviderOracleManager)\n        returns (bool)\n    {\n        return true;\n    }\n\n    /// @inheritdoc IChainlinkOracleManager\n    function searchRoundToSubmit(address _asset, uint256 _expiryTimestamp)\n        public\n        view\n        override\n        returns (uint80)\n    {\n        address assetOracle = getAssetOracle(_asset);\n\n        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);\n\n        require(\n            aggregator.latestTimestamp() > _expiryTimestamp,\n            \"ChainlinkOracleManager: The latest round timestamp is not after the expiry timestamp\"\n        );\n\n        uint80 latestRound = uint80(aggregator.latestRound());\n\n        uint16 phaseOffset = 64;\n        uint16 phaseId = uint16(latestRound >> phaseOffset);\n\n        uint80 lowestPossibleRound = uint80((phaseId << phaseOffset) | 1);\n        uint80 highestPossibleRound = latestRound;\n        uint80 firstId = lowestPossibleRound;\n        uint80 lastId = highestPossibleRound;\n\n        require(\n            lastId > firstId,\n            \"ChainlinkOracleManager: Not enough rounds to find round after\"\n        );\n\n        //binary search until we find two values our desired timestamp lies between\n        while (lastId - firstId != 1) {\n            BinarySearchResult memory result = _binarySearchStep(\n                aggregator,\n                _expiryTimestamp,\n                lowestPossibleRound,\n                highestPossibleRound\n            );\n\n            lowestPossibleRound = result.firstRound;\n            highestPossibleRound = result.lastRound;\n            firstId = result.firstRoundProxy;\n            lastId = result.lastRoundProxy;\n        }\n\n        return highestPossibleRound; //return round above\n    }\n\n    /// @notice Get the expiry price from chainlink asset oracle and store it in the price registry\n    /// @param _asset asset to set price of\n    /// @param _expiryTimestamp timestamp of price\n    /// @param _roundIdAfterExpiry the chainlink round id immediately after the option expired\n    function _setExpiryPriceInRegistryByRound(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _roundIdAfterExpiry\n    ) internal {\n        address assetOracle = getAssetOracle(_asset);\n\n        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);\n\n        require(\n            aggregator.getTimestamp(uint256(_roundIdAfterExpiry)) >\n                _expiryTimestamp,\n            \"ChainlinkOracleManager: The round posted is not after the expiry timestamp\"\n        );\n\n        uint16 phaseOffset = 64;\n        uint16 phaseId = uint16(_roundIdAfterExpiry >> phaseOffset);\n\n        uint64 expiryRound = uint64(_roundIdAfterExpiry) - 1;\n        uint80 expiryRoundId = uint80(\n            (uint256(phaseId) << phaseOffset) | expiryRound\n        );\n\n        require(\n            aggregator.getTimestamp(uint256(expiryRoundId)) <= _expiryTimestamp,\n            \"ChainlinkOracleManager: Expiry round prior to the one posted is after the expiry timestamp\"\n        );\n\n        (uint256 price, uint256 roundId) = _getExpiryPrice(\n            aggregator,\n            _expiryTimestamp,\n            _roundIdAfterExpiry,\n            expiryRoundId\n        );\n\n        emit PriceRegistrySubmission(\n            _asset,\n            _expiryTimestamp,\n            price,\n            roundId,\n            msg.sender,\n            false\n        );\n\n        PriceRegistry(\n            config.protocolAddresses(ProtocolValue.encode(\"priceRegistry\"))\n        ).setSettlementPrice(\n                _asset,\n                _expiryTimestamp,\n                price,\n                CHAINLINK_ORACLE_DECIMALS\n            );\n    }\n\n    function _getExpiryPrice(\n        IEACAggregatorProxy aggregator,\n        uint256,\n        uint256,\n        uint256 _expiryRoundId\n    ) internal view virtual returns (uint256, uint256) {\n        return (uint256(aggregator.getAnswer(_expiryRoundId)), _expiryRoundId);\n    }\n\n    /// @notice Performs a binary search step between the first and last round in the aggregator proxy\n    /// @param _expiryTimestamp expiry timestamp to find the price at\n    /// @param _firstRoundProxy the lowest possible round for the timestamp\n    /// @param _lastRoundProxy the highest possible round for the timestamp\n    /// @return a binary search result object representing lowest and highest possible rounds of the timestamp\n    function _binarySearchStep(\n        IEACAggregatorProxy aggregator,\n        uint256 _expiryTimestamp,\n        uint80 _firstRoundProxy,\n        uint80 _lastRoundProxy\n    ) internal view returns (BinarySearchResult memory) {\n        uint16 phaseOffset = 64;\n        uint16 phaseId = uint16(_lastRoundProxy >> phaseOffset);\n\n        uint64 lastRoundId = uint64(_lastRoundProxy);\n        uint64 firstRoundId = uint64(_firstRoundProxy);\n\n        uint80 roundToCheck = uint80(\n            (uint256(firstRoundId) + uint256(lastRoundId)) / 2\n        );\n        uint80 roundToCheckProxy = uint80(\n            (uint256(phaseId) << phaseOffset) | roundToCheck\n        );\n\n        uint256 roundToCheckTimestamp = aggregator.getTimestamp(\n            uint256(roundToCheckProxy)\n        );\n\n        if (roundToCheckTimestamp <= _expiryTimestamp) {\n            return\n                BinarySearchResult(\n                    roundToCheckProxy,\n                    _lastRoundProxy,\n                    roundToCheck,\n                    lastRoundId\n                );\n        }\n\n        return\n            BinarySearchResult(\n                _firstRoundProxy,\n                roundToCheckProxy,\n                firstRoundId,\n                roundToCheck\n            );\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./ChainlinkOracleManager.sol\";\nimport \"../../interfaces/external/chainlink/IEACAggregatorProxy.sol\";\nimport \"../../interfaces/IChainlinkFixedTimeOracleManager.sol\";\n\n/// @title For managing Chainlink oracles with updates at fixed times.\n/// @author Rolla\n/// @notice Update times are counted as seconds since the start of the day.\ncontract ChainlinkFixedTimeOracleManager is\n    ChainlinkOracleManager,\n    IChainlinkFixedTimeOracleManager\n{\n    mapping(uint256 => bool) public override chainlinkFixedTimeUpdates;\n\n    /// @param _config address of quant central configuration\n    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit\n    constructor(\n        address _config,\n        uint8 _strikeAssetDecimals,\n        uint256 _fallbackPeriodSeconds\n    )\n        ChainlinkOracleManager(\n            _config,\n            _strikeAssetDecimals,\n            _fallbackPeriodSeconds\n        )\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    /// @inheritdoc IChainlinkFixedTimeOracleManager\n    function setFixedTimeUpdate(uint256 fixedTime, bool isValidTime)\n        external\n        override\n    {\n        require(\n            config.hasRole(\n                config.quantRoles(\"ORACLE_MANAGER_ROLE\"),\n                msg.sender\n            ),\n            \"ChainlinkFixedTimeOracleManager: Only an oracle admin can add a fixed time for updates\"\n        );\n\n        chainlinkFixedTimeUpdates[fixedTime] = isValidTime;\n\n        emit FixedTimeUpdate(fixedTime, isValidTime);\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function isValidOption(\n        address,\n        uint256 _expiryTime,\n        uint256\n    )\n        public\n        view\n        override(ChainlinkOracleManager, IProviderOracleManager)\n        returns (bool)\n    {\n        uint256 timeInSeconds = _expiryTime % 86400;\n        return chainlinkFixedTimeUpdates[timeInSeconds];\n    }\n\n    /// @notice Gets the price and roundId for a given expiry time.\n    /// @param aggregator address of the Chainlink aggregator proxy contract\n    /// @param _expiryTimestamp option expiration timestamp in seconds since the Unix epoch\n    /// @param _roundIdAfterExpiry id of the round right after the expiry\n    /// @param _expiryRoundId id of the round right before or at the expiry\n    function _getExpiryPrice(\n        IEACAggregatorProxy aggregator,\n        uint256 _expiryTimestamp,\n        uint256 _roundIdAfterExpiry,\n        uint256 _expiryRoundId\n    ) internal view override returns (uint256 price, uint256 roundId) {\n        if (\n            aggregator.getTimestamp(uint256(_expiryRoundId)) == _expiryTimestamp\n        ) {\n            price = uint256(aggregator.getAnswer(_expiryRoundId));\n            roundId = _expiryRoundId;\n        } else {\n            price = uint256(aggregator.getAnswer(_roundIdAfterExpiry));\n            roundId = _roundIdAfterExpiry;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "ChainlinkOracleManager.sol",
            "ChainlinkFixedTimeOracleManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ChainlinkOracleManager.sol#L120, ChainlinkFixedTimeOracleManager.sol#L81, ChainlinkFixedTimeOracleManager.sol#L84",
                "Type": "Usage of deprecated Chainlink functions",
                "Description": "The Chainlink functions latestAnswer() and getAnswer() are deprecated and should be replaced with latestRoundData() and getRoundData() respectively.",
                "Repair": "Switch to latestRoundData() as described in the Chainlink documentation"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\nabstract contract TimelockController is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE =\n        keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(\n            msg.sender == address(this),\n            \"TimelockController: caller must be timelock\"\n        );\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay,\n        bool ignoreMinDelay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay, ignoreMinDelay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(\n            targets.length == values.length,\n            \"TimelockController: length mismatch\"\n        );\n        require(\n            targets.length == datas.length,\n            \"TimelockController: length mismatch\"\n        );\n\n        bytes32 id = hashOperationBatch(\n            targets,\n            values,\n            datas,\n            predecessor,\n            salt\n        );\n        _schedule(id, delay, false);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(\n                id,\n                i,\n                targets[i],\n                values[i],\n                datas[i],\n                predecessor,\n                delay\n            );\n        }\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(\n            isOperationPending(id),\n            \"TimelockController: operation cannot be cancelled\"\n        );\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRole(EXECUTOR_ROLE) {\n        require(\n            targets.length == values.length,\n            \"TimelockController: length mismatch\"\n        );\n        require(\n            targets.length == datas.length,\n            \"TimelockController: length mismatch\"\n        );\n\n        bytes32 id = hashOperationBatch(\n            targets,\n            values,\n            datas,\n            predecessor,\n            salt\n        );\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id)\n        public\n        view\n        virtual\n        returns (bool pending)\n    {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id)\n        public\n        view\n        virtual\n        returns (bool pending)\n    {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id)\n        public\n        view\n        virtual\n        returns (bool ready)\n    {\n        uint256 timestamp = getTimestamp(id);\n        // solhint-disable-next-line not-rely-on-time\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id)\n        public\n        view\n        virtual\n        returns (bool done)\n    {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id)\n        public\n        view\n        virtual\n        returns (uint256 timestamp)\n    {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(\n        bytes32 id,\n        uint256 delay,\n        bool ignoreMinDelay\n    ) private {\n        require(\n            !isOperation(id),\n            \"TimelockController: operation already scheduled\"\n        );\n        require(\n            ignoreMinDelay || delay >= getMinDelay(),\n            \"TimelockController: insufficient delay\"\n        );\n        // solhint-disable-next-line not-rely-on-time\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(\n            isOperationReady(id),\n            \"TimelockController: operation is not ready\"\n        );\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(\n            isOperationReady(id),\n            \"TimelockController: operation is not ready\"\n        );\n        require(\n            predecessor == bytes32(0) || isOperationDone(predecessor),\n            \"TimelockController: missing dependency\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "TimelockController.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TimelockController.sol#L414-L415",
                "Type": "Low-level transfer via call() can fail silently",
                "Description": "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, which can cause transfers to fail silently.",
                "Repair": "Check for the account's existence prior to transferring"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./QuantMath.sol\";\nimport \"../options/QToken.sol\";\nimport \"../interfaces/IPriceRegistry.sol\";\n\n/// @title For calculating collateral requirements and payouts for options and spreads\n/// in a fixed point format\n/// @author Rolla\nlibrary FundsCalculator {\n    using QuantMath for uint256;\n    using QuantMath for int256;\n    using QuantMath for QuantMath.FixedPointInt;\n\n    struct OptionPayoutInput {\n        QuantMath.FixedPointInt strikePrice;\n        QuantMath.FixedPointInt expiryPrice;\n        QuantMath.FixedPointInt amount;\n    }\n\n    /// @notice Calculates payout of an option post-expiry from a qToken address\n    /// @param _qToken the address of the qToken (option) which is being exercised\n    /// @param _amount the amount of the qToken which is being exercised\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @param _expiryPrice the expiry price of the option with the amount of decimals\n    /// @return payoutToken the address of the payout token\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayout(\n        address _qToken,\n        uint256 _amount,\n        uint8 _optionsDecimals,\n        uint8 _strikeAssetDecimals,\n        IPriceRegistry.PriceWithDecimals memory _expiryPrice\n    )\n        internal\n        view\n        returns (\n            address payoutToken,\n            QuantMath.FixedPointInt memory payoutAmount\n        )\n    {\n        QToken qToken = QToken(_qToken);\n        bool isCall = qToken.isCall();\n\n        payoutToken = isCall ? qToken.underlyingAsset() : qToken.strikeAsset();\n\n        payoutAmount = getPayoutAmount(\n            isCall,\n            qToken.strikePrice(),\n            _amount,\n            _optionsDecimals,\n            _strikeAssetDecimals,\n            _expiryPrice\n        );\n    }\n\n    /// @notice Calculates the collateral required to mint an option or a spread\n    /// @param _qTokenToMint the desired qToken\n    /// @param _qTokenForCollateral for spreads, this is the address of the qtoken to be used as collateral.\n    /// for options, no collateral is provided so the zero address should be passed.\n    /// @param _optionsAmount the amount of options/spread to mint\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateral the address of the collateral token required\n    /// @return collateralAmount the collateral amount required as a fixed point type\n    function getCollateralRequirement(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _optionsAmount,\n        uint8 _optionsDecimals,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        view\n        returns (\n            address collateral,\n            QuantMath.FixedPointInt memory collateralAmount\n        )\n    {\n        QToken qTokenToMint = QToken(_qTokenToMint);\n        uint256 qTokenToMintStrikePrice = qTokenToMint.strikePrice();\n\n        uint256 qTokenForCollateralStrikePrice;\n\n        // check if we're getting the collateral requirement for a spread\n        if (_qTokenForCollateral != address(0)) {\n            QToken qTokenForCollateral = QToken(_qTokenForCollateral);\n            qTokenForCollateralStrikePrice = qTokenForCollateral.strikePrice();\n\n            // Check that expiries match\n            require(\n                qTokenToMint.expiryTime() == qTokenForCollateral.expiryTime(),\n                \"Controller: Can't create spreads from options with different expiries\"\n            );\n\n            // Check that the underlyings match\n            require(\n                qTokenToMint.underlyingAsset() ==\n                    qTokenForCollateral.underlyingAsset(),\n                \"Controller: Can't create spreads from options with different underlying assets\"\n            );\n\n            // Check that the option types match\n            require(\n                qTokenToMint.isCall() == qTokenForCollateral.isCall(),\n                \"Controller: Can't create spreads from options with different types\"\n            );\n\n            // Check that the options have a matching oracle\n            require(\n                qTokenToMint.oracle() == qTokenForCollateral.oracle(),\n                \"Controller: Can't create spreads from options with different oracles\"\n            );\n        } else {\n            // we're not getting the collateral requirement for a spread\n            qTokenForCollateralStrikePrice = 0;\n        }\n\n        collateralAmount = getOptionCollateralRequirement(\n            qTokenToMintStrikePrice,\n            qTokenForCollateralStrikePrice,\n            _optionsAmount,\n            qTokenToMint.isCall(),\n            _optionsDecimals,\n            _underlyingDecimals,\n            _strikeAssetDecimals\n        );\n\n        collateral = qTokenToMint.isCall()\n            ? qTokenToMint.underlyingAsset()\n            : qTokenToMint.strikeAsset();\n    }\n\n    /// @notice Calculates payout of an option post-expiry from qToken attributes\n    /// @param _isCall true if the option is a call, false for a put\n    /// @param _strikePrice the strike price of the option\n    /// @param _amount the amount of options being exercised\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @param _expiryPrice the expiry price of the option with the amount of decimals\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutAmount(\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _amount,\n        uint8 _optionsDecimals,\n        uint8 _strikeAssetDecimals,\n        IPriceRegistry.PriceWithDecimals memory _expiryPrice\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        FundsCalculator.OptionPayoutInput memory payoutInput = FundsCalculator\n            .OptionPayoutInput(\n                _strikePrice.fromScaledUint(_strikeAssetDecimals),\n                _expiryPrice.price.fromScaledUint(_expiryPrice.decimals),\n                _amount.fromScaledUint(_optionsDecimals)\n            );\n\n        if (_isCall) {\n            payoutAmount = getPayoutForCall(payoutInput);\n        } else {\n            payoutAmount = getPayoutForPut(payoutInput);\n        }\n    }\n\n    /// @notice Calculates payout of a call given option payout inputs of strike, expiry and amount\n    /// @param payoutInput strike, expiry and amount as fixed points\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutForCall(\n        FundsCalculator.OptionPayoutInput memory payoutInput\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        payoutAmount = payoutInput.expiryPrice.isGreaterThan(\n            payoutInput.strikePrice\n        )\n            ? payoutInput\n                .expiryPrice\n                .sub(payoutInput.strikePrice)\n                .mul(payoutInput.amount)\n                .div(payoutInput.expiryPrice)\n            : int256(0).fromUnscaledInt();\n    }\n\n    /// @notice Calculates payout of a put given option payout inputs of strike, expiry and amount\n    /// @param payoutInput strike, expiry and amount as fixed points\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutForPut(\n        FundsCalculator.OptionPayoutInput memory payoutInput\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        payoutAmount = payoutInput.strikePrice.isGreaterThan(\n            payoutInput.expiryPrice\n        )\n            ? (payoutInput.strikePrice.sub(payoutInput.expiryPrice)).mul(\n                payoutInput.amount\n            )\n            : int256(0).fromUnscaledInt();\n    }\n\n    /// @notice Calculates the collateral required to mint an option or spread\n    /// @param _qTokenToMintStrikePrice the strike price of the qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the qToken being used as\n    /// collateral in the case of a spread\n    /// @param _optionsAmount the amount of options/spread being minted\n    /// @param _qTokenToMintIsCall whether or not the token to mint is a call. if a spread,\n    /// the qToken as collateral is implicitly also a call. and for minting a put, the \n    /// qToken as collateral is implicitly also a put\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralAmount the collateral amount required as a fixed point type    \n    function getOptionCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint256 _optionsAmount,\n        bool _qTokenToMintIsCall,\n        uint8 _optionsDecimals,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    ) internal pure returns (QuantMath.FixedPointInt memory collateralAmount) {\n        QuantMath.FixedPointInt memory collateralPerOption;\n        if (_qTokenToMintIsCall) {\n            collateralPerOption = getCallCollateralRequirement(\n                _qTokenToMintStrikePrice,\n                _qTokenForCollateralStrikePrice,\n                _underlyingDecimals,\n                _strikeAssetDecimals\n            );\n        } else {\n            collateralPerOption = getPutCollateralRequirement(\n                _qTokenToMintStrikePrice,\n                _qTokenForCollateralStrikePrice,\n                _strikeAssetDecimals\n            );\n        }\n\n        collateralAmount = _optionsAmount.fromScaledUint(_optionsDecimals).mul(\n            collateralPerOption\n        );\n    }\n\n    /// @notice Calculates the collateral required to mint a single PUT option or PUT spread\n    /// @param _qTokenToMintStrikePrice the strike price of the PUT qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the PUT qToken being used as\n    /// collateral in the case of a spread\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralPerOption the collateral amount required per option as a fixed point type\n    function getPutCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        pure\n        returns (QuantMath.FixedPointInt memory collateralPerOption)\n    {\n        QuantMath.FixedPointInt\n            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(\n                _strikeAssetDecimals\n            );\n        QuantMath.FixedPointInt\n            memory collateralStrikePrice = _qTokenForCollateralStrikePrice\n                .fromScaledUint(_strikeAssetDecimals);\n\n        // Initially (non-spread) required collateral is the long strike price\n        collateralPerOption = mintStrikePrice;\n\n        if (_qTokenForCollateralStrikePrice > 0) {\n            collateralPerOption = mintStrikePrice.isGreaterThan(\n                collateralStrikePrice\n            )\n                ? mintStrikePrice.sub(collateralStrikePrice) // Put Credit Spread\n                : int256(0).fromUnscaledInt(); // Put Debit Spread\n        }\n    }\n\n    /// @notice Calculates the collateral required to mint a single CALL option or CALL spread\n    /// @param _qTokenToMintStrikePrice the strike price of the CALL qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the CALL qToken being\n    /// used as collateral in the case of a spread\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralPerOption the collateral amount required per option as a fixed point type\n    function getCallCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        pure\n        returns (QuantMath.FixedPointInt memory collateralPerOption)\n    {\n        QuantMath.FixedPointInt\n            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(\n                _strikeAssetDecimals\n            );\n        QuantMath.FixedPointInt\n            memory collateralStrikePrice = _qTokenForCollateralStrikePrice\n                .fromScaledUint(_strikeAssetDecimals);\n\n        // Initially (non-spread) required collateral is the long strike price\n        collateralPerOption = (10**_underlyingDecimals).fromScaledUint(\n            _underlyingDecimals\n        );\n\n        if (_qTokenForCollateralStrikePrice > 0) {\n            collateralPerOption = mintStrikePrice.isGreaterThanOrEqual(\n                collateralStrikePrice\n            )\n                ? int256(0).fromUnscaledInt() // Call Debit Spread\n                : (collateralStrikePrice.sub(mintStrikePrice)).div(\n                    collateralStrikePrice\n                ); // Call Credit Spread\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "FundsCalculator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FundsCalculator.sol#L91-L117",
                "Type": "Spreads can be minted with a deactivated oracle",
                "Description": "When an oracle is deactivated, it is still available for option spreads minting, allowing users to mint new options within spreads that rely on a deactivated oracle.",
                "Repair": "Require the oracle to be active on spreads minting as well"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./QuantConfig.sol\";\nimport \"./utils/EIP712MetaTransaction.sol\";\nimport \"./utils/OperateProxy.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IOracleRegistry.sol\";\nimport \"./interfaces/ICollateralToken.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IOperateProxy.sol\";\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./libraries/ProtocolValue.sol\";\nimport \"./libraries/QuantMath.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/Actions.sol\";\n\n/// @title The main entry point in the Quant Protocol\n/// @author Rolla\n/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.\n/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.\n/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.\n/// @dev This contract is an upgradeable proxy, and it supports meta transactions.\n/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the\n/// OptionsFactory first.\ncontract Controller is\n    IController,\n    EIP712MetaTransaction,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using QuantMath for QuantMath.FixedPointInt;\n    using Actions for ActionArgs;\n\n    /// @inheritdoc IController\n    address public override optionsFactory;\n\n    /// @inheritdoc IController\n    address public override operateProxy;\n\n    /// @inheritdoc IController\n    address public override quantCalculator;\n\n    /// @inheritdoc IController\n    function operate(ActionArgs[] memory _actions)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        uint256 length = _actions.length;\n        for (uint256 i = 0; i < length; ) {\n            ActionArgs memory action = _actions[i];\n\n            if (action.actionType == ActionType.MintOption) {\n                (address to, address qToken, uint256 amount) = action\n                    .parseMintOptionArgs();\n                _mintOptionsPosition(to, qToken, amount);\n            } else if (action.actionType == ActionType.MintSpread) {\n                (\n                    address qTokenToMint,\n                    address qTokenForCollateral,\n                    uint256 amount\n                ) = action.parseMintSpreadArgs();\n                _mintSpread(qTokenToMint, qTokenForCollateral, amount);\n            } else if (action.actionType == ActionType.Exercise) {\n                (address qToken, uint256 amount) = action.parseExerciseArgs();\n                _exercise(qToken, amount);\n            } else if (action.actionType == ActionType.ClaimCollateral) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseClaimCollateralArgs();\n                _claimCollateral(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.Neutralize) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseNeutralizeArgs();\n                _neutralizePosition(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.QTokenPermit) {\n                (\n                    address qToken,\n                    address owner,\n                    address spender,\n                    uint256 value,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseQTokenPermitArgs();\n                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);\n            } else if (\n                action.actionType == ActionType.CollateralTokenApproval\n            ) {\n                (\n                    address owner,\n                    address operator,\n                    bool approved,\n                    uint256 nonce,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseCollateralTokenApprovalArgs();\n                _collateralTokenApproval(\n                    owner,\n                    operator,\n                    approved,\n                    nonce,\n                    deadline,\n                    v,\n                    r,\n                    s\n                );\n            } else {\n                require(\n                    action.actionType == ActionType.Call,\n                    \"Controller: Invalid action type\"\n                );\n                (address callee, bytes memory data) = action.parseCallArgs();\n                _call(callee, data);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n\n    // @inheritdoc IController\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _optionsFactory,\n        address _quantCalculator\n    ) public override initializer {\n        require(\n            _optionsFactory != address(0),\n            \"Controller: invalid OptionsFactory address\"\n        );\n        require(\n            _quantCalculator != address(0),\n            \"Controller: invalid QuantCalculator address\"\n        );\n\n        __ReentrancyGuard_init();\n        EIP712MetaTransaction.initializeEIP712(_name, _version);\n        optionsFactory = _optionsFactory;\n\n        /// @dev Unless this line is removed, a new OperateProxy will be created\n        /// during each upgrade. So make sure any application that requires approving\n        /// the OperateProxy to spend funds is aware of this.\n        operateProxy = address(new OperateProxy());\n\n        quantCalculator = _quantCalculator;\n    }\n\n    /// @notice Mints options for a given QToken, which must have been previously created in\n    /// the configured OptionsFactory.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset, and then this function can be called, pulling the collateral\n    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.\n    /// Note that QTokens represent a long position, giving holders the ability to exercise options\n    /// after expiry, while CollateralTokens represent a short position, giving holders the ability\n    /// to claim the collateral after expiry.\n    /// @param _to The address to which the QTokens and CollateralTokens will be minted.\n    /// @param _qToken The QToken that represents the long position for the option to be minted.\n    /// @param _amount The amount of options to be minted.\n    function _mintOptionsPosition(\n        address _to,\n        address _qToken,\n        uint256 _amount\n    ) internal returns (uint256) {\n        IQToken qToken = IQToken(_qToken);\n\n        // get the collateral required to mint the specified amount of options\n        // the zero address is passed as the second argument as it's only used\n        // for spreads\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(_qToken, address(0), _amount);\n\n        _checkIfUnexpiredQToken(_qToken);\n\n        // check if the oracle set during the option's creation through the OptionsFactory\n        // is an active oracle in the OracleRegistry\n        require(\n            IOracleRegistry(\n                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(\n                    ProtocolValue.encode(\"oracleRegistry\")\n                )\n            ).isOracleActive(qToken.oracle()),\n            \"Controller: Can't mint an options position as the oracle is inactive\"\n        );\n\n        // pull the required collateral from the caller/signer\n        IERC20(collateral).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            collateralAmount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Mint the options to the sender's address\n        qToken.mint(_to, _amount);\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qToken,\n            address(0)\n        );\n\n        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,\n        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory\n        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);\n\n        emit OptionsPositionMinted(\n            _to,\n            _msgSender(),\n            _qToken,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Creates a spread position from an option to long and another option to short.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset in cases of a debit spread.\n    /// @param _qTokenToMint The QToken for the option to be long.\n    /// @param _qTokenForCollateral The QToken for the option to be short.\n    /// @param _amount The amount of long options to be minted.\n    function _mintSpread(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    ) internal returns (uint256) {\n        require(\n            _qTokenToMint != _qTokenForCollateral,\n            \"Controller: Can only create a spread with different tokens\"\n        );\n\n        IQToken qTokenToMint = IQToken(_qTokenToMint);\n        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);\n\n        // Calculate the extra collateral required to create the spread.\n        // A positive value for debit spreads and zero for credit spreads.\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount\n            );\n\n        _checkIfUnexpiredQToken(_qTokenToMint);\n        _checkIfUnexpiredQToken(_qTokenForCollateral);\n\n        // Burn the QToken being shorted\n        qTokenForCollateral.burn(_msgSender(), _amount);\n\n        // Transfer in any collateral required for the spread\n        if (collateralAmount > 0) {\n            IERC20(collateral).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                collateralAmount\n            );\n        }\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Check if the CollateralToken representing this specific spread has already been created\n        // Create it if it hasn't\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qTokenToMint,\n            _qTokenForCollateral\n        );\n        (, address qTokenAsCollateral) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n        if (qTokenAsCollateral == address(0)) {\n            require(\n                collateralTokenId ==\n                    collateralToken.createCollateralToken(\n                        _qTokenToMint,\n                        _qTokenForCollateral\n                    ),\n                \"Controller: failed creating the collateral token to represent the spread\"\n            );\n        }\n\n        // Mint the tokens for the new spread position\n        collateralToken.mintCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            _amount\n        );\n        qTokenToMint.mint(_msgSender(), _amount);\n\n        emit SpreadMinted(\n            _msgSender(),\n            _qTokenToMint,\n            _qTokenForCollateral,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Closes a long position after the option's expiry.\n    /// @dev Pass an `_amount` of 0 to close the entire position.\n    /// @param _qToken The QToken representing the long position to be closed.\n    /// @param _amount The amount of options to exercise.\n    function _exercise(address _qToken, uint256 _amount) internal {\n        IQToken qToken = IQToken(_qToken);\n        require(\n            block.timestamp > qToken.expiryTime(),\n            \"Controller: Can not exercise options before their expiry\"\n        );\n\n        uint256 amountToExercise = _amount;\n        // if the amount is 0, the entire position will be exercised\n        if (amountToExercise == 0) {\n            amountToExercise = qToken.balanceOf(_msgSender());\n        }\n\n        // Use the QuantCalculator to check how much the sender/signer is due.\n        // Will only be a positive value for options that expired In The Money.\n        (\n            bool isSettled,\n            address payoutToken,\n            uint256 exerciseTotal\n        ) = IQuantCalculator(quantCalculator).getExercisePayout(\n                address(qToken),\n                amountToExercise\n            );\n\n        require(isSettled, \"Controller: Cannot exercise unsettled options\");\n\n        // Burn the long tokens\n        qToken.burn(_msgSender(), amountToExercise);\n\n        // Transfer any profit due after expiration\n        if (exerciseTotal > 0) {\n            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);\n        }\n\n        emit OptionsExercised(\n            _msgSender(),\n            address(qToken),\n            amountToExercise,\n            exerciseTotal,\n            payoutToken\n        );\n    }\n\n    /// @notice Closes a short position after the option's expiry.\n    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.\n    /// @param _amount The size of the position to close.\n    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        uint256 collateralTokenId = _collateralTokenId;\n\n        // Use the QuantCalculator to check how much collateral the sender/signer is due.\n        (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(\n                collateralTokenId,\n                _amount,\n                _msgSender()\n            );\n\n        // Burn the short tokens\n        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim\n        );\n\n        // Transfer any collateral due after expiration\n        if (returnableCollateral > 0) {\n            IERC20(collateralAsset).safeTransfer(\n                _msgSender(),\n                returnableCollateral\n            );\n        }\n\n        emit CollateralClaimed(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim,\n            returnableCollateral,\n            collateralAsset\n        );\n    }\n\n    /// @notice Closes a neutral position, claiming all the collateral required to create it.\n    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.\n    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.\n    /// @param _amount The size of the position to close.\n    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        /// @dev Put these values in the stack to save gas from having to read\n        /// from calldata\n        (uint256 collateralTokenId, uint256 amount) = (\n            _collateralTokenId,\n            _amount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n\n        //get the amount of CollateralTokens owned\n        uint256 collateralTokensOwned = collateralToken.balanceOf(\n            _msgSender(),\n            collateralTokenId\n        );\n\n        //get the amount of QTokens owned\n        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());\n\n        // the size of the position that can be neutralized\n        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned\n            ? qTokensOwned\n            : collateralTokensOwned;\n\n        // make sure that the amount passed is not greater than the amount that can be neutralized\n        uint256 amountToNeutralize;\n        if (amount != 0) {\n            require(\n                amount <= maxNeutralizable,\n                \"Controller: Tried to neutralize more than balance\"\n            );\n            amountToNeutralize = amount;\n        } else {\n            amountToNeutralize = maxNeutralizable;\n        }\n\n        // use the QuantCalculator to check how much collateral the sender/signer is due\n        // for closing the neutral position\n        (address collateralType, uint256 collateralOwed) = IQuantCalculator(\n            quantCalculator\n        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);\n\n        // burn the short tokens\n        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);\n\n        // burn the long tokens\n        collateralToken.burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToNeutralize\n        );\n\n        // tranfer the collateral owed\n        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);\n\n        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)\n        if (qTokenLong != address(0)) {\n            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);\n        }\n\n        emit NeutralizePosition(\n            _msgSender(),\n            qTokenShort,\n            amountToNeutralize,\n            collateralOwed,\n            collateralType,\n            qTokenLong\n        );\n    }\n\n    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.\n    /// @param _qToken The QToken to be approved.\n    /// @param _spender The address of the spender.\n    /// @param _value The amount of tokens to be approved for spending.\n    /// @param _deadline Timestamp at which the permit signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _qTokenPermit(\n        address _qToken,\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IQToken(_qToken).permit(\n            _owner,\n            _spender,\n            _value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice Allows a CollateralToken owner to either approve an operator address\n    /// to spend all of their tokens on their behalf, or to remove a prior approval.\n    /// @param _owner The address of the owner of the CollateralToken.\n    /// @param _operator The address of the operator to be approved or removed.\n    /// @param _approved Whether the operator is being approved or removed.\n    /// @param _nonce The nonce for the approval through a meta transaction.\n    /// @param _deadline Timestamp at which the approval signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _collateralTokenApproval(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _nonce,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(\n                _owner,\n                _operator,\n                _approved,\n                _nonce,\n                _deadline,\n                _v,\n                _r,\n                _s\n            );\n    }\n\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n\n    /// @notice Checks if the given QToken has not expired yet, reverting otherwise\n    /// @param _qToken The address of the QToken to check.\n    function _checkIfUnexpiredQToken(address _qToken) internal view {\n        require(\n            IQToken(_qToken).expiryTime() > block.timestamp,\n            \"Controller: Cannot mint expired options\"\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"../interfaces/IOperateProxy.sol\";\n\n/// @title Contract to be used by the Controller to make unprivileged external calls\n/// @author Rolla\ncontract OperateProxy is IOperateProxy {\n    /// @inheritdoc IOperateProxy\n    function callFunction(address callee, bytes memory data) external override {\n        require(\n            callee != address(0),\n            \"OperateProxy: cannot make function calls to the zero address\"\n        );\n\n        (bool success, bytes memory returnData) = address(callee).call(data);\n        require(success, \"OperateProxy: low-level call failed\");\n        emit FunctionCallExecuted(tx.origin, returnData);\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol",
            "OperateProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Controller.sol#L550-L558, OperateProxy.sol#L10-L19",
                "Type": "OperateProxy.callFunction() should check if the callee is a contract",
                "Description": "The OperateProxy.callFunction() function does not check if the callee is a contract, which can cause non-contract addresses to be called and considered successful, potentially causing malfunction or fund loss.",
                "Repair": "Add a check and throw when the callee is not a contract"
            }
        ]
    }
]