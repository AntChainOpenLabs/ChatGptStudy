[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n  function balanceOf(address to) external view returns (uint256);\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 constant BASE = 10**18;\n\n  event Buy(uint256 count, uint256 ethSpent, address to);\n  event Sell(uint256 count, uint256 ethReceived, address to);\n  event Swap(uint256 count, uint256 ethSpent, address to);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function mintAndSell721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function mintAndSell721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function buyAndSwap721(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndSwap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap1155WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndRedeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndRedeemWETH(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function mintAndSell1155(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function mintAndSell1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function _mint721(\n    uint256 vaultId, \n    uint256[] memory ids\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); \n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _swap721(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < idsIn.length; i++) {\n      transferFromERC721(assetAddress, idsIn[i], vault);\n      approveERC721(assetAddress, vault, idsIn[i]);\n    }\n    uint256[] memory emptyIds;\n    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _swap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory amounts,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _redeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds,\n    address to\n  ) internal {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n    INFTXVault(vault).redeemTo(amount, specificIds, to);\n  }\n\n  function _mint1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _buyVaultToken(\n    address vault, \n    uint256 minTokenOut, \n    uint256 maxWethIn, \n    address[] calldata path\n  ) internal returns (uint256[] memory) {\n    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n      minTokenOut,\n      maxWethIn,\n      path, \n      address(this),\n      block.timestamp\n    );\n\n    return amounts;\n  }\n  function _sellVaultTokenWETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function _sellVaultTokenETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXSimpleFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXInventoryStaking public immutable inventoryStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 public lpLockTime = 48 hours; \n  uint256 public inventoryLockTime = 7 days; \n  uint256 constant BASE = 10**18;\n\n  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {\n    require(newLPLockTime <= 7 days, \"Lock too long\");\n    lpLockTime = newLPLockTime;\n  } \n\n  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {\n    require(newInventoryLockTime <= 14 days, \"Lock too long\");\n    inventoryLockTime = newInventoryLockTime;\n  }\n\n  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {\n    uint256 count = tokenIds.length;\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    uint256[] memory amounts = new uint256[](0);\n    address assetAddress = vault.assetAddress();\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      transferFromERC721(assetAddress, tokenIds[i], address(vault));\n      approveERC721(assetAddress, address(vault), tokenIds[i]);\n    }\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {\n    uint256 count;\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      count += amounts[i];\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());\n    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, \"\");\n    nft.setApprovalForAll(address(vault), true);\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function addLiquidity721ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn\n  ) public payable returns (uint256) {\n    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);\n  }\n\n  function addLiquidity721ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn\n  ) public payable returns (uint256) {\n    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);\n  }\n\n  function addLiquidity1155ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    // Finish this.\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity721To(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity1155To(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function _addLiquidity721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidity1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidityAndLock(\n    uint256 vaultId, \n    address vault, \n    uint256 minTokenIn, \n    uint256 minWethIn, \n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    // Provide liquidity.\n    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);\n    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(\n      address(vault), \n      sushiRouter.WETH(),\n      minTokenIn, \n      wethIn, \n      minTokenIn,\n      minWethIn,\n      address(this), \n      block.timestamp\n    );\n\n    // Stake in LP rewards contract \n    address lpToken = pairFor(vault, address(WETH));\n    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);\n    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);\n    \n    if (amountToken < minTokenIn) {\n      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);\n    }\n\n    uint256 lockEndTime = block.timestamp + lpLockTime;\n    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);\n    return (amountToken, amountEth, liquidity);\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n\n  function rescue(address token) external onlyOwner {\n    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTXMarketplaceZap.sol",
            "NFTXStakingZap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXMarketplaceZap.sol and NFTXStakingZap.sol",
                "Type": "Vault locking",
                "Description": "A malicious user could transfer any amount of a vault's vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace.",
                "Repair": "Remove the locking logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Multiple functions in various contracts",
                "Type": "Missing non-reentrancy modifier",
                "Description": "Reentrancy represents a real and significant risk and should be protected against regardless of if you can foresee the external event that causes lack of protection to be an issue.",
                "Repair": "Add nonReentrant modifier to the functions"
            },
            {
                "Location": "Multiple functions in various contracts",
                "Type": "Ignoring transfer return value",
                "Description": "The transfer return value has to be checked as there are popular tokens, such as USDT that transfer/transferFrom method doesn\u2019t return anything.",
                "Repair": "Use safeTransfer instead of transfer or add a whitelist. Check the transfer return value."
            },
            {
                "Location": "buyAndSwap1155WETH() function may cause loss of user assets",
                "Type": "High Severity",
                "Description": "buyAndSwap1155WETH() function may cause loss of user assets due to incorrect use of msg.value instead of maxWethIn.",
                "Repair": "Change the _buyVaultToken function to use maxWethIn instead of msg.value"
            },
            {
                "Location": "xToken Approvals Allow Spenders To Spend More Tokens",
                "Type": "Medium Severity",
                "Description": "xToken Approvals Allow Spenders To Spend More Tokens due to the approve function using xToken shares instead of the equivalent rebalanced amount.",
                "Repair": "Override the approve and transferFrom functions to track rebalanced amounts instead of shares"
            },
            {
                "Location": "Low-level call return value not checked",
                "Type": "Medium Severity",
                "Description": "Low-level call return value not checked in the NFTXStakingZap.addLiquidity721ETHTo function.",
                "Repair": "Check the return value of the payable(to).call(...) function to revert the entire transaction if the refund call fails"
            },
            {
                "Location": "buyAndSwap1155WETH Does Not Work As Intended",
                "Type": "Medium Severity",
                "Description": "buyAndSwap1155WETH Does Not Work As Intended due to the _buyVaultToken function using msg.value instead of maxWethIn.",
                "Repair": "Update the _buyVaultToken function to use maxWethIn instead of msg.value"
            },
            {
                "Location": "NFTXSimpleFeeDistributor#addReceiver function",
                "Type": "Failure to check for existing receiver",
                "Description": "The same receiver can be added multiple times, resulting in erroneous fee distributions.",
                "Repair": "Add a check to ensure that the receiver does not already exist before adding it"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXSimpleFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/SafeMathUpgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/ReentrancyGuardUpgradeable.sol\";\n\ncontract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  bool public distributionPaused;\n\n  address public override nftxVaultFactory;\n  address public override lpStaking;\n  address public override treasury;\n\n  // Total allocation points per vault. \n  uint256 public override allocTotal;\n  FeeReceiver[] public feeReceivers;\n\n  address public override inventoryStaking;\n\n  event UpdateTreasuryAddress(address newTreasury);\n  event UpdateLPStakingAddress(address newLPStaking);\n  event UpdateInventoryStakingAddress(address newInventoryStaking);\n  event UpdateNFTXVaultFactory(address factory);\n  event PauseDistribution(bool paused); \n\n  event AddFeeReceiver(address receiver, uint256 allocPoint);\n  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);\n  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);\n  event RemoveFeeReceiver(address receiver);\n  \n  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {\n    __Pausable_init();\n    setTreasuryAddress(_treasury);\n    setLPStakingAddress(_lpStaking);\n\n    _addReceiver(0.8 ether, lpStaking, true);\n  }\n\n  function distribute(uint256 vaultId) external override virtual nonReentrant {\n    require(nftxVaultFactory != address(0));\n    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n    if (distributionPaused || allocTotal == 0) {\n      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n      return;\n    } \n\n    uint256 length = feeReceivers.length;\n    uint256 leftover;\n    for (uint256 i = 0; i < length; i++) {\n      FeeReceiver memory _feeReceiver = feeReceivers[i];\n      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;\n      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n      if (!complete) {\n        leftover = amountToSend;\n      } else {\n        leftover = 0;\n      }\n    }\n\n    if (leftover > 0) {\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);\n    }\n  }\n\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {\n    _addReceiver(_allocPoint, _receiver, _isContract);\n  }\n\n  function initializeVaultReceivers(uint256 _vaultId) external override {\n    require(msg.sender == nftxVaultFactory, \"FeeReceiver: not factory\");\n    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);\n    if (inventoryStaking != address(0))\n      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);\n  }\n\n  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    allocTotal -= feeReceiver.allocPoint;\n    feeReceiver.allocPoint = _allocPoint;\n    allocTotal += _allocPoint;\n    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);\n  }\n\n  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    address oldReceiver = feeReceiver.receiver;\n    feeReceiver.receiver = _address;\n    feeReceiver.isContract = _isContract;\n    emit UpdateFeeReceiverAddress(oldReceiver, _address);\n  }\n\n  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {\n    uint256 arrLength = feeReceivers.length;\n    require(_receiverIdx < arrLength, \"FeeDistributor: Out of bounds\");\n    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);\n    allocTotal -= feeReceivers[_receiverIdx].allocPoint;\n    // Copy the last element to what is being removed and remove the last element.\n    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];\n    feeReceivers.pop();\n  }\n\n  function setTreasuryAddress(address _treasury) public override onlyOwner {\n    require(_treasury != address(0), \"Treasury != address(0)\");\n    treasury = _treasury;\n    emit UpdateTreasuryAddress(_treasury);\n  }\n\n  function setLPStakingAddress(address _lpStaking) public override onlyOwner {\n    require(_lpStaking != address(0), \"LPStaking != address(0)\");\n    lpStaking = _lpStaking;\n    emit UpdateLPStakingAddress(_lpStaking);\n  }\n\n  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {\n    inventoryStaking = _inventoryStaking;\n    emit UpdateInventoryStakingAddress(_inventoryStaking);\n  }\n\n  function setNFTXVaultFactory(address _factory) external override onlyOwner {\n    nftxVaultFactory = _factory;\n    emit UpdateNFTXVaultFactory(_factory);\n  }\n\n  function pauseFeeDistribution(bool pause) external onlyOwner {\n    distributionPaused = pause;\n    emit PauseDistribution(pause);\n  }\n\n  function rescueTokens(address _address) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\n    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);\n  }\n\n  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\n    feeReceivers.push(_feeReceiver);\n    allocTotal += _allocPoint;\n    emit AddFeeReceiver(_receiver, _allocPoint);\n  }\n\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n      // If the receive is not properly processed, send it to the treasury instead.\n       \n      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, ) = address(_receiver.receiver).call(payload);\n\n      // If the allowance has not been spent, it means we can pass it forward to next.\n      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n    } else {\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    }\n  }\n} \n\n",
        "CodeNames": [
            "NFTXSimpleFeeDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXSimpleFeeDistributor.sol",
                "Type": "Denial of Service",
                "Description": "If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.",
                "Repair": "The DAO can remove the malicious receiver. Alternatively, the contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function."
            },
            {
                "Location": "NFTXSimpleFeeDistributor contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "Dishonest Stakers Can Siphon Rewards From  xToken  Holders Through The  deposit  Function In  NFTXInventoryStaking.",
                "Repair": "Ensure the distribute function in NFTXSimpleFeeDistributor is restricted to a given role, ensuring malicious users cannot control at what point rewards are distributed."
            },
            {
                "Location": "_sendForReceiver function in NFTXSimpleFeeDistributor contract",
                "Type": "Return variable can remain unassigned",
                "Description": "If the else block is true, no value is returned, resulting in the distribute function sending more fees than expected.",
                "Repair": "Add a return value to the else block of the _sendForReceiver function"
            },
            {
                "Location": "_sendForReceiver function in NFTXSimpleFeeDistributor contract",
                "Type": "Failure to set return value",
                "Description": "When _receiver is not a contract, no value is returned, causing the distribute function to send more fees than expected.",
                "Repair": "Add a return value to the else block of the _sendForReceiver function"
            },
            {
                "Location": "NFTXSimpleFeeDistributor._sendForReceiver function",
                "Type": "Double spending",
                "Description": "Double spending of fees being distributed will happen in favor of the first fee receivers in the feeReceivers list at the expense of the last ones. _sendForReceiver doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list.",
                "Repair": "Add a return statement to indicate successful transfer when receiver is not a contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/IERC20Metadata.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/Address.sol\";\nimport \"./util/Create2.sol\";\nimport \"./proxy/Initializable.sol\";\nimport \"./proxy/UpgradeableBeacon.sol\";\nimport \"./proxy/Create2BeaconProxy.sol\";\nimport \"./token/XTokenUpgradeable.sol\";\n\n// Author: 0xKiwi.\n\n// Pausing codes for inventory staking are:\n// 10: Deposit\n\ncontract NFTXInventoryStaking is PausableUpgradeable, UpgradeableBeacon, INFTXInventoryStaking {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant BASE = 10**18;\n    // Small locktime to prevent flash deposits.\n    uint256 public constant DEFAULT_LOCKTIME = 2;\n\n    INFTXVaultFactory public override nftxVaultFactory;\n    mapping(uint256 => address) internal UNUSED;\n\n    event XTokenCreated(uint256 vaultId, address baseToken, address xToken);\n    event Deposit(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, uint256 timelockUntil, address sender);\n    event Withdraw(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, address sender);\n\n    function __NFTXInventoryStaking_init(address _nftxVaultFactory) external virtual override initializer {\n        __Ownable_init();\n        nftxVaultFactory = INFTXVaultFactory(_nftxVaultFactory);\n        address xTokenImpl = address(new XTokenUpgradeable());\n        __UpgradeableBeacon__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == nftxVaultFactory.feeDistributor(), \"LPStaking: Not authorized\");\n        _;\n    }\n    \n    function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit XTokenCreated(vaultId, baseToken, xToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n        \n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!isContract(deployedXToken) || XTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        return true;\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) public virtual override {\n        onlyOwnerIfPaused(10);\n\n        (IERC20Upgradeable baseToken, XTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, DEFAULT_LOCKTIME);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit Deposit(vaultId, _amount, xTokensMinted, DEFAULT_LOCKTIME, msg.sender);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        require(nftxVaultFactory.excludedFromFees(msg.sender), \"Not a zap\");\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit Deposit(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) public virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit Withdraw(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n        require(address(xToken) != address(0), \"XToken not deployed\");\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0 \n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply() \n            : multiplier;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n    \n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        require(isContract(xToken), \"XToken not deployed\");\n        return xToken;\n    } \n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, XTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n\n    function _deployXToken(address vaultToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(vaultToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(vaultToken));\n        address deployedXToken = Create2.deploy(0, salt, type(Create2BeaconProxy).creationCode);\n        XTokenUpgradeable(deployedXToken).__XToken_init(vaultToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n",
        "CodeNames": [
            "NFTXInventoryStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXInventoryStaking contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "The NFTXInventoryStaking contract distributes new rewards to all previous stakers when the owner calls the receiveRewards function. This allows an attacker to frontrun this receiveRewards transaction when they see it in the mem pool with a deposit function.",
                "Repair": "Distribute the rewards equally over time to the stakers instead of in a single chunk on each receiveRewards call."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./proxy/ClonesUpgradeable.sol\";\nimport \"./proxy/BeaconProxy.sol\";\nimport \"./proxy/UpgradeableBeacon.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./NFTXVaultUpgradeable.sol\";\n\n// Authors: @0xKiwi_ and @alexgausman.\n\ncontract NFTXVaultFactoryUpgradeable is\n    PausableUpgradeable,\n    UpgradeableBeacon,\n    INFTXVaultFactory\n{\n    uint256 private NOT_USED1; // Removed, no longer needed.\n    address public override zapContract;\n    address public override feeDistributor;\n    address public override eligibilityManager;\n\n    mapping(uint256 => address) private NOT_USED2; // Removed, no longer needed.\n    mapping(address => address[]) _vaultsForAsset;\n    \n    address[] internal vaults;\n\n    // v1.0.1\n    mapping(address => bool) public override excludedFromFees;\n\n    // v1.0.2\n    struct VaultFees {\n        bool active;\n        uint64 mintFee;\n        uint64 randomRedeemFee;\n        uint64 targetRedeemFee;\n        uint64 randomSwapFee;\n        uint64 targetSwapFee;\n    }\n    mapping(uint256 => VaultFees) private _vaultFees;\n    uint64 public override factoryMintFee;\n    uint64 public override factoryRandomRedeemFee;\n    uint64 public override factoryTargetRedeemFee;\n    uint64 public override factoryRandomSwapFee;\n    uint64 public override factoryTargetSwapFee;\n\n    function __NFTXVaultFactory_init(address _vaultImpl, address _feeDistributor) public override initializer {\n        __Pausable_init();\n        // We use a beacon proxy so that every child contract follows the same implementation code.\n        __UpgradeableBeacon__init(_vaultImpl);\n        setFeeDistributor(_feeDistributor);\n        setFactoryFees(0.1 ether, 0.05 ether, 0.1 ether, 0.05 ether, 0.1 ether);\n    }\n\n    function assignFees() public {\n        require(factoryMintFee == 0 && factoryTargetRedeemFee == 0, \"Assigned\");\n        factoryMintFee = uint64(0.1 ether);\n        factoryRandomRedeemFee = uint64(0.05 ether);\n        factoryTargetRedeemFee = uint64(0.1 ether);\n        factoryRandomSwapFee = uint64(0.05 ether);\n        factoryTargetSwapFee = uint64(0.1 ether);\n\n        emit UpdateFactoryFees(0.1 ether, 0.05 ether, 0.1 ether, 0.05 ether, 0.1 ether);\n    }\n\n    function createVault(\n        string memory name,\n        string memory symbol,\n        address _assetAddress,\n        bool is1155,\n        bool allowAllItems\n    ) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(0);\n        require(feeDistributor != address(0), \"NFTX: Fee receiver unset\");\n        require(childImplementation() != address(0), \"NFTX: Vault implementation unset\");\n        address vaultAddr = deployVault(name, symbol, _assetAddress, is1155, allowAllItems);\n        uint256 _vaultId = vaults.length;\n        _vaultsForAsset[_assetAddress].push(vaultAddr);\n        vaults.push(vaultAddr);\n        INFTXFeeDistributor(feeDistributor).initializeVaultReceivers(_vaultId);\n        emit NewVault(_vaultId, vaultAddr, _assetAddress);\n        return _vaultId;\n    }\n\n    function setFactoryFees(\n        uint256 mintFee, \n        uint256 randomRedeemFee, \n        uint256 targetRedeemFee,\n        uint256 randomSwapFee, \n        uint256 targetSwapFee\n    ) public onlyOwner virtual override {\n        require(mintFee <= 1 ether, \"Cannot > 1 ether\");\n        require(randomRedeemFee <= 1 ether, \"Cannot > 1 ether\");\n        require(targetRedeemFee <= 1 ether, \"Cannot > 1 ether\");\n        require(randomSwapFee <= 1 ether, \"Cannot > 1 ether\");\n        require(targetSwapFee <= 1 ether, \"Cannot > 1 ether\");\n\n        factoryMintFee = uint64(mintFee);\n        factoryRandomRedeemFee = uint64(randomRedeemFee);\n        factoryTargetRedeemFee = uint64(targetRedeemFee);\n        factoryRandomSwapFee = uint64(randomSwapFee);\n        factoryTargetSwapFee = uint64(targetSwapFee);\n\n        emit UpdateFactoryFees(mintFee, randomRedeemFee, targetRedeemFee, randomSwapFee, targetSwapFee);\n    }\n\n    function setVaultFees(\n        uint256 vaultId, \n        uint256 mintFee, \n        uint256 randomRedeemFee, \n        uint256 targetRedeemFee,\n        uint256 randomSwapFee, \n        uint256 targetSwapFee\n    ) public virtual override {\n        if (msg.sender != owner()) {\n            address vaultAddr = vaults[vaultId];\n            require(msg.sender == vaultAddr, \"Not from vault\");\n        }\n        require(mintFee <= 1 ether, \"Cannot > 1 ether\");\n        require(randomRedeemFee <= 1 ether, \"Cannot > 1 ether\");\n        require(targetRedeemFee <= 1 ether, \"Cannot > 1 ether\");\n        require(randomSwapFee <= 1 ether, \"Cannot > 1 ether\");\n        require(targetSwapFee <= 1 ether, \"Cannot > 1 ether\");\n\n        _vaultFees[vaultId] = VaultFees(\n            true, \n            uint64(mintFee),\n            uint64(randomRedeemFee),\n            uint64(targetRedeemFee),\n            uint64(randomSwapFee), \n            uint64(targetSwapFee)\n        );\n        emit UpdateVaultFees(vaultId, mintFee, randomRedeemFee, targetRedeemFee, randomSwapFee, targetSwapFee);\n    }\n\n    function disableVaultFees(uint256 vaultId) public virtual override {\n        if (msg.sender != owner()) {\n            address vaultAddr = vaults[vaultId];\n            require(msg.sender == vaultAddr, \"Not vault\");\n        }\n        delete _vaultFees[vaultId];\n        emit DisableVaultFees(vaultId);\n    }\n\n    function setFeeDistributor(address _feeDistributor) public onlyOwner virtual override {\n        require(_feeDistributor != address(0));\n        emit NewFeeDistributor(feeDistributor, _feeDistributor);\n        feeDistributor = _feeDistributor;\n    }\n\n    function setZapContract(address _zapContract) public onlyOwner virtual override {\n        emit NewZapContract(zapContract, _zapContract);\n        zapContract = _zapContract;\n    }\n\n    function setFeeExclusion(address _excludedAddr, bool excluded) public onlyOwner virtual override {\n        emit FeeExclusion(_excludedAddr, excluded);\n        excludedFromFees[_excludedAddr] = excluded;\n    }\n\n    function setEligibilityManager(address _eligibilityManager) external onlyOwner virtual override {\n        emit NewEligibilityManager(eligibilityManager, _eligibilityManager);\n        eligibilityManager = _eligibilityManager;\n    }\n\n    function vaultFees(uint256 vaultId) external view virtual override returns (uint256, uint256, uint256, uint256, uint256) {\n        VaultFees memory fees = _vaultFees[vaultId];\n        if (fees.active) {\n            return (\n                uint256(fees.mintFee), \n                uint256(fees.randomRedeemFee), \n                uint256(fees.targetRedeemFee), \n                uint256(fees.randomSwapFee), \n                uint256(fees.targetSwapFee)\n            );\n        }\n        \n        return (uint256(factoryMintFee), uint256(factoryRandomRedeemFee), uint256(factoryTargetRedeemFee), uint256(factoryRandomSwapFee), uint256(factoryTargetSwapFee));\n    }\n\n    function isLocked(uint256 lockId) external view override virtual returns (bool) {\n        return isPaused[lockId];\n    }\n\n    function vaultsForAsset(address assetAddress) external view override virtual returns (address[] memory) {\n        return _vaultsForAsset[assetAddress];\n    }\n\n    function vault(uint256 vaultId) external view override virtual returns (address) {\n        return vaults[vaultId];\n    }\n\n    function allVaults() external view override virtual returns (address[] memory) {\n        return vaults;\n    }\n\n    function numVaults() external view override virtual returns (uint256) {\n        return vaults.length;\n    }\n    \n    function deployVault(\n        string memory name,\n        string memory symbol,\n        address _assetAddress,\n        bool is1155,\n        bool allowAllItems\n    ) internal returns (address) {\n        address newBeaconProxy = address(new BeaconProxy(address(this), \"\"));\n        NFTXVaultUpgradeable(newBeaconProxy).__NFTXVault_init(name, symbol, _assetAddress, is1155, allowAllItems);\n        // Manager for configuration.\n        NFTXVaultUpgradeable(newBeaconProxy).setManager(msg.sender);\n        // Owner for administrative functions.\n        NFTXVaultUpgradeable(newBeaconProxy).transferOwnership(owner());\n        return newBeaconProxy;\n    }\n}\n\n\n",
        "CodeNames": [
            "NFTXVaultFactoryUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXVaultFactoryUpgradeable contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "NFTXVaultFactoryUpgradeable implementation can be replaced in production breaking the system.",
                "Repair": "Either restrict the ability to change the factory implementation to pre-production stages or make nftxVaultFactory immutable by allowing changing it only once."
            },
            {
                "Location": "NFTXVaultFactoryUpgradeable contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "NFTXVaultFactoryUpgradeable implementation can be replaced in production breaking the system.",
                "Repair": "If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts."
            },
            {
                "Location": "No access control on assignFees() function in NFTXVaultFactoryUpgradeable contract",
                "Type": "Medium Severity",
                "Description": "No access control on assignFees() function in NFTXVaultFactoryUpgradeable contract.",
                "Repair": "Remove the assignFees() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXEligibility.sol\";\nimport \"./interface/INFTXEligibilityManager.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/IERC165Upgradeable.sol\";\nimport \"./token/ERC20FlashMintUpgradeable.sol\";\nimport \"./token/ERC721SafeHolderUpgradeable.sol\";\nimport \"./token/ERC1155SafeHolderUpgradeable.sol\";\nimport \"./token/IERC721Upgradeable.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\nimport \"./util/ReentrancyGuardUpgradeable.sol\";\nimport \"./util/EnumerableSetUpgradeable.sol\";\n\n// Authors: @0xKiwi_ and @alexgausman.\n\ncontract NFTXVaultUpgradeable is\n    OwnableUpgradeable,\n    ERC20FlashMintUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721SafeHolderUpgradeable,\n    ERC1155SafeHolderUpgradeable,\n    INFTXVault\n{\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    uint256 constant base = 10**18;\n\n    uint256 public override vaultId;\n    address public override manager;\n    address public override assetAddress;\n    INFTXVaultFactory public override vaultFactory;\n    INFTXEligibility public override eligibilityStorage;\n\n    uint256 randNonce;\n    uint256 private UNUSED_FEE1;\n    uint256 private UNUSED_FEE2;\n    uint256 private UNUSED_FEE3;\n\n    bool public override is1155;\n    bool public override allowAllItems;\n    bool public override enableMint;\n    bool public override enableRandomRedeem;\n    bool public override enableTargetRedeem;\n\n    EnumerableSetUpgradeable.UintSet holdings;\n    mapping(uint256 => uint256) quantity1155;\n\n    bool public override enableRandomSwap;\n    bool public override enableTargetSwap;\n\n    function __NFTXVault_init(\n        string memory _name,\n        string memory _symbol,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) public override virtual initializer {\n        __Ownable_init();\n        __ERC20_init(_name, _symbol);\n        require(_assetAddress != address(0), \"Asset != address(0)\");\n        assetAddress = _assetAddress;\n        vaultFactory = INFTXVaultFactory(msg.sender);\n        vaultId = vaultFactory.numVaults();\n        is1155 = _is1155;\n        allowAllItems = _allowAllItems;\n        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);\n        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);\n    }\n\n    function finalizeVault() external override virtual {\n        setManager(address(0));\n    }\n\n    // Added in v1.0.3.\n    function setVaultMetadata(\n        string memory name_, \n        string memory symbol_\n    ) public override virtual {\n        onlyPrivileged();\n        _setMetadata(name_, symbol_);\n    }\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRandomRedeem,\n        bool _enableTargetRedeem,\n        bool _enableRandomSwap,\n        bool _enableTargetSwap\n    ) public override virtual {\n        onlyPrivileged();\n        enableMint = _enableMint;\n        enableRandomRedeem = _enableRandomRedeem;\n        enableTargetRedeem = _enableTargetRedeem;\n        enableRandomSwap = _enableRandomSwap;\n        enableTargetSwap = _enableTargetSwap;\n\n        emit EnableMintUpdated(_enableMint);\n        emit EnableRandomRedeemUpdated(_enableRandomRedeem);\n        emit EnableTargetRedeemUpdated(_enableTargetRedeem);\n        emit EnableRandomSwapUpdated(_enableRandomSwap);\n        emit EnableTargetSwapUpdated(_enableTargetSwap);\n    }\n\n    function assignDefaultFeatures() external {\n        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, \"Not dev\");\n        enableRandomSwap = enableRandomRedeem;\n        enableTargetSwap = enableTargetRedeem;\n        emit EnableRandomSwapUpdated(enableRandomSwap);\n        emit EnableTargetSwapUpdated(enableTargetSwap);\n    }\n\n    function setFees(\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) public override virtual {\n        onlyPrivileged();\n        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);\n    }\n\n    function disableVaultFees() public override virtual {\n        onlyPrivileged();\n        vaultFactory.disableVaultFees(vaultId);\n    }\n\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow \n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external override virtual returns (address) {\n        onlyPrivileged();\n        require(\n            address(eligibilityStorage) == address(0),\n            \"NFTXVault: eligibility already set\"\n        );\n        INFTXEligibilityManager eligManager = INFTXEligibilityManager(\n            vaultFactory.eligibilityManager()\n        );\n        address _eligibility = eligManager.deployEligibility(\n            moduleIndex,\n            initData\n        );\n        eligibilityStorage = INFTXEligibility(_eligibility);\n        // Toggle this to let the contract know to check eligibility now.\n        allowAllItems = false;\n        emit EligibilityDeployed(moduleIndex, _eligibility);\n        return _eligibility;\n    }\n\n    // // This function allows for the manager to set their own arbitrary eligibility contract.\n    // // Once eligiblity is set, it cannot be unset or changed.\n    // Disabled for launch.\n    // function setEligibilityStorage(address _newEligibility) public virtual {\n    //     onlyPrivileged();\n    //     require(\n    //         address(eligibilityStorage) == address(0),\n    //         \"NFTXVault: eligibility already set\"\n    //     );\n    //     eligibilityStorage = INFTXEligibility(_newEligibility);\n    //     // Toggle this to let the contract know to check eligibility now.\n    //     allowAllItems = false;\n    //     emit CustomEligibilityDeployed(address(_newEligibility));\n    // }\n\n    // The manager has control over options like fees and features\n    function setManager(address _manager) public override virtual {\n        onlyPrivileged();\n        manager = _manager;\n        emit ManagerSet(_manager);\n    }\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external override virtual returns (uint256) {\n        return mintTo(tokenIds, amounts, msg.sender);\n    }\n\n    function mintTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        address to\n    ) public override virtual nonReentrant returns (uint256) {\n        onlyOwnerIfPaused(1);\n        require(enableMint, \"Minting not enabled\");\n        // Take the NFTs.\n        uint256 count = receiveNFTs(tokenIds, amounts);\n\n        // Mint to the user.\n        _mint(to, base * count);\n        uint256 totalFee = mintFee() * count;\n        _chargeAndDistributeFees(to, totalFee);\n\n        emit Minted(tokenIds, amounts, to);\n        return count;\n    }\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        override\n        virtual\n        returns (uint256[] memory)\n    {\n        return redeemTo(amount, specificIds, msg.sender);\n    }\n\n    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n        public\n        override\n        virtual\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        onlyOwnerIfPaused(2);\n        require(\n            amount == specificIds.length || enableRandomRedeem,\n            \"NFTXVault: Random redeem not enabled\"\n        );\n        require(\n            specificIds.length == 0 || enableTargetRedeem,\n            \"NFTXVault: Target redeem not enabled\"\n        );\n        \n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burn(msg.sender, base * amount);\n\n        // Pay the tokens + toll.\n        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (\n            randomRedeemFee() * (amount - specificIds.length)\n        );\n        _chargeAndDistributeFees(msg.sender, totalFee);\n\n        // Withdraw from vault.\n        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);\n        emit Redeemed(redeemedIds, specificIds, to);\n        return redeemedIds;\n    }\n    \n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external override virtual returns (uint256[] memory) {\n        return swapTo(tokenIds, amounts, specificIds, msg.sender);\n    }\n\n    function swapTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        uint256[] memory specificIds,\n        address to\n    ) public override virtual nonReentrant returns (uint256[] memory) {\n        onlyOwnerIfPaused(3);\n        uint256 count;\n        if (is1155) {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 amount = amounts[i];\n                require(amount > 0, \"NFTXVault: transferring < 1\");\n                count += amount;\n            }\n        } else {\n            count = tokenIds.length;\n        }\n\n        require(\n            count == specificIds.length || enableRandomSwap,\n            \"NFTXVault: Random swap disabled\"\n        );\n        require(\n            specificIds.length == 0 || enableTargetSwap,\n            \"NFTXVault: Target swap disabled\"\n        );\n\n        uint256 totalFee = (targetSwapFee() * specificIds.length) + (\n            randomSwapFee() * (count - specificIds.length)\n        );\n        _chargeAndDistributeFees(msg.sender, totalFee);\n        \n        // Give the NFTs first, so the user wont get the same thing back, just to be nice. \n        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);\n\n        receiveNFTs(tokenIds, amounts);\n\n        emit Swapped(tokenIds, amounts, specificIds, ids, to);\n        return ids;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes memory data\n    ) public override virtual returns (bool) {\n        onlyOwnerIfPaused(4);\n        return super.flashLoan(receiver, token, amount, data);\n    }\n\n    function mintFee() public view override virtual returns (uint256) {\n        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);\n        return _mintFee;\n    }\n\n    function randomRedeemFee() public view override virtual returns (uint256) {\n        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);\n        return _randomRedeemFee;\n    }\n\n    function targetRedeemFee() public view override virtual returns (uint256) {\n        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);\n        return _targetRedeemFee;\n    }\n\n    function randomSwapFee() public view override virtual returns (uint256) {\n        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);\n        return _randomSwapFee;\n    }\n\n    function targetSwapFee() public view override virtual returns (uint256) {\n        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);\n        return _targetSwapFee;\n    }\n\n    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {\n        return vaultFactory.vaultFees(vaultId);\n    }\n\n    function allValidNFTs(uint256[] memory tokenIds)\n        public\n        view\n        override\n        virtual\n        returns (bool)\n    {\n        if (allowAllItems) {\n            return true;\n        }\n\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return false;\n        }\n        return _eligibilityStorage.checkAllEligible(tokenIds);\n    }\n\n    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {\n        return holdings.at(holdingsIndex);\n    }\n\n    // Added in v1.0.3.\n    function allHoldings() external view override virtual returns (uint256[] memory) {\n        uint256 len = holdings.length();\n        uint256[] memory idArray = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            idArray[i] = holdings.at(i);\n        }\n        return idArray;\n    }\n\n    // Added in v1.0.3.\n    function totalHoldings() external view override virtual returns (uint256) {\n        return holdings.length();\n    }\n\n    // Added in v1.0.3.\n    function version() external pure returns (string memory) {\n        return \"v1.0.5\";\n    } \n\n    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.\n    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return;\n        }\n        _eligibilityStorage.afterRedeemHook(tokenIds);\n    }\n\n    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)\n        internal\n        virtual\n        returns (uint256)\n    {\n        require(allValidNFTs(tokenIds), \"NFTXVault: not eligible\");\n        if (is1155) {\n            // This is technically a check, so placing it before the effect.\n            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds,\n                amounts,\n                \"\"\n            );\n\n            uint256 count;\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                uint256 amount = amounts[i];\n                require(amount > 0, \"NFTXVault: transferring < 1\");\n                if (quantity1155[tokenId] == 0) {\n                    holdings.add(tokenId);\n                }\n                quantity1155[tokenId] += amount;\n                count += amount;\n            }\n            return count;\n        } else {\n            address _assetAddress = assetAddress;\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                // We may already own the NFT here so we check in order:\n                // Does the vault own it?\n                //   - If so, check if its in holdings list\n                //      - If so, we reject. This means the NFT has already been claimed for.\n                //      - If not, it means we have not yet accounted for this NFT, so we continue.\n                //   -If not, we \"pull\" it from the msg.sender and add to holdings.\n                transferFromERC721(_assetAddress, tokenId);\n                holdings.add(tokenId);\n            }\n            return tokenIds.length;\n        }\n    }\n\n    function withdrawNFTsTo(\n        uint256 amount,\n        uint256[] memory specificIds,\n        address to\n    ) internal virtual returns (uint256[] memory) {\n        bool _is1155 = is1155;\n        address _assetAddress = assetAddress;\n        uint256[] memory redeemedIds = new uint256[](amount);\n        for (uint256 i = 0; i < amount; i++) {\n            // This will always be fine considering the validations made above. \n            uint256 tokenId = i < specificIds.length ? \n                specificIds[i] : getRandomTokenIdFromVault();\n            redeemedIds[i] = tokenId;\n\n            if (_is1155) {\n                quantity1155[tokenId] -= 1;\n                if (quantity1155[tokenId] == 0) {\n                    holdings.remove(tokenId);\n                }\n\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    to,\n                    tokenId,\n                    1,\n                    \"\"\n                );\n            } else {\n                holdings.remove(tokenId);\n                transferERC721(_assetAddress, to, tokenId);\n            }\n        }\n        afterRedeemHook(redeemedIds);\n        return redeemedIds;\n    }\n\n    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {\n        // Do not charge fees if the zap contract is calling\n        // Added in v1.0.3. Changed to mapping in v1.0.5.\n        if (vaultFactory.excludedFromFees(msg.sender)) {\n            return;\n        }\n        \n        // Mint fees directly to the distributor and distribute.\n        if (amount > 0) {\n            address feeDistributor = vaultFactory.feeDistributor();\n            // Changed to a _transfer() in v1.0.3.\n            _transfer(user, feeDistributor, amount);\n            INFTXFeeDistributor(feeDistributor).distribute(vaultId);\n        }\n    }\n\n    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n        bytes memory data;\n        if (assetAddr == kitties) {\n            // Changed in v1.0.4.\n            data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, tokenId);\n        } else if (assetAddr == punks) {\n            // CryptoPunks.\n            data = abi.encodeWithSignature(\"transferPunk(address,uint256)\", to, tokenId);\n        } else {\n            // Default.\n            data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", address(this), to, tokenId);\n        }\n        (bool success,) = address(assetAddr).call(data);\n        require(success);\n    }\n\n    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {\n        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n        bytes memory data;\n        if (assetAddr == kitties) {\n            // Cryptokitties.\n            data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n        } else if (assetAddr == punks) {\n            // CryptoPunks.\n            // Fix here for frontrun attack. Added in v1.0.2.\n            bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n            (address owner) = abi.decode(result, (address));\n            require(checkSuccess && owner == msg.sender, \"Not the owner\");\n            data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n        } else {\n            // Default.\n            // Allow other contracts to \"push\" into the vault, safely.\n            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.\n            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {\n                require(!holdings.contains(tokenId), \"Trying to use an owned NFT\");\n                return;\n            } else {\n                data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n            }\n        }\n        (bool success, bytes memory resultData) = address(assetAddr).call(data);\n        require(success, string(resultData));\n    }\n\n    function getRandomTokenIdFromVault() internal virtual returns (uint256) {\n        uint256 randomIndex = uint256(\n            keccak256(\n                abi.encodePacked(\n                    blockhash(block.number - 1), \n                    randNonce,\n                    block.coinbase,\n                    block.difficulty,\n                    block.timestamp\n                )\n            )\n        ) % holdings.length();\n        randNonce += 1;\n        return holdings.at(randomIndex);\n    }\n\n    function onlyPrivileged() internal view {\n        if (manager == address(0)) {\n            require(msg.sender == owner(), \"Not owner\");\n        } else {\n            require(msg.sender == manager, \"Not manager\");\n        }\n    }\n\n    function onlyOwnerIfPaused(uint256 lockId) internal view {\n        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), \"Paused\");\n    }\n}\n\n\n",
        "CodeNames": [
            "NFTXVaultUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXVaultUpgradeable contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "Pool Manager can frontrun fees to 100% and use it to steal the value from users.",
                "Repair": "Add a timelock to change fees. In that way, frontrunning wouldn't be possible and users would know the fees they are agreeing with."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXSimpleFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXInventoryStaking public immutable inventoryStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 public lpLockTime = 48 hours; \n  uint256 public inventoryLockTime = 7 days; \n  uint256 constant BASE = 10**18;\n\n  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {\n    require(newLPLockTime <= 7 days, \"Lock too long\");\n    lpLockTime = newLPLockTime;\n  } \n\n  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {\n    require(newInventoryLockTime <= 14 days, \"Lock too long\");\n    inventoryLockTime = newInventoryLockTime;\n  }\n\n  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {\n    uint256 count = tokenIds.length;\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    uint256[] memory amounts = new uint256[](0);\n    address assetAddress = vault.assetAddress();\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      transferFromERC721(assetAddress, tokenIds[i], address(vault));\n      approveERC721(assetAddress, address(vault), tokenIds[i]);\n    }\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {\n    uint256 count;\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      count += amounts[i];\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());\n    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, \"\");\n    nft.setApprovalForAll(address(vault), true);\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function addLiquidity721ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn\n  ) public payable returns (uint256) {\n    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);\n  }\n\n  function addLiquidity721ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn\n  ) public payable returns (uint256) {\n    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);\n  }\n\n  function addLiquidity1155ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    // Finish this.\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity721To(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity1155To(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function _addLiquidity721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidity1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidityAndLock(\n    uint256 vaultId, \n    address vault, \n    uint256 minTokenIn, \n    uint256 minWethIn, \n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    // Provide liquidity.\n    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);\n    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(\n      address(vault), \n      sushiRouter.WETH(),\n      minTokenIn, \n      wethIn, \n      minTokenIn,\n      minWethIn,\n      address(this), \n      block.timestamp\n    );\n\n    // Stake in LP rewards contract \n    address lpToken = pairFor(vault, address(WETH));\n    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);\n    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);\n    \n    if (amountToken < minTokenIn) {\n      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);\n    }\n\n    uint256 lockEndTime = block.timestamp + lpLockTime;\n    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);\n    return (amountToken, amountEth, liquidity);\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n\n  function rescue(address token) external onlyOwner {\n    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTXStakingZap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address",
                "Type": "Medium Severity",
                "Description": "transferFromERC721 function transfers Cryptokitties to the wrong address.",
                "Repair": "Change the transferFromERC721 function to transfer to 'to' instead of 'address(this)'"
            },
            {
                "Location": "NFTXStakingZap contract",
                "Type": "Bypass timelock",
                "Description": "The applicable timelock can be reduced by calling deposit in NFTXInventoryStaking.",
                "Repair": "Add a check to ensure that the applicable timelock is not reduced"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n  function balanceOf(address to) external view returns (uint256);\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 constant BASE = 10**18;\n\n  event Buy(uint256 count, uint256 ethSpent, address to);\n  event Sell(uint256 count, uint256 ethReceived, address to);\n  event Swap(uint256 count, uint256 ethSpent, address to);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function mintAndSell721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function mintAndSell721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function buyAndSwap721(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndSwap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap1155WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndRedeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndRedeemWETH(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function mintAndSell1155(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function mintAndSell1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function _mint721(\n    uint256 vaultId, \n    uint256[] memory ids\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); \n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _swap721(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < idsIn.length; i++) {\n      transferFromERC721(assetAddress, idsIn[i], vault);\n      approveERC721(assetAddress, vault, idsIn[i]);\n    }\n    uint256[] memory emptyIds;\n    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _swap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory amounts,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _redeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds,\n    address to\n  ) internal {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n    INFTXVault(vault).redeemTo(amount, specificIds, to);\n  }\n\n  function _mint1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _buyVaultToken(\n    address vault, \n    uint256 minTokenOut, \n    uint256 maxWethIn, \n    address[] calldata path\n  ) internal returns (uint256[] memory) {\n    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n      minTokenOut,\n      maxWethIn,\n      path, \n      address(this),\n      block.timestamp\n    );\n\n    return amounts;\n  }\n  function _sellVaultTokenWETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function _sellVaultTokenETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTXMarketplaceZap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXMarketplaceZap.sol#buyAnd*() should return unused weth/eth back to msg.sender instead of to",
                "Type": "Medium Severity",
                "Description": "NFTXMarketplaceZap.sol#buyAnd*() should return unused weth/eth back to msg.sender instead of to.",
                "Repair": "Update the function to return unused WETH/ETH back to msg.sender instead of 'to'"
            }
        ]
    }
]