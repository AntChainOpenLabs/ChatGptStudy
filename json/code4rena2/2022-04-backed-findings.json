[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}\n\n\n",
        "CodeNames": [
            "NFTLoanFacilitator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTLoanFacilitator.sol#L205-L208, NFTLoanFacilitator.sol#L215-L218",
                "Type": "Reentrancy Attack",
                "Description": "An attacker can manipulate loanInfo by reentrancy attack when any lenders try to buyout. The attacker can set bad values of lendInfo (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.",
                "Repair": "Use nonReentrant modifier on lend() to prevent reentrancy attack or block ERC777 tokens"
            },
            {
                "Location": "NFTLoanFacilitator.sol#L205-L208, NFTLoanFacilitator.sol#L215-L218",
                "Type": "Denial of Service (DoS)",
                "Description": "If an attacker (lender) lends to a loan, the attacker can always revert transactions when any lenders try to buyout, making anyone can not buyout the loan of the attacker.",
                "Repair": "Don't transfer ERC20(loanAssetContractAddress) to currentLoanOwner in lend(), use a global mapping to record redemption of lenders and add an external function redeem for lenders to transfer ERC20(loanAssetContractAddress) or block ERC777 tokens"
            },
            {
                "Location": "NFTLoanFacilitator.sol#L214-L221, NFTLoanFacilitator.sol#L230-L250",
                "Type": "Reentrancy Attack",
                "Description": "If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.",
                "Repair": "Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely. If desired, also require that the lender cannot be the same account as the borrower of a loan."
            },
            {
                "Location": "NFTLoanFacilitator.sol#L155-L160",
                "Type": "Protocol doesn't handle fee on transfer tokens",
                "Description": "Loans can be created with tokens that support fee on transfer, which can cause the second transfer to fail or be received at a loss for the borrower and lender.",
                "Repair": "Calculate the originationFee based on the requested loan amount or calculate the amount received from the initial transfer and use this amount to calculate the originationFee"
            },
            {
                "Location": "NFTLoanFacilitator.sol#L102-L102",
                "Type": "mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk",
                "Description": "If mintBorrowTicketTo is a contract that does not implement the onERC721Received method, the BorrowTicket NFT will be used later to get back the user's funds, which can put users' funds at risk.",
                "Repair": "Use safeMint in NFTLoanTicket.sol#mint()"
            },
            {
                "Location": "NFTLoanFacilitator.sol#L148",
                "Type": "Min loan amount semantics",
                "Description": "The loan amount is used as a min loan amount. It can be matched as high as possible (realistically up to the collateral NFT's worth to remain in profit) and the borrower has to pay interest on the entire amount instead of just on the desired loan amount when the loan was created.",
                "Repair": "Add a maxLoanAmount parameter to limit the loan amount that can be matched to the collateral NFT's worth."
            },
            {
                "Location": "NFTLoanFacilitator.sol#L167-L179",
                "Type": "Precision loss",
                "Description": "When previousInterestRate is less than 10 and requiredImprovementRate is 100, due to precision loss, the new interestRate is allowed to be the same as the previous one.",
                "Repair": "Use OpenZeppelin/Math.sol#L39-L42 to avoid precision loss and change the check to previousInterestRate != 0 && previousInterestRate < Math.ceilDiv(previousInterestRate * requiredImprovementRate, SCALAR)."
            },
            {
                "Location": "NFTLoanFacilitator.sol#L241",
                "Type": "Incorrect function call",
                "Description": "The repayAndCloseLoan function does not revert if there has not been a lender for a loan (matched with lend). Users should use closeLoan in this case but the contract should disallow calling repayAndCloseLoan because users can lose funds.",
                "Repair": "Add a check that there actually is something to repay by requiring loan.lastAccumulatedTimestamp > 0 before calling repayAndCloseLoan."
            },
            {
                "Location": "NFTLoanFacilitator.sol#L116-L126",
                "Type": "Unchecked transfer",
                "Description": "The sendCollateralTo address is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen.",
                "Repair": "Use safeTransferFrom instead of transferFrom"
            },
            {
                "Location": "NFTLoanFacilitator.sol#L309",
                "Type": "Incorrect loan amount calculation",
                "Description": "The borrower might not get the desired min loan amount if the originationFeeRate changes, as the minLoanAmount is calculated based on the current origination fee rate and not the rate at the time of loan creation.",
                "Repair": "Store originationFeeRate in the Loan struct at the time of origination to guarantee a borrower gets the fee rate that was present when they created the loan"
            }
        ]
    }
]