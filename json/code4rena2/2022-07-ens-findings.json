[
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC1155Fuse.sol\";\nimport \"./Controllable.sol\";\nimport \"./INameWrapper.sol\";\nimport \"./INameWrapperUpgrade.sol\";\nimport \"./IMetadataService.sol\";\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BytesUtil.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     */\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /**\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     */\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 && expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !isApprovedForAll(registrant, msg.sender) &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &&\n            !isApprovedForAll(owner, msg.sender) &&\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses & PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, \"\");\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses & CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses & ~PARENT_CANNOT_CONTROL != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "NameWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NameWrapper.sol#L820-L821, NameWrapper.sol#L524, NameWrapper.sol#L572",
                "Type": "Fake ERC1155 token creation",
                "Description": "It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper due to re-entrancy possibility in NameWrapper._transferAndBurnFuses.",
                "Repair": "Add nonReentrant modifiers with ReentrancyGuard implementation from openzeppelin or fix the individual re-entrancy issue by saving ERC1155 data and requiring it to match the data after transfer"
            },
            {
                "Location": "NameWrapper.sol",
                "Type": "Smart Contract Logic",
                "Description": "The preimage DB (i.e., NameWrapper.names) can be maliciously manipulated/corrupted.",
                "Repair": "When wrapping node X, check whether NameWrapper.names[X] is empty directly, and update the preimage DB if it is empty"
            },
            {
                "Location": "NameWrapper.sol#L504, NameWrapper.sol#L356",
                "Type": "expiry violation",
                "Description": "The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy.",
                "Repair": "auto-burn CANNOT_UNWRAP or force the parent to have CANNOT_UNWRAP burnt if they want to set expiries on a child via setSubnodeOwner / setSubnodeRecord / setChildFuses"
            },
            {
                "Location": "NameWrapper.sol#L955-L961",
                "Type": "Incorrect logic",
                "Description": "There is a general incorrect logic of allowing to burn only PARENT_CANNOT_CONTROL fuse without burning CANNOT_UNWRAP fuse.",
                "Repair": "Burning any fuse (including PARENT_CANNOT_CONTROL) must require CANNOT_UNWRAP fuse to be burned"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/* This contract is a variation on ERC1155 with the additions of _setData, getData and _canTransfer and ownerOf. _setData and getData allows the use of the other 96 bits next to the address of the owner for extra data. We use this to store 'fuses' that control permissions that can be burnt. 32 bits are used for the fuses themselves and 64 bits are used for the expiry of the name. When a name has expired, its fuses will be be set back to 0 */\n\nerror OperationProhibited(bytes32 node);\n\nabstract contract ERC1155Fuse is ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => uint256) public _tokens;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**************************************************************************\n     * ERC721 methods\n     *************************************************************************/\n\n    function ownerOf(uint256 id) public view virtual returns (address) {\n        (address owner, , ) = getData(id);\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            account != address(0),\n            \"ERC1155: balance query for the zero address\"\n        );\n        (address owner, , ) = getData(id);\n        if (owner == account) {\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            \"ERC1155: accounts and ids length mismatch\"\n        );\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(\n            msg.sender != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev Returns the Name's owner address and fuses\n     */\n    function getData(uint256 tokenId)\n        public\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64 expiry\n        )\n    {\n        uint256 t = _tokens[tokenId];\n        owner = address(uint160(t));\n        expiry = uint64(t >> 192);\n        if (block.timestamp > expiry) {\n            fuses = 0;\n        } else {\n            fuses = uint32(t >> 160);\n        }\n    }\n\n    /**\n     * @dev Sets the Name's owner address and fuses\n     */\n    function _setData(\n        uint256 tokenId,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal virtual {\n        _tokens[tokenId] =\n            uint256(uint160(owner)) |\n            (uint256(fuses) << 160) |\n            (uint256(expiry) << 192);\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            (address oldOwner, uint32 fuses, uint64 expiration) = getData(id);\n\n            if (!_canTransfer(fuses)) {\n                revert OperationProhibited(bytes32(id));\n            }\n\n            require(\n                amount == 1 && oldOwner == from,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _setData(id, to, fuses, expiration);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**************************************************************************\n     * Internal/private methods\n     *************************************************************************/\n\n    function _canTransfer(uint32 fuses) internal virtual returns (bool);\n\n    function _mint(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal virtual {\n        uint256 tokenId = uint256(node);\n        address owner = ownerOf(tokenId);\n        require(owner == address(0), \"ERC1155: mint of existing token\");\n        require(newOwner != address(0), \"ERC1155: mint to the zero address\");\n        require(\n            newOwner != address(this),\n            \"ERC1155: newOwner cannot be the NameWrapper contract\"\n        );\n\n        _setData(tokenId, newOwner, fuses, expiry);\n        emit TransferSingle(msg.sender, address(0x0), newOwner, tokenId, 1);\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            newOwner,\n            tokenId,\n            1,\n            \"\"\n        );\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ownerOf(tokenId);\n        // Clear fuses and set owner to 0\n        _setData(tokenId, address(0x0), 0, 0);\n        emit TransferSingle(msg.sender, owner, address(0x0), tokenId, 1);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);\n        if (oldOwner == to) {\n            return;\n        }\n\n        if (!_canTransfer(fuses)) {\n            revert OperationProhibited(bytes32(id));\n        }\n\n        require(\n            amount == 1 && oldOwner == from,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        _setData(id, to, fuses, expiry);\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC1155Receiver(to).onERC1155Received.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response !=\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC1155Fuse.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ERC1155Fuse.sol#L274-L284",
                "Type": "Non-compliance with ERC1155 standard",
                "Description": "ERC1155Fuse: _transfer does not revert when sent to the old owner violating the EIP-1155 standard.",
                "Repair": "Revert even if the 'to' address already owns the token"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BaseRegistrarImplementation is ERC721, IBaseRegistrar, Ownable  {\n    // A map of expiry times\n    mapping(uint256=>uint) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ERC721_ID = bytes4(\n        keccak256(\"balanceOf(address)\") ^\n        keccak256(\"ownerOf(uint256)\") ^\n        keccak256(\"approve(address,uint256)\") ^\n        keccak256(\"getApproved(uint256)\") ^\n        keccak256(\"setApprovalForAll(address,bool)\") ^\n        keccak256(\"isApprovedForAll(address,address)\") ^\n        keccak256(\"transferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n    );\n    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721(\"\",\"\") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns(uint) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns(bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(uint256 id, address owner, uint duration) external override returns(uint) {\n      return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\n      return _register(id, owner, duration, false);\n    }\n\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) {\n        require(available(id));\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if(_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if(updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint duration) external override live onlyController returns(uint) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override(ERC721, IERC165) view returns (bool) {\n        return interfaceID == INTERFACE_META_ID ||\n               interfaceID == ERC721_ID ||\n               interfaceID == RECLAIM_ID;\n    }\n}\n\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC1155Fuse.sol\";\nimport \"./Controllable.sol\";\nimport \"./INameWrapper.sol\";\nimport \"./INameWrapperUpgrade.sol\";\nimport \"./IMetadataService.sol\";\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BytesUtil.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     */\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /**\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     */\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 && expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !isApprovedForAll(registrant, msg.sender) &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &&\n            !isApprovedForAll(owner, msg.sender) &&\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses & PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, \"\");\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses & CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses & ~PARENT_CANNOT_CONTROL != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n\n\npragma solidity >=0.8.4;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"../registry/ReverseRegistrar.sol\";\nimport \"./IETHRegistrarController.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../wrapper/INameWrapper.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract ETHRegistrarController is Ownable, IETHRegistrarController {\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper\n    ) {\n        require(_maxCommitmentAge > _minCommitmentAge);\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(string memory name, uint256 duration)\n        public\n        view\n        override\n        returns (IPriceOracle.Price memory price)\n    {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0) {\n            require(\n                resolver != address(0),\n                \"ETHRegistrarController: resolver is required when data is supplied\"\n            );\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    resolver,\n                    data,\n                    secret,\n                    reverseRecord,\n                    fuses,\n                    wrapperExpiry\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= (price.base + price.premium),\n            \"ETHRegistrarController: Not enough ether provided\"\n        );\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                fuses,\n                wrapperExpiry\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            fuses,\n            wrapperExpiry\n        );\n\n        _setRecords(resolver, keccak256(bytes(name)), data);\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(string calldata name, uint256 duration)\n        external\n        payable\n        override\n    {\n        bytes32 label = keccak256(bytes(name));\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= price.base,\n            \"ETHController: Not enough Ether provided for renewal\"\n        );\n\n        uint256 expires = base.renew(uint256(label), duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, label, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        pure\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require a valid commitment (is old enough and is committed)\n        require(\n            commitments[commitment] + minCommitmentAge <= block.timestamp,\n            \"ETHRegistrarController: Commitment is not valid\"\n        );\n\n        // If the commitment is too old, or the name is registered, stop\n        require(\n            commitments[commitment] + maxCommitmentAge > block.timestamp,\n            \"ETHRegistrarController: Commitment has expired\"\n        );\n        require(available(name), \"ETHRegistrarController: Name is unavailable\");\n\n        delete (commitments[commitment]);\n\n        require(duration >= MIN_REGISTRATION_DURATION);\n    }\n\n    function _setRecords(\n        address resolver,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        for (uint256 i = 0; i < data.length; i++) {\n            // check first few bytes are namehash\n            bytes32 txNamehash = bytes32(data[i][4:36]);\n            require(\n                txNamehash == nodehash,\n                \"ETHRegistrarController: Namehash on record do not match the name being registered\"\n            );\n            resolver.functionCall(\n                data[i],\n                \"ETHRegistrarController: Failed to set Record\"\n            );\n        }\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, \".eth\")\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "BaseRegistrarImplementation.sol",
            "NameWrapper.sol",
            "ETHRegistrarController.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ETHRegistrarController.sol, BaseRegistrarImplementation.sol, NameWrapper.sol",
                "Type": "Smart Contract Logic",
                "Description": "Users can create extra ENS records at no cost by exploiting the functionCall in the _setRecords function. The preimage DB (i.e., NameWrapper.names) can be maliciously manipulated/corrupted.",
                "Repair": "Update the code to check whether the node is already wrapped before updating the preimage DB"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\n\n/**\n * The ENS registry contract.\n */\ncontract ENSRegistry is ENS {\n\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping (bytes32 => Record) records;\n    mapping (address => mapping(address => bool)) operators;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier authorised(bytes32 node) {\n        address owner = records[node].owner;\n        require(owner == msg.sender || operators[owner][msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Constructs a new ENS registry.\n     */\n    constructor() public {\n        records[0x0].owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets the record for a node.\n     * @param node The node to update.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\n        setOwner(node, owner);\n        _setResolverAndTTL(node, resolver, ttl);\n    }\n\n    /**\n     * @dev Sets the record for a subnode.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\n        _setResolverAndTTL(subnode, resolver, ttl);\n    }\n\n    /**\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param owner The address of the new owner.\n     */\n    function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\n        _setOwner(node, owner);\n        emit Transfer(node, owner);\n    }\n\n    /**\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        _setOwner(subnode, owner);\n        emit NewOwner(node, label, owner);\n        return subnode;\n    }\n\n    /**\n     * @dev Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolver The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\n        emit NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /**\n     * @dev Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttl The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n\n    /**\n     * @dev Enable or disable approval for a third party (\"operator\") to manage\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\n     * @param operator Address to add to the set of authorized operators.\n     * @param approved True if the operator is approved, false to revoke approval.\n     */\n    function setApprovalForAll(address operator, bool approved) external virtual override {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Returns the address that owns the specified node.\n     * @param node The specified node.\n     * @return address of the owner.\n     */\n    function owner(bytes32 node) public virtual override view returns (address) {\n        address addr = records[node].owner;\n        if (addr == address(this)) {\n            return address(0x0);\n        }\n\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address of the resolver for the specified node.\n     * @param node The specified node.\n     * @return address of the resolver.\n     */\n    function resolver(bytes32 node) public virtual override view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * @dev Returns the TTL of a node, and any records associated with it.\n     * @param node The specified node.\n     * @return ttl of the node.\n     */\n    function ttl(bytes32 node) public virtual override view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * @dev Returns whether a record has been imported to the registry.\n     * @param node The specified node.\n     * @return Bool if record exists\n     */\n    function recordExists(bytes32 node) public virtual override view returns (bool) {\n        return records[node].owner != address(0x0);\n    }\n\n    /**\n     * @dev Query if an address is an authorized operator for another address.\n     * @param owner The address that owns the records.\n     * @param operator The address that acts on behalf of the owner.\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\n     */\n    function isApprovedForAll(address owner, address operator) external virtual override view returns (bool) {\n        return operators[owner][operator];\n    }\n\n    function _setOwner(bytes32 node, address owner) internal virtual {\n        records[node].owner = owner;\n    }\n\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\n        if(resolver != records[node].resolver) {\n            records[node].resolver = resolver;\n            emit NewResolver(node, resolver);\n        }\n\n        if(ttl != records[node].ttl) {\n            records[node].ttl = ttl;\n            emit NewTTL(node, ttl);\n        }\n    }\n}\n\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC1155Fuse.sol\";\nimport \"./Controllable.sol\";\nimport \"./INameWrapper.sol\";\nimport \"./INameWrapperUpgrade.sol\";\nimport \"./IMetadataService.sol\";\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BytesUtil.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     */\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /**\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     */\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 && expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !isApprovedForAll(registrant, msg.sender) &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &&\n            !isApprovedForAll(owner, msg.sender) &&\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses & PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, \"\");\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses & CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses & ~PARENT_CANNOT_CONTROL != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "ENSRegistry.sol",
            "NameWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NameWrapper.sol#L356, NameWrapper.sol#L295, ENSRegistry.sol#L74",
                "Type": "PARENT_CANNOT_CONTROL bypass",
                "Description": "The PARENT_CANNOT_CONTROL fuse can be bypassed by maliciously unwrapping parent node.",
                "Repair": "auto-burn CANNOT_UNWRAP or leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Owned.sol\";\nimport \"./BytesUtils.sol\";\nimport \"./RRUtils.sol\";\nimport \"./DNSSEC.sol\";\nimport \"./algorithms/Algorithm.sol\";\nimport \"./digests/Digest.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/*\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\n */\ncontract DNSSECImpl is DNSSEC, Owned {\n    using Buffer for Buffer.buffer;\n    using BytesUtils for bytes;\n    using RRUtils for *;\n\n    uint16 constant DNSCLASS_IN = 1;\n\n    uint16 constant DNSTYPE_DS = 43;\n    uint16 constant DNSTYPE_DNSKEY = 48;\n\n    uint constant DNSKEY_FLAG_ZONEKEY = 0x100;\n\n    error InvalidLabelCount(bytes name, uint labelsExpected);\n    error SignatureNotValidYet(uint32 inception, uint32 now);\n    error SignatureExpired(uint32 expiration, uint32 now);\n    error InvalidClass(uint16 class);\n    error InvalidRRSet();\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\n    error InvalidProofType(uint16 proofType);\n    error ProofNameMismatch(bytes signerName, bytes proofName);\n    error NoMatchingProof(bytes signerName);\n\n    mapping (uint8 => Algorithm) public algorithms;\n    mapping (uint8 => Digest) public digests;\n\n    /**\n     * @dev Constructor.\n     * @param _anchors The binary format RR entries for the root DS records.\n     */\n    constructor(bytes memory _anchors) {\n        // Insert the 'trust anchors' - the key hashes that start the chain\n        // of trust for all other records.\n        anchors = _anchors;\n    }\n\n    /**\n     * @dev Sets the contract address for a signature verification algorithm.\n     *      Callable only by the owner.\n     * @param id The algorithm ID\n     * @param algo The address of the algorithm contract.\n     */\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n    /**\n     * @dev Sets the contract address for a digest verification algorithm.\n     *      Callable only by the owner.\n     * @param id The digest ID\n     * @param digest The address of the digest contract.\n     */\n    function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @return The RRData from the last RRSet in the chain.\n     */\n    function verifyRRSet(RRSetWithSignature[] memory input) external virtual view override returns(bytes memory) {\n        return verifyRRSet(input, block.timestamp);\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @param now The Unix timestamp to validate the records at.\n     * @return The RRData from the last RRSet in the chain.\n     */\n    function verifyRRSet(RRSetWithSignature[] memory input, uint256 now) public virtual view override returns(bytes memory) {\n        bytes memory proof = anchors;\n        for(uint i = 0; i < input.length; i++) {\n            RRUtils.SignedSet memory rrset = validateSignedSet(input[i], proof, now);\n            proof = rrset.data;\n        }\n        return proof;\n    }\n\n    /**\n     * @dev Validates an RRSet against the already trusted RR provided in `proof`.\n     *\n     * @param input The signed RR set. This is in the format described in section\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\n     *        data, followed by a series of canonicalised RR records that the signature\n     *        applies to.\n     * @param proof The DNSKEY or DS to validate the signature against.\n     * @param now The current timestamp.\n     */\n    function validateSignedSet(RRSetWithSignature memory input, bytes memory proof, uint256 now) internal view returns(RRUtils.SignedSet memory rrset) {\n        rrset = input.rrset.readSignedSet();\n\n        // Do some basic checks on the RRs and extract the name\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\n        if(name.labelCount(0) != rrset.labels) {\n            revert InvalidLabelCount(name, rrset.labels);\n        }\n        rrset.name = name;\n\n        // All comparisons involving the Signature Expiration and\n        // Inception fields MUST use \"serial number arithmetic\", as\n        // defined in RFC 1982\n\n        // o  The validator's notion of the current time MUST be less than or\n        //    equal to the time listed in the RRSIG RR's Expiration field.\n        if(!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\n            revert SignatureExpired(rrset.expiration, uint32(now));\n        }\n\n        // o  The validator's notion of the current time MUST be greater than or\n        //    equal to the time listed in the RRSIG RR's Inception field.\n        if(!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\n        }\n\n        // Validate the signature\n        verifySignature(name, rrset, input, proof);\n\n        return rrset;\n    }\n\n    /**\n     * @dev Validates a set of RRs.\n     * @param rrset The RR set.\n     * @param typecovered The type covered by the RRSIG record.\n     */\n    function validateRRs(RRUtils.SignedSet memory rrset, uint16 typecovered) internal pure returns (bytes memory name) {\n        // Iterate over all the RRs\n        for (RRUtils.RRIterator memory iter = rrset.rrs(); !iter.done(); iter.next()) {\n            // We only support class IN (Internet)\n            if(iter.class != DNSCLASS_IN) {\n                revert InvalidClass(iter.class);\n            }\n\n            if(name.length == 0) {\n                name = iter.name();\n            } else {\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\n                // repeatedly.\n                if(name.length != iter.data.nameLength(iter.offset) \n                    || !name.equals(0, iter.data, iter.offset, name.length))\n                {\n                    revert InvalidRRSet();\n                }\n            }\n\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n            if(iter.dnstype != typecovered) {\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n            }\n        }\n    }\n\n    /**\n     * @dev Performs signature verification.\n     *\n     * Throws or reverts if unable to verify the record.\n     *\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\n     * @param data The original data to verify.\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\n     */\n    function verifySignature(bytes memory name, RRUtils.SignedSet memory rrset, RRSetWithSignature memory data, bytes memory proof) internal view {\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\n        //    that contains the RRset.\n        if(rrset.signerName.length > name.length\n            || !rrset.signerName.equals(0, name, name.length - rrset.signerName.length))\n        {\n            revert InvalidSignerName(name, rrset.signerName);\n        }\n\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\n        // Check the proof\n        if (proofRR.dnstype == DNSTYPE_DS) {\n            verifyWithDS(rrset, data, proofRR);\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\n            verifyWithKnownKey(rrset, data, proofRR);\n        } else {\n            revert InvalidProofType(proofRR.dnstype);\n        }\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known public key.\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithKnownKey(RRUtils.SignedSet memory rrset, RRSetWithSignature memory data, RRUtils.RRIterator memory proof) internal view {\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n        for(; !proof.done(); proof.next()) {\n            bytes memory proofName = proof.name();\n            if(!proofName.equals(rrset.signerName)) {\n                revert ProofNameMismatch(rrset.signerName, proofName);\n            }\n\n            bytes memory keyrdata = proof.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(0, keyrdata.length);\n            if(verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                return;\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify some data using a provided key and a signature.\n     * @param dnskey The dns key record to verify the signature with.\n     * @param rrset The signed RRSET being verified.\n     * @param data The original data `rrset` was decoded from.\n     * @return True iff the key verifies the signature.\n     */\n    function verifySignatureWithKey(RRUtils.DNSKEY memory dnskey, bytes memory keyrdata, RRUtils.SignedSet memory rrset, RRSetWithSignature memory data)\n        internal\n        view\n        returns (bool)\n    {\n        // TODO: Check key isn't expired, unless updating key itself\n\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\n        if(dnskey.protocol != 3) {\n            return false;\n        }\n\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\n        //   the zone's apex DNSKEY RRset.\n        if(dnskey.algorithm != rrset.algorithm) {\n            return false;\n        }\n        uint16 computedkeytag = keyrdata.computeKeytag();\n        if (computedkeytag != rrset.keytag) {\n            return false;\n        }\n\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\n        //   set.\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n            return false;\n        }\n\n        return algorithms[dnskey.algorithm].verify(keyrdata, data.rrset, data.sig);\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\n     *      that the record \n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithDS(RRUtils.SignedSet memory rrset, RRSetWithSignature memory data, RRUtils.RRIterator memory proof) internal view {\n        for(RRUtils.RRIterator memory iter = rrset.rrs(); !iter.done(); iter.next()) {\n            if(iter.dnstype != DNSTYPE_DNSKEY) {\n                revert InvalidProofType(iter.dnstype);\n            }\n\n            bytes memory keyrdata = iter.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(0, keyrdata.length);\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                // It's self-signed - look for a DS record to verify it.\n                if(verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)) {\n                    return;\n                }\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify a key using DS records.\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\n     * @param dsrrs The DS records to use in verification.\n     * @param dnskey The dnskey to verify.\n     * @param keyrdata The RDATA section of the key.\n     * @return True if a DS record verifies this key.\n     */\n    function verifyKeyWithDS(bytes memory keyname, RRUtils.RRIterator memory dsrrs, RRUtils.DNSKEY memory dnskey, bytes memory keyrdata)\n        internal view returns (bool)\n    {\n        uint16 keytag = keyrdata.computeKeytag();\n        for (; !dsrrs.done(); dsrrs.next()) {\n            bytes memory proofName = dsrrs.name();\n            if(!proofName.equals(keyname)) {\n                revert ProofNameMismatch(keyname, proofName);\n            }\n\n            RRUtils.DS memory ds = dsrrs.data.readDS(dsrrs.rdataOffset, dsrrs.nextOffset - dsrrs.rdataOffset);\n            if(ds.keytag != keytag) {\n                continue;\n            }\n            if (ds.algorithm != dnskey.algorithm) {\n                continue;\n            }\n\n            Buffer.buffer memory buf;\n            buf.init(keyname.length + keyrdata.length);\n            buf.append(keyname);\n            buf.append(keyrdata);\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Attempts to verify a DS record's hash value against some data.\n     * @param digesttype The digest ID from the DS record.\n     * @param data The data to digest.\n     * @param digest The digest data to check against.\n     * @return True iff the digest matches.\n     */\n    function verifyDSHash(uint8 digesttype, bytes memory data, bytes memory digest) internal view returns (bool) {\n        if (address(digests[digesttype]) == address(0)) {\n            return false;\n        }\n        return digests[digesttype].verify(data, digest);\n    }\n}\n\n\n",
        "CodeNames": [
            "DNSSECImpl.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "DNSSECImpl.sol#L186-L190",
                "Type": "DNSSEC signature verification",
                "Description": "DNSSECImpl.verifySignature compares strings incorrectly, allowing malicious zones to forge DNSSEC trust chain.",
                "Repair": "Check label by label instead of comparing the entire name"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC1155Fuse.sol\";\nimport \"./Controllable.sol\";\nimport \"./INameWrapper.sol\";\nimport \"./INameWrapperUpgrade.sol\";\nimport \"./IMetadataService.sol\";\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BytesUtil.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     */\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /**\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     */\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 && expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !isApprovedForAll(registrant, msg.sender) &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &&\n            !isApprovedForAll(owner, msg.sender) &&\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses & PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, \"\");\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses & CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses & ~PARENT_CANNOT_CONTROL != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n\n\npragma solidity >=0.8.4;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"../registry/ReverseRegistrar.sol\";\nimport \"./IETHRegistrarController.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../wrapper/INameWrapper.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract ETHRegistrarController is Ownable, IETHRegistrarController {\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper\n    ) {\n        require(_maxCommitmentAge > _minCommitmentAge);\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(string memory name, uint256 duration)\n        public\n        view\n        override\n        returns (IPriceOracle.Price memory price)\n    {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0) {\n            require(\n                resolver != address(0),\n                \"ETHRegistrarController: resolver is required when data is supplied\"\n            );\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    resolver,\n                    data,\n                    secret,\n                    reverseRecord,\n                    fuses,\n                    wrapperExpiry\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= (price.base + price.premium),\n            \"ETHRegistrarController: Not enough ether provided\"\n        );\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                fuses,\n                wrapperExpiry\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            fuses,\n            wrapperExpiry\n        );\n\n        _setRecords(resolver, keccak256(bytes(name)), data);\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(string calldata name, uint256 duration)\n        external\n        payable\n        override\n    {\n        bytes32 label = keccak256(bytes(name));\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= price.base,\n            \"ETHController: Not enough Ether provided for renewal\"\n        );\n\n        uint256 expires = base.renew(uint256(label), duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, label, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        pure\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require a valid commitment (is old enough and is committed)\n        require(\n            commitments[commitment] + minCommitmentAge <= block.timestamp,\n            \"ETHRegistrarController: Commitment is not valid\"\n        );\n\n        // If the commitment is too old, or the name is registered, stop\n        require(\n            commitments[commitment] + maxCommitmentAge > block.timestamp,\n            \"ETHRegistrarController: Commitment has expired\"\n        );\n        require(available(name), \"ETHRegistrarController: Name is unavailable\");\n\n        delete (commitments[commitment]);\n\n        require(duration >= MIN_REGISTRATION_DURATION);\n    }\n\n    function _setRecords(\n        address resolver,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        for (uint256 i = 0; i < data.length; i++) {\n            // check first few bytes are namehash\n            bytes32 txNamehash = bytes32(data[i][4:36]);\n            require(\n                txNamehash == nodehash,\n                \"ETHRegistrarController: Namehash on record do not match the name being registered\"\n            );\n            resolver.functionCall(\n                data[i],\n                \"ETHRegistrarController: Failed to set Record\"\n            );\n        }\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, \".eth\")\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "NameWrapper.sol",
            "ETHRegistrarController.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ETHRegistrarController.sol#L201, NameWrapper.sol#L271",
                "Type": "subdomain renew",
                "Description": "Renew of 2nd level domain is not done properly.",
                "Repair": "Renew using Namewrapper's renew contract"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function unwrapETH2LD(bytes32 labelhash, address newRegistrant, address newController) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash))",
                "Type": "use of transferFrom instead of safeTransferFrom",
                "Description": "The use of transferFrom instead of safeTransferFrom to transfer ERC721 token can result in locking up the token in an unprepared contract or rejection of ERC-721 safeTransfers.",
                "Repair": "Use of safeTransferFrom instead of transferFrom"
            },
            {
                "Location": "function wrapETH2LD(bytes32 labelhash, address to) public override",
                "Type": "over-extended permissioning",
                "Description": "The current permissioning for wrapETH2LD allows msg.senders who are not owner to call it if they are EITHER approved for all on the ERC721 registrar or approved on the wrapper, which is an over-extension of approval.",
                "Repair": "Limit the approval to the tokens managed by the wrapper contract and not extend to unwrapped domains"
            },
            {
                "Location": "function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool)",
                "Type": "wrong equals logic",
                "Description": "The equals function with offset might return true when equals without offset returns false, which can lead to unexpected behavior.",
                "Repair": "Change the equals function to use '==' instead of '='"
            },
            {
                "Location": "function transfer(address payable recipient, uint256 amount) public override",
                "Type": "transfer() depends on gas consts",
                "Description": "The transfer() function forwards only 2300 gas, which may not be enough in the future if the recipient is a contract and gas costs change, leading to the breaking of existing contracts functionality.",
                "Repair": "Use of .call instead of .transfer or .send method"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.4;\n\nimport \"./BytesUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n* @dev RRUtils is a library that provides utilities for parsing DNS resource records.\n*/\nlibrary RRUtils {\n    using BytesUtils for *;\n    using Buffer for *;\n\n    /**\n    * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\n    * @param self The byte array to read a name from.\n    * @param offset The offset to start reading at.\n    * @return The length of the DNS name at 'offset', in bytes.\n    */\n    function nameLength(bytes memory self, uint offset) internal pure returns(uint) {\n        uint idx = offset;\n        while (true) {\n            assert(idx < self.length);\n            uint labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n        return idx - offset;\n    }\n\n    /**\n    * @dev Returns a DNS format name at the specified offset of self.\n    * @param self The byte array to read a name from.\n    * @param offset The offset to start reading at.\n    * @return ret The name.\n    */\n    function readName(bytes memory self, uint offset) internal pure returns(bytes memory ret) {\n        uint len = nameLength(self, offset);\n        return self.substring(offset, len);\n    }\n\n    /**\n    * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\n    * @param self The byte array to read a name from.\n    * @param offset The offset to start reading at.\n    * @return The number of labels in the DNS name at 'offset', in bytes.\n    */\n    function labelCount(bytes memory self, uint offset) internal pure returns(uint) {\n        uint count = 0;\n        while (true) {\n            assert(offset < self.length);\n            uint labelLen = self.readUint8(offset);\n            offset += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n            count += 1;\n        }\n        return count;\n    }\n\n    uint constant RRSIG_TYPE = 0;\n    uint constant RRSIG_ALGORITHM = 2;\n    uint constant RRSIG_LABELS = 3;\n    uint constant RRSIG_TTL = 4;\n    uint constant RRSIG_EXPIRATION = 8;\n    uint constant RRSIG_INCEPTION = 12;\n    uint constant RRSIG_KEY_TAG = 16;\n    uint constant RRSIG_SIGNER_NAME = 18;\n\n    struct SignedSet {\n        uint16 typeCovered;\n        uint8 algorithm;\n        uint8 labels;\n        uint32 ttl;\n        uint32 expiration;\n        uint32 inception;\n        uint16 keytag;\n        bytes signerName;\n        bytes data;\n        bytes name;\n    }\n\n    function readSignedSet(bytes memory data) internal pure returns(SignedSet memory self) {\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\n        self.labels = data.readUint8(RRSIG_LABELS);\n        self.ttl = data.readUint32(RRSIG_TTL);\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\n        self.inception = data.readUint32(RRSIG_INCEPTION);\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\n        self.data = data.substring(RRSIG_SIGNER_NAME + self.signerName.length, data.length - RRSIG_SIGNER_NAME - self.signerName.length);\n    }\n\n    function rrs(SignedSet memory rrset) internal pure returns(RRIterator memory) {\n        return iterateRRs(rrset.data, 0);\n    }\n\n    /**\n    * @dev An iterator over resource records.\n    */\n    struct RRIterator {\n        bytes data;\n        uint offset;\n        uint16 dnstype;\n        uint16 class;\n        uint32 ttl;\n        uint rdataOffset;\n        uint nextOffset;\n    }\n\n    /**\n    * @dev Begins iterating over resource records.\n    * @param self The byte string to read from.\n    * @param offset The offset to start reading at.\n    * @return ret An iterator object.\n    */\n    function iterateRRs(bytes memory self, uint offset) internal pure returns (RRIterator memory ret) {\n        ret.data = self;\n        ret.nextOffset = offset;\n        next(ret);\n    }\n\n    /**\n    * @dev Returns true iff there are more RRs to iterate.\n    * @param iter The iterator to check.\n    * @return True iff the iterator has finished.\n    */\n    function done(RRIterator memory iter) internal pure returns(bool) {\n        return iter.offset >= iter.data.length;\n    }\n\n    /**\n    * @dev Moves the iterator to the next resource record.\n    * @param iter The iterator to advance.\n    */\n    function next(RRIterator memory iter) internal pure {\n        iter.offset = iter.nextOffset;\n        if (iter.offset >= iter.data.length) {\n            return;\n        }\n\n        // Skip the name\n        uint off = iter.offset + nameLength(iter.data, iter.offset);\n\n        // Read type, class, and ttl\n        iter.dnstype = iter.data.readUint16(off);\n        off += 2;\n        iter.class = iter.data.readUint16(off);\n        off += 2;\n        iter.ttl = iter.data.readUint32(off);\n        off += 4;\n\n        // Read the rdata\n        uint rdataLength = iter.data.readUint16(off);\n        off += 2;\n        iter.rdataOffset = off;\n        iter.nextOffset = off + rdataLength;\n    }\n\n    /**\n    * @dev Returns the name of the current record.\n    * @param iter The iterator.\n    * @return A new bytes object containing the owner name from the RR.\n    */\n    function name(RRIterator memory iter) internal pure returns(bytes memory) {\n        return iter.data.substring(iter.offset, nameLength(iter.data, iter.offset));\n    }\n\n    /**\n    * @dev Returns the rdata portion of the current record.\n    * @param iter The iterator.\n    * @return A new bytes object containing the RR's RDATA.\n    */\n    function rdata(RRIterator memory iter) internal pure returns(bytes memory) {\n        return iter.data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);\n    }\n\n    uint constant DNSKEY_FLAGS = 0;\n    uint constant DNSKEY_PROTOCOL = 2;\n    uint constant DNSKEY_ALGORITHM = 3;\n    uint constant DNSKEY_PUBKEY = 4;\n\n    struct DNSKEY {\n        uint16 flags;\n        uint8 protocol;\n        uint8 algorithm;\n        bytes publicKey;\n    }\n\n    function readDNSKEY(bytes memory data, uint offset, uint length) internal pure returns(DNSKEY memory self) {\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\n        self.publicKey = data.substring(offset + DNSKEY_PUBKEY, length - DNSKEY_PUBKEY);\n    } \n\n    uint constant DS_KEY_TAG = 0;\n    uint constant DS_ALGORITHM = 2;\n    uint constant DS_DIGEST_TYPE = 3;\n    uint constant DS_DIGEST = 4;\n\n    struct DS {\n        uint16 keytag;\n        uint8 algorithm;\n        uint8 digestType;\n        bytes digest;\n    }\n\n    function readDS(bytes memory data, uint offset, uint length) internal pure returns(DS memory self) {\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\n    }\n\n    function compareNames(bytes memory self, bytes memory other) internal pure returns (int) {\n        if (self.equals(other)) {\n            return 0;\n        }\n\n        uint off;\n        uint otheroff;\n        uint prevoff;\n        uint otherprevoff;\n        uint counts = labelCount(self, 0);\n        uint othercounts = labelCount(other, 0);\n\n        // Keep removing labels from the front of the name until both names are equal length\n        while (counts > othercounts) {\n            prevoff = off;\n            off = progress(self, off);\n            counts--;\n        }\n\n        while (othercounts > counts) {\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            othercounts--;\n        }\n\n        // Compare the last nonequal labels to each other\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\n            prevoff = off;\n            off = progress(self, off);\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            counts -= 1;\n        }\n\n        if (off == 0) {\n            return -1;\n        }\n        if(otheroff == 0) {\n            return 1;\n        }\n\n        return self.compare(prevoff + 1, self.readUint8(prevoff), other, otherprevoff + 1, other.readUint8(otherprevoff));\n    }\n\n    /**\n     * @dev Compares two serial numbers using RFC1982 serial number math.\n     */\n    function serialNumberGte(uint32 i1, uint32 i2) internal pure returns(bool) {\n        return int32(i1) - int32(i2) >= 0;\n    }\n\n    function progress(bytes memory body, uint off) internal pure returns(uint) {\n        return off + 1 + body.readUint8(off);\n    }\n\n    /**\n     * @dev Computes the keytag for a chunk of data.\n     * @param data The data to compute a keytag for.\n     * @return The computed key tag.\n     */\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\n        /* This function probably deserves some explanation.\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\n         *\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\n         *         uint ac;\n         *         for (uint i = 0; i < data.length; i++) {\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\n         *         }\n         *         return uint16(ac + (ac >> 16));\n         *     }\n         *\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\n         * large words work in our favour.\n         *\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\n         * effectively summing 16 different numbers with each EVM ADD opcode.\n         *\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\n         * and the remaining sums can be done just on ac1.\n         */\n        unchecked {\n            require(data.length <= 8192, \"Long keys not permitted\");\n            uint ac1;\n            uint ac2;\n            for(uint i = 0; i < data.length + 31; i += 32) {\n                uint word;\n                assembly {\n                    word := mload(add(add(data, 32), i))\n                }\n                if(i + 32 > data.length) {\n                    uint unused = 256 - (data.length - i) * 8;\n                    word = (word >> unused) << unused;\n                }\n                ac1 += (word & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8;\n                ac2 += (word & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n            }\n            ac1 = (ac1 & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n                + ((ac1 & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16);\n            ac2 = (ac2 & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n                + ((ac2 & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16);\n            ac1 = (ac1 << 8) + ac2;\n            ac1 = (ac1 & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n                + ((ac1 & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32);\n            ac1 = (ac1 & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n                + ((ac1 & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64);\n            ac1 = (ac1 & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n                + (ac1 >> 128);\n            ac1 += (ac1 >> 16) & 0xFFFF;\n            return uint16(ac1);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "RRUtils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RRUtils.sol#L266-L268",
                "Type": "Incorrect implementation",
                "Description": "Comparing serial numbers should follow RFC1982 due to the possibility of numbers wrapping around. RRUtils.serialNumberGte tried to follow the RFC but failed to do so, leading to incorrect results in comparison.",
                "Repair": "Use the naive implementation instead"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    /*\n    * @dev Returns the keccak-256 hash of a byte range.\n    * @param self The byte string to hash.\n    * @param offset The position to start hashing at.\n    * @param len The number of bytes to hash.\n    * @return The hash of the byte range.\n    */\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal.\n    * @param self The first bytes to compare.\n    * @param other The second bytes to compare.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal. Comparison is done per-rune,\n    *      on unicode codepoints.\n    * @param self The first bytes to compare.\n    * @param offset The offset of self.\n    * @param len    The length of self.\n    * @param other The second bytes to compare.\n    * @param otheroffset The offset of the other string.\n    * @param otherlen    The length of the other string.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\n        uint shortest = len;\n        if (otherlen < len)\n        shortest = otherlen;\n\n        uint selfptr;\n        uint otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask;\n                if (shortest > 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                int diff = int(a & mask) - int(b & mask);\n                if (diff != 0)\n                return diff;\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int(len) - int(otherlen);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @param len The number of bytes to compare\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal with offsets.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\n    *      they are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n    * @dev Returns the 8-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 8 bits of the string, interpreted as an integer.\n    */\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n    * @dev Returns the 16-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 16 bits of the string, interpreted as an integer.\n    */\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bits of the string, interpreted as an integer.\n    */\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n        }\n    }\n\n    /*\n    * @dev Returns the n byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes.\n    * @param len The number of bytes.\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)),  mask)\n        }\n    }\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /*\n    * @dev Copies a substring into a new byte string.\n    * @param self The byte string to copy from.\n    * @param offset The offset to start copying at.\n    * @param len The number of bytes to copy.\n    */\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint dest;\n        uint src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\n        require(len <= 52);\n\n        uint ret = 0;\n        uint8 decoded;\n        for(uint i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if(i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint bitlen = len * 5;\n        if(len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if(len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if(len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if(len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if(len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    /**\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\n     * @param self The string to search\n     * @param off The offset to start searching at \n     * @param len The number of bytes to search\n     * @param needle The byte to search for\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\n     */\n    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {\n        for(uint256 idx = off; idx < off + len; idx++) {\n            if(self[idx] == needle) {\n                return idx;\n            }\n        }\n        return type(uint256).max;\n    }\n}\n\n",
        "CodeNames": [
            "BytesUtils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BytesUtils.sol#L66-L70",
                "Type": "Incorrect condition",
                "Description": "Due to incorrect condition in ByteUtil.compare function, irrelevant characters are masked out only for strings shorter than 32 characters.",
                "Repair": "Mask calculation formula should be corrected"
            },
            {
                "Location": "BytesUtils.sol#L44-L51",
                "Type": "Failure to check input validity",
                "Description": "Compare will return false answer without reverting when the inputs are not valid.",
                "Repair": "Check whether the offset, len are within the length of self, as well as for the other"
            }
        ]
    }
]