[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../../lib/utils/Ownable.sol\";\nimport { EIP712 } from \"../../lib/utils/EIP712.sol\";\nimport { SafeCast } from \"../../lib/utils/SafeCast.sol\";\n\nimport { GovernorStorageV1 } from \"./storage/GovernorStorageV1.sol\";\nimport { Token } from \"../../token/Token.sol\";\nimport { Treasury } from \"../treasury/Treasury.sol\";\nimport { IManager } from \"../../manager/IManager.sol\";\nimport { IGovernor } from \"./IGovernor.sol\";\n\n/// @title Governor\n/// @author Rohan Kulkarni\n/// @notice A DAO's proposal manager and transaction scheduler\n/// Modified from:\n/// - OpenZeppelin Contracts v4.7.3 (governance/extensions/GovernorTimelockControl.sol)\n/// - NounsDAOLogicV1.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\ncontract Governor is IGovernor, UUPS, Ownable, EIP712, GovernorStorageV1 {\n    ///                                                          ///\n    ///                         CONSTANTS                        ///\n    ///                                                          ///\n\n    /// @notice The EIP-712 typehash to vote with a signature\n    bytes32 public constant VOTE_TYPEHASH = keccak256(\"Vote(address voter,uint256 proposalId,uint256 support,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's governor\n    /// @param _treasury The DAO's treasury address\n    /// @param _token The DAO's governance token address\n    /// @param _vetoer The address eligible to veto proposals\n    /// @param _votingDelay The voting delay\n    /// @param _votingPeriod The voting period\n    /// @param _proposalThresholdBps The proposal threshold basis points\n    /// @param _quorumThresholdBps The quorum threshold basis points\n    function initialize(\n        address _treasury,\n        address _token,\n        address _vetoer,\n        uint256 _votingDelay,\n        uint256 _votingPeriod,\n        uint256 _proposalThresholdBps,\n        uint256 _quorumThresholdBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure non-zero addresses are provided\n        if (_treasury == address(0)) revert ADDRESS_ZERO();\n        if (_token == address(0)) revert ADDRESS_ZERO();\n\n        // Store the governor settings\n        settings.treasury = Treasury(payable(_treasury));\n        settings.token = Token(_token);\n        settings.vetoer = _vetoer;\n        settings.votingDelay = SafeCast.toUint48(_votingDelay);\n        settings.votingPeriod = SafeCast.toUint48(_votingPeriod);\n        settings.proposalThresholdBps = SafeCast.toUint16(_proposalThresholdBps);\n        settings.quorumThresholdBps = SafeCast.toUint16(_quorumThresholdBps);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(settings.token.symbol(), \" GOV\"), \"1\");\n\n        // Grant ownership to the treasury\n        __Ownable_init(_treasury);\n    }\n\n    ///                                                          ///\n    ///                         HASH PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Hashes a proposal's details into a proposal id\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function hashProposal(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        bytes32 _descriptionHash\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_targets, _values, _calldatas, _descriptionHash));\n    }\n\n    ///                                                          ///\n    ///                        CREATE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Creates a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _description The proposal description\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (bytes32) {\n        // Get the current proposal threshold\n        uint256 currentProposalThreshold = proposalThreshold();\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller's voting weight is greater than or equal to the threshold\n            if (getVotes(msg.sender, block.timestamp - 1) < proposalThreshold()) revert BELOW_PROPOSAL_THRESHOLD();\n        }\n\n        // Cache the number of targets\n        uint256 numTargets = _targets.length;\n\n        // Ensure at least one target exists\n        if (numTargets == 0) revert PROPOSAL_TARGET_MISSING();\n\n        // Ensure the number of targets matches the number of values and calldata\n        if (numTargets != _values.length) revert PROPOSAL_LENGTH_MISMATCH();\n        if (numTargets != _calldatas.length) revert PROPOSAL_LENGTH_MISMATCH();\n\n        // Compute the description hash\n        bytes32 descriptionHash = keccak256(bytes(_description));\n\n        // Compute the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);\n\n        // Get the pointer to store the proposal\n        Proposal storage proposal = proposals[proposalId];\n\n        // Ensure the proposal doesn't already exist\n        if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId);\n\n        // Used to store the snapshot and deadline\n        uint256 snapshot;\n        uint256 deadline;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the snapshot and deadline\n            snapshot = block.timestamp + settings.votingDelay;\n            deadline = snapshot + settings.votingPeriod;\n        }\n\n        // Store the proposal data\n        proposal.voteStart = uint32(snapshot);\n        proposal.voteEnd = uint32(deadline);\n        proposal.proposalThreshold = uint32(currentProposalThreshold);\n        proposal.quorumVotes = uint32(quorum());\n        proposal.proposer = msg.sender;\n        proposal.timeCreated = uint32(block.timestamp);\n\n        emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                          CAST VOTE                       ///\n    ///                                                          ///\n\n    /// @notice Casts a vote\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    function castVote(bytes32 _proposalId, uint256 _support) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, \"\");\n    }\n\n    /// @notice Casts a vote with a reason\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _reason The vote reason\n    function castVoteWithReason(\n        bytes32 _proposalId,\n        uint256 _support,\n        string memory _reason\n    ) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, _reason);\n    }\n\n    /// @notice Casts a signed vote\n    /// @param _voter The voter address\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function castVoteBySig(\n        address _voter,\n        bytes32 _proposalId,\n        uint256 _support,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256) {\n        // Ensure the deadline has not passed\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the signed digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the message\n            digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(VOTE_TYPEHASH, _voter, _proposalId, _support, nonces[_voter]++, _deadline))\n                )\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the given voter\n        if (recoveredAddress == address(0) || recoveredAddress != _voter) revert INVALID_SIGNATURE();\n\n        return _castVote(_proposalId, _voter, _support, \"\");\n    }\n\n    /// @dev Stores a vote\n    /// @param _proposalId The proposal id\n    /// @param _voter The voter address\n    /// @param _support The vote choice\n    function _castVote(\n        bytes32 _proposalId,\n        address _voter,\n        uint256 _support,\n        string memory _reason\n    ) internal returns (uint256) {\n        // Ensure voting is active\n        if (state(_proposalId) != ProposalState.Active) revert VOTING_NOT_STARTED();\n\n        // Ensure the voter hasn't already voted\n        if (hasVoted[_proposalId][_voter]) revert ALREADY_VOTED();\n\n        // Ensure the vote is valid\n        if (_support > 2) revert INVALID_VOTE();\n\n        // Record the voter as having voted\n        hasVoted[_proposalId][_voter] = true;\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Used to store the voter's weight\n        uint256 weight;\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Get the voter's weight at the time the proposal was created\n            weight = getVotes(_voter, proposal.timeCreated);\n\n            // If the vote is against:\n            if (_support == 0) {\n                // Update the total number of votes against\n                proposal.againstVotes += uint32(weight);\n\n                // Else if the vote is for:\n            } else if (_support == 1) {\n                // Update the total number of votes for\n                proposal.forVotes += uint32(weight);\n\n                // Else if the vote is to abstain:\n            } else if (_support == 2) {\n                // Update the total number of votes abstaining\n                proposal.abstainVotes += uint32(weight);\n            }\n        }\n\n        emit VoteCast(_voter, _proposalId, _support, weight, _reason);\n\n        return weight;\n    }\n\n    ///                                                          ///\n    ///                        QUEUE PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Queues a proposal\n    /// @param _proposalId The proposal id\n    function queue(bytes32 _proposalId) external returns (uint256 eta) {\n        // Ensure the proposal has succeeded\n        if (state(_proposalId) != ProposalState.Succeeded) revert PROPOSAL_UNSUCCESSFUL();\n\n        // Schedule the proposal for execution\n        eta = settings.treasury.queue(_proposalId);\n\n        emit ProposalQueued(_proposalId, eta);\n    }\n\n    ///                                                          ///\n    ///                       EXECUTE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Executes a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function execute(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        bytes[] calldata _calldatas,\n        bytes32 _descriptionHash\n    ) external payable returns (bytes32) {\n        // Get the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, _descriptionHash);\n\n        // Ensure the proposal is queued\n        if (state(proposalId) != ProposalState.Queued) revert PROPOSAL_NOT_QUEUED(proposalId);\n\n        // Mark the proposal as executed\n        proposals[proposalId].executed = true;\n\n        // Execute the proposal\n        settings.treasury.execute{ value: msg.value }(_targets, _values, _calldatas, _descriptionHash);\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                        CANCEL PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Cancels a proposal\n    /// @param _proposalId The proposal id\n    function cancel(bytes32 _proposalId) external {\n        // Ensure the proposal hasn't been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold\n            if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)\n                revert INVALID_CANCEL();\n        }\n\n        // Update the proposal as canceled\n        proposals[_proposalId].canceled = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        VETO PROPOSAL                     ///\n    ///                                                          ///\n\n    /// @notice Vetoes a proposal\n    /// @param _proposalId The proposal id\n    function veto(bytes32 _proposalId) external {\n        // Ensure the caller is the vetoer\n        if (msg.sender != settings.vetoer) revert ONLY_VETOER();\n\n        // Ensure the proposal has not been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Update the proposal as vetoed\n        proposal.vetoed = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        PROPOSAL STATE                    ///\n    ///                                                          ///\n\n    /// @notice The state of a proposal\n    /// @param _proposalId The proposal id\n    function state(bytes32 _proposalId) public view returns (ProposalState) {\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Ensure the proposal exists\n        if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();\n\n        // If the proposal was executed:\n        if (proposal.executed) {\n            return ProposalState.Executed;\n\n            // Else if the proposal was canceled:\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n\n            // Else if the proposal was vetoed:\n        } else if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n\n            // Else if voting has not started:\n        } else if (block.timestamp < proposal.voteStart) {\n            return ProposalState.Pending;\n\n            // Else if voting has not ended:\n        } else if (block.timestamp < proposal.voteEnd) {\n            return ProposalState.Active;\n\n            // Else if the proposal failed (outvoted OR didn't reach quorum):\n        } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n\n            // Else if the proposal has not been queued:\n        } else if (settings.treasury.timestamp(_proposalId) == 0) {\n            return ProposalState.Succeeded;\n\n            // Else if the proposal can no longer be executed:\n        } else if (settings.treasury.isExpired(_proposalId)) {\n            return ProposalState.Expired;\n\n            // Else the proposal is queued\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice The voting weight of an account at a timestamp\n    /// @param _account The account address\n    /// @param _timestamp The specific timestamp\n    function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        return settings.token.getPastVotes(_account, _timestamp);\n    }\n\n    /// @notice The current number of votes required to submit a proposal\n    function proposalThreshold() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.proposalThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The current number of votes required to be in favor of a proposal in order to reach quorum\n    function quorum() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.quorumThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The data stored for a given proposal\n    /// @param _proposalId The proposal id\n    function getProposal(bytes32 _proposalId) external view returns (Proposal memory) {\n        return proposals[_proposalId];\n    }\n\n    /// @notice The timestamp when voting starts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalSnapshot(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteStart;\n    }\n\n    /// @notice The timestamp when voting ends for a proposal\n    /// @param _proposalId The proposal id\n    function proposalDeadline(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteEnd;\n    }\n\n    /// @notice The vote counts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalVotes(bytes32 _proposalId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Proposal memory proposal = proposals[_proposalId];\n\n        return (proposal.againstVotes, proposal.forVotes, proposal.abstainVotes);\n    }\n\n    /// @notice The timestamp valid to execute a proposal\n    /// @param _proposalId The proposal id\n    function proposalEta(bytes32 _proposalId) external view returns (uint256) {\n        return settings.treasury.timestamp(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                      GOVERNOR SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The basis points of the token supply required to create a proposal\n    function proposalThresholdBps() external view returns (uint256) {\n        return settings.proposalThresholdBps;\n    }\n\n    /// @notice The basis points of the token supply required to reach quorum\n    function quorumThresholdBps() external view returns (uint256) {\n        return settings.quorumThresholdBps;\n    }\n\n    /// @notice The amount of time until voting begins after a proposal is created\n    function votingDelay() external view returns (uint256) {\n        return settings.votingDelay;\n    }\n\n    /// @notice The amount of time to vote on a proposal\n    function votingPeriod() external view returns (uint256) {\n        return settings.votingPeriod;\n    }\n\n    /// @notice The address eligible to veto any proposal (address(0) if burned)\n    function vetoer() external view returns (address) {\n        return settings.vetoer;\n    }\n\n    /// @notice The address of the governance token\n    function token() external view returns (address) {\n        return address(settings.token);\n    }\n\n    /// @notice The address of the treasury\n    function treasury() external view returns (address) {\n        return address(settings.treasury);\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the voting delay\n    /// @param _newVotingDelay The new voting delay\n    function updateVotingDelay(uint256 _newVotingDelay) external onlyOwner {\n        emit VotingDelayUpdated(settings.votingDelay, _newVotingDelay);\n\n        settings.votingDelay = SafeCast.toUint48(_newVotingDelay);\n    }\n\n    /// @notice Updates the voting period\n    /// @param _newVotingPeriod The new voting period\n    function updateVotingPeriod(uint256 _newVotingPeriod) external onlyOwner {\n        emit VotingPeriodUpdated(settings.votingPeriod, _newVotingPeriod);\n\n        settings.votingPeriod = SafeCast.toUint48(_newVotingPeriod);\n    }\n\n    /// @notice Updates the minimum proposal threshold\n    /// @param _newProposalThresholdBps The new proposal threshold basis points\n    function updateProposalThresholdBps(uint256 _newProposalThresholdBps) external onlyOwner {\n        emit ProposalThresholdBpsUpdated(settings.proposalThresholdBps, _newProposalThresholdBps);\n\n        settings.proposalThresholdBps = SafeCast.toUint16(_newProposalThresholdBps);\n    }\n\n    /// @notice Updates the minimum quorum threshold\n    /// @param _newQuorumVotesBps The new quorum votes basis points\n    function updateQuorumThresholdBps(uint256 _newQuorumVotesBps) external onlyOwner {\n        emit QuorumVotesBpsUpdated(settings.quorumThresholdBps, _newQuorumVotesBps);\n\n        settings.quorumThresholdBps = SafeCast.toUint16(_newQuorumVotesBps);\n    }\n\n    /// @notice Updates the vetoer\n    /// @param _newVetoer The new vetoer address\n    function updateVetoer(address _newVetoer) external onlyOwner {\n        if (_newVetoer == address(0)) revert ADDRESS_ZERO();\n\n        emit VetoerUpdated(settings.vetoer, _newVetoer);\n\n        settings.vetoer = _newVetoer;\n    }\n\n    /// @notice Burns the vetoer\n    function burnVetoer() external onlyOwner {\n        emit VetoerUpdated(settings.vetoer, address(0));\n\n        delete settings.vetoer;\n    }\n\n    ///                                                          ///\n    ///                       GOVERNOR UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "CodeNames": [
            "Governor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Governor.sol#L76, Governor.sol#L596-L602",
                "Type": "Loss of Veto Power can Lead to 51% Attack",
                "Description": "The lack of zero address check and lack of 2 step address changing process for vetoer address might lead to DAO owner losing their veto power unintentionally and open to 51% attack which can drain their entire treasury.",
                "Repair": "Add zero address check for vetoer address at initialize(). Change updateVetoer() vetoer address changing process to 2-step process like explained below. First make the updateVetoer() function approve a new vetoer address as a pending vetoer. Next that pending vetoer has to claim the ownership in a separate transaction to be a new vetoer."
            },
            {
                "Location": "Governor.sol#L248-L297",
                "Type": "Increase voting power by incentivizing",
                "Description": "If the benefit to be gained from the outcome of the vote is less than the cost of obtaining the right to vote, the outcome of the vote is influenced.",
                "Repair": "Add blacklist check for _castVote function and create a function to delete the voting power and add the address to the blacklist"
            },
            {
                "Location": "Governor.sol",
                "Type": "Compromised or malicious vetoer",
                "Description": "The settings.vetoer can veto any proposals with unrestricted power, which can be very high if the vetoer becomes compromised or malicious.",
                "Repair": "Add token supply threshold governance configuration. After the token supply exceeds this threshold, restrict the vetoer's power by allowing them to veto a proposal only during a defined period after the voting is done and only when the number of support and against votes are very close or the number of support votes is much higher than the against votes."
            },
            {
                "Location": "Governor.sol",
                "Type": "DAO proposal vulnerability",
                "Description": "A proposal can pass with 0 votes in favor at early DAO stages, allowing an attacker to gain sudo powers and take the funds. This vulnerability is caused by a combination of factors, including the ability to create a proposal directly after deployment, the proposal threshold and quorum votes being set to 0, and the allowance of a proposal with 0 votes to pass.",
                "Repair": "Require at least 1 vote for a proposal to be considered Succeeded"
            },
            {
                "Location": "Governor.sol#L588",
                "Type": "Bad settings",
                "Description": "If certain settings are set incorrectly, it can block proposals and auctions from succeeding or completing, and the impact is high.",
                "Repair": "Implement reasonable range bounds reverting where appropriate"
            },
            {
                "Location": "Governor.sol",
                "Type": "Ineffective Quorum Votes",
                "Description": "Quorum votes have no effect for determining whether proposal is defeated or succeeded when token supply is low.",
                "Repair": "Add a minimum quorum votes governance configuration that is at least 1. When quorum() returns 0 because the token supply is low, calling propose could set proposal.quorumVotes to the minimum quorum votes."
            },
            {
                "Location": "Governor contract",
                "Type": "Quorum could be less than intended",
                "Description": "There could be tokens minted between the quorum computation and the vote, which would lead to a quorum lower than intended.",
                "Repair": "Compute the total supply afterwards or take the vote with a timestamp of proposal.timeCreated 1 to not count the block during which the tx was submitted"
            },
            {
                "Location": "Governor contract",
                "Type": "Precision issue",
                "Description": "Precision is not enough for proposalThreshold and quorum. Collections with at least 20000 NFTs in total supply may have some trouble.",
                "Repair": "Increase division to a more precise value such as 1e18 to allow high total supply NFT to always set threshold as 1"
            },
            {
                "Location": "Governor.sol",
                "Type": "Cancellation vulnerability",
                "Description": "A proposal can be cancelled by anyone if the proposal has exactly proposalThreshold votes.",
                "Repair": "Change the check in cancel to match the requirement in propose"
            },
            {
                "Location": "Governor.sol",
                "Type": "Voting vulnerability",
                "Description": "State function does not require majority of votes for supporting and passing a proposal.",
                "Repair": "Governance configuration can be added to indicate whether the majority of votes is needed or not for supporting and passing a proposal"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Base64 } from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { LibUintToString } from \"sol2string/contracts/LibUintToString.sol\";\nimport { UriEncode } from \"sol-uriencode/src/UriEncode.sol\";\n\nimport { UUPS } from \"../../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../../lib/utils/Ownable.sol\";\n\nimport { MetadataRendererStorageV1 } from \"./storage/MetadataRendererStorageV1.sol\";\nimport { IPropertyIPFSMetadataRenderer } from \"./interfaces/IPropertyIPFSMetadataRenderer.sol\";\nimport { IManager } from \"../../manager/IManager.sol\";\n\n/// @title Metadata Renderer\n/// @author Iain Nash & Rohan Kulkarni\n/// @notice A DAO's artwork generator and renderer\ncontract MetadataRenderer is IPropertyIPFSMetadataRenderer, UUPS, Ownable, MetadataRendererStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's token metadata renderer\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder address responsible for adding initial properties\n    /// @param _treasury The DAO treasury that will own the contract\n    function initialize(\n        bytes calldata _initStrings,\n        address _token,\n        address _founder,\n        address _treasury\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Decode the token initialization strings\n        (string memory _name, , string memory _description, string memory _contractImage, string memory _rendererBase) = abi.decode(\n            _initStrings,\n            (string, string, string, string, string)\n        );\n\n        // Store the renderer settings\n        settings.name = _name;\n        settings.description = _description;\n        settings.contractImage = _contractImage;\n        settings.rendererBase = _rendererBase;\n        settings.token = _token;\n        settings.treasury = _treasury;\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n    }\n\n    ///                                                          ///\n    ///                     PROPERTIES & ITEMS                   ///\n    ///                                                          ///\n\n    /// @notice The number of properties\n    function propertiesCount() external view returns (uint256) {\n        return properties.length;\n    }\n\n    /// @notice The number of items in a property\n    /// @param _propertyId The property id\n    function itemsCount(uint256 _propertyId) external view returns (uint256) {\n        return properties[_propertyId].items.length;\n    }\n\n    /// @notice Adds properties and/or items to be pseudo-randomly chosen from during token minting\n    /// @param _names The names of the properties to add\n    /// @param _items The items to add to each property\n    /// @param _ipfsGroup The IPFS base URI and extension\n    function addProperties(\n        string[] calldata _names,\n        ItemParam[] calldata _items,\n        IPFSGroup calldata _ipfsGroup\n    ) external onlyOwner {\n        // Cache the existing amount of IPFS data stored\n        uint256 dataLength = ipfsData.length;\n\n        // If this is the first time adding properties and/or items:\n        if (dataLength == 0) {\n            // Transfer ownership to the DAO treasury\n            transferOwnership(settings.treasury);\n        }\n\n        // Add the IPFS group information\n        ipfsData.push(_ipfsGroup);\n\n        // Cache the number of existing properties\n        uint256 numStoredProperties = properties.length;\n\n        // Cache the number of new properties\n        uint256 numNewProperties = _names.length;\n\n        // Cache the number of new items\n        uint256 numNewItems = _items.length;\n\n        unchecked {\n            // For each new property:\n            for (uint256 i = 0; i < numNewProperties; ++i) {\n                // Append storage space\n                properties.push();\n\n                // Get the new property id\n                uint256 propertyId = numStoredProperties + i;\n\n                // Store the property name\n                properties[propertyId].name = _names[i];\n\n                emit PropertyAdded(propertyId, _names[i]);\n            }\n\n            // For each new item:\n            for (uint256 i = 0; i < numNewItems; ++i) {\n                // Cache the id of the associated property\n                uint256 _propertyId = _items[i].propertyId;\n\n                // Offset the id if the item is for a new property\n                // Note: Property ids under the hood are offset by 1\n                if (_items[i].isNewProperty) {\n                    _propertyId += numStoredProperties;\n                }\n\n                // Get the pointer to the other items for the property\n                Item[] storage items = properties[_propertyId].items;\n\n                // Append storage space\n                items.push();\n\n                // Get the index of the new item\n                // Cannot underflow as the items array length is ensured to be at least 1\n                uint256 newItemIndex = items.length - 1;\n\n                // Store the new item\n                Item storage newItem = items[newItemIndex];\n\n                // Store the new item's name and reference slot\n                newItem.name = _items[i].name;\n                newItem.referenceSlot = uint16(dataLength);\n\n                emit ItemAdded(_propertyId, newItemIndex);\n            }\n        }\n    }\n\n    ///                                                          ///\n    ///                     ATTRIBUTE GENERATION                 ///\n    ///                                                          ///\n\n    /// @notice Generates attributes for a token upon mint\n    /// @param _tokenId The ERC-721 token id\n    function onMinted(uint256 _tokenId) external returns (bool) {\n        // Ensure the caller is the token contract\n        if (msg.sender != settings.token) revert ONLY_TOKEN();\n\n        // Compute some randomness for the token id\n        uint256 seed = _generateSeed(_tokenId);\n\n        // Get the pointer to store generated attributes\n        uint16[16] storage tokenAttributes = attributes[_tokenId];\n\n        // Cache the total number of properties available\n        uint256 numProperties = properties.length;\n\n        // Store the total as reference in the first slot of the token's array of attributes\n        tokenAttributes[0] = uint16(numProperties);\n\n        unchecked {\n            // For each property:\n            for (uint256 i = 0; i < numProperties; ++i) {\n                // Get the number of items to choose from\n                uint256 numItems = properties[i].items.length;\n\n                // Use the token's seed to select an item\n                tokenAttributes[i + 1] = uint16(seed % numItems);\n\n                // Adjust the randomness\n                seed >>= 16;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice The properties and query string for a generated token\n    /// @param _tokenId The ERC-721 token id\n    function getAttributes(uint256 _tokenId) public view returns (bytes memory aryAttributes, bytes memory queryString) {\n        // Get the token's query string\n        queryString = abi.encodePacked(\n            \"?contractAddress=\",\n            Strings.toHexString(uint256(uint160(address(this))), 20),\n            \"&tokenId=\",\n            Strings.toString(_tokenId)\n        );\n\n        // Get the token's generated attributes\n        uint16[16] memory tokenAttributes = attributes[_tokenId];\n\n        // Cache the number of properties when the token was minted\n        uint256 numProperties = tokenAttributes[0];\n\n        // Ensure the given token was minted\n        if (numProperties == 0) revert TOKEN_NOT_MINTED(_tokenId);\n\n        unchecked {\n            // Cache the index of the last property\n            uint256 lastProperty = numProperties - 1;\n\n            // For each of the token's properties:\n            for (uint256 i = 0; i < numProperties; ++i) {\n                // Check if this is the last property\n                bool isLast = i == lastProperty;\n\n                // Get a copy of the property\n                Property memory property = properties[i];\n\n                // Get the token's generated attribute\n                uint256 attribute = tokenAttributes[i + 1];\n\n                // Get the associated item data\n                Item memory item = property.items[attribute];\n\n                // Store the encoded attributes and query string\n                aryAttributes = abi.encodePacked(aryAttributes, '\"', property.name, '\": \"', item.name, '\"', isLast ? \"\" : \",\");\n                queryString = abi.encodePacked(queryString, \"&images=\", _getItemImage(item, property.name));\n            }\n        }\n    }\n\n    /// @dev Generates a psuedo-random seed for a token id\n    function _generateSeed(uint256 _tokenId) private view returns (uint256) {\n        return uint256(keccak256(abi.encode(_tokenId, blockhash(block.number), block.coinbase, block.timestamp)));\n    }\n\n    /// @dev Encodes the reference URI of an item\n    function _getItemImage(Item memory _item, string memory _propertyName) private view returns (string memory) {\n        return\n            UriEncode.uriEncode(\n                string(\n                    abi.encodePacked(ipfsData[_item.referenceSlot].baseUri, _propertyName, \"/\", _item.name, ipfsData[_item.referenceSlot].extension)\n                )\n            );\n    }\n\n    ///                                                          ///\n    ///                            URIs                          ///\n    ///                                                          ///\n\n    /// @notice The contract URI\n    function contractURI() external view returns (string memory) {\n        return\n            _encodeAsJson(\n                abi.encodePacked(\n                    '{\"name\": \"',\n                    settings.name,\n                    '\", \"description\": \"',\n                    settings.description,\n                    '\", \"image\": \"',\n                    settings.contractImage,\n                    '\"}'\n                )\n            );\n    }\n\n    /// @notice The token URI\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\n        (bytes memory aryAttributes, bytes memory queryString) = getAttributes(_tokenId);\n        return\n            _encodeAsJson(\n                abi.encodePacked(\n                    '{\"name\": \"',\n                    settings.name,\n                    \" #\",\n                    LibUintToString.toString(_tokenId),\n                    '\", \"description\": \"',\n                    settings.description,\n                    '\", \"image\": \"',\n                    settings.rendererBase,\n                    queryString,\n                    '\", \"properties\": {',\n                    aryAttributes,\n                    \"}}\"\n                )\n            );\n    }\n\n    /// @dev Encodes data to JSON\n    function _encodeAsJson(bytes memory _jsonBlob) private pure returns (string memory) {\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(_jsonBlob)));\n    }\n\n    ///                                                          ///\n    ///                       METADATA SETTINGS                  ///\n    ///                                                          ///\n\n    /// @notice The associated ERC-721 token\n    function token() external view returns (address) {\n        return settings.token;\n    }\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The contract image\n    function contractImage() external view returns (string memory) {\n        return settings.contractImage;\n    }\n\n    /// @notice The renderer base\n    function rendererBase() external view returns (string memory) {\n        return settings.rendererBase;\n    }\n\n    /// @notice The collection description\n    function description() external view returns (string memory) {\n        return settings.description;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the contract image\n    /// @param _newContractImage The new contract image\n    function updateContractImage(string memory _newContractImage) external onlyOwner {\n        emit ContractImageUpdated(settings.contractImage, _newContractImage);\n\n        settings.contractImage = _newContractImage;\n    }\n\n    /// @notice Updates the renderer base\n    /// @param _newRendererBase The new renderer base\n    function updateRendererBase(string memory _newRendererBase) external onlyOwner {\n        emit RendererBaseUpdated(settings.rendererBase, _newRendererBase);\n\n        settings.rendererBase = _newRendererBase;\n    }\n\n    /// @notice Updates the collection description\n    /// @param _newDescription The new description\n    function updateDescription(string memory _newDescription) external onlyOwner {\n        emit DescriptionUpdated(settings.description, _newDescription);\n\n        settings.description = _newDescription;\n    }\n\n    ///                                                          ///\n    ///                        METADATA UPGRADE                  ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract to a valid implementation\n    /// @dev This function is called in UUPS `upgradeTo` & `upgradeToAndCall`\n    /// @param _impl The address of the new implementation\n    function _authorizeUpgrade(address _impl) internal view override onlyOwner {\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _impl)) revert INVALID_UPGRADE(_impl);\n    }\n}\n\n\n",
        "CodeNames": [
            "MetadataRenderer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MetadataRenderer.sol",
                "Type": "Tokens without properties can be minted and cannot be rendered",
                "Description": "It's possible to mint tokens when properties haven't yet been set in MetadataRenderer. Such tokens won't be possible to render due to this check in the getAttributes function of MetaRenderer contract.",
                "Repair": "In the onMinted() function of MetadataRenderer, ensure that properties.length is greater than 0."
            },
            {
                "Location": "MetadataRenderer.sol#L194",
                "Type": "Mismatching length between properties and items",
                "Description": "It is not possible to mint a ERC721 token if its properties has different length than its items.",
                "Repair": "Check length of both arrays in MetadataRenderer.addProperties() method"
            },
            {
                "Location": "MetadataRenderer.sol#L188-L198",
                "Type": "Index out of bounds error",
                "Description": "If the number of properties is more than 15 then the onMinted function will revert due to the limit on the number of attributes a token may have.",
                "Repair": "Limit the maximum amount of properties an owner can add to be less than the maximum amount of attributes any token can have or allow any number of attributes to be added to a token"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../../lib/utils/Ownable.sol\";\nimport { EIP712 } from \"../../lib/utils/EIP712.sol\";\nimport { SafeCast } from \"../../lib/utils/SafeCast.sol\";\n\nimport { GovernorStorageV1 } from \"./storage/GovernorStorageV1.sol\";\nimport { Token } from \"../../token/Token.sol\";\nimport { Treasury } from \"../treasury/Treasury.sol\";\nimport { IManager } from \"../../manager/IManager.sol\";\nimport { IGovernor } from \"./IGovernor.sol\";\n\n/// @title Governor\n/// @author Rohan Kulkarni\n/// @notice A DAO's proposal manager and transaction scheduler\n/// Modified from:\n/// - OpenZeppelin Contracts v4.7.3 (governance/extensions/GovernorTimelockControl.sol)\n/// - NounsDAOLogicV1.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\ncontract Governor is IGovernor, UUPS, Ownable, EIP712, GovernorStorageV1 {\n    ///                                                          ///\n    ///                         CONSTANTS                        ///\n    ///                                                          ///\n\n    /// @notice The EIP-712 typehash to vote with a signature\n    bytes32 public constant VOTE_TYPEHASH = keccak256(\"Vote(address voter,uint256 proposalId,uint256 support,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's governor\n    /// @param _treasury The DAO's treasury address\n    /// @param _token The DAO's governance token address\n    /// @param _vetoer The address eligible to veto proposals\n    /// @param _votingDelay The voting delay\n    /// @param _votingPeriod The voting period\n    /// @param _proposalThresholdBps The proposal threshold basis points\n    /// @param _quorumThresholdBps The quorum threshold basis points\n    function initialize(\n        address _treasury,\n        address _token,\n        address _vetoer,\n        uint256 _votingDelay,\n        uint256 _votingPeriod,\n        uint256 _proposalThresholdBps,\n        uint256 _quorumThresholdBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure non-zero addresses are provided\n        if (_treasury == address(0)) revert ADDRESS_ZERO();\n        if (_token == address(0)) revert ADDRESS_ZERO();\n\n        // Store the governor settings\n        settings.treasury = Treasury(payable(_treasury));\n        settings.token = Token(_token);\n        settings.vetoer = _vetoer;\n        settings.votingDelay = SafeCast.toUint48(_votingDelay);\n        settings.votingPeriod = SafeCast.toUint48(_votingPeriod);\n        settings.proposalThresholdBps = SafeCast.toUint16(_proposalThresholdBps);\n        settings.quorumThresholdBps = SafeCast.toUint16(_quorumThresholdBps);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(settings.token.symbol(), \" GOV\"), \"1\");\n\n        // Grant ownership to the treasury\n        __Ownable_init(_treasury);\n    }\n\n    ///                                                          ///\n    ///                         HASH PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Hashes a proposal's details into a proposal id\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function hashProposal(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        bytes32 _descriptionHash\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_targets, _values, _calldatas, _descriptionHash));\n    }\n\n    ///                                                          ///\n    ///                        CREATE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Creates a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _description The proposal description\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (bytes32) {\n        // Get the current proposal threshold\n        uint256 currentProposalThreshold = proposalThreshold();\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller's voting weight is greater than or equal to the threshold\n            if (getVotes(msg.sender, block.timestamp - 1) < proposalThreshold()) revert BELOW_PROPOSAL_THRESHOLD();\n        }\n\n        // Cache the number of targets\n        uint256 numTargets = _targets.length;\n\n        // Ensure at least one target exists\n        if (numTargets == 0) revert PROPOSAL_TARGET_MISSING();\n\n        // Ensure the number of targets matches the number of values and calldata\n        if (numTargets != _values.length) revert PROPOSAL_LENGTH_MISMATCH();\n        if (numTargets != _calldatas.length) revert PROPOSAL_LENGTH_MISMATCH();\n\n        // Compute the description hash\n        bytes32 descriptionHash = keccak256(bytes(_description));\n\n        // Compute the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);\n\n        // Get the pointer to store the proposal\n        Proposal storage proposal = proposals[proposalId];\n\n        // Ensure the proposal doesn't already exist\n        if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId);\n\n        // Used to store the snapshot and deadline\n        uint256 snapshot;\n        uint256 deadline;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the snapshot and deadline\n            snapshot = block.timestamp + settings.votingDelay;\n            deadline = snapshot + settings.votingPeriod;\n        }\n\n        // Store the proposal data\n        proposal.voteStart = uint32(snapshot);\n        proposal.voteEnd = uint32(deadline);\n        proposal.proposalThreshold = uint32(currentProposalThreshold);\n        proposal.quorumVotes = uint32(quorum());\n        proposal.proposer = msg.sender;\n        proposal.timeCreated = uint32(block.timestamp);\n\n        emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                          CAST VOTE                       ///\n    ///                                                          ///\n\n    /// @notice Casts a vote\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    function castVote(bytes32 _proposalId, uint256 _support) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, \"\");\n    }\n\n    /// @notice Casts a vote with a reason\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _reason The vote reason\n    function castVoteWithReason(\n        bytes32 _proposalId,\n        uint256 _support,\n        string memory _reason\n    ) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, _reason);\n    }\n\n    /// @notice Casts a signed vote\n    /// @param _voter The voter address\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function castVoteBySig(\n        address _voter,\n        bytes32 _proposalId,\n        uint256 _support,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256) {\n        // Ensure the deadline has not passed\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the signed digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the message\n            digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(VOTE_TYPEHASH, _voter, _proposalId, _support, nonces[_voter]++, _deadline))\n                )\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the given voter\n        if (recoveredAddress == address(0) || recoveredAddress != _voter) revert INVALID_SIGNATURE();\n\n        return _castVote(_proposalId, _voter, _support, \"\");\n    }\n\n    /// @dev Stores a vote\n    /// @param _proposalId The proposal id\n    /// @param _voter The voter address\n    /// @param _support The vote choice\n    function _castVote(\n        bytes32 _proposalId,\n        address _voter,\n        uint256 _support,\n        string memory _reason\n    ) internal returns (uint256) {\n        // Ensure voting is active\n        if (state(_proposalId) != ProposalState.Active) revert VOTING_NOT_STARTED();\n\n        // Ensure the voter hasn't already voted\n        if (hasVoted[_proposalId][_voter]) revert ALREADY_VOTED();\n\n        // Ensure the vote is valid\n        if (_support > 2) revert INVALID_VOTE();\n\n        // Record the voter as having voted\n        hasVoted[_proposalId][_voter] = true;\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Used to store the voter's weight\n        uint256 weight;\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Get the voter's weight at the time the proposal was created\n            weight = getVotes(_voter, proposal.timeCreated);\n\n            // If the vote is against:\n            if (_support == 0) {\n                // Update the total number of votes against\n                proposal.againstVotes += uint32(weight);\n\n                // Else if the vote is for:\n            } else if (_support == 1) {\n                // Update the total number of votes for\n                proposal.forVotes += uint32(weight);\n\n                // Else if the vote is to abstain:\n            } else if (_support == 2) {\n                // Update the total number of votes abstaining\n                proposal.abstainVotes += uint32(weight);\n            }\n        }\n\n        emit VoteCast(_voter, _proposalId, _support, weight, _reason);\n\n        return weight;\n    }\n\n    ///                                                          ///\n    ///                        QUEUE PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Queues a proposal\n    /// @param _proposalId The proposal id\n    function queue(bytes32 _proposalId) external returns (uint256 eta) {\n        // Ensure the proposal has succeeded\n        if (state(_proposalId) != ProposalState.Succeeded) revert PROPOSAL_UNSUCCESSFUL();\n\n        // Schedule the proposal for execution\n        eta = settings.treasury.queue(_proposalId);\n\n        emit ProposalQueued(_proposalId, eta);\n    }\n\n    ///                                                          ///\n    ///                       EXECUTE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Executes a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function execute(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        bytes[] calldata _calldatas,\n        bytes32 _descriptionHash\n    ) external payable returns (bytes32) {\n        // Get the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, _descriptionHash);\n\n        // Ensure the proposal is queued\n        if (state(proposalId) != ProposalState.Queued) revert PROPOSAL_NOT_QUEUED(proposalId);\n\n        // Mark the proposal as executed\n        proposals[proposalId].executed = true;\n\n        // Execute the proposal\n        settings.treasury.execute{ value: msg.value }(_targets, _values, _calldatas, _descriptionHash);\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                        CANCEL PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Cancels a proposal\n    /// @param _proposalId The proposal id\n    function cancel(bytes32 _proposalId) external {\n        // Ensure the proposal hasn't been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold\n            if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)\n                revert INVALID_CANCEL();\n        }\n\n        // Update the proposal as canceled\n        proposals[_proposalId].canceled = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        VETO PROPOSAL                     ///\n    ///                                                          ///\n\n    /// @notice Vetoes a proposal\n    /// @param _proposalId The proposal id\n    function veto(bytes32 _proposalId) external {\n        // Ensure the caller is the vetoer\n        if (msg.sender != settings.vetoer) revert ONLY_VETOER();\n\n        // Ensure the proposal has not been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Update the proposal as vetoed\n        proposal.vetoed = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        PROPOSAL STATE                    ///\n    ///                                                          ///\n\n    /// @notice The state of a proposal\n    /// @param _proposalId The proposal id\n    function state(bytes32 _proposalId) public view returns (ProposalState) {\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Ensure the proposal exists\n        if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();\n\n        // If the proposal was executed:\n        if (proposal.executed) {\n            return ProposalState.Executed;\n\n            // Else if the proposal was canceled:\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n\n            // Else if the proposal was vetoed:\n        } else if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n\n            // Else if voting has not started:\n        } else if (block.timestamp < proposal.voteStart) {\n            return ProposalState.Pending;\n\n            // Else if voting has not ended:\n        } else if (block.timestamp < proposal.voteEnd) {\n            return ProposalState.Active;\n\n            // Else if the proposal failed (outvoted OR didn't reach quorum):\n        } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n\n            // Else if the proposal has not been queued:\n        } else if (settings.treasury.timestamp(_proposalId) == 0) {\n            return ProposalState.Succeeded;\n\n            // Else if the proposal can no longer be executed:\n        } else if (settings.treasury.isExpired(_proposalId)) {\n            return ProposalState.Expired;\n\n            // Else the proposal is queued\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice The voting weight of an account at a timestamp\n    /// @param _account The account address\n    /// @param _timestamp The specific timestamp\n    function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        return settings.token.getPastVotes(_account, _timestamp);\n    }\n\n    /// @notice The current number of votes required to submit a proposal\n    function proposalThreshold() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.proposalThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The current number of votes required to be in favor of a proposal in order to reach quorum\n    function quorum() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.quorumThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The data stored for a given proposal\n    /// @param _proposalId The proposal id\n    function getProposal(bytes32 _proposalId) external view returns (Proposal memory) {\n        return proposals[_proposalId];\n    }\n\n    /// @notice The timestamp when voting starts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalSnapshot(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteStart;\n    }\n\n    /// @notice The timestamp when voting ends for a proposal\n    /// @param _proposalId The proposal id\n    function proposalDeadline(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteEnd;\n    }\n\n    /// @notice The vote counts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalVotes(bytes32 _proposalId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Proposal memory proposal = proposals[_proposalId];\n\n        return (proposal.againstVotes, proposal.forVotes, proposal.abstainVotes);\n    }\n\n    /// @notice The timestamp valid to execute a proposal\n    /// @param _proposalId The proposal id\n    function proposalEta(bytes32 _proposalId) external view returns (uint256) {\n        return settings.treasury.timestamp(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                      GOVERNOR SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The basis points of the token supply required to create a proposal\n    function proposalThresholdBps() external view returns (uint256) {\n        return settings.proposalThresholdBps;\n    }\n\n    /// @notice The basis points of the token supply required to reach quorum\n    function quorumThresholdBps() external view returns (uint256) {\n        return settings.quorumThresholdBps;\n    }\n\n    /// @notice The amount of time until voting begins after a proposal is created\n    function votingDelay() external view returns (uint256) {\n        return settings.votingDelay;\n    }\n\n    /// @notice The amount of time to vote on a proposal\n    function votingPeriod() external view returns (uint256) {\n        return settings.votingPeriod;\n    }\n\n    /// @notice The address eligible to veto any proposal (address(0) if burned)\n    function vetoer() external view returns (address) {\n        return settings.vetoer;\n    }\n\n    /// @notice The address of the governance token\n    function token() external view returns (address) {\n        return address(settings.token);\n    }\n\n    /// @notice The address of the treasury\n    function treasury() external view returns (address) {\n        return address(settings.treasury);\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the voting delay\n    /// @param _newVotingDelay The new voting delay\n    function updateVotingDelay(uint256 _newVotingDelay) external onlyOwner {\n        emit VotingDelayUpdated(settings.votingDelay, _newVotingDelay);\n\n        settings.votingDelay = SafeCast.toUint48(_newVotingDelay);\n    }\n\n    /// @notice Updates the voting period\n    /// @param _newVotingPeriod The new voting period\n    function updateVotingPeriod(uint256 _newVotingPeriod) external onlyOwner {\n        emit VotingPeriodUpdated(settings.votingPeriod, _newVotingPeriod);\n\n        settings.votingPeriod = SafeCast.toUint48(_newVotingPeriod);\n    }\n\n    /// @notice Updates the minimum proposal threshold\n    /// @param _newProposalThresholdBps The new proposal threshold basis points\n    function updateProposalThresholdBps(uint256 _newProposalThresholdBps) external onlyOwner {\n        emit ProposalThresholdBpsUpdated(settings.proposalThresholdBps, _newProposalThresholdBps);\n\n        settings.proposalThresholdBps = SafeCast.toUint16(_newProposalThresholdBps);\n    }\n\n    /// @notice Updates the minimum quorum threshold\n    /// @param _newQuorumVotesBps The new quorum votes basis points\n    function updateQuorumThresholdBps(uint256 _newQuorumVotesBps) external onlyOwner {\n        emit QuorumVotesBpsUpdated(settings.quorumThresholdBps, _newQuorumVotesBps);\n\n        settings.quorumThresholdBps = SafeCast.toUint16(_newQuorumVotesBps);\n    }\n\n    /// @notice Updates the vetoer\n    /// @param _newVetoer The new vetoer address\n    function updateVetoer(address _newVetoer) external onlyOwner {\n        if (_newVetoer == address(0)) revert ADDRESS_ZERO();\n\n        emit VetoerUpdated(settings.vetoer, _newVetoer);\n\n        settings.vetoer = _newVetoer;\n    }\n\n    /// @notice Burns the vetoer\n    function burnVetoer() external onlyOwner {\n        emit VetoerUpdated(settings.vetoer, address(0));\n\n        delete settings.vetoer;\n    }\n\n    ///                                                          ///\n    ///                       GOVERNOR UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { NounsBuilderTest } from \"./utils/NounsBuilderTest.sol\";\n\ncontract AuctionTest is NounsBuilderTest {\n    address internal bidder1;\n    address internal bidder2;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        bidder1 = vm.addr(0xB1);\n        bidder2 = vm.addr(0xB2);\n\n        vm.deal(bidder1, 100 ether);\n        vm.deal(bidder2, 100 ether);\n\n        deployMock();\n    }\n\n    function test_AuctionHouseInitialized() public {\n        assertEq(auction.owner(), founder);\n\n        assertEq(auction.treasury(), address(treasury));\n        assertEq(auction.duration(), auctionParams.duration);\n        assertEq(auction.reservePrice(), auctionParams.reservePrice);\n        assertEq(auction.timeBuffer(), 5 minutes);\n        assertEq(auction.minBidIncrement(), 10);\n    }\n\n    function testRevert_AlreadyInitialized() public {\n        vm.expectRevert(abi.encodeWithSignature(\"ALREADY_INITIALIZED()\"));\n        auction.initialize(address(token), address(this), address(treasury), 1 minutes, 0 ether);\n    }\n\n    function test_Unpause() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        assertEq(auction.owner(), address(treasury));\n\n        assertEq(token.ownerOf(0), founder);\n        assertEq(token.ownerOf(1), founder2);\n        assertEq(token.ownerOf(2), address(auction));\n\n        (uint256 tokenId, uint256 highestBid, address highestBidder, uint256 startTime, uint256 endTime, bool settled) = auction.auction();\n\n        assertEq(tokenId, 2);\n        assertEq(highestBid, 0);\n        assertEq(highestBidder, address(0));\n        assertEq(startTime, 1);\n        assertEq(endTime, 1 + auctionParams.duration);\n        assertEq(settled, false);\n    }\n\n    function testRevert_OnlyFounderCanUnpause() public {\n        vm.expectRevert(abi.encodeWithSignature(\"ONLY_OWNER()\"));\n        auction.unpause();\n    }\n\n    function test_CreateBid(uint256 _amount) public {\n        vm.assume(_amount >= auction.reservePrice() && _amount <= bidder1.balance);\n\n        vm.prank(founder);\n        auction.unpause();\n\n        uint256 beforeBidderBalance = bidder1.balance;\n        uint256 beforeAuctionBalance = address(auction).balance;\n\n        vm.prank(bidder1);\n        auction.createBid{ value: _amount }(2);\n\n        (, uint256 highestBid, address highestBidder, , , ) = auction.auction();\n\n        assertEq(highestBid, _amount);\n        assertEq(highestBidder, bidder1);\n\n        uint256 afterBidderBalance = bidder1.balance;\n        uint256 afterAuctionBalance = address(auction).balance;\n\n        assertEq(beforeBidderBalance - afterBidderBalance, _amount);\n        assertEq(afterAuctionBalance - beforeAuctionBalance, _amount);\n    }\n\n    function testRevert_InvalidBidTokenId() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        vm.expectRevert(abi.encodeWithSignature(\"INVALID_TOKEN_ID()\"));\n        auction.createBid{ value: 0.420 ether }(3);\n    }\n\n    function testRevert_MustMeetReservePrice() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        vm.expectRevert(abi.encodeWithSignature(\"RESERVE_PRICE_NOT_MET()\"));\n        auction.createBid{ value: 0.0001 ether }(2);\n    }\n\n    function test_CreateSubsequentBid() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        uint256 bidder1BeforeBalance = bidder1.balance;\n        uint256 bidder2BeforeBalance = bidder2.balance;\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.1 ether }(2);\n\n        vm.warp(5 minutes);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 0.5 ether }(2);\n\n        uint256 bidder1AfterBalance = bidder1.balance;\n        uint256 bidder2AfterBalance = bidder2.balance;\n\n        assertEq(bidder1BeforeBalance, bidder1AfterBalance);\n        assertEq(bidder2BeforeBalance - bidder2AfterBalance, 0.5 ether);\n        assertEq(address(auction).balance, 0.5 ether);\n\n        (, uint256 highestBid, address highestBidder, , , ) = auction.auction();\n\n        assertEq(highestBid, 0.5 ether);\n        assertEq(highestBidder, bidder2);\n    }\n\n    function testRevert_MustMeetMinBidIncrement() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.warp(5 minutes);\n\n        vm.prank(bidder2);\n        vm.expectRevert(abi.encodeWithSignature(\"MINIMUM_BID_NOT_MET()\"));\n        auction.createBid{ value: 0.461 ether }(2);\n    }\n\n    function test_ExtendAuction() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.warp(9 minutes);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        (, , , , uint256 endTime, ) = auction.auction();\n\n        assertEq(endTime, 14 minutes);\n    }\n\n    function testRevert_AuctionExpired() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.warp(10 minutes + 1 seconds);\n\n        vm.prank(bidder1);\n        vm.expectRevert(abi.encodeWithSignature(\"AUCTION_OVER()\"));\n        auction.createBid{ value: 0.420 ether }(2);\n    }\n\n    function test_SettleAuction() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        vm.warp(10 minutes + 1 seconds);\n\n        auction.settleCurrentAndCreateNewAuction();\n\n        assertEq(token.ownerOf(2), bidder2);\n        assertEq(token.getVotes(bidder2), 1);\n\n        assertEq(address(treasury).balance, 1 ether);\n    }\n\n    function testRevert_CannotSettleWhenAuctionStillActive() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.warp(5 minutes);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        vm.expectRevert(abi.encodeWithSignature(\"AUCTION_ACTIVE()\"));\n        auction.settleCurrentAndCreateNewAuction();\n    }\n\n    function testRevert_TokenBurnFromNoBids() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        assertEq(token.ownerOf(2), address(auction));\n\n        vm.warp(10 minutes + 1 seconds);\n        auction.settleCurrentAndCreateNewAuction();\n\n        vm.expectRevert(abi.encodeWithSignature(\"INVALID_OWNER()\"));\n        token.ownerOf(2);\n    }\n\n    function test_OnlySettleWhenPaused() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        vm.warp(10 minutes + 1 seconds);\n\n        vm.prank(address(treasury));\n        auction.pause();\n\n        auction.settleAuction();\n\n        (, , , , , bool settled) = auction.auction();\n\n        assertEq(settled, true);\n    }\n\n    function testRevert_CannotOnlySettleWhenNotPaused() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        vm.warp(10 minutes + 1 seconds);\n\n        vm.expectRevert(abi.encodeWithSignature(\"UNPAUSED()\"));\n        auction.settleAuction();\n    }\n}\n\n\n",
        "CodeNames": [
            "Governor.sol",
            "Auction.sol",
            "Auction.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Governor.sol, Auction.sol",
                "Type": "Changing treasury owner through transferOwnership() can break Governor.sol and Auction.sol",
                "Description": "If ownership is transferred through transferOwnership() in Governor.sol or Auction.sol, it causes an inconsistency between the owner of these contracts and settings.treasury which would prevent governance from ever modifying its own parameters and Ethereum from auctions will be sent to the wrong address.",
                "Repair": "Modify transferOwnership() in the relevant contracts so that if ownership is transferred, then settings.treasury is changed accordingly."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { NounsBuilderTest } from \"./utils/NounsBuilderTest.sol\";\n\ncontract AuctionTest is NounsBuilderTest {\n    address internal bidder1;\n    address internal bidder2;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        bidder1 = vm.addr(0xB1);\n        bidder2 = vm.addr(0xB2);\n\n        vm.deal(bidder1, 100 ether);\n        vm.deal(bidder2, 100 ether);\n\n        deployMock();\n    }\n\n    function test_AuctionHouseInitialized() public {\n        assertEq(auction.owner(), founder);\n\n        assertEq(auction.treasury(), address(treasury));\n        assertEq(auction.duration(), auctionParams.duration);\n        assertEq(auction.reservePrice(), auctionParams.reservePrice);\n        assertEq(auction.timeBuffer(), 5 minutes);\n        assertEq(auction.minBidIncrement(), 10);\n    }\n\n    function testRevert_AlreadyInitialized() public {\n        vm.expectRevert(abi.encodeWithSignature(\"ALREADY_INITIALIZED()\"));\n        auction.initialize(address(token), address(this), address(treasury), 1 minutes, 0 ether);\n    }\n\n    function test_Unpause() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        assertEq(auction.owner(), address(treasury));\n\n        assertEq(token.ownerOf(0), founder);\n        assertEq(token.ownerOf(1), founder2);\n        assertEq(token.ownerOf(2), address(auction));\n\n        (uint256 tokenId, uint256 highestBid, address highestBidder, uint256 startTime, uint256 endTime, bool settled) = auction.auction();\n\n        assertEq(tokenId, 2);\n        assertEq(highestBid, 0);\n        assertEq(highestBidder, address(0));\n        assertEq(startTime, 1);\n        assertEq(endTime, 1 + auctionParams.duration);\n        assertEq(settled, false);\n    }\n\n    function testRevert_OnlyFounderCanUnpause() public {\n        vm.expectRevert(abi.encodeWithSignature(\"ONLY_OWNER()\"));\n        auction.unpause();\n    }\n\n    function test_CreateBid(uint256 _amount) public {\n        vm.assume(_amount >= auction.reservePrice() && _amount <= bidder1.balance);\n\n        vm.prank(founder);\n        auction.unpause();\n\n        uint256 beforeBidderBalance = bidder1.balance;\n        uint256 beforeAuctionBalance = address(auction).balance;\n\n        vm.prank(bidder1);\n        auction.createBid{ value: _amount }(2);\n\n        (, uint256 highestBid, address highestBidder, , , ) = auction.auction();\n\n        assertEq(highestBid, _amount);\n        assertEq(highestBidder, bidder1);\n\n        uint256 afterBidderBalance = bidder1.balance;\n        uint256 afterAuctionBalance = address(auction).balance;\n\n        assertEq(beforeBidderBalance - afterBidderBalance, _amount);\n        assertEq(afterAuctionBalance - beforeAuctionBalance, _amount);\n    }\n\n    function testRevert_InvalidBidTokenId() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        vm.expectRevert(abi.encodeWithSignature(\"INVALID_TOKEN_ID()\"));\n        auction.createBid{ value: 0.420 ether }(3);\n    }\n\n    function testRevert_MustMeetReservePrice() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        vm.expectRevert(abi.encodeWithSignature(\"RESERVE_PRICE_NOT_MET()\"));\n        auction.createBid{ value: 0.0001 ether }(2);\n    }\n\n    function test_CreateSubsequentBid() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        uint256 bidder1BeforeBalance = bidder1.balance;\n        uint256 bidder2BeforeBalance = bidder2.balance;\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.1 ether }(2);\n\n        vm.warp(5 minutes);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 0.5 ether }(2);\n\n        uint256 bidder1AfterBalance = bidder1.balance;\n        uint256 bidder2AfterBalance = bidder2.balance;\n\n        assertEq(bidder1BeforeBalance, bidder1AfterBalance);\n        assertEq(bidder2BeforeBalance - bidder2AfterBalance, 0.5 ether);\n        assertEq(address(auction).balance, 0.5 ether);\n\n        (, uint256 highestBid, address highestBidder, , , ) = auction.auction();\n\n        assertEq(highestBid, 0.5 ether);\n        assertEq(highestBidder, bidder2);\n    }\n\n    function testRevert_MustMeetMinBidIncrement() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.warp(5 minutes);\n\n        vm.prank(bidder2);\n        vm.expectRevert(abi.encodeWithSignature(\"MINIMUM_BID_NOT_MET()\"));\n        auction.createBid{ value: 0.461 ether }(2);\n    }\n\n    function test_ExtendAuction() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.warp(9 minutes);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        (, , , , uint256 endTime, ) = auction.auction();\n\n        assertEq(endTime, 14 minutes);\n    }\n\n    function testRevert_AuctionExpired() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.warp(10 minutes + 1 seconds);\n\n        vm.prank(bidder1);\n        vm.expectRevert(abi.encodeWithSignature(\"AUCTION_OVER()\"));\n        auction.createBid{ value: 0.420 ether }(2);\n    }\n\n    function test_SettleAuction() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        vm.warp(10 minutes + 1 seconds);\n\n        auction.settleCurrentAndCreateNewAuction();\n\n        assertEq(token.ownerOf(2), bidder2);\n        assertEq(token.getVotes(bidder2), 1);\n\n        assertEq(address(treasury).balance, 1 ether);\n    }\n\n    function testRevert_CannotSettleWhenAuctionStillActive() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.warp(5 minutes);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        vm.expectRevert(abi.encodeWithSignature(\"AUCTION_ACTIVE()\"));\n        auction.settleCurrentAndCreateNewAuction();\n    }\n\n    function testRevert_TokenBurnFromNoBids() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        assertEq(token.ownerOf(2), address(auction));\n\n        vm.warp(10 minutes + 1 seconds);\n        auction.settleCurrentAndCreateNewAuction();\n\n        vm.expectRevert(abi.encodeWithSignature(\"INVALID_OWNER()\"));\n        token.ownerOf(2);\n    }\n\n    function test_OnlySettleWhenPaused() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        vm.warp(10 minutes + 1 seconds);\n\n        vm.prank(address(treasury));\n        auction.pause();\n\n        auction.settleAuction();\n\n        (, , , , , bool settled) = auction.auction();\n\n        assertEq(settled, true);\n    }\n\n    function testRevert_CannotOnlySettleWhenNotPaused() public {\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(2);\n\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(2);\n\n        vm.warp(10 minutes + 1 seconds);\n\n        vm.expectRevert(abi.encodeWithSignature(\"UNPAUSED()\"));\n        auction.settleAuction();\n    }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol",
            "Auction.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Auction.sol",
                "Type": "Malicious pausing the contract",
                "Description": "Contract can be paused by any user by passing special amount of gas for the call of settleCurrentAndCreateNewAuction (which consists of two internal calls of _settleAuction and _createAuction functions).",
                "Repair": "Add a special check for upper bound of gasLeft at start of _createAuction function."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\n\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IToken } from \"./IToken.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, UUPS, ReentrancyGuard, ERC721Votes, TokenStorageV1 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _founders The DAO founders\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        address _metadataRenderer,\n        address _auction\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , ) = abi.decode(_initStrings, (string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n    }\n\n    /// @dev Called upon initialization to add founders and compute their vesting allocations\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders) internal {\n        // Cache the number of founders\n        uint256 numFounders = _founders.length;\n\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < numFounders; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) continue;\n\n                // Update the total ownership and ensure it's valid\n                if ((totalOwnership += uint8(founderPct)) > 100) revert INVALID_FOUNDER_OWNERSHIP();\n\n                // Compute the founder's id\n                uint256 founderId = settings.numFounders++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    (baseTokenId += schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = uint8(numFounders);\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) ++_tokenId;\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the auction house for bidding and handles founder vesting\n    function mint() external nonReentrant returns (uint256 tokenId) {\n        // Cache the auction address\n        address minter = settings.auction;\n\n        // Ensure the caller is the auction\n        if (msg.sender != minter) revert ONLY_AUCTION();\n\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = settings.totalSupply++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the auction house for bidding\n        _mint(minter, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token that did not see any bids\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external {\n        // Ensure the caller is the auction house\n        if (msg.sender != settings.auction) revert ONLY_AUCTION();\n\n        // Burn the token\n        _burn(_tokenId);\n    }\n\n    ///                                                          ///\n    ///                           METADATA                       ///\n    ///                                                          ///\n\n    /// @notice The URI for a token\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.tokenURI(_tokenId);\n    }\n\n    /// @notice The URI for the contract\n    function contractURI() public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.contractURI();\n    }\n\n    ///                                                          ///\n    ///                           FOUNDERS                       ///\n    ///                                                          ///\n\n    /// @notice The number of founders\n    function totalFounders() external view returns (uint256) {\n        return settings.numFounders;\n    }\n\n    /// @notice The founders total percent ownership\n    function totalFounderOwnership() external view returns (uint256) {\n        return settings.totalOwnership;\n    }\n\n    /// @notice The vesting details of a founder\n    /// @param _founderId The founder id\n    function getFounder(uint256 _founderId) external view returns (Founder memory) {\n        return founder[_founderId];\n    }\n\n    /// @notice The vesting details of all founders\n    function getFounders() external view returns (Founder[] memory) {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory founders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) founders[i] = founder[i];\n        }\n\n        return founders;\n    }\n\n    /// @notice The founder scheduled to receive the given token id\n    /// NOTE: If a founder is returned, there's no guarantee they'll receive the token as vesting expiration is not considered\n    /// @param _tokenId The ERC-721 token id\n    function getScheduledRecipient(uint256 _tokenId) external view returns (Founder memory) {\n        return tokenRecipient[_tokenId % 100];\n    }\n\n    ///                                                          ///\n    ///                           SETTINGS                       ///\n    ///                                                          ///\n\n    /// @notice The total supply of tokens\n    function totalSupply() external view returns (uint256) {\n        return settings.totalSupply;\n    }\n\n    /// @notice The address of the auction house\n    function auction() external view returns (address) {\n        return settings.auction;\n    }\n\n    /// @notice The address of the metadata renderer\n    function metadataRenderer() external view returns (address) {\n        return address(settings.metadataRenderer);\n    }\n\n    /// @notice The address of the owner\n    function owner() public view returns (address) {\n        return settings.metadataRenderer.owner();\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override {\n        // Ensure the caller is the shared owner of the token and metadata renderer\n        if (msg.sender != owner()) revert ONLY_OWNER();\n\n        // Ensure the implementation is valid\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "CodeNames": [
            "Token.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Token.sol#L118",
                "Type": "Token ID computation error",
                "Description": "The IDs of the founders tokens are wrongly computed, some of them can have an id higher than 100 and then never be minted.",
                "Repair": "Replace the line 118 of Token.sol by baseTokenId = (baseTokenId + schedule) % 100;"
            },
            {
                "Location": "Token.sol#L110",
                "Type": "Token distribution vulnerability",
                "Description": "The actual percentages of tokens that the founders receive deviate significantly from the desired percentages due to the 'greedy' minting scheme for founders.",
                "Repair": "Mint the tokens for the founders every 100 tokens, i.e. everytime when tokenId % 100 == 0. Like that, it is ensured that the actual percentages are equal to the desired percentages."
            },
            {
                "Location": "Token.sol#L179",
                "Type": "Infinite loop",
                "Description": "If the sum of ownershipPct is 100, the Token and Auction cannot be used as the while loop in the mint function will not stop.",
                "Repair": "Use _tokenId instead of baseTokenId"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super._afterTokenTransfer(_from, _to, _tokenId);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC721Votes.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ERC721Votes.sol#L179-L190",
                "Type": "Delegation to address(0)",
                "Description": "If a user delegates to address(0) that vote gets lost.",
                "Repair": "Don't allow delegation to address(0) by adding a check or if someone tries to delegate to address(0), delegate to the NFT owner instead"
            },
            {
                "Location": "ERC721Votes contract",
                "Type": "Delegation Mechanism",
                "Description": "Token owners can double their voting power once by delegating to their own address as their first delegation, due to the initial default value of the delegation mapping in ERC721Votes being set to address(0). This can be exploited by malicious token owners to accrue more voting power than they deserve.",
                "Repair": "Make the delegates function public rather than external and call this function rather than accessing the delegation mapping directly"
            },
            {
                "Location": "ERC721Votes.sol",
                "Type": "Delegation vulnerability",
                "Description": "NFT owner can block token burning and transfer by delegating to zero address.",
                "Repair": "Prohibit zero address as a delegation destination"
            },
            {
                "Location": "ERC721Votes.sol",
                "Type": "Delegation disables NFT transfers and burning",
                "Description": "If Alice the NFT owner first delegates her votes to herself, second delegates to anyone else with delegate() or delegateBySig() then all her NFT ids will become stuck: their transfers and burning will be disabled.",
                "Repair": "Include delegates() call as a fix"
            },
            {
                "Location": "ERC721Votes.getPastVotes(..) function",
                "Type": "Incorrect vote accounting",
                "Description": "Multiple vote checkpoints per block will lead to incorrect vote accounting.",
                "Repair": "Batch multiple checkpoints writes per block/timestamp"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function _afterTokenTransfer(address _from, address _to, uint256 _tokenId) internal override",
                "Type": "Unchecked operation",
                "Description": "User can get unlimited votes by causing overflow in _moveDelegates during delegation.",
                "Repair": "Change delegate transfer in afterTokenTransfer to _moveDelegateVotes(delegates(_from), delegates(_to), 1)"
            },
            {
                "Location": "function burn(uint256 tokenId)",
                "Type": "Incorrect accounting",
                "Description": "Owners receive more percentage of total nft if some nfts were burned (because were not sold).",
                "Repair": "Decrement settings.totalSupply value when burn function is called."
            },
            {
                "Location": "function propose(address[] memory _targets, uint256[] memory _values, bytes[] memory _calldatas, string memory _description) external returns (bytes32)",
                "Type": "Front-running",
                "Description": "Creating a new governance proposal can be prevented by anyone by front-running the create proposal transaction with the same data, followed by an immediate call to the Governor.cancel function.",
                "Repair": "Add a per-account nonce storage variable (e.g. mapping(address = uint256) internal proposalCreatorNonces;) to the Governor contract and include the proposalCreatorNonces[msg.sender]++ nonce within the computed proposal id."
            },
            {
                "Location": "_transferFrom() function",
                "Type": "Indefinite increase in voting power",
                "Description": "Creating new accounts and delegating can lead to indefinite increase in voting power.",
                "Repair": "Move delegates from the source's delegates to the destination's delegates instead of moving directly from source to destination"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni\n/// @notice A DAO's auction house\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _weth The address of WETH\n    constructor(address _manager, address _weth) payable initializer {\n        manager = IManager(_manager);\n        WETH = _weth;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = 5 minutes;\n        settings.minBidIncrement = 10;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the bid is for the current token\n        if (_auction.tokenId != _tokenId) revert INVALID_TOKEN_ID();\n\n        // Ensure the auction is still active\n        if (block.timestamp >= _auction.endTime) revert AUCTION_OVER();\n\n        // Cache the address of the highest bidder\n        address highestBidder = _auction.highestBidder;\n\n        // If this is the first bid:\n        if (highestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msg.value < settings.reservePrice) revert RESERVE_PRICE_NOT_MET();\n\n            // Else this is a subsequent bid:\n        } else {\n            // Cache the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(highestBidder, highestBid);\n        }\n\n        // Store the new highest bid\n        auction.highestBid = msg.value;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store if the auction will be extended\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (_auction.endTime - block.timestamp) < settings.timeBuffer;\n        }\n\n        // If the time remaining is within the buffer:\n        if (extend) {\n            // Cannot realistically overflow\n            unchecked {\n                // Extend the auction by the time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msg.value, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Transfer it to the DAO treasury\n            if (highestBid != 0) _handleOutgoingTransfer(settings.treasury, highestBid);\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n\n            // Pause the contract if token minting failed\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (auction.tokenId == 0) {\n            // Transfer ownership of the contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Start the first auction\n            _createAuction();\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            IWETH(WETH).transfer(_to, _amount);\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Auction.sol#L307-L335",
                "Type": "changing auction parameters during ongoing auction",
                "Description": "Auction parameters can be changed anytime, even during ongoing auctions, and take effect immediately. Users may need time to react to the changes.",
                "Repair": "Do not apply changed parameters on ongoing auctions. Add a timelock for the changes"
            },
            {
                "Location": "Auction.sol#L248-L254",
                "Type": "Irretrievable stuck bid and NFT",
                "Description": "If the first auction is paused and unpaused in a protocol deployed with no founder fees, the highest bid (as well as the first NFT), will get stuck in the protocol with no ability to retrieve either of them.",
                "Repair": "Force settle if a bid was there or handle token0 like any other. Mint the first token to a founder or settle before unpausing to avoid the issue."
            },
            {
                "Location": "Auction.sol#L234",
                "Type": "Catch block issue",
                "Description": "The try-catch block in the _createAuction function will only catch reverts that come from the require keyword and not the reverts with custom errors or other kinds of errors.",
                "Repair": "Remove the Error so that it'll catch any kind of revert"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { NounsBuilderTest } from \"./utils/NounsBuilderTest.sol\";\n\nimport { IManager, Manager } from \"../src/manager/Manager.sol\";\nimport { IToken, Token } from \"../src/token/Token.sol\";\n\nimport { MetadataRendererTypesV1 } from \"../src/token/metadata/types/MetadataRendererTypesV1.sol\";\n\nimport { TokenTypesV1 } from \"../src/token/types/TokenTypesV1.sol\";\n\ncontract TokenTest is NounsBuilderTest, TokenTypesV1 {\n    function setUp() public virtual override {\n        super.setUp();\n    }\n\n    function deployWithCustomFounders(\n        address[] memory _wallets,\n        uint256[] memory _percents,\n        uint256[] memory _vestExpirys\n    ) internal virtual {\n        setFounderParams(_wallets, _percents, _vestExpirys);\n\n        setMockTokenParams();\n\n        setMockAuctionParams();\n\n        setMockGovParams();\n\n        deploy(foundersArr, tokenParams, auctionParams, govParams);\n    }\n\n    function test_MockTokenInit() public {\n        deployMock();\n\n        assertEq(token.name(), \"Mock Token\");\n        assertEq(token.symbol(), \"MOCK\");\n        assertEq(token.auction(), address(auction));\n        assertEq(token.owner(), founder);\n        assertEq(token.metadataRenderer(), address(metadataRenderer));\n        assertEq(token.totalSupply(), 0);\n    }\n\n    function test_MockFounders() public {\n        deployMock();\n\n        assertEq(token.totalFounders(), 2);\n        assertEq(token.totalFounderOwnership(), 15);\n\n        Founder[] memory fdrs = token.getFounders();\n\n        assertEq(fdrs.length, 2);\n\n        Founder memory fdr1 = fdrs[0];\n        Founder memory fdr2 = fdrs[1];\n\n        assertEq(fdr1.wallet, foundersArr[0].wallet);\n        assertEq(fdr1.ownershipPct, foundersArr[0].ownershipPct);\n        assertEq(fdr1.vestExpiry, foundersArr[0].vestExpiry);\n\n        assertEq(fdr2.wallet, foundersArr[1].wallet);\n        assertEq(fdr2.ownershipPct, foundersArr[1].ownershipPct);\n        assertEq(fdr2.vestExpiry, foundersArr[1].vestExpiry);\n    }\n\n    function test_MockAuctionUnpause() public {\n        deployMock();\n\n        vm.prank(founder);\n        auction.unpause();\n\n        assertEq(token.totalSupply(), 3);\n\n        assertEq(token.ownerOf(0), founder);\n        assertEq(token.ownerOf(1), founder2);\n        assertEq(token.ownerOf(2), address(auction));\n\n        assertEq(token.balanceOf(founder), 1);\n        assertEq(token.balanceOf(founder2), 1);\n        assertEq(token.balanceOf(address(auction)), 1);\n\n        assertEq(token.getVotes(founder), 1);\n        assertEq(token.getVotes(founder2), 1);\n        assertEq(token.getVotes(address(auction)), 1);\n    }\n\n    function test_MaxOwnership100Founders() public {\n        createUsers(100, 1 ether);\n\n        address[] memory wallets = new address[](100);\n        uint256[] memory percents = new uint256[](100);\n        uint256[] memory vestExpirys = new uint256[](100);\n\n        uint256 pct = 1;\n        uint256 end = 4 weeks;\n\n        unchecked {\n            for (uint256 i; i < 100; ++i) {\n                wallets[i] = otherUsers[i];\n                percents[i] = pct;\n                vestExpirys[i] = end;\n            }\n        }\n\n        deployWithCustomFounders(wallets, percents, vestExpirys);\n\n        assertEq(token.totalFounders(), 100);\n        assertEq(token.totalFounderOwnership(), 100);\n\n        Founder memory founder;\n\n        for (uint256 i; i < 100; ++i) {\n            founder = token.getScheduledRecipient(i);\n\n            assertEq(founder.wallet, otherUsers[i]);\n        }\n    }\n\n    function test_MaxOwnership50Founders() public {\n        createUsers(50, 1 ether);\n\n        address[] memory wallets = new address[](50);\n        uint256[] memory percents = new uint256[](50);\n        uint256[] memory vestExpirys = new uint256[](50);\n\n        uint256 pct = 2;\n        uint256 end = 4 weeks;\n\n        unchecked {\n            for (uint256 i; i < 50; ++i) {\n                wallets[i] = otherUsers[i];\n                percents[i] = pct;\n                vestExpirys[i] = end;\n            }\n        }\n\n        deployWithCustomFounders(wallets, percents, vestExpirys);\n\n        assertEq(token.totalFounders(), 50);\n        assertEq(token.totalFounderOwnership(), 100);\n\n        Founder memory founder;\n\n        for (uint256 i; i < 50; ++i) {\n            founder = token.getScheduledRecipient(i);\n\n            assertEq(founder.wallet, otherUsers[i]);\n\n            founder = token.getScheduledRecipient(i + 50);\n\n            assertEq(founder.wallet, otherUsers[i]);\n        }\n    }\n\n    function test_MaxOwnership2Founders() public {\n        createUsers(2, 1 ether);\n\n        address[] memory wallets = new address[](2);\n        uint256[] memory percents = new uint256[](2);\n        uint256[] memory vestExpirys = new uint256[](2);\n\n        uint256 pct = 50;\n        uint256 end = 4 weeks;\n\n        unchecked {\n            for (uint256 i; i < 2; ++i) {\n                wallets[i] = otherUsers[i];\n                percents[i] = pct;\n                vestExpirys[i] = end;\n            }\n        }\n\n        deployWithCustomFounders(wallets, percents, vestExpirys);\n\n        assertEq(token.totalFounders(), 2);\n        assertEq(token.totalFounderOwnership(), 100);\n\n        Founder memory founder;\n\n        unchecked {\n            for (uint256 i; i < 500; ++i) {\n                founder = token.getScheduledRecipient(i);\n\n                if (i % 2 == 0) assertEq(founder.wallet, otherUsers[0]);\n                else assertEq(founder.wallet, otherUsers[1]);\n            }\n        }\n    }\n\n    function testRevert_OnlyAuctionCanMint() public {\n        deployMock();\n\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.expectRevert(abi.encodeWithSignature(\"ONLY_AUCTION()\"));\n        token.mint();\n    }\n\n    function testRevert_OnlyAuctionCanBurn() public {\n        deployMock();\n\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.expectRevert(abi.encodeWithSignature(\"ONLY_AUCTION()\"));\n        token.burn(1);\n    }\n\n    function testRevert_OnlyDAOCanUpgrade() public {\n        deployMock();\n\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.expectRevert(abi.encodeWithSignature(\"ONLY_OWNER()\"));\n        token.upgradeTo(address(this));\n    }\n\n    function testRevert_OnlyDAOCanUpgradeToAndCall() public {\n        deployMock();\n\n        vm.prank(founder);\n        auction.unpause();\n\n        vm.expectRevert(abi.encodeWithSignature(\"ONLY_OWNER()\"));\n        token.upgradeToAndCall(address(this), \"\");\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\n\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IToken } from \"./IToken.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, UUPS, ReentrancyGuard, ERC721Votes, TokenStorageV1 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _founders The DAO founders\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        address _metadataRenderer,\n        address _auction\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , ) = abi.decode(_initStrings, (string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n    }\n\n    /// @dev Called upon initialization to add founders and compute their vesting allocations\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders) internal {\n        // Cache the number of founders\n        uint256 numFounders = _founders.length;\n\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < numFounders; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) continue;\n\n                // Update the total ownership and ensure it's valid\n                if ((totalOwnership += uint8(founderPct)) > 100) revert INVALID_FOUNDER_OWNERSHIP();\n\n                // Compute the founder's id\n                uint256 founderId = settings.numFounders++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    (baseTokenId += schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = uint8(numFounders);\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) ++_tokenId;\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the auction house for bidding and handles founder vesting\n    function mint() external nonReentrant returns (uint256 tokenId) {\n        // Cache the auction address\n        address minter = settings.auction;\n\n        // Ensure the caller is the auction\n        if (msg.sender != minter) revert ONLY_AUCTION();\n\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = settings.totalSupply++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the auction house for bidding\n        _mint(minter, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token that did not see any bids\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external {\n        // Ensure the caller is the auction house\n        if (msg.sender != settings.auction) revert ONLY_AUCTION();\n\n        // Burn the token\n        _burn(_tokenId);\n    }\n\n    ///                                                          ///\n    ///                           METADATA                       ///\n    ///                                                          ///\n\n    /// @notice The URI for a token\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.tokenURI(_tokenId);\n    }\n\n    /// @notice The URI for the contract\n    function contractURI() public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.contractURI();\n    }\n\n    ///                                                          ///\n    ///                           FOUNDERS                       ///\n    ///                                                          ///\n\n    /// @notice The number of founders\n    function totalFounders() external view returns (uint256) {\n        return settings.numFounders;\n    }\n\n    /// @notice The founders total percent ownership\n    function totalFounderOwnership() external view returns (uint256) {\n        return settings.totalOwnership;\n    }\n\n    /// @notice The vesting details of a founder\n    /// @param _founderId The founder id\n    function getFounder(uint256 _founderId) external view returns (Founder memory) {\n        return founder[_founderId];\n    }\n\n    /// @notice The vesting details of all founders\n    function getFounders() external view returns (Founder[] memory) {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory founders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) founders[i] = founder[i];\n        }\n\n        return founders;\n    }\n\n    /// @notice The founder scheduled to receive the given token id\n    /// NOTE: If a founder is returned, there's no guarantee they'll receive the token as vesting expiration is not considered\n    /// @param _tokenId The ERC-721 token id\n    function getScheduledRecipient(uint256 _tokenId) external view returns (Founder memory) {\n        return tokenRecipient[_tokenId % 100];\n    }\n\n    ///                                                          ///\n    ///                           SETTINGS                       ///\n    ///                                                          ///\n\n    /// @notice The total supply of tokens\n    function totalSupply() external view returns (uint256) {\n        return settings.totalSupply;\n    }\n\n    /// @notice The address of the auction house\n    function auction() external view returns (address) {\n        return settings.auction;\n    }\n\n    /// @notice The address of the metadata renderer\n    function metadataRenderer() external view returns (address) {\n        return address(settings.metadataRenderer);\n    }\n\n    /// @notice The address of the owner\n    function owner() public view returns (address) {\n        return settings.metadataRenderer.owner();\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override {\n        // Ensure the caller is the shared owner of the token and metadata renderer\n        if (msg.sender != owner()) revert ONLY_OWNER();\n\n        // Ensure the implementation is valid\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "CodeNames": [
            "Token.t.sol",
            "Token.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "initialize function of the Token contract",
                "Type": "Truncation",
                "Description": "Truncation in casting can lead to a founder receiving all the base tokens",
                "Repair": "Don't truncate the founderPct variable to a uint8 when adding it to the totalOwnership variable, or alternatively check that it is less than type(uint8).max (or less or equal to 100)"
            }
        ]
    }
]