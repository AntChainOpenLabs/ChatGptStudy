[
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.6.12;\n\nimport \"../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./ICore.sol\";\n\n/*\n    Wrapped Interest-Bearing Bitcoin (Ethereum mainnet variant)\n*/\ncontract WrappedIbbtcEth is Initializable, ERC20Upgradeable {\n    address public governance;\n    address public pendingGovernance;\n    ERC20Upgradeable public ibbtc; \n    \n    ICore public core;\n\n    uint256 public pricePerShare;\n    uint256 public lastPricePerShareUpdate;\n\n    event SetCore(address core);\n    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);\n    event SetPendingGovernance(address pendingGovernance);\n    event AcceptPendingGovernance(address pendingGovernance);\n\n    /// ===== Modifiers =====\n    modifier onlyPendingGovernance() {\n        require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"onlyGovernance\");\n        _;\n    }\n\n    function initialize(address _governance, address _ibbtc, address _core) public initializer {\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n        governance = _governance;\n        core = ICore(_core);\n        ibbtc = ERC20Upgradeable(_ibbtc);\n\n        updatePricePerShare();\n\n        emit SetCore(_core);\n    }\n\n    /// ===== Permissioned: Governance =====\n    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {\n        pendingGovernance = _pendingGovernance;\n        emit SetPendingGovernance(pendingGovernance);\n    }\n\n    /// @dev The ibBTC token is technically capable of having it's Core contract changed via governance process. This allows the wrapper to adapt.\n    /// @dev This function should be run atomically with setCore() on ibBTC if that eventuality ever arises.\n    function setCore(address _core) external onlyGovernance {\n        core = ICore(_core);\n        emit SetCore(_core);\n    }\n\n    /// ===== Permissioned: Pending Governance =====\n    function acceptPendingGovernance() external onlyPendingGovernance {\n        governance = pendingGovernance;\n        emit AcceptPendingGovernance(pendingGovernance);\n    }\n\n    /// ===== Permissionless Calls =====\n\n    /// @dev Update live ibBTC price per share from core\n    /// @dev We cache this to reduce gas costs of mint / burn / transfer operations.\n    /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date\n    function updatePricePerShare() public virtual returns (uint256) {\n        pricePerShare = core.pricePerShare();\n        lastPricePerShareUpdate = now;\n\n        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);\n    }\n\n    /// @dev Deposit ibBTC to mint wibBTC shares\n    function mint(uint256 _shares) external {\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n        _mint(_msgSender(), _shares);\n    }\n\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n    function burn(uint256 _shares) external {\n        _burn(_msgSender(), _shares);\n        require(ibbtc.transfer(_msgSender(), _shares));\n    }\n\n    /// ===== Transfer Overrides =====\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\n    /// ===== View Methods =====\n\n    /// @dev Wrapped ibBTC shares of account\n    function sharesOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @dev Current account shares * pricePerShare\n    function balanceOf(address account) public view override returns (uint256) {\n        return sharesOf(account).mul(pricePerShare).div(1e18);\n    }\n\n    /// @dev Total wrapped ibBTC shares\n    function totalShares() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev Current total shares * pricePerShare\n    function totalSupply() public view override returns (uint256) {\n        return totalShares().mul(pricePerShare).div(1e18);\n    }\n\n    function balanceToShares(uint256 balance) public view returns (uint256) {\n        return balance.mul(1e18).div(pricePerShare);\n    }\n\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\n        return shares.mul(pricePerShare).div(1e18);\n    }\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.6.12;\n\nimport \"../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./ICoreOracle.sol\";\n\n/*\n    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)\n*/\ncontract WrappedIbbtc is Initializable, ERC20Upgradeable {\n    address public governance;\n    address public pendingGovernance;\n    ERC20Upgradeable public ibbtc; \n\n    ICoreOracle public oracle;\n\n    event SetOracle(address oracle);\n    event SetPendingGovernance(address pendingGovernance);\n    event AcceptPendingGovernance(address pendingGovernance);\n\n    /// ===== Modifiers =====\n    modifier onlyPendingGovernance() {\n        require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"onlyGovernance\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == address(oracle), \"onlyOracle\");\n        _;\n    }\n\n    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n        governance = _governance;\n        oracle = ICoreOracle(_oracle);\n        ibbtc = ERC20Upgradeable(_ibbtc);\n\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Governance =====\n    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {\n        pendingGovernance = _pendingGovernance;\n        emit SetPendingGovernance(pendingGovernance);\n    }\n\n    function setOracle(address _oracle) external onlyGovernance {\n        oracle = ICoreOracle(_oracle);\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Pending Governance =====\n    function acceptPendingGovernance() external onlyPendingGovernance {\n        governance = pendingGovernance;\n        emit AcceptPendingGovernance(pendingGovernance);\n    }\n\n    /// ===== Permissionless Calls =====\n\n    /// @dev Deposit ibBTC to mint wibBTC shares\n    function mint(uint256 _shares) external {\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n        _mint(_msgSender(), _shares);\n    }\n\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n    function burn(uint256 _shares) external {\n        _burn(_msgSender(), _shares);\n        require(ibbtc.transfer(_msgSender(), _shares));\n    }\n\n    /// ===== Transfer Overrides =====\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\n    /// ===== View Methods =====\n\n    /// @dev Current pricePerShare read live from oracle\n    function pricePerShare() public view virtual returns (uint256) {\n        return oracle.pricePerShare();\n    }\n\n    /// @dev Wrapped ibBTC shares of account\n    function sharesOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @dev Current account shares * pricePerShare\n    function balanceOf(address account) public view override returns (uint256) {\n        return sharesOf(account).mul(pricePerShare()).div(1e18);\n    }\n\n    /// @dev Total wrapped ibBTC shares\n    function totalShares() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev Current total shares * pricePerShare\n    function totalSupply() public view override returns (uint256) {\n        return totalShares().mul(pricePerShare()).div(1e18);\n    }\n\n    function balanceToShares(uint256 balance) public view returns (uint256) {\n        return balance.mul(1e18).div(pricePerShare());\n    }\n\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\n        return shares.mul(pricePerShare()).div(1e18);\n    }\n}\n\n\n",
        "CodeNames": [
            "WrappedIbbtcEth.sol",
            "WrappedIbbtc.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "WrappedIbbtc and WrappedIbbtcEth contracts",
                "Type": "Smart Contract Vulnerability",
                "Description": "The smart contract vulnerabilities include not filtering out price feed outliers, no sanity check on pricePerShare which might lead to lost value, using stalled price for mint/burn if updatePricePerShare wasn't run properly, hard to clear balance, and null check in pricePerShare.",
                "Repair": "Introduce a minting/burning query that runs on a schedule, separating user funds contribution and actual mint/burn. Add a sanity check to ensure that on every update, the price is greater than 0. Add a null check to ensure that on every update, the price is greater than 0. Introduce a threshold variable for maximum time elapsed since last price update to WrappedIbbtcEth contract. Add a transferShares function beside the original transfer() to build a better UX."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "wibBTC contract",
                "Type": "Design flaw",
                "Description": "The design of wibBTC is not fully compatible with the current Curve StableSwap pool.",
                "Repair": "Create a revised version of the Curve StableSwap contract that can handle dynamic balances properly"
            },
            {
                "Location": "approve and transferFrom functions",
                "Type": "Authorization flaw",
                "Description": "The approved spender may spend more tokens than desired.",
                "Repair": "Track the rebalanced amounts in the _allowances field and subtract the transferred amount in transferFrom"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.6.12;\n\nimport \"../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./ICoreOracle.sol\";\n\n/*\n    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)\n*/\ncontract WrappedIbbtc is Initializable, ERC20Upgradeable {\n    address public governance;\n    address public pendingGovernance;\n    ERC20Upgradeable public ibbtc; \n\n    ICoreOracle public oracle;\n\n    event SetOracle(address oracle);\n    event SetPendingGovernance(address pendingGovernance);\n    event AcceptPendingGovernance(address pendingGovernance);\n\n    /// ===== Modifiers =====\n    modifier onlyPendingGovernance() {\n        require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"onlyGovernance\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == address(oracle), \"onlyOracle\");\n        _;\n    }\n\n    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n        governance = _governance;\n        oracle = ICoreOracle(_oracle);\n        ibbtc = ERC20Upgradeable(_ibbtc);\n\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Governance =====\n    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {\n        pendingGovernance = _pendingGovernance;\n        emit SetPendingGovernance(pendingGovernance);\n    }\n\n    function setOracle(address _oracle) external onlyGovernance {\n        oracle = ICoreOracle(_oracle);\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Pending Governance =====\n    function acceptPendingGovernance() external onlyPendingGovernance {\n        governance = pendingGovernance;\n        emit AcceptPendingGovernance(pendingGovernance);\n    }\n\n    /// ===== Permissionless Calls =====\n\n    /// @dev Deposit ibBTC to mint wibBTC shares\n    function mint(uint256 _shares) external {\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n        _mint(_msgSender(), _shares);\n    }\n\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n    function burn(uint256 _shares) external {\n        _burn(_msgSender(), _shares);\n        require(ibbtc.transfer(_msgSender(), _shares));\n    }\n\n    /// ===== Transfer Overrides =====\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\n    /// ===== View Methods =====\n\n    /// @dev Current pricePerShare read live from oracle\n    function pricePerShare() public view virtual returns (uint256) {\n        return oracle.pricePerShare();\n    }\n\n    /// @dev Wrapped ibBTC shares of account\n    function sharesOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @dev Current account shares * pricePerShare\n    function balanceOf(address account) public view override returns (uint256) {\n        return sharesOf(account).mul(pricePerShare()).div(1e18);\n    }\n\n    /// @dev Total wrapped ibBTC shares\n    function totalShares() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev Current total shares * pricePerShare\n    function totalSupply() public view override returns (uint256) {\n        return totalShares().mul(pricePerShare()).div(1e18);\n    }\n\n    function balanceToShares(uint256 balance) public view returns (uint256) {\n        return balance.mul(1e18).div(pricePerShare());\n    }\n\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\n        return shares.mul(pricePerShare()).div(1e18);\n    }\n}\n\n\n",
        "CodeNames": [
            "WrappedIbbtc.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "WrappedIbbtc contract",
                "Type": "Functional issue",
                "Description": "User will not be able to transfer if oracle.pricePerShare() (L124) revert.",
                "Repair": "Change either WrappedIbbtc or WrappedIbbtcEth to behave consistently with the specification"
            }
        ]
    }
]