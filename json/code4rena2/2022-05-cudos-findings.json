[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "updateValset function",
                "Type": "Missing check",
                "Description": "The updateValset function doesn't check that the sum of the powers of the new validators in the new valset is greater than the threshold, which can lead to unwanted behavior.",
                "Repair": "Add a check in the updateValset to assure that the sum of the new powers is greater than the threshold."
            },
            {
                "Location": "withdrawERC20 function",
                "Type": "Admin drains ERC20 funds",
                "Description": "Ability for admin to drain all ERC20 funds stored in contract at will, meaning all ERC20 based Cudos tokens (and any other ERC20 tokens stored in the contract) could be extracted by anyone with admin role and later sold, leaving users funds bridged on Cudos Cosmos chain with no ERC20 representation stored across the bridge similar in impact as the wormhole hack.",
                "Repair": "Delete the function or alternatively, send all funds to the '0' address to burn rather than give them to the admin."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CosmosToken.sol\";\nimport \"./CudosAccessControls.sol\";\n\npragma experimental ABIEncoderV2;\n\n// This is being used purely to avoid stack too deep errors\nstruct LogicCallArgs {\n\t// Transfers out to the logic contract\n\tuint256[] transferAmounts;\n\taddress[] transferTokenContracts;\n\t// The fees (transferred to msg.sender)\n\tuint256[] feeAmounts;\n\taddress[] feeTokenContracts;\n\t// The arbitrary logic call\n\taddress logicContractAddress;\n\tbytes payload;\n\t// Invalidation metadata\n\tuint256 timeOut;\n\tbytes32 invalidationId;\n\tuint256 invalidationNonce;\n}\n\n// This is used purely to avoid stack too deep errors\n// represents everything about a given validator set\nstruct ValsetArgs {\n\t// the validators in this set, represented by an Ethereum address\n\taddress[] validators;\n\t// the powers of the given validators in the same order as above\n\tuint256[] powers;\n\t// the nonce of this validator set\n\tuint256 valsetNonce;\n\t// the reward amount denominated in the below reward token, can be\n\t// set to zero\n\tuint256 rewardAmount;\n\t// the reward token, should be set to the zero address if not being used\n\taddress rewardToken;\n}\n\ncontract Gravity is ReentrancyGuard {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t// These are updated often\n\tbytes32 public state_lastValsetCheckpoint;\n\tmapping(address => uint256) public state_lastBatchNonces;\n\tmapping(bytes32 => uint256) public state_invalidationMapping;\n\tuint256 public state_lastValsetNonce = 0;\n\t// event nonce zero is reserved by the Cosmos module as a special\n\t// value indicating that no events have yet been submitted\n\tuint256 public state_lastEventNonce = 1;\n\n\t// These are set once at initialization\n\tbytes32 public state_gravityId;\n\tuint256 public state_powerThreshold;\n\n\tCudosAccessControls public cudosAccessControls;\n\n\tmapping(address => bool) public whitelisted;\n\n\t// TransactionBatchExecutedEvent and SendToCosmosEvent both include the field _eventNonce.\n\t// This is incremented every time one of these events is emitted. It is checked by the\n\t// Cosmos module to ensure that all events are received in order, and that none are lost.\n\t//\n\t// ValsetUpdatedEvent does not include the field _eventNonce because it is never submitted to the Cosmos\n\t// module. It is purely for the use of relayers to allow them to successfully submit batches.\n\tevent TransactionBatchExecutedEvent(\n\t\tuint256 indexed _batchNonce,\n\t\taddress indexed _token,\n\t\tuint256 _eventNonce\n\t);\n\tevent SendToCosmosEvent(\n\t\taddress indexed _tokenContract,\n\t\taddress indexed _sender,\n\t\tbytes32 indexed _destination,\n\t\tuint256 _amount,\n\t\tuint256 _eventNonce\n\t);\n\tevent ERC20DeployedEvent(\n\t\t// FYI: Can't index on a string without doing a bunch of weird stuff\n\t\tstring _cosmosDenom,\n\t\taddress indexed _tokenContract,\n\t\tstring _name,\n\t\tstring _symbol,\n\t\tuint8 _decimals,\n\t\tuint256 _eventNonce\n\t);\n\tevent ValsetUpdatedEvent(\n\t\tuint256 indexed _newValsetNonce,\n\t\tuint256 _eventNonce,\n\t\tuint256 _rewardAmount,\n\t\taddress _rewardToken,\n\t\taddress[] _validators,\n\t\tuint256[] _powers\n\t);\n\tevent LogicCallEvent(\n\t\tbytes32 _invalidationId,\n\t\tuint256 _invalidationNonce,\n\t\tbytes _returnData,\n\t\tuint256 _eventNonce\n\t);\n\n\tevent WhitelistedStatusModified(\n\t\taddress _sender,\n\t\taddress[] _users,\n\t\tbool _isWhitelisted\n\t);\n\n\n\tmodifier onlyWhitelisted() {\n\t\t require(\n            whitelisted[msg.sender] || cudosAccessControls.hasAdminRole(msg.sender) ,\n            \"The caller is not whitelisted for this operation\"\n        );\n\t\t_;\n\t}\n\n\tfunction manageWhitelist(\n\t\taddress[] memory _users,\n\t\tbool _isWhitelisted\n\t\t) public onlyWhitelisted {\n\t\t for (uint256 i = 0; i < _users.length; i++) {\n            require(\n                _users[i] != address(0),\n                \"User is the zero address\"\n            );\n            whitelisted[_users[i]] = _isWhitelisted;\n        }\n        emit WhitelistedStatusModified(msg.sender, _users, _isWhitelisted);\n\t}\n\n\t// TEST FIXTURES\n\t// These are here to make it easier to measure gas usage. They should be removed before production\n\tfunction testMakeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId) public pure {\n\t\tmakeCheckpoint(_valsetArgs, _gravityId);\n\t}\n\n\tfunction testCheckValidatorSignatures(\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) public pure {\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValidators,\n\t\t\t_currentPowers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\t_theHash,\n\t\t\t_powerThreshold\n\t\t);\n\t}\n\n\t// END TEST FIXTURES\n\n\tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\n\t\treturn state_lastBatchNonces[_erc20Address];\n\t}\n\n\tfunction lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {\n\t\treturn state_invalidationMapping[_invalidation_id];\n\t}\n\n\t// Utility function to verify geth style signatures\n\tfunction verifySig(\n\t\taddress _signer,\n\t\tbytes32 _theHash,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) private pure returns (bool) {\n\t\tbytes32 messageDigest = keccak256(\n\t\t\tabi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _theHash)\n\t\t);\n\t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n\t}\n\n\t// Make a new checkpoint from the supplied validator set\n\t// A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\n\t// instead of storing the information directly. This saves on storage and gas.\n\t// The format of the checkpoint is:\n\t// h(gravityId, \"checkpoint\", valsetNonce, validators[], powers[])\n\t// Where h is the keccak256 hash function.\n\t// The validator powers must be decreasing or equal. This is important for checking the signatures on the\n\t// next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\n\tfunction makeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId)\n\t\tprivate\n\t\tpure\n\t\treturns (bytes32)\n\t{\n\t\t// bytes32 encoding of the string \"checkpoint\"\n\t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n\n\t\tbytes32 checkpoint = keccak256(\n\t\t\tabi.encode(\n\t\t\t\t_gravityId,\n\t\t\t\tmethodName,\n\t\t\t\t_valsetArgs.valsetNonce,\n\t\t\t\t_valsetArgs.validators,\n\t\t\t\t_valsetArgs.powers,\n\t\t\t\t_valsetArgs.rewardAmount,\n\t\t\t\t_valsetArgs.rewardToken\n\t\t\t)\n\t\t);\n\n\t\treturn checkpoint;\n\t}\n\n\tfunction checkValidatorSignatures(\n\t\t// The current validator set and their powers\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\t// The current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// This is what we are checking they have signed\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) private pure {\n\t\tuint256 cumulativePower = 0;\n\n\t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\n\t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\n\t\t\t// (In a valid signature, it is either 27 or 28)\n\t\t\tif (_v[i] != 0) {\n\t\t\t\t// Check that the current validator has signed off on the hash\n\t\t\t\trequire(\n\t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\n\t\t\t\t\t\"Validator signature does not match.\"\n\t\t\t\t);\n\n\t\t\t\t// Sum up cumulative power\n\t\t\t\tcumulativePower = cumulativePower + _currentPowers[i];\n\n\t\t\t\t// Break early to avoid wasting gas\n\t\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that there was enough power\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\t\t// Success\n\t}\n\n\tfunction isOrchestrator(ValsetArgs memory _newValset, address _sender) private pure returns(bool) {\n\n\t\tfor (uint256 i = 0; i < _newValset.validators.length; i++) {\n\t\t\tif(_newValset.validators[i] == _sender) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// This updates the valset by checking that the validators in the current valset have signed off on the\n\t// new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\n\t// generated from the new valset.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the new valset.\n\tfunction updateValset(\n\t\t// The new version of the validator set\n\t\tValsetArgs memory _newValset,\n\t\t// The current validators that approve the change\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s\n\t) public nonReentrant {\n\t\t// CHECKS\n\n\t\t// Check that the valset nonce is greater than the old one\n\t\trequire(\n\t\t\t_newValset.valsetNonce > _currentValset.valsetNonce,\n\t\t\t\"New valset nonce must be greater than the current nonce\"\n\t\t);\n\n\t\t// Check that new validators and powers set is well-formed\n\t\trequire(\n\t\t\t_newValset.validators.length == _newValset.powers.length,\n\t\t\t\"Malformed new validator set\"\n\t\t);\n\n\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(\n\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\"Malformed current validator set\"\n\t\t);\n\n\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\trequire(\n\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t);\n\n\t\trequire(\n\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t);\n\n\t\t// Check that enough current validators have signed off on the new validator set\n\t\tbytes32 newCheckpoint = makeCheckpoint(_newValset, state_gravityId);\n\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValset.validators,\n\t\t\t_currentValset.powers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\tnewCheckpoint,\n\t\t\tstate_powerThreshold\n\t\t);\n\n\t\t// ACTIONS\n\n\t\t// Stored to be used next time to validate that the valset\n\t\t// supplied by the caller is correct.\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\t// Store new nonce\n\t\tstate_lastValsetNonce = _newValset.valsetNonce;\n\n\t\t// Send submission reward to msg.sender if reward token is a valid value\n\t\tif (_newValset.rewardToken != address(0) && _newValset.rewardAmount != 0) {\n\t\t\tIERC20(_newValset.rewardToken).safeTransfer(msg.sender, _newValset.rewardAmount);\n\t\t}\n\n\t\t// LOGS\n\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ValsetUpdatedEvent(\n\t\t\t_newValset.valsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t_newValset.rewardAmount,\n\t\t\t_newValset.rewardToken,\n\t\t\t_newValset.validators,\n\t\t\t_newValset.powers\n\t\t);\n\t}\n\n\t// submitBatch processes a batch of Cosmos -> Ethereum transactions by sending the tokens in the transactions\n\t// to the destination addresses. It is approved by the current Cosmos validator set.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the batch.\n\tfunction submitBatch (\n\t\t// The validators that approve the batch\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// The batch of transactions\n\t\tuint256[] memory _amounts,\n\t\taddress[] memory _destinations,\n\t\tuint256[] memory _fees,\n\t\tuint256 _batchNonce,\n\t\taddress _tokenContract,\n\t\t// a block height beyond which this batch is not valid\n\t\t// used to provide a fee-free timeout\n\t\tuint256 _batchTimeout\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the batch nonce is higher than the last nonce for this token\n\t\t\trequire(\n\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\n\t\t\t\t\"New batch nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that the block height is less than the timeout height\n\t\t\trequire(\n\t\t\t\tblock.number < _batchTimeout,\n\t\t\t\t\"Batch timeout must be greater than the current block height\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the transaction batch is well-formed\n\t\t\trequire(\n\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,\n\t\t\t\t\"Malformed batch of transactions\"\n\t\t\t);\n\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"\n\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n\t\t\t\t\t\t_amounts,\n\t\t\t\t\t\t_destinations,\n\t\t\t\t\t\t_fees,\n\t\t\t\t\t\t_batchNonce,\n\t\t\t\t\t\t_tokenContract,\n\t\t\t\t\t\t_batchTimeout\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\n\t\t\t// ACTIONS\n\n\t\t\t// Store batch nonce\n\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\n\n\t\t\t{\n\t\t\t\t// Send transaction amounts to destinations\n\t\t\t\tuint256 totalFee;\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\n\t\t\t\t\ttotalFee = totalFee.add(_fees[i]);\n\t\t\t\t}\n\n\t\t\t\t// Send transaction fees to msg.sender\n\t\t\t\tIERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n\t\t\t}\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);\n\t\t}\n\t}\n\n\t// This makes calls to contracts that execute arbitrary logic\n\t// First, it gives the logic contract some tokens\n\t// Then, it gives msg.senders tokens for fees\n\t// Then, it calls an arbitrary function on the logic contract\n\t// invalidationId and invalidationNonce are used for replay prevention.\n\t// They can be used to implement a per-token nonce by setting the token\n\t// address as the invalidationId and incrementing the nonce each call.\n\t// They can be used for nonce-free replay prevention by using a different invalidationId\n\t// for each call.\n\tfunction submitLogicCall(\n\t\t// The validators that approve the call\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tLogicCallArgs memory _args\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\trequire(block.number < _args.timeOut, \"Timed out\");\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\trequire(\n\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,\n\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the token transfer list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,\n\t\t\t\t\"Malformed list of token transfers\"\n\t\t\t);\n\n\t\t\t// Check that the fee list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,\n\t\t\t\t\"Malformed list of fees\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 argsHash = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tstate_gravityId,\n\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t_args.transferAmounts,\n\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t_args.feeAmounts,\n\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.payload,\n\t\t\t\t_args.timeOut,\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce\n\t\t\t)\n\t\t);\n\n\t\t{\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\treturnData,\n\t\t\t\tstate_lastEventNonce\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\t_amount,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction deployERC20(\n\t\tstring memory _cosmosDenom,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tuint8 _decimals\n\t) public {\n\t\t// Deploy an ERC20 with entire supply granted to Gravity.sol\n\t\tCosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n\n\t\t// Fire an event to let the Cosmos module know\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ERC20DeployedEvent(\n\t\t\t_cosmosDenom,\n\t\t\taddress(erc20),\n\t\t\t_name,\n\t\t\t_symbol,\n\t\t\t_decimals,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction withdrawERC20(\n\t\taddress _tokenAddress) \n\t\texternal {\n\t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n\t}\n\n\tconstructor(\n\t\t// A unique identifier for this gravity instance to use in signatures\n\t\tbytes32 _gravityId,\n\t\t// How much voting power is needed to approve operations\n\t\tuint256 _powerThreshold,\n\t\t// The validator set, not in valset args format since many of it's\n\t\t// arguments would never be used in this case\n\t\taddress[] memory _validators,\n    uint256[] memory _powers,\n\t\tCudosAccessControls _cudosAccessControls\n\t) public {\n\t\t// CHECKS\n\n\t\t// Check that validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(_validators.length == _powers.length, \"Malformed current validator set\");\n\t\trequire(address(_cudosAccessControls) != address(0), \"Access control contract address is incorrect\");\n\n\t\t// Check cumulative power to ensure the contract has sufficient power to actually\n\t\t// pass a vote\n\t\tuint256 cumulativePower = 0;\n\t\tfor (uint256 i = 0; i < _powers.length; i++) {\n\t\t\tcumulativePower = cumulativePower + _powers[i];\n\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\n\t\tValsetArgs memory _valset;\n\t\t_valset = ValsetArgs(_validators, _powers, 0, 0, address(0));\n\n\t\tbytes32 newCheckpoint = makeCheckpoint(_valset, _gravityId);\n\n\t\t// ACTIONS\n\n\t\tstate_gravityId = _gravityId;\n\t\tstate_powerThreshold = _powerThreshold;\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\tcudosAccessControls = _cudosAccessControls;\n\n\t\t// LOGS\n\n\t\temit ValsetUpdatedEvent(\n\t\t\tstate_lastValsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t0,\n\t\t\taddress(0),\n\t\t\t_validators,\n\t\t\t_powers\n\t\t);\n\t}\n}\n\n\n",
        "CodeNames": [
            "Gravity.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Gravity.sol contract",
                "Type": "No pause/unpause functionality",
                "Description": "In case a hack is occurring or an exploit is discovered, the team (or validators in this case) should be able to pause functionality until the necessary changes are made to the system.",
                "Repair": "Add pause/unpause functionality to the contract."
            },
            {
                "Location": "Gravity.sol contract",
                "Type": "Calls inside loops",
                "Description": "Calls to external contracts inside a loop are dangerous (especially if the loop index can be user-controlled) because it could lead to DoS if one of the calls reverts or execution runs out of gas.",
                "Repair": "Avoid combining multiple calls in a single transaction, especially when calls are executed as part of a loop. Always assume that external calls can fail. Implement the contract logic to handle failed calls."
            },
            {
                "Location": "Gravity.sol#L600",
                "Type": "Fee on transfer vulnerability",
                "Description": "The protocol doesn't handle fee on transfer tokens, which can result in draining of other user's funds.",
                "Repair": "Restrict token transfers to tokens that do not support fee on transfer"
            }
        ]
    }
]