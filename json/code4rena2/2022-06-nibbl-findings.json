[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Basket's withdraw multiple tokens function",
                "Type": "Reentrancy",
                "Description": "Reentrancy bug in Basket's withdraw multiple tokens function which gives attacker ability to transfer basket ownership and spend it but withdraw all the tokens out of basket",
                "Repair": "Check ownership of id=0 in every iteration or don't allow ownership transfer in the multiple-token-transfer functions"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "buy function in NibblVault.sol",
                "Type": "Loss of NFT",
                "Description": "Lack of sanity check on _initialTokenSupply and _initialTokenPrice can lead to a seller losing his NFT.",
                "Repair": "Add sanity checks to ensure a sane expected value for _initialTokenSupply and _initialTokenPrice"
            },
            {
                "Location": "buy function in NibblVault.sol",
                "Type": "Fee avoidance",
                "Description": "In the buy function of the NibblVault contract, when msg.value < _lowerCurveDiff, the fee for SecondaryCurve part is not charged.",
                "Repair": "Charge the fee for SecondaryCurve part using _chargeFeeSecondaryCurve function"
            },
            {
                "Location": "NibblVault contract, _getTwav() function",
                "Type": "Ineffective TWAV Implementation",
                "Description": "The current TWAV implementation only has a period of 1 minute, which is too short to prevent price manipulation. A user could call the updateTWAV function to add the new valuation/observation to the twavObservations array each time a new Ethereum block is mined. As such, the current implementation becomes the average value of a security over a specific number of observations (in this case 4 observations), thus it can be considered as Observation weighted average valuation (OWAV). There is a fundamental difference between TWAV and OWAV.",
                "Repair": "Implement a proper TWAV that provides the average value of a security over a specified time. The time period/windows of the TWAV must be explicitly defined (e.g. 15 minutes, 1 hour, 24 hours) in the contract."
            },
            {
                "Location": "NibblVault.updateTWAV function",
                "Type": "State Change Vulnerability",
                "Description": "Calling NibblVault.updateTWAP function will change the state of the system. It will cause the TWAP to be updated and buyout to be rejected in certain condition. When the system is in Pause mode, the system state should be frozen. However, it was possible for someone to call the NibblVault.updateTWAP function during the Pause mode, thus making changes to the system state.",
                "Repair": "Add the whenNotPaused modifier to the function"
            },
            {
                "Location": "NibblVault.sol",
                "Type": "Functionality",
                "Description": "Buyout cannot be rejected when paused",
                "Repair": "Reset buyoutEndTime when the system is paused"
            },
            {
                "Location": "initialize function in NibblVault.sol",
                "Type": "Arithmetic",
                "Description": "uint32 _secondaryReserveRatio can be overflowed by setting a relatively small _initialTokenSupply and _initialTokenPrice",
                "Repair": "Add overflow checks or use OpenZeppelin safe cast helpers"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\ncontract Twav {\n    struct TwavObservation {\n        uint32 timestamp;\n        uint256 cumulativeValuation;\n    }\n\n    /// @notice current index of twavObservations index\n    uint8 public twavObservationsIndex;\n    uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n    uint32 public lastBlockTimeStamp;\n\n    /// @notice record of TWAV \n    TwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n    /// @notice updates twavObservations array\n    /// @param _blockTimestamp timestamp of the block\n    /// @param _valuation current valuation\n    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n        uint32 _timeElapsed; \n        unchecked {\n            _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n        }\n\n        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n        twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n        lastBlockTimeStamp = _blockTimestamp;\n    }\n\n    /// @notice returns the TWAV of the last 4 blocks\n    /// @return _twav TWAV of the last 4 blocks\n    function _getTwav() internal view returns(uint256 _twav){\n        if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n            uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n            TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n            TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n            _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n        }\n    }\n\n    function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) {\n        return twavObservations;\n    }\n}\n\n",
        "CodeNames": [
            "Twav.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_updateTwav() and _getTwav() functions in Twav.sol",
                "Type": "Integer overflow",
                "Description": "_updateTwav() and _getTwav() will revert when cumulativePrice overflows.",
                "Repair": "Add unchecked keyword in every line you add/subtract cumulative prices"
            },
            {
                "Location": "Twav._getTwav function",
                "Type": "Incorrect Functionality",
                "Description": "The if condition of Twav._getTwav() is missing some edge cases. In this case, this function will return 0 which is different from the correct value and it will affect the main functions like NibblVault.buy() and NibblVault.sell(). I think this condition is to confirm at least 4 values were saved for twav calculation. Btw this timestamp would be zero even though there are more than 4 values properly as it's modularized by 2**32. In this case, the if condition will be false and this function will return 0.",
                "Repair": "Replace timestamp with cumulativeValuation"
            },
            {
                "Location": "Twav._getTwav function",
                "Type": "Arithmetic Overflow/Underflow",
                "Description": "Since _blockTimestamp is uint32, subtraction underflow is desired at _twavObservationCurrent.timestamp - _twavObservationPrev.timestamp. The timestamp subtraction may revert due to underflow. Since _getTwav() is used in NibblVault._rejectBuyout(), if it reverts and there is a buyout, an essential feature of the NibblVault contract will be unavailable, causing users' funds to be frozen in the contract.",
                "Repair": "Handle underflow consistently"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "Basket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Basket.sol contract",
                "Type": "Missing name and symbol",
                "Description": "Basket NFTs have no name and symbol.",
                "Repair": "Pass name and symbol variables as immutable so they are hardcoded in the implementation byte code"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { NibblVault } from \"./NibblVault.sol\";\nimport { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { ProxyVault } from \"./Proxy/ProxyVault.sol\";\nimport { ProxyBasket } from \"./Proxy/ProxyBasket.sol\";\nimport { NibblVaultFactoryData } from \"./Utilities/NibblVaultFactoryData.sol\";\nimport { AccessControlMechanism } from \"./Utilities/AccessControlMechanism.sol\";\nimport { INibblVaultFactory } from \"./Interfaces/INibblVaultFactory.sol\";\nimport { Basket } from \"./Basket.sol\";\n\ncontract NibblVaultFactory is INibblVaultFactory, AccessControlMechanism, Pausable, NibblVaultFactoryData {\n    /// @notice Minimum initial reserve balance a user has to deposit to create a new vault\n    uint256 private constant MIN_INITIAL_RESERVE_BALANCE = 1e9;\n\n    /// @notice array containing the addresses of all the vaults\n    ProxyVault[] public nibbledTokens;\n    constructor (address _vaultImplementation, address _feeTo, address _admin, address _basketImplementation) AccessControlMechanism(_admin) {\n        vaultImplementation = _vaultImplementation;\n        feeTo = _feeTo;\n        basketImplementation = _basketImplementation;\n    }\n\n    /// @notice mints a new vault\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _curator address of the vault curator\n    /// @param _name name of the fractional token to be created\n    /// @param _symbol symbol of the fractional token\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price\n    /// @param _minBuyoutTime minimum time after which buyout can be triggered\n    function createVault(\n        address _assetAddress,\n        address _curator,\n        string memory _name,\n        string memory _symbol,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n        ) external payable override whenNotPaused returns(address payable _proxyVault) {\n        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n        NibblVault _vault = NibblVault(payable(_proxyVault));\n        _vault.initialize{value: msg.value}(_name, _symbol, _assetAddress, _assetTokenID, _curator, _initialSupply,_initialTokenPrice, _minBuyoutTime);\n        IERC721(_assetAddress).safeTransferFrom(msg.sender, address(_vault), _assetTokenID);\n        nibbledTokens.push(ProxyVault(_proxyVault));\n        emit Fractionalise(_assetAddress, _assetTokenID, _proxyVault);\n    }\n\n    /// @notice get address of vault to be deployed\n    /// @param _curator address of curator\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price    \n    function getVaultAddress(\n        address _curator,\n        address _assetAddress,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice) public view returns(address _vault) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice));\n        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this))));\n        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _vault = address(uint160(uint256(_hash)));     \n    }\n\n    function getVaults() public view returns(ProxyVault[] memory ) {\n        return nibbledTokens;\n    }\n\n    function createBasket(address _curator, string memory _mix) public override returns(address)  {\n        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation));\n        Basket _basket = Basket(_basketAddress);\n        _basket.initialise(_curator);\n        emit BasketCreated(_curator, _basketAddress);\n        return _basketAddress;\n    }\n\n    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));\n        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _basket = address(uint160(uint256(hash)));     \n    }\n\n    /// @notice proposes new Basket implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by IMPLEMENTER_ROLE\n    /// @param _newBasketImplementation new implementation basket address\n    function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingBasketImplementation = _newBasketImplementation;\n        basketUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new basket implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateBasketImplementation() external override {\n        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        basketImplementation = pendingBasketImplementation;\n        delete basketUpdateTime;\n    }\n\n    function withdrawAdminFee() external override {\n        (bool _success, ) = payable(feeTo).call{value: address(this).balance}(\"\");\n        require(_success);\n    }\n\n    // Cancellation functions aren't required as we can call propose function again with different parameters\n\n    /// @notice proposes new admin fee address\n    /// @dev new address can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFeeAddress new address to receive admin fee on address\n    function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n        pendingFeeTo = _newFeeAddress;\n        feeToUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee address\n    /// @dev can only be updated after timelock\n    function updateNewAdminFeeAddress() external override {\n        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeTo = pendingFeeTo;\n        delete feeToUpdateTime;\n    }\n\n    /// @notice proposes new admin fee\n    /// @dev new fee can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFee new admin fee \n    function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n        pendingFeeAdmin = _newFee;\n        feeAdminUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee\n    /// @dev new fee can be updated only after timelock\n    function updateNewAdminFee() external override {\n        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeAdmin = pendingFeeAdmin;\n        delete feeAdminUpdateTime;\n    }\n\n    /// @notice proposes new vault implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newVaultImplementation new implementation vault address\n    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingVaultImplementation = _newVaultImplementation;\n        vaultUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new vault implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateVaultImplementation() external override {\n        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        vaultImplementation = pendingVaultImplementation;\n        delete vaultUpdateTime;\n    }\n\n    /// @notice pauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function pause() external onlyRole(PAUSER_ROLE) override {\n        _pause();\n    }\n\n    /// @notice unpauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function unPause() external onlyRole(PAUSER_ROLE) override {\n        _unpause();\n    }\n\n    receive() payable external {    }\n\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\ncontract NibblVaultFactoryData {\n    uint256 public UPDATE_TIME = 2 days;\n    uint256 public constant MAX_ADMIN_FEE = 10_000; //1%\n\n    address public vaultImplementation;\n    address public pendingVaultImplementation;\n    uint256 public vaultUpdateTime; //Cooldown period\n\n    address public feeTo;\n    address public pendingFeeTo;\n    uint256 public feeToUpdateTime; //Cooldown period  \n\n    uint256 public feeAdmin = 2_000;\n    uint256 public pendingFeeAdmin;\n    uint256 public feeAdminUpdateTime; //Cooldown period\n\n    address public basketImplementation;\n    address public pendingBasketImplementation;\n    uint256 public basketUpdateTime; //Cooldown period    \n\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "NibblVaultFactory.sol",
            "NibblVaultFactoryData.sol",
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NibblVaultFactoryData.sol line 6, NibblVaultFactory.sol line 158-169, NibblVault.sol line 37",
                "Type": "Timelock Manipulation",
                "Description": "The NibblVault buyout duration is longer than the update timelock, which allows an attacker to initiate a buyout and then the administrator can update the vault implementation, leaving the bidder in a bad state and losing funds. The vulnerability can be fixed by implementing functionality for bidder to cancel the bid or increasing/decreasing the UPDATE_TIME/BUYOUT_DURATION so the invariant BUYOUT_DURATION < UPDATE_TIME holds.",
                "Repair": "Implement functionality for bidder to cancel the bid or increase/decrease the UPDATE_TIME/BUYOUT_DURATION so the invariant BUYOUT_DURATION < UPDATE_TIME holds"
            }
        ]
    }
]