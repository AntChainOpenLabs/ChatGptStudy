[
    {
        "Code": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../libraries/Position.sol\";\nimport \"../libraries/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\";\nimport \"../interfaces/IOverlayV1Market.sol\";\nimport \"../interfaces/IOverlayV1Mothership.sol\";\nimport \"../interfaces/IOverlayToken.sol\";\nimport \"../interfaces/IOverlayTokenNew.sol\";\n\ncontract OverlayV1OVLCollateral is ERC1155Supply {\n\n    event log(string k, uint v);\n    event log_addr(string k, address v);\n\n    using Position for Position.Info;\n    using FixedPoint for uint256;\n\n    bytes32 constant private GOVERNOR = keccak256(\"GOVERNOR\");\n\n    mapping (address => mapping(uint => uint)) internal currentBlockPositionsLong;\n    mapping (address => mapping(uint => uint)) internal currentBlockPositionsShort;\n    mapping (address => MarketInfo) public marketInfo;\n    struct MarketInfo {\n        uint marginMaintenance;\n        uint marginRewardRate;\n        uint maxLeverage;\n    }\n\n    Position.Info[] public positions;\n\n    IOverlayV1Mothership public immutable mothership;\n    IOverlayTokenNew immutable public ovl;\n\n    uint256 public fees;\n    uint256 public liquidations;\n\n    event Build(\n        address market,\n        uint256 positionId,\n        uint256 oi,\n        uint256 debt\n    );\n\n    event Unwind(\n        address market,\n        uint256 positionId,\n        uint256 oi,\n        uint256 debt\n    );\n\n    event Liquidate(\n        uint256 positionId,\n        uint256 oi,\n        uint256 reward,\n        address rewarded\n    );\n\n    event Update(\n        uint feesCollected,\n        uint feesBurned,\n        uint liquidationsCollected,\n        uint liquidationsBurned\n    );\n\n    modifier onlyGovernor () {\n        require(mothership.hasRole(GOVERNOR, msg.sender), \"OVLV1:!governor\");\n        _;\n    }\n\n    constructor (\n        string memory _uri,\n        address _mothership\n    ) ERC1155(_uri) {\n\n        mothership = IOverlayV1Mothership(_mothership);\n\n        ovl = IOverlayV1Mothership(_mothership).ovl();\n\n        positions.push(Position.Info({\n            market: address(0),\n            isLong: false,\n            leverage: 0,\n            pricePoint: 0,\n            oiShares: 0,\n            debt: 0,\n            cost: 0\n        }));\n\n    }\n\n    function setMarketInfo (\n        address _market,\n        uint _marginMaintenance,\n        uint _marginRewardRate,\n        uint _maxLeverage\n    ) external onlyGovernor {\n\n        marketInfo[_market].marginMaintenance = _marginMaintenance;\n        marketInfo[_market].marginRewardRate = _marginRewardRate;\n        marketInfo[_market].maxLeverage = _maxLeverage;\n\n    }\n\n    function marginMaintenance(\n        address _market\n    ) external view returns (\n        uint marginMaintenance_\n    ) {\n\n        marginMaintenance_ = marketInfo[_market].marginMaintenance;\n\n    }\n\n    function maxLeverage(\n        address _market\n    ) external view returns (\n        uint maxLeverage_\n    ) {\n\n        maxLeverage_ = marketInfo[_market].maxLeverage;\n\n    }\n\n    function marginRewardRate(\n        address _market\n    ) external view returns (\n        uint marginRewardRate_\n    ) {\n\n        marginRewardRate_ = marketInfo[_market].marginRewardRate;\n\n    }\n\n\n    /// @notice Disburses fees\n    function disburse () public {\n\n        (   uint256 _marginBurnRate,\n            uint256 _feeBurnRate,\n            address _feeTo ) = mothership.getUpdateParams();\n\n        uint _feeForward = fees;\n        uint _feeBurn = _feeForward.mulUp(_feeBurnRate);\n        _feeForward = _feeForward - _feeBurn;\n\n        uint _liqForward = liquidations;\n        uint _liqBurn = _liqForward.mulUp(_marginBurnRate);\n        _liqForward -= _liqBurn;\n\n        fees = 0;\n        liquidations = 0;\n\n        emit Update(\n            _feeForward,\n            _feeBurn,\n            _liqForward,\n            _liqBurn\n        );\n\n        ovl.burn(address(this), _feeBurn + _liqBurn);\n        ovl.transfer(_feeTo, _feeForward + _liqForward);\n\n    }\n\n    function getCurrentBlockPositionId (\n        address _market,\n        bool _isLong,\n        uint _leverage,\n        uint _pricePointNext\n    ) internal returns (\n        uint positionId_\n    ) {\n\n        mapping(uint=>uint) storage _currentBlockPositions = _isLong\n            ? currentBlockPositionsLong[_market]\n            : currentBlockPositionsShort[_market];\n\n        positionId_ = _currentBlockPositions[_leverage];\n\n        Position.Info storage position = positions[positionId_];\n\n        if (position.pricePoint < _pricePointNext) {\n\n            positions.push(Position.Info({\n                market: _market,\n                isLong: _isLong,\n                leverage: _leverage,\n                pricePoint: _pricePointNext,\n                oiShares: 0,\n                debt: 0,\n                cost: 0\n            }));\n\n            positionId_ = positions.length - 1;\n\n            _currentBlockPositions[_leverage] = positionId_;\n\n        }\n\n    }\n\n\n    /// @notice Build a position on Overlay with OVL collateral\n    /// @dev This interacts with an Overlay Market to register oi and hold \n    /// positions on behalf of users.\n    /// @param _market The address of the desired market to interact with.\n    /// @param _collateral The amount of OVL to use as collateral in the position.\n    /// @param _leverage The amount of leverage to use in the position\n    /// @param _isLong Whether to take out a position on the long or short side.\n    /// @param _oiMinimum Minimum acceptable amount of OI after impact and fees.\n    /// @return positionId_ Id of the built position for on chain convenience.\n    function build (\n        address _market,\n        uint256 _collateral,\n        uint256 _leverage,\n        bool _isLong,\n        uint256 _oiMinimum\n    ) external returns (\n        uint positionId_\n    ) {\n\n        require(mothership.marketActive(_market), \"OVLV1:!market\");\n        require(_leverage <= marketInfo[_market].maxLeverage, \"OVLV1:lev>max\");\n\n        (   uint _oiAdjusted,\n            uint _collateralAdjusted,\n            uint _debtAdjusted,\n            uint _fee,\n            uint _impact,\n            uint _pricePointNext ) = IOverlayV1Market(_market)\n                .enterOI(\n                    _isLong,\n                    _collateral,\n                    _leverage\n                );\n\n        require(_oiAdjusted >= _oiMinimum, \"OVLV1:oi<min\");\n\n        uint _positionId = getCurrentBlockPositionId(\n            _market,\n            _isLong,\n            _leverage,\n            _pricePointNext\n        );\n\n        Position.Info storage pos = positions[_positionId];\n\n        pos.oiShares += _oiAdjusted;\n        pos.cost += _collateralAdjusted;\n        pos.debt += _debtAdjusted;\n\n        fees += _fee;\n\n        emit Build(_market, _positionId, _oiAdjusted, _debtAdjusted);\n\n        ovl.transferFromBurn(msg.sender, address(this), _collateralAdjusted + _fee, _impact);\n\n        // ovl.burn(msg.sender, _impact);\n\n        _mint(msg.sender, _positionId, _oiAdjusted, \"\"); // WARNING: last b/c erc1155 callback\n\n        positionId_ = _positionId;\n\n    }\n\n    /// @notice Unwinds shares of an existing position.\n    /// @dev Interacts with a market contract to realize the PnL on a position.\n    /// @param _positionId Id of the position to be unwound.\n    /// @param _shares Number of shars to unwind from the position.\n    function unwind (\n        uint256 _positionId,\n        uint256 _shares\n    ) external {\n\n        require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), \"OVLV1:!shares\");\n\n        Position.Info storage pos = positions[_positionId];\n\n        require(0 < pos.oiShares, \"OVLV1:liquidated\");\n\n        {\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = IOverlayV1Market(pos.market)\n                .exitData(\n                    pos.isLong,\n                    pos.pricePoint\n                );\n\n        uint _totalPosShares = totalSupply(_positionId);\n\n        uint _userOiShares = _shares;\n        uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;\n        uint _userDebt = _shares * pos.debt / _totalPosShares;\n        uint _userCost = _shares * pos.cost / _totalPosShares;\n        uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;\n\n        emit Unwind(pos.market, _positionId, _userOi, _userDebt);\n\n        // TODO: think through edge case of underwater position ... and fee adjustments ...\n        uint _feeAmount = _userNotional.mulUp(mothership.fee());\n\n        uint _userValueAdjusted = _userNotional - _feeAmount;\n        if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt;\n        else _userValueAdjusted = 0;\n\n        fees += _feeAmount; // adds to fee pot, which is transferred on update\n\n        pos.debt -= _userDebt;\n        pos.cost -= _userCost;\n        pos.oiShares -= _userOiShares;\n\n        // ovl.transfer(msg.sender, _userCost);\n\n        // mint/burn excess PnL = valueAdjusted - cost\n        if (_userCost < _userValueAdjusted) {\n\n            ovl.transferMint(\n                msg.sender, \n                _userCost, \n                _userValueAdjusted - _userCost\n            );\n\n        } else {\n\n            ovl.transferBurn(\n                msg.sender, \n                _userValueAdjusted, \n                _userCost - _userValueAdjusted\n            );\n\n        }\n\n\n        IOverlayV1Market(pos.market).exitOI(\n            pos.isLong,\n            _userOi,\n            _userOiShares,\n            _userCost < _userValueAdjusted ? _userValueAdjusted - _userCost : 0,\n            _userCost < _userValueAdjusted ? 0 : _userCost - _userValueAdjusted\n        );\n\n        }\n\n        _burn(msg.sender, _positionId, _shares);\n\n    }\n\n    /// @notice Liquidates an existing position.\n    /// @dev Interacts with an Overlay Market to exit all open interest\n    /// associated with a liquidatable positoin.\n    /// @param _positionId ID of the position being liquidated.\n    /// @param _rewardsTo Address to send liquidation reward to.\n    function liquidate (\n        uint256 _positionId,\n        address _rewardsTo\n    ) external {\n\n        Position.Info storage pos = positions[_positionId];\n\n        require(0 < pos.oiShares, \"OVLV1:liquidated\");\n\n        bool _isLong = pos.isLong;\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = IOverlayV1Market(pos.market)\n                .exitData(\n                    _isLong,\n                    pos.pricePoint\n                );\n\n        MarketInfo memory _marketInfo = marketInfo[pos.market];\n\n        require(pos.isLiquidatable(\n            _oi,\n            _oiShares,\n            _priceFrame,\n            _marketInfo.marginMaintenance\n        ), \"OVLV1:!liquidatable\");\n\n        uint _value = pos.value(_oi, _oiShares, _priceFrame);\n\n        IOverlayV1Market(pos.market).exitOI(\n            _isLong,\n            pos.oi(_oi, _oiShares),\n            pos.oiShares,\n            0,\n            pos.cost - _value\n        );\n\n        // TODO: which is better on gas\n        pos.oiShares = 0;\n        pos.debt = 0;\n        // positions[positionId].oiShares = 0;\n\n        uint _toReward = _value.mulUp(_marketInfo.marginRewardRate);\n\n        liquidations += _value - _toReward;\n\n        emit Liquidate(\n            _positionId,\n            _oi,\n            _toReward,\n            _rewardsTo\n        );\n\n        // ovl.burn(address(this), pos.cost - _value);\n        ovl.transferBurn(_rewardsTo, _toReward, pos.cost - _value);\n\n    }\n\n\n    /// @notice Retrieves required information from market contract \n    /// to calculate position value with.\n    /// @dev Gets price frame, total open interest and \n    /// total open interest shares from an Overlay market.\n    /// @param _positionId ID of position to determine value of.\n    /// @return value_ Value of the position\n    function value (\n        uint _positionId\n    ) public view returns (\n        uint256 value_\n    ) {\n\n        Position.Info storage pos = positions[_positionId];\n\n        IOverlayV1Market _market = IOverlayV1Market(pos.market);\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = _market\n            .positionInfo(\n                pos.isLong,\n                pos.pricePoint\n            );\n\n        value_ = pos.value(\n            _oi,\n            _oiShares,\n            _priceFrame\n        );\n\n    }\n\n}\n\n\n",
        "CodeNames": [
            "OverlayV1OVLCollateral.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OverlayV1OVLCollateral contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "ERC1155Supply vulnerability in the OverlayV1OVLCollateral contract due to the use of an outdated version of OpenZeppelin contracts (4.3.2) that has a recently discovered vulnerability. A malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.",
                "Repair": "Update to a patched version of 4.3.3"
            },
            {
                "Location": "OverlayV1OVLCollateral contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "The fees recorded in the OverlayV1OVLCollateral contract may be greater than the value of fees stored due to double counting for underwater positions. This can lead to fee withdrawal malfunction and funds leakage to fees. Consider accruing fees only on a remaining part of position that is available after taking debt into account.",
                "Repair": "Accrue fees only on a remaining part of position that is available after taking debt into account"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"../interfaces/IOverlayV1Market.sol\";\nimport \"../OverlayToken.sol\";\n\ncontract OverlayV1Mothership is AccessControlEnumerable {\n\n    uint16 public constant MIN_FEE = 1; // 0.01%\n    uint16 public constant MAX_FEE = 100; // 1.00%\n\n    uint16 public constant MIN_MARGIN_MAINTENANCE = 100; // 1% maintenance\n    uint16 public constant MAX_MARGIN_MAINTENANCE = 6000; // 60% maintenance\n\n    bytes32 public constant ADMIN = 0x00;\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant MINTER = keccak256(\"MINTER\");\n    bytes32 public constant BURNER = keccak256(\"BURNER\");\n\n    // ovl erc20 token\n    address public ovl;\n\n    // portion of liquidations to burn on update\n    uint public marginBurnRate;\n\n    // global params adjustable by gov\n    // build/unwind trading fee\n    uint public fee;\n    // portion of build/unwind fee burnt\n    uint public feeBurnRate;\n    // address to send fees to\n    address public feeTo;\n\n    mapping(address => bool) public marketActive;\n    mapping(address => bool) public marketExists;\n    address[] public allMarkets;\n\n    mapping(address => bool) public collateralExists;\n    mapping(address => bool) public collateralActive;\n    address[] public allCollateral;\n\n    modifier onlyGovernor () {\n        require(hasRole(GOVERNOR, msg.sender), \"OVLV1:!gov\");\n        _;\n    }\n\n    modifier onlyGuardian () {\n        require(hasRole(GUARDIAN, msg.sender), \"OVLV1:!guard\");\n        _;\n    }\n\n    constructor(\n        address _feeTo,\n        uint _fee,\n        uint _feeBurnRate,\n        uint _marginBurnRate\n    ) {\n\n        _setupRole(ADMIN, msg.sender);\n        _setupRole(GOVERNOR, msg.sender);\n        _setupRole(GUARDIAN, msg.sender);\n        _setRoleAdmin(GOVERNOR, ADMIN);\n        _setRoleAdmin(GUARDIAN, ADMIN);\n\n        // global params\n        fee = _fee;\n        feeBurnRate = _feeBurnRate;\n        feeTo = _feeTo;\n        marginBurnRate = _marginBurnRate;\n\n    }\n\n    function setOVL (address _ovl) external onlyGovernor {\n\n        ovl = _ovl;\n\n    }\n\n    function totalMarkets () external view returns (uint) {\n        return allMarkets.length;\n    }\n\n    /// @notice Initializes an existing market contract after deployment\n    /// @dev Should be called after contract deployment in specific market factory.createMarket\n    function initializeMarket(address market) external onlyGovernor {\n\n        require(!marketExists[market], \"OVLV1:!!initialized\");\n\n        marketExists[market] = true;\n        marketActive[market] = true;\n\n        allMarkets.push(market);\n\n    }\n\n    /// @notice Disables an existing market contract for a mirin market\n    function disableMarket(address market) external onlyGovernor {\n\n        require(marketActive[market], \"OVLV1: !enabled\");\n\n        marketActive[market] = false;\n\n    }\n\n    /// @notice Enables an existing market contract for a mirin market\n    function enableMarket(address market) external onlyGovernor {\n\n        require(marketExists[market], \"OVLV1: !exists\");\n\n        require(!marketActive[market], \"OVLV1: !disabled\");\n\n        marketActive[market] = true;\n\n    }\n\n    function initializeCollateral (address _collateral) external onlyGovernor {\n\n        require(!collateralExists[_collateral], \"OVLV1:!!iintialized\");\n\n        collateralExists[_collateral] = true;\n        collateralActive[_collateral] = true;\n\n        allCollateral.push(_collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    function enableCollateral (address _collateral) external onlyGovernor {\n\n        require(collateralExists[_collateral], \"OVLV1:!exists\");\n\n        require(!collateralActive[_collateral], \"OVLV1:!disabled\");\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    function disableCollateral (address _collateral) external onlyGovernor {\n\n        require(collateralActive[_collateral], \"OVLV1:!enabled\");\n\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    /// @notice Allows gov to adjust per market params\n\n    /// @notice Allows gov to adjust global params\n    function adjustGlobalParams(\n        uint16 _fee,\n        uint16 _feeBurnRate,\n        address _feeTo\n    ) external onlyGovernor {\n        fee = _fee;\n        feeBurnRate = _feeBurnRate;\n        feeTo = _feeTo;\n    }\n\n    function getUpdateParams() external view returns (\n        uint,\n        uint,\n        address\n    ) {\n        return (\n            marginBurnRate,\n            feeBurnRate,\n            feeTo\n        );\n    }\n\n}\n\n\n",
        "CodeNames": [
            "OverlayV1Mothership.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OverlayV1Mothership contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "Governance functions in the OverlayV1Mothership contract can change important parameters of the system without emitting events or using a timelock, which can impact the function of the protocol or its availability. Consider using a timelock for critical params of the system and emitting events to inform the outside world.",
                "Repair": "Use a timelock for critical params of the system and emit events to inform the outside world"
            },
            {
                "Location": "OverlayV1Mothership contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "The disableCollateral() function in the OverlayV1Mothership contract revokes the roles but doesn't set collateralActive[_collateral] to false, which means that enableCollateral() can never be used again. Consider setting collateralActive[_collateral] to true in enableCollateral() and to false in disableCollateral().",
                "Repair": "Set collateralActive[_collateral] to true in enableCollateral() and to false in disableCollateral()"
            },
            {
                "Location": "adjustGlobalParams function on line 1603 of OverlayV1Mothership.sol",
                "Type": "Improper Upper Bound Definition",
                "Description": "Values that are too large will lead to reversions in several critical functions.",
                "Repair": "Define upper and lower bounds on the adjustGlobalParams function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IOverlayV1Mothership.sol\";\nimport \"../interfaces/IOverlayToken.sol\";\nimport \"../interfaces/IOverlayTokenNew.sol\";\nimport \"./OverlayV1Comptroller.sol\";\nimport \"./OverlayV1OI.sol\";\nimport \"./OverlayV1PricePoint.sol\";\n\nabstract contract OverlayV1Governance is\n    OverlayV1Comptroller,\n    OverlayV1OI,\n    OverlayV1PricePoint {\n\n    uint constant private ONE = 1e18;\n\n    bytes32 constant private COLLATERAL = keccak256(\"COLLATERAL\");\n    bytes32 constant private GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 constant private MARKET = keccak256(\"MARKET\");\n\n    address public immutable ovl;\n\n    IOverlayV1Mothership public immutable mothership;\n\n    uint256 public leverageMax;\n\n    mapping (address => bool) public isCollateral;\n\n    modifier onlyCollateral () {\n        require(isCollateral[msg.sender], \"OVLV1:!collateral\");\n        _;\n    }\n\n    modifier onlyGovernor () {\n        require(mothership.hasRole(GOVERNOR, msg.sender), \"OVLV1:!governor\");\n        _;\n    }\n\n    modifier enabled() {\n        require(mothership.hasRole(MARKET, address(this)), \"OVLV1:!enabled\");\n        _;\n    }\n\n    constructor(\n        address _mothership\n    ) {\n\n        mothership = IOverlayV1Mothership(_mothership);\n        ovl = address(IOverlayV1Mothership(_mothership).ovl());\n\n    }\n\n    function addCollateral (address _collateral) public onlyGovernor {\n\n        isCollateral[_collateral] = true;\n\n    }\n\n    function removeCollateral (address _collateral) public onlyGovernor {\n\n        isCollateral[_collateral] = false;\n\n    }\n\n    function setEverything (\n        uint256 _k,\n        uint256 _pbnj,\n        uint256 _compoundPeriod,\n        uint256 _lmbda,\n        uint256 _staticCap,\n        uint256 _brrrrdExpected,\n        uint256 _brrrrdWindowMacro,\n        uint256 _brrrrdWindowMicro\n    ) public onlyGovernor {\n\n        setK(_k);\n\n        setSpread(_pbnj);\n\n        setPeriods(\n            _compoundPeriod\n        );\n\n        setComptrollerParams(\n            _lmbda,\n            _staticCap,\n            _brrrrdExpected,\n            _brrrrdWindowMacro,\n            _brrrrdWindowMicro\n        );\n\n    }\n\n    function setSpread(\n        uint256 _pbnj\n    ) public onlyGovernor {\n\n        pbnj = _pbnj;\n\n    }\n\n    function setK (\n        uint256 _k\n    ) public onlyGovernor {\n        k = _k;\n    }\n\n    function setPeriods(\n        uint256 _compoundingPeriod\n    ) public onlyGovernor {\n\n        compoundingPeriod = _compoundingPeriod;\n\n    }\n\n    function setComptrollerParams (\n        uint256 _lmbda,\n        uint256 _staticCap,\n        uint256 _brrrrExpected,\n        uint256 _brrrrdWindowMacro,\n        uint256 _brrrrdWindowMicro\n    ) public onlyGovernor {\n\n        lmbda = _lmbda;\n        staticCap = _staticCap;\n        brrrrdExpected = _brrrrExpected;\n        brrrrdWindowMacro = _brrrrdWindowMacro;\n        brrrrdWindowMicro = _brrrrdWindowMicro;\n\n    }\n\n}\n\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../libraries/Position.sol\";\nimport \"../libraries/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\";\nimport \"../interfaces/IOverlayV1Market.sol\";\nimport \"../interfaces/IOverlayV1Mothership.sol\";\nimport \"../interfaces/IOverlayToken.sol\";\nimport \"../interfaces/IOverlayTokenNew.sol\";\n\ncontract OverlayV1OVLCollateral is ERC1155Supply {\n\n    event log(string k, uint v);\n    event log_addr(string k, address v);\n\n    using Position for Position.Info;\n    using FixedPoint for uint256;\n\n    bytes32 constant private GOVERNOR = keccak256(\"GOVERNOR\");\n\n    mapping (address => mapping(uint => uint)) internal currentBlockPositionsLong;\n    mapping (address => mapping(uint => uint)) internal currentBlockPositionsShort;\n    mapping (address => MarketInfo) public marketInfo;\n    struct MarketInfo {\n        uint marginMaintenance;\n        uint marginRewardRate;\n        uint maxLeverage;\n    }\n\n    Position.Info[] public positions;\n\n    IOverlayV1Mothership public immutable mothership;\n    IOverlayTokenNew immutable public ovl;\n\n    uint256 public fees;\n    uint256 public liquidations;\n\n    event Build(\n        address market,\n        uint256 positionId,\n        uint256 oi,\n        uint256 debt\n    );\n\n    event Unwind(\n        address market,\n        uint256 positionId,\n        uint256 oi,\n        uint256 debt\n    );\n\n    event Liquidate(\n        uint256 positionId,\n        uint256 oi,\n        uint256 reward,\n        address rewarded\n    );\n\n    event Update(\n        uint feesCollected,\n        uint feesBurned,\n        uint liquidationsCollected,\n        uint liquidationsBurned\n    );\n\n    modifier onlyGovernor () {\n        require(mothership.hasRole(GOVERNOR, msg.sender), \"OVLV1:!governor\");\n        _;\n    }\n\n    constructor (\n        string memory _uri,\n        address _mothership\n    ) ERC1155(_uri) {\n\n        mothership = IOverlayV1Mothership(_mothership);\n\n        ovl = IOverlayV1Mothership(_mothership).ovl();\n\n        positions.push(Position.Info({\n            market: address(0),\n            isLong: false,\n            leverage: 0,\n            pricePoint: 0,\n            oiShares: 0,\n            debt: 0,\n            cost: 0\n        }));\n\n    }\n\n    function setMarketInfo (\n        address _market,\n        uint _marginMaintenance,\n        uint _marginRewardRate,\n        uint _maxLeverage\n    ) external onlyGovernor {\n\n        marketInfo[_market].marginMaintenance = _marginMaintenance;\n        marketInfo[_market].marginRewardRate = _marginRewardRate;\n        marketInfo[_market].maxLeverage = _maxLeverage;\n\n    }\n\n    function marginMaintenance(\n        address _market\n    ) external view returns (\n        uint marginMaintenance_\n    ) {\n\n        marginMaintenance_ = marketInfo[_market].marginMaintenance;\n\n    }\n\n    function maxLeverage(\n        address _market\n    ) external view returns (\n        uint maxLeverage_\n    ) {\n\n        maxLeverage_ = marketInfo[_market].maxLeverage;\n\n    }\n\n    function marginRewardRate(\n        address _market\n    ) external view returns (\n        uint marginRewardRate_\n    ) {\n\n        marginRewardRate_ = marketInfo[_market].marginRewardRate;\n\n    }\n\n\n    /// @notice Disburses fees\n    function disburse () public {\n\n        (   uint256 _marginBurnRate,\n            uint256 _feeBurnRate,\n            address _feeTo ) = mothership.getUpdateParams();\n\n        uint _feeForward = fees;\n        uint _feeBurn = _feeForward.mulUp(_feeBurnRate);\n        _feeForward = _feeForward - _feeBurn;\n\n        uint _liqForward = liquidations;\n        uint _liqBurn = _liqForward.mulUp(_marginBurnRate);\n        _liqForward -= _liqBurn;\n\n        fees = 0;\n        liquidations = 0;\n\n        emit Update(\n            _feeForward,\n            _feeBurn,\n            _liqForward,\n            _liqBurn\n        );\n\n        ovl.burn(address(this), _feeBurn + _liqBurn);\n        ovl.transfer(_feeTo, _feeForward + _liqForward);\n\n    }\n\n    function getCurrentBlockPositionId (\n        address _market,\n        bool _isLong,\n        uint _leverage,\n        uint _pricePointNext\n    ) internal returns (\n        uint positionId_\n    ) {\n\n        mapping(uint=>uint) storage _currentBlockPositions = _isLong\n            ? currentBlockPositionsLong[_market]\n            : currentBlockPositionsShort[_market];\n\n        positionId_ = _currentBlockPositions[_leverage];\n\n        Position.Info storage position = positions[positionId_];\n\n        if (position.pricePoint < _pricePointNext) {\n\n            positions.push(Position.Info({\n                market: _market,\n                isLong: _isLong,\n                leverage: _leverage,\n                pricePoint: _pricePointNext,\n                oiShares: 0,\n                debt: 0,\n                cost: 0\n            }));\n\n            positionId_ = positions.length - 1;\n\n            _currentBlockPositions[_leverage] = positionId_;\n\n        }\n\n    }\n\n\n    /// @notice Build a position on Overlay with OVL collateral\n    /// @dev This interacts with an Overlay Market to register oi and hold \n    /// positions on behalf of users.\n    /// @param _market The address of the desired market to interact with.\n    /// @param _collateral The amount of OVL to use as collateral in the position.\n    /// @param _leverage The amount of leverage to use in the position\n    /// @param _isLong Whether to take out a position on the long or short side.\n    /// @param _oiMinimum Minimum acceptable amount of OI after impact and fees.\n    /// @return positionId_ Id of the built position for on chain convenience.\n    function build (\n        address _market,\n        uint256 _collateral,\n        uint256 _leverage,\n        bool _isLong,\n        uint256 _oiMinimum\n    ) external returns (\n        uint positionId_\n    ) {\n\n        require(mothership.marketActive(_market), \"OVLV1:!market\");\n        require(_leverage <= marketInfo[_market].maxLeverage, \"OVLV1:lev>max\");\n\n        (   uint _oiAdjusted,\n            uint _collateralAdjusted,\n            uint _debtAdjusted,\n            uint _fee,\n            uint _impact,\n            uint _pricePointNext ) = IOverlayV1Market(_market)\n                .enterOI(\n                    _isLong,\n                    _collateral,\n                    _leverage\n                );\n\n        require(_oiAdjusted >= _oiMinimum, \"OVLV1:oi<min\");\n\n        uint _positionId = getCurrentBlockPositionId(\n            _market,\n            _isLong,\n            _leverage,\n            _pricePointNext\n        );\n\n        Position.Info storage pos = positions[_positionId];\n\n        pos.oiShares += _oiAdjusted;\n        pos.cost += _collateralAdjusted;\n        pos.debt += _debtAdjusted;\n\n        fees += _fee;\n\n        emit Build(_market, _positionId, _oiAdjusted, _debtAdjusted);\n\n        ovl.transferFromBurn(msg.sender, address(this), _collateralAdjusted + _fee, _impact);\n\n        // ovl.burn(msg.sender, _impact);\n\n        _mint(msg.sender, _positionId, _oiAdjusted, \"\"); // WARNING: last b/c erc1155 callback\n\n        positionId_ = _positionId;\n\n    }\n\n    /// @notice Unwinds shares of an existing position.\n    /// @dev Interacts with a market contract to realize the PnL on a position.\n    /// @param _positionId Id of the position to be unwound.\n    /// @param _shares Number of shars to unwind from the position.\n    function unwind (\n        uint256 _positionId,\n        uint256 _shares\n    ) external {\n\n        require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), \"OVLV1:!shares\");\n\n        Position.Info storage pos = positions[_positionId];\n\n        require(0 < pos.oiShares, \"OVLV1:liquidated\");\n\n        {\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = IOverlayV1Market(pos.market)\n                .exitData(\n                    pos.isLong,\n                    pos.pricePoint\n                );\n\n        uint _totalPosShares = totalSupply(_positionId);\n\n        uint _userOiShares = _shares;\n        uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;\n        uint _userDebt = _shares * pos.debt / _totalPosShares;\n        uint _userCost = _shares * pos.cost / _totalPosShares;\n        uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;\n\n        emit Unwind(pos.market, _positionId, _userOi, _userDebt);\n\n        // TODO: think through edge case of underwater position ... and fee adjustments ...\n        uint _feeAmount = _userNotional.mulUp(mothership.fee());\n\n        uint _userValueAdjusted = _userNotional - _feeAmount;\n        if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt;\n        else _userValueAdjusted = 0;\n\n        fees += _feeAmount; // adds to fee pot, which is transferred on update\n\n        pos.debt -= _userDebt;\n        pos.cost -= _userCost;\n        pos.oiShares -= _userOiShares;\n\n        // ovl.transfer(msg.sender, _userCost);\n\n        // mint/burn excess PnL = valueAdjusted - cost\n        if (_userCost < _userValueAdjusted) {\n\n            ovl.transferMint(\n                msg.sender, \n                _userCost, \n                _userValueAdjusted - _userCost\n            );\n\n        } else {\n\n            ovl.transferBurn(\n                msg.sender, \n                _userValueAdjusted, \n                _userCost - _userValueAdjusted\n            );\n\n        }\n\n\n        IOverlayV1Market(pos.market).exitOI(\n            pos.isLong,\n            _userOi,\n            _userOiShares,\n            _userCost < _userValueAdjusted ? _userValueAdjusted - _userCost : 0,\n            _userCost < _userValueAdjusted ? 0 : _userCost - _userValueAdjusted\n        );\n\n        }\n\n        _burn(msg.sender, _positionId, _shares);\n\n    }\n\n    /// @notice Liquidates an existing position.\n    /// @dev Interacts with an Overlay Market to exit all open interest\n    /// associated with a liquidatable positoin.\n    /// @param _positionId ID of the position being liquidated.\n    /// @param _rewardsTo Address to send liquidation reward to.\n    function liquidate (\n        uint256 _positionId,\n        address _rewardsTo\n    ) external {\n\n        Position.Info storage pos = positions[_positionId];\n\n        require(0 < pos.oiShares, \"OVLV1:liquidated\");\n\n        bool _isLong = pos.isLong;\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = IOverlayV1Market(pos.market)\n                .exitData(\n                    _isLong,\n                    pos.pricePoint\n                );\n\n        MarketInfo memory _marketInfo = marketInfo[pos.market];\n\n        require(pos.isLiquidatable(\n            _oi,\n            _oiShares,\n            _priceFrame,\n            _marketInfo.marginMaintenance\n        ), \"OVLV1:!liquidatable\");\n\n        uint _value = pos.value(_oi, _oiShares, _priceFrame);\n\n        IOverlayV1Market(pos.market).exitOI(\n            _isLong,\n            pos.oi(_oi, _oiShares),\n            pos.oiShares,\n            0,\n            pos.cost - _value\n        );\n\n        // TODO: which is better on gas\n        pos.oiShares = 0;\n        pos.debt = 0;\n        // positions[positionId].oiShares = 0;\n\n        uint _toReward = _value.mulUp(_marketInfo.marginRewardRate);\n\n        liquidations += _value - _toReward;\n\n        emit Liquidate(\n            _positionId,\n            _oi,\n            _toReward,\n            _rewardsTo\n        );\n\n        // ovl.burn(address(this), pos.cost - _value);\n        ovl.transferBurn(_rewardsTo, _toReward, pos.cost - _value);\n\n    }\n\n\n    /// @notice Retrieves required information from market contract \n    /// to calculate position value with.\n    /// @dev Gets price frame, total open interest and \n    /// total open interest shares from an Overlay market.\n    /// @param _positionId ID of position to determine value of.\n    /// @return value_ Value of the position\n    function value (\n        uint _positionId\n    ) public view returns (\n        uint256 value_\n    ) {\n\n        Position.Info storage pos = positions[_positionId];\n\n        IOverlayV1Market _market = IOverlayV1Market(pos.market);\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = _market\n            .positionInfo(\n                pos.isLong,\n                pos.pricePoint\n            );\n\n        value_ = pos.value(\n            _oi,\n            _oiShares,\n            _priceFrame\n        );\n\n    }\n\n}\n\n\n",
        "CodeNames": [
            "OverlayV1Governance.sol",
            "OverlayV1OVLCollateral.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OverlayV1OVLCollateral and OverlayV1Governance contracts",
                "Type": "Smart Contract Vulnerability",
                "Description": "The cached version of the ovl address in the OverlayV1OVLCollateral and OverlayV1Governance contracts may be outdated if the governor points it to a new address using the setter function in the mothership contract. Consider removing the cached version and always fetch on the go (this will increase the gas costs though).",
                "Repair": "Remove the cached version and always fetch on the go"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\ncontract OverlayToken is AccessControlEnumerable, ERC20(\"Overlay\", \"OVL\") {\n\n  bytes32 public constant ADMIN_ROLE = 0x00;\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURNER\");\n\n  constructor() {\n\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(MINTER_ROLE, msg.sender);\n    _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(BURNER_ROLE, ADMIN_ROLE);\n\n  }\n\n  modifier onlyMinter() {\n    require(hasRole(MINTER_ROLE, msg.sender), \"only minter\");\n    _;\n  }\n\n  modifier onlyBurner() {\n    require(hasRole(BURNER_ROLE, msg.sender), \"only burner\");\n    _;\n  }\n\n  function mint(address _recipient, uint256 _amount) external onlyMinter {\n      _mint(_recipient, _amount);\n  }\n\n  function burn(address _account, uint256 _amount) external onlyBurner {\n      _burn(_account, _amount);\n  }\n}\n\n\n",
        "CodeNames": [
            "OverlayToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OverlayToken.sol contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "The _totalSupply variable in the OverlayToken.sol contract is not updated in the _transferMint() and _transferBurn() functions, which means that _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens. Consider updating _totalSupply in _transferMint() and _transferBurn().",
                "Repair": "Update _totalSupply in _transferMint() and _transferBurn()"
            },
            {
                "Location": "burn function in OverlayToken.sol",
                "Type": "Burn Function Could Burn Tokens of Any User",
                "Description": "The burner could burn any amount of tokens of any user.",
                "Repair": "Add onlyBurner modifier with access control privileges to prevent unexpected burn amounts, given only collateral managers are given burn permissions"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity ^0.8.7;\n\nimport \"../utils/Errors.sol\";\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\n        int256 x_int256 = int256(x);\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\n        int256 y_int256 = int256(y);\n\n        int256 logx_times_y;\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n            int256 ln_36_x = _ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n        } else {\n            logx_times_y = _ln(x_int256) * y_int256;\n        }\n        logx_times_y /= ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        _require(\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n            Errors.PRODUCT_OUT_OF_BOUNDS\n        );\n\n        return uint256(exp(logx_times_y));\n\n        }\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\n\n        unchecked {\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return ((ONE_18 * ONE_18) / exp(-x));\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        int256 firstAN;\n        if (x >= x0) {\n            x -= x0;\n            firstAN = a0;\n        } else if (x >= x1) {\n            x -= x1;\n            firstAN = a1;\n        } else {\n            firstAN = 1; // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        int256 product = ONE_20;\n\n        if (x >= x2) {\n            x -= x2;\n            product = (product * a2) / ONE_20;\n        }\n        if (x >= x3) {\n            x -= x3;\n            product = (product * a3) / ONE_20;\n        }\n        if (x >= x4) {\n            x -= x4;\n            product = (product * a4) / ONE_20;\n        }\n        if (x >= x5) {\n            x -= x5;\n            product = (product * a5) / ONE_20;\n        }\n        if (x >= x6) {\n            x -= x6;\n            product = (product * a6) / ONE_20;\n        }\n        if (x >= x7) {\n            x -= x7;\n            product = (product * a7) / ONE_20;\n        }\n        if (x >= x8) {\n            x -= x8;\n            product = (product * a8) / ONE_20;\n        }\n        if (x >= x9) {\n            x -= x9;\n            product = (product * a9) / ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = ((term * x) / ONE_20) / 2;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 3;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 4;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 5;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 6;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 7;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 8;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 9;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 10;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 11;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 12;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n\n        }\n\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n        // upscaling.\n\n        unchecked {\n\n        int256 logBase;\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n            logBase = _ln_36(base);\n        } else {\n            logBase = _ln(base) * ONE_18;\n        }\n\n        int256 logArg;\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n            logArg = _ln_36(arg);\n        } else {\n            logArg = _ln(arg) * ONE_18;\n        }\n\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n        return (logArg * ONE_18) / logBase;\n\n        }\n\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        // The real natural logarithm is not defined for negative numbers or zero.\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n            return _ln_36(a) / ONE_18;\n        } else {\n            return _ln(a);\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n\n        unchecked {\n\n        if (a < ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by ONE_18.\n            return (-_ln((ONE_18 * ONE_18) / a));\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        int256 sum = 0;\n        if (a >= a0 * ONE_18) {\n            a /= a0; // Integer, not fixed point division\n            sum += x0;\n        }\n\n        if (a >= a1 * ONE_18) {\n            a /= a1; // Integer, not fixed point division\n            sum += x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= 100;\n        a *= 100;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= a2) {\n            a = (a * ONE_20) / a2;\n            sum += x2;\n        }\n\n        if (a >= a3) {\n            a = (a * ONE_20) / a3;\n            sum += x3;\n        }\n\n        if (a >= a4) {\n            a = (a * ONE_20) / a4;\n            sum += x4;\n        }\n\n        if (a >= a5) {\n            a = (a * ONE_20) / a5;\n            sum += x5;\n        }\n\n        if (a >= a6) {\n            a = (a * ONE_20) / a6;\n            sum += x6;\n        }\n\n        if (a >= a7) {\n            a = (a * ONE_20) / a7;\n            sum += x7;\n        }\n\n        if (a >= a8) {\n            a = (a * ONE_20) / a8;\n            sum += x8;\n        }\n\n        if (a >= a9) {\n            a = (a * ONE_20) / a9;\n            sum += x9;\n        }\n\n        if (a >= a10) {\n            a = (a * ONE_20) / a10;\n            sum += x10;\n        }\n\n        if (a >= a11) {\n            a = (a * ONE_20) / a11;\n            sum += x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n        int256 z_squared = (z * z) / ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 11;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100;\n\n        }\n\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n\n        unchecked {\n\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n        int256 z_squared = (z * z) / ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 11;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 13;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 15;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2;\n\n        }\n\n    }\n}\n\n",
        "CodeNames": [
            "LogExpMath.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "pow() function in LogExpMath.sol",
                "Type": "Missing Check on Input Parameters",
                "Description": "This omission might lead to unexpected results.",
                "Repair": "Check if the extra code of the balancer contract is useful and if so add it"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./libraries/FixedPoint.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol\";\nimport \"./interfaces/IUniswapV3Pool.sol\";\nimport \"./market/OverlayV1Market.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/TickMath.sol\";\n\ncontract OverlayV1UniswapV3Market is OverlayV1Market {\n\n    using FixedPoint for uint256;\n\n    uint256 internal X96 = 0x1000000000000000000000000;\n\n    uint256 public immutable macroWindow; // window size for main TWAP\n    uint256 public immutable microWindow; // window size for bid/ask TWAP\n\n    address public immutable marketFeed;\n    address public immutable ovlFeed;\n    address public immutable base;\n    address public immutable quote;\n    uint128 internal immutable baseAmount;\n\n    address internal immutable eth;\n    bool internal immutable ethIs0;\n\n    constructor(\n        address _mothership,\n        address _ovlFeed,\n        address _marketFeed,\n        address _quote,\n        address _eth,\n        uint128 _baseAmount,\n        uint256 _macroWindow,\n        uint256 _microWindow,\n        uint256 _priceFrameCap\n    ) OverlayV1Market (\n        _mothership\n    ) OverlayV1Comptroller (\n        _microWindow\n    ) OverlayV1OI (\n        _microWindow\n    ) OverlayV1PricePoint (\n        _priceFrameCap\n    ) {\n\n        // immutables\n        eth = _eth;\n        ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\n        ovlFeed = _ovlFeed;\n        marketFeed = _marketFeed;\n        baseAmount = _baseAmount;\n        macroWindow = _macroWindow;\n        microWindow = _microWindow;\n\n        address _token0 = IUniswapV3Pool(_marketFeed).token0();\n        address _token1 = IUniswapV3Pool(_marketFeed).token1();\n\n        base = _token0 != _quote ? _token0 : _token1;\n        quote = _token0 == _quote ? _token0 : _token1;\n\n        int24 _tick = OracleLibraryV2.consult(\n            _marketFeed,\n            uint32(_macroWindow),\n            uint32(0)\n        );\n\n        _pricePoints.push(PricePoint(\n            _tick, \n            _tick, \n            0\n        ));\n\n        uint _price = OracleLibraryV2.getQuoteAtTick(\n            _tick,\n            uint128(_baseAmount),\n            _token0 != _quote ? _token0 : _token1,\n            _token0 == _quote ? _token0 : _token1\n        );\n\n        emit NewPricePoint(_price, _price, 0);\n\n    }\n\n\n    /// @notice Reads the current price and depth information\n    /// @dev Reads price and depth of market feed\n    /// @return price_ Price point\n    function fetchPricePoint () public view override returns (\n        PricePoint memory price_\n    ) {\n\n        int56[] memory _ticks;\n        uint160[] memory _liqs;\n\n        uint _ovlPrice;\n        uint _marketLiquidity;\n\n        int24 _microTick;\n        int24 _macroTick;\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](3);\n            _secondsAgo[2] = uint32(macroWindow);\n            _secondsAgo[1] = uint32(microWindow);\n\n            ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n\n            _macroTick = int24(( _ticks[0] - _ticks[2]) / int56(int32(int(macroWindow))));\n\n            _microTick = int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))));\n\n            uint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);\n\n            uint _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );\n\n            _marketLiquidity = ethIs0\n                ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n                : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n\n        }\n\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](2);\n\n            _secondsAgo[1] = uint32(macroWindow);\n\n            ( _ticks, ) = IUniswapV3Pool(ovlFeed).observe(_secondsAgo);\n\n            _ovlPrice = OracleLibraryV2.getQuoteAtTick(\n                int24((_ticks[0] - _ticks[1]) / int56(int32(int(macroWindow)))),\n                1e18,\n                ovl,\n                eth\n            );\n\n        }\n\n        price_ = PricePoint(\n            _microTick, \n            _macroTick, \n            computeDepth(_marketLiquidity, _ovlPrice)\n        );\n\n    }\n\n\n    /// @notice Arithmetic to get depth\n    /// @dev Derived from cnstant product formula X*Y=K and tailored \n    /// to Uniswap V3 selective liquidity provision.\n    /// @param _marketLiquidity Amount of liquidity in market in ETH terms.\n    /// @param _ovlPrice Price of OVL against ETH.\n    /// @return depth_ Depth criteria for market in OVL terms.\n    function computeDepth (\n        uint _marketLiquidity,\n        uint _ovlPrice\n    ) public override view returns (\n        uint depth_\n    ) {\n\n        depth_ = ((_marketLiquidity * 1e18) / _ovlPrice)\n            .mulUp(lmbda)    \n            .divDown(2e18);\n\n    }\n\n    function _tickToPrice (\n        int24 _tick\n    ) public override view returns (\n        uint quote_\n    ) {\n\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(_tick);\n\n        // better precision if no overflow when squared\n        if (sqrtRatioX96 <= type(uint128).max) {\n\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n\n            quote_ = base < quote\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n\n        } else {\n\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n\n            quote_ = base < quote\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n\n        }\n\n    }\n\n}\n\n\n",
        "CodeNames": [
            "OverlayV1UniswapV3Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "fetchPricePoint function in OverlayV1UniswapV3Market",
                "Type": "Computes Wrong Market Liquidity",
                "Description": "If the ovlFeed and marketFeed do not have the same token position for the ETH pair, then the market liquidity & depth is computed wrong (inverted).",
                "Repair": "Use marketFeed.token0() == WETH to compute the liquidity instead of ovlFeed.token0() == WETH"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./FixedPoint.sol\";\n\nlibrary Position {\n\n    using FixedPoint for uint256;\n\n    struct Info {\n        address market; // the market for the position\n        bool isLong; // whether long or short\n        uint leverage; // discrete initial leverage amount\n        uint pricePoint; // pricePointIndex\n        uint256 oiShares; // shares of total open interest on long/short side, depending on isLong value\n        uint256 debt; // total debt associated with this position\n        uint256 cost; // total amount of collateral initially locked; effectively, cost to enter position\n    }\n\n    uint256 constant TWO = 2e18;\n\n    function _initialOi (\n        Info memory _self\n    ) private pure returns (\n        uint initialOi_\n    ) {\n\n        initialOi_ = _self.cost + _self.debt;\n\n    }\n\n    function _oi (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares\n    ) private pure returns (uint256 oi_) {\n\n        oi_ = _self.oiShares\n            .mulDown(totalOi)\n            .divUp(totalOiShares);\n\n    }\n\n    /// @dev Floors to zero, so won't properly compute if self is underwater\n    function _value (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (uint256 val_) {\n\n        uint256 __oi = _oi(_self, totalOi, totalOiShares);\n\n        if (_self.isLong) { // oi * priceFrame - debt\n\n            val_ = __oi.mulDown(priceFrame);\n            val_ -= Math.min(val_, _self.debt); // floor to 0\n\n        } else { // oi * (2 - priceFrame) - debt\n\n            val_ = __oi.mulDown(2e18);\n            val_ -= Math.min(val_, _self.debt + __oi.mulDown(priceFrame)); // floor to 0\n\n        }\n\n    }\n\n    /// @dev is true when position value < 0\n    function _isUnderwater(\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (bool isUnder) {\n\n        uint256 __oi = _oi(_self, totalOi, totalOiShares);\n\n        bool _long = _self.isLong;\n\n        if (_long) isUnder = __oi.mulDown(priceFrame) < _self.debt;\n        else isUnder = __oi.mulDown(priceFrame) + _self.debt < ( __oi * 2 );\n\n    }\n\n    /// @dev Floors to _self.debt, so won't properly compute if _self is underwater\n    function _notional (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (uint256 notion) {\n\n        uint256 val = _value(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n        notion = val + _self.debt;\n\n    }\n\n    /// @dev ceils uint256.max if position value <= 0\n    function _openLeverage (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (uint lev) {\n\n        uint val = _value(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n        if (val != 0) {\n\n            uint256 notion = _notional(\n                _self,\n                totalOi,\n                totalOiShares,\n                priceFrame\n            );\n\n            lev = notion.divDown(val);\n\n        } else lev = type(uint256).max;\n\n    }\n\n    /// @dev floors zero if position value <= 0; equiv to 1 / open leverage\n    function _openMargin (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (uint margin) {\n\n        uint notion = _notional(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n        if (notion != 0) {\n\n            uint256 val = _value(\n                _self,\n                totalOi,\n                totalOiShares,\n                priceFrame\n            );\n\n            margin = val.divDown(notion);\n\n        } else margin = 0;\n\n    }\n\n    /// @dev is true when open margin < maintenance margin\n    function _isLiquidatable (\n        Info memory _self,\n        uint256 _totalOi,\n        uint256 _totalOiShares,\n        uint256 _priceFrame,\n        uint256 _marginMaintenance\n    ) private pure returns (\n        bool can_\n    ) {\n\n        uint _val = _value(\n            _self,\n            _totalOi,\n            _totalOiShares,\n            _priceFrame\n        );\n\n        uint _initOi = _initialOi(_self);\n\n        uint _maintenanceMargin = _initOi.mulUp(_marginMaintenance);\n\n        can_ = _val < _maintenanceMargin;\n\n    }\n\n    function _liquidationPrice (\n        Info memory _self,\n        uint256 _totalOi,\n        uint256 _totalOiShares,\n        uint256 _priceEntry,\n        uint256 _marginMaintenance\n    ) private pure returns (uint256 liqPrice) {\n\n        uint256 _posOi = _oi(_self, _totalOi, _totalOiShares);\n        uint256 _posInitialOi = _initialOi(_self);\n\n        uint256 _oiFrame = _posInitialOi.mulUp(_marginMaintenance)\n            .add(_self.debt)\n            .divDown(_posOi);\n\n        if (_self.isLong) liqPrice = _priceEntry.mulUp(_oiFrame);\n        else liqPrice = _priceEntry.mulUp(TWO.sub(_oiFrame));\n\n    }\n\n    function initialOi (\n        Info storage self\n    ) internal view returns (\n        uint256 initialOi_\n    ) {\n\n        Info memory _self = self;\n\n        initialOi_ = _initialOi(_self);\n\n    }\n\n    /// @notice Computes the open interest of a position\n    function oi (\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares\n    ) internal view returns (uint256) {\n\n        Info memory _self = self;\n\n        return _oi(_self, totalOi, totalOiShares);\n\n    }\n\n    /// @notice Computes the value of a position\n    /// @dev Floors to zero, so won't properly compute if self is underwater\n    function value(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (uint256) {\n\n        Info memory _self = self;\n\n        return _value(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Whether position is underwater\n    /// @dev is true when position value <= 0\n    function isUnderwater(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (bool) {\n\n        Info memory _self = self;\n\n        return _isUnderwater(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Computes the notional of a position\n    /// @dev Floors to _self.debt if value <= 0\n    function notional(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (uint256) {\n\n        Info memory _self = self;\n\n        return _notional(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Computes the open leverage of a position\n    /// @dev ceils uint256.max if position value <= 0\n    function openLeverage(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (uint) {\n\n        Info memory _self = self;\n\n        return _openLeverage(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Computes the open margin of a position\n    /// @dev floors zero if position value <= 0\n    function openMargin(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (uint) {\n\n        Info memory _self = self;\n\n        return _openMargin(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Whether a position can be liquidated\n    /// @dev is true when value < maintenance margin\n    function isLiquidatable(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame,\n        uint256 marginMaintenance\n    ) internal view returns (bool) {\n\n        Info memory _self = self;\n\n        return _isLiquidatable(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame,\n            marginMaintenance\n        );\n\n    }\n\n    /// @notice Computes the liquidation price of a position\n    /// @dev price when value < maintenance margin\n    function liquidationPrice(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceEntry,\n        uint256 marginMaintenance\n    ) internal view returns (\n        uint256 liquidationPrice_\n    ) {\n\n        Info memory _self = self;\n\n        liquidationPrice_ = _liquidationPrice(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceEntry,\n            marginMaintenance\n        );\n\n    }\n}\n\n\n",
        "CodeNames": [
            "Position.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "isUnderwater function in Position.sol",
                "Type": "Returns Opposite Boolean for Short Positions",
                "Description": "The function will return the opposite of what it should when called on short positions.",
                "Repair": "Flip the left and right side of the inequality for short positions in isUnderwater"
            }
        ]
    }
]