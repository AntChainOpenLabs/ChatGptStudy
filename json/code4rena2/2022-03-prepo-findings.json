[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ICollateral.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"./interfaces/IHook.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract Collateral is\n    ICollateral,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bool private _depositsAllowed;\n    bool private _withdrawalsAllowed;\n    address private _treasury;\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n    IERC20Upgradeable private _baseToken;\n    IStrategyController private _strategyController;\n\n    uint256 private _delayedWithdrawalExpiry;\n    mapping(address => WithdrawalRequest) private _accountToWithdrawalRequest;\n\n    IHook private _depositHook;\n    IHook private _withdrawHook;\n\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    function initialize(address _newBaseToken, address _newTreasury)\n        public\n        initializer\n    {\n        __Ownable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __ERC20_init_unchained(\n            string(\"prePO Collateral Token\"),\n            string(\"preCT\")\n        );\n        _baseToken = IERC20Upgradeable(_newBaseToken);\n        _treasury = _newTreasury;\n    }\n\n    function deposit(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_depositsAllowed, \"Deposits not allowed\");\n        _baseToken.safeTransferFrom(msg.sender, address(this), _amount);\n        // Calculate fees and shares to mint including latent contract funds\n        uint256 _amountToDeposit = _baseToken.balanceOf(address(this));\n        // Record deposit before fee is taken\n        if (address(_depositHook) != address(0)) {\n            _depositHook.hook(msg.sender, _amount, _amountToDeposit);\n        }\n        /**\n         * Add 1 to avoid rounding to zero, only process deposit if user is\n         * depositing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amountToDeposit > _fee, \"Deposit amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        _amountToDeposit -= _fee;\n\n        uint256 _valueBefore = _strategyController.totalValue();\n        _baseToken.approve(address(_strategyController), _amountToDeposit);\n        _strategyController.deposit(_amountToDeposit);\n        uint256 _valueAfter = _strategyController.totalValue();\n        _amountToDeposit = _valueAfter - _valueBefore;\n\n        uint256 _shares = 0;\n        if (totalSupply() == 0) {\n            _shares = _amountToDeposit;\n        } else {\n            /**\n             * # of shares owed = amount deposited / cost per share, cost per\n             * share = total supply / total value.\n             */\n            _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);\n        }\n        _mint(msg.sender, _shares);\n        return _shares;\n    }\n\n    function initiateWithdrawal(uint256 _amount) external override {\n        /**\n         * Checking the balance before initiation is necessary since a user\n         * could initiate an unlimited withdrawal amount ahead of time,\n         * negating the protection a delayed withdrawal offers.\n         */\n        require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");\n        _accountToWithdrawalRequest[msg.sender].amount = _amount;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;\n    }\n\n    function uninitiateWithdrawal() external override {\n        _accountToWithdrawalRequest[msg.sender].amount = 0;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = 0;\n    }\n\n    function _processDelayedWithdrawal(address _account, uint256 _amount)\n        internal\n    {\n        /**\n         * Verify that the withdrawal being processed matches what was\n         * recorded during initiation.\n         */\n        require(\n            _accountToWithdrawalRequest[_account].amount == _amount,\n            \"Initiated amount does not match\"\n        );\n        uint256 _recordedBlock = _accountToWithdrawalRequest[_account]\n            .blockNumber;\n        require(\n            _recordedBlock + _delayedWithdrawalExpiry >= block.number,\n            \"Must withdraw before expiry\"\n        );\n        require(\n            block.number > _recordedBlock,\n            \"Must withdraw in a later block\"\n        );\n        // Reset the initiation prior to withdrawal.\n        _accountToWithdrawalRequest[_account].amount = 0;\n        _accountToWithdrawalRequest[_account].blockNumber = 0;\n    }\n\n    function withdraw(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_withdrawalsAllowed, \"Withdrawals not allowed\");\n        if (_delayedWithdrawalExpiry != 0) {\n            _processDelayedWithdrawal(msg.sender, _amount);\n        }\n        uint256 _owed = (_strategyController.totalValue() * _amount) /\n            totalSupply();\n        _burn(msg.sender, _amount);\n\n        uint256 _balanceBefore = _baseToken.balanceOf(address(this));\n        _strategyController.withdraw(address(this), _owed);\n        uint256 _balanceAfter = _baseToken.balanceOf(address(this));\n\n        uint256 _amountWithdrawn = _balanceAfter - _balanceBefore;\n        // Record withdrawal before fee is taken\n        if (address(_withdrawHook) != address(0)) {\n            _withdrawHook.hook(msg.sender, _amount, _amountWithdrawn);\n        }\n\n        /**\n         * Send redemption fee to the protocol treasury. Add 1 to avoid\n         * rounding to zero, only process withdrawal if user is\n         * withdrawing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountWithdrawn * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_amountWithdrawn > _fee, \"Withdrawal amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        _amountWithdrawn -= _fee;\n        _baseToken.safeTransfer(msg.sender, _amountWithdrawn);\n        return _amountWithdrawn;\n    }\n\n    function setDepositsAllowed(bool _allowed) external override onlyOwner {\n        _depositsAllowed = _allowed;\n        emit DepositsAllowedChanged(_allowed);\n    }\n\n    function setWithdrawalsAllowed(bool _allowed) external override onlyOwner {\n        _withdrawalsAllowed = _allowed;\n        emit WithdrawalsAllowedChanged(_allowed);\n    }\n\n    function setStrategyController(IStrategyController _newStrategyController)\n        external\n        override\n        onlyOwner\n    {\n        _strategyController = _newStrategyController;\n        emit StrategyControllerChanged(address(_strategyController));\n    }\n\n    function setDelayedWithdrawalExpiry(uint256 _newDelayedWithdrawalExpiry)\n        external\n        override\n        onlyOwner\n    {\n        _delayedWithdrawalExpiry = _newDelayedWithdrawalExpiry;\n        emit DelayedWithdrawalExpiryChanged(_delayedWithdrawalExpiry);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_mintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_redemptionFee);\n    }\n\n    function setDepositHook(IHook _newDepositHook)\n        external\n        override\n        onlyOwner\n    {\n        _depositHook = _newDepositHook;\n        emit DepositHookChanged(address(_depositHook));\n    }\n\n    function setWithdrawHook(IHook _newWithdrawHook)\n        external\n        override\n        onlyOwner\n    {\n        _withdrawHook = _newWithdrawHook;\n        emit WithdrawHookChanged(address(_withdrawHook));\n    }\n\n    function getDepositsAllowed() external view override returns (bool) {\n        return _depositsAllowed;\n    }\n\n    function getWithdrawalsAllowed() external view override returns (bool) {\n        return _withdrawalsAllowed;\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getBaseToken()\n        external\n        view\n        override\n        returns (IERC20Upgradeable)\n    {\n        return _baseToken;\n    }\n\n    function getStrategyController()\n        external\n        view\n        override\n        returns (IStrategyController)\n    {\n        return _strategyController;\n    }\n\n    function getDelayedWithdrawalExpiry()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _delayedWithdrawalExpiry;\n    }\n\n    function getWithdrawalRequest(address _account)\n        external\n        view\n        override\n        returns (WithdrawalRequest memory)\n    {\n        return _accountToWithdrawalRequest[_account];\n    }\n\n    function getDepositHook() external view override returns (IHook) {\n        return _depositHook;\n    }\n\n    function getWithdrawHook() external view override returns (IHook) {\n        return _withdrawHook;\n    }\n\n    function getAmountForShares(uint256 _shares)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() == 0) {\n            return _shares;\n        }\n        return (_shares * totalAssets()) / totalSupply();\n    }\n\n    function getSharesForAmount(uint256 _amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _totalAssets = totalAssets();\n        return\n            (_totalAssets > 0)\n                ? ((_amount * totalSupply()) / _totalAssets)\n                : 0;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return\n            _baseToken.balanceOf(address(this)) +\n            _strategyController.totalValue();\n    }\n}\n\n\n",
        "CodeNames": [
            "Collateral.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Collateral.sol#L82-L91",
                "Type": "First depositor can break minting of shares",
                "Description": "Users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.",
                "Repair": "Send the first min liquidity LP tokens to the zero address to enable share dilution when totalSupply() == 0, ensure the number of shares to be minted is non-zero, create a periphery contract that contains a wrapper function that atomically calls initialize() and deposit(), call deposit() once in initialize() to achieve the same effect as the suggestion above."
            },
            {
                "Location": "Collateral.sol#L97",
                "Type": "Withdrawal delay can be circumvented",
                "Description": "After initiating a withdrawal with initiateWithdrawal, it's still possible to transfer the collateral tokens, allowing for a user to always be in a valid withdrawal window.",
                "Repair": "Disable transfers for the token owner if there's a withdrawal request (_accountToWithdrawalRequest[owner].blockNumber > 0), check if the transfer is still within the withdrawal window before allowing it."
            },
            {
                "Location": "Collateral.sol",
                "Type": "Smart Contract Logic",
                "Description": "Wrong formula of getSharesForAmount() can potentially cause fund loss when being used to calculate the shares to be used in withdraw()",
                "Repair": "Change Collateral.totalValue() to only return _strategyController.totalValue()"
            },
            {
                "Location": "Collateral.sol",
                "Type": "Smart Contract Logic",
                "Description": "getSharesForAmount returns wrong value when totalAssets == 0",
                "Repair": "Add a check in the getSharesForAmount() function to return _amount when totalSupply() == 0"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./LongShortToken.sol\";\nimport \"./PrePOMarket.sol\";\nimport \"./interfaces/ILongShortToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/IPrePOMarketFactory.sol\";\n\ncontract PrePOMarketFactory is\n    IPrePOMarketFactory,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    mapping(address => bool) private _validCollateral;\n    mapping(bytes32 => address) private _deployedMarkets;\n\n    function initialize() public initializer {\n        OwnableUpgradeable.__Ownable_init();\n    }\n\n    function isCollateralValid(address _collateral)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _validCollateral[_collateral];\n    }\n\n    function getMarket(bytes32 _longShortHash)\n        external\n        view\n        override\n        returns (IPrePOMarket)\n    {\n        return IPrePOMarket(_deployedMarkets[_longShortHash]);\n    }\n\n    function createMarket(\n        string memory _tokenNameSuffix,\n        string memory _tokenSymbolSuffix,\n        address _governance,\n        address _collateral,\n        uint256 _floorLongPrice,\n        uint256 _ceilingLongPrice,\n        uint256 _floorValuation,\n        uint256 _ceilingValuation,\n        uint256 _mintingFee,\n        uint256 _redemptionFee,\n        uint256 _expiryTime\n    ) external override onlyOwner nonReentrant {\n        require(_validCollateral[_collateral], \"Invalid collateral\");\n\n        (\n            LongShortToken _longToken,\n            LongShortToken _shortToken\n        ) = _createPairTokens(_tokenNameSuffix, _tokenSymbolSuffix);\n        bytes32 _salt = keccak256(abi.encodePacked(_longToken, _shortToken));\n\n        PrePOMarket _newMarket = new PrePOMarket{salt: _salt}(\n            _governance,\n            _collateral,\n            ILongShortToken(address(_longToken)),\n            ILongShortToken(address(_shortToken)),\n            _floorLongPrice,\n            _ceilingLongPrice,\n            _floorValuation,\n            _ceilingValuation,\n            _mintingFee,\n            _redemptionFee,\n            _expiryTime,\n            false\n        );\n        _deployedMarkets[_salt] = address(_newMarket);\n\n        _longToken.transferOwnership(address(_newMarket));\n        _shortToken.transferOwnership(address(_newMarket));\n        emit MarketAdded(address(_newMarket), _salt);\n    }\n\n    function setCollateralValidity(address _collateral, bool _validity)\n        external\n        override\n        onlyOwner\n    {\n        _validCollateral[_collateral] = _validity;\n        emit CollateralValidityChanged(_collateral, _validity);\n    }\n\n    function _createPairTokens(\n        string memory _tokenNameSuffix,\n        string memory _tokenSymbolSuffix\n    )\n        internal\n        returns (LongShortToken _newLongToken, LongShortToken _newShortToken)\n    {\n        string memory _longTokenName = string(\n            abi.encodePacked(\"LONG\", \" \", _tokenNameSuffix)\n        );\n        string memory _shortTokenName = string(\n            abi.encodePacked(\"SHORT\", \" \", _tokenNameSuffix)\n        );\n        string memory _longTokenSymbol = string(\n            abi.encodePacked(\"L\", \"_\", _tokenSymbolSuffix)\n        );\n        string memory _shortTokenSymbol = string(\n            abi.encodePacked(\"S\", \"_\", _tokenSymbolSuffix)\n        );\n        _newLongToken = new LongShortToken(_longTokenName, _longTokenSymbol);\n        _newShortToken = new LongShortToken(\n            _shortTokenName,\n            _shortTokenSymbol\n        );\n        return (_newLongToken, _newShortToken);\n    }\n}\n\n\n",
        "CodeNames": [
            "PrePOMarketFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PrePOMarketFactory.sol#L42",
                "Type": "Duplicate _tokenNameSuffix and _tokenSymbolSuffix will incorrectly update current Market",
                "Description": "Creating a new market with the same name and symbol suffix as an existing market will overwrite the existing mapping within PrePOMarketFactory.",
                "Repair": "Add a check to ensure that the market does not already exist before creating a new one."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SingleStrategyController is\n    IStrategyController,\n    Ownable,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    address private _vault;\n    IStrategy private _strategy;\n    IERC20 private immutable _baseToken;\n\n    modifier onlyVault() {\n        require(msg.sender == _vault, \"Caller is not the vault\");\n        _;\n    }\n\n    constructor(IERC20 _token) {\n        require(address(_token) != address(0), \"Zero address\");\n        _baseToken = _token;\n    }\n\n    // Assumes approval to take `_amount` has already been given by vault\n    function deposit(uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _baseToken.safeTransferFrom(_vault, address(this), _amount);\n        _strategy.deposit(_baseToken.balanceOf(address(this)));\n    }\n\n    function withdraw(address _recipient, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _strategy.withdraw(_recipient, _amount);\n    }\n\n    function migrate(IStrategy _newStrategy)\n        external\n        override\n        onlyOwner\n        nonReentrant\n    {\n        uint256 _oldStrategyBalance;\n        IStrategy _oldStrategy = _strategy;\n        _strategy = _newStrategy;\n        _baseToken.approve(address(_newStrategy), type(uint256).max);\n        if (address(_oldStrategy) != address(0)) {\n            _baseToken.approve(address(_oldStrategy), 0);\n            _oldStrategyBalance = _oldStrategy.totalValue();\n            _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n            _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n        }\n        emit StrategyMigrated(\n            address(_oldStrategy),\n            address(_newStrategy),\n            _oldStrategyBalance\n        );\n    }\n\n    function setVault(address _newVault) external override onlyOwner {\n        _vault = _newVault;\n        emit VaultChanged(_newVault);\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return _baseToken.balanceOf(address(this)) + _strategy.totalValue();\n    }\n\n    function getVault() external view override returns (address) {\n        return _vault;\n    }\n\n    function getStrategy() external view override returns (IStrategy) {\n        return _strategy;\n    }\n\n    function getBaseToken() external view override returns (IERC20) {\n        return _baseToken;\n    }\n}\n\n\n",
        "CodeNames": [
            "SingleStrategyController.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SingleStrategyController.sol#L51-L72",
                "Type": "Strategy Migration May Leave Tokens in the Old Strategy Impacting Share Calculations",
                "Description": "If a strategy does not have sufficient funds to withdraw() for the full amount then it is possible that tokens will be left in this yield contract during migrate(), impacting share calculations.",
                "Repair": "Add a check to ensure that no funds are left in the old strategy after calling _oldStrategy.withdraw()."
            },
            {
                "Location": "SingleStrategyController.sol",
                "Type": "Smart Contract Logic",
                "Description": "SingleStrategyController doesn't verify that new strategy uses the same base token",
                "Repair": "Add a check in the migrate() function to verify that the new strategy uses the correct base token"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ILongShortToken.sol\";\nimport \"./interfaces/IPrePOMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract PrePOMarket is IPrePOMarket, Ownable, ReentrancyGuard {\n    address private _treasury;\n\n    IERC20 private immutable _collateral;\n    ILongShortToken private immutable _longToken;\n    ILongShortToken private immutable _shortToken;\n\n    uint256 private immutable _floorLongPrice;\n    uint256 private immutable _ceilingLongPrice;\n    uint256 private _finalLongPrice;\n\n    uint256 private immutable _floorValuation;\n    uint256 private immutable _ceilingValuation;\n\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n\n    uint256 private immutable _expiryTime;\n\n    bool private _publicMinting;\n\n    uint256 private constant MAX_PRICE = 1e18;\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    /**\n     * Assumes `_newCollateral`, `_newLongToken`, and `_newShortToken` are\n     * valid, since they will be handled by the PrePOMarketFactory. The\n     * treasury is initialized to governance due to stack limitations.\n     *\n     * Assumes that ownership of `_longToken` and `_shortToken` has been\n     * transferred to this contract via `createMarket()` in\n     * `PrePOMarketFactory.sol`.\n     */\n    constructor(\n        address _governance,\n        address _newCollateral,\n        ILongShortToken _newLongToken,\n        ILongShortToken _newShortToken,\n        uint256 _newFloorLongPrice,\n        uint256 _newCeilingLongPrice,\n        uint256 _newFloorValuation,\n        uint256 _newCeilingValuation,\n        uint256 _newMintingFee,\n        uint256 _newRedemptionFee,\n        uint256 _newExpiryTime,\n        bool _allowed\n    ) {\n        require(\n            _newCeilingLongPrice > _newFloorLongPrice,\n            \"Ceiling must exceed floor\"\n        );\n        require(_newExpiryTime > block.timestamp, \"Invalid expiry\");\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newCeilingLongPrice <= MAX_PRICE, \"Ceiling cannot exceed 1\");\n\n        transferOwnership(_governance);\n        _treasury = _governance;\n\n        _collateral = IERC20(_newCollateral);\n        _longToken = _newLongToken;\n        _shortToken = _newShortToken;\n\n        _floorLongPrice = _newFloorLongPrice;\n        _ceilingLongPrice = _newCeilingLongPrice;\n        _finalLongPrice = MAX_PRICE + 1;\n\n        _floorValuation = _newFloorValuation;\n        _ceilingValuation = _newCeilingValuation;\n\n        _mintingFee = _newMintingFee;\n        _redemptionFee = _newRedemptionFee;\n\n        _expiryTime = _newExpiryTime;\n\n        _publicMinting = _allowed;\n\n        emit MarketCreated(\n            address(_newLongToken),\n            address(_newShortToken),\n            _newFloorLongPrice,\n            _newCeilingLongPrice,\n            _newFloorValuation,\n            _newCeilingValuation,\n            _newMintingFee,\n            _newRedemptionFee,\n            _newExpiryTime\n        );\n    }\n\n    function mintLongShortTokens(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        if (msg.sender != owner()) {\n            require(_publicMinting, \"Public minting disabled\");\n        }\n        require(_finalLongPrice > MAX_PRICE, \"Market ended\");\n        require(\n            _collateral.balanceOf(msg.sender) >= _amount,\n            \"Insufficient collateral\"\n        );\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is minting\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_amount * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amount > _fee, \"Minting amount too small\");\n        _collateral.transferFrom(msg.sender, _treasury, _fee);\n        _amount -= _fee;\n        _collateral.transferFrom(msg.sender, address(this), _amount);\n        _longToken.mint(msg.sender, _amount);\n        _shortToken.mint(msg.sender, _amount);\n        emit Mint(msg.sender, _amount);\n        return _amount;\n    }\n\n    function redeem(uint256 _longAmount, uint256 _shortAmount)\n        external\n        override\n        nonReentrant\n    {\n        require(\n            _longToken.balanceOf(msg.sender) >= _longAmount,\n            \"Insufficient long tokens\"\n        );\n        require(\n            _shortToken.balanceOf(msg.sender) >= _shortAmount,\n            \"Insufficient short tokens\"\n        );\n\n        uint256 _collateralOwed;\n        if (_finalLongPrice <= MAX_PRICE) {\n            uint256 _shortPrice = MAX_PRICE - _finalLongPrice;\n            _collateralOwed =\n                (_finalLongPrice * _longAmount + _shortPrice * _shortAmount) /\n                MAX_PRICE;\n        } else {\n            require(\n                _longAmount == _shortAmount,\n                \"Long and Short must be equal\"\n            );\n            _collateralOwed = _longAmount;\n        }\n\n        _longToken.burnFrom(msg.sender, _longAmount);\n        _shortToken.burnFrom(msg.sender, _shortAmount);\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is redeeming\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_collateralOwed * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_collateralOwed > _fee, \"Redemption amount too small\");\n        _collateral.transfer(_treasury, _fee);\n        _collateralOwed -= _fee;\n        _collateral.transfer(msg.sender, _collateralOwed);\n\n        emit Redemption(msg.sender, _collateralOwed);\n    }\n\n    function setTreasury(address _newTreasury) external override onlyOwner {\n        _treasury = _newTreasury;\n        emit TreasuryChanged(_newTreasury);\n    }\n\n    function setFinalLongPrice(uint256 _newFinalLongPrice)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _newFinalLongPrice >= _floorLongPrice,\n            \"Price cannot be below floor\"\n        );\n        require(\n            _newFinalLongPrice <= _ceilingLongPrice,\n            \"Price cannot exceed ceiling\"\n        );\n        _finalLongPrice = _newFinalLongPrice;\n        emit FinalLongPriceSet(_newFinalLongPrice);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_newMintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_newRedemptionFee);\n    }\n\n    function setPublicMinting(bool _allowed) external override onlyOwner {\n        _publicMinting = _allowed;\n        emit PublicMintingChanged(_allowed);\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getCollateral() external view override returns (IERC20) {\n        return _collateral;\n    }\n\n    function getLongToken() external view override returns (ILongShortToken) {\n        return _longToken;\n    }\n\n    function getShortToken() external view override returns (ILongShortToken) {\n        return _shortToken;\n    }\n\n    function getFloorLongPrice() external view override returns (uint256) {\n        return _floorLongPrice;\n    }\n\n    function getCeilingLongPrice() external view override returns (uint256) {\n        return _ceilingLongPrice;\n    }\n\n    function getFinalLongPrice() external view override returns (uint256) {\n        return _finalLongPrice;\n    }\n\n    function getFloorValuation() external view override returns (uint256) {\n        return _floorValuation;\n    }\n\n    function getCeilingValuation() external view override returns (uint256) {\n        return _ceilingValuation;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getExpiryTime() external view override returns (uint256) {\n        return _expiryTime;\n    }\n\n    function isPublicMintingAllowed() external view override returns (bool) {\n        return _publicMinting;\n    }\n\n    function getMaxPrice() external pure override returns (uint256) {\n        return MAX_PRICE;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n}\n\n\n",
        "CodeNames": [
            "PrePOMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PrePOMarket.sol",
                "Type": "Smart Contract Logic",
                "Description": "Market expiry behaviour differs in implementation and documentation",
                "Repair": "Update the documentation to reflect the default behaviour of 1:1 redemption or add logic to enforce expiry settlement at the lower bound"
            }
        ]
    }
]