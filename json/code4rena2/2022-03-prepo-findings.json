[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "multiple locations",
                "Type": "smart contract vulnerability",
                "Description": "The text describes several vulnerabilities in the smart contract code, including issues with share minting, market creation, withdrawal delays, strategy migration, and base token verification. The recommended repair methods include adding checks and conditions to the code to prevent these vulnerabilities from being exploited.",
                "Repair": "add checks and conditions to the code"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ICollateral.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"./interfaces/IHook.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract Collateral is\n    ICollateral,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bool private _depositsAllowed;\n    bool private _withdrawalsAllowed;\n    address private _treasury;\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n    IERC20Upgradeable private _baseToken;\n    IStrategyController private _strategyController;\n\n    uint256 private _delayedWithdrawalExpiry;\n    mapping(address => WithdrawalRequest) private _accountToWithdrawalRequest;\n\n    IHook private _depositHook;\n    IHook private _withdrawHook;\n\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    function initialize(address _newBaseToken, address _newTreasury)\n        public\n        initializer\n    {\n        __Ownable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __ERC20_init_unchained(\n            string(\"prePO Collateral Token\"),\n            string(\"preCT\")\n        );\n        _baseToken = IERC20Upgradeable(_newBaseToken);\n        _treasury = _newTreasury;\n    }\n\n    function deposit(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_depositsAllowed, \"Deposits not allowed\");\n        _baseToken.safeTransferFrom(msg.sender, address(this), _amount);\n        // Calculate fees and shares to mint including latent contract funds\n        uint256 _amountToDeposit = _baseToken.balanceOf(address(this));\n        // Record deposit before fee is taken\n        if (address(_depositHook) != address(0)) {\n            _depositHook.hook(msg.sender, _amount, _amountToDeposit);\n        }\n        /**\n         * Add 1 to avoid rounding to zero, only process deposit if user is\n         * depositing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amountToDeposit > _fee, \"Deposit amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        _amountToDeposit -= _fee;\n\n        uint256 _valueBefore = _strategyController.totalValue();\n        _baseToken.approve(address(_strategyController), _amountToDeposit);\n        _strategyController.deposit(_amountToDeposit);\n        uint256 _valueAfter = _strategyController.totalValue();\n        _amountToDeposit = _valueAfter - _valueBefore;\n\n        uint256 _shares = 0;\n        if (totalSupply() == 0) {\n            _shares = _amountToDeposit;\n        } else {\n            /**\n             * # of shares owed = amount deposited / cost per share, cost per\n             * share = total supply / total value.\n             */\n            _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);\n        }\n        _mint(msg.sender, _shares);\n        return _shares;\n    }\n\n    function initiateWithdrawal(uint256 _amount) external override {\n        /**\n         * Checking the balance before initiation is necessary since a user\n         * could initiate an unlimited withdrawal amount ahead of time,\n         * negating the protection a delayed withdrawal offers.\n         */\n        require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");\n        _accountToWithdrawalRequest[msg.sender].amount = _amount;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;\n    }\n\n    function uninitiateWithdrawal() external override {\n        _accountToWithdrawalRequest[msg.sender].amount = 0;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = 0;\n    }\n\n    function _processDelayedWithdrawal(address _account, uint256 _amount)\n        internal\n    {\n        /**\n         * Verify that the withdrawal being processed matches what was\n         * recorded during initiation.\n         */\n        require(\n            _accountToWithdrawalRequest[_account].amount == _amount,\n            \"Initiated amount does not match\"\n        );\n        uint256 _recordedBlock = _accountToWithdrawalRequest[_account]\n            .blockNumber;\n        require(\n            _recordedBlock + _delayedWithdrawalExpiry >= block.number,\n            \"Must withdraw before expiry\"\n        );\n        require(\n            block.number > _recordedBlock,\n            \"Must withdraw in a later block\"\n        );\n        // Reset the initiation prior to withdrawal.\n        _accountToWithdrawalRequest[_account].amount = 0;\n        _accountToWithdrawalRequest[_account].blockNumber = 0;\n    }\n\n    function withdraw(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_withdrawalsAllowed, \"Withdrawals not allowed\");\n        if (_delayedWithdrawalExpiry != 0) {\n            _processDelayedWithdrawal(msg.sender, _amount);\n        }\n        uint256 _owed = (_strategyController.totalValue() * _amount) /\n            totalSupply();\n        _burn(msg.sender, _amount);\n\n        uint256 _balanceBefore = _baseToken.balanceOf(address(this));\n        _strategyController.withdraw(address(this), _owed);\n        uint256 _balanceAfter = _baseToken.balanceOf(address(this));\n\n        uint256 _amountWithdrawn = _balanceAfter - _balanceBefore;\n        // Record withdrawal before fee is taken\n        if (address(_withdrawHook) != address(0)) {\n            _withdrawHook.hook(msg.sender, _amount, _amountWithdrawn);\n        }\n\n        /**\n         * Send redemption fee to the protocol treasury. Add 1 to avoid\n         * rounding to zero, only process withdrawal if user is\n         * withdrawing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountWithdrawn * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_amountWithdrawn > _fee, \"Withdrawal amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        _amountWithdrawn -= _fee;\n        _baseToken.safeTransfer(msg.sender, _amountWithdrawn);\n        return _amountWithdrawn;\n    }\n\n    function setDepositsAllowed(bool _allowed) external override onlyOwner {\n        _depositsAllowed = _allowed;\n        emit DepositsAllowedChanged(_allowed);\n    }\n\n    function setWithdrawalsAllowed(bool _allowed) external override onlyOwner {\n        _withdrawalsAllowed = _allowed;\n        emit WithdrawalsAllowedChanged(_allowed);\n    }\n\n    function setStrategyController(IStrategyController _newStrategyController)\n        external\n        override\n        onlyOwner\n    {\n        _strategyController = _newStrategyController;\n        emit StrategyControllerChanged(address(_strategyController));\n    }\n\n    function setDelayedWithdrawalExpiry(uint256 _newDelayedWithdrawalExpiry)\n        external\n        override\n        onlyOwner\n    {\n        _delayedWithdrawalExpiry = _newDelayedWithdrawalExpiry;\n        emit DelayedWithdrawalExpiryChanged(_delayedWithdrawalExpiry);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_mintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_redemptionFee);\n    }\n\n    function setDepositHook(IHook _newDepositHook)\n        external\n        override\n        onlyOwner\n    {\n        _depositHook = _newDepositHook;\n        emit DepositHookChanged(address(_depositHook));\n    }\n\n    function setWithdrawHook(IHook _newWithdrawHook)\n        external\n        override\n        onlyOwner\n    {\n        _withdrawHook = _newWithdrawHook;\n        emit WithdrawHookChanged(address(_withdrawHook));\n    }\n\n    function getDepositsAllowed() external view override returns (bool) {\n        return _depositsAllowed;\n    }\n\n    function getWithdrawalsAllowed() external view override returns (bool) {\n        return _withdrawalsAllowed;\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getBaseToken()\n        external\n        view\n        override\n        returns (IERC20Upgradeable)\n    {\n        return _baseToken;\n    }\n\n    function getStrategyController()\n        external\n        view\n        override\n        returns (IStrategyController)\n    {\n        return _strategyController;\n    }\n\n    function getDelayedWithdrawalExpiry()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _delayedWithdrawalExpiry;\n    }\n\n    function getWithdrawalRequest(address _account)\n        external\n        view\n        override\n        returns (WithdrawalRequest memory)\n    {\n        return _accountToWithdrawalRequest[_account];\n    }\n\n    function getDepositHook() external view override returns (IHook) {\n        return _depositHook;\n    }\n\n    function getWithdrawHook() external view override returns (IHook) {\n        return _withdrawHook;\n    }\n\n    function getAmountForShares(uint256 _shares)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() == 0) {\n            return _shares;\n        }\n        return (_shares * totalAssets()) / totalSupply();\n    }\n\n    function getSharesForAmount(uint256 _amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _totalAssets = totalAssets();\n        return\n            (_totalAssets > 0)\n                ? ((_amount * totalSupply()) / _totalAssets)\n                : 0;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return\n            _baseToken.balanceOf(address(this)) +\n            _strategyController.totalValue();\n    }\n}\n\n\n",
        "CodeNames": [
            "Collateral.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "getSharesForAmount() function in Collateral.sol",
                "Type": "Wrong formula",
                "Description": "getSharesForAmount() returns wrong value when totalAssets == 0",
                "Repair": "Change Collateral.totalAssets() to only include _strategyController.totalValue()"
            },
            {
                "Location": "getSharesForAmount() function in Collateral.sol",
                "Type": "Wrong formula",
                "Description": "Wrong formula of getSharesForAmount() can potentially cause fund loss when being used to calculate the shares to be used in withdraw()",
                "Repair": "Add a check to return _amount if totalSupply() == 0"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ILongShortToken.sol\";\nimport \"./interfaces/IPrePOMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract PrePOMarket is IPrePOMarket, Ownable, ReentrancyGuard {\n    address private _treasury;\n\n    IERC20 private immutable _collateral;\n    ILongShortToken private immutable _longToken;\n    ILongShortToken private immutable _shortToken;\n\n    uint256 private immutable _floorLongPrice;\n    uint256 private immutable _ceilingLongPrice;\n    uint256 private _finalLongPrice;\n\n    uint256 private immutable _floorValuation;\n    uint256 private immutable _ceilingValuation;\n\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n\n    uint256 private immutable _expiryTime;\n\n    bool private _publicMinting;\n\n    uint256 private constant MAX_PRICE = 1e18;\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    /**\n     * Assumes `_newCollateral`, `_newLongToken`, and `_newShortToken` are\n     * valid, since they will be handled by the PrePOMarketFactory. The\n     * treasury is initialized to governance due to stack limitations.\n     *\n     * Assumes that ownership of `_longToken` and `_shortToken` has been\n     * transferred to this contract via `createMarket()` in\n     * `PrePOMarketFactory.sol`.\n     */\n    constructor(\n        address _governance,\n        address _newCollateral,\n        ILongShortToken _newLongToken,\n        ILongShortToken _newShortToken,\n        uint256 _newFloorLongPrice,\n        uint256 _newCeilingLongPrice,\n        uint256 _newFloorValuation,\n        uint256 _newCeilingValuation,\n        uint256 _newMintingFee,\n        uint256 _newRedemptionFee,\n        uint256 _newExpiryTime,\n        bool _allowed\n    ) {\n        require(\n            _newCeilingLongPrice > _newFloorLongPrice,\n            \"Ceiling must exceed floor\"\n        );\n        require(_newExpiryTime > block.timestamp, \"Invalid expiry\");\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newCeilingLongPrice <= MAX_PRICE, \"Ceiling cannot exceed 1\");\n\n        transferOwnership(_governance);\n        _treasury = _governance;\n\n        _collateral = IERC20(_newCollateral);\n        _longToken = _newLongToken;\n        _shortToken = _newShortToken;\n\n        _floorLongPrice = _newFloorLongPrice;\n        _ceilingLongPrice = _newCeilingLongPrice;\n        _finalLongPrice = MAX_PRICE + 1;\n\n        _floorValuation = _newFloorValuation;\n        _ceilingValuation = _newCeilingValuation;\n\n        _mintingFee = _newMintingFee;\n        _redemptionFee = _newRedemptionFee;\n\n        _expiryTime = _newExpiryTime;\n\n        _publicMinting = _allowed;\n\n        emit MarketCreated(\n            address(_newLongToken),\n            address(_newShortToken),\n            _newFloorLongPrice,\n            _newCeilingLongPrice,\n            _newFloorValuation,\n            _newCeilingValuation,\n            _newMintingFee,\n            _newRedemptionFee,\n            _newExpiryTime\n        );\n    }\n\n    function mintLongShortTokens(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        if (msg.sender != owner()) {\n            require(_publicMinting, \"Public minting disabled\");\n        }\n        require(_finalLongPrice > MAX_PRICE, \"Market ended\");\n        require(\n            _collateral.balanceOf(msg.sender) >= _amount,\n            \"Insufficient collateral\"\n        );\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is minting\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_amount * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amount > _fee, \"Minting amount too small\");\n        _collateral.transferFrom(msg.sender, _treasury, _fee);\n        _amount -= _fee;\n        _collateral.transferFrom(msg.sender, address(this), _amount);\n        _longToken.mint(msg.sender, _amount);\n        _shortToken.mint(msg.sender, _amount);\n        emit Mint(msg.sender, _amount);\n        return _amount;\n    }\n\n    function redeem(uint256 _longAmount, uint256 _shortAmount)\n        external\n        override\n        nonReentrant\n    {\n        require(\n            _longToken.balanceOf(msg.sender) >= _longAmount,\n            \"Insufficient long tokens\"\n        );\n        require(\n            _shortToken.balanceOf(msg.sender) >= _shortAmount,\n            \"Insufficient short tokens\"\n        );\n\n        uint256 _collateralOwed;\n        if (_finalLongPrice <= MAX_PRICE) {\n            uint256 _shortPrice = MAX_PRICE - _finalLongPrice;\n            _collateralOwed =\n                (_finalLongPrice * _longAmount + _shortPrice * _shortAmount) /\n                MAX_PRICE;\n        } else {\n            require(\n                _longAmount == _shortAmount,\n                \"Long and Short must be equal\"\n            );\n            _collateralOwed = _longAmount;\n        }\n\n        _longToken.burnFrom(msg.sender, _longAmount);\n        _shortToken.burnFrom(msg.sender, _shortAmount);\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is redeeming\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_collateralOwed * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_collateralOwed > _fee, \"Redemption amount too small\");\n        _collateral.transfer(_treasury, _fee);\n        _collateralOwed -= _fee;\n        _collateral.transfer(msg.sender, _collateralOwed);\n\n        emit Redemption(msg.sender, _collateralOwed);\n    }\n\n    function setTreasury(address _newTreasury) external override onlyOwner {\n        _treasury = _newTreasury;\n        emit TreasuryChanged(_newTreasury);\n    }\n\n    function setFinalLongPrice(uint256 _newFinalLongPrice)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _newFinalLongPrice >= _floorLongPrice,\n            \"Price cannot be below floor\"\n        );\n        require(\n            _newFinalLongPrice <= _ceilingLongPrice,\n            \"Price cannot exceed ceiling\"\n        );\n        _finalLongPrice = _newFinalLongPrice;\n        emit FinalLongPriceSet(_newFinalLongPrice);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_newMintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_newRedemptionFee);\n    }\n\n    function setPublicMinting(bool _allowed) external override onlyOwner {\n        _publicMinting = _allowed;\n        emit PublicMintingChanged(_allowed);\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getCollateral() external view override returns (IERC20) {\n        return _collateral;\n    }\n\n    function getLongToken() external view override returns (ILongShortToken) {\n        return _longToken;\n    }\n\n    function getShortToken() external view override returns (ILongShortToken) {\n        return _shortToken;\n    }\n\n    function getFloorLongPrice() external view override returns (uint256) {\n        return _floorLongPrice;\n    }\n\n    function getCeilingLongPrice() external view override returns (uint256) {\n        return _ceilingLongPrice;\n    }\n\n    function getFinalLongPrice() external view override returns (uint256) {\n        return _finalLongPrice;\n    }\n\n    function getFloorValuation() external view override returns (uint256) {\n        return _floorValuation;\n    }\n\n    function getCeilingValuation() external view override returns (uint256) {\n        return _ceilingValuation;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getExpiryTime() external view override returns (uint256) {\n        return _expiryTime;\n    }\n\n    function isPublicMintingAllowed() external view override returns (bool) {\n        return _publicMinting;\n    }\n\n    function getMaxPrice() external pure override returns (uint256) {\n        return MAX_PRICE;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n}\n\n\n",
        "CodeNames": [
            "PrePOMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PrePOMarket.sol",
                "Type": "Market expiry behavior",
                "Description": "Market expiry behavior differs in implementation and documentation",
                "Repair": "Add logic to settle at lower bound if market has expired or update documentation to reflect default behavior of 1:1 redemption"
            }
        ]
    }
]