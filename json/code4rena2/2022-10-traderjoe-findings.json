[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../LBErrors.sol\";\nimport \"../interfaces/IPendingOwnable.sol\";\n\n/// @title Pending Ownable\n/// @author Trader Joe\n/// @notice Contract module which provides a basic access control mechanism, where\n/// there is an account (an owner) that can be granted exclusive access to\n/// specific functions. The ownership of this contract is transferred using the\n/// push and pull pattern, the current owner set a `pendingOwner` using\n/// {setPendingOwner} and that address can then call {becomeOwner} to become the\n/// owner of that contract. The main logic and comments comes from OpenZeppelin's\n/// Ownable contract.\n///\n/// By default, the owner account will be the one that deploys the contract. This\n/// can later be changed with {setPendingOwner} and {becomeOwner}.\n///\n/// This module is used through inheritance. It will make available the modifier\n/// `onlyOwner`, which can be applied to your functions to restrict their use to\n/// the owner\ncontract PendingOwnable is IPendingOwnable {\n    address private _owner;\n    address private _pendingOwner;\n\n    /// @notice Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        if (msg.sender != _owner) revert PendingOwnable__NotOwner();\n        _;\n    }\n\n    /// @notice Throws if called by any account other than the pending owner.\n    modifier onlyPendingOwner() {\n        if (msg.sender != _pendingOwner || msg.sender == address(0)) revert PendingOwnable__NotPendingOwner();\n        _;\n    }\n\n    /// @notice Initializes the contract setting the deployer as the initial owner\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    /// @notice Returns the address of the current owner\n    /// @return The address of the current owner\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    /// @notice Returns the address of the current pending owner\n    /// @return The address of the current pending owner\n    function pendingOwner() public view override returns (address) {\n        return _pendingOwner;\n    }\n\n    /// @notice Sets the pending owner address. This address will be able to become\n    /// the owner of this contract by calling {becomeOwner}\n    function setPendingOwner(address pendingOwner_) public override onlyOwner {\n        if (pendingOwner_ == address(0)) revert PendingOwnable__AddressZero();\n        if (_pendingOwner != address(0)) revert PendingOwnable__PendingOwnerAlreadySet();\n        _setPendingOwner(pendingOwner_);\n    }\n\n    /// @notice Revoke the pending owner address. This address will not be able to\n    /// call {becomeOwner} to become the owner anymore.\n    /// Can only be called by the owner\n    function revokePendingOwner() public override onlyOwner {\n        if (_pendingOwner == address(0)) revert PendingOwnable__NoPendingOwner();\n        _setPendingOwner(address(0));\n    }\n\n    /// @notice Transfers the ownership to the new owner (`pendingOwner).\n    /// Can only be called by the pending owner\n    function becomeOwner() public override onlyPendingOwner {\n        _transferOwnership(msg.sender);\n    }\n\n    /// @notice Leaves the contract without owner. It will not be possible to call\n    /// `onlyOwner` functions anymore. Can only be called by the current owner.\n    ///\n    /// NOTE: Renouncing ownership will leave the contract without an owner,\n    /// thereby removing any functionality that is only available to the owner.\n    function renounceOwnership() public override onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /// @notice Transfers ownership of the contract to a new account (`newOwner`).\n    /// Internal function without access restriction.\n    /// @param _newOwner The address of the new owner\n    function _transferOwnership(address _newOwner) internal virtual {\n        address _oldOwner = _owner;\n        _owner = _newOwner;\n        _pendingOwner = address(0);\n        emit OwnershipTransferred(_oldOwner, _newOwner);\n    }\n\n    /// @notice Push the new owner, it needs to be pulled to be effective.\n    /// Internal function without access restriction.\n    /// @param pendingOwner_ The address of the new pending owner\n    function _setPendingOwner(address pendingOwner_) internal virtual {\n        _pendingOwner = pendingOwner_;\n        emit PendingOwnerSet(pendingOwner_);\n    }\n}\n\n\n",
        "CodeNames": [
            "PendingOwnable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PendingOwnable.sol#L42",
                "Type": "Owner privileges vulnerability",
                "Description": "The contract's owner has numerous privileges, and there is no timelock structure in place to use these privileges. Private key thefts of project owners have increased recently, making this vulnerability a medium severity.",
                "Repair": "Add a timelock contract to use onlyOwner privileges. Only allow a multisign wallet to use onlyOwner privileges."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Constants.sol\";\nimport \"./SafeCast.sol\";\nimport \"./SafeMath.sol\";\n\n/// @title Liquidity Book Fee Helper Library\n/// @author Trader Joe\n/// @notice Helper contract used for fees calculation\nlibrary FeeHelper {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n\n    /// @dev Structure to store the protocol fees:\n    /// - binStep: The bin step\n    /// - baseFactor: The base factor\n    /// - filterPeriod: The filter period, where the fees stays constant\n    /// - decayPeriod: The decay period, where the fees are halved\n    /// - reductionFactor: The reduction factor, used to calculate the reduction of the accumulator\n    /// - variableFeeControl: The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// - protocolShare: The share of fees sent to protocol\n    /// - maxVolatilityAccumulated: The max value of volatility accumulated\n    /// - volatilityAccumulated: The value of volatility accumulated\n    /// - volatilityReference: The value of volatility reference\n    /// - indexRef: The index reference\n    /// - time: The last time the accumulator was called\n    struct FeeParameters {\n        uint16 binStep;\n        uint16 baseFactor;\n        uint16 filterPeriod;\n        uint16 decayPeriod;\n        uint16 reductionFactor;\n        uint24 variableFeeControl;\n        uint16 protocolShare;\n        uint24 maxVolatilityAccumulated;\n        uint24 volatilityAccumulated;\n        uint24 volatilityReference;\n        uint24 indexRef;\n        uint40 time;\n    }\n\n    /// @dev Structure used during swaps to distributes the fees:\n    /// - total: The total amount of fees\n    /// - protocol: The amount of fees reserved for protocol\n    struct FeesDistribution {\n        uint128 total;\n        uint128 protocol;\n    }\n\n    /// @notice Update the value of the volatility accumulated\n    /// @param _fp The current fee parameters\n    /// @param _activeId The current active id\n    function updateVariableFeeParameters(FeeParameters memory _fp, uint256 _activeId) internal view {\n        uint256 _deltaT = block.timestamp - _fp.time;\n\n        if (_deltaT >= _fp.filterPeriod || _fp.time == 0) {\n            _fp.indexRef = uint24(_activeId);\n            if (_deltaT < _fp.decayPeriod) {\n                unchecked {\n                    // This can't overflow as `reductionFactor <= BASIS_POINT_MAX`\n                    _fp.volatilityReference = uint24(\n                        (uint256(_fp.reductionFactor) * _fp.volatilityAccumulated) / Constants.BASIS_POINT_MAX\n                    );\n                }\n            } else {\n                _fp.volatilityReference = 0;\n            }\n        }\n\n        _fp.time = (block.timestamp).safe40();\n\n        updateVolatilityAccumulated(_fp, _activeId);\n    }\n\n    /// @notice Update the volatility accumulated\n    /// @param _fp The fee parameter\n    /// @param _activeId The current active id\n    function updateVolatilityAccumulated(FeeParameters memory _fp, uint256 _activeId) internal pure {\n        uint256 volatilityAccumulated = (_activeId.absSub(_fp.indexRef) * Constants.BASIS_POINT_MAX) +\n            _fp.volatilityReference;\n        _fp.volatilityAccumulated = volatilityAccumulated > _fp.maxVolatilityAccumulated\n            ? _fp.maxVolatilityAccumulated\n            : uint24(volatilityAccumulated);\n    }\n\n    /// @notice Returns the base fee added to a swap, with 18 decimals\n    /// @param _fp The current fee parameters\n    /// @return The fee with 18 decimals precision\n    function getBaseFee(FeeParameters memory _fp) internal pure returns (uint256) {\n        unchecked {\n            return uint256(_fp.baseFactor) * _fp.binStep * 1e10;\n        }\n    }\n\n    /// @notice Returns the variable fee added to a swap, with 18 decimals\n    /// @param _fp The current fee parameters\n    /// @return variableFee The variable fee with 18 decimals precision\n    function getVariableFee(FeeParameters memory _fp) internal pure returns (uint256 variableFee) {\n        if (_fp.variableFeeControl != 0) {\n            // Can't overflow as the max value is `max(uint24) * (max(uint24) * max(uint16)) ** 2 < max(uint104)`\n            // It returns 18 decimals as:\n            // decimals(variableFeeControl * (volatilityAccumulated * binStep)**2 / 100) = 4 + (4 + 4) * 2 - 2 = 18\n            unchecked {\n                uint256 _prod = uint256(_fp.volatilityAccumulated) * _fp.binStep;\n                variableFee = (_prod * _prod * _fp.variableFeeControl) / 100;\n            }\n        }\n    }\n\n    /// @notice Return the amount of fees added to an amount\n    /// @param _fp The current fee parameter\n    /// @param _amount The amount of token sent\n    /// @return The fee amount\n    function getFeeAmount(FeeParameters memory _fp, uint256 _amount) internal pure returns (uint256) {\n        return (_amount * getTotalFee(_fp)) / (Constants.PRECISION);\n    }\n\n    /// @notice Return the fees from an amount\n    /// @param _fp The current fee parameter\n    /// @param _amountPlusFee The amount of token sent\n    /// @return The fee amount\n    function getFeeAmountFrom(FeeParameters memory _fp, uint256 _amountPlusFee) internal pure returns (uint256) {\n        uint256 _fee = getTotalFee(_fp);\n        return (_amountPlusFee * _fee) / (Constants.PRECISION + _fee);\n    }\n\n    /// @notice Return the fees added when an user adds liquidity and change the ratio in the active bin\n    /// @param _fp The current fee parameter\n    /// @param _amountPlusFee The amount of token sent\n    /// @return The fee amount\n    function getFeeAmountForC(FeeParameters memory _fp, uint256 _amountPlusFee) internal pure returns (uint256) {\n        uint256 _fee = getTotalFee(_fp);\n        return (_amountPlusFee * _fee * (_fee + Constants.PRECISION)) / (Constants.PRECISION * Constants.PRECISION);\n    }\n\n    /// @notice Return the fees distribution added to an amount\n    /// @param _fp The current fee parameter\n    /// @param _fees The fee amount\n    /// @return fees The fee distribution\n    function getFeeAmountDistribution(FeeParameters memory _fp, uint256 _fees)\n        internal\n        pure\n        returns (FeesDistribution memory fees)\n    {\n        fees.total = _fees.safe128();\n        // unsafe math is fine because total >= protocol\n        unchecked {\n            fees.protocol = uint128((_fees * _fp.protocolShare) / Constants.BASIS_POINT_MAX);\n        }\n    }\n\n    /// @notice Return the total fee, i.e. baseFee + variableFee\n    /// @param _fp The current fee parameter\n    /// @return The total fee, with 18 decimals\n    function getTotalFee(FeeParameters memory _fp) private pure returns (uint256) {\n        unchecked {\n            return getBaseFee(_fp) + getVariableFee(_fp);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "FeeHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FeeHelper.sol#L58-L72",
                "Type": "Fee manipulation vulnerability",
                "Description": "An attacker can keep fees extremely high at basically zero cost by swapping just under every Tf seconds, a zero-ish amount. This makes the protocol completely uncompetitive around the clock. The impact to the protocol is that most users will favor alternative AMMs, which directly translates to a large loss of revenue. The severity of this vulnerability is debated, but it is considered medium severity.",
                "Repair": "Decay linearly to the time since last swap when T < Tf, don't update _tf.time if swap did not affect Vr, or only skip Vr update if swap amount is not negligible."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinRouterTest is TestHelper {\n    event AVAXreceived();\n\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n        wavax = new WAVAX();\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n        addAllAssetsToQuoteWhitelist(factory);\n        router = new LBRouter(factory, IJoeFactory(JOE_V1_FACTORY_ADDRESS), IWAVAX(address(wavax)));\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n    }\n\n    function testAddLiquidityNoSlippage() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n\n        (int256[] memory _deltaIds, , , uint256 amountXIn) = addLiquidityFromRouter(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        uint256 totalXbalance;\n        uint256 totalYBalance;\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            uint256 LBTokenAmount = pair.balanceOf(DEV, ids[i]);\n            amounts[i] = LBTokenAmount;\n            (uint256 reserveX, uint256 reserveY) = pair.getBin(uint24(ids[i]));\n            bool hasXBalanceInBin = (LBTokenAmount != 0) && (reserveX != 0);\n            bool hasYBalanceInBin = (LBTokenAmount != 0) && (reserveY != 0);\n            totalXbalance += hasXBalanceInBin ? (LBTokenAmount * reserveX - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n            totalYBalance += hasYBalanceInBin ? (LBTokenAmount * reserveY - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n        }\n        assertApproxEqAbs(totalXbalance, amountXIn, 1000);\n        assertApproxEqAbs(totalYBalance, _amountYIn, 1000);\n\n        pair.setApprovalForAll(address(router), true);\n\n        router.removeLiquidity(\n            token6D,\n            token18D,\n            DEFAULT_BIN_STEP,\n            totalXbalance,\n            totalYBalance,\n            ids,\n            amounts,\n            DEV,\n            block.timestamp\n        );\n\n        assertEq(token6D.balanceOf(DEV), amountXIn);\n        assertEq(token18D.balanceOf(DEV), _amountYIn);\n    }\n\n    function testRemoveLiquidityReverseOrder() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n\n        (int256[] memory _deltaIds, , , uint256 amountXIn) = addLiquidityFromRouter(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        uint256 totalXbalance;\n        uint256 totalYBalance;\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            uint256 LBTokenAmount = pair.balanceOf(DEV, ids[i]);\n            amounts[i] = LBTokenAmount;\n            (uint256 reserveX, uint256 reserveY) = pair.getBin(uint24(ids[i]));\n            bool hasXBalanceInBin = (LBTokenAmount != 0) && (reserveX != 0);\n            bool hasYBalanceInBin = (LBTokenAmount != 0) && (reserveY != 0);\n            totalXbalance += hasXBalanceInBin ? (LBTokenAmount * reserveX - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n            totalYBalance += hasYBalanceInBin ? (LBTokenAmount * reserveY - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n        }\n        assertApproxEqAbs(totalXbalance, amountXIn, 1000);\n        assertApproxEqAbs(totalYBalance, _amountYIn, 1000);\n\n        pair.setApprovalForAll(address(router), true);\n\n        router.removeLiquidity(\n            token18D,\n            token6D,\n            DEFAULT_BIN_STEP,\n            _amountYIn,\n            totalXbalance,\n            ids,\n            amounts,\n            DEV,\n            block.timestamp\n        );\n\n        assertEq(token6D.balanceOf(DEV), amountXIn);\n        assertEq(token18D.balanceOf(DEV), _amountYIn);\n    }\n\n    function testRemoveLiquiditySlippageReverts() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 23;\n        uint24 _gap = 2;\n\n        (int256[] memory _deltaIds, , , uint256 amountXIn) = addLiquidityFromRouter(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        uint256 totalXbalance;\n        uint256 totalYBalance;\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            uint256 LBTokenAmount = pair.balanceOf(DEV, ids[i]);\n            amounts[i] = LBTokenAmount;\n            (uint256 reserveX, uint256 reserveY) = pair.getBin(uint24(ids[i]));\n            bool hasXBalanceInBin = (LBTokenAmount != 0) && (reserveX != 0);\n            bool hasYBalanceInBin = (LBTokenAmount != 0) && (reserveY != 0);\n            totalXbalance += hasXBalanceInBin ? (LBTokenAmount * reserveX - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n            totalYBalance += hasYBalanceInBin ? (LBTokenAmount * reserveY - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n        }\n        assertApproxEqAbs(totalXbalance, amountXIn, 1000);\n        assertApproxEqAbs(totalYBalance, _amountYIn, 1000);\n\n        pair.setApprovalForAll(address(router), true);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                LBRouter__AmountSlippageCaught.selector,\n                totalXbalance + 1,\n                totalXbalance,\n                totalYBalance,\n                totalYBalance\n            )\n        );\n        router.removeLiquidity(\n            token6D,\n            token18D,\n            DEFAULT_BIN_STEP,\n            totalXbalance + 1,\n            totalYBalance,\n            ids,\n            amounts,\n            DEV,\n            block.timestamp\n        );\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                LBRouter__AmountSlippageCaught.selector,\n                totalXbalance,\n                totalXbalance,\n                totalYBalance + 1,\n                totalYBalance\n            )\n        );\n        router.removeLiquidity(\n            token6D,\n            token18D,\n            DEFAULT_BIN_STEP,\n            totalXbalance,\n            totalYBalance + 1,\n            ids,\n            amounts,\n            DEV,\n            block.timestamp\n        );\n    }\n\n    function testAddLiquidityAVAX() public {\n        pair = createLBPairDefaultFees(token6D, wavax);\n        uint24 _numberBins = 23;\n        uint256 _amountYIn = 100e18; //AVAX\n        uint24 _gap = 2;\n\n        (int256[] memory _deltaIds, , , uint256 amountXIn) = addLiquidityFromRouter(\n            token6D,\n            ERC20MockDecimals(address(wavax)),\n            _amountYIn,\n            ID_ONE,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        uint256 totalXbalance;\n        uint256 totalYBalance;\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            uint256 LBTokenAmount = pair.balanceOf(DEV, ids[i]);\n            amounts[i] = LBTokenAmount;\n            (uint256 reserveX, uint256 reserveY) = pair.getBin(uint24(ids[i]));\n            bool hasXBalanceInBin = (LBTokenAmount != 0) && (reserveX != 0);\n            bool hasYBalanceInBin = (LBTokenAmount != 0) && (reserveY != 0);\n            totalXbalance += hasXBalanceInBin ? (LBTokenAmount * reserveX - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n            totalYBalance += hasYBalanceInBin ? (LBTokenAmount * reserveY - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n        }\n        assertApproxEqAbs(totalXbalance, amountXIn, 1000);\n        assertApproxEqAbs(totalYBalance, _amountYIn, 1000);\n\n        pair.setApprovalForAll(address(router), true);\n\n        uint256 AVAXBalanceBefore = address(DEV).balance;\n        {\n            router.removeLiquidityAVAX(\n                token6D,\n                DEFAULT_BIN_STEP,\n                totalXbalance,\n                totalYBalance,\n                ids,\n                amounts,\n                DEV,\n                block.timestamp\n            );\n        }\n        assertEq(token6D.balanceOf(DEV), amountXIn);\n        assertEq(address(DEV).balance - AVAXBalanceBefore, totalYBalance);\n    }\n\n    function testAddLiquidityAVAXReversed() public {\n        pair = createLBPairDefaultFees(wavax, token6D);\n        uint24 _numberBins = 21;\n        uint256 amountTokenIn = 100e18;\n        uint24 _gap = 2;\n        (int256[] memory _deltaIds, , , uint256 _amountAVAXIn) = addLiquidityFromRouter(\n            ERC20MockDecimals(address(wavax)),\n            token6D,\n            amountTokenIn,\n            ID_ONE,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        uint256 totalXbalance;\n        uint256 totalYBalance;\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            uint256 LBTokenAmount = pair.balanceOf(DEV, ids[i]);\n            amounts[i] = LBTokenAmount;\n            (uint256 reserveX, uint256 reserveY) = pair.getBin(uint24(ids[i]));\n            bool hasXBalanceInBin = (LBTokenAmount != 0) && (reserveX != 0);\n            bool hasYBalanceInBin = (LBTokenAmount != 0) && (reserveY != 0);\n            totalXbalance += hasXBalanceInBin ? (LBTokenAmount * reserveX - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n            totalYBalance += hasYBalanceInBin ? (LBTokenAmount * reserveY - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n        }\n        assertApproxEqAbs(totalXbalance, _amountAVAXIn, 1000);\n        assertApproxEqAbs(totalYBalance, amountTokenIn, 1000);\n\n        pair.setApprovalForAll(address(router), true);\n        uint256 AVAXBalanceBefore = address(DEV).balance;\n        {\n            router.removeLiquidityAVAX(\n                token6D,\n                DEFAULT_BIN_STEP,\n                totalYBalance,\n                totalXbalance,\n                ids,\n                amounts,\n                DEV,\n                block.timestamp\n            );\n        }\n        assertEq(token6D.balanceOf(DEV), amountTokenIn);\n        assertEq(address(DEV).balance - AVAXBalanceBefore, totalXbalance);\n    }\n\n    function testAddLiquidityTaxToken() public {\n        taxToken = new ERC20WithTransferTax();\n        pair = createLBPairDefaultFees(taxToken, wavax);\n        uint24 _numberBins = 9;\n        uint256 _amountAVAXIn = 100e18;\n        uint24 _gap = 2;\n\n        (int256[] memory _deltaIds, , , uint256 amountTokenIn) = addLiquidityFromRouter(\n            ERC20MockDecimals(address(taxToken)),\n            ERC20MockDecimals(address(wavax)),\n            _amountAVAXIn,\n            ID_ONE,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        uint256 totalXbalance;\n        uint256 totalYBalance;\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            uint256 LBTokenAmount = pair.balanceOf(DEV, ids[i]);\n            amounts[i] = LBTokenAmount;\n            (uint256 reserveX, uint256 reserveY) = pair.getBin(uint24(ids[i]));\n            bool hasXBalanceInBin = (LBTokenAmount != 0) && (reserveX != 0);\n            bool hasYBalanceInBin = (LBTokenAmount != 0) && (reserveY != 0);\n            totalXbalance += hasXBalanceInBin ? (LBTokenAmount * reserveX - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n            totalYBalance += hasYBalanceInBin ? (LBTokenAmount * reserveY - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n        }\n\n        pair.setApprovalForAll(address(router), true);\n\n        vm.expectRevert(bytes(\"ERC20: burn amount exceeds balance\"));\n        router.removeLiquidityAVAX(\n            taxToken,\n            DEFAULT_BIN_STEP,\n            totalXbalance,\n            _amountAVAXIn,\n            ids,\n            amounts,\n            DEV,\n            block.timestamp\n        );\n\n        router.removeLiquidity(\n            taxToken,\n            wavax,\n            DEFAULT_BIN_STEP,\n            totalXbalance,\n            _amountAVAXIn,\n            ids,\n            amounts,\n            DEV,\n            block.timestamp\n        );\n\n        assertEq(taxToken.balanceOf(DEV), amountTokenIn / 4 + 1); //2 transfers with 50% tax\n        assertEq(wavax.balanceOf(DEV), _amountAVAXIn);\n    }\n\n    function testAddLiquidityIgnored() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n\n        addLiquidityFromRouter(token6D, token18D, _amountYIn, _startId, _numberBins, _gap, DEFAULT_BIN_STEP);\n\n        factory.setLBPairIgnored(token6D, token18D, DEFAULT_BIN_STEP, true);\n        ILBRouter.LiquidityParameters memory _liquidityParameters = prepareLiquidityParameters(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        router.addLiquidity(_liquidityParameters);\n    }\n\n    function testForIdSlippageCaughtReverts() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n\n        addLiquidityFromRouter(token6D, token18D, _amountYIn, _startId, _numberBins, _gap, DEFAULT_BIN_STEP);\n\n        (, , , uint256 amountXIn) = spreadLiquidityForRouter(_amountYIn, _startId, _numberBins, _gap);\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = prepareLiquidityParameters(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n        _liquidityParameters.amountXMin = 0;\n        _liquidityParameters.amountYMin = 0;\n        _liquidityParameters.idSlippage = 0;\n\n        //_liq.activeIdDesired + _liq.idSlippage < _activeId\n        token18D.mint(address(pair), _amountYIn);\n        pair.swap(false, ALICE);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                LBRouter__IdSlippageCaught.selector,\n                8388608,\n                _liquidityParameters.idSlippage,\n                8388620\n            )\n        );\n        router.addLiquidity(_liquidityParameters);\n\n        // _activeId + _liq.idSlippage < _liq.activeIdDesired\n        token6D.mint(address(pair), 2 * amountXIn);\n        pair.swap(true, ALICE);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                LBRouter__IdSlippageCaught.selector,\n                8388608,\n                _liquidityParameters.idSlippage,\n                8388596\n            )\n        );\n        router.addLiquidity(_liquidityParameters);\n    }\n\n    function testForAmountSlippageCaughtReverts() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n        addLiquidityFromRouter(token6D, token18D, _amountYIn, _startId, _numberBins, _gap, DEFAULT_BIN_STEP);\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = prepareLiquidityParameters(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        (, , , uint256 amountXIn) = spreadLiquidityForRouter(_amountYIn, _startId, _numberBins, _gap);\n\n        token18D.mint(address(pair), _amountYIn / 3);\n        pair.swap(false, ALICE);\n\n        //no slippage allowed\n        _liquidityParameters.amountXMin = amountXIn;\n        _liquidityParameters.amountYMin = _amountYIn;\n\n        //Amount slippage is low in every case - depends only on C [bin composition] change in active bin\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                LBRouter__AmountSlippageCaught.selector,\n                98518565614280135938,\n                98515492308801033280,\n                100000000000000000000,\n                100000000000000000000\n            )\n        );\n        router.addLiquidity(_liquidityParameters);\n    }\n\n    function testForIdDesiredOverflowReverts() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n        uint256 overflown24 = uint256(type(uint24).max) + 1;\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = prepareLiquidityParameters(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n        //this will fail until n16 from audit will be fixed\n        _liquidityParameters.activeIdDesired = overflown24;\n        _liquidityParameters.idSlippage = 0;\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__IdDesiredOverflows.selector, overflown24, 0));\n        router.addLiquidity(_liquidityParameters);\n\n        _liquidityParameters.activeIdDesired = 0;\n        _liquidityParameters.idSlippage = overflown24;\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__IdDesiredOverflows.selector, 0, overflown24));\n        router.addLiquidity(_liquidityParameters);\n\n        _liquidityParameters.activeIdDesired = overflown24;\n        _liquidityParameters.idSlippage = overflown24;\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__IdDesiredOverflows.selector, overflown24, overflown24));\n        router.addLiquidity(_liquidityParameters);\n    }\n\n    function testForLengthsMismatchReverts() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = prepareLiquidityParameters(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        int256[] memory _wrongLengthDeltaIds = new int256[](_numberBins - 1);\n\n        _liquidityParameters.deltaIds = _wrongLengthDeltaIds;\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.addLiquidity(_liquidityParameters);\n    }\n\n    function testWrongTokenOrderReverts() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = prepareLiquidityParameters(\n            token18D,\n            token6D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        vm.expectRevert(LBRouter__WrongTokenOrder.selector);\n        router.addLiquidity(_liquidityParameters);\n        vm.expectRevert(LBRouter__WrongTokenOrder.selector);\n        router.addLiquidityAVAX(_liquidityParameters);\n    }\n\n    function testAddLiquidityAVAXnotAVAXReverts() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = prepareLiquidityParameters(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                LBRouter__WrongAvaxLiquidityParameters.selector,\n                _liquidityParameters.tokenX,\n                _liquidityParameters.tokenY,\n                _liquidityParameters.amountX,\n                _liquidityParameters.amountY,\n                0\n            )\n        );\n        router.addLiquidityAVAX(_liquidityParameters);\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinRouterTest is TestHelper {\n    LBPair internal pair0;\n    LBPair internal pair1;\n    LBPair internal pair2;\n    LBPair internal pair3;\n    LBPair internal taxTokenPair1;\n    LBPair internal taxTokenPair;\n\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token10D = new ERC20MockDecimals(10);\n        token12D = new ERC20MockDecimals(12);\n        token18D = new ERC20MockDecimals(18);\n        token24D = new ERC20MockDecimals(24);\n\n        taxToken = new ERC20WithTransferTax();\n\n        wavax = new WAVAX();\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n\n        router = new LBRouter(factory, IJoeFactory(JOE_V1_FACTORY_ADDRESS), IWAVAX(address(wavax)));\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n        addLiquidityFromRouter(token6D, token18D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n\n        pair0 = createLBPairDefaultFees(token6D, token10D);\n        addLiquidityFromRouter(token6D, token10D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n        pair1 = createLBPairDefaultFees(token10D, token12D);\n        addLiquidityFromRouter(token10D, token12D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n        pair2 = createLBPairDefaultFees(token12D, token18D);\n        addLiquidityFromRouter(token12D, token18D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n        pair3 = createLBPairDefaultFees(token18D, token24D);\n        addLiquidityFromRouter(token18D, token24D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n        taxTokenPair1 = createLBPairDefaultFees(token6D, taxToken);\n        addLiquidityFromRouter(token6D, ERC20MockDecimals(address(taxToken)), 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n\n        taxTokenPair = createLBPairDefaultFees(taxToken, wavax);\n        addLiquidityFromRouter(\n            ERC20MockDecimals(address(taxToken)),\n            ERC20MockDecimals(address(wavax)),\n            100e18,\n            ID_ONE,\n            9,\n            2,\n            DEFAULT_BIN_STEP\n        );\n\n        pairWavax = createLBPairDefaultFees(token6D, wavax);\n        addLiquidityFromRouter(token6D, ERC20MockDecimals(address(wavax)), 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n    }\n\n    function testSwapExactTokensForTokensSinglePair() public {\n        uint256 amountIn = 1e18;\n\n        token6D.mint(DEV, amountIn);\n\n        token6D.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = token6D;\n        tokenList[1] = token18D;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        (uint256 amountOut, ) = router.getSwapOut(pair, amountIn, true);\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InsufficientAmountOut.selector, amountOut + 1, amountOut));\n        router.swapExactTokensForTokens(amountIn, amountOut + 1, pairVersions, tokenList, DEV, block.timestamp);\n\n        router.swapExactTokensForTokens(amountIn, amountOut, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertApproxEqAbs(token18D.balanceOf(DEV), amountOut, 10);\n    }\n\n    function testSwapExactTokensForAvaxSinglePair() public {\n        uint256 amountIn = 1e18;\n\n        token6D.mint(ALICE, amountIn);\n\n        vm.startPrank(ALICE);\n        token6D.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = token6D;\n        tokenList[1] = wavax;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        (uint256 amountOut, ) = router.getSwapOut(pair, amountIn, true);\n\n        uint256 devBalanceBefore = ALICE.balance;\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InsufficientAmountOut.selector, amountOut + 1, amountOut));\n        router.swapExactTokensForAVAX(amountIn, amountOut + 1, pairVersions, tokenList, ALICE, block.timestamp);\n\n        router.swapExactTokensForAVAX(amountIn, amountOut, pairVersions, tokenList, ALICE, block.timestamp);\n        vm.stopPrank();\n\n        assertEq(ALICE.balance - devBalanceBefore, amountOut);\n    }\n\n    function testSwapExactAVAXForTokensSinglePair() public {\n        uint256 amountIn = 1e18;\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = wavax;\n        tokenList[1] = token6D;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        (uint256 amountOut, ) = router.getSwapOut(pairWavax, amountIn, false);\n\n        vm.deal(DEV, amountIn);\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InsufficientAmountOut.selector, amountOut + 1, amountOut));\n        router.swapExactAVAXForTokens{value: amountIn}(amountOut + 1, pairVersions, tokenList, DEV, block.timestamp);\n\n        router.swapExactAVAXForTokens{value: amountIn}(amountOut, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertApproxEqAbs(token6D.balanceOf(DEV), amountOut, 13);\n    }\n\n    function testSwapTokensForExactTokensSinglePair() public {\n        uint256 amountOut = 1e18;\n\n        (uint256 amountIn, ) = router.getSwapIn(pair, amountOut, true);\n        token6D.mint(DEV, amountIn);\n\n        token6D.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = token6D;\n        tokenList[1] = token18D;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__MaxAmountInExceeded.selector, amountIn - 1, amountIn));\n        router.swapTokensForExactTokens(amountOut, amountIn - 1, pairVersions, tokenList, DEV, block.timestamp);\n\n        router.swapTokensForExactTokens(amountOut, amountIn, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertApproxEqAbs(token18D.balanceOf(DEV), amountOut, 10);\n    }\n\n    function testSwapTokensForExactAVAXSinglePair() public {\n        uint256 amountOut = 1e18;\n\n        (uint256 amountIn, ) = router.getSwapIn(pairWavax, amountOut, true);\n        token6D.mint(ALICE, amountIn);\n\n        vm.startPrank(ALICE);\n        token6D.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = token6D;\n        tokenList[1] = wavax;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        uint256 devBalanceBefore = ALICE.balance;\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__MaxAmountInExceeded.selector, amountIn - 1, amountIn));\n        router.swapTokensForExactAVAX(amountOut, amountIn - 1, pairVersions, tokenList, ALICE, block.timestamp);\n\n        router.swapTokensForExactAVAX(amountOut, amountIn, pairVersions, tokenList, ALICE, block.timestamp);\n        vm.stopPrank();\n\n        assertEq(ALICE.balance - devBalanceBefore, amountOut);\n    }\n\n    function testSwapAVAXForExactTokensSinglePair() public {\n        uint256 amountOut = 1e18;\n\n        (uint256 amountIn, ) = router.getSwapIn(pairWavax, amountOut, false);\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = wavax;\n        tokenList[1] = token6D;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        vm.deal(DEV, amountIn);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__MaxAmountInExceeded.selector, amountIn - 1, amountIn));\n        router.swapAVAXForExactTokens{value: amountIn - 1}(amountOut, pairVersions, tokenList, ALICE, block.timestamp);\n        router.swapAVAXForExactTokens{value: amountIn}(amountOut, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertApproxEqAbs(token6D.balanceOf(DEV), amountOut, 13);\n    }\n\n    function testSwapExactTokensForTokensSupportingFeeOnTransferTokens() public {\n        uint256 amountIn = 1e18;\n\n        taxToken.mint(DEV, amountIn);\n\n        taxToken.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = taxToken;\n        tokenList[1] = wavax;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        (uint256 amountOut, ) = router.getSwapOut(taxTokenPair, amountIn, true);\n        amountOut = amountOut / 2;\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InsufficientAmountOut.selector, amountOut + 2, amountOut + 1));\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn,\n            amountOut + 2,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn,\n            0,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        // 50% tax to take into account\n        assertApproxEqAbs(wavax.balanceOf(DEV), amountOut, 10);\n\n        // Swap back in the other direction\n        amountIn = wavax.balanceOf(DEV);\n        wavax.approve(address(router), amountIn);\n        tokenList[0] = wavax;\n        tokenList[1] = taxToken;\n\n        (amountOut, ) = router.getSwapOut(taxTokenPair, amountIn, true);\n        amountOut = amountOut / 2;\n        uint256 balanceBefore = taxToken.balanceOf(DEV);\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InsufficientAmountOut.selector, amountOut + 2, amountOut + 1));\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn,\n            amountOut + 2,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn,\n            amountOut,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        assertApproxEqAbs(taxToken.balanceOf(DEV) - balanceBefore, amountOut, 10);\n    }\n\n    function testSwapExactTokensForAVAXSupportingFeeOnTransferTokens() public {\n        uint256 amountIn = 1e18;\n\n        taxToken.mint(ALICE, amountIn);\n\n        vm.startPrank(ALICE);\n        taxToken.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = taxToken;\n        tokenList[1] = wavax;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        (uint256 amountOut, ) = router.getSwapOut(taxTokenPair, amountIn, true);\n        amountOut = amountOut / 2;\n        uint256 devBalanceBefore = ALICE.balance;\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InsufficientAmountOut.selector, amountOut + 2, amountOut + 1));\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            amountIn,\n            amountOut + 2,\n            pairVersions,\n            tokenList,\n            ALICE,\n            block.timestamp\n        );\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            amountIn,\n            amountOut,\n            pairVersions,\n            tokenList,\n            ALICE,\n            block.timestamp\n        );\n        vm.stopPrank();\n\n        assertGe(ALICE.balance - devBalanceBefore, amountOut);\n    }\n\n    function testSwapExactAVAXForTokensSupportingFeeOnTransferTokens() public {\n        uint256 amountIn = 1e18;\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = wavax;\n        tokenList[1] = taxToken;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        (uint256 amountOut, ) = router.getSwapOut(taxTokenPair, amountIn, true);\n        amountOut = amountOut / 2;\n        vm.deal(DEV, amountIn);\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InsufficientAmountOut.selector, amountOut + 2, amountOut + 1));\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens{value: amountIn}(\n            amountOut + 2,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens{value: amountIn}(\n            amountOut,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        assertApproxEqAbs(taxToken.balanceOf(DEV), amountOut, 10);\n    }\n\n    function testSwapExactTokensForTokensMultiplePairs() public {\n        uint256 amountIn = 1e18;\n\n        token6D.mint(DEV, amountIn);\n\n        token6D.approve(address(router), amountIn);\n\n        (IERC20[] memory tokenList, uint256[] memory pairVersions) = _buildComplexSwapRoute();\n\n        router.swapExactTokensForTokens(amountIn, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertGt(token24D.balanceOf(DEV), 0);\n    }\n\n    function testSwapTokensForExactTokensMultiplePairs() public {\n        uint256 amountOut = 1e18;\n\n        token6D.mint(DEV, 100e18);\n\n        token6D.approve(address(router), 100e18);\n\n        (IERC20[] memory tokenList, uint256[] memory pairVersions) = _buildComplexSwapRoute();\n        vm.expectRevert(\n            abi.encodeWithSelector(LBRouter__MaxAmountInExceeded.selector, 100500938281494149, 1005009382814941406)\n        );\n        router.swapTokensForExactTokens(amountOut, 100500938281494149, pairVersions, tokenList, DEV, block.timestamp);\n        router.swapTokensForExactTokens(amountOut, 100e18, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertEq(token24D.balanceOf(DEV), amountOut);\n    }\n\n    function testSwapWithDifferentBinSteps() public {\n        factory.setPreset(\n            75,\n            DEFAULT_BASE_FACTOR,\n            DEFAULT_FILTER_PERIOD,\n            DEFAULT_DECAY_PERIOD,\n            5,\n            10,\n            DEFAULT_PROTOCOL_SHARE,\n            DEFAULT_MAX_VOLATILITY_ACCUMULATED,\n            DEFAULT_SAMPLE_LIFETIME\n        );\n        createLBPairDefaultFeesFromStartIdAndBinStep(token6D, token18D, ID_ONE, 75);\n        addLiquidityFromRouter(token6D, token18D, 100e18, ID_ONE, 9, 2, 75);\n\n        uint256 amountIn = 1e18;\n\n        token6D.mint(DEV, amountIn);\n        token6D.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList;\n        uint256[] memory pairVersions;\n        tokenList = new IERC20[](2);\n        tokenList[0] = token6D;\n        tokenList[1] = token18D;\n        pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        router.swapExactTokensForTokens(amountIn, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertGt(token18D.balanceOf(DEV), 0);\n\n        token18D.approve(address(router), token18D.balanceOf(DEV));\n\n        tokenList[0] = token18D;\n        tokenList[1] = token6D;\n        pairVersions = new uint256[](1);\n        pairVersions[0] = 75;\n\n        router.swapExactTokensForTokens(token18D.balanceOf(DEV), 0, pairVersions, tokenList, DEV, block.timestamp);\n        assertGt(token6D.balanceOf(DEV), 0);\n    }\n\n    function _buildComplexSwapRoute() private view returns (IERC20[] memory tokenList, uint256[] memory pairVersions) {\n        tokenList = new IERC20[](5);\n        tokenList[0] = token6D;\n        tokenList[1] = token10D;\n        tokenList[2] = token12D;\n        tokenList[3] = token18D;\n        tokenList[4] = token24D;\n\n        pairVersions = new uint256[](4);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n        pairVersions[1] = DEFAULT_BIN_STEP;\n        pairVersions[2] = DEFAULT_BIN_STEP;\n        pairVersions[3] = DEFAULT_BIN_STEP;\n    }\n\n    function testTaxTokenEqualOnlyV2Swap() public {\n        uint256 amountIn = 1e18;\n\n        taxToken.mint(ALICE, amountIn);\n        taxToken.mint(BOB, amountIn);\n        token6D.mint(ALICE, amountIn);\n        token6D.mint(BOB, amountIn);\n\n        IERC20[] memory tokenList = new IERC20[](3);\n        tokenList[0] = token6D;\n        tokenList[1] = taxToken;\n        tokenList[2] = wavax;\n        uint256[] memory pairVersions = new uint256[](2);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n        pairVersions[1] = DEFAULT_BIN_STEP;\n\n        vm.startPrank(ALICE);\n        token6D.approve(address(router), amountIn);\n        taxToken.approve(address(router), amountIn);\n        uint256 aliceBalanceBefore = ALICE.balance;\n        uint256 amountOutNotSupporting = router.swapExactTokensForAVAX(\n            amountIn,\n            0,\n            pairVersions,\n            tokenList,\n            ALICE,\n            block.timestamp\n        );\n        vm.stopPrank();\n\n        vm.startPrank(BOB);\n        token6D.approve(address(router), amountIn);\n        taxToken.approve(address(router), amountIn);\n        uint256 bobBalanceBefore = BOB.balance;\n        uint256 amountOutSupporting = router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            amountIn,\n            0,\n            pairVersions,\n            tokenList,\n            BOB,\n            block.timestamp\n        );\n        vm.stopPrank();\n\n        assertEq(ALICE.balance, BOB.balance);\n        assertEq(amountOutNotSupporting, amountOutSupporting);\n    }\n\n    function testSwappingOnNotExistingV2PairReverts() public {\n        IERC20[] memory tokenListAvaxIn;\n        IERC20[] memory tokenList;\n        uint256[] memory pairVersions;\n\n        uint256 amountIn2 = 1e18;\n        vm.deal(DEV, amountIn2);\n\n        tokenList = new IERC20[](3);\n        tokenList[0] = token6D;\n        tokenList[1] = token18D;\n        tokenList[2] = wavax;\n\n        pairVersions = new uint256[](2);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n        pairVersions[1] = DEFAULT_BIN_STEP + 1;\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapExactTokensForTokens(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapExactTokensForAVAX(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapTokensForExactTokens(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapTokensForExactAVAX(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn2,\n            0,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            amountIn2,\n            0,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        tokenListAvaxIn = new IERC20[](3);\n        tokenListAvaxIn[0] = wavax;\n        tokenListAvaxIn[1] = token6D;\n        tokenListAvaxIn[2] = token18D;\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token6D, token18D, pairVersions[1]));\n        router.swapExactAVAXForTokens{value: amountIn2}(0, pairVersions, tokenListAvaxIn, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token6D, token18D, pairVersions[1]));\n        router.swapAVAXForExactTokens{value: amountIn2}(0, pairVersions, tokenListAvaxIn, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token6D, token18D, pairVersions[1]));\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens{value: amountIn2}(\n            0,\n            pairVersions,\n            tokenListAvaxIn,\n            DEV,\n            block.timestamp\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract LiquidityBinRouterForkTest is TestHelper {\n    LBPair internal pair0;\n    LBPair internal pair1;\n    LBPair internal pair2;\n    LBPair internal pair3;\n    LBPair internal taxTokenPair;\n\n    function setUp() public {\n        vm.createSelectFork(vm.rpcUrl(\"avalanche\"), 19_358_000);\n        token6D = new ERC20MockDecimals(6);\n        token10D = new ERC20MockDecimals(10);\n        token12D = new ERC20MockDecimals(12);\n        token18D = new ERC20MockDecimals(18);\n        token24D = new ERC20MockDecimals(24);\n\n        taxToken = new ERC20WithTransferTax();\n\n        wavax = WAVAX(WAVAX_AVALANCHE_ADDRESS);\n        usdc = ERC20MockDecimals(USDC_AVALANCHE_ADDRESS);\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n\n        router = new LBRouter(factory, IJoeFactory(JOE_V1_FACTORY_ADDRESS), IWAVAX(address(wavax)));\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n        addLiquidityFromRouter(token6D, token18D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n\n        pair0 = createLBPairDefaultFees(token6D, token10D);\n        addLiquidityFromRouter(token6D, token10D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n        pair1 = createLBPairDefaultFees(token10D, token12D);\n        addLiquidityFromRouter(token10D, token12D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n        pair2 = createLBPairDefaultFees(token12D, token18D);\n        addLiquidityFromRouter(token12D, token18D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n        pair3 = createLBPairDefaultFees(token18D, token24D);\n        addLiquidityFromRouter(token18D, token24D, 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n\n        taxTokenPair = createLBPairDefaultFees(taxToken, wavax);\n        addLiquidityFromRouter(\n            ERC20MockDecimals(address(taxToken)),\n            ERC20MockDecimals(address(wavax)),\n            100e18,\n            ID_ONE,\n            9,\n            2,\n            DEFAULT_BIN_STEP\n        );\n\n        pairWavax = createLBPairDefaultFees(token6D, wavax);\n        addLiquidityFromRouter(token6D, ERC20MockDecimals(address(wavax)), 100e18, ID_ONE, 9, 2, DEFAULT_BIN_STEP);\n    }\n\n    function testSwapExactTokensForTokensMultiplePairsWithV1() public {\n        if (block.number < 1000) {\n            console.log(\"fork mainnet for V1 testing support\");\n            return;\n        }\n\n        uint256 amountIn = 1e18;\n\n        token6D.mint(DEV, amountIn);\n\n        token6D.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList;\n        uint256[] memory pairVersions;\n\n        tokenList = new IERC20[](3);\n        tokenList[0] = token6D;\n        tokenList[1] = wavax;\n        tokenList[2] = usdc;\n\n        pairVersions = new uint256[](2);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n        pairVersions[1] = 0;\n\n        router.swapExactTokensForTokens(amountIn, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertGt(usdc.balanceOf(DEV), 0);\n\n        tokenList[0] = usdc;\n        tokenList[1] = wavax;\n        tokenList[2] = token6D;\n\n        pairVersions[0] = 0;\n        pairVersions[1] = DEFAULT_BIN_STEP;\n\n        uint256 balanceBefore = token6D.balanceOf(DEV);\n\n        usdc.approve(address(router), usdc.balanceOf(DEV));\n        router.swapExactTokensForTokens(usdc.balanceOf(DEV), 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertGt(token6D.balanceOf(DEV) - balanceBefore, 0);\n    }\n\n    function testSwapTokensForExactTokensMultiplePairsWithV1() public {\n        if (block.number < 1000) {\n            console.log(\"fork mainnet for V1 testing support\");\n            return;\n        }\n\n        uint256 amountOut = 1e6;\n\n        token6D.mint(DEV, 100e18);\n\n        token6D.approve(address(router), 100e18);\n\n        IERC20[] memory tokenList;\n        uint256[] memory pairVersions;\n\n        tokenList = new IERC20[](3);\n        tokenList[0] = token6D;\n        tokenList[1] = wavax;\n        tokenList[2] = usdc;\n\n        pairVersions = new uint256[](2);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n        pairVersions[1] = 0;\n\n        router.swapTokensForExactTokens(amountOut, 100e18, pairVersions, tokenList, DEV, block.timestamp);\n\n        assertEq(usdc.balanceOf(DEV), amountOut);\n\n        tokenList[0] = usdc;\n        tokenList[1] = wavax;\n        tokenList[2] = token6D;\n\n        pairVersions[0] = 0;\n        pairVersions[1] = DEFAULT_BIN_STEP;\n\n        uint256 balanceBefore = token6D.balanceOf(DEV);\n\n        usdc.approve(address(router), usdc.balanceOf(DEV));\n        router.swapTokensForExactTokens(amountOut, usdc.balanceOf(DEV), pairVersions, tokenList, DEV, block.timestamp);\n\n        assertEq(token6D.balanceOf(DEV) - balanceBefore, amountOut);\n\n        vm.stopPrank();\n    }\n\n    function testTaxTokenSwappedOnV1Pairs() public {\n        if (block.number < 1000) {\n            console.log(\"fork mainnet for V1 testing support\");\n            return;\n        }\n        uint256 amountIn = 100e18;\n\n        IJoeFactory factoryv1 = IJoeFactory(JOE_V1_FACTORY_ADDRESS);\n        //create taxToken-AVAX pair in DEXv1\n        address taxPairv11 = factoryv1.createPair(address(taxToken), address(wavax));\n        taxToken.mint(taxPairv11, amountIn);\n        vm.deal(DEV, amountIn);\n        wavax.deposit{value: amountIn}();\n        wavax.transfer(taxPairv11, amountIn);\n        IJoePair(taxPairv11).mint(DEV);\n\n        //create taxToken-token6D pair in DEXv1\n        address taxPairv12 = factoryv1.createPair(address(taxToken), address(token6D));\n        taxToken.mint(taxPairv12, amountIn);\n        token6D.mint(taxPairv12, amountIn);\n        IJoePair(taxPairv12).mint(DEV);\n\n        token6D.mint(DEV, amountIn);\n        token6D.approve(address(router), amountIn);\n\n        IERC20[] memory tokenList;\n        uint256[] memory pairVersions;\n\n        tokenList = new IERC20[](3);\n        tokenList[0] = token6D;\n        tokenList[1] = taxToken;\n        tokenList[2] = wavax;\n\n        pairVersions = new uint256[](2);\n        pairVersions[0] = 0;\n        pairVersions[1] = 0;\n        uint256 amountIn2 = 1e18;\n\n        vm.expectRevert(\"Joe: K\");\n        router.swapExactTokensForTokens(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn2,\n            0,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n        vm.deal(DEV, amountIn2);\n        vm.expectRevert(\"Joe: K\");\n        router.swapExactTokensForAVAX(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            amountIn2,\n            0,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        tokenList[0] = wavax;\n        tokenList[1] = taxToken;\n        tokenList[2] = token6D;\n\n        vm.deal(DEV, amountIn2);\n        vm.expectRevert(\"Joe: K\");\n        router.swapExactAVAXForTokens{value: amountIn2}(0, pairVersions, tokenList, DEV, block.timestamp);\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens{value: amountIn2}(\n            0,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n    }\n\n    function testSwappingOnNotExistingV1PairReverts() public {\n        IERC20[] memory tokenListAvaxIn;\n        IERC20[] memory tokenList;\n        uint256[] memory pairVersions;\n\n        uint256 amountIn2 = 1e18;\n        vm.deal(DEV, amountIn2);\n\n        tokenList = new IERC20[](3);\n        tokenList[0] = token6D;\n        tokenList[1] = token18D;\n        tokenList[2] = wavax;\n\n        pairVersions = new uint256[](2);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n        pairVersions[1] = 0;\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapExactTokensForTokens(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapExactTokensForAVAX(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapTokensForExactTokens(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapTokensForExactAVAX(amountIn2, 0, pairVersions, tokenList, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn2,\n            0,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token18D, wavax, pairVersions[1]));\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            amountIn2,\n            0,\n            pairVersions,\n            tokenList,\n            DEV,\n            block.timestamp\n        );\n\n        tokenListAvaxIn = new IERC20[](3);\n        tokenListAvaxIn[0] = wavax;\n        tokenListAvaxIn[1] = token6D;\n        tokenListAvaxIn[2] = token18D;\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token6D, token18D, pairVersions[1]));\n        router.swapExactAVAXForTokens{value: amountIn2}(0, pairVersions, tokenListAvaxIn, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token6D, token18D, pairVersions[1]));\n        router.swapAVAXForExactTokens{value: amountIn2}(0, pairVersions, tokenListAvaxIn, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__PairNotCreated.selector, token6D, token18D, pairVersions[1]));\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens{value: amountIn2}(\n            0,\n            pairVersions,\n            tokenListAvaxIn,\n            DEV,\n            block.timestamp\n        );\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./libraries/BinHelper.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/FeeHelper.sol\";\nimport \"./libraries/Math512Bits.sol\";\nimport \"./libraries/SwapHelper.sol\";\nimport \"./libraries/TokenHelper.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/ILBToken.sol\";\nimport \"./interfaces/ILBRouter.sol\";\n\n/// @title Liquidity Book Router\n/// @author Trader Joe\n/// @notice Main contract to interact with to swap and manage liquidity on Joe V2 exchange.\ncontract LBRouter is ILBRouter {\n    using TokenHelper for IERC20;\n    using TokenHelper for IWAVAX;\n    using FeeHelper for FeeHelper.FeeParameters;\n    using Math512Bits for uint256;\n    using SwapHelper for ILBPair.Bin;\n\n    ILBFactory public immutable override factory;\n    IJoeFactory public immutable override oldFactory;\n    IWAVAX public immutable override wavax;\n\n    modifier onlyFactoryOwner() {\n        if (msg.sender != factory.owner()) revert LBRouter__NotFactoryOwner();\n        _;\n    }\n\n    modifier ensure(uint256 _deadline) {\n        if (block.timestamp > _deadline) revert LBRouter__DeadlineExceeded(_deadline, block.timestamp);\n        _;\n    }\n\n    modifier verifyInputs(uint256[] memory _pairBinSteps, IERC20[] memory _tokenPath) {\n        if (_pairBinSteps.length == 0 || _pairBinSteps.length + 1 != _tokenPath.length)\n            revert LBRouter__LengthsMismatch();\n        _;\n    }\n\n    /// @notice Constructor\n    /// @param _factory LBFactory address\n    /// @param _oldFactory Address of old factory (Joe V1)\n    /// @param _wavax Address of WAVAX\n    constructor(\n        ILBFactory _factory,\n        IJoeFactory _oldFactory,\n        IWAVAX _wavax\n    ) {\n        factory = _factory;\n        oldFactory = _oldFactory;\n        wavax = _wavax;\n    }\n\n    /// @dev Receive function that only accept AVAX from the WAVAX contract\n    receive() external payable {\n        if (msg.sender != address(wavax)) revert LBRouter__SenderIsNotWAVAX();\n    }\n\n    /// @notice Returns the approximate id corresponding to the inputted price.\n    /// Warning, the returned id may be inaccurate close to the start price of a bin\n    /// @param _LBPair The address of the LBPair\n    /// @param _price The price of y per x (multiplied by 1e36)\n    /// @return The id corresponding to this price\n    function getIdFromPrice(ILBPair _LBPair, uint256 _price) external view override returns (uint24) {\n        return BinHelper.getIdFromPrice(_price, _LBPair.feeParameters().binStep);\n    }\n\n    /// @notice Returns the price corresponding to the inputted id\n    /// @param _LBPair The address of the LBPair\n    /// @param _id The id\n    /// @return The price corresponding to this id\n    function getPriceFromId(ILBPair _LBPair, uint24 _id) external view override returns (uint256) {\n        return BinHelper.getPriceFromId(_id, _LBPair.feeParameters().binStep);\n    }\n\n    /// @notice Simulate a swap in\n    /// @param _LBPair The address of the LBPair\n    /// @param _amountOut The amount of token to receive\n    /// @param _swapForY Whether you swap X for Y (true), or Y for X (false)\n    /// @return amountIn The amount of token to send in order to receive _amountOut token\n    /// @return feesIn The amount of fees paid in token sent\n    function getSwapIn(\n        ILBPair _LBPair,\n        uint256 _amountOut,\n        bool _swapForY\n    ) public view override returns (uint256 amountIn, uint256 feesIn) {\n        (uint256 _pairReserveX, uint256 _pairReserveY, uint256 _activeId) = _LBPair.getReservesAndId();\n\n        if (_amountOut == 0 || (_swapForY ? _amountOut > _pairReserveY : _amountOut > _pairReserveX))\n            revert LBRouter__WrongAmounts(_amountOut, _swapForY ? _pairReserveY : _pairReserveX); // If this is wrong, then we're sure the amounts sent are wrong\n\n        FeeHelper.FeeParameters memory _fp = _LBPair.feeParameters();\n        _fp.updateVariableFeeParameters(_activeId);\n\n        uint256 _amountOutOfBin;\n        uint256 _amountInWithFees;\n        uint256 _reserve;\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstNonEmptyBinId function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            {\n                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));\n                _reserve = _swapForY ? _reserveY : _reserveX;\n            }\n            uint256 _price = BinHelper.getPriceFromId(_activeId, _fp.binStep);\n            if (_reserve != 0) {\n                _amountOutOfBin = _amountOut > _reserve ? _reserve : _amountOut;\n\n                uint256 _amountInToBin = _swapForY\n                    ? _amountOutOfBin.shiftDivRoundUp(Constants.SCALE_OFFSET, _price)\n                    : _price.mulShiftRoundUp(_amountOutOfBin, Constants.SCALE_OFFSET);\n\n                // We update the fee, but we don't store the new volatility reference, volatility accumulated and indexRef to not penalize traders\n                _fp.updateVolatilityAccumulated(_activeId);\n                uint256 _fee = _fp.getFeeAmount(_amountInToBin);\n                _amountInWithFees = _amountInToBin + _fee;\n\n                if (_amountInWithFees + _reserve > type(uint112).max) revert LBRouter__SwapOverflows(_activeId);\n                amountIn += _amountInWithFees;\n                feesIn += _fee;\n                _amountOut -= _amountOutOfBin;\n            }\n\n            if (_amountOut != 0) {\n                _activeId = _LBPair.findFirstNonEmptyBinId(uint24(_activeId), _swapForY);\n            } else {\n                break;\n            }\n        }\n        if (_amountOut != 0) revert LBRouter__BrokenSwapSafetyCheck(); // Safety check, but should never be false as it would have reverted on transfer\n    }\n\n    /// @notice Simulate a swap out\n    /// @param _LBPair The address of the LBPair\n    /// @param _amountIn The amount of token sent\n    /// @param _swapForY Whether you swap X for Y (true), or Y for X (false)\n    /// @return amountOut The amount of token received if _amountIn tokenX are sent\n    /// @return feesIn The amount of fees paid in token sent\n    function getSwapOut(\n        ILBPair _LBPair,\n        uint256 _amountIn,\n        bool _swapForY\n    ) external view override returns (uint256 amountOut, uint256 feesIn) {\n        (, , uint256 _activeId) = _LBPair.getReservesAndId();\n\n        FeeHelper.FeeParameters memory _fp = _LBPair.feeParameters();\n        _fp.updateVariableFeeParameters(_activeId);\n        ILBPair.Bin memory _bin;\n\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstNonEmptyBinId function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            {\n                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));\n                _bin = ILBPair.Bin(uint112(_reserveX), uint112(_reserveY), 0, 0);\n            }\n            if (_bin.reserveX != 0 || _bin.reserveY != 0) {\n                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin\n                    .getAmounts(_fp, _activeId, _swapForY, _amountIn);\n\n                if (_amountInToBin > type(uint112).max) revert LBRouter__BinReserveOverflows(_activeId);\n\n                _amountIn -= _amountInToBin + _fees.total;\n                feesIn += _fees.total;\n                amountOut += _amountOutOfBin;\n            }\n\n            if (_amountIn != 0) {\n                _activeId = _LBPair.findFirstNonEmptyBinId(uint24(_activeId), _swapForY);\n            } else {\n                break;\n            }\n        }\n        if (_amountIn != 0) revert LBRouter__TooMuchTokensIn(_amountIn);\n    }\n\n    /// @notice Create a liquidity bin LBPair for _tokenX and _tokenY using the factory\n    /// @param _tokenX The address of the first token\n    /// @param _tokenY The address of the second token\n    /// @param _activeId The active id of the pair\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @return pair The address of the newly created LBPair\n    function createLBPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _binStep\n    ) external override returns (ILBPair pair) {\n        pair = factory.createLBPair(_tokenX, _tokenY, _activeId, _binStep);\n    }\n\n    /// @notice Add liquidity while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _liquidityParameters The liquidity parameters\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function addLiquidity(LiquidityParameters memory _liquidityParameters)\n        external\n        override\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        ILBPair _LBPair = _getLBPairInformation(\n            _liquidityParameters.tokenX,\n            _liquidityParameters.tokenY,\n            _liquidityParameters.binStep\n        );\n        if (_liquidityParameters.tokenX != _LBPair.tokenX()) revert LBRouter__WrongTokenOrder();\n\n        _liquidityParameters.tokenX.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountX);\n        _liquidityParameters.tokenY.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountY);\n\n        (depositIds, liquidityMinted) = _addLiquidity(_liquidityParameters, _LBPair);\n    }\n\n    /// @notice Add liquidity with AVAX while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _liquidityParameters The liquidity parameters\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function addLiquidityAVAX(LiquidityParameters memory _liquidityParameters)\n        external\n        payable\n        override\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        ILBPair _LBPair = _getLBPairInformation(\n            _liquidityParameters.tokenX,\n            _liquidityParameters.tokenY,\n            _liquidityParameters.binStep\n        );\n        if (_liquidityParameters.tokenX != _LBPair.tokenX()) revert LBRouter__WrongTokenOrder();\n\n        if (_liquidityParameters.tokenX == wavax && _liquidityParameters.amountX == msg.value) {\n            _wavaxDepositAndTransfer(address(_LBPair), msg.value);\n            _liquidityParameters.tokenY.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountY);\n        } else if (_liquidityParameters.tokenY == wavax && _liquidityParameters.amountY == msg.value) {\n            _liquidityParameters.tokenX.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountX);\n            _wavaxDepositAndTransfer(address(_LBPair), msg.value);\n        } else\n            revert LBRouter__WrongAvaxLiquidityParameters(\n                address(_liquidityParameters.tokenX),\n                address(_liquidityParameters.tokenY),\n                _liquidityParameters.amountX,\n                _liquidityParameters.amountY,\n                msg.value\n            );\n\n        (depositIds, liquidityMinted) = _addLiquidity(_liquidityParameters, _LBPair);\n    }\n\n    /// @notice Remove liquidity while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _tokenX The address of token X\n    /// @param _tokenY The address of token Y\n    /// @param _binStep The bin step of the LBPair\n    /// @param _amountXMin The min amount to receive of token X\n    /// @param _amountYMin The min amount to receive of token Y\n    /// @param _ids The list of ids to burn\n    /// @param _amounts The list of amounts to burn of each id in `_ids`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountX Amount of token X returned\n    /// @return amountY Amount of token Y returned\n    function removeLiquidity(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint16 _binStep,\n        uint256 _amountXMin,\n        uint256 _amountYMin,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) returns (uint256 amountX, uint256 amountY) {\n        ILBPair _LBPair = _getLBPairInformation(_tokenX, _tokenY, _binStep);\n        if (_tokenX != _LBPair.tokenX()) {\n            (_tokenX, _tokenY) = (_tokenY, _tokenX);\n            (_amountXMin, _amountYMin) = (_amountYMin, _amountXMin);\n        }\n\n        (amountX, amountY) = _removeLiquidity(_LBPair, _amountXMin, _amountYMin, _ids, _amounts, _to);\n    }\n\n    /// @notice Remove AVAX liquidity while performing safety checks\n    /// @dev This function is **NOT** compliant with fee on transfer tokens.\n    /// This is wanted as it would make users pays the fee on transfer twice,\n    /// use the `removeLiquidity` function to remove liquidity with fee on transfer tokens.\n    /// @param _token The address of token\n    /// @param _binStep The bin step of the LBPair\n    /// @param _amountTokenMin The min amount to receive of token\n    /// @param _amountAVAXMin The min amount to receive of AVAX\n    /// @param _ids The list of ids to burn\n    /// @param _amounts The list of amounts to burn of each id in `_ids`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountToken Amount of token returned\n    /// @return amountAVAX Amount of AVAX returned\n    function removeLiquidityAVAX(\n        IERC20 _token,\n        uint16 _binStep,\n        uint256 _amountTokenMin,\n        uint256 _amountAVAXMin,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) returns (uint256 amountToken, uint256 amountAVAX) {\n        ILBPair _LBPair = _getLBPairInformation(_token, IERC20(wavax), _binStep);\n\n        bool _isAVAXTokenY = IERC20(wavax) == _LBPair.tokenY();\n        {\n            if (!_isAVAXTokenY) {\n                (_amountTokenMin, _amountAVAXMin) = (_amountAVAXMin, _amountTokenMin);\n            }\n\n            (uint256 _amountX, uint256 _amountY) = _removeLiquidity(\n                _LBPair,\n                _amountTokenMin,\n                _amountAVAXMin,\n                _ids,\n                _amounts,\n                address(this)\n            );\n\n            (amountToken, amountAVAX) = _isAVAXTokenY ? (_amountX, _amountY) : (_amountY, _amountX);\n        }\n\n        _token.safeTransfer(_to, amountToken);\n\n        wavax.withdraw(amountAVAX);\n        _safeTransferAVAX(_to, amountAVAX);\n    }\n\n    /// @notice Swaps exact tokens for tokens while performing safety checks\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        amountOut = _swapExactTokensForTokens(_amountIn, _pairs, _pairBinSteps, _tokenPath, _to);\n\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps exact tokens for AVAX while performing safety checks\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMinAVAX The min amount of AVAX to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForAVAX(\n        uint256 _amountIn,\n        uint256 _amountOutMinAVAX,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        amountOut = _swapExactTokensForTokens(_amountIn, _pairs, _pairBinSteps, _tokenPath, address(this));\n\n        if (_amountOutMinAVAX > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMinAVAX, amountOut);\n\n        wavax.withdraw(amountOut);\n        _safeTransferAVAX(_to, amountOut);\n    }\n\n    /// @notice Swaps exact AVAX for tokens while performing safety checks\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactAVAXForTokens(\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _wavaxDepositAndTransfer(_pairs[0], msg.value);\n\n        amountOut = _swapExactTokensForTokens(msg.value, _pairs, _pairBinSteps, _tokenPath, _to);\n\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps tokens for exact tokens while performing safety checks\n    /// @param _amountOut The amount of token to receive\n    /// @param _amountInMax The max amount of token to send\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapTokensForExactTokens(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256[] memory amountsIn) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);\n\n        if (amountsIn[0] > _amountInMax) revert LBRouter__MaxAmountInExceeded(_amountInMax, amountsIn[0]);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);\n\n        if (_amountOutReal < _amountOut) revert LBRouter__InsufficientAmountOut(_amountOut, _amountOutReal);\n    }\n\n    /// @notice Swaps tokens for exact AVAX while performing safety checks\n    /// @param _amountAVAXOut The amount of AVAX to receive\n    /// @param _amountInMax The max amount of token to send\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapTokensForExactAVAX(\n        uint256 _amountAVAXOut,\n        uint256 _amountInMax,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256[] memory amountsIn) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountAVAXOut);\n\n        if (amountsIn[0] > _amountInMax) revert LBRouter__MaxAmountInExceeded(_amountInMax, amountsIn[0]);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, address(this));\n\n        if (_amountOutReal < _amountAVAXOut) revert LBRouter__InsufficientAmountOut(_amountAVAXOut, _amountOutReal);\n\n        wavax.withdraw(_amountOutReal);\n        _safeTransferAVAX(_to, _amountOutReal);\n    }\n\n    /// @notice Swaps AVAX for exact tokens while performing safety checks\n    /// @dev will refund any excess sent\n    /// @param _amountOut The amount of tokens to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapAVAXForExactTokens(\n        uint256 _amountOut,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        override\n        ensure(_deadline)\n        verifyInputs(_pairBinSteps, _tokenPath)\n        returns (uint256[] memory amountsIn)\n    {\n        if (_tokenPath[0] != IERC20(wavax)) revert LBRouter__InvalidTokenPath(address(_tokenPath[0]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);\n\n        if (amountsIn[0] > msg.value) revert LBRouter__MaxAmountInExceeded(msg.value, amountsIn[0]);\n\n        _wavaxDepositAndTransfer(_pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);\n\n        if (_amountOutReal < _amountOut) revert LBRouter__InsufficientAmountOut(_amountOut, _amountOutReal);\n\n        if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value);\n    }\n\n    /// @notice Swaps exact tokens for tokens while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        IERC20 _targetToken = _tokenPath[_pairs.length];\n\n        uint256 _balanceBefore = _targetToken.balanceOf(_to);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, _to);\n\n        amountOut = _targetToken.balanceOf(_to) - _balanceBefore;\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps exact tokens for AVAX while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMinAVAX The min amount of AVAX to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMinAVAX,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        uint256 _balanceBefore = wavax.balanceOf(address(this));\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, address(this));\n\n        amountOut = wavax.balanceOf(address(this)) - _balanceBefore;\n        if (_amountOutMinAVAX > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMinAVAX, amountOut);\n\n        wavax.withdraw(amountOut);\n        _safeTransferAVAX(_to, amountOut);\n    }\n\n    /// @notice Swaps exact AVAX for tokens while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[0] != IERC20(wavax)) revert LBRouter__InvalidTokenPath(address(_tokenPath[0]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        IERC20 _targetToken = _tokenPath[_pairs.length];\n\n        uint256 _balanceBefore = _targetToken.balanceOf(_to);\n\n        _wavaxDepositAndTransfer(_pairs[0], msg.value);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, _to);\n\n        amountOut = _targetToken.balanceOf(_to) - _balanceBefore;\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Unstuck tokens that are sent to this contract by mistake\n    /// @dev Only callable by the factory owner\n    /// @param _token The address of the token\n    /// @param _to The address of the user to send back the tokens\n    /// @param _amount The amount to send\n    function sweep(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyFactoryOwner {\n        if (address(_token) == address(0)) {\n            if (_amount == type(uint256).max) _amount = address(this).balance;\n            _safeTransferAVAX(_to, _amount);\n        } else {\n            if (_amount == type(uint256).max) _amount = _token.balanceOf(address(this));\n            _token.safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Unstuck LBTokens that are sent to this contract by mistake\n    /// @dev Only callable by the factory owner\n    /// @param _lbToken The address of the LBToken\n    /// @param _to The address of the user to send back the tokens\n    /// @param _ids The list of token ids\n    /// @param _amounts The list of amounts to send\n    function sweepLBToken(\n        ILBToken _lbToken,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    ) external override onlyFactoryOwner {\n        _lbToken.safeBatchTransferFrom(address(this), _to, _ids, _amounts);\n    }\n\n    /// @notice Helper function to add liquidity\n    /// @param _liq The liquidity parameter\n    /// @param _LBPair LBPair where liquidity is deposited\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function _addLiquidity(LiquidityParameters memory _liq, ILBPair _LBPair)\n        private\n        ensure(_liq.deadline)\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        unchecked {\n            if (_liq.deltaIds.length != _liq.distributionX.length && _liq.deltaIds.length != _liq.distributionY.length)\n                revert LBRouter__LengthsMismatch();\n\n            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)\n                revert LBRouter__IdDesiredOverflows(_liq.activeIdDesired, _liq.idSlippage);\n\n            (, , uint256 _activeId) = _LBPair.getReservesAndId();\n            if (\n                _liq.activeIdDesired + _liq.idSlippage < _activeId || _activeId + _liq.idSlippage < _liq.activeIdDesired\n            ) revert LBRouter__IdSlippageCaught(_liq.activeIdDesired, _liq.idSlippage, _activeId);\n\n            depositIds = new uint256[](_liq.deltaIds.length);\n            for (uint256 i; i < depositIds.length; ++i) {\n                int256 _id = int256(_activeId) + _liq.deltaIds[i];\n                if (_id < 0 || uint256(_id) > type(uint24).max) revert LBRouter__IdOverflows(_id);\n                depositIds[i] = uint256(_id);\n            }\n\n            uint256 _amountXAdded;\n            uint256 _amountYAdded;\n\n            (_amountXAdded, _amountYAdded, liquidityMinted) = _LBPair.mint(\n                depositIds,\n                _liq.distributionX,\n                _liq.distributionY,\n                _liq.to\n            );\n\n            if (_amountXAdded < _liq.amountXMin || _amountYAdded < _liq.amountYMin)\n                revert LBRouter__AmountSlippageCaught(_liq.amountXMin, _amountXAdded, _liq.amountYMin, _amountYAdded);\n        }\n    }\n\n    /// @notice Helper function to return the amounts in\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _pairs The list of pairs\n    /// @param _tokenPath The swap path\n    /// @param _amountOut The amount out\n    /// @return amountsIn The list of amounts in\n    function _getAmountsIn(\n        uint256[] memory _pairBinSteps,\n        address[] memory _pairs,\n        IERC20[] memory _tokenPath,\n        uint256 _amountOut\n    ) private view returns (uint256[] memory amountsIn) {\n        amountsIn = new uint256[](_tokenPath.length);\n        // Avoid doing -1, as `_pairs.length == _pairBinSteps.length-1`\n        amountsIn[_pairs.length] = _amountOut;\n\n        for (uint256 i = _pairs.length; i != 0; i--) {\n            IERC20 _token = _tokenPath[i - 1];\n            uint256 _binStep = _pairBinSteps[i - 1];\n\n            address _pair = _pairs[i - 1];\n\n            if (_binStep == 0) {\n                (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();\n                if (_token > _tokenPath[i]) {\n                    (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);\n                }\n\n                uint256 amountOut_ = amountsIn[i];\n                // Legacy uniswap way of rounding\n                amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1;\n            } else {\n                (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);\n            }\n        }\n    }\n\n    /// @notice Helper function to remove liquidity\n    /// @param _LBPair The address of the LBPair\n    /// @param _amountXMin The min amount to receive of token X\n    /// @param _amountYMin The min amount to receive of token Y\n    /// @param _ids The list of ids to burn\n    /// @param _amounts The list of amounts to burn of each id in `_ids`\n    /// @param _to The address of the recipient\n    /// @param amountX The amount of token X sent by the pair\n    /// @param amountY The amount of token Y sent by the pair\n    function _removeLiquidity(\n        ILBPair _LBPair,\n        uint256 _amountXMin,\n        uint256 _amountYMin,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to\n    ) private returns (uint256 amountX, uint256 amountY) {\n        ILBToken(address(_LBPair)).safeBatchTransferFrom(msg.sender, address(_LBPair), _ids, _amounts);\n        (amountX, amountY) = _LBPair.burn(_ids, _amounts, _to);\n        if (amountX < _amountXMin || amountY < _amountYMin)\n            revert LBRouter__AmountSlippageCaught(_amountXMin, amountX, _amountYMin, amountY);\n    }\n\n    /// @notice Helper function to swap exact tokens for tokens\n    /// @param _amountIn The amount of token sent\n    /// @param _pairs The list of pairs\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @return amountOut The amount of token sent to `_to`\n    function _swapExactTokensForTokens(\n        uint256 _amountIn,\n        address[] memory _pairs,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to\n    ) private returns (uint256 amountOut) {\n        IERC20 _token;\n        uint256 _binStep;\n        address _recipient;\n        address _pair;\n\n        IERC20 _tokenNext = _tokenPath[0];\n        amountOut = _amountIn;\n\n        unchecked {\n            for (uint256 i; i < _pairs.length; ++i) {\n                _pair = _pairs[i];\n                _binStep = _pairBinSteps[i];\n\n                _token = _tokenNext;\n                _tokenNext = _tokenPath[i + 1];\n\n                _recipient = i + 1 == _pairs.length ? _to : _pairs[i + 1];\n\n                if (_binStep == 0) {\n                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n\n                    if (_token < _tokenNext) {\n                        amountOut = (_reserve1 * amountOut * 997) / (_reserve0 * 1_000 + amountOut * 997);\n                        IJoePair(_pair).swap(0, amountOut, _recipient, \"\");\n                    } else {\n                        amountOut = (_reserve0 * amountOut * 997) / (_reserve1 * 1_000 + amountOut * 997);\n                        IJoePair(_pair).swap(amountOut, 0, _recipient, \"\");\n                    }\n                } else {\n                    bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();\n\n                    (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);\n\n                    if (_swapForY) amountOut = _amountYOut;\n                    else amountOut = _amountXOut;\n                }\n            }\n        }\n    }\n\n    /// @notice Helper function to swap tokens for exact tokens\n    /// @param _pairs The array of pairs\n    /// @param _pairBinSteps The versions of each pair (1: DexV1, 2: dexV2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _amountsIn The list of amounts in\n    /// @param _to The address of the recipient\n    /// @return amountOut The amount of token sent to `_to`\n    function _swapTokensForExactTokens(\n        address[] memory _pairs,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        uint256[] memory _amountsIn,\n        address _to\n    ) private returns (uint256 amountOut) {\n        IERC20 _token;\n        uint256 _binStep;\n        address _recipient;\n        address _pair;\n\n        IERC20 _tokenNext = _tokenPath[0];\n\n        unchecked {\n            for (uint256 i; i < _pairs.length; ++i) {\n                _pair = _pairs[i];\n                _binStep = _pairBinSteps[i];\n\n                _token = _tokenNext;\n                _tokenNext = _tokenPath[i + 1];\n\n                _recipient = i + 1 == _pairs.length ? _to : _pairs[i + 1];\n\n                if (_binStep == 0) {\n                    amountOut = _amountsIn[i + 1];\n                    if (_token < _tokenNext) {\n                        IJoePair(_pair).swap(0, amountOut, _recipient, \"\");\n                    } else {\n                        IJoePair(_pair).swap(amountOut, 0, _recipient, \"\");\n                    }\n                } else {\n                    bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();\n\n                    (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);\n\n                    if (_swapForY) amountOut = _amountYOut;\n                    else amountOut = _amountXOut;\n                }\n            }\n        }\n    }\n\n    /// @notice Helper function to swap exact tokens supporting for fee on transfer tokens\n    /// @param _pairs The list of pairs\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    function _swapSupportingFeeOnTransferTokens(\n        address[] memory _pairs,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to\n    ) private {\n        IERC20 _token;\n        uint256 _binStep;\n        address _recipient;\n        address _pair;\n\n        IERC20 _tokenNext = _tokenPath[0];\n\n        unchecked {\n            for (uint256 i; i < _pairs.length; ++i) {\n                _pair = _pairs[i];\n                _binStep = _pairBinSteps[i];\n\n                _token = _tokenNext;\n                _tokenNext = _tokenPath[i + 1];\n\n                _recipient = i + 1 == _pairs.length ? _to : _pairs[i + 1];\n\n                if (_binStep == 0) {\n                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n                    if (_token < _tokenNext) {\n                        uint256 _balance = _token.balanceOf(_pair);\n                        uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000);\n\n                        IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");\n                    } else {\n                        uint256 _balance = _token.balanceOf(_pair);\n                        uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000);\n\n                        IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");\n                    }\n                } else {\n                    ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient);\n                }\n            }\n        }\n    }\n\n    /// @notice Helper function to return the address of the LBPair\n    /// @dev Revert if the pair is not created yet\n    /// @param _tokenX The address of the tokenX\n    /// @param _tokenY The address of the tokenY\n    /// @param _binStep The bin step of the LBPair\n    /// @return The address of the LBPair\n    function _getLBPairInformation(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint256 _binStep\n    ) private view returns (ILBPair) {\n        ILBPair _LBPair = factory.getLBPairInformation(_tokenX, _tokenY, _binStep).LBPair;\n        if (address(_LBPair) == address(0))\n            revert LBRouter__PairNotCreated(address(_tokenX), address(_tokenY), _binStep);\n        return _LBPair;\n    }\n\n    /// @notice Helper function to return the address of the pair (v1 or v2, according to `_binStep`)\n    /// @dev Revert if the pair is not created yet\n    /// @param _binStep The bin step of the LBPair, 0 means using V1 pair, any other value will use V2\n    /// @param _tokenX The address of the tokenX\n    /// @param _tokenY The address of the tokenY\n    /// @return _pair The address of the pair of binStep `_binStep`\n    function _getPair(\n        uint256 _binStep,\n        IERC20 _tokenX,\n        IERC20 _tokenY\n    ) private view returns (address _pair) {\n        if (_binStep == 0) {\n            _pair = oldFactory.getPair(address(_tokenX), address(_tokenY));\n            if (_pair == address(0)) revert LBRouter__PairNotCreated(address(_tokenX), address(_tokenY), _binStep);\n        } else _pair = address(_getLBPairInformation(_tokenX, _tokenY, _binStep));\n    }\n\n    function _getPairs(uint256[] memory _pairBinSteps, IERC20[] memory _tokenPath)\n        private\n        view\n        returns (address[] memory pairs)\n    {\n        pairs = new address[](_pairBinSteps.length);\n\n        IERC20 _token;\n        IERC20 _tokenNext = _tokenPath[0];\n        unchecked {\n            for (uint256 i; i < pairs.length; ++i) {\n                _token = _tokenNext;\n                _tokenNext = _tokenPath[i + 1];\n\n                pairs[i] = _getPair(_pairBinSteps[i], _token, _tokenNext);\n            }\n        }\n    }\n\n    /// @notice Helper function to transfer AVAX\n    /// @param _to The address of the recipient\n    /// @param _amount The AVAX amount to send\n    function _safeTransferAVAX(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        if (!success) revert LBRouter__FailedToSendAVAX(_to, _amount);\n    }\n\n    /// @notice Helper function to deposit and transfer wavax\n    /// @param _to The address of the recipient\n    /// @param _amount The AVAX amount to wrap\n    function _wavaxDepositAndTransfer(address _to, uint256 _amount) private {\n        wavax.deposit{value: _amount}();\n        wavax.safeTransfer(_to, _amount);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinRouterTest is TestHelper {\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n        wavax = new WAVAX();\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n\n        router = new LBRouter(factory, IJoeFactory(JOE_V1_FACTORY_ADDRESS), IWAVAX(WAVAX_AVALANCHE_ADDRESS));\n    }\n\n    function testConstructor() public {\n        assertEq(address(router.factory()), address(factory));\n        assertEq(address(router.oldFactory()), JOE_V1_FACTORY_ADDRESS);\n        assertEq(address(router.wavax()), WAVAX_AVALANCHE_ADDRESS);\n    }\n\n    function testCreateLBPair() public {\n        factory.setFactoryLockedState(false);\n\n        router.createLBPair(token6D, token18D, ID_ONE, DEFAULT_BIN_STEP);\n\n        assertEq(factory.getNumberOfLBPairs(), 1);\n        pair = LBPair(address(factory.getLBPairInformation(token6D, token18D, DEFAULT_BIN_STEP).LBPair));\n\n        assertEq(address(pair.factory()), address(factory));\n        assertEq(address(pair.tokenX()), address(token6D));\n        assertEq(address(pair.tokenY()), address(token18D));\n\n        FeeHelper.FeeParameters memory feeParameters = pair.feeParameters();\n        assertEq(feeParameters.volatilityAccumulated, 0);\n        assertEq(feeParameters.time, 0);\n        assertEq(feeParameters.maxVolatilityAccumulated, DEFAULT_MAX_VOLATILITY_ACCUMULATED);\n        assertEq(feeParameters.filterPeriod, DEFAULT_FILTER_PERIOD);\n        assertEq(feeParameters.decayPeriod, DEFAULT_DECAY_PERIOD);\n        assertEq(feeParameters.binStep, DEFAULT_BIN_STEP);\n        assertEq(feeParameters.baseFactor, DEFAULT_BASE_FACTOR);\n        assertEq(feeParameters.protocolShare, DEFAULT_PROTOCOL_SHARE);\n    }\n\n    function testModifierEnsure() public {\n        uint256[] memory defaultUintArray = new uint256[](2);\n        IERC20[] memory defaultIERCArray = new IERC20[](2);\n\n        uint256 wrongDeadline = block.timestamp - 1;\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.removeLiquidity(\n            token6D,\n            token18D,\n            DEFAULT_BIN_STEP,\n            1,\n            1,\n            defaultUintArray,\n            defaultUintArray,\n            DEV,\n            wrongDeadline\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.removeLiquidityAVAX(\n            token6D,\n            DEFAULT_BIN_STEP,\n            1,\n            1,\n            defaultUintArray,\n            defaultUintArray,\n            DEV,\n            wrongDeadline\n        );\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapExactTokensForTokens(1, 1, defaultUintArray, defaultIERCArray, DEV, wrongDeadline);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapExactTokensForAVAX(1, 1, defaultUintArray, defaultIERCArray, DEV, wrongDeadline);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapExactAVAXForTokens(1, defaultUintArray, defaultIERCArray, DEV, wrongDeadline);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapTokensForExactTokens(1, 1, defaultUintArray, defaultIERCArray, DEV, wrongDeadline);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapTokensForExactAVAX(1, 1, defaultUintArray, defaultIERCArray, DEV, wrongDeadline);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapAVAXForExactTokens(1, defaultUintArray, defaultIERCArray, DEV, wrongDeadline);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            1,\n            1,\n            defaultUintArray,\n            defaultIERCArray,\n            DEV,\n            wrongDeadline\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            1,\n            1,\n            defaultUintArray,\n            defaultIERCArray,\n            DEV,\n            wrongDeadline\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n            1,\n            defaultUintArray,\n            defaultIERCArray,\n            DEV,\n            wrongDeadline\n        );\n\n        //TODO _addLiquidity private\n    }\n\n    function testModifieronlyFactoryOwner() public {\n        vm.prank(ALICE);\n        vm.expectRevert(LBRouter__NotFactoryOwner.selector);\n        router.sweep(token6D, address(0), 1);\n    }\n\n    function testModifierVerifyInputs() public {\n        IERC20[] memory defaultIERCArray = new IERC20[](1);\n        uint256[] memory pairBinStepsZeroLength = new uint256[](0);\n        IERC20[] memory mismatchedIERCArray = new IERC20[](3);\n        uint256[] memory mismatchedpairBinSteps = new uint256[](4);\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactTokensForTokens(1, 1, pairBinStepsZeroLength, defaultIERCArray, DEV, block.timestamp);\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactTokensForTokens(1, 1, mismatchedpairBinSteps, mismatchedIERCArray, DEV, block.timestamp);\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactTokensForAVAX(1, 1, pairBinStepsZeroLength, defaultIERCArray, DEV, block.timestamp);\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactTokensForAVAX(1, 1, mismatchedpairBinSteps, mismatchedIERCArray, DEV, block.timestamp);\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactAVAXForTokens(1, pairBinStepsZeroLength, defaultIERCArray, DEV, block.timestamp);\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactAVAXForTokens(1, mismatchedpairBinSteps, mismatchedIERCArray, DEV, block.timestamp);\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapTokensForExactTokens(1, 1, pairBinStepsZeroLength, defaultIERCArray, DEV, block.timestamp);\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapTokensForExactTokens(1, 1, mismatchedpairBinSteps, mismatchedIERCArray, DEV, block.timestamp);\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapTokensForExactAVAX(1, 1, pairBinStepsZeroLength, defaultIERCArray, DEV, block.timestamp);\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapTokensForExactAVAX(1, 1, mismatchedpairBinSteps, mismatchedIERCArray, DEV, block.timestamp);\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapAVAXForExactTokens(1, pairBinStepsZeroLength, defaultIERCArray, DEV, block.timestamp);\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapAVAXForExactTokens(1, mismatchedpairBinSteps, mismatchedIERCArray, DEV, block.timestamp);\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            1,\n            1,\n            pairBinStepsZeroLength,\n            defaultIERCArray,\n            DEV,\n            block.timestamp\n        );\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            1,\n            1,\n            mismatchedpairBinSteps,\n            mismatchedIERCArray,\n            DEV,\n            block.timestamp\n        );\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            1,\n            1,\n            pairBinStepsZeroLength,\n            defaultIERCArray,\n            DEV,\n            block.timestamp\n        );\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            1,\n            1,\n            mismatchedpairBinSteps,\n            mismatchedIERCArray,\n            DEV,\n            block.timestamp\n        );\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n            1,\n            pairBinStepsZeroLength,\n            defaultIERCArray,\n            DEV,\n            block.timestamp\n        );\n\n        vm.expectRevert(LBRouter__LengthsMismatch.selector);\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n            1,\n            mismatchedpairBinSteps,\n            mismatchedIERCArray,\n            DEV,\n            block.timestamp\n        );\n    }\n\n    function testEnsureModifierLiquidity() public {\n        uint256 wrongDeadline = block.timestamp - 1;\n        uint256 _amountYIn = 1e18;\n        uint24 _numberBins = 11;\n        uint24 _gap = 2;\n        uint16 _binStep = DEFAULT_BIN_STEP;\n        int256[] memory _deltaIds;\n        uint256[] memory _distributionX;\n        uint256[] memory _distributionY;\n        uint256 amountXIn;\n        factory.setFactoryLockedState(false);\n        router.createLBPair(token6D, token18D, ID_ONE, DEFAULT_BIN_STEP);\n        router.createLBPair(token6D, wavax, ID_ONE, DEFAULT_BIN_STEP);\n\n        (_deltaIds, _distributionX, _distributionY, amountXIn) = spreadLiquidityForRouter(\n            _amountYIn,\n            ID_ONE,\n            _numberBins,\n            _gap\n        );\n\n        token6D.mint(DEV, amountXIn);\n        token6D.approve(address(router), amountXIn);\n        token18D.mint(DEV, _amountYIn);\n        token18D.approve(address(router), _amountYIn);\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = ILBRouter.LiquidityParameters(\n            token6D,\n            token18D,\n            _binStep,\n            amountXIn,\n            _amountYIn,\n            0,\n            0,\n            ID_ONE,\n            ID_ONE,\n            _deltaIds,\n            _distributionX,\n            _distributionY,\n            DEV,\n            wrongDeadline\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__DeadlineExceeded.selector, wrongDeadline, block.timestamp));\n        router.addLiquidity(_liquidityParameters);\n    }\n\n    function testGetPriceFromId() public {\n        pair = createLBPairDefaultFees(token6D, token18D);\n        uint256 price;\n\n        price = router.getPriceFromId(pair, ID_ONE);\n        assertEq(price, 340282366920938463463374607431768211456);\n\n        price = router.getPriceFromId(pair, ID_ONE - 10000);\n        assertEq(price, 4875582648561453899431769403);\n\n        price = router.getPriceFromId(pair, ID_ONE + 10000);\n        assertEq(price, 23749384962529715407923990466761537977856189636583);\n    }\n\n    function testGetIdFromPrice() public {\n        pair = createLBPairDefaultFees(token6D, token18D);\n        uint24 id;\n\n        id = router.getIdFromPrice(pair, 340282366920938463463374607431768211456);\n        assertEq(id, ID_ONE);\n\n        id = router.getIdFromPrice(pair, 4875582648561453899431769403);\n        assertEq(id, ID_ONE - 10000);\n\n        id = router.getIdFromPrice(pair, 23749384962529715407923990466761537977856189636583);\n        assertEq(id, ID_ONE + 10000);\n    }\n\n    function testGetSwapInWrongAmountsReverts() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n        uint256 amountXIn;\n        int256[] memory _deltaIds;\n        pair = createLBPairDefaultFees(token6D, token18D);\n        (_deltaIds, , , amountXIn) = addLiquidityFromRouter(\n            token6D,\n            token18D,\n            _amountYIn,\n            _startId,\n            _numberBins,\n            _gap,\n            DEFAULT_BIN_STEP\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__WrongAmounts.selector, 0, _amountYIn));\n        router.getSwapIn(pair, 0, true);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__WrongAmounts.selector, _amountYIn + 1, _amountYIn));\n        router.getSwapIn(pair, _amountYIn + 1, true);\n\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        uint256 totalXbalance;\n        uint256 totalYBalance;\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            uint256 LBTokenAmount = pair.balanceOf(DEV, ids[i]);\n            amounts[i] = LBTokenAmount;\n            (uint256 reserveX, uint256 reserveY) = pair.getBin(uint24(ids[i]));\n            bool hasXBalanceInBin = (LBTokenAmount != 0) && (reserveX != 0);\n            bool hasYBalanceInBin = (LBTokenAmount != 0) && (reserveY != 0);\n            totalXbalance += hasXBalanceInBin ? (LBTokenAmount * reserveX - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n            totalYBalance += hasYBalanceInBin ? (LBTokenAmount * reserveY - 1) / pair.totalSupply(ids[i]) + 1 : 0;\n        }\n        assertApproxEqAbs(totalXbalance, amountXIn, 1000);\n        assertApproxEqAbs(totalYBalance, _amountYIn, 1000);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__WrongAmounts.selector, amountXIn + 1, totalXbalance));\n        router.getSwapIn(pair, amountXIn + 1, false);\n    }\n\n    function testGetSwapInOverflowReverts() public {\n        uint256 _amountYIn = type(uint112).max - 1;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 1;\n        uint24 _gap = 2;\n        uint256 amountXIn;\n        pair = createLBPairDefaultFees(token6D, token18D);\n        (, , , amountXIn) = addLiquidity(_amountYIn, _startId, _numberBins, _gap);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__SwapOverflows.selector, _startId));\n        router.getSwapIn(pair, _amountYIn, true);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__SwapOverflows.selector, _startId));\n        router.getSwapIn(pair, amountXIn, false);\n    }\n\n    function testSweep() public {\n        uint256 amountMinted = 100e6;\n        token6D.mint(address(router), amountMinted);\n        router.sweep(token6D, ALICE, amountMinted);\n        assertEq(token6D.balanceOf(ALICE), amountMinted);\n        assertEq(token6D.balanceOf(address(router)), 0);\n\n        uint256 amountAvax = 10e18;\n        vm.deal(address(router), amountAvax);\n        router.sweep(IERC20(address(0)), ALICE, amountAvax);\n        assertEq(ALICE.balance, amountAvax);\n        assertEq(address(router).balance, 0);\n    }\n\n    function testSweepMax() public {\n        uint256 amountMinted = 1000e6;\n        token6D.mint(address(router), amountMinted);\n        router.sweep(token6D, ALICE, type(uint256).max);\n        assertEq(token6D.balanceOf(ALICE), amountMinted);\n        assertEq(token6D.balanceOf(address(router)), 0);\n\n        uint256 amountAvax = 100e18;\n        vm.deal(address(router), amountAvax);\n        router.sweep(IERC20(address(0)), ALICE, type(uint256).max);\n        assertEq(ALICE.balance, amountAvax);\n        assertEq(address(router).balance, 0);\n    }\n\n    function testGetSwapInMoreBins() public {\n        uint256 _amountYIn = 100e18;\n        uint24 _startId = ID_ONE;\n        uint24 _numberBins = 9;\n        uint24 _gap = 2;\n        uint256 amountXIn;\n        pair = createLBPairDefaultFees(token6D, token18D);\n        (, , , amountXIn) = addLiquidity(_amountYIn, _startId, _numberBins, _gap);\n        //getSwapIn goes through all bins with liquidity\n        (uint256 amountIn, ) = router.getSwapIn(pair, amountXIn - 100, false);\n        (uint256 amountIn2, ) = router.getSwapIn(pair, _amountYIn - 100, true);\n    }\n\n    function testSweepLBToken() public {\n        uint256 amountIn = 1e18;\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);\n\n        uint256[] memory amounts = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n        assertEq(pair.userPositionNumber(DEV), 5);\n\n        assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);\n\n        pair.safeBatchTransferFrom(DEV, address(router), _ids, amounts);\n\n        for (uint256 i; i < 5; i++) {\n            assertEq(pair.balanceOf(address(router), _ids[i]), amounts[i]);\n            assertEq(pair.balanceOf(DEV, _ids[i]), 0);\n        }\n        vm.prank(ALICE);\n        vm.expectRevert(LBRouter__NotFactoryOwner.selector);\n        router.sweepLBToken(pair, DEV, _ids, amounts);\n\n        router.sweepLBToken(pair, DEV, _ids, amounts);\n\n        for (uint256 i; i < 5; i++) {\n            assertEq(pair.balanceOf(DEV, _ids[i]), amounts[i]);\n            assertEq(pair.balanceOf(address(router), _ids[i]), 0);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinRouterTest is TestHelper {\n    event AVAXreceived();\n\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n        wavax = new WAVAX();\n        uint16 binStep = 100;\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        factory.setPreset(\n            binStep,\n            uint16(Constants.BASIS_POINT_MAX),\n            DEFAULT_FILTER_PERIOD,\n            DEFAULT_DECAY_PERIOD,\n            DEFAULT_REDUCTION_FACTOR,\n            DEFAULT_VARIABLE_FEE_CONTROL,\n            DEFAULT_PROTOCOL_SHARE,\n            DEFAULT_MAX_VOLATILITY_ACCUMULATED / 6,\n            DEFAULT_SAMPLE_LIFETIME\n        );\n\n        router = new LBRouter(factory, IJoeFactory(JOE_V1_FACTORY_ADDRESS), IWAVAX(address(wavax)));\n\n        pair = LBPair(address(factory.createLBPair(token6D, token18D, ID_ONE, 100)));\n    }\n\n    function testFeeOnActiveBin() public {\n        //setup pool with only Y liquidity\n        uint16 binStep = 100;\n        uint256 _amountYIn = 100e18;\n        uint24 _numberBins = 1;\n        int256[] memory _deltaIds;\n        uint256[] memory _distributionX;\n        uint256[] memory _distributionY;\n        _deltaIds = new int256[](_numberBins);\n        _distributionX = new uint256[](_numberBins);\n        _distributionY = new uint256[](_numberBins);\n        _deltaIds[0] = 0;\n        _distributionX[0] = 0;\n        _distributionY[0] = Constants.PRECISION;\n\n        vm.prank(BOB);\n        token18D.approve(address(router), _amountYIn);\n\n        token18D.mint(BOB, _amountYIn);\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = ILBRouter.LiquidityParameters(\n            token6D,\n            token18D,\n            binStep,\n            0,\n            _amountYIn,\n            0,\n            _amountYIn,\n            ID_ONE,\n            ID_ONE,\n            _deltaIds,\n            _distributionX,\n            _distributionY,\n            BOB,\n            block.timestamp\n        );\n        vm.prank(BOB);\n        router.addLiquidity(_liquidityParameters);\n\n        //setup liquidity add with only tokenX\n        uint256 amountXIn = 100e18;\n        _distributionX[0] = Constants.PRECISION;\n        _distributionY[0] = 0;\n\n        token6D.mint(ALICE, amountXIn);\n        vm.prank(ALICE);\n        token6D.approve(address(router), amountXIn);\n\n        uint256 feesXTotal;\n        (feesXTotal, , , ) = pair.getGlobalFees();\n        assertEq(feesXTotal, 0);\n\n        _liquidityParameters = ILBRouter.LiquidityParameters(\n            token6D,\n            token18D,\n            binStep,\n            amountXIn,\n            0,\n            0,\n            0,\n            ID_ONE,\n            ID_ONE,\n            _deltaIds,\n            _distributionX,\n            _distributionY,\n            ALICE,\n            block.timestamp\n        );\n\n        vm.prank(ALICE);\n        router.addLiquidity(_liquidityParameters);\n\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            amounts[i] = pair.balanceOf(ALICE, ids[i]);\n        }\n\n        vm.prank(ALICE);\n        pair.setApprovalForAll(address(router), true);\n        vm.prank(ALICE);\n        router.removeLiquidity(token6D, token18D, binStep, 0, 0, ids, amounts, ALICE, block.timestamp);\n\n        (feesXTotal, , , ) = pair.getGlobalFees();\n        assertGt(feesXTotal, amountXIn / 199);\n\n        //remove BOB's liquidity to ALICE account\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            amounts[i] = pair.balanceOf(BOB, ids[i]);\n        }\n        vm.prank(BOB);\n        pair.setApprovalForAll(address(router), true);\n        vm.prank(BOB);\n        router.removeLiquidity(token6D, token18D, binStep, 0, 0, ids, amounts, ALICE, block.timestamp);\n\n        uint256 ALICE6DbalanceAfterSecondRemove = token6D.balanceOf(ALICE);\n\n        assertEq(ALICE6DbalanceAfterSecondRemove + feesXTotal, amountXIn);\n    }\n\n    function testFeeOnActiveBinReverse() public {\n        //setup pool with only X liquidity\n        uint16 binStep = 100;\n        uint256 _amountXIn = 100e18;\n        uint24 _numberBins = 1;\n        int256[] memory _deltaIds;\n        uint256[] memory _distributionX;\n        uint256[] memory _distributionY;\n        _deltaIds = new int256[](_numberBins);\n        _distributionX = new uint256[](_numberBins);\n        _distributionY = new uint256[](_numberBins);\n        _deltaIds[0] = 0;\n        _distributionX[0] = Constants.PRECISION;\n        _distributionY[0] = 0;\n\n        vm.prank(BOB);\n        token6D.approve(address(router), _amountXIn);\n\n        token6D.mint(BOB, _amountXIn);\n\n        ILBRouter.LiquidityParameters memory _liquidityParameters = ILBRouter.LiquidityParameters(\n            token6D,\n            token18D,\n            binStep,\n            _amountXIn,\n            0,\n            _amountXIn,\n            0,\n            ID_ONE,\n            ID_ONE,\n            _deltaIds,\n            _distributionX,\n            _distributionY,\n            BOB,\n            block.timestamp\n        );\n        vm.prank(BOB);\n        router.addLiquidity(_liquidityParameters);\n\n        //setup liquidity add with only tokenX\n        uint256 amountYIn = 100e18;\n        _distributionX[0] = 0;\n        _distributionY[0] = Constants.PRECISION;\n\n        token18D.mint(ALICE, amountYIn);\n        vm.prank(ALICE);\n        token18D.approve(address(router), amountYIn);\n\n        uint256 feesYTotal;\n        (, feesYTotal, , ) = pair.getGlobalFees();\n        assertEq(feesYTotal, 0);\n\n        _liquidityParameters = ILBRouter.LiquidityParameters(\n            token6D,\n            token18D,\n            binStep,\n            0,\n            amountYIn,\n            0,\n            0,\n            ID_ONE,\n            ID_ONE,\n            _deltaIds,\n            _distributionX,\n            _distributionY,\n            ALICE,\n            block.timestamp\n        );\n\n        vm.prank(ALICE);\n        router.addLiquidity(_liquidityParameters);\n\n        uint256[] memory amounts = new uint256[](_numberBins);\n        uint256[] memory ids = new uint256[](_numberBins);\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            amounts[i] = pair.balanceOf(ALICE, ids[i]);\n        }\n\n        vm.prank(ALICE);\n        pair.setApprovalForAll(address(router), true);\n        vm.prank(ALICE);\n        router.removeLiquidity(token6D, token18D, binStep, 0, 0, ids, amounts, ALICE, block.timestamp);\n\n        //remove BOB's liquidity to ALICE account\n        for (uint256 i; i < _numberBins; i++) {\n            ids[i] = uint256(int256(uint256(ID_ONE)) + _deltaIds[i]);\n            amounts[i] = pair.balanceOf(BOB, ids[i]);\n        }\n        vm.prank(BOB);\n        pair.setApprovalForAll(address(router), true);\n        vm.prank(BOB);\n        router.removeLiquidity(token6D, token18D, binStep, 0, 0, ids, amounts, ALICE, block.timestamp);\n\n        uint256 ALICE6DbalanceAfterSecondRemove = token18D.balanceOf(ALICE);\n\n        (, feesYTotal, , ) = pair.getGlobalFees();\n        assertGt(feesYTotal, amountYIn / 199);\n        assertEq(ALICE6DbalanceAfterSecondRemove + feesYTotal, amountYIn);\n    }\n}\n\n\n",
        "CodeNames": [
            "LBRouter.Liquidity.t.sol",
            "LBRouter.Swaps.t.sol",
            "LBRouter.sol",
            "LBRouter.t.sol",
            "LBRouter.FeesOnLiquidityAdd.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LBRouter.removeLiquidity",
                "Type": "Incorrect function behavior",
                "Description": "LBRouter.removeLiquidity reorders tokens when the user did not pass them in the pair order (ascending order), causing the return value amountX to be the amount of the user-provided token Y that is returned and vice versa.",
                "Repair": "Add a statement to return the correct values when the tokens are swapped"
            },
            {
                "Location": "LBRouter.sol",
                "Type": "Incorrect output amount calculation",
                "Description": "Output amount is calculated incorrectly for a Trader Joe V1 pool when swapping tokens across multiple pools and some of the pools in the chain are V1 ones. Calculated amounts will always be smaller than expected ones, which will always affect chained swaps that include V1 pools.",
                "Repair": "Use the JoeLibrary.getAmountOut function in the _swapSupportingFeeOnTransferTokens function of LBRouter when computing output amounts for V1 pools."
            },
            {
                "Location": "LBRouter._getAmountsIn function",
                "Type": "Incorrect math calculation",
                "Description": "The vulnerability is caused by an incorrect order of operations in the calculation formula in the _getAmountsIn function, which results in users losing more tokens than expected when swapping through JoePair.",
                "Repair": "Modify the calculation formula in the _getAmountsIn function to fix the order of operations"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/utils/structs/EnumerableSet.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./interfaces/ILBToken.sol\";\n\n/// @title Liquidity Book Token\n/// @author Trader Joe\n/// @notice The LBToken is an implementation of a multi-token.\n/// It allows to create multi-ERC20 represented by their ids\ncontract LBToken is ILBToken {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @dev Mapping from token id to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    /// @dev Mapping from account to spender approvals\n    mapping(address => mapping(address => bool)) private _spenderApprovals;\n\n    /// @dev Mapping from token id to total supplies\n    mapping(uint256 => uint256) private _totalSupplies;\n\n    /// @dev  Mapping from account to set of ids, where user currently have a non-zero balance\n    mapping(address => EnumerableSet.UintSet) private _userIds;\n\n    string private constant _name = \"Liquidity Book Token\";\n    string private constant _symbol = \"LBT\";\n\n    modifier checkApproval(address _from, address _spender) {\n        if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender);\n        _;\n    }\n\n    modifier checkAddresses(address _from, address _to) {\n        if (_from == address(0) || _to == address(0)) revert LBToken__TransferFromOrToAddress0();\n        _;\n    }\n\n    modifier checkLength(uint256 _lengthA, uint256 _lengthB) {\n        if (_lengthA != _lengthB) revert LBToken__LengthMismatch(_lengthA, _lengthB);\n        _;\n    }\n\n    /// @notice Returns the name of the token\n    /// @return The name of the token\n    function name() public pure virtual override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Returns the symbol of the token, usually a shorter version of the name\n    /// @return The symbol of the token\n    function symbol() public pure virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice Returns the total supply of token of type `id`\n    /// @dev This is the amount of token of type `id` minted minus the amount burned\n    /// @param _id The token id\n    /// @return The total supply of that token id\n    function totalSupply(uint256 _id) public view virtual override returns (uint256) {\n        return _totalSupplies[_id];\n    }\n\n    /// @notice Returns the amount of tokens of type `id` owned by `_account`\n    /// @param _account The address of the owner\n    /// @param _id The token id\n    /// @return The amount of tokens of type `id` owned by `_account`\n    function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {\n        return _balances[_id][_account];\n    }\n\n    /// @notice Return the balance of multiple (account/id) pairs\n    /// @param _accounts The addresses of the owners\n    /// @param _ids The token ids\n    /// @return batchBalances The balance for each (account, id) pair\n    function balanceOfBatch(address[] memory _accounts, uint256[] memory _ids)\n        public\n        view\n        virtual\n        override\n        checkLength(_accounts.length, _ids.length)\n        returns (uint256[] memory batchBalances)\n    {\n        batchBalances = new uint256[](_accounts.length);\n\n        unchecked {\n            for (uint256 i; i < _accounts.length; ++i) {\n                batchBalances[i] = balanceOf(_accounts[i], _ids[i]);\n            }\n        }\n    }\n\n    /// @notice Returns the type id at index `_index` where `account` has a non-zero balance\n    /// @param _account The address of the account\n    /// @param _index The position index\n    /// @return The `account` non-zero position at index `_index`\n    function userPositionAtIndex(address _account, uint256 _index) public view virtual override returns (uint256) {\n        return _userIds[_account].at(_index);\n    }\n\n    /// @notice Returns the number of non-zero balances of `account`\n    /// @param _account The address of the account\n    /// @return The number of non-zero balances of `account`\n    function userPositionNumber(address _account) public view virtual override returns (uint256) {\n        return _userIds[_account].length();\n    }\n\n    /// @notice Returns true if `spender` is approved to transfer `_account`'s tokens\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @return True if `spender` is approved to transfer `_account`'s tokens\n    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {\n        return _isApprovedForAll(_owner, _spender);\n    }\n\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n    /// @param _spender The address of the spender\n    /// @param _approved The boolean value to grant or revoke permission\n    function setApprovalForAll(address _spender, bool _approved) public virtual override {\n        _setApprovalForAll(msg.sender, _spender, _approved);\n    }\n\n    /// @notice Transfers `_amount` token of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to send\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) {\n        address _spender = msg.sender;\n\n        _transfer(_from, _to, _id, _amount);\n\n        emit TransferSingle(_spender, _from, _to, _id, _amount);\n    }\n\n    /// @notice Batch transfers `_amount` tokens of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the tokens\n    /// @param _to The address of the recipient\n    /// @param _ids The list of token ids\n    /// @param _amounts The list of amounts to send\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    )\n        public\n        virtual\n        override\n        checkLength(_ids.length, _amounts.length)\n        checkAddresses(_from, _to)\n        checkApproval(_from, msg.sender)\n    {\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                _transfer(_from, _to, _ids[i], _amounts[i]);\n            }\n        }\n\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n    }\n\n    /// @notice Internal function to transfer `_amount` tokens of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to send\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        uint256 _fromBalance = _balances[_id][_from];\n        if (_fromBalance < _amount) revert LBToken__TransferExceedsBalance(_from, _id, _amount);\n\n        _beforeTokenTransfer(_from, _to, _id, _amount);\n\n        uint256 _toBalance = _balances[_id][_to];\n\n        unchecked {\n            _balances[_id][_from] = _fromBalance - _amount;\n            _balances[_id][_to] = _toBalance + _amount;\n        }\n\n        _remove(_from, _id, _fromBalance, _amount);\n        _add(_to, _id, _toBalance, _amount);\n    }\n\n    /// @dev Creates `_amount` tokens of type `_id`, and assigns them to `_account`\n    /// @param _account The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to mint\n    function _mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        if (_account == address(0)) revert LBToken__MintToAddress0();\n\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\n\n        _totalSupplies[_id] += _amount;\n\n        uint256 _accountBalance = _balances[_id][_account];\n        unchecked {\n            _balances[_id][_account] = _accountBalance + _amount;\n        }\n\n        _add(_account, _id, _accountBalance, _amount);\n\n        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);\n    }\n\n    /// @dev Destroys `_amount` tokens of type `_id` from `_account`\n    /// @param _account The address of the owner\n    /// @param _id The token id\n    /// @param _amount The amount to destroy\n    function _burn(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        if (_account == address(0)) revert LBToken__BurnFromAddress0();\n\n        uint256 _accountBalance = _balances[_id][_account];\n        if (_accountBalance < _amount) revert LBToken__BurnExceedsBalance(_account, _id, _amount);\n\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\n\n        unchecked {\n            _balances[_id][_account] = _accountBalance - _amount;\n            _totalSupplies[_id] -= _amount;\n        }\n\n        _remove(_account, _id, _accountBalance, _amount);\n\n        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);\n    }\n\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @param _approved The boolean value to grant or revoke permission\n    function _setApprovalForAll(\n        address _owner,\n        address _spender,\n        bool _approved\n    ) internal virtual {\n        if (_owner == _spender) revert LBToken__SelfApproval(_owner);\n\n        _spenderApprovals[_owner][_spender] = _approved;\n        emit ApprovalForAll(_owner, _spender, _approved);\n    }\n\n    /// @notice Returns true if `spender` is approved to transfer `owner`'s tokens\n    /// or if `sender` is the `owner`\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @return True if `spender` is approved to transfer `owner`'s tokens\n    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {\n        return _owner == _spender || _spenderApprovals[_owner][_spender];\n    }\n\n    /// @notice Internal function to add an id to an user's set\n    /// @param _account The user's address\n    /// @param _id The id of the token\n    /// @param _accountBalance The user's balance\n    /// @param _amount The amount of tokens\n    function _add(\n        address _account,\n        uint256 _id,\n        uint256 _accountBalance,\n        uint256 _amount\n    ) internal {\n        if (_accountBalance == 0 && _amount != 0) {\n            _userIds[_account].add(_id);\n        }\n    }\n\n    /// @notice Internal function to remove an id from an user's set\n    /// @param _account The user's address\n    /// @param _id The id of the token\n    /// @param _accountBalance The user's balance\n    /// @param _amount The amount of tokens\n    function _remove(\n        address _account,\n        uint256 _id,\n        uint256 _accountBalance,\n        uint256 _amount\n    ) internal {\n        if (_accountBalance == _amount && _amount != 0) {\n            _userIds[_account].remove(_id);\n        }\n    }\n\n    /// @notice Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    ///\n    /// Calling conditions (for each `id` and `amount` pair):\n    ///\n    /// - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n    /// of token type `id` will be  transferred to `to`.\n    /// - When `from` is zero, `amount` tokens of token type `id` will be minted\n    /// for `to`.\n    /// - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n    /// will be burned.\n    /// - `from` and `to` are never both zero.\n    /// @param from The address of the owner of the token\n    /// @param to The address of the recipient of the  token\n    /// @param id The id of the token\n    /// @param amount The amount of token of type `id`\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinTokenTest is TestHelper {\n    event TransferBatch(\n        address indexed sender,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event TransferSingle(address indexed sender, address indexed from, address indexed to, uint256 id, uint256 amount);\n\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n    }\n\n    function testSafeBatchTransferFrom() public {\n        uint256 amountIn = 1e18;\n\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);\n\n        uint256[] memory amounts = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n        assertEq(pair.userPositionNumber(DEV), 5);\n\n        assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);\n        vm.expectEmit(true, true, true, true);\n        emit TransferBatch(DEV, DEV, ALICE, _ids, amounts);\n        pair.safeBatchTransferFrom(DEV, ALICE, _ids, amounts);\n        assertEq(pair.balanceOf(DEV, ID_ONE - 1), 0);\n        assertEq(pair.balanceOf(ALICE, ID_ONE - 1), amountIn / 3);\n\n        vm.prank(ALICE);\n        pair.setApprovalForAll(BOB, true);\n        assertTrue(pair.isApprovedForAll(ALICE, BOB));\n        assertFalse(pair.isApprovedForAll(BOB, ALICE));\n\n        vm.prank(BOB);\n        vm.expectEmit(true, true, true, true);\n        emit TransferBatch(BOB, ALICE, BOB, _ids, amounts);\n        pair.safeBatchTransferFrom(ALICE, BOB, _ids, amounts);\n        assertEq(pair.balanceOf(DEV, ID_ONE - 1), 0); // DEV\n        assertEq(pair.balanceOf(ALICE, ID_ONE - 1), 0);\n        assertEq(pair.balanceOf(BOB, ID_ONE - 1), amountIn / 3);\n    }\n\n    function testSafeTransferFrom() public {\n        uint256 amountIn = 1e18;\n\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);\n\n        uint256[] memory amounts = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n        assertEq(pair.userPositionNumber(DEV), 5);\n\n        assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);\n        vm.expectEmit(true, true, true, true);\n        emit TransferSingle(DEV, DEV, ALICE, _ids[0], amounts[0]);\n        pair.safeTransferFrom(DEV, ALICE, _ids[0], amounts[0]);\n        assertEq(pair.balanceOf(DEV, _ids[0]), 0);\n        assertEq(pair.balanceOf(ALICE, _ids[0]), amountIn / 3);\n\n        vm.prank(ALICE);\n        pair.setApprovalForAll(BOB, true);\n        assertTrue(pair.isApprovedForAll(ALICE, BOB));\n        assertFalse(pair.isApprovedForAll(BOB, ALICE));\n\n        vm.prank(BOB);\n        vm.expectEmit(true, true, true, true);\n        emit TransferSingle(BOB, ALICE, BOB, _ids[0], amounts[0]);\n        pair.safeTransferFrom(ALICE, BOB, _ids[0], amounts[0]);\n        assertEq(pair.balanceOf(DEV, _ids[0]), 0);\n        assertEq(pair.balanceOf(ALICE, _ids[0]), 0);\n        assertEq(pair.balanceOf(BOB, _ids[0]), amountIn / 3);\n    }\n\n    function testSafeBatchTransferNotApprovedReverts() public {\n        uint256 amountIn = 1e18;\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);\n\n        uint256[] memory amounts = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n\n        vm.prank(BOB);\n        vm.expectRevert(abi.encodeWithSelector(LBToken__SpenderNotApproved.selector, DEV, BOB));\n        pair.safeBatchTransferFrom(DEV, BOB, _ids, amounts);\n    }\n\n    function testSafeTransferNotApprovedReverts() public {\n        uint256 amountIn = 1e18;\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);\n\n        uint256[] memory amounts = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n\n        vm.prank(BOB);\n        vm.expectRevert(abi.encodeWithSelector(LBToken__SpenderNotApproved.selector, DEV, BOB));\n        pair.safeTransferFrom(DEV, BOB, _ids[0], amounts[0]);\n    }\n\n    function testSafeBatchTransferFromReverts() public {\n        uint24 binAmount = 11;\n        uint256 amountIn = 1e18;\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, binAmount, 0);\n\n        uint256[] memory amounts = new uint256[](binAmount);\n        for (uint256 i; i < binAmount; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n\n        vm.prank(BOB);\n        vm.expectRevert(abi.encodeWithSelector(LBToken__SpenderNotApproved.selector, DEV, BOB));\n        pair.safeBatchTransferFrom(DEV, BOB, _ids, amounts);\n\n        vm.prank(address(0));\n        vm.expectRevert(LBToken__TransferFromOrToAddress0.selector);\n        pair.safeBatchTransferFrom(address(0), BOB, _ids, amounts);\n\n        vm.prank(DEV);\n        vm.expectRevert(LBToken__TransferFromOrToAddress0.selector);\n        pair.safeBatchTransferFrom(DEV, address(0), _ids, amounts);\n\n        amounts[0] += 1;\n        vm.expectRevert(abi.encodeWithSelector(LBToken__TransferExceedsBalance.selector, DEV, _ids[0], amounts[0]));\n        pair.safeBatchTransferFrom(DEV, ALICE, _ids, amounts);\n\n        amounts[0] -= 1; //revert back to proper amount\n        _ids[1] = ID_ONE + binAmount;\n        vm.expectRevert(abi.encodeWithSelector(LBToken__TransferExceedsBalance.selector, DEV, _ids[1], amounts[1]));\n        pair.safeBatchTransferFrom(DEV, ALICE, _ids, amounts);\n    }\n\n    function testSafeTransferFromReverts() public {\n        uint24 binAmount = 11;\n        uint256 amountIn = 1e18;\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, binAmount, 0);\n\n        uint256[] memory amounts = new uint256[](binAmount);\n        for (uint256 i; i < binAmount; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n\n        vm.prank(BOB);\n        vm.expectRevert(abi.encodeWithSelector(LBToken__SpenderNotApproved.selector, DEV, BOB));\n        pair.safeTransferFrom(DEV, BOB, _ids[0], amounts[0]);\n\n        vm.prank(address(0));\n        vm.expectRevert(LBToken__TransferFromOrToAddress0.selector);\n        pair.safeTransferFrom(address(0), BOB, _ids[0], amounts[0]);\n\n        vm.prank(DEV);\n        vm.expectRevert(LBToken__TransferFromOrToAddress0.selector);\n        pair.safeTransferFrom(DEV, address(0), _ids[0], amounts[0]);\n\n        amounts[0] += 1;\n        vm.expectRevert(abi.encodeWithSelector(LBToken__TransferExceedsBalance.selector, DEV, _ids[0], amounts[0]));\n        pair.safeTransferFrom(DEV, ALICE, _ids[0], amounts[0]);\n\n        _ids[1] = ID_ONE + binAmount;\n        vm.expectRevert(abi.encodeWithSelector(LBToken__TransferExceedsBalance.selector, DEV, _ids[1], amounts[1]));\n        pair.safeTransferFrom(DEV, ALICE, _ids[1], amounts[1]);\n    }\n\n    function testModifierCheckLength() public {\n        uint24 binAmount = 11;\n        uint256 amountIn = 1e18;\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, binAmount, 0);\n\n        uint256[] memory amounts = new uint256[](binAmount - 1);\n        for (uint256 i; i < binAmount - 1; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n\n        vm.expectRevert(abi.encodeWithSelector(LBToken__LengthMismatch.selector, _ids.length, amounts.length));\n        pair.safeBatchTransferFrom(DEV, ALICE, _ids, amounts);\n\n        address[] memory accounts = new address[](binAmount - 1);\n        for (uint256 i; i < binAmount - 1; i++) {\n            accounts[i] = DEV;\n        }\n        vm.expectRevert(abi.encodeWithSelector(LBToken__LengthMismatch.selector, accounts.length, _ids.length));\n        pair.balanceOfBatch(accounts, _ids);\n    }\n\n    function testSelfApprovalReverts() public {\n        vm.expectRevert(abi.encodeWithSelector(LBToken__SelfApproval.selector, DEV));\n        pair.setApprovalForAll(DEV, true);\n    }\n\n    function testPrivateViewFunctions() public {\n        assertEq(pair.name(), \"Liquidity Book Token\");\n        assertEq(pair.symbol(), \"LBT\");\n    }\n\n    function testBalanceOfBatch() public {\n        uint24 binAmount = 5;\n        uint256 amountIn = 1e18;\n        uint24 _startId = ID_ONE;\n        uint24 _gap = 0;\n        uint256[] memory batchBalances = new uint256[](binAmount);\n\n        uint256[] memory _ids = new uint256[](binAmount);\n        for (uint256 i; i < binAmount / 2; i++) {\n            _ids[i] = _startId - (binAmount / 2) * (1 + _gap) + i * (1 + _gap);\n        }\n\n        address[] memory accounts = new address[](binAmount);\n        for (uint256 i; i < binAmount; i++) {\n            accounts[i] = DEV;\n        }\n        batchBalances = pair.balanceOfBatch(accounts, _ids);\n        for (uint256 i; i < binAmount; i++) {\n            assertEq(batchBalances[i], 0);\n        }\n\n        (_ids, , , ) = addLiquidity(amountIn, _startId, binAmount, _gap);\n        uint256[] memory amounts = new uint256[](binAmount);\n        for (uint256 i; i < binAmount; i++) {\n            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n        batchBalances = pair.balanceOfBatch(accounts, _ids);\n        for (uint256 i; i < binAmount; i++) {\n            assertEq(batchBalances[i], amounts[i]);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "LBToken.sol",
            "LBToken.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LBToken._burn",
                "Type": "Typo/Programming mistake",
                "Description": "In LBToken._burn, the _beforeTokenTransfer hook is called with from = address(0) and to = _account, which is dangerous for future extensions or protocols that built on top of the protocol/fork.",
                "Repair": "Call the hook with the correct parameters"
            },
            {
                "Location": "LBToken.sol",
                "Type": "Balance Duplication",
                "Description": "Transferring funds to yourself increases your balance due to the improper usage of a supporting temporary variable, balance duplication can be achieved.",
                "Repair": "Add checks to make sure that _from != _to and use _balances[_id][_from] -= _amount instead of _balances[_id][_from] = _fromBalance _amount"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/** Imports **/\n\nimport \"./LBErrors.sol\";\nimport \"./LBToken.sol\";\nimport \"./libraries/BinHelper.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/Decoder.sol\";\nimport \"./libraries/FeeDistributionHelper.sol\";\nimport \"./libraries/Math512Bits.sol\";\nimport \"./libraries/Oracle.sol\";\nimport \"./libraries/ReentrancyGuardUpgradeable.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SwapHelper.sol\";\nimport \"./libraries/TokenHelper.sol\";\nimport \"./libraries/TreeMath.sol\";\nimport \"./interfaces/ILBFlashLoanCallback.sol\";\nimport \"./interfaces/ILBPair.sol\";\n\n/// @title Liquidity Book Pair\n/// @author Trader Joe\n/// @notice The implementation of Liquidity Book Pair that also acts as the receipt token for liquidity positions\ncontract LBPair is LBToken, ReentrancyGuardUpgradeable, ILBPair {\n    /** Libraries **/\n\n    using Math512Bits for uint256;\n    using TreeMath for mapping(uint256 => uint256)[3];\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using TokenHelper for IERC20;\n    using FeeHelper for FeeHelper.FeeParameters;\n    using SwapHelper for Bin;\n    using Decoder for bytes32;\n    using FeeDistributionHelper for FeeHelper.FeesDistribution;\n    using Oracle for bytes32[65_535];\n\n    /** Modifiers **/\n\n    modifier onlyFactory() {\n        if (msg.sender != address(factory)) revert LBPair__OnlyFactory();\n        _;\n    }\n\n    /** Public immutable variables **/\n\n    ILBFactory public immutable override factory;\n\n    /** Public variables **/\n\n    IERC20 public override tokenX;\n    IERC20 public override tokenY;\n\n    /** Private variables **/\n\n    PairInformation private _pairInformation;\n    FeeHelper.FeeParameters private _feeParameters;\n    /// @dev The reserves of tokens for every bin. This is the amount\n    /// of tokenY if `id < _pairInformation.activeId`; of tokenX if `id > _pairInformation.activeId`\n    /// and a mix of both if `id == _pairInformation.activeId`\n    mapping(uint256 => Bin) private _bins;\n    /// @dev Tree to find bins with non zero liquidity\n    mapping(uint256 => uint256)[3] private _tree;\n    /// @dev Mapping from account to user's unclaimed fees. The first 128 bits are tokenX and the last are for tokenY\n    mapping(address => bytes32) private _unclaimedFees;\n    /// @dev Mapping from account to id to user's accruedDebt.\n    mapping(address => mapping(uint256 => Debts)) private _accruedDebts;\n    /// @dev Oracle array\n    bytes32[65_535] private _oracle;\n\n    /** OffSets */\n\n    uint256 private constant _OFFSET_PAIR_RESERVE_X = 24;\n    uint256 private constant _OFFSET_PROTOCOL_FEE = 128;\n    uint256 private constant _OFFSET_BIN_RESERVE_Y = 112;\n    uint256 private constant _OFFSET_VARIABLE_FEE_PARAMETERS = 144;\n    uint256 private constant _OFFSET_ORACLE_SAMPLE_LIFETIME = 136;\n    uint256 private constant _OFFSET_ORACLE_SIZE = 152;\n    uint256 private constant _OFFSET_ORACLE_ACTIVE_SIZE = 168;\n    uint256 private constant _OFFSET_ORACLE_LAST_TIMESTAMP = 184;\n    uint256 private constant _OFFSET_ORACLE_ID = 224;\n\n    /** Constructor **/\n\n    /// @notice Set the factory address\n    /// @param _factory The address of the factory\n    constructor(ILBFactory _factory) LBToken() {\n        if (address(_factory) == address(0)) revert LBPair__AddressZero();\n        factory = _factory;\n    }\n\n    /// @notice Initialize the parameters of the LBPair\n    /// @dev The different parameters needs to be validated very cautiously.\n    /// It is highly recommended to never call this function directly, use the factory\n    /// as it validates the different parameters\n    /// @param _tokenX The address of the tokenX. Can't be address 0\n    /// @param _tokenY The address of the tokenY. Can't be address 0\n    /// @param _activeId The active id of the pair\n    /// @param _sampleLifetime The lifetime of a sample. It's the min time between 2 oracle's sample\n    /// @param _packedFeeParameters The fee parameters packed in a single 256 bits slot\n    function initialize(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _sampleLifetime,\n        bytes32 _packedFeeParameters\n    ) external override onlyFactory {\n        if (address(_tokenX) == address(0) || address(_tokenY) == address(0)) revert LBPair__AddressZero();\n        if (address(tokenX) != address(0)) revert LBPair__AlreadyInitialized();\n\n        __ReentrancyGuard_init();\n\n        tokenX = _tokenX;\n        tokenY = _tokenY;\n\n        _pairInformation.activeId = _activeId;\n        _pairInformation.oracleSampleLifetime = _sampleLifetime;\n\n        _setFeesParameters(_packedFeeParameters);\n        _increaseOracle(2);\n    }\n\n    /** External View Functions **/\n\n    /// @notice View function to get the reserves and active id\n    /// @return reserveX The reserve of asset X\n    /// @return reserveY The reserve of asset Y\n    /// @return activeId The active id of the pair\n    function getReservesAndId()\n        external\n        view\n        override\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        )\n    {\n        return _getReservesAndId();\n    }\n\n    /// @notice View function to get the global fees information, the total fees and those for protocol\n    /// @dev The fees for users are `total - protocol`\n    /// @return feesXTotal The total fees of asset X\n    /// @return feesYTotal The total fees of asset Y\n    /// @return feesXProtocol The protocol fees of asset X\n    /// @return feesYProtocol The protocol fees of asset Y\n    function getGlobalFees()\n        external\n        view\n        override\n        returns (\n            uint256 feesXTotal,\n            uint256 feesYTotal,\n            uint256 feesXProtocol,\n            uint256 feesYProtocol\n        )\n    {\n        return _getGlobalFees();\n    }\n\n    /// @notice View function to get the oracle parameters\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\n    /// @return oracleSize The size of the oracle (last ids can be empty)\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\n    /// @return oracleId The index of the oracle's latest sample\n    /// @return min The min delta time of two samples\n    /// @return max The safe max delta time of two samples\n    function getOracleParameters()\n        external\n        view\n        override\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        )\n    {\n        (oracleSampleLifetime, oracleSize, oracleActiveSize, oracleLastTimestamp, oracleId) = _getOracleParameters();\n        min = oracleActiveSize == 0 ? 0 : oracleSampleLifetime;\n        max = oracleSampleLifetime * oracleActiveSize;\n    }\n\n    /// @notice View function to get the oracle's sample at `_timeDelta` seconds\n    /// @dev Return a linearized sample, the weighted average of 2 neighboring samples\n    /// @param _timeDelta The number of seconds before the current timestamp\n    /// @return cumulativeId The weighted average cumulative id\n    /// @return cumulativeVolatilityAccumulated The weighted average cumulative volatility accumulated\n    /// @return cumulativeBinCrossed The weighted average cumulative bin crossed\n    function getOracleSampleFrom(uint256 _timeDelta)\n        external\n        view\n        override\n        returns (\n            uint256 cumulativeId,\n            uint256 cumulativeVolatilityAccumulated,\n            uint256 cumulativeBinCrossed\n        )\n    {\n        uint256 _lookUpTimestamp = block.timestamp - _timeDelta;\n\n        (, , uint256 _oracleActiveSize, , uint256 _oracleId) = _getOracleParameters();\n\n        uint256 timestamp;\n        (timestamp, cumulativeId, cumulativeVolatilityAccumulated, cumulativeBinCrossed) = _oracle.getSampleAt(\n            _oracleActiveSize,\n            _oracleId,\n            _lookUpTimestamp\n        );\n\n        if (timestamp < _lookUpTimestamp) {\n            FeeHelper.FeeParameters memory _fp = _feeParameters;\n            uint256 _activeId = _pairInformation.activeId;\n            _fp.updateVariableFeeParameters(_activeId);\n\n            unchecked {\n                uint256 _deltaT = _lookUpTimestamp - timestamp;\n\n                cumulativeId += _activeId * _deltaT;\n                cumulativeVolatilityAccumulated += uint256(_fp.volatilityAccumulated) * _deltaT;\n            }\n        }\n    }\n\n    /// @notice View function to get the fee parameters\n    /// @return The fee parameters\n    function feeParameters() external view override returns (FeeHelper.FeeParameters memory) {\n        return _feeParameters;\n    }\n\n    /// @notice View function to get the first bin that isn't empty, will not be `_id` itself\n    /// @param _id The bin id\n    /// @param _swapForY Whether you've swapping token X for token Y (true) or token Y for token X (false)\n    /// @return The id of the non empty bin\n    function findFirstNonEmptyBinId(uint24 _id, bool _swapForY) external view override returns (uint24) {\n        return _tree.findFirstBin(_id, _swapForY);\n    }\n\n    /// @notice View function to get the bin at `id`\n    /// @param _id The bin id\n    /// @return reserveX The reserve of tokenX of the bin\n    /// @return reserveY The reserve of tokenY of the bin\n    function getBin(uint24 _id) external view override returns (uint256 reserveX, uint256 reserveY) {\n        return _getBin(_id);\n    }\n\n    /// @notice View function to get the pending fees of a user\n    /// @dev The array must be strictly increasing to ensure uniqueness\n    /// @param _account The address of the user\n    /// @param _ids The list of ids\n    /// @return amountX The amount of tokenX pending\n    /// @return amountY The amount of tokenY pending\n    function pendingFees(address _account, uint256[] memory _ids)\n        external\n        view\n        override\n        returns (uint256 amountX, uint256 amountY)\n    {\n        bytes32 _unclaimedData = _unclaimedFees[_account];\n\n        amountX = _unclaimedData.decode(type(uint128).max, 0);\n        amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n        uint256 _lastId;\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                uint256 _id = _ids[i];\n\n                // Ensures uniqueness of ids\n                if (_lastId >= _id && i != 0) revert LBPair__OnlyStrictlyIncreasingId();\n\n                uint256 _balance = balanceOf(_account, _id);\n\n                if (_balance != 0) {\n                    Bin memory _bin = _bins[_id];\n\n                    (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\n\n                    amountX += _amountX;\n                    amountY += _amountY;\n                }\n\n                _lastId = _id;\n            }\n        }\n    }\n\n    /** External Functions **/\n\n    /// @notice Performs a low level swap, this needs to be called from a contract which performs important safety checks\n    /// @dev Will swap the full amount that this contract received of token X or Y\n    /// @param _swapForY whether the token sent was Y (true) or X (false)\n    /// @param _to The address of the recipient\n    /// @return amountXOut The amount of token X sent to `_to`\n    /// @return amountYOut The amount of token Y sent to `_to`\n    function swap(bool _swapForY, address _to)\n        external\n        override\n        nonReentrant\n        returns (uint256 amountXOut, uint256 amountYOut)\n    {\n        PairInformation memory _pair = _pairInformation;\n\n        uint256 _amountIn = _swapForY\n            ? tokenX.received(_pair.reserveX, _pair.feesX.total)\n            : tokenY.received(_pair.reserveY, _pair.feesY.total);\n\n        if (_amountIn == 0) revert LBPair__InsufficientAmounts();\n\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n        _fp.updateVariableFeeParameters(_pair.activeId);\n        uint256 _startId = _pair.activeId;\n\n        uint256 _amountOut;\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstBin function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            Bin memory _bin = _bins[_pair.activeId];\n            if ((!_swapForY && _bin.reserveX != 0) || (_swapForY && _bin.reserveY != 0)) {\n                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin\n                    .getAmounts(_fp, _pair.activeId, _swapForY, _amountIn);\n\n                _bin.updateFees(_swapForY ? _pair.feesX : _pair.feesY, _fees, _swapForY, totalSupply(_pair.activeId));\n\n                _bin.updateReserves(_pair, _swapForY, _amountInToBin.safe112(), _amountOutOfBin.safe112());\n\n                _amountIn -= _amountInToBin + _fees.total;\n                _amountOut += _amountOutOfBin;\n\n                _bins[_pair.activeId] = _bin;\n\n                if (_swapForY) {\n                    emit Swap(\n                        msg.sender,\n                        _to,\n                        _pair.activeId,\n                        _amountInToBin,\n                        0,\n                        0,\n                        _amountOutOfBin,\n                        _fp.volatilityAccumulated,\n                        _fees.total,\n                        0\n                    );\n                } else {\n                    emit Swap(\n                        msg.sender,\n                        _to,\n                        _pair.activeId,\n                        0,\n                        _amountInToBin,\n                        _amountOutOfBin,\n                        0,\n                        _fp.volatilityAccumulated,\n                        0,\n                        _fees.total\n                    );\n                }\n            }\n\n            if (_amountIn != 0) {\n                _pair.activeId = _tree.findFirstBin(_pair.activeId, _swapForY);\n            } else {\n                break;\n            }\n        }\n\n        if (_amountOut == 0) revert LBPair__BrokenSwapSafetyCheck(); // Safety check\n\n        // We use oracleSize so it can start filling empty slot that were added recently\n        uint256 _updatedOracleId = _oracle.update(\n            _pair.oracleSize,\n            _pair.oracleSampleLifetime,\n            _pair.oracleLastTimestamp,\n            _pair.oracleId,\n            _pair.activeId,\n            _fp.volatilityAccumulated,\n            _startId.absSub(_pair.activeId)\n        );\n\n        // We update the oracleId and lastTimestamp if the sample write on another slot\n        if (_updatedOracleId != _pair.oracleId || _pair.oracleLastTimestamp == 0) {\n            // Can't overflow as the updatedOracleId < oracleSize\n            _pair.oracleId = uint16(_updatedOracleId);\n            _pair.oracleLastTimestamp = block.timestamp.safe40();\n\n            // We increase the activeSize if the updated sample is written in a new slot\n            // Can't overflow as _updatedOracleId < maxSize = 2**16-1\n            unchecked {\n                if (_updatedOracleId == _pair.oracleActiveSize) ++_pair.oracleActiveSize;\n            }\n        }\n\n        _feeParameters = _fp;\n        _pairInformation = _pair;\n\n        if (_swapForY) {\n            amountYOut = _amountOut;\n            tokenY.safeTransfer(_to, _amountOut);\n        } else {\n            amountXOut = _amountOut;\n            tokenX.safeTransfer(_to, _amountOut);\n        }\n    }\n\n    /// @notice Performs a flash loan\n    /// @param _to the address that will execute the external call\n    /// @param _amountXOut The amount of tokenX\n    /// @param _amountYOut The amount of tokenY\n    /// @param _data The bytes data that will be forwarded to _to\n    function flashLoan(\n        address _to,\n        uint256 _amountXOut,\n        uint256 _amountYOut,\n        bytes calldata _data\n    ) external override nonReentrant {\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n\n        uint256 _fee = factory.flashLoanFee();\n\n        FeeHelper.FeesDistribution memory _feesX = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountXOut, _fee));\n        FeeHelper.FeesDistribution memory _feesY = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountYOut, _fee));\n\n        (uint256 _reserveX, uint256 _reserveY, uint256 _id) = _getReservesAndId();\n\n        tokenX.safeTransfer(_to, _amountXOut);\n        tokenY.safeTransfer(_to, _amountYOut);\n\n        ILBFlashLoanCallback(_to).LBFlashLoanCallback(\n            msg.sender,\n            _amountXOut,\n            _amountYOut,\n            _feesX.total,\n            _feesY.total,\n            _data\n        );\n\n        _feesX.flashLoanHelper(_pairInformation.feesX, tokenX, _reserveX);\n        _feesY.flashLoanHelper(_pairInformation.feesY, tokenY, _reserveY);\n\n        uint256 _totalSupply = totalSupply(_id);\n\n        _bins[_id].accTokenXPerShare += _feesX.getTokenPerShare(_totalSupply);\n        _bins[_id].accTokenYPerShare += _feesY.getTokenPerShare(_totalSupply);\n\n        emit FlashLoan(msg.sender, _to, _amountXOut, _amountYOut, _feesX.total, _feesY.total);\n    }\n\n    /// @notice Performs a low level add, this needs to be called from a contract which performs important safety checks.\n    /// @param _ids The list of ids to add liquidity\n    /// @param _distributionX The distribution of tokenX with sum(_distributionX) = 1e18 (100%) or 0 (0%)\n    /// @param _distributionY The distribution of tokenY with sum(_distributionY) = 1e18 (100%) or 0 (0%)\n    /// @param _to The address of the recipient\n    /// @return The amount of token X that was added to the pair\n    /// @return The amount of token Y that was added to the pair\n    /// @return liquidityMinted Amount of LBToken minted\n    function mint(\n        uint256[] memory _ids,\n        uint256[] memory _distributionX,\n        uint256[] memory _distributionY,\n        address _to\n    )\n        external\n        override\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256[] memory liquidityMinted\n        )\n    {\n        if (_ids.length == 0 || _ids.length != _distributionX.length || _ids.length != _distributionY.length)\n            revert LBPair__WrongLengths();\n\n        PairInformation memory _pair = _pairInformation;\n\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n\n        MintInfo memory _mintInfo;\n\n        _mintInfo.amountXIn = tokenX.received(_pair.reserveX, _pair.feesX.total).safe128();\n        _mintInfo.amountYIn = tokenY.received(_pair.reserveY, _pair.feesY.total).safe128();\n\n        liquidityMinted = new uint256[](_ids.length);\n\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                _mintInfo.id = _ids[i].safe24();\n                Bin memory _bin = _bins[_mintInfo.id];\n\n                if (_bin.reserveX == 0 && _bin.reserveY == 0) _tree.addToTree(_mintInfo.id);\n\n                _mintInfo.distributionX = _distributionX[i];\n                _mintInfo.distributionY = _distributionY[i];\n\n                if (\n                    _mintInfo.distributionX > Constants.PRECISION ||\n                    _mintInfo.distributionY > Constants.PRECISION ||\n                    (_mintInfo.totalDistributionX += _mintInfo.distributionX) > Constants.PRECISION ||\n                    (_mintInfo.totalDistributionY += _mintInfo.distributionY) > Constants.PRECISION\n                ) revert LBPair__DistributionsOverflow();\n\n                // Can't overflow as amounts are uint128 and distributions are smaller or equal to 1e18\n                _mintInfo.amountX = (_mintInfo.amountXIn * _mintInfo.distributionX) / Constants.PRECISION;\n                _mintInfo.amountY = (_mintInfo.amountYIn * _mintInfo.distributionY) / Constants.PRECISION;\n\n                uint256 _price = BinHelper.getPriceFromId(_mintInfo.id, _fp.binStep);\n                if (_mintInfo.id >= _pair.activeId) {\n                    if (_mintInfo.id == _pair.activeId) {\n                        uint256 _totalSupply = totalSupply(_mintInfo.id);\n\n                        uint256 _userL = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\n                            _mintInfo.amountY;\n\n                        uint256 _receivedX;\n                        uint256 _receivedY;\n                        {\n                            uint256 _supply = _totalSupply + _userL;\n                            _receivedX = (_userL * (uint256(_bin.reserveX) + _mintInfo.amountX)) / _supply;\n                            _receivedY = (_userL * (uint256(_bin.reserveY) + _mintInfo.amountY)) / _supply;\n                        }\n\n                        _fp.updateVariableFeeParameters(_mintInfo.id);\n\n                        if (_mintInfo.amountX > _receivedX) {\n                            FeeHelper.FeesDistribution memory _fees = _fp.getFeeAmountDistribution(\n                                _fp.getFeeAmountForC(_mintInfo.amountX - _receivedX)\n                            );\n\n                            _mintInfo.amountX -= _fees.total;\n                            _mintInfo.activeFeeX += _fees.total;\n\n                            _bin.updateFees(_pair.feesX, _fees, true, _totalSupply);\n\n                            emit CompositionFee(msg.sender, _to, _mintInfo.id, _fees.total, 0);\n                        } else if (_mintInfo.amountY > _receivedY) {\n                            FeeHelper.FeesDistribution memory _fees = _fp.getFeeAmountDistribution(\n                                _fp.getFeeAmountForC(_mintInfo.amountY - _receivedY)\n                            );\n\n                            _mintInfo.amountY -= _fees.total;\n                            _mintInfo.activeFeeY += _fees.total;\n\n                            _bin.updateFees(_pair.feesY, _fees, false, _totalSupply);\n\n                            emit CompositionFee(msg.sender, _to, _mintInfo.id, 0, _fees.total);\n                        }\n                    } else if (_mintInfo.amountY != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\n                } else if (_mintInfo.amountX != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\n\n                uint256 _liquidity = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\n                    _mintInfo.amountY;\n\n                if (_liquidity == 0) revert LBPair__InsufficientLiquidityMinted(_mintInfo.id);\n\n                liquidityMinted[i] = _liquidity;\n\n                // The addition can't overflow as the amounts are checked to be uint128 and the reserves are uint112\n                _bin.reserveX = (_mintInfo.amountX + _bin.reserveX).safe112();\n                _bin.reserveY = (_mintInfo.amountY + _bin.reserveY).safe112();\n\n                // The addition or the cast can't overflow as it would have reverted during the L568 and L569 if amounts were greater than uint112\n                _pair.reserveX += uint112(_mintInfo.amountX);\n                _pair.reserveY += uint112(_mintInfo.amountY);\n\n                _mintInfo.amountXAddedToPair += _mintInfo.amountX;\n                _mintInfo.amountYAddedToPair += _mintInfo.amountY;\n\n                _bins[_mintInfo.id] = _bin;\n                _mint(_to, _mintInfo.id, _liquidity);\n\n                emit LiquidityAdded(\n                    msg.sender,\n                    _to,\n                    _mintInfo.id,\n                    _liquidity,\n                    _mintInfo.amountX,\n                    _mintInfo.amountY,\n                    _mintInfo.distributionX,\n                    _mintInfo.distributionY\n                );\n            }\n\n            _pairInformation = _pair;\n\n            uint256 _amountAddedPlusFee = _mintInfo.amountXAddedToPair + _mintInfo.activeFeeX;\n            // If user sent too much tokens, We send them back the excess\n            if (_mintInfo.amountXIn > _amountAddedPlusFee) {\n                tokenX.safeTransfer(_to, _mintInfo.amountXIn - _amountAddedPlusFee);\n            }\n\n            _amountAddedPlusFee = _mintInfo.amountYAddedToPair + _mintInfo.activeFeeY;\n            if (_mintInfo.amountYIn > _amountAddedPlusFee) {\n                tokenY.safeTransfer(_to, _mintInfo.amountYIn - _amountAddedPlusFee);\n            }\n        }\n\n        return (_mintInfo.amountXAddedToPair, _mintInfo.amountYAddedToPair, liquidityMinted);\n    }\n\n    /// @notice Performs a low level remove, this needs to be called from a contract which performs important safety checks\n    /// @param _ids The ids the user want to remove its liquidity\n    /// @param _amounts The amount of token to burn\n    /// @param _to The address of the recipient\n    /// @return amountX The amount of token X sent to `_to`\n    /// @return amountY The amount of token Y sent to `_to`\n    function burn(\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to\n    ) external override nonReentrant returns (uint256 amountX, uint256 amountY) {\n        (uint256 _pairReserveX, uint256 _pairReserveY, uint256 _activeId) = _getReservesAndId();\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                uint24 _id = _ids[i].safe24();\n                uint256 _amountToBurn = _amounts[i];\n\n                if (_amountToBurn == 0) revert LBPair__InsufficientLiquidityBurned(_id);\n\n                (uint256 _reserveX, uint256 _reserveY) = _getBin(_id);\n\n                uint256 _totalSupply = totalSupply(_id);\n\n                uint256 _amountX;\n                uint256 _amountY;\n\n                if (_id <= _activeId) {\n                    _amountY = _amountToBurn.mulDivRoundDown(_reserveY, _totalSupply);\n\n                    amountY += _amountY;\n                    _reserveY -= _amountY;\n                    _pairReserveY -= _amountY;\n                }\n                if (_id >= _activeId) {\n                    _amountX = _amountToBurn.mulDivRoundDown(_reserveX, _totalSupply);\n\n                    amountX += _amountX;\n                    _reserveX -= _amountX;\n                    _pairReserveX -= _amountX;\n                }\n\n                if (_reserveX == 0 && _reserveY == 0) _tree.removeFromTree(_id);\n\n                // Optimized `_bins[_id] = _bin` to do only 1 sstore\n                assembly {\n                    mstore(0, _id)\n                    mstore(32, _bins.slot)\n                    let slot := keccak256(0, 64)\n\n                    let reserves := add(shl(_OFFSET_BIN_RESERVE_Y, _reserveY), _reserveX)\n                    sstore(slot, reserves)\n                }\n\n                _burn(address(this), _id, _amountToBurn);\n\n                emit LiquidityRemoved(msg.sender, _to, _id, _amountToBurn, _amountX, _amountY);\n            }\n        }\n\n        // Optimization to do only 2 sstore\n        _pairInformation.reserveX = uint136(_pairReserveX);\n        _pairInformation.reserveY = uint136(_pairReserveY);\n\n        tokenX.safeTransfer(_to, amountX);\n        tokenY.safeTransfer(_to, amountY);\n    }\n\n    /// @notice Increase the length of the oracle\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\n    function increaseOracleLength(uint16 _newSize) external override {\n        _increaseOracle(_newSize);\n    }\n\n    /// @notice Collect fees of an user\n    /// @param _account The address of the user\n    /// @param _ids The list of bin ids to collect fees in\n    /// @return amountX The amount of tokenX claimed\n    /// @return amountY The amount of tokenY claimed\n    function collectFees(address _account, uint256[] memory _ids)\n        external\n        override\n        nonReentrant\n        returns (uint256 amountX, uint256 amountY)\n    {\n        unchecked {\n            bytes32 _unclaimedData = _unclaimedFees[_account];\n            delete _unclaimedFees[_account];\n\n            amountX = _unclaimedData.decode(type(uint128).max, 0);\n            amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n            for (uint256 i; i < _ids.length; ++i) {\n                uint256 _id = _ids[i];\n                uint256 _balance = balanceOf(_account, _id);\n\n                if (_balance != 0) {\n                    Bin memory _bin = _bins[_id];\n\n                    (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\n                    _updateUserDebts(_bin, _account, _id, _balance);\n\n                    amountX += _amountX;\n                    amountY += _amountY;\n                }\n            }\n\n            if (amountX != 0) {\n                _pairInformation.feesX.total -= uint128(amountX);\n            }\n            if (amountY != 0) {\n                _pairInformation.feesY.total -= uint128(amountY);\n            }\n\n            tokenX.safeTransfer(_account, amountX);\n            tokenY.safeTransfer(_account, amountY);\n\n            emit FeesCollected(msg.sender, _account, amountX, amountY);\n        }\n    }\n\n    /// @notice Collect the protocol fees and send them to the feeRecipient\n    /// @dev The balances are not zeroed to save gas by not resetting the storage slot\n    /// Only callable by the fee recipient\n    /// @return amountX The amount of tokenX claimed\n    /// @return amountY The amount of tokenY claimed\n    function collectProtocolFees() external override nonReentrant returns (uint256 amountX, uint256 amountY) {\n        unchecked {\n            address _feeRecipient = factory.feeRecipient();\n\n            if (msg.sender != _feeRecipient) revert LBPair__OnlyFeeRecipient(_feeRecipient, msg.sender);\n\n            // The fees returned can't be greater than uint128, so the assembly blocks are safe\n            (\n                uint256 _feesXTotal,\n                uint256 _feesYTotal,\n                uint256 _feesXProtocol,\n                uint256 _feesYProtocol\n            ) = _getGlobalFees();\n\n            if (_feesXProtocol > 1) {\n                amountX = _feesXProtocol - 1;\n                _feesXTotal -= amountX;\n\n                // Assembly block that does:\n                // _pairInformation.feesX = FeeHelper.FeesDistribution({total: _feesXTotal, protocol: 1});\n                assembly {\n                    let _slotX := add(_pairInformation.slot, 2)\n\n                    sstore(_slotX, add(shl(_OFFSET_PROTOCOL_FEE, 1), _feesXTotal))\n                }\n\n                tokenX.safeTransfer(_feeRecipient, amountX);\n            }\n\n            if (_feesYProtocol > 1) {\n                amountY = _feesYProtocol - 1;\n                _feesYTotal -= amountY;\n\n                // Assembly block that does:\n                // _pairInformation.feesY = FeeHelper.FeesDistribution({total: _feesYTotal, protocol: 1});\n                assembly {\n                    let _slotY := add(_pairInformation.slot, 3)\n\n                    sstore(_slotY, add(shl(_OFFSET_PROTOCOL_FEE, 1), _feesYTotal))\n                }\n\n                tokenY.safeTransfer(_feeRecipient, amountY);\n            }\n\n            emit ProtocolFeesCollected(msg.sender, _feeRecipient, amountX, amountY);\n        }\n    }\n\n    /// @notice Set the fees parameters\n    /// @dev Needs to be called by the factory that will validate the values\n    /// The bin step will not change\n    /// Only callable by the factory\n    /// @param _packedFeeParameters The packed fee parameters\n    function setFeesParameters(bytes32 _packedFeeParameters) external override onlyFactory {\n        _setFeesParameters(_packedFeeParameters);\n    }\n\n    function forceDecay() external override onlyFactory {\n        unchecked {\n            _feeParameters.volatilityReference = uint24(\n                (uint256(_feeParameters.reductionFactor) * _feeParameters.volatilityReference) /\n                    Constants.BASIS_POINT_MAX\n            );\n        }\n    }\n\n    /** Internal Functions **/\n\n    /// @notice Collect and update fees before any token transfer, mint or burn\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient of the  token\n    /// @param _id The id of the token\n    /// @param _amount The amount of token of type `id`\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal override(LBToken) {\n        unchecked {\n            super._beforeTokenTransfer(_from, _to, _id, _amount);\n\n            Bin memory _bin = _bins[_id];\n\n            if (_from != _to) {\n                if (_from != address(0) && _from != address(this)) {\n                    uint256 _balanceFrom = balanceOf(_from, _id);\n\n                    _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);\n                }\n\n                if (_to != address(0) && _to != address(this)) {\n                    uint256 _balanceTo = balanceOf(_to, _id);\n\n                    _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);\n                }\n            }\n        }\n    }\n\n    /** Private Functions **/\n\n    /// @notice View function to get the pending fees of an account on a given bin\n    /// @param _bin  The bin where the user is collecting fees\n    /// @param _account The address of the user\n    /// @param _id The id where the user is collecting fees\n    /// @param _balance The previous balance of the user\n    /// @return amountX The amount of tokenX pending for the account\n    /// @return amountY The amount of tokenY pending for the account\n    function _getPendingFees(\n        Bin memory _bin,\n        address _account,\n        uint256 _id,\n        uint256 _balance\n    ) private view returns (uint256 amountX, uint256 amountY) {\n        Debts memory _debts = _accruedDebts[_account][_id];\n\n        amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX;\n        amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY;\n    }\n\n    /// @notice Update fees of a given user\n    /// @param _bin The bin where the user has collected fees\n    /// @param _account The address of the user\n    /// @param _id The id where the user has collected fees\n    /// @param _balance The new balance of the user\n    function _updateUserDebts(\n        Bin memory _bin,\n        address _account,\n        uint256 _id,\n        uint256 _balance\n    ) private {\n        uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n        uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n\n        _accruedDebts[_account][_id].debtX = _debtX;\n        _accruedDebts[_account][_id].debtY = _debtY;\n    }\n\n    /// @notice Update the unclaimed fees of a given user before a transfer\n    /// @param _bin The bin where the user has collected fees\n    /// @param _user The address of the user\n    /// @param _id The id where the user has collected fees\n    /// @param _previousBalance The previous balance of the user\n    /// @param _newBalance The new balance of the user\n    function _cacheFees(\n        Bin memory _bin,\n        address _user,\n        uint256 _id,\n        uint256 _previousBalance,\n        uint256 _newBalance\n    ) private {\n        unchecked {\n            bytes32 _unclaimedData = _unclaimedFees[_user];\n\n            uint256 amountX = _unclaimedData.decode(type(uint128).max, 0);\n            uint256 amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n            (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _user, _id, _previousBalance);\n            _updateUserDebts(_bin, _user, _id, _newBalance);\n\n            (amountX += _amountX).safe128();\n            (amountY += _amountY).safe128();\n\n            _unclaimedFees[_user] = bytes32((amountY << 128) | amountX);\n        }\n    }\n\n    /// @notice Internal function to set the fee parameters of the pair\n    /// @param _packedFeeParameters The packed fee parameters\n    function _setFeesParameters(bytes32 _packedFeeParameters) internal {\n        bytes32 _feeStorageSlot;\n        assembly {\n            _feeStorageSlot := sload(_feeParameters.slot)\n        }\n\n        uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);\n        uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n        assembly {\n            sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))\n        }\n    }\n\n    /// @notice Private function to increase the oracle's number of sample\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\n    function _increaseOracle(uint16 _newSize) private {\n        uint256 _oracleSize = _pairInformation.oracleSize;\n\n        if (_oracleSize >= _newSize) revert LBPair__NewSizeTooSmall(_newSize, _oracleSize);\n\n        _pairInformation.oracleSize = _newSize;\n\n        unchecked {\n            for (uint256 _id = _oracleSize; _id < _newSize; ++_id) {\n                _oracle.initialize(_id);\n            }\n        }\n\n        emit OracleSizeIncreased(_oracleSize, _newSize);\n    }\n\n    /// @notice Private view function to return the oracle's parameters\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\n    /// @return oracleSize The size of the oracle (last ids can be empty)\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\n    /// @return oracleId The index of the oracle's latest sample\n    function _getOracleParameters()\n        internal\n        view\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId\n        )\n    {\n        bytes32 _slot;\n        assembly {\n            _slot := sload(add(_pairInformation.slot, 1))\n        }\n        oracleSampleLifetime = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SAMPLE_LIFETIME);\n        oracleSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SIZE);\n        oracleActiveSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_ACTIVE_SIZE);\n        oracleLastTimestamp = _slot.decode(type(uint40).max, _OFFSET_ORACLE_LAST_TIMESTAMP);\n        oracleId = _slot.decode(type(uint24).max, _OFFSET_ORACLE_ID);\n    }\n\n    /// @notice Internal view function to get the reserves and active id\n    /// @return reserveX The reserve of asset X\n    /// @return reserveY The reserve of asset Y\n    /// @return activeId The active id of the pair\n    function _getReservesAndId()\n        internal\n        view\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        )\n    {\n        uint256 _mask24 = type(uint24).max;\n        uint256 _mask136 = type(uint136).max;\n        assembly {\n            let slot := sload(add(_pairInformation.slot, 1))\n            reserveY := and(slot, _mask136)\n\n            slot := sload(_pairInformation.slot)\n            activeId := and(slot, _mask24)\n            reserveX := and(shr(_OFFSET_PAIR_RESERVE_X, slot), _mask136)\n        }\n    }\n\n    /// @notice Internal view function to get the bin at `id`\n    /// @param _id The bin id\n    /// @return reserveX The reserve of tokenX of the bin\n    /// @return reserveY The reserve of tokenY of the bin\n    function _getBin(uint24 _id) internal view returns (uint256 reserveX, uint256 reserveY) {\n        bytes32 _data;\n        uint256 _mask112 = type(uint112).max;\n        // low level read of mapping to only load 1 storage slot\n        assembly {\n            mstore(0, _id)\n            mstore(32, _bins.slot)\n            _data := sload(keccak256(0, 64))\n\n            reserveX := and(_data, _mask112)\n            reserveY := shr(_OFFSET_BIN_RESERVE_Y, _data)\n        }\n\n        return (reserveX.safe112(), reserveY.safe112());\n    }\n\n    /// @notice Internal view function to get the global fees information, the total fees and those for protocol\n    /// @dev The fees for users are `total - protocol`\n    /// @return feesXTotal The total fees of asset X\n    /// @return feesYTotal The total fees of asset Y\n    /// @return feesXProtocol The protocol fees of asset X\n    /// @return feesYProtocol The protocol fees of asset Y\n    function _getGlobalFees()\n        internal\n        view\n        returns (\n            uint256 feesXTotal,\n            uint256 feesYTotal,\n            uint256 feesXProtocol,\n            uint256 feesYProtocol\n        )\n    {\n        bytes32 _slotX;\n        bytes32 _slotY;\n        assembly {\n            _slotX := sload(add(_pairInformation.slot, 2))\n            _slotY := sload(add(_pairInformation.slot, 3))\n        }\n\n        feesXTotal = _slotX.decode(type(uint128).max, 0);\n        feesYTotal = _slotY.decode(type(uint128).max, 0);\n\n        feesXProtocol = _slotX.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE);\n        feesYProtocol = _slotY.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE);\n    }\n\n    /// @notice Internal pure function to return the flashloan fee amount\n    /// @param _amount The amount to flashloan\n    /// @param _fee the fee percentage, in basis point\n    /// @return The fee amount\n    function _getFlashLoanFee(uint256 _amount, uint256 _fee) internal pure returns (uint256) {\n        return (_amount * _fee) / Constants.PRECISION;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinPairSwapsTest is TestHelper {\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n        addAllAssetsToQuoteWhitelist(factory);\n        router = new LBRouter(ILBFactory(DEV), IJoeFactory(DEV), IWAVAX(DEV));\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n    }\n\n    function testSwapInsufficientAmountReverts() public {\n        vm.expectRevert(LBPair__InsufficientAmounts.selector);\n        pair.swap(true, DEV);\n        vm.expectRevert(LBPair__InsufficientAmounts.selector);\n        pair.swap(false, DEV);\n    }\n\n    function testSwapXtoYSingleBinFromGetSwapOut() public {\n        uint256 tokenAmount = 100e18;\n        token18D.mint(address(pair), tokenAmount);\n\n        uint256[] memory _ids = new uint256[](1);\n        _ids[0] = ID_ONE;\n\n        uint256[] memory _liquidities = new uint256[](1);\n        _liquidities[0] = Constants.PRECISION;\n\n        pair.mint(_ids, new uint256[](1), _liquidities, DEV);\n\n        uint256 amountXIn = 1e12;\n\n        (uint256 amountYOut, ) = router.getSwapOut(pair, amountXIn, true);\n\n        token6D.mint(address(pair), amountXIn);\n\n        pair.swap(true, DEV);\n\n        assertEq(token6D.balanceOf(DEV), 0);\n        assertEq(token18D.balanceOf(DEV), amountYOut);\n\n        (uint256 binReserveX, uint256 binReserveY) = pair.getBin(ID_ONE);\n\n        (uint256 feesXTotal, , , ) = pair.getGlobalFees();\n\n        assertEq(binReserveX, amountXIn - feesXTotal);\n        assertEq(binReserveY, tokenAmount - amountYOut);\n    }\n\n    function testSwapYtoXSingleBinFromGetSwapOut() public {\n        uint256 tokenAmount = 100e18;\n        token6D.mint(address(pair), tokenAmount);\n\n        uint256[] memory _ids = new uint256[](1);\n        _ids[0] = ID_ONE;\n\n        // uint256 price = router.getPriceFromId(pair, uint24(_ids[0]));\n\n        uint256[] memory _liquidities = new uint256[](1);\n        _liquidities[0] = Constants.PRECISION;\n\n        pair.mint(_ids, _liquidities, new uint256[](1), DEV);\n\n        uint256 amountYIn = 1e12;\n\n        (uint256 amountXOut, ) = router.getSwapOut(pair, amountYIn, false);\n\n        token18D.mint(address(pair), amountYIn);\n\n        pair.swap(false, DEV);\n\n        assertEq(token6D.balanceOf(DEV), amountXOut);\n        assertEq(token18D.balanceOf(DEV), 0);\n\n        (uint256 binReserveX, uint256 binReserveY) = pair.getBin(uint24(_ids[0]));\n\n        (, uint256 feesYTotal, , ) = pair.getGlobalFees();\n\n        assertEq(binReserveX, tokenAmount - amountXOut);\n        assertEq(binReserveY, amountYIn - feesYTotal);\n    }\n\n    function testSwapXtoYSingleBinFromGetSwapIn() public {\n        uint256 tokenAmount = 100e18;\n        token18D.mint(address(pair), tokenAmount);\n\n        uint256[] memory _ids = new uint256[](1);\n        _ids[0] = ID_ONE;\n\n        uint256[] memory _liquidities = new uint256[](1);\n        _liquidities[0] = Constants.PRECISION;\n\n        pair.mint(_ids, new uint256[](1), _liquidities, DEV);\n\n        uint256 amountYOut = 1e12;\n\n        (uint256 amountXIn, ) = router.getSwapIn(pair, amountYOut, true);\n\n        token6D.mint(address(pair), amountXIn);\n\n        pair.swap(true, DEV);\n\n        assertEq(token6D.balanceOf(DEV), 0);\n        assertEq(token18D.balanceOf(DEV), amountYOut);\n\n        (uint256 binReserveX, uint256 binReserveY) = pair.getBin(ID_ONE);\n\n        (uint256 feesXTotal, , , ) = pair.getGlobalFees();\n\n        assertEq(binReserveX, amountXIn - feesXTotal);\n        assertEq(binReserveY, tokenAmount - amountYOut);\n    }\n\n    function testSwapYtoXSingleBinFromGetSwapIn() public {\n        uint256 tokenAmount = 100e18;\n        token6D.mint(address(pair), tokenAmount);\n\n        uint256[] memory _ids = new uint256[](1);\n        _ids[0] = ID_ONE + 1;\n\n        uint256[] memory _liquidities = new uint256[](1);\n        _liquidities[0] = Constants.PRECISION;\n\n        pair.mint(_ids, _liquidities, new uint256[](1), DEV);\n\n        uint256 amountXOut = 1e12;\n\n        (uint256 amountYIn, ) = router.getSwapIn(pair, amountXOut, false);\n\n        token18D.mint(address(pair), amountYIn);\n\n        pair.swap(false, DEV);\n\n        assertEq(token6D.balanceOf(DEV), amountXOut);\n        assertEq(token18D.balanceOf(DEV), 0);\n\n        (uint256 binReserveX, uint256 binReserveY) = pair.getBin(uint24(_ids[0]));\n\n        (, uint256 feesYTotal, , ) = pair.getGlobalFees();\n\n        assertEq(binReserveX, tokenAmount - amountXOut);\n        assertEq(binReserveY, amountYIn - feesYTotal);\n    }\n\n    function testSwapYtoXConsecutiveBinFromGetSwapIn() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountXOutForSwap = 30e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 9, 0);\n\n        (uint256 amountYInForSwap, ) = router.getSwapIn(pair, amountXOutForSwap, false);\n\n        token18D.mint(address(pair), amountYInForSwap);\n\n        pair.swap(false, ALICE);\n\n        assertGe(token6D.balanceOf(ALICE), amountXOutForSwap);\n        assertApproxEqRel(token6D.balanceOf(ALICE), amountXOutForSwap, 1e14);\n    }\n\n    function testSwapXtoYConsecutiveBinFromGetSwapIn() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountYOutForSwap = 30e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 9, 0);\n\n        (uint256 amountXInForSwap, ) = router.getSwapIn(pair, amountYOutForSwap, true);\n\n        token6D.mint(address(pair), amountXInForSwap);\n\n        pair.swap(true, ALICE);\n\n        assertGe(token18D.balanceOf(ALICE), amountYOutForSwap);\n        assertApproxEqRel(token18D.balanceOf(ALICE), amountYOutForSwap, 1e14);\n    }\n\n    function testSwapYtoXConsecutiveBinFromGetSwapOut() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountYInForSwap = 30e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 9, 0);\n\n        (uint256 amountXOutForSwap, ) = router.getSwapOut(pair, amountYInForSwap, false);\n\n        token18D.mint(address(pair), amountYInForSwap);\n\n        pair.swap(false, ALICE);\n\n        assertApproxEqAbs(token6D.balanceOf(ALICE), amountXOutForSwap, 1);\n    }\n\n    function testSwapXtoYConsecutiveBinFromGetSwapOut() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountXInForSwap = 30e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 9, 0);\n\n        (uint256 amountYOutForSwap, ) = router.getSwapOut(pair, amountXInForSwap, true);\n\n        token6D.mint(address(pair), amountXInForSwap);\n\n        pair.swap(true, ALICE);\n\n        assertEq(token18D.balanceOf(ALICE), amountYOutForSwap);\n    }\n\n    function testSwapYtoXDistantBinsFromGetSwapIn() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountXOutForSwap = 30e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 9, 100);\n\n        (uint256 amountYInForSwap, ) = router.getSwapIn(pair, amountXOutForSwap, false);\n\n        token18D.mint(address(pair), amountYInForSwap);\n\n        pair.swap(false, ALICE);\n\n        assertGe(token6D.balanceOf(ALICE), amountXOutForSwap);\n        assertApproxEqRel(token6D.balanceOf(ALICE), amountXOutForSwap, 1e14);\n    }\n\n    function testSwapXtoYDistantBinsFromGetSwapIn() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountYOutForSwap = 30e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 9, 100);\n\n        (uint256 amountXInForSwap, ) = router.getSwapIn(pair, amountYOutForSwap, true);\n\n        token6D.mint(address(pair), amountXInForSwap);\n\n        pair.swap(true, ALICE);\n\n        assertGe(token18D.balanceOf(ALICE), amountYOutForSwap);\n        assertApproxEqRel(token18D.balanceOf(ALICE), amountYOutForSwap, 1e14);\n    }\n\n    function testSwapYtoXDistantBinsFromGetSwapOut() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountYInForSwap = 30e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 9, 100);\n\n        (uint256 amountXOutForSwap, ) = router.getSwapOut(pair, amountYInForSwap, false);\n\n        token18D.mint(address(pair), amountYInForSwap);\n\n        pair.swap(false, ALICE);\n\n        assertApproxEqAbs(token6D.balanceOf(ALICE), amountXOutForSwap, 1);\n    }\n\n    function testSwapXtoYDistantBinsFromGetSwapOut() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountXInForSwap = 30e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 9, 100);\n\n        (uint256 amountYOutForSwap, ) = router.getSwapOut(pair, amountXInForSwap, true);\n\n        token6D.mint(address(pair), amountXInForSwap);\n\n        pair.swap(true, ALICE);\n\n        assertEq(token18D.balanceOf(ALICE), amountYOutForSwap);\n    }\n\n    function testInvalidTokenPathReverts() public {\n        uint256 _amountIn = 10e18;\n        uint256 _amountOutMinAVAX = 10e18;\n        uint256[] memory _pairBinSteps = new uint256[](1);\n        IERC20[] memory _tokenPath = new IERC20[](2);\n        _tokenPath[0] = token6D;\n        _tokenPath[1] = token18D;\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InvalidTokenPath.selector, _tokenPath[1]));\n        router.swapExactTokensForAVAX(_amountIn, _amountOutMinAVAX, _pairBinSteps, _tokenPath, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InvalidTokenPath.selector, _tokenPath[1]));\n        router.swapTokensForExactAVAX(_amountIn, _amountOutMinAVAX, _pairBinSteps, _tokenPath, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InvalidTokenPath.selector, _tokenPath[1]));\n        router.swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n            _amountIn,\n            _amountOutMinAVAX,\n            _pairBinSteps,\n            _tokenPath,\n            DEV,\n            block.timestamp\n        );\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InvalidTokenPath.selector, _tokenPath[0]));\n        router.swapAVAXForExactTokens(_amountIn, _pairBinSteps, _tokenPath, DEV, block.timestamp);\n\n        vm.expectRevert(abi.encodeWithSelector(LBRouter__InvalidTokenPath.selector, _tokenPath[0]));\n        router.swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n            _amountIn,\n            _pairBinSteps,\n            _tokenPath,\n            DEV,\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\nimport \"src/libraries/Oracle.sol\";\n\ncontract LiquidityBinPairOracleTest is TestHelper {\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n\n        router = new LBRouter(ILBFactory(DEV), IJoeFactory(DEV), IWAVAX(DEV));\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n    }\n\n    function testVerifyOracleInitialParams() public {\n        (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        ) = pair.getOracleParameters();\n\n        assertEq(oracleSampleLifetime, 120);\n        assertEq(oracleSize, 2);\n        assertEq(oracleActiveSize, 0);\n        assertEq(oracleLastTimestamp, 0);\n        assertEq(oracleId, 0);\n        assertEq(min, 0);\n        assertEq(max, 0);\n    }\n\n    function testIncreaseOracleLength() public {\n        (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        ) = pair.getOracleParameters();\n\n        pair.increaseOracleLength(100);\n\n        (\n            uint256 newOracleSampleLifetime,\n            uint256 newOracleSize,\n            uint256 newOracleActiveSize,\n            uint256 newOracleLastTimestamp,\n            uint256 newOracleId,\n            uint256 newMin,\n            uint256 newMax\n        ) = pair.getOracleParameters();\n\n        assertEq(newOracleSampleLifetime, oracleSampleLifetime);\n        assertEq(newOracleSize, 100);\n        assertEq(newOracleActiveSize, oracleActiveSize);\n        assertEq(newOracleLastTimestamp, oracleLastTimestamp);\n        assertEq(newOracleId, oracleId);\n        assertEq(newMin, min);\n        assertEq(newMax, max);\n    }\n\n    function testOracleSampleFromEdgeCases() public {\n        uint256 tokenAmount = 100e18;\n        token18D.mint(address(pair), tokenAmount);\n\n        uint256[] memory _ids = new uint256[](1);\n        _ids[0] = ID_ONE;\n\n        uint256[] memory _liquidities = new uint256[](1);\n        _liquidities[0] = Constants.PRECISION;\n\n        pair.mint(_ids, new uint256[](1), _liquidities, DEV);\n\n        token6D.mint(address(pair), 5e18);\n\n        vm.expectRevert(Oracle__NotInitialized.selector);\n        pair.getOracleSampleFrom(0);\n\n        vm.warp(10_000);\n\n        pair.swap(true, DEV);\n\n        vm.expectRevert(abi.encodeWithSelector(Oracle__LookUpTimestampTooOld.selector, 10_000, 9_000));\n        pair.getOracleSampleFrom(1_000);\n    }\n\n    function testOracleSampleFromWith2Samples() public {\n        uint256 tokenAmount = 100e18;\n        token18D.mint(address(pair), tokenAmount);\n\n        uint256[] memory _ids = new uint256[](1);\n        _ids[0] = ID_ONE;\n\n        uint256[] memory _liquidities = new uint256[](1);\n        _liquidities[0] = Constants.PRECISION;\n\n        pair.mint(_ids, new uint256[](1), _liquidities, DEV);\n\n        token6D.mint(address(pair), 5e18);\n\n        pair.swap(true, DEV);\n\n        vm.warp(block.timestamp + 250);\n\n        token6D.mint(address(pair), 5e18);\n\n        pair.swap(true, DEV);\n\n        uint256 _ago = 130;\n        uint256 _time = block.timestamp - _ago;\n\n        (uint256 cumulativeId, uint256 cumulativeVolatilityAccumulated, uint256 cumulativeBinCrossed) = pair\n            .getOracleSampleFrom(_ago);\n        assertEq(cumulativeId / _time, ID_ONE);\n        assertEq(cumulativeVolatilityAccumulated, 0);\n        assertEq(cumulativeBinCrossed, 0);\n    }\n\n    function testOracleSampleFromWith100Samples() public {\n        uint256 amount1In = 200e18;\n        (\n            uint256[] memory _ids,\n            uint256[] memory _distributionX,\n            uint256[] memory _distributionY,\n            uint256 amount0In\n        ) = spreadLiquidity(amount1In * 2, ID_ONE, 99, 100);\n\n        token6D.mint(address(pair), amount0In);\n        token18D.mint(address(pair), amount1In);\n\n        pair.mint(_ids, _distributionX, _distributionY, DEV);\n        pair.increaseOracleLength(100);\n\n        uint256 startTimestamp;\n\n        for (uint256 i; i < 200; ++i) {\n            token6D.mint(address(pair), 1e18);\n\n            vm.warp(1500 + 100 * i);\n            pair.swap(true, DEV);\n\n            if (i == 1) startTimestamp = block.timestamp;\n        }\n\n        (uint256 cId, uint256 cAcc, uint256 cBin) = pair.getOracleSampleFrom(0);\n\n        for (uint256 i; i < 99; ++i) {\n            uint256 _ago = ((block.timestamp - startTimestamp) * i) / 100;\n\n            (uint256 cumulativeId, uint256 cumulativeVolatilityAccumulated, uint256 cumulativeBinCrossed) = pair\n                .getOracleSampleFrom(_ago);\n            assertGe(cId, cumulativeId);\n            assertGe(cAcc, cumulativeVolatilityAccumulated);\n            assertGe(cBin, cumulativeBinCrossed);\n\n            (cId, cAcc, cBin) = (cumulativeId, cumulativeVolatilityAccumulated, cumulativeBinCrossed);\n        }\n    }\n\n    function testOracleSampleFromWith100SamplesNotAllInitialized() public {\n        uint256 amount1In = 101e18;\n        (\n            uint256[] memory _ids,\n            uint256[] memory _distributionX,\n            uint256[] memory _distributionY,\n            uint256 amount0In\n        ) = spreadLiquidity(amount1In * 2, ID_ONE, 99, 100);\n\n        token6D.mint(address(pair), amount0In);\n        token18D.mint(address(pair), amount1In);\n\n        pair.mint(_ids, _distributionX, _distributionY, DEV);\n\n        uint256 startTimestamp;\n\n        uint16 newSize = 2;\n        for (uint256 i; i < 50; ++i) {\n            token6D.mint(address(pair), 1e18);\n\n            newSize += 2;\n            pair.increaseOracleLength(newSize);\n\n            vm.warp(1500 + 100 * i);\n            pair.swap(true, DEV);\n\n            if (i == 1) startTimestamp = block.timestamp;\n        }\n\n        (uint256 cId, uint256 cAcc, uint256 cBin) = pair.getOracleSampleFrom(0);\n\n        for (uint256 i; i < 49; ++i) {\n            uint256 _ago = ((block.timestamp - startTimestamp) * i) / 50;\n\n            (uint256 cumulativeId, uint256 cumulativeVolatilityAccumulated, uint256 cumulativeBinCrossed) = pair\n                .getOracleSampleFrom(_ago);\n            assertGe(cId, cumulativeId);\n            assertGe(cAcc, cumulativeVolatilityAccumulated);\n            assertGe(cBin, cumulativeBinCrossed);\n\n            (cId, cAcc, cBin) = (cumulativeId, cumulativeVolatilityAccumulated, cumulativeBinCrossed);\n        }\n    }\n\n    function testTLowerThanTimestamp() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint24 startId = ID_ONE;\n\n        FeeHelper.FeeParameters memory _feeParameters = pair.feeParameters();\n        addLiquidity(amountYInLiquidity, startId, 51, 5);\n\n        (uint256 amountYInForSwap, ) = router.getSwapIn(pair, amountYInLiquidity / 4, true);\n        token6D.mint(address(pair), amountYInForSwap);\n        vm.prank(ALICE);\n        pair.swap(true, ALICE);\n\n        (uint256 cumulativeId, uint256 cumulativeVolatilityAccumulated, uint256 cumulativeBinCrossed) = pair\n            .getOracleSampleFrom(0);\n\n        vm.warp(block.timestamp + 90);\n        (\n            uint256 cumulativeIdAfter,\n            uint256 cumulativeVolatilityAccumulatedAfter,\n            uint256 cumulativeBinCrossedAfter\n        ) = pair.getOracleSampleFrom(0);\n\n        assertEq(cumulativeId * block.timestamp, cumulativeIdAfter);\n        assertLt(cumulativeVolatilityAccumulated, cumulativeVolatilityAccumulatedAfter);\n        assertEq(cumulativeBinCrossed, cumulativeBinCrossedAfter);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinPairLiquidityTest is TestHelper {\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n\n        router = new LBRouter(ILBFactory(DEV), IJoeFactory(DEV), IWAVAX(DEV));\n    }\n\n    function testConstructor(\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated\n    ) public {\n        bytes32 _packedFeeParameters = bytes32(\n            abi.encodePacked(\n                uint136(_maxVolatilityAccumulated), // The first 112 bits are reserved for the dynamic parameters\n                _protocolShare,\n                _variableFeeControl,\n                _reductionFactor,\n                _decayPeriod,\n                _filterPeriod,\n                _baseFactor,\n                _binStep\n            )\n        );\n\n        pair = new LBPair(ILBFactory(DEV));\n        pair.initialize(token6D, token18D, ID_ONE, DEFAULT_SAMPLE_LIFETIME, _packedFeeParameters);\n\n        assertEq(address(pair.factory()), DEV);\n        assertEq(address(pair.tokenX()), address(token6D));\n        assertEq(address(pair.tokenY()), address(token18D));\n\n        FeeHelper.FeeParameters memory feeParameters = pair.feeParameters();\n        assertEq(feeParameters.volatilityAccumulated, 0, \"volatilityAccumulated should be 0\");\n        assertEq(feeParameters.volatilityReference, 0, \"volatilityReference should be 0\");\n        assertEq(feeParameters.indexRef, 0, \"indexRef should be 0\");\n        assertEq(feeParameters.time, 0, \"Time should be zero\");\n        assertEq(\n            feeParameters.maxVolatilityAccumulated,\n            _maxVolatilityAccumulated,\n            \"Max volatilityAccumulated should be correctly set\"\n        );\n        assertEq(feeParameters.filterPeriod, _filterPeriod, \"Filter Period should be correctly set\");\n        assertEq(feeParameters.decayPeriod, _decayPeriod, \"Decay Period should be correctly set\");\n        assertEq(feeParameters.binStep, _binStep, \"Bin Step should be correctly set\");\n        assertEq(feeParameters.baseFactor, _baseFactor, \"Base Factor should be correctly set\");\n        assertEq(feeParameters.protocolShare, _protocolShare, \"Protocol Share should be correctly set\");\n    }\n\n    function testFuzzingAddLiquidity(uint256 _price) public {\n        // Avoids Math__Exp2InputTooBig and very small x amounts\n        vm.assume(_price < 2**239);\n        // Avoids LBPair__BinReserveOverflows (very big x amounts)\n        vm.assume(_price > 2**17);\n\n        uint24 startId = getIdFromPrice(_price);\n\n        uint256 _calculatedPrice = getPriceFromId(startId);\n\n        // Can't use `assertApproxEqRel` as it overflow when multiplying by 1e18\n        // Assert that price is at most `binStep`% away from the calculated price\n        assertEq(\n            (\n                (((_price * (Constants.BASIS_POINT_MAX - DEFAULT_BIN_STEP)) / 10_000) <= _calculatedPrice &&\n                    _calculatedPrice <= (_price * (Constants.BASIS_POINT_MAX + DEFAULT_BIN_STEP)) / 10_000)\n            ),\n            true,\n            \"Wrong log2\"\n        );\n\n        pair = createLBPairDefaultFeesFromStartId(token6D, token18D, startId);\n\n        uint256 amountYIn = _price > 2**128 ? 2 * ((1 << 112) - 1) : 2;\n\n        (, , , uint256 amountXIn) = addLiquidity(amountYIn, startId, 3, 0);\n\n        console2.log(\"startId\", startId);\n\n        (uint256 currentBinReserveX, uint256 currentBinReserveY) = pair.getBin(startId);\n        (uint256 binYReserve0, uint256 binYReserve1) = pair.getBin(startId - 1);\n        (uint256 binXReserve0, uint256 binXReserve1) = pair.getBin(startId + 1);\n\n        console2.log(\"bin0\", currentBinReserveX, currentBinReserveY);\n        console2.log(\"binY\", binYReserve0, binYReserve1);\n        console2.log(\"binX\", binXReserve0, binXReserve1);\n\n        assertApproxEqRel(currentBinReserveX, amountXIn / 2, 1e3, \"currentBinReserveX\");\n        assertApproxEqRel(currentBinReserveY, amountYIn / 2, 1e3, \"currentBinReserveY\");\n\n        assertEq(binYReserve0, 0, \"binYReserve0\");\n        assertApproxEqRel(binYReserve1, amountYIn / 2, 1e3, \"binYReserve1\");\n\n        assertEq(binXReserve1, 0, \"binXReserve0\");\n        assertApproxEqRel(binXReserve0, amountXIn / 2, 1e3, \"binXReserve1\");\n        assertEq(binXReserve1, 0, \"binXReserve0\");\n    }\n\n    function testBurnLiquidity() public {\n        pair = createLBPairDefaultFees(token6D, token18D);\n        uint256 amount1In = 3e12;\n        (\n            uint256[] memory _ids,\n            uint256[] memory _distributionX,\n            uint256[] memory _distributionY,\n            uint256 amount0In\n        ) = spreadLiquidity(amount1In * 2, ID_ONE, 5, 0);\n\n        token6D.mint(address(pair), amount0In);\n        token18D.mint(address(pair), amount1In);\n\n        pair.mint(_ids, _distributionX, _distributionY, ALICE);\n\n        token6D.mint(address(pair), amount0In);\n        token18D.mint(address(pair), amount1In);\n\n        pair.mint(_ids, _distributionX, _distributionY, BOB);\n\n        uint256[] memory amounts = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            amounts[i] = pair.balanceOf(BOB, _ids[i]);\n        }\n\n        vm.startPrank(BOB);\n        pair.safeBatchTransferFrom(BOB, address(pair), _ids, amounts);\n        pair.burn(_ids, amounts, BOB);\n        pair.collectFees(BOB, _ids); // the excess token were sent to fees, so they need to be claimed\n        vm.stopPrank();\n\n        assertEq(token6D.balanceOf(BOB), amount0In);\n        assertEq(token18D.balanceOf(BOB), amount1In);\n    }\n\n    function testFlawedCompositionFactor() public {\n        uint24 _numberBins = 5;\n        uint24 startId = ID_ONE;\n        uint256 amount0In = 3e12;\n        uint256 amount1In = 3e12;\n        pair = createLBPairDefaultFees(token6D, token18D);\n\n        addLiquidity(amount1In, startId, _numberBins, 0);\n\n        (uint256 reserveX, uint256 reserveY, uint256 activeId) = pair.getReservesAndId();\n\n        uint256[] memory _ids = new uint256[](3);\n        _ids[0] = activeId - 1;\n        _ids[1] = activeId;\n        _ids[2] = activeId + 1;\n        uint256[] memory _distributionX = new uint256[](3);\n        _distributionX[0] = Constants.PRECISION / 3;\n        _distributionX[1] = Constants.PRECISION / 3;\n        _distributionX[2] = Constants.PRECISION / 3;\n        uint256[] memory _distributionY = new uint256[](3);\n\n        token6D.mint(address(pair), amount0In);\n        token18D.mint(address(pair), amount1In);\n\n        vm.expectRevert(abi.encodeWithSelector(LBPair__CompositionFactorFlawed.selector, _ids[0]));\n        pair.mint(_ids, _distributionX, _distributionY, ALICE);\n\n        _distributionX[2] = 0;\n        _distributionX[1] = 0;\n        _distributionX[0] = 0;\n        _distributionY[0] = Constants.PRECISION / 3;\n        _distributionY[1] = Constants.PRECISION / 3;\n        _distributionY[2] = Constants.PRECISION / 3;\n\n        vm.expectRevert(abi.encodeWithSelector(LBPair__CompositionFactorFlawed.selector, _ids[2]));\n        pair.mint(_ids, _distributionX, _distributionY, ALICE);\n\n        uint256[] memory _ids2 = new uint256[](1);\n        uint256[] memory _distributionX2 = new uint256[](1);\n        uint256[] memory _distributionY2 = new uint256[](1);\n\n        _ids2[0] = activeId - 1;\n        _distributionX2[0] = Constants.PRECISION;\n        vm.expectRevert(abi.encodeWithSelector(LBPair__CompositionFactorFlawed.selector, _ids2[0]));\n        pair.mint(_ids2, _distributionX2, _distributionY2, ALICE);\n\n        _ids2[0] = activeId + 1;\n        _distributionY2[0] = Constants.PRECISION;\n        _distributionX2[0] = 0;\n        vm.expectRevert(abi.encodeWithSelector(LBPair__CompositionFactorFlawed.selector, _ids2[0]));\n        pair.mint(_ids2, _distributionX2, _distributionY2, ALICE);\n    }\n\n    function testInsufficientLiquidityMinted() public {\n        uint24 _numberBins = 5;\n        uint24 startId = ID_ONE;\n        uint256 amount0In = 3e12;\n        uint256 amount1In = 3e12;\n        pair = createLBPairDefaultFees(token6D, token18D);\n\n        addLiquidity(amount1In, startId, _numberBins, 0);\n\n        (uint256 reserveX, uint256 reserveY, uint256 activeId) = pair.getReservesAndId();\n\n        uint256[] memory _ids = new uint256[](3);\n        _ids[0] = activeId - 1;\n        _ids[1] = activeId;\n        _ids[2] = activeId + 1;\n        uint256[] memory _distributionX = new uint256[](3);\n        _distributionX[0] = 0;\n        _distributionX[1] = Constants.PRECISION / 3;\n        _distributionX[2] = Constants.PRECISION / 3;\n        uint256[] memory _distributionY = new uint256[](3);\n\n        token6D.mint(address(pair), amount0In);\n        token18D.mint(address(pair), amount1In);\n\n        vm.expectRevert(abi.encodeWithSelector(LBPair__InsufficientLiquidityMinted.selector, _ids[0]));\n        pair.mint(_ids, _distributionX, _distributionY, ALICE);\n\n        _distributionX[2] = 0;\n        _distributionX[1] = 0;\n        _distributionX[0] = 0;\n        _distributionY[0] = Constants.PRECISION / 3;\n        _distributionY[1] = Constants.PRECISION / 3;\n        _distributionY[2] = 0;\n\n        vm.expectRevert(abi.encodeWithSelector(LBPair__InsufficientLiquidityMinted.selector, _ids[2]));\n        pair.mint(_ids, _distributionX, _distributionY, ALICE);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\nimport \"src/libraries/Math512Bits.sol\";\n\ncontract LiquidityBinPairFeesTest is TestHelper {\n    using Math512Bits for uint256;\n\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n\n        router = new LBRouter(ILBFactory(DEV), IJoeFactory(DEV), IWAVAX(DEV));\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n    }\n\n    function testClaimFeesY() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountXOutForSwap = 1e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 5, 0);\n\n        (uint256 amountYInForSwap, uint256 feesFromGetSwapIn) = router.getSwapIn(pair, amountXOutForSwap, false);\n\n        token18D.mint(address(pair), amountYInForSwap);\n        vm.prank(ALICE);\n        pair.swap(false, DEV);\n\n        (, uint256 feesYTotal, , uint256 feesYProtocol) = pair.getGlobalFees();\n        assertEq(feesYTotal, feesFromGetSwapIn);\n\n        uint256 accumulatedYFees = feesYTotal - feesYProtocol;\n\n        uint256[] memory orderedIds = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            orderedIds[i] = startId - 2 + i;\n        }\n\n        (uint256 feeX, uint256 feeY) = pair.pendingFees(DEV, orderedIds);\n\n        assertApproxEqAbs(accumulatedYFees, feeY, 1);\n\n        uint256 balanceBefore = token18D.balanceOf(DEV);\n        pair.collectFees(DEV, orderedIds);\n        assertEq(feeY, token18D.balanceOf(DEV) - balanceBefore);\n\n        // Trying to claim a second time\n        balanceBefore = token18D.balanceOf(DEV);\n        (feeX, feeY) = pair.pendingFees(DEV, orderedIds);\n        assertEq(feeY, 0);\n        pair.collectFees(DEV, orderedIds);\n        assertEq(token18D.balanceOf(DEV), balanceBefore);\n    }\n\n    function testClaimFeesX() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountYOutForSwap = 1e18;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 5, 0);\n\n        (uint256 amountXInForSwap, uint256 feesFromGetSwapIn) = router.getSwapIn(pair, amountYOutForSwap, true);\n\n        token6D.mint(address(pair), amountXInForSwap);\n        vm.prank(ALICE);\n        pair.swap(true, DEV);\n\n        (uint256 feesXTotal, , uint256 feesXProtocol, ) = pair.getGlobalFees();\n        assertEq(feesXTotal, feesFromGetSwapIn);\n        uint256 accumulatedXFees = feesXTotal - feesXProtocol;\n\n        uint256[] memory orderedIds = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            orderedIds[i] = startId - 2 + i;\n        }\n\n        (uint256 feeX, uint256 feeY) = pair.pendingFees(DEV, orderedIds);\n\n        assertApproxEqAbs(accumulatedXFees, feeX, 1);\n\n        uint256 balanceBefore = token6D.balanceOf(DEV);\n        pair.collectFees(DEV, orderedIds);\n        assertEq(feeX, token6D.balanceOf(DEV) - balanceBefore);\n\n        // Trying to claim a second time\n        balanceBefore = token6D.balanceOf(DEV);\n        (feeX, feeY) = pair.pendingFees(DEV, orderedIds);\n        assertEq(feeX, 0);\n        pair.collectFees(DEV, orderedIds);\n        assertEq(token6D.balanceOf(DEV), balanceBefore);\n    }\n\n    function testFeesOnTokenTransfer() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountYForSwap = 1e6;\n        uint24 startId = ID_ONE;\n\n        (uint256[] memory _ids, , , ) = addLiquidity(amountYInLiquidity, startId, 5, 0);\n\n        token18D.mint(address(pair), amountYForSwap);\n\n        pair.swap(false, ALICE);\n\n        uint256[] memory amounts = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            amounts[i] = pair.balanceOf(DEV, _ids[i]);\n        }\n\n        pair.safeBatchTransferFrom(DEV, BOB, _ids, amounts);\n\n        token18D.mint(address(pair), amountYForSwap);\n        pair.swap(false, ALICE);\n\n        (uint256 feesForDevX, uint256 feesForDevY) = pair.pendingFees(DEV, _ids);\n        (uint256 feesForBobX, uint256 feesForBobY) = pair.pendingFees(BOB, _ids);\n\n        assertGt(feesForDevY, 0, \"DEV should have fees on token Y\");\n        assertGt(feesForBobY, 0, \"BOB should also have fees on token Y\");\n\n        (, uint256 feesYTotal, , uint256 feesYProtocol) = pair.getGlobalFees();\n\n        uint256 accumulatedYFees = feesYTotal - feesYProtocol;\n\n        assertApproxEqAbs(feesForDevY + feesForBobY, accumulatedYFees, 1, \"Sum of users fees = accumulated fees\");\n\n        uint256 balanceBefore = token18D.balanceOf(DEV);\n        pair.collectFees(DEV, _ids);\n        assertEq(\n            feesForDevY,\n            token18D.balanceOf(DEV) - balanceBefore,\n            \"DEV gets the expected amount when withdrawing fees\"\n        );\n\n        balanceBefore = token18D.balanceOf(BOB);\n        pair.collectFees(BOB, _ids);\n        assertEq(\n            feesForBobY,\n            token18D.balanceOf(BOB) - balanceBefore,\n            \"BOB gets the expected amount when withdrawing fees\"\n        );\n    }\n\n    function testClaimProtocolFees() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint256 amountXOutForSwap = 1e6;\n        uint256 amountYOutForSwap = 1e6;\n        uint24 startId = ID_ONE;\n\n        addLiquidity(amountYInLiquidity, startId, 5, 0);\n\n        (uint256 amountYInForSwap, uint256 feesFromGetSwapIn) = router.getSwapIn(pair, amountXOutForSwap, false);\n\n        token18D.mint(address(pair), amountYInForSwap);\n        vm.prank(ALICE);\n        pair.swap(false, DEV);\n\n        (, uint256 feesYTotal, , uint256 feesYProtocol) = pair.getGlobalFees();\n        assertEq(feesFromGetSwapIn, feesYTotal);\n        assertGt(feesYTotal, 0);\n\n        address protocolFeesReceiver = factory.feeRecipient();\n\n        uint256 balanceBefore = token18D.balanceOf(protocolFeesReceiver);\n        pair.collectProtocolFees();\n        assertEq(token18D.balanceOf(protocolFeesReceiver) - balanceBefore, feesYProtocol - 1);\n\n        // Claiming twice\n\n        pair.collectProtocolFees();\n        assertEq(token18D.balanceOf(protocolFeesReceiver) - balanceBefore, feesYProtocol - 1);\n\n        //Claiming rewards for X\n        (uint256 amountXInForSwap, ) = router.getSwapIn(pair, amountXOutForSwap, true);\n\n        token6D.mint(address(pair), amountXInForSwap);\n        vm.prank(BOB);\n        pair.swap(true, DEV);\n        balanceBefore = token6D.balanceOf(protocolFeesReceiver);\n        pair.collectProtocolFees();\n        assertEq(token6D.balanceOf(protocolFeesReceiver) - balanceBefore, feesYProtocol - 1);\n    }\n\n    function testForceDecay() public {\n        uint256 amountYInLiquidity = 100e18;\n        uint24 startId = ID_ONE;\n\n        FeeHelper.FeeParameters memory _feeParameters = pair.feeParameters();\n        addLiquidity(amountYInLiquidity, startId, 51, 5);\n\n        (uint256 amountYInForSwap, ) = router.getSwapIn(pair, amountYInLiquidity / 4, true);\n        token6D.mint(address(pair), amountYInForSwap);\n        vm.prank(ALICE);\n        pair.swap(true, ALICE);\n\n        vm.warp(block.timestamp + 90);\n\n        (amountYInForSwap, ) = router.getSwapIn(pair, amountYInLiquidity / 4, true);\n        token6D.mint(address(pair), amountYInForSwap);\n        vm.prank(ALICE);\n        pair.swap(true, ALICE);\n\n        _feeParameters = pair.feeParameters();\n        uint256 referenceBeforeForceDecay = _feeParameters.volatilityReference;\n        uint256 referenceAfterForceDecayExpected = (uint256(_feeParameters.reductionFactor) *\n            referenceBeforeForceDecay) / Constants.BASIS_POINT_MAX;\n\n        factory.forceDecay(pair);\n\n        _feeParameters = pair.feeParameters();\n        uint256 referenceAfterForceDecay = _feeParameters.volatilityReference;\n        assertEq(referenceAfterForceDecay, referenceAfterForceDecayExpected);\n    }\n\n    function testClaimFeesComplex(uint256 amountY, uint256 amountX) public {\n        vm.assume(amountY < 10e18);\n        vm.assume(amountY > 0);\n        vm.assume(amountX < 10e18);\n        vm.assume(amountX > 0);\n\n        uint256 amountYInLiquidity = 100e18;\n        uint256 totalFeesFromGetSwapX;\n        uint256 totalFeesFromGetSwapY;\n\n        addLiquidity(amountYInLiquidity, ID_ONE, 5, 0);\n\n        //swap X -> Y and accrue X fees\n        (uint256 amountXInForSwap, uint256 feesXFromGetSwap) = router.getSwapIn(pair, amountY, true);\n        totalFeesFromGetSwapX += feesXFromGetSwap;\n\n        token6D.mint(address(pair), amountXInForSwap);\n        vm.prank(ALICE);\n        pair.swap(true, DEV);\n        (uint256 feesXTotal, , uint256 feesXProtocol, ) = pair.getGlobalFees();\n        assertEq(feesXTotal, totalFeesFromGetSwapX);\n\n        //swap Y -> X and accrue Y fees\n        (uint256 amountYInForSwap, uint256 feesYFromGetSwap) = router.getSwapIn(pair, amountX, false);\n        totalFeesFromGetSwapY += feesYFromGetSwap;\n        token18D.mint(address(pair), amountYInForSwap);\n        vm.prank(ALICE);\n        pair.swap(false, DEV);\n\n        (, uint256 feesYTotal, , uint256 feesYProtocol) = pair.getGlobalFees();\n        assertEq(feesYTotal, totalFeesFromGetSwapY);\n\n        //swap Y -> X and accrue Y fees\n        (, feesYFromGetSwap) = router.getSwapOut(pair, amountY, false);\n        totalFeesFromGetSwapY += feesYFromGetSwap;\n        token18D.mint(address(pair), amountY);\n        vm.prank(ALICE);\n        pair.swap(false, DEV);\n\n        (, feesYTotal, , feesYProtocol) = pair.getGlobalFees();\n        assertEq(feesYTotal, totalFeesFromGetSwapY);\n\n        //swap X -> Y and accrue X fees\n        (, feesXFromGetSwap) = router.getSwapOut(pair, amountX, true);\n        totalFeesFromGetSwapX += feesXFromGetSwap;\n        token6D.mint(address(pair), amountX);\n        vm.prank(ALICE);\n        pair.swap(true, DEV);\n\n        (feesXTotal, , feesXProtocol, ) = pair.getGlobalFees();\n        assertEq(feesXTotal, totalFeesFromGetSwapX);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.7;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinPairTest is TestHelper {\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n        addAllAssetsToQuoteWhitelist(factory);\n        router = new LBRouter(ILBFactory(DEV), IJoeFactory(DEV), IWAVAX(DEV));\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n    }\n\n    function testPendingFeesNotIncreasingReverts() public {\n        uint256[] memory _ids = new uint256[](2);\n        _ids[0] = uint256(ID_ONE);\n        _ids[1] = uint256(ID_ONE) - 1;\n        vm.expectRevert(LBPair__OnlyStrictlyIncreasingId.selector);\n        pair.pendingFees(DEV, _ids);\n    }\n\n    function testMintWrongLengthsReverts() public {\n        uint256[] memory _deltaIds;\n        uint256[] memory _distributionX;\n        uint256[] memory _distributionY;\n        uint256 _numberBins = 0;\n        _deltaIds = new uint256[](_numberBins);\n        _distributionX = new uint256[](_numberBins);\n        _distributionY = new uint256[](_numberBins);\n\n        vm.expectRevert(LBPair__WrongLengths.selector);\n        pair.mint(_deltaIds, _distributionX, _distributionY, DEV);\n        _numberBins = 2;\n        _deltaIds = new uint256[](_numberBins);\n        _distributionX = new uint256[](_numberBins - 1);\n        _distributionY = new uint256[](_numberBins);\n        vm.expectRevert(LBPair__WrongLengths.selector);\n        pair.mint(_deltaIds, _distributionX, _distributionY, DEV);\n        _distributionX = new uint256[](_numberBins);\n        _distributionY = new uint256[](_numberBins - 1);\n        vm.expectRevert(LBPair__WrongLengths.selector);\n        pair.mint(_deltaIds, _distributionX, _distributionY, DEV);\n    }\n\n    function testDistributionOverflowReverts() public {\n        uint256 amount = 10e18;\n        token6D.mint(address(pair), amount);\n        token18D.mint(address(pair), amount);\n        uint256[] memory _deltaIds;\n        uint256[] memory _distributionX;\n        uint256[] memory _distributionY;\n        uint256 _numberBins = 1;\n        _deltaIds = new uint256[](_numberBins);\n        _distributionX = new uint256[](_numberBins);\n        _distributionY = new uint256[](_numberBins);\n        _distributionX[0] = Constants.PRECISION + 1;\n        vm.expectRevert(LBPair__DistributionsOverflow.selector);\n        pair.mint(_deltaIds, _distributionX, _distributionY, DEV);\n\n        _distributionX[0] = 0;\n        _distributionY[0] = Constants.PRECISION + 1;\n        vm.expectRevert(LBPair__DistributionsOverflow.selector);\n        pair.mint(_deltaIds, _distributionX, _distributionY, DEV);\n\n        _numberBins = 2;\n        _deltaIds = new uint256[](_numberBins);\n        _deltaIds[0] = ID_ONE;\n        _deltaIds[1] = ID_ONE + 1;\n        _distributionX = new uint256[](_numberBins);\n        _distributionY = new uint256[](_numberBins);\n        _distributionX[0] = Constants.PRECISION / 2;\n        _distributionX[1] = Constants.PRECISION / 2 + 1;\n        vm.expectRevert(LBPair__DistributionsOverflow.selector);\n        pair.mint(_deltaIds, _distributionX, _distributionY, DEV);\n\n        _distributionX[0] = 0;\n        _distributionX[1] = 0;\n        _distributionY[0] = Constants.PRECISION / 2;\n        _distributionY[1] = Constants.PRECISION / 2 + 1;\n        vm.expectRevert(LBPair__DistributionsOverflow.selector);\n        pair.mint(_deltaIds, _distributionX, _distributionY, DEV);\n    }\n\n    function testInsufficientLiquidityBurnedReverts() public {\n        uint256 _numberBins = 2;\n        uint256[] memory _deltaIds;\n        uint256[] memory _amounts;\n        _deltaIds = new uint256[](_numberBins);\n        _amounts = new uint256[](_numberBins);\n        _deltaIds[0] = ID_ONE;\n        _deltaIds[1] = ID_ONE + 1;\n        _amounts[0] = 0;\n        _amounts[1] = 0;\n        vm.expectRevert(abi.encodeWithSelector(LBPair__InsufficientLiquidityBurned.selector, _deltaIds[0]));\n        pair.burn(_deltaIds, _amounts, DEV);\n    }\n\n    function testCollectingFeesOnlyFeeRecipient() public {\n        vm.prank(ALICE);\n        vm.expectRevert(abi.encodeWithSelector(LBPair__OnlyFeeRecipient.selector, DEV, ALICE));\n        pair.collectProtocolFees();\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./TestHelper.sol\";\n\ncontract LiquidityBinPairFlashLoansTest is TestHelper {\n    FlashBorrower private borrower;\n\n    event CalldataTransmitted();\n\n    function setUp() public {\n        token6D = new ERC20MockDecimals(6);\n        token18D = new ERC20MockDecimals(18);\n\n        factory = new LBFactory(DEV, 8e14);\n        ILBPair _LBPairImplementation = new LBPair(factory);\n        factory.setLBPairImplementation(address(_LBPairImplementation));\n        addAllAssetsToQuoteWhitelist(factory);\n        setDefaultFactoryPresets(DEFAULT_BIN_STEP);\n\n        router = new LBRouter(ILBFactory(DEV), IJoeFactory(DEV), IWAVAX(DEV));\n\n        pair = createLBPairDefaultFees(token6D, token18D);\n\n        borrower = new FlashBorrower(pair);\n    }\n\n    function testFlashloan() public {\n        (uint256[] memory _ids, , , ) = addLiquidity(100e18, ID_ONE, 9, 5);\n        uint256 amountXBorrowed = 10e18;\n        uint256 amountYBorrowed = 10e18;\n\n        // Paying for fees\n        token6D.mint(address(borrower), 1e18);\n        token18D.mint(address(borrower), 1e18);\n\n        vm.expectEmit(false, false, false, false);\n        emit CalldataTransmitted();\n\n        borrower.flashBorrow(amountXBorrowed, amountYBorrowed);\n\n        (uint256 feesForDevX, uint256 feesForDevY) = pair.pendingFees(DEV, _ids);\n        assertGt(feesForDevX, 0, \"DEV should have fees on token X\");\n        assertGt(feesForDevY, 0, \"DEV should have fees on token Y\");\n    }\n\n    function testFailFlashloanMoreThanReserves() public {\n        uint256 amountXBorrowed = 150e18;\n\n        token6D.mint(address(borrower), 1e18);\n\n        borrower.flashBorrow(amountXBorrowed, 0);\n    }\n\n    function testFailFlashlaonWithReentrancy() public {\n        uint256 amountXBorrowed = 150e18;\n\n        token6D.mint(address(borrower), 1e18);\n\n        borrower.flashBorrowWithReentrancy(amountXBorrowed, 0);\n    }\n}\n\n\n",
        "CodeNames": [
            "LBPair.sol",
            "LBPair.Swaps.t.sol",
            "LBPair.Oracle.t.sol",
            "LBPair.Liquidity.t.sol",
            "LBPair.Fees.t.sol",
            "LBPair.t.sol",
            "LBPair.FlashLoans.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LBPair.flashLoan() function in LBPair.sol contract",
                "Type": "Manipulation of flashloan fee collection mechanism",
                "Description": "The flashloan fee collection mechanism in the LBPair.flashLoan() function can be easily manipulated, allowing a user to provide liquidity to an active bin right before a flashloan to receive most of the fees. This trick can be used both by the borrower themselves, or by a third party miner or a node operator frontrunning the flashloan transactions. This is in detriment to the liquidity providers, who would be providing the bulk of the flashloan, but receiving a much less fraction of the fees.",
                "Repair": "Have a separate global fee structure for a given pair, and record token X and token Y fees per share separately. If the ideal remediation cannot be achieved, a compromise would be to distribute the flashloan fees from the -nth populated bin to the +nth populated bin, where n is respective to the active bin. n could be an adjustable market parameter."
            },
            {
                "Location": "LBPair contracts",
                "Type": "Incorrect fee calculation",
                "Description": "LBPair contracts consistently collect less fees than their FeeParameters. The difference between the expected fees and the actual collected fees is referred to as the 'Fee Deficit'. The exponential growth of the Fee Deficit percentage is concerning, considering that the vast majority of the fees collected by LPs and DEXs are during high volatility periods.",
                "Repair": "Use FeeHelper.getFeeAmount instead of FeeHelper.getFeeAmountFrom when there is enough liquidity in a bin for a swap. Fix the condition for when an amountIn overflows the maximum amount available in a bin. Calculate fees on amountIn instead of amountInToBin in LBRouter.getSwapIn. Use SwapHelper.getAmountsV2 and FeeHelper.getAmountInWithFees instead of SwapHelper.getAmounts and FeeHelper.getFeeAmountFrom. "
            },
            {
                "Location": "_beforeTokenTransfer() function in LBPair.sol",
                "Type": "Fee calculation vulnerability",
                "Description": "The vulnerability allows an attacker to steal the entire reserves of the LBPair by exploiting the bug in the _beforeTokenTransfer() function, which skips fee accrual for the LBToken address and 0 address. The attacker can collect fees for the 0 address to overflow the FeesX/FeesY variables, even though the fees are not retrievable for them.",
                "Repair": "Remove the exemption of any address from _cacheFees() function, including address(0)"
            },
            {
                "Location": "LBPair.setFeeParameter function",
                "Type": "Incorrect implementation",
                "Description": "Wrong implementation of function LBPair.setFeeParameter can break the functionality of LBPair and make user's tokens locked. Incorrect fee calculation when executing an action with LBPair (swap, flashLoan, mint).",
                "Repair": "Modify function LBPair._setFeesParameters to include a shift left operation before executing or operation"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function swapAVAXForExactTokens(uint256 _amountOut, uint256[] memory _pairBinSteps, IERC20[] memory _tokenPath, address _to, uint256 _deadline) external payable override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256[] memory amountsIn)",
                "Type": "Arithmetic Underflow",
                "Description": "Calling swapAVAXForExactTokens function while sending excess amount cannot refund such excess amount, which results in an arithmetic underflow and reverts the transaction.",
                "Repair": "Update the code at line 520 to if (msg.value >= amountsIn[0]) _safeTransferAVAX(_to, msg.value - amountsIn[0]);"
            }
        ]
    }
]