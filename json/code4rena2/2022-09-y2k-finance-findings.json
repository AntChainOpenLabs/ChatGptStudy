[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SemiFungibleVault} from \"./SemiFungibleVault.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract Vault is SemiFungibleVault, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error AddressZero();\n    error AddressNotFactory(address _contract);\n    error AddressNotController(address _contract);\n    error MarketEpochDoesNotExist();\n    error EpochAlreadyStarted();\n    error EpochNotFinished();\n    error FeeMoreThan150(uint256 _fee);\n    error ZeroValue();\n    error OwnerDidNotAuthorize(address _sender, address _owner);\n    error EpochEndMustBeAfterBegin();\n    error MarketEpochExists();\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable tokenInsured;\n    address private treasury;\n    int256 public immutable strikePrice;\n    address private immutable factory;\n    address public controller;\n\n    uint256[] public epochs;\n    uint256 public timewindow;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => uint256) public idFinalTVL;\n    mapping(uint256 => uint256) public idClaimTVL;\n    // @audit uint32 for timestamp is enough for the next 80 years\n    mapping(uint256 => uint256) public idEpochBegin;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idDepegged;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idExists;\n    mapping(uint256 => uint256) public epochFee;\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only factory addresses can call functions that use this modifier\n      */\n    modifier onlyFactory() {\n        if(msg.sender != factory)\n            revert AddressNotFactory(msg.sender);\n        _;\n    }\n\n    /** @notice Only controller addresses can call functions that use this modifier\n      */\n    modifier onlyController() {\n        if(msg.sender != controller)\n            revert AddressNotController(msg.sender);\n        _;\n    }\n\n    /** @notice Only market addresses can call functions that use this modifier\n      */\n    modifier marketExists(uint256 id) {\n        if(idExists[id] != true)\n            revert MarketEpochDoesNotExist();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier before the current epoch has started\n      */\n    modifier epochHasNotStarted(uint256 id) {\n        if(block.timestamp > idEpochBegin[id] - timewindow)\n            revert EpochAlreadyStarted();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier after the current epoch has started\n      */\n    modifier epochHasEnded(uint256 id) {\n        if((block.timestamp < id) && idDepegged[id] == false)\n            revert EpochNotFinished();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice constructor\n        @param  _assetAddress    token address representing your asset to be deposited;\n        @param  _name   token name for the ERC1155 mints. Insert the name of your token; Example: Y2K_USDC_1.2$\n        @param  _symbol token symbol for the ERC1155 mints. insert here if risk or hedge + Symbol. Example: HedgeY2K or riskY2K;\n        @param  _token  address of the oracle to lookup the price in chainlink oracles;\n        @param  _strikePrice    uint256 representing the price to trigger the depeg event;\n        @param _controller  address of the controller contract, this contract can trigger the depeg events;\n     */\n    constructor(\n        address _assetAddress,\n        string memory _name,\n        string memory _symbol,\n        address _treasury,\n        address _token,\n        int256 _strikePrice,\n        address _controller\n    ) SemiFungibleVault(ERC20(_assetAddress), _name, _symbol) {\n\n        if(_treasury == address(0))\n            revert AddressZero();\n\n        if(_controller == address(0))\n            revert AddressZero();\n\n        if(_token == address(0))\n            revert AddressZero();\n\n        tokenInsured = _token;\n        treasury = _treasury;\n        strikePrice = _strikePrice;\n        factory = msg.sender;\n        controller = _controller;\n        timewindow = 1 days;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Deposit function from ERC4626, with payment of a fee to a treasury implemented;\n        @param  id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param  assets  uint256 representing how many assets the user wants to deposit, a fee will be taken from this value;\n        @param receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n        @return shares how many assets the owner is entitled to, removing the fee from it's shares;\n     */\n    function deposit(\n        uint256 id,\n        uint256 assets,\n        address receiver\n    )\n        public\n        override\n        marketExists(id)\n        epochHasNotStarted(id)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(id, assets)) != 0, \"ZeroValue\");\n\n        asset.transferFrom(msg.sender, address(this), shares);\n\n        _mint(receiver, id, shares, EMPTY);\n\n        emit Deposit(msg.sender, receiver, id, shares, shares);\n\n        return shares;\n    }\n\n    /**\n        @notice Deposit ETH function\n        @param  id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n        @return shares how many assets the owner is entitled to, removing the fee from its shares;\n     */\n    function depositETH(uint256 id, address receiver)\n        external\n        payable\n        returns (uint256 shares)\n    {\n        require(msg.value > 0, \"ZeroValue\");\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n        assert(IWETH(address(asset)).transfer(msg.sender, msg.value));\n\n        return deposit(id, msg.value, receiver);\n    }\n\n    /**\n    @notice Withdraw entitled deposited assets, checking if a depeg event //TODO add GOV token rewards\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n    @param assets   uint256 of how many assets you want to withdraw, this value will be used to calculate how many assets you are entitle to according to the events;\n    @param receiver  Address of the receiver of the assets provided by this function, that represent the ownership of the transfered asset;\n    @param owner    Address of the owner of these said assets;\n    @return shares How many shares the owner is entitled to, according to the conditions;\n     */\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        uint256 entitledShares = beforeWithdraw(id, shares);\n        _burn(owner, id, shares);\n\n        //Taking fee from the amount\n        uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);\n        entitledShares = entitledShares - feeValue;\n        asset.transfer(treasury, feeValue);\n\n        emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n        asset.transfer(receiver, entitledShares);\n\n        return entitledShares;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice returns total assets for the id of given epoch\n        @param  _id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n     */\n    function totalAssets(uint256 _id)\n        public\n        view\n        override\n        marketExists(_id)\n        returns (uint256)\n    {\n        return totalSupply(_id);\n    }\n\n    /**\n    @notice Calculates how much ether the %fee is taking from @param amount\n    @param amount Amount to withdraw from vault\n    @param _epoch Target epoch\n    @return feeValue Current fee value\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 _epoch)\n        public\n        view\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 1000 then divide by 5\n        return (amount * epochFee[_epoch]) / 1000;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           Factory FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Factory function, changes treasury address\n    @param _treasury New treasury address\n     */\n    function changeTreasury(address _treasury) public onlyFactory {\n        if(_treasury == address(0))\n            revert AddressZero();\n        treasury = _treasury;\n    }\n\n    /**\n    @notice Factory function, changes vault time window\n    @param _timewindow New vault time window\n     */\n    function changeTimewindow(uint256 _timewindow) public onlyFactory {\n        timewindow = _timewindow;\n    }\n\n    /**\n    @notice Factory function, changes controller address\n    @param _controller New controller address\n     */\n    function changeController(address _controller) public onlyFactory {\n        if(_controller == address(0))\n            revert AddressZero();\n        controller = _controller;\n    }\n\n    /**\n    @notice Function to deploy hedge assets for given epochs, after the creation of this vault\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function createAssets(uint256 epochBegin, uint256 epochEnd, uint256 _withdrawalFee)\n        public\n        onlyFactory\n    {\n        if(_withdrawalFee > 150)\n            revert FeeMoreThan150(_withdrawalFee);\n\n        if(idExists[epochEnd] == true)\n            revert MarketEpochExists();\n        \n        if(epochBegin >= epochEnd)\n            revert EpochEndMustBeAfterBegin();\n\n        idExists[epochEnd] = true;\n        idEpochBegin[epochEnd] = epochBegin;\n        epochs.push(epochEnd);\n\n        epochFee[epochEnd] = _withdrawalFee;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Controller can call this function to trigger the end of the epoch, storing the TVL of that epoch and if a depeg event occurred\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param depeg Boolean value indicating if the depeg event occurred, or not. Example: If depeg occurred depeg = true\n     */\n    function endEpoch(uint256 id, bool depeg)\n        public\n        onlyController\n        marketExists(id)\n    {\n        idDepegged[id] = depeg;\n        idFinalTVL[id] = totalAssets(id);\n    }\n\n    /**\n    @notice Function to be called after endEpoch, by the Controller only, this function stores the TVL of the counterparty vault in a mapping to be used for later calculations of the entitled withdraw\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param claimTVL uint256 representing the TVL the counterparty vault has, storing this value in a mapping\n     */\n    function setClaimTVL(uint256 id, uint256 claimTVL) public onlyController {\n        idClaimTVL[id] = claimTVL;\n    }\n\n    /**\n    solhint-disable-next-line max-line-length\n    @notice Function to be called after endEpoch and setClaimTVL functions, respecting the calls in order, after storing the TVL of the end of epoch and the TVL amount to claim, this function will allow the transfer of tokens to the counterparty vault\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param _counterparty Address of the other vault, meaning address of the risk vault, if this is an hedge vault, and vice-versa\n    */\n    function sendTokens(uint256 id, address _counterparty)\n        public\n        onlyController\n        marketExists(id)\n    {\n        asset.transfer(_counterparty, idFinalTVL[id]);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Calculations of how much the user will receive;\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param amount uint256 of the amount the user wants to withdraw\n    @return entitledAmount How much amount the user will receive, according to the conditions\n    */\n    function beforeWithdraw(uint256 id, uint256 amount)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        // in case the risk wins aka no depeg event\n        // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)\n        // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool\n        // in case there is a depeg event, the risk users can only withdraw the hedge\n        if (\n            keccak256(abi.encodePacked(symbol)) ==\n            keccak256(abi.encodePacked(\"rY2K\"))\n        ) {\n            if (!idDepegged[id]) {\n                //depeg event did not happen\n                /*\n                entitledAmount =\n                    (amount / idFinalTVL[id]) *\n                    idClaimTVL[id] +\n                    amount;\n                */\n                entitledAmount =\n                    amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                        idClaimTVL[id],\n                        1 ether\n                    ) +\n                    amount;\n            } else {\n                //depeg event did happen\n                entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                    idClaimTVL[id],\n                    1 ether\n                );\n            }\n        }\n        // in case the hedge wins aka depegging\n        // hedge users pay the hedge to risk users anyway,\n        // hedge guy can withdraw risk (that is transfered from the risk pool),\n        // withdraw = % tvl that hedge buyer owns\n        // otherwise hedge users cannot withdraw any Eth\n        else {\n            entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                idClaimTVL[id],\n                1 ether\n            );\n        }\n\n        return entitledAmount;\n    }\n    \n    /** @notice Lookup total epochs length\n      */\n    function epochsLength() public view returns (uint256) {\n        return epochs.length;\n    }\n\n    /** @notice Lookup next epochs' end from target\n        @param _epoch Target epoch\n        @return nextEpochEnd Next epoch end\n      */\n    function getNextEpoch(uint256 _epoch)\n        public\n        view\n        returns (uint256 nextEpochEnd)\n    {\n        for (uint256 i = 0; i < epochsLength(); i++) {\n            if (epochs[i] == _epoch) {\n                if (i == epochsLength() - 1) {\n                    return 0;\n                }\n                return epochs[i + 1];\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Vault contract and Controller contract",
                "Type": "Possible loss of user funds",
                "Description": "Users who deposit in one vault can lose all deposits and receive nothing when counterparty vault has no deposits",
                "Repair": "Allow users to withdraw their full deposit amounts if they have deposited in only one vault and no one has deposited in the counterparty vault"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Vault} from \"./Vault.sol\";\n\ninterface IController {\n    function getVaultFactory() external view returns (address);\n}\n\ncontract VaultFactory {\n    // solhint-disable var-name-mixedcase\n    address public immutable Admin;\n    address public immutable WETH;\n    // solhint-enable var-name-mixedcase\n    address public treasury;\n    address public controller;\n    uint256 public marketIndex;\n\n    struct MarketVault{\n        uint256 index;\n        uint256 epochBegin;\n        uint256 epochEnd;\n        Vault hedge;\n        Vault risk;\n        uint256 withdrawalFee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error MarketDoesNotExist(uint256 marketIndex);\n    error AddressNotAdmin(address addr);\n    error AddressZero();\n    error AddressNotController();\n    error AddressFactoryNotInController();\n    error ControllerNotSet();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Market is created when event is emitted\n      * @param mIndex Current market index\n      * @param hedge Hedge vault address\n      * @param risk Risk vault address\n      * @param token Token address\n      * @param name Market name\n      */ \n    event MarketCreated(\n        uint256 indexed mIndex,\n        address hedge,\n        address risk,\n        address token,\n        string name,\n        int256 strikePrice\n    );\n\n    /** @notice Epoch is created when event is emitted\n      * @param marketEpochId Current market epoch id\n      * @param mIndex Current market index\n      * @param startEpoch Epoch start time\n      * @param endEpoch Epoch end time\n      * @param hedge Hedge vault address\n      * @param risk Risk vault address\n      * @param token Token address\n      * @param name Market name\n      * @param strikePrice Vault strike price\n      */\n    event EpochCreated(\n        bytes32 indexed marketEpochId,\n        uint256 indexed mIndex,\n        uint256 startEpoch,\n        uint256 endEpoch,\n        address hedge,\n        address risk,\n        address token,\n        string name,\n        int256 strikePrice,\n        uint256 withdrawalFee\n    );\n\n    /** @notice Controller is set when event is emitted\n      * @param newController Address for new controller\n      */ \n    event controllerSet(address indexed newController);\n\n    /** @notice Treasury is changed when event is emitted\n      * @param _treasury Treasury address\n      * @param _marketIndex Target market index\n      */ \n    event changedTreasury(address _treasury, uint256 indexed _marketIndex);\n\n    /** @notice Vault fee is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param _feeRate Target fee rate\n      */ \n    event changedVaultFee(uint256 indexed _marketIndex, uint256 _feeRate);\n\n    /** @notice Vault time window is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param _timeWindow Target time window\n      */ \n    event changedTimeWindow(uint256 indexed _marketIndex, uint256 _timeWindow);\n    \n    /** @notice Controller is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param controller Target controller address\n      */ \n    event changedController(\n        uint256 indexed _marketIndex,\n        address indexed controller\n    );\n    event changedOracle(address indexed _token, address _oracle);\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address[]) public indexVaults; //[0] hedge and [1] risk vault\n    mapping(uint256 => uint256[]) public indexEpochs; //all epochs in the market\n    mapping(address => address) public tokenToOracle; //token address to respective oracle smart contract address\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != Admin)\n            revert AddressNotAdmin(msg.sender);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _treasury Treasury address\n      * @param _weth Wrapped Ether token address\n      * @param _admin Admin address\n      */ \n    constructor(\n        address _treasury,\n        address _weth,\n        address _admin\n    ) {\n        if(_admin == address(0))\n            revert AddressZero();\n        if(_weth == address(0))\n            revert AddressZero();\n\n        if(_treasury == address(0))\n            revert AddressZero();\n\n        Admin = _admin;\n        WETH = _weth;\n        marketIndex = 0;\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function to create two new vaults, hedge and risk, with the respective params, and storing the oracle for the token provided\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n    @param _token Address of the oracle to lookup the price in chainlink oracles\n    @param _strikePrice uint256 representing the price to trigger the depeg event, needs to be 18 decimals\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param  _oracle Address representing the smart contract to lookup the price of the given _token param\n    @return insr    Address of the deployed hedge vault\n    @return rsk     Address of the deployed risk vault\n     */\n    function createNewMarket(\n        uint256 _withdrawalFee,\n        address _token,\n        int256 _strikePrice,\n        uint256 epochBegin,\n        uint256 epochEnd,\n        address _oracle,\n        string memory _name\n    ) public onlyAdmin returns (address insr, address rsk) {\n        if(\n            IController(controller).getVaultFactory() != address(this)\n            )\n            revert AddressFactoryNotInController();\n\n        if(controller == address(0))\n            revert ControllerNotSet();\n\n        marketIndex += 1;\n\n        //y2kUSDC_99*RISK or y2kUSDC_99*HEDGE\n\n        Vault hedge = new Vault(\n            WETH,\n            string(abi.encodePacked(_name,\"HEDGE\")),\n            \"hY2K\",\n            treasury,\n            _token,\n            _strikePrice,\n            controller\n        );\n\n        Vault risk = new Vault(\n            WETH,\n            string(abi.encodePacked(_name,\"RISK\")),\n            \"rY2K\",\n            treasury,\n            _token,\n            _strikePrice,\n            controller\n        );\n\n        indexVaults[marketIndex] = [address(hedge), address(risk)];\n\n        if (tokenToOracle[_token] == address(0)) {\n            tokenToOracle[_token] = _oracle;\n        }\n\n        emit MarketCreated(\n            marketIndex,\n            address(hedge),\n            address(risk),\n            _token,\n            _name,\n            _strikePrice\n        );\n\n        MarketVault memory marketVault = MarketVault(marketIndex, epochBegin, epochEnd, hedge, risk, _withdrawalFee);\n\n        _createEpoch(marketVault);\n\n        return (address(hedge), address(risk));\n    }\n\n    /**    \n    @notice Function to deploy hedge assets for given epochs, after the creation of this vault, where the Index is the date of the end of epoch\n    @param  index uint256 of the market index to create more assets in\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function deployMoreAssets(\n        uint256 index,\n        uint256 epochBegin,\n        uint256 epochEnd,\n        uint256 _withdrawalFee\n    ) public onlyAdmin {\n        if(controller == address(0))\n            revert ControllerNotSet();\n\n        if (index > marketIndex) {\n            revert MarketDoesNotExist(index);\n        }\n        address hedge = indexVaults[index][0];\n        address risk = indexVaults[index][1];\n\n        MarketVault memory marketVault = MarketVault(index, epochBegin, epochEnd, Vault(hedge), Vault(risk), _withdrawalFee);\n\n        _createEpoch(marketVault);\n    }\n\n    function _createEpoch(\n        MarketVault memory _marketVault\n    ) internal {\n        \n        _marketVault.hedge.createAssets(_marketVault.epochBegin, _marketVault.epochEnd, _marketVault.withdrawalFee);\n        _marketVault.risk.createAssets(_marketVault.epochBegin, _marketVault.epochEnd, _marketVault.withdrawalFee);\n\n        indexEpochs[_marketVault.index].push(_marketVault.epochEnd);\n\n        emit EpochCreated(\n            keccak256(abi.encodePacked(_marketVault.index, _marketVault.epochBegin, _marketVault.epochEnd)),\n            _marketVault.index,\n            _marketVault.epochBegin,\n            _marketVault.epochEnd,\n            address(_marketVault.hedge),\n            address(_marketVault.risk),\n            _marketVault.hedge.tokenInsured(),\n            _marketVault.hedge.name(),\n            _marketVault.hedge.strikePrice(),\n            _marketVault.withdrawalFee\n        );\n    }\n\n    /**\n    @notice Admin function, sets the controller address\n    @param  _controller Address of the controller smart contract\n     */\n    function setController(address _controller) public onlyAdmin {\n        if(_controller == address(0))\n            revert AddressZero();\n        controller = _controller;\n\n        emit controllerSet(_controller);\n    }\n\n    /**\n    @notice Admin function, changes the assigned treasury address\n    @param _treasury Treasury address\n    @param  _marketIndex Target market index\n     */\n    function changeTreasury(address _treasury, uint256 _marketIndex)\n        public\n        onlyAdmin\n    {\n        treasury = _treasury;\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeTreasury(_treasury);\n        risk.changeTreasury(_treasury);\n\n        emit changedTreasury(_treasury, _marketIndex);\n    }\n\n    /**\n    @notice Admin function, changes vault time window\n    @param _marketIndex Target market index\n    @param  _timewindow New time window\n     */\n    function changeTimewindow(uint256 _marketIndex, uint256 _timewindow)\n        public\n        onlyAdmin\n    {\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeTimewindow(_timewindow);\n        risk.changeTimewindow(_timewindow);\n\n        emit changedTimeWindow(_marketIndex, _timewindow);\n    }\n\n    /**\n    @notice Admin function, changes controller address\n    @param _marketIndex Target market index\n    @param  _controller Address of the controller smart contract\n     */\n    function changeController(uint256 _marketIndex, address _controller)\n        public\n        onlyAdmin\n    {\n        if(_controller == address(0))\n            revert AddressZero();\n\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeController(_controller);\n        risk.changeController(_controller);\n\n        emit changedController(_marketIndex, _controller);\n    }\n\n    /**\n    @notice Admin function, changes oracle address for a given token\n    @param _token Target token address\n    @param  _oracle Oracle address\n     */\n    function changeOracle(address _token, address _oracle) public onlyAdmin {\n        if(_oracle == address(0))\n            revert AddressZero();\n        if(_token == address(0))\n            revert AddressZero();\n            \n        tokenToOracle[_token] = _oracle;\n        emit changedOracle(_token, _oracle);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function the retrieve the addresses of the hedge and risk vaults, in an array, in the respective order\n    @param index uint256 of the market index which to the vaults are associated to\n    @return vaults Address array of two vaults addresses, [0] being the hedge vault, [1] being the risk vault\n     */\n    function getVaults(uint256 index)\n        public\n        view\n        returns (address[] memory vaults)\n    {\n        return indexVaults[index];\n    }\n}\n\n\n",
        "CodeNames": [
            "VaultFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaultFactory contract",
                "Type": "Change of control vulnerability",
                "Description": "It's possible to change for Vault and lost control on it",
                "Repair": "Verify that the incoming Controller's VaultFactory address is the same as the VaultFactory's address itself"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\n\ncontract PegOracle {\n    /***\n    @dev  for example: oracle1 would be stETH / USD, while oracle2 would be ETH / USD oracle\n    ***/\n    address public oracle1;\n    address public oracle2;\n\n    uint8 public decimals;\n\n    AggregatorV3Interface internal priceFeed1;\n    AggregatorV3Interface internal priceFeed2;\n\n    /** @notice Contract constructor\n      * @param _oracle1 First oracle address\n      * @param _oracle2 Second oracle address\n      */\n    constructor(address _oracle1, address _oracle2) {\n        require(_oracle1 != address(0), \"oracle1 cannot be the zero address\");\n        require(_oracle2 != address(0), \"oracle2 cannot be the zero address\");\n        require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n        priceFeed1 = AggregatorV3Interface(_oracle1);\n        priceFeed2 = AggregatorV3Interface(_oracle2);\n        require(\n            (priceFeed1.decimals() == priceFeed2.decimals()),\n            \"Decimals must be the same\"\n        );\n\n        oracle1 = _oracle1;\n        oracle2 = _oracle2;\n\n        decimals = priceFeed1.decimals();\n    }\n\n    /** @notice Returns oracle-fed data from the latest round\n      * @return roundID Current round id \n      * @return nowPrice Current price\n      * @return startedAt Starting timestamp\n      * @return timeStamp Current timestamp\n      * @return answeredInRound Round id for which answer was computed \n      */ \n    function latestRoundData()\n        public\n        view\n        returns (\n            uint80 roundID,\n            int256 nowPrice,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        )\n    {\n        (\n            uint80 roundID1,\n            int256 price1,\n            uint256 startedAt1,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        int256 price2 = getOracle2_Price();\n\n        if (price1 > price2) {\n            nowPrice = (price2 * 10000) / price1;\n        } else {\n            nowPrice = (price1 * 10000) / price2;\n        }\n\n        int256 decimals10 = int256(10**(18 - priceFeed1.decimals()));\n        nowPrice = nowPrice * decimals10;\n\n        return (\n            roundID1,\n            nowPrice / 1000000,\n            startedAt1,\n            timeStamp1,\n            answeredInRound1\n        );\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup first oracle price\n      * @return price Current first oracle price\n      */ \n    function getOracle1_Price() public view returns (int256 price) {\n        (\n            uint80 roundID1,\n            int256 price1,\n            ,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        require(price1 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound1 >= roundID1,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp1 != 0, \"Timestamp == 0 !\");\n\n        return price1;\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup second oracle price\n      * @return price Current second oracle price\n      */ \n    function getOracle2_Price() public view returns (int256 price) {\n        (\n            uint80 roundID2,\n            int256 price2,\n            ,\n            uint256 timeStamp2,\n            uint80 answeredInRound2\n        ) = priceFeed2.latestRoundData();\n\n        require(price2 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound2 >= roundID2,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp2 != 0, \"Timestamp == 0 !\");\n\n        return price2;\n    }\n}\n\n\n",
        "CodeNames": [
            "PegOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PegOracle",
                "Type": "design flaw",
                "Description": "A design flaw in the case of using 2 oracles (aka PegOracle) where PegOracle treats both assets symmetrically.",
                "Repair": "Support markets only for assets that have access to an oracle with price against canonical value x/ETH or x/USD."
            },
            {
                "Location": "PegOracle.sol#L46-L83",
                "Type": "Incorrect handling of pricefeed decimals",
                "Description": "The code only works for pricefeeds of 8 decimals, any others give wrong/incorrect data.",
                "Repair": "Change the math used to handle pricefeed decimals to return correct results for all decimals"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeTransferLib} from \"@solmate/utils/SafeTransferLib.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n// Inheritance\nimport {IStakingRewards} from \"./IStakingRewards.sol\";\nimport {RewardsDistributionRecipient} from \"./RewardsDistributionRecipient.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {\n    ERC1155Holder\n} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Owned.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\ncontract StakingRewards is\n    IStakingRewards,\n    RewardsDistributionRecipient,\n    ReentrancyGuard,\n    Pausable,\n    ERC1155Holder\n{\n    using SafeMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    ERC20 public immutable rewardsToken;\n    IERC1155 public immutable stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate;\n    uint256 public rewardsDuration;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public id;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 id, uint256 amount);\n    event Withdrawn(address indexed user, uint256 id, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        uint256 _epochEnd,\n        uint256 _rewardsDuration,\n        uint256 _rewardRate\n    ) Owned(_owner) {\n        rewardsToken = ERC20(_rewardsToken);\n        stakingToken = IERC1155(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        id = _epochEnd;\n        rewardsDuration = _rewardsDuration;\n        rewardRate = _rewardRate;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount != 0, \"Cannot stake 0\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            amount,\n            \"\"\n        );\n        emit Staked(msg.sender, id, amount);\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        emit Withdrawn(msg.sender, id, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(_totalSupply)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardsDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance.div(rewardsDuration),\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n}\n\n\n",
        "CodeNames": [
            "StakingRewards.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StakingRewards.recoverERC20()",
                "Type": "admin privilege",
                "Description": "StakingRewards: recoverERC20() can be used as a backdoor by the owner to retrieve rewardsToken.",
                "Repair": "Add an additional check to require that the rewardsToken cannot be withdrawn."
            },
            {
                "Location": "StakingRewards.sol#notifyRewardAmount()",
                "Type": "Improper reward balance checks",
                "Description": "Improper reward balance checks can make some users unable to withdraw their rewards",
                "Repair": "Consider changing the function notifyRewardAmount to addRward and use transferFrom to transfer rewardsToken into the contract"
            },
            {
                "Location": "StakingRewards contract",
                "Type": "Dilution of reward rate",
                "Description": "StakingRewards reward rate can be dragged out and diluted",
                "Repair": "Consider not extending the reward payouts by rewardsDuration on every call"
            },
            {
                "Location": "StakingRewards.sol#stake",
                "Type": "Staking unable to be paused",
                "Description": "StakingRewards.sol inherits pausable and implements the whenNotPaused modifier on stake, but doesn't implement any method to actually pause or unpause the contract.",
                "Repair": "Create simple external pause and unpause functions that can be called by owner"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SemiFungibleVault} from \"./SemiFungibleVault.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract Vault is SemiFungibleVault, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error AddressZero();\n    error AddressNotFactory(address _contract);\n    error AddressNotController(address _contract);\n    error MarketEpochDoesNotExist();\n    error EpochAlreadyStarted();\n    error EpochNotFinished();\n    error FeeMoreThan150(uint256 _fee);\n    error ZeroValue();\n    error OwnerDidNotAuthorize(address _sender, address _owner);\n    error EpochEndMustBeAfterBegin();\n    error MarketEpochExists();\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable tokenInsured;\n    address private treasury;\n    int256 public immutable strikePrice;\n    address private immutable factory;\n    address public controller;\n\n    uint256[] public epochs;\n    uint256 public timewindow;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => uint256) public idFinalTVL;\n    mapping(uint256 => uint256) public idClaimTVL;\n    // @audit uint32 for timestamp is enough for the next 80 years\n    mapping(uint256 => uint256) public idEpochBegin;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idDepegged;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idExists;\n    mapping(uint256 => uint256) public epochFee;\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only factory addresses can call functions that use this modifier\n      */\n    modifier onlyFactory() {\n        if(msg.sender != factory)\n            revert AddressNotFactory(msg.sender);\n        _;\n    }\n\n    /** @notice Only controller addresses can call functions that use this modifier\n      */\n    modifier onlyController() {\n        if(msg.sender != controller)\n            revert AddressNotController(msg.sender);\n        _;\n    }\n\n    /** @notice Only market addresses can call functions that use this modifier\n      */\n    modifier marketExists(uint256 id) {\n        if(idExists[id] != true)\n            revert MarketEpochDoesNotExist();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier before the current epoch has started\n      */\n    modifier epochHasNotStarted(uint256 id) {\n        if(block.timestamp > idEpochBegin[id] - timewindow)\n            revert EpochAlreadyStarted();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier after the current epoch has started\n      */\n    modifier epochHasEnded(uint256 id) {\n        if((block.timestamp < id) && idDepegged[id] == false)\n            revert EpochNotFinished();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice constructor\n        @param  _assetAddress    token address representing your asset to be deposited;\n        @param  _name   token name for the ERC1155 mints. Insert the name of your token; Example: Y2K_USDC_1.2$\n        @param  _symbol token symbol for the ERC1155 mints. insert here if risk or hedge + Symbol. Example: HedgeY2K or riskY2K;\n        @param  _token  address of the oracle to lookup the price in chainlink oracles;\n        @param  _strikePrice    uint256 representing the price to trigger the depeg event;\n        @param _controller  address of the controller contract, this contract can trigger the depeg events;\n     */\n    constructor(\n        address _assetAddress,\n        string memory _name,\n        string memory _symbol,\n        address _treasury,\n        address _token,\n        int256 _strikePrice,\n        address _controller\n    ) SemiFungibleVault(ERC20(_assetAddress), _name, _symbol) {\n\n        if(_treasury == address(0))\n            revert AddressZero();\n\n        if(_controller == address(0))\n            revert AddressZero();\n\n        if(_token == address(0))\n            revert AddressZero();\n\n        tokenInsured = _token;\n        treasury = _treasury;\n        strikePrice = _strikePrice;\n        factory = msg.sender;\n        controller = _controller;\n        timewindow = 1 days;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Deposit function from ERC4626, with payment of a fee to a treasury implemented;\n        @param  id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param  assets  uint256 representing how many assets the user wants to deposit, a fee will be taken from this value;\n        @param receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n        @return shares how many assets the owner is entitled to, removing the fee from it's shares;\n     */\n    function deposit(\n        uint256 id,\n        uint256 assets,\n        address receiver\n    )\n        public\n        override\n        marketExists(id)\n        epochHasNotStarted(id)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(id, assets)) != 0, \"ZeroValue\");\n\n        asset.transferFrom(msg.sender, address(this), shares);\n\n        _mint(receiver, id, shares, EMPTY);\n\n        emit Deposit(msg.sender, receiver, id, shares, shares);\n\n        return shares;\n    }\n\n    /**\n        @notice Deposit ETH function\n        @param  id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n        @return shares how many assets the owner is entitled to, removing the fee from its shares;\n     */\n    function depositETH(uint256 id, address receiver)\n        external\n        payable\n        returns (uint256 shares)\n    {\n        require(msg.value > 0, \"ZeroValue\");\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n        assert(IWETH(address(asset)).transfer(msg.sender, msg.value));\n\n        return deposit(id, msg.value, receiver);\n    }\n\n    /**\n    @notice Withdraw entitled deposited assets, checking if a depeg event //TODO add GOV token rewards\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n    @param assets   uint256 of how many assets you want to withdraw, this value will be used to calculate how many assets you are entitle to according to the events;\n    @param receiver  Address of the receiver of the assets provided by this function, that represent the ownership of the transfered asset;\n    @param owner    Address of the owner of these said assets;\n    @return shares How many shares the owner is entitled to, according to the conditions;\n     */\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        uint256 entitledShares = beforeWithdraw(id, shares);\n        _burn(owner, id, shares);\n\n        //Taking fee from the amount\n        uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);\n        entitledShares = entitledShares - feeValue;\n        asset.transfer(treasury, feeValue);\n\n        emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n        asset.transfer(receiver, entitledShares);\n\n        return entitledShares;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice returns total assets for the id of given epoch\n        @param  _id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n     */\n    function totalAssets(uint256 _id)\n        public\n        view\n        override\n        marketExists(_id)\n        returns (uint256)\n    {\n        return totalSupply(_id);\n    }\n\n    /**\n    @notice Calculates how much ether the %fee is taking from @param amount\n    @param amount Amount to withdraw from vault\n    @param _epoch Target epoch\n    @return feeValue Current fee value\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 _epoch)\n        public\n        view\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 1000 then divide by 5\n        return (amount * epochFee[_epoch]) / 1000;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           Factory FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Factory function, changes treasury address\n    @param _treasury New treasury address\n     */\n    function changeTreasury(address _treasury) public onlyFactory {\n        if(_treasury == address(0))\n            revert AddressZero();\n        treasury = _treasury;\n    }\n\n    /**\n    @notice Factory function, changes vault time window\n    @param _timewindow New vault time window\n     */\n    function changeTimewindow(uint256 _timewindow) public onlyFactory {\n        timewindow = _timewindow;\n    }\n\n    /**\n    @notice Factory function, changes controller address\n    @param _controller New controller address\n     */\n    function changeController(address _controller) public onlyFactory {\n        if(_controller == address(0))\n            revert AddressZero();\n        controller = _controller;\n    }\n\n    /**\n    @notice Function to deploy hedge assets for given epochs, after the creation of this vault\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function createAssets(uint256 epochBegin, uint256 epochEnd, uint256 _withdrawalFee)\n        public\n        onlyFactory\n    {\n        if(_withdrawalFee > 150)\n            revert FeeMoreThan150(_withdrawalFee);\n\n        if(idExists[epochEnd] == true)\n            revert MarketEpochExists();\n        \n        if(epochBegin >= epochEnd)\n            revert EpochEndMustBeAfterBegin();\n\n        idExists[epochEnd] = true;\n        idEpochBegin[epochEnd] = epochBegin;\n        epochs.push(epochEnd);\n\n        epochFee[epochEnd] = _withdrawalFee;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Controller can call this function to trigger the end of the epoch, storing the TVL of that epoch and if a depeg event occurred\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param depeg Boolean value indicating if the depeg event occurred, or not. Example: If depeg occurred depeg = true\n     */\n    function endEpoch(uint256 id, bool depeg)\n        public\n        onlyController\n        marketExists(id)\n    {\n        idDepegged[id] = depeg;\n        idFinalTVL[id] = totalAssets(id);\n    }\n\n    /**\n    @notice Function to be called after endEpoch, by the Controller only, this function stores the TVL of the counterparty vault in a mapping to be used for later calculations of the entitled withdraw\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param claimTVL uint256 representing the TVL the counterparty vault has, storing this value in a mapping\n     */\n    function setClaimTVL(uint256 id, uint256 claimTVL) public onlyController {\n        idClaimTVL[id] = claimTVL;\n    }\n\n    /**\n    solhint-disable-next-line max-line-length\n    @notice Function to be called after endEpoch and setClaimTVL functions, respecting the calls in order, after storing the TVL of the end of epoch and the TVL amount to claim, this function will allow the transfer of tokens to the counterparty vault\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param _counterparty Address of the other vault, meaning address of the risk vault, if this is an hedge vault, and vice-versa\n    */\n    function sendTokens(uint256 id, address _counterparty)\n        public\n        onlyController\n        marketExists(id)\n    {\n        asset.transfer(_counterparty, idFinalTVL[id]);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Calculations of how much the user will receive;\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param amount uint256 of the amount the user wants to withdraw\n    @return entitledAmount How much amount the user will receive, according to the conditions\n    */\n    function beforeWithdraw(uint256 id, uint256 amount)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        // in case the risk wins aka no depeg event\n        // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)\n        // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool\n        // in case there is a depeg event, the risk users can only withdraw the hedge\n        if (\n            keccak256(abi.encodePacked(symbol)) ==\n            keccak256(abi.encodePacked(\"rY2K\"))\n        ) {\n            if (!idDepegged[id]) {\n                //depeg event did not happen\n                /*\n                entitledAmount =\n                    (amount / idFinalTVL[id]) *\n                    idClaimTVL[id] +\n                    amount;\n                */\n                entitledAmount =\n                    amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                        idClaimTVL[id],\n                        1 ether\n                    ) +\n                    amount;\n            } else {\n                //depeg event did happen\n                entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                    idClaimTVL[id],\n                    1 ether\n                );\n            }\n        }\n        // in case the hedge wins aka depegging\n        // hedge users pay the hedge to risk users anyway,\n        // hedge guy can withdraw risk (that is transfered from the risk pool),\n        // withdraw = % tvl that hedge buyer owns\n        // otherwise hedge users cannot withdraw any Eth\n        else {\n            entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                idClaimTVL[id],\n                1 ether\n            );\n        }\n\n        return entitledAmount;\n    }\n    \n    /** @notice Lookup total epochs length\n      */\n    function epochsLength() public view returns (uint256) {\n        return epochs.length;\n    }\n\n    /** @notice Lookup next epochs' end from target\n        @param _epoch Target epoch\n        @return nextEpochEnd Next epoch end\n      */\n    function getNextEpoch(uint256 _epoch)\n        public\n        view\n        returns (uint256 nextEpochEnd)\n    {\n        for (uint256 i = 0; i < epochsLength(); i++) {\n            if (epochs[i] == _epoch) {\n                if (i == epochsLength() - 1) {\n                    return 0;\n                }\n                return epochs[i + 1];\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Vault.sol",
                "Type": "non-compliant implementation",
                "Description": "Vault.sol is not EIP-4626 compliant and can cause integration problems in the future that can lead to a wide range of issues for both parties.",
                "Repair": "Modify all functions listed to meet the specifications of EIP-4626."
            },
            {
                "Location": "Vault contract",
                "Type": "Inability to withdraw funds before epoch start time",
                "Description": "Users funds lost because they can't withdraw() their funds before epoch startTime and they are stuck in positions that become unprofitable even when epoch is not started",
                "Repair": "Add some logic to give users the ability to withdraw funds before epoch start time"
            },
            {
                "Location": "Vault contract",
                "Type": "Fees taken on risk collateral",
                "Description": "Fees are taken on risk collateral",
                "Repair": "Fee calculations should be restructured to only take fees on premiums and insurance payouts"
            },
            {
                "Location": "Vault.sol",
                "Type": "Smart contract logic",
                "Description": "The timewindow can be changed unexpectedly, blocking users from calling the deposit function.",
                "Repair": "Update the epochHasNotStarted modifier to check if block.timestamp is less than or equal to idEpochBegin[id] instead of idEpochBegin[id] timewindow"
            },
            {
                "Location": "Vault.sol",
                "Type": "Smart contract logic",
                "Description": "It is possible that receiver and treasury can receive nothing when calling the withdraw function due to division being performed before multiplication.",
                "Repair": "Update the beforeWithdraw function to use multiplication before division instead of division before multiplication"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function changeController()",
                "Type": "Admin privilege",
                "Description": "Admin can unilaterally withdraw all user funds from both risk and insure vaults.",
                "Repair": "Allow the change of controller address only in the VaultFactory()"
            },
            {
                "Location": "function withdraw()",
                "Type": "Griefing attack",
                "Description": "Anyone can withdraw to receiver once the receiver is isApprovedForAll(owner, receiver). The funds will be sent to receiver, but it will happen whenever an arbitrary msg.sender wants.",
                "Repair": "Change the approval requirement to be for the caller, not receiver"
            },
            {
                "Location": "tokenToOracle",
                "Type": "Incorrect oracle tracking",
                "Description": "Oracles are tracked by individual token, instead of by pair, leading to surprise results.",
                "Repair": "Change tokenToOracle to represent the pair of tokens, either by creating a Pair struct as the key, or by nesting a mapping inside of another mapping"
            },
            {
                "Location": "Pegged asset ratio calculation",
                "Type": "Payout required if pegged asset goes higher than underlying",
                "Description": "Risk users are required to payout if the price of the pegged asset goes higher than underlying",
                "Repair": "The ratio returned should always the ratio of the pegged asset to the underlying (i.e. pegged/underlying)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"@solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\nimport {\n    ERC1155Supply\n} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\";\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nabstract contract SemiFungibleVault is ERC1155Supply {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n    ERC20 public immutable asset;\n    string public name;\n    string public symbol;\n    bytes internal constant EMPTY = \"\";\n\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Deposit into vault when event is emitted\n      * @param caller Address of deposit caller\n      * @param owner Owner of assets\n      * @param id Vault id\n      * @param assets Amount of owner assets to deposit into vault\n      * @param shares Amount of shares to mint for owner\n      */\n    event Deposit(\n        address caller,\n        address indexed owner,\n        uint256 indexed id,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /** @notice Withdraw from vault when event is emitted\n      * @param caller Address of withdraw caller\n      * @param receiver Address of receiver of assets\n      * @param owner Owner of shares\n      * @param id Vault id\n      * @param assets Amount of owner assets to withdraw from vault\n      * @param shares Amount of owner shares to burn\n      */ \n    event Withdraw(\n        address caller,\n        address receiver,\n        address indexed owner,\n        uint256 indexed id,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /** @notice Contract constructor\n      * @param _asset ERC20 token\n      * @param _name Token name\n      * @param _symbol Token symbol \n      */\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC1155(\"\") {\n        asset = _asset;\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Triggers deposit into vault and mints shares for receiver\n      * @param id Vault id\n      * @param assets Amount of tokens to deposit\n      * @param receiver Receiver of shares\n      * @return shares Amount of shares minted\n      */ \n    function deposit(\n        uint256 id,\n        uint256 assets,\n        address receiver\n    ) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(id, assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, id, shares, EMPTY);\n\n        emit Deposit(msg.sender, receiver, id, assets, shares);\n\n        afterDeposit(id, assets, shares);\n    }\n\n    /** @notice Triggers withdraw from vault and burns receivers' shares\n      * @param id Vault id\n      * @param assets Amount of tokens to withdraw\n      * @param receiver Receiver of assets\n      * @param owner Owner of shares\n      * @return shares Amount of shares burned\n      */ \n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual returns (uint256 shares) {\n        require(\n            msg.sender == owner || isApprovedForAll(owner, receiver),\n            \"Only owner can withdraw, or owner has approved receiver for all\"\n        );\n\n        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        beforeWithdraw(id, assets, shares);\n        _burn(owner, id, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, id, assets, shares);\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**@notice Returns total assets for token\n     * @param  _id uint256 token id of token\n     */\n    function totalAssets(uint256 _id) public view virtual returns (uint256);\n\n    /** @notice Converts assets to shares\n        @param  id uint256 token id of token\n        @param assets Total number of assets\n     */\n    function convertToShares(uint256 id, uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply(id); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0 ? assets : assets.mulDivDown(supply, totalAssets(id));\n    }\n\n    /** @notice Converts shares to assets\n        @param  id uint256 token id of token\n        @param shares Total number of shares\n     */\n    function convertToAssets(uint256 id, uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply(id); // Saves an extra SLOAD if totalSupply is non-zero.\n        return\n            supply == 0 ? shares : shares.mulDivDown(totalAssets(id), supply);\n    }\n\n    /**\n        @notice Shows shares conversion output from depositing assets\n        @param  id uint256 token id of token\n        @param assets Total number of assets\n     */\n    function previewDeposit(uint256 id, uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(id, assets);\n    }\n\n    /**\n        @notice Shows shares conversion output from minting shares\n        @param  id uint256 token id of token\n        @param shares Total number of shares\n     */\n    function previewMint(uint256 id, uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply(id); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(id), supply);\n    }\n\n    /**\n        @notice Shows assets conversion output from withdrawing assets\n        @param  id uint256 token id of token\n        @param assets Total number of assets\n     */\n    function previewWithdraw(uint256 id, uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply(id); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets(id));\n    }\n\n     /**\n        @notice Shows assets conversion output from burning shares\n        @param  id uint256 token id of token\n        @param shares Total number of shares\n     */\n    function previewRedeem(uint256 id, uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(id, shares);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n    \n    /**\n        @notice Shows max amount of assets depositable into vault\n     */\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /**\n        @notice Shows max amount of mintable shares\n     */\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n     /**\n        @notice Shows max amount of assets withdrawable from vault\n     */\n    function maxWithdraw(uint256 id, address owner)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(id, balanceOf(owner, id));\n    }\n\n    /**\n        @notice Shows max amount of redeemable assets\n     */\n    function maxRedeem(uint256 id, address owner)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return balanceOf(owner, id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n    // solhint-disable no-empty-blocks\n    function beforeWithdraw(\n        uint256 id,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterDeposit(\n        uint256 id,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}\n\n\n",
        "CodeNames": [
            "SemiFungibleVault.sol",
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SemiFungibleVault.deposit, Controller.triggerDepeg, Controller.triggerEndEpoch",
                "Type": "Fee-on-Transfer",
                "Description": "Certain tokens charge a fee for transfers and this is not correctly handled in multiple places, leading to a loss of funds.",
                "Repair": "Check the actual balance differences when fee-on-transfer tokens should be supported. If they are not supported, this should be clearly documented."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeTransferLib} from \"@solmate/utils/SafeTransferLib.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n// Inheritance\nimport {IStakingRewards} from \"./IStakingRewards.sol\";\nimport {RewardsDistributionRecipient} from \"./RewardsDistributionRecipient.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {\n    ERC1155Holder\n} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Owned.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\ncontract StakingRewards is\n    IStakingRewards,\n    RewardsDistributionRecipient,\n    ReentrancyGuard,\n    Pausable,\n    ERC1155Holder\n{\n    using SafeMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    ERC20 public immutable rewardsToken;\n    IERC1155 public immutable stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate;\n    uint256 public rewardsDuration;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public id;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 id, uint256 amount);\n    event Withdrawn(address indexed user, uint256 id, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        uint256 _epochEnd,\n        uint256 _rewardsDuration,\n        uint256 _rewardRate\n    ) Owned(_owner) {\n        rewardsToken = ERC20(_rewardsToken);\n        stakingToken = IERC1155(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        id = _epochEnd;\n        rewardsDuration = _rewardsDuration;\n        rewardRate = _rewardRate;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount != 0, \"Cannot stake 0\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            amount,\n            \"\"\n        );\n        emit Staked(msg.sender, id, amount);\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        emit Withdrawn(msg.sender, id, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(_totalSupply)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardsDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance.div(rewardsDuration),\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol",
            "StakingRewards.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Controller contract, StakingRewards contract",
                "Type": "Smart Contract Logic",
                "Description": "Significant loss of precision possible due to rounding down in notifyRewardAmount function of StakingRewards contract.",
                "Repair": "Accumulate the differences that occur due to rounding and let the users claim them in the end according to their shares"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Controller contract",
                "Type": "Smart Contract Logic",
                "Description": "Depeg event can happen at incorrect price due to incorrect condition in isDisaster modifier of Controller contract.",
                "Repair": "Change the isDisaster modifier to revert when price of a pegged asset is equal to the strike price of a Vault"
            },
            {
                "Location": "Controller contract",
                "Type": "Smart Contract Logic",
                "Description": "After the vault expires, users may still receive rewards through the StakingRewards contract in Controller contract.",
                "Repair": "Add code to limit the periodFinish in notifyRewardAmount function of StakingRewards contract"
            },
            {
                "Location": "Controller contract",
                "Type": "Smart Contract Logic",
                "Description": "Rewards are not rolled over in Controller contract.",
                "Repair": "Accumulate the differences that occur due to rounding and let the users claim them in the end according to their shares"
            },
            {
                "Location": "Controller.sol:L198",
                "Type": "Preventing winners to withdraw",
                "Description": "At the end of an epoch, the triggerEndEpoch() is called to trigger 'epoch end without depeg event', making risk users the winners and entitling them to withdraw (risk + hedge) from the vault. In the case of the Arbitrum sequencer going down or restarting, there is a grace period of one hour before the getLatestPrice() returns to execute without reverting. This means that the triggerEndEpoch() cannot complete during this time, because it calls the getLatestPrice().",
                "Repair": "Relax the use of getLatestPrice() for informational purpose only in the DepegInsurance event emission"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\n\ncontract PegOracle {\n    /***\n    @dev  for example: oracle1 would be stETH / USD, while oracle2 would be ETH / USD oracle\n    ***/\n    address public oracle1;\n    address public oracle2;\n\n    uint8 public decimals;\n\n    AggregatorV3Interface internal priceFeed1;\n    AggregatorV3Interface internal priceFeed2;\n\n    /** @notice Contract constructor\n      * @param _oracle1 First oracle address\n      * @param _oracle2 Second oracle address\n      */\n    constructor(address _oracle1, address _oracle2) {\n        require(_oracle1 != address(0), \"oracle1 cannot be the zero address\");\n        require(_oracle2 != address(0), \"oracle2 cannot be the zero address\");\n        require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n        priceFeed1 = AggregatorV3Interface(_oracle1);\n        priceFeed2 = AggregatorV3Interface(_oracle2);\n        require(\n            (priceFeed1.decimals() == priceFeed2.decimals()),\n            \"Decimals must be the same\"\n        );\n\n        oracle1 = _oracle1;\n        oracle2 = _oracle2;\n\n        decimals = priceFeed1.decimals();\n    }\n\n    /** @notice Returns oracle-fed data from the latest round\n      * @return roundID Current round id \n      * @return nowPrice Current price\n      * @return startedAt Starting timestamp\n      * @return timeStamp Current timestamp\n      * @return answeredInRound Round id for which answer was computed \n      */ \n    function latestRoundData()\n        public\n        view\n        returns (\n            uint80 roundID,\n            int256 nowPrice,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        )\n    {\n        (\n            uint80 roundID1,\n            int256 price1,\n            uint256 startedAt1,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        int256 price2 = getOracle2_Price();\n\n        if (price1 > price2) {\n            nowPrice = (price2 * 10000) / price1;\n        } else {\n            nowPrice = (price1 * 10000) / price2;\n        }\n\n        int256 decimals10 = int256(10**(18 - priceFeed1.decimals()));\n        nowPrice = nowPrice * decimals10;\n\n        return (\n            roundID1,\n            nowPrice / 1000000,\n            startedAt1,\n            timeStamp1,\n            answeredInRound1\n        );\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup first oracle price\n      * @return price Current first oracle price\n      */ \n    function getOracle1_Price() public view returns (int256 price) {\n        (\n            uint80 roundID1,\n            int256 price1,\n            ,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        require(price1 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound1 >= roundID1,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp1 != 0, \"Timestamp == 0 !\");\n\n        return price1;\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup second oracle price\n      * @return price Current second oracle price\n      */ \n    function getOracle2_Price() public view returns (int256 price) {\n        (\n            uint80 roundID2,\n            int256 price2,\n            ,\n            uint256 timeStamp2,\n            uint80 answeredInRound2\n        ) = priceFeed2.latestRoundData();\n\n        require(price2 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound2 >= roundID2,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp2 != 0, \"Timestamp == 0 !\");\n\n        return price2;\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol",
            "PegOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Controller contract, PegOracle contract",
                "Type": "Smart Contract Logic",
                "Description": "Different Oracle issues can return outdated prices due to incorrect timestamp check in getLatestPrice function of PegOracle contract and inconsistency in how price1 and price2 are taken in Controller contract.",
                "Repair": "Check for stale prices by performing necessary round or timestamp checks"
            },
            {
                "Location": "PegOracle.sol and Controller.sol contracts",
                "Type": "Loss of precision",
                "Description": "The first multiplication is first divided by 1e6 and then re-multiplied by uint256 decimals = 10**(18-(priceFeed.decimals())); which leads to loss of precision. This behavior will make the relative price between the assets incorrect.",
                "Repair": "Use a formula that transforms the relative price to 1e18, and avoid dividing and multiplying by different values that lead to loss of precision"
            }
        ]
    }
]