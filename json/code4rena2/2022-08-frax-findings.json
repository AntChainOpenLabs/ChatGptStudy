[
    {
        "Code": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================= FraxlendPairCore =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./FraxlendPairConstants.sol\";\nimport \"./libraries/VaultAccount.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/ISwapper.sol\";\n\n/// @title FraxlendPairCore\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice  An abstract contract which contains the core logic and storage for the FraxlendPair\nabstract contract FraxlendPairCore is FraxlendPairConstants, IERC4626, ERC20, Ownable, Pausable, ReentrancyGuard {\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    string public version = \"1.0.0\";\n\n    // ============================================================================================\n    // Settings set by constructor() & initialize()\n    // ============================================================================================\n\n    // Asset and collateral contracts\n    IERC20 internal immutable assetContract;\n    IERC20 public immutable collateralContract;\n\n    // Oracle wrapper contract and oracleData\n    address public immutable oracleMultiply;\n    address public immutable oracleDivide;\n    uint256 public immutable oracleNormalization;\n\n    // LTV Settings\n    uint256 public immutable maxLTV;\n\n    // Liquidation Fee\n    uint256 public immutable cleanLiquidationFee;\n    uint256 public immutable dirtyLiquidationFee;\n\n    // Interest Rate Calculator Contract\n    IRateCalculator public immutable rateContract; // For complex rate calculations\n    bytes public rateInitCallData; // Optional extra data from init function to be passed to rate calculator\n\n    // Swapper\n    mapping(address => bool) public swappers; // approved swapper addresses\n\n    // Deployer\n    address public immutable DEPLOYER_ADDRESS;\n\n    // Admin contracts\n    address public immutable CIRCUIT_BREAKER_ADDRESS;\n    address public immutable COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address public immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    // ERC20 token name, accessible via name()\n    string internal nameOfContract;\n\n    // Maturity Date & Penalty Interest Rate (per Sec)\n    uint256 public immutable maturityDate;\n    uint256 public immutable penaltyRate;\n\n    // ============================================================================================\n    // Storage\n    // ============================================================================================\n\n    /// @notice Stores information about the current interest rate\n    /// @dev struct is packed to reduce SLOADs. feeToProtocolRate is 1e5 precision, ratePerSec is 1e18 precision\n    CurrentRateInfo public currentRateInfo;\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 feeToProtocolRate; // Fee amount 1e5 precision\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @notice Stores information about the current exchange rate. Collateral:Asset ratio\n    /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token\n    ExchangeRateInfo public exchangeRateInfo;\n    struct ExchangeRateInfo {\n        uint32 lastTimestamp;\n        uint224 exchangeRate; // collateral:asset ratio. i.e. how much collateral to buy 1e18 asset\n    }\n\n    // Contract Level Accounting\n    VaultAccount public totalAsset; // amount = total amount of assets, shares = total shares outstanding\n    VaultAccount public totalBorrow; // amount = total borrow amount with interest accrued, shares = total shares outstanding\n    uint256 public totalCollateral; // total amount of collateral in contract\n\n    // User Level Accounting\n    /// @notice Stores the balance of collateral for each user\n    mapping(address => uint256) public userCollateralBalance; // amount of collateral each user is backed\n    /// @notice Stores the balance of borrow shares for each user\n    mapping(address => uint256) public userBorrowShares; // represents the shares held by individuals\n    // NOTE: user shares of assets are represented as ERC-20 tokens and accessible via balanceOf()\n\n    // Internal Whitelists\n    bool public immutable borrowerWhitelistActive;\n    mapping(address => bool) public approvedBorrowers;\n\n    bool public immutable lenderWhitelistActive;\n    mapping(address => bool) public approvedLenders;\n\n    // ============================================================================================\n    // Initialize\n    // ============================================================================================\n\n    /// @notice The ```constructor``` function is called on deployment\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate date of the Pair\n    /// @param _penaltyRate The interest rate after maturity date\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    constructor(\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    ) {\n        // Handle Immutables Configuration\n        {\n            (\n                address _circuitBreaker,\n                address _comptrollerAddress,\n                address _timeLockAddress,\n                address _fraxlendWhitelistAddress\n            ) = abi.decode(_immutables, (address, address, address, address));\n\n            // Deployer contract\n            DEPLOYER_ADDRESS = msg.sender;\n            CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n            COMPTROLLER_ADDRESS = _comptrollerAddress;\n            TIME_LOCK_ADDRESS = _timeLockAddress;\n            FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelistAddress;\n        }\n\n        {\n            (\n                address _asset,\n                address _collateral,\n                address _oracleMultiply,\n                address _oracleDivide,\n                uint256 _oracleNormalization,\n                address _rateContract,\n\n            ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n\n            // Pair Settings\n            assetContract = IERC20(_asset);\n            collateralContract = IERC20(_collateral);\n            currentRateInfo.feeToProtocolRate = DEFAULT_PROTOCOL_FEE;\n            cleanLiquidationFee = _liquidationFee;\n            dirtyLiquidationFee = (_liquidationFee * 9000) / LIQ_PRECISION; // 90% of clean fee\n\n            if (_maxLTV >= LTV_PRECISION && !_isBorrowerWhitelistActive) revert BorrowerWhitelistRequired();\n            maxLTV = _maxLTV;\n\n            // Swapper Settings\n            swappers[FRAXSWAP_ROUTER_ADDRESS] = true;\n\n            // Oracle Settings\n            {\n                IFraxlendWhitelist _fraxlendWhitelist = IFraxlendWhitelist(FRAXLEND_WHITELIST_ADDRESS);\n                // Check that oracles are on the whitelist\n                if (_oracleMultiply != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleMultiply)) {\n                    revert NotOnWhitelist(_oracleMultiply);\n                }\n\n                if (_oracleDivide != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleDivide)) {\n                    revert NotOnWhitelist(_oracleDivide);\n                }\n\n                // Write oracleData to storage\n                oracleMultiply = _oracleMultiply;\n                oracleDivide = _oracleDivide;\n                oracleNormalization = _oracleNormalization;\n\n                // Rate Settings\n                if (!_fraxlendWhitelist.rateContractWhitelist(_rateContract)) {\n                    revert NotOnWhitelist(_rateContract);\n                }\n            }\n\n            rateContract = IRateCalculator(_rateContract);\n        }\n\n        // Set approved borrowers whitelist\n        borrowerWhitelistActive = _isBorrowerWhitelistActive;\n\n        // Set approved lenders whitlist active\n        lenderWhitelistActive = _isLenderWhitelistActive;\n\n        // Set maturity date & penalty interest rate\n        maturityDate = _maturityDate;\n        penaltyRate = _penaltyRate;\n    }\n\n    /// @notice The ```initialize``` function is called immediately after deployment\n    /// @dev This function can only be called by the deployer\n    /// @param _name The name of the contract\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    /// @param _rateInitCallData The configuration data for the Rate Calculator contract\n    function initialize(\n        string calldata _name,\n        address[] calldata _approvedBorrowers,\n        address[] calldata _approvedLenders,\n        bytes calldata _rateInitCallData\n    ) external {\n        if (msg.sender != DEPLOYER_ADDRESS) {\n            revert NotDeployer();\n        }\n        if (bytes(_name).length == 0) {\n            revert NameEmpty();\n        }\n        if (bytes(nameOfContract).length != 0) {\n            revert AlreadyInitialized();\n        }\n\n        // Set name\n        nameOfContract = _name;\n\n        // Set approved borrowers\n        for (uint256 i = 0; i < _approvedBorrowers.length; ++i) {\n            approvedBorrowers[_approvedBorrowers[i]] = true;\n        }\n\n        // Set approved lenders\n        for (uint256 i = 0; i < _approvedLenders.length; ++i) {\n            approvedLenders[_approvedLenders[i]] = true;\n        }\n\n        // Reverts if init data is not valid\n        IRateCalculator(rateContract).requireValidInitData(_rateInitCallData);\n\n        // Set rate init Data\n        rateInitCallData = _rateInitCallData;\n\n        // Instantiate Interest\n        _addInterest();\n\n        // Instantiate Exchange Rate\n        _updateExchangeRate();\n    }\n\n    // ============================================================================================\n    // Internal Helpers\n    // ============================================================================================\n\n    /// @notice The ```_totalAssetAvailable``` function returns the total balance of Asset Tokens in the contract\n    /// @param _totalAsset VaultAccount struct which stores total amount and shares for assets\n    /// @param _totalBorrow VaultAccount struct which stores total amount and shares for borrows\n    /// @return The balance of Asset Tokens held by contract\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _totalAsset.amount - _totalBorrow.amount;\n    }\n\n    /// @notice The ```_isSolvent``` function determines if a given borrower is solvent given an exchange rate\n    /// @param _borrower The borrower address to check\n    /// @param _exchangeRate The exchange rate, i.e. the amount of collateral to buy 1e18 asset\n    /// @return Whether borrower is solvent\n    function _isSolvent(address _borrower, uint256 _exchangeRate) internal view returns (bool) {\n        if (maxLTV == 0) return true;\n        uint256 _borrowerAmount = totalBorrow.toAmount(userBorrowShares[_borrower], true);\n        if (_borrowerAmount == 0) return true;\n        uint256 _collateralAmount = userCollateralBalance[_borrower];\n        if (_collateralAmount == 0) return false;\n\n        uint256 _ltv = (((_borrowerAmount * _exchangeRate) / EXCHANGE_PRECISION) * LTV_PRECISION) / _collateralAmount;\n        return _ltv <= maxLTV;\n    }\n\n    /// @notice The ```_isPastMaturity``` function determines if the current block timestamp is past the maturityDate date\n    /// @return Whether or not the debt is past maturity\n    function _isPastMaturity() internal view returns (bool) {\n        return maturityDate != 0 && block.timestamp > maturityDate;\n    }\n\n    // ============================================================================================\n    // Modifiers\n    // ============================================================================================\n\n    /// @notice Checks for solvency AFTER executing contract code\n    /// @param _borrower The borrower whose solvency we will check\n    modifier isSolvent(address _borrower) {\n        _;\n        if (!_isSolvent(_borrower, exchangeRateInfo.exchangeRate)) {\n            revert Insolvent(\n                totalBorrow.toAmount(userBorrowShares[_borrower], true),\n                userCollateralBalance[_borrower],\n                exchangeRateInfo.exchangeRate\n            );\n        }\n    }\n\n    /// @notice Checks if msg.sender is an approved Borrower\n    modifier approvedBorrower() {\n        if (borrowerWhitelistActive && !approvedBorrowers[msg.sender]) {\n            revert OnlyApprovedBorrowers();\n        }\n        _;\n    }\n\n    /// @notice Checks if msg.sender and _receiver are both an approved Lender\n    /// @param _receiver An additional receiver address to check\n    modifier approvedLender(address _receiver) {\n        if (lenderWhitelistActive && (!approvedLenders[msg.sender] || !approvedLenders[_receiver])) {\n            revert OnlyApprovedLenders();\n        }\n        _;\n    }\n\n    /// @notice Ensure function is not called when passed maturity\n    modifier isNotPastMaturity() {\n        if (_isPastMaturity()) {\n            revert PastMaturity();\n        }\n        _;\n    }\n\n    // ============================================================================================\n    // Functions: Interest Accumulation and Adjustment\n    // ============================================================================================\n\n    /// @notice The ```AddInterest``` event is emitted when interest is accrued by borrowers\n    /// @param _interestEarned The total interest accrued by all borrowers\n    /// @param _rate The interest rate used to calculate accrued interest\n    /// @param _deltaTime The time elapsed since last interest accrual\n    /// @param _feesAmount The amount of fees paid to protocol\n    /// @param _feesShare The amount of shares distributed to protocol\n    event AddInterest(\n        uint256 _interestEarned,\n        uint256 _rate,\n        uint256 _deltaTime,\n        uint256 _feesAmount,\n        uint256 _feesShare\n    );\n\n    /// @notice The ```UpdateRate``` event is emitted when the interest rate is updated\n    /// @param _ratePerSec The old interest rate (per second)\n    /// @param _deltaTime The time elapsed since last update\n    /// @param _utilizationRate The utilization of assets in the Pair\n    /// @param _newRatePerSec The new interest rate (per second)\n    event UpdateRate(uint256 _ratePerSec, uint256 _deltaTime, uint256 _utilizationRate, uint256 _newRatePerSec);\n\n    /// @notice The ```addInterest``` function is a public implementation of _addInterest and allows 3rd parties to trigger interest accrual\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function addInterest()\n        external\n        nonReentrant\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        return _addInterest();\n    }\n\n    /// @notice The ```_addInterest``` function is invoked prior to every external function and is used to accrue interest and update interest rate\n    /// @dev Can only called once per block\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function _addInterest()\n        internal\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        // Add interest only once per block\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\n            _newRate = _currentRateInfo.ratePerSec;\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\n        }\n\n        // Pull some data from storage to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // If there are no borrows or contract is paused, no interest accrues and we reset interest rate\n        if (_totalBorrow.shares == 0 || paused()) {\n            if (!paused()) {\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\n            }\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Effects: write to storage\n            currentRateInfo = _currentRateInfo;\n        } else {\n            // We know totalBorrow.shares > 0\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\n\n            // NOTE: Violates Checks-Effects-Interactions pattern\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\n            // Calc new rate\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\n            if (_isPastMaturity()) {\n                _newRate = uint64(penaltyRate);\n            } else {\n                bytes memory _rateData = abi.encode(\n                    _currentRateInfo.ratePerSec,\n                    _deltaTime,\n                    _utilizationRate,\n                    block.number - _currentRateInfo.lastBlock\n                );\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\n            }\n\n            // Event must be here to use non-mutated values\n            emit UpdateRate(_currentRateInfo.ratePerSec, _deltaTime, _utilizationRate, _newRate);\n\n            // Effects: bookkeeping\n            _currentRateInfo.ratePerSec = _newRate;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Calculate interest accrued\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\n\n            // Accumulate interest and fees, only if no overflow upon casting\n            if (\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\n                _interestEarned + _totalAsset.amount <= type(uint128).max\n            ) {\n                _totalBorrow.amount += uint128(_interestEarned);\n                _totalAsset.amount += uint128(_interestEarned);\n                if (_currentRateInfo.feeToProtocolRate > 0) {\n                    _feesAmount = (_interestEarned * _currentRateInfo.feeToProtocolRate) / FEE_PRECISION;\n\n                    _feesShare = (_feesAmount * _totalAsset.shares) / (_totalAsset.amount - _feesAmount);\n\n                    // Effects: Give new shares to this contract, effectively diluting lenders an amount equal to the fees\n                    // We can safely cast because _feesShare < _feesAmount < interestEarned which is always less than uint128\n                    _totalAsset.shares += uint128(_feesShare);\n\n                    // Effects: write to storage\n                    _mint(address(this), _feesShare);\n                }\n                emit AddInterest(_interestEarned, _currentRateInfo.ratePerSec, _deltaTime, _feesAmount, _feesShare);\n            }\n\n            // Effects: write to storage\n            totalAsset = _totalAsset;\n            currentRateInfo = _currentRateInfo;\n            totalBorrow = _totalBorrow;\n        }\n    }\n\n    // ============================================================================================\n    // Functions: ExchangeRate\n    // ============================================================================================\n    /// @notice The ```UpdateExchangeRate``` event is emitted when the Collateral:Asset exchange rate is updated\n    /// @param _rate The new rate given as the amount of Collateral Token to buy 1e18 Asset Token\n    event UpdateExchangeRate(uint256 _rate);\n\n    /// @notice The ```updateExchangeRate``` function is the external implementation of _updateExchangeRate.\n    /// @dev This function is invoked at most once per block as these queries can be expensive\n    /// @return _exchangeRate The new exchange rate\n    function updateExchangeRate() external nonReentrant returns (uint256 _exchangeRate) {\n        _exchangeRate = _updateExchangeRate();\n    }\n\n    /// @notice The ```_updateExchangeRate``` function retrieves the latest exchange rate. i.e how much collateral to buy 1e18 asset.\n    /// @dev This function is invoked at most once per block as these queries can be expensive\n    /// @return _exchangeRate The new exchange rate\n    function _updateExchangeRate() internal returns (uint256 _exchangeRate) {\n        ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;\n        if (_exchangeRateInfo.lastTimestamp == block.timestamp) {\n            return _exchangeRate = _exchangeRateInfo.exchangeRate;\n        }\n\n        uint256 _price = uint256(1e36);\n        if (oracleMultiply != address(0)) {\n            (, int256 _answer, , , ) = AggregatorV3Interface(oracleMultiply).latestRoundData();\n            if (_answer <= 0) {\n                revert OracleLTEZero(oracleMultiply);\n            }\n            _price = _price * uint256(_answer);\n        }\n\n        if (oracleDivide != address(0)) {\n            (, int256 _answer, , , ) = AggregatorV3Interface(oracleDivide).latestRoundData();\n            if (_answer <= 0) {\n                revert OracleLTEZero(oracleDivide);\n            }\n            _price = _price / uint256(_answer);\n        }\n\n        _exchangeRate = _price / oracleNormalization;\n\n        // write to storage, if no overflow\n        if (_exchangeRate > type(uint224).max) revert PriceTooLarge();\n        _exchangeRateInfo.exchangeRate = uint224(_exchangeRate);\n        _exchangeRateInfo.lastTimestamp = uint32(block.timestamp);\n        exchangeRateInfo = _exchangeRateInfo;\n        emit UpdateExchangeRate(_exchangeRate);\n    }\n\n    // ============================================================================================\n    // Functions: Lending\n    // ============================================================================================\n\n    /// @notice The ```_deposit``` function is the internal implementation for lending assets\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _totalAsset An in memory VaultAccount struct representing the total amounts and shares for the Asset Token\n    /// @param _amount The amount of Asset Token to be transferred\n    /// @param _shares The amount of Asset Shares (fTokens) to be minted\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    function _deposit(\n        VaultAccount memory _totalAsset,\n        uint128 _amount,\n        uint128 _shares,\n        address _receiver\n    ) internal {\n        // Effects: bookkeeping\n        _totalAsset.amount += _amount;\n        _totalAsset.shares += _shares;\n\n        // Effects: write back to storage\n        _mint(_receiver, _shares);\n        totalAsset = _totalAsset;\n\n        // Interactions\n        assetContract.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Deposit(msg.sender, _receiver, _amount, _shares);\n    }\n\n    /// @notice The ```deposit``` function allows a user to Lend Assets by specifying the amount of Asset Tokens to lend\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _amount The amount of Asset Token to transfer to Pair\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _sharesReceived The number of fTokens received for the deposit\n    function deposit(uint256 _amount, address _receiver)\n        external\n        nonReentrant\n        isNotPastMaturity\n        whenNotPaused\n        approvedLender(_receiver)\n        returns (uint256 _sharesReceived)\n    {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _sharesReceived = _totalAsset.toShares(_amount, false);\n        _deposit(_totalAsset, _amount.toUint128(), _sharesReceived.toUint128(), _receiver);\n    }\n\n    /// @notice The ```mint``` function allows a user to Lend assets by specifying the number of Assets Shares (fTokens) to mint\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _shares The number of Asset Shares (fTokens) that a user wants to mint\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _amountReceived The amount of Asset Tokens transferred to the Pair\n    function mint(uint256 _shares, address _receiver)\n        external\n        nonReentrant\n        isNotPastMaturity\n        whenNotPaused\n        approvedLender(_receiver)\n        returns (uint256 _amountReceived)\n    {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _amountReceived = _totalAsset.toAmount(_shares, true);\n        _deposit(_totalAsset, _amountReceived.toUint128(), _shares.toUint128(), _receiver);\n    }\n\n    /// @notice The ```_redeem``` function is an internal implementation which allows a Lender to pull their Asset Tokens out of the Pair\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _totalAsset An in-memory VaultAccount struct which holds the total amount of Asset Tokens and the total number of Asset Shares (fTokens)\n    /// @param _amountToReturn The number of Asset Tokens to return\n    /// @param _shares The number of Asset Shares (fTokens) to burn\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    function _redeem(\n        VaultAccount memory _totalAsset,\n        uint128 _amountToReturn,\n        uint128 _shares,\n        address _receiver,\n        address _owner\n    ) internal {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance(_owner, msg.sender);\n            // NOTE: This will revert on underflow ensuring that allowance > shares\n            if (allowed != type(uint256).max) _approve(_owner, msg.sender, allowed - _shares);\n        }\n\n        // Check for sufficient withdraw liquidity\n        uint256 _assetsAvailable = _totalAssetAvailable(_totalAsset, totalBorrow);\n        if (_assetsAvailable < _amountToReturn) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _amountToReturn);\n        }\n\n        // Effects: bookkeeping\n        _totalAsset.amount -= _amountToReturn;\n        _totalAsset.shares -= _shares;\n\n        // Effects: write to storage\n        totalAsset = _totalAsset;\n        _burn(_owner, _shares);\n\n        // Interactions\n        assetContract.safeTransfer(_receiver, _amountToReturn);\n        emit Withdraw(msg.sender, _receiver, _owner, _amountToReturn, _shares);\n    }\n\n    /// @notice The ```redeem``` function allows the caller to redeem their Asset Shares for Asset Tokens\n    /// @param _shares The number of Asset Shares (fTokens) to burn for Asset Tokens\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _amountToReturn The amount of Asset Tokens to be transferred\n    function redeem(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) external nonReentrant returns (uint256 _amountToReturn) {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _amountToReturn = _totalAsset.toAmount(_shares, false);\n        _redeem(_totalAsset, _amountToReturn.toUint128(), _shares.toUint128(), _receiver, _owner);\n    }\n\n    /// @notice The ```withdraw``` function allows a user to redeem their Asset Shares for a specified amount of Asset Tokens\n    /// @param _amount The amount of Asset Tokens to be transferred in exchange for burning Asset Shares\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _shares The number of Asset Shares (fTokens) burned\n    function withdraw(\n        uint256 _amount,\n        address _receiver,\n        address _owner\n    ) external nonReentrant returns (uint256 _shares) {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _shares = _totalAsset.toShares(_amount, true);\n        _redeem(_totalAsset, _amount.toUint128(), _shares.toUint128(), _receiver, _owner);\n    }\n\n    // ============================================================================================\n    // Functions: Borrowing\n    // ============================================================================================\n\n    /// @notice The ```BorrowAsset``` event is emitted when a borrower increases their position\n    /// @param _borrower The borrower whose account was debited\n    /// @param _receiver The address to which the Asset Tokens were transferred\n    /// @param _borrowAmount The amount of Asset Tokens transferred\n    /// @param _sharesAdded The number of Borrow Shares the borrower was debited\n    event BorrowAsset(\n        address indexed _borrower,\n        address indexed _receiver,\n        uint256 _borrowAmount,\n        uint256 _sharesAdded\n    );\n\n    /// @notice The ```_borrowAsset``` function is the internal implementation for borrowing assets\n    /// @param _borrowAmount The amount of the Asset Token to borrow\n    /// @param _receiver The address to receive the Asset Tokens\n    /// @return _sharesAdded The amount of borrow shares the msg.sender will be debited\n    function _borrowAsset(uint128 _borrowAmount, address _receiver) internal returns (uint256 _sharesAdded) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Check available capital\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _borrowAmount);\n        }\n\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\n        _sharesAdded = _totalBorrow.toShares(_borrowAmount, true);\n        _totalBorrow.amount += _borrowAmount;\n        _totalBorrow.shares += uint128(_sharesAdded);\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\n\n        // Effects: write back to storage\n        totalBorrow = _totalBorrow;\n        userBorrowShares[msg.sender] += _sharesAdded;\n\n        // Interactions\n        if (_receiver != address(this)) {\n            assetContract.safeTransfer(_receiver, _borrowAmount);\n        }\n        emit BorrowAsset(msg.sender, _receiver, _borrowAmount, _sharesAdded);\n    }\n\n    /// @notice The ```borrowAsset``` function allows a user to open/increase a borrow position\n    /// @dev Borrower must call ```ERC20.approve``` on the Collateral Token contract if applicable\n    /// @param _borrowAmount The amount of Asset Token to borrow\n    /// @param _collateralAmount The amount of Collateral Token to transfer to Pair\n    /// @param _receiver The address which will receive the Asset Tokens\n    /// @return _shares The number of borrow Shares the msg.sender will be debited\n    function borrowAsset(\n        uint256 _borrowAmount,\n        uint256 _collateralAmount,\n        address _receiver\n    )\n        external\n        isNotPastMaturity\n        whenNotPaused\n        nonReentrant\n        isSolvent(msg.sender)\n        approvedBorrower\n        returns (uint256 _shares)\n    {\n        _addInterest();\n        _updateExchangeRate();\n        if (_collateralAmount > 0) {\n            _addCollateral(msg.sender, _collateralAmount, msg.sender);\n        }\n        _shares = _borrowAsset(_borrowAmount.toUint128(), _receiver);\n    }\n\n    event AddCollateral(address indexed _sender, address indexed _borrower, uint256 _collateralAmount);\n\n    /// @notice The ```_addCollateral``` function is an internal implementation for adding collateral to a borrowers position\n    /// @param _sender The source of funds for the new collateral\n    /// @param _collateralAmount The amount of Collateral Token to be transferred\n    /// @param _borrower The borrower account for which the collateral should be credited\n    function _addCollateral(\n        address _sender,\n        uint256 _collateralAmount,\n        address _borrower\n    ) internal {\n        // Effects: write to state\n        userCollateralBalance[_borrower] += _collateralAmount;\n        totalCollateral += _collateralAmount;\n\n        // Interactions\n        if (_sender != address(this)) {\n            collateralContract.safeTransferFrom(_sender, address(this), _collateralAmount);\n        }\n        emit AddCollateral(_sender, _borrower, _collateralAmount);\n    }\n\n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\n    /// @param _borrower The account to be credited\n    function addCollateral(uint256 _collateralAmount, address _borrower) external nonReentrant isNotPastMaturity {\n        _addInterest();\n        _addCollateral(msg.sender, _collateralAmount, _borrower);\n    }\n\n    /// @notice The ```RemoveCollateral``` event is emitted when collateral is removed from a borrower's position\n    /// @param _sender The account from which funds are transferred\n    /// @param _collateralAmount The amount of Collateral Token to be transferred\n    /// @param _receiver The address to which Collateral Tokens will be transferred\n    event RemoveCollateral(\n        address indexed _sender,\n        uint256 _collateralAmount,\n        address indexed _receiver,\n        address indexed _borrower\n    );\n\n    /// @notice The ```_removeCollateral``` function is the internal implementation for removing collateral from a borrower's position\n    /// @param _collateralAmount The amount of Collateral Token to remove from the borrower's position\n    /// @param _receiver The address to receive the Collateral Token transferred\n    /// @param _borrower The borrower whose account will be debited the Collateral amount\n    function _removeCollateral(\n        uint256 _collateralAmount,\n        address _receiver,\n        address _borrower\n    ) internal {\n        // Effects: write to state\n        // Following line will revert on underflow if _collateralAmount > userCollateralBalance\n        userCollateralBalance[_borrower] -= _collateralAmount;\n        // Following line will revert on underflow if totalCollateral < _collateralAmount\n        totalCollateral -= _collateralAmount;\n\n        // Interactions\n        if (_receiver != address(this)) {\n            collateralContract.safeTransfer(_receiver, _collateralAmount);\n        }\n        emit RemoveCollateral(msg.sender, _collateralAmount, _receiver, _borrower);\n    }\n\n    /// @notice The ```removeCollateral``` function is used to remove collateral from msg.sender's borrow position\n    /// @dev msg.sender must be solvent after invocation or transaction will revert\n    /// @param _collateralAmount The amount of Collateral Token to transfer\n    /// @param _receiver The address to receive the transferred funds\n    function removeCollateral(uint256 _collateralAmount, address _receiver)\n        external\n        nonReentrant\n        isSolvent(msg.sender)\n    {\n        _addInterest();\n        // Note: exchange rate is irrelevant when borrower has no debt shares\n        if (userBorrowShares[msg.sender] > 0) {\n            _updateExchangeRate();\n        }\n        _removeCollateral(_collateralAmount, _receiver, msg.sender);\n    }\n\n    /// @notice The ```RepayAsset``` event is emitted whenever a debt position is repaid\n    /// @param _sender The msg.sender of the transaction\n    /// @param _borrower The borrower whose account will be credited\n    /// @param _amountToRepay The amount of Asset token to be transferred\n    /// @param _shares The amount of Borrow Shares which will be debited from the borrower after repayment\n    event RepayAsset(address indexed _sender, address indexed _borrower, uint256 _amountToRepay, uint256 _shares);\n\n    /// @notice The ```_repayAsset``` function is the internal implementation for repaying a borrow position\n    /// @dev The payer must have called ERC20.approve() on the Asset Token contract prior to invocation\n    /// @param _totalBorrow An in memory copy of the totalBorrow VaultAccount struct\n    /// @param _amountToRepay The amount of Asset Token to transfer\n    /// @param _shares The number of Borrow Shares the sender is repaying\n    /// @param _payer The address from which funds will be transferred\n    /// @param _borrower The borrower account which will be credited\n    function _repayAsset(\n        VaultAccount memory _totalBorrow,\n        uint128 _amountToRepay,\n        uint128 _shares,\n        address _payer,\n        address _borrower\n    ) internal {\n        // Effects: Bookkeeping\n        _totalBorrow.amount -= _amountToRepay;\n        _totalBorrow.shares -= _shares;\n\n        // Effects: write to state\n        userBorrowShares[_borrower] -= _shares;\n        totalBorrow = _totalBorrow;\n\n        // Interactions\n        if (_payer != address(this)) {\n            assetContract.safeTransferFrom(_payer, address(this), _amountToRepay);\n        }\n        emit RepayAsset(msg.sender, _borrower, _amountToRepay, _shares);\n    }\n\n    /// @notice The ```repayAsset``` function allows the caller to pay down the debt for a given borrower.\n    /// @dev Caller must first invoke ```ERC20.approve()``` for the Asset Token contract\n    /// @param _shares The number of Borrow Shares which will be repaid by the call\n    /// @param _borrower The account for which the debt will be reduced\n    /// @return _amountToRepay The amount of Asset Tokens which were transferred in order to repay the Borrow Shares\n    function repayAsset(uint256 _shares, address _borrower) external nonReentrant returns (uint256 _amountToRepay) {\n        _addInterest();\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        _repayAsset(_totalBorrow, _amountToRepay.toUint128(), _shares.toUint128(), msg.sender, _borrower);\n    }\n\n    // ============================================================================================\n    // Functions: Liquidations\n    // ============================================================================================\n    /// @notice The ```Liquidate``` event is emitted when a liquidation occurs\n    /// @param _borrower The borrower account for which the liquidation occured\n    /// @param _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    /// @param _sharesToLiquidate The number of Borrow Shares the liquidator repaid on behalf of the borrower\n    /// @param _sharesToAdjust The number of Borrow Shares that were adjusted on liabilites and assets (a writeoff)\n    event Liquidate(\n        address indexed _borrower,\n        uint256 _collateralForLiquidator,\n        uint256 _sharesToLiquidate,\n        uint256 _amountLiquidatorToRepay,\n        uint256 _sharesToAdjust,\n        uint256 _amountToAdjust\n    );\n\n    /// @notice The ```liquidate``` function allows a third party to repay a borrower's debt if they have become insolvent\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling ```Liquidate()```\n    /// @param _shares The number of Borrow Shares repaid by the liquidator\n    /// @param _borrower The account for which the repayment is credited and from whom collateral will be taken\n    /// @return _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    function liquidate(uint256 _shares, address _borrower)\n        external\n        whenNotPaused\n        nonReentrant\n        approvedLender(msg.sender)\n        returns (uint256 _collateralForLiquidator)\n    {\n        _addInterest();\n\n        // Get best available exchange rate\n        uint256 _exchangeRate = _updateExchangeRate();\n        if (_isSolvent(_borrower, _exchangeRate)) {\n            revert BorrowerSolvent();\n        }\n\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Determine how much of the borrow and collateral will be repaid\n        _collateralForLiquidator =\n            (((_totalBorrow.toAmount(_shares, false) * _exchangeRate) / EXCHANGE_PRECISION) *\n                (LIQ_PRECISION + cleanLiquidationFee)) /\n            LIQ_PRECISION;\n\n        // Effects & Interactions\n        // NOTE: reverts if _shares > userBorrowShares\n        uint256 _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        _repayAsset(_totalBorrow, _amountToRepay.toUint128(), _shares.toUint128(), msg.sender, _borrower); // liquidator repays shares on behalf of borrower\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        // Collateral is removed on behalf of borrower and sent to liquidator\n        _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);\n        emit Liquidate(_borrower, _collateralForLiquidator, _shares, 0, 0, 0);\n    }\n\n    /// @notice The ```liquidateClean``` function allows a third party to repay a borrower's debt if they have become insolvent\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling ```Liquidate()```\n    /// @param _sharesToLiquidate The number of Borrow Shares repaid by the liquidator\n    /// @param _deadline The timestamp after which tx will revert\n    /// @param _borrower The account for which the repayment is credited and from whom collateral will be taken\n    /// @return _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    function liquidateClean(\n        uint128 _sharesToLiquidate,\n        uint256 _deadline,\n        address _borrower\n    ) external whenNotPaused nonReentrant approvedLender(msg.sender) returns (uint256 _collateralForLiquidator) {\n        if (block.timestamp > _deadline) revert PastDeadline(block.timestamp, _deadline);\n\n        _addInterest();\n        uint256 _exchangeRate = _updateExchangeRate();\n\n        if (_isSolvent(_borrower, _exchangeRate)) {\n            revert BorrowerSolvent();\n        }\n\n        // Read from state\n        VaultAccount memory _totalBorrow = totalBorrow;\n        uint256 _userCollateralBalance = userCollateralBalance[_borrower];\n        uint128 _borrowerShares = userBorrowShares[_borrower].toUint128();\n\n        // Prevent stack-too-deep\n        int256 _leftoverCollateral;\n        {\n            // Checks & Calculations\n            // Determine the liquidation amount in collateral units (i.e. how much debt is liquidator going to repay)\n            uint256 _liquidationAmountInCollateralUnits = ((_totalBorrow.toAmount(_sharesToLiquidate, false) *\n                _exchangeRate) / EXCHANGE_PRECISION);\n\n            // We first optimistically calculate the amount of collateral to give the liquidator based on the higher clean liquidation fee\n            // This fee only applies if the liquidator does a full liquidation\n            uint256 _optimisticCollateralForLiquidator = (_liquidationAmountInCollateralUnits *\n                (LIQ_PRECISION + cleanLiquidationFee)) / LIQ_PRECISION;\n\n            // Because interest accrues every block, _liquidationAmountInCollateralUnits from a few lines up is an ever increasing value\n            // This means that leftoverCollateral can occasionally go negative by a few hundred wei (cleanLiqFee premium covers this for liquidator)\n            _leftoverCollateral = (_userCollateralBalance.toInt256() - _optimisticCollateralForLiquidator.toInt256());\n\n            // If cleanLiquidation fee results in no leftover collateral, give liquidator all the collateral\n            // This will only be true when there liquidator is cleaning out the position\n            _collateralForLiquidator = _leftoverCollateral <= 0\n                ? _userCollateralBalance\n                : (_liquidationAmountInCollateralUnits * (LIQ_PRECISION + dirtyLiquidationFee)) / LIQ_PRECISION;\n        }\n        // Calced here for use during repayment, grouped with other calcs before effects start\n        uint128 _amountLiquidatorToRepay = (_totalBorrow.toAmount(_sharesToLiquidate, true)).toUint128();\n\n        // Determine if and how much debt to writeoff\n        // Note: ensures that sharesToLiquidate is never larger than borrowerShares\n        uint128 _sharesToAdjust;\n        uint128 _amountToAdjust;\n        {\n            if (_leftoverCollateral <= 0) {\n                uint128 _leftoverBorrowShares = _borrowerShares - _sharesToLiquidate;\n                if (_leftoverBorrowShares > 0) {\n                    // Write off bad debt\n                    _sharesToAdjust = _leftoverBorrowShares;\n                    _amountToAdjust = (_totalBorrow.toAmount(_sharesToAdjust, false)).toUint128();\n\n                    // Effects: write to state\n                    totalAsset.amount -= _amountToAdjust;\n\n                    // Note: Ensure this memory stuct will be passed to _repayAsset for write to state\n                    _totalBorrow.amount -= _amountToAdjust;\n                    _totalBorrow.shares -= _sharesToAdjust;\n                }\n            }\n        }\n\n        // Effects & Interactions\n        // NOTE: reverts if _shares > userBorrowShares\n        _repayAsset(_totalBorrow, _amountLiquidatorToRepay, _sharesToLiquidate, msg.sender, _borrower); // liquidator repays shares on behalf of borrower\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        // Collateral is removed on behalf of borrower and sent to liquidator\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);\n        emit Liquidate(\n            _borrower,\n            _collateralForLiquidator,\n            _sharesToLiquidate,\n            _amountLiquidatorToRepay,\n            _sharesToAdjust,\n            _amountToAdjust\n        );\n    }\n\n    // ============================================================================================\n    // Functions: Leverage\n    // ============================================================================================\n\n    /// @notice The ```LeveragedPosition``` event is emitted when a borrower takes out a new leveraged position\n    /// @param _borrower The account for which the debt is debited\n    /// @param _swapperAddress The address of the swapper which conforms the FraxSwap interface\n    /// @param _borrowAmount The amount of Asset Token to be borrowed to be borrowed\n    /// @param _borrowShares The number of Borrow Shares the borrower is credited\n    /// @param _initialCollateralAmount The amount of initial Collateral Tokens supplied by the borrower\n    /// @param _amountCollateralOut The amount of Collateral Token which was received for the Asset Tokens\n    event LeveragedPosition(\n        address indexed _borrower,\n        address _swapperAddress,\n        uint256 _borrowAmount,\n        uint256 _borrowShares,\n        uint256 _initialCollateralAmount,\n        uint256 _amountCollateralOut\n    );\n\n    /// @notice The ```leveragedPosition``` function allows a user to enter a leveraged borrow position with minimal upfront Collateral\n    /// @dev Caller must invoke ```ERC20.approve()``` on the Collateral Token contract prior to calling function\n    /// @param _swapperAddress The address of the whitelisted swapper to use to swap borrowed Asset Tokens for Collateral Tokens\n    /// @param _borrowAmount The amount of Asset Tokens borrowed\n    /// @param _initialCollateralAmount The initial amount of Collateral Tokens supplied by the borrower\n    /// @param _amountCollateralOutMin The minimum amount of Collateral Tokens to be received in exchange for the borrowed Asset Tokens\n    /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.\n    /// @return _totalCollateralBalance The total amount of Collateral Tokens added to a users account (initial + swap)\n    function leveragedPosition(\n        address _swapperAddress,\n        uint256 _borrowAmount,\n        uint256 _initialCollateralAmount,\n        uint256 _amountCollateralOutMin,\n        address[] memory _path\n    )\n        external\n        isNotPastMaturity\n        nonReentrant\n        whenNotPaused\n        approvedBorrower\n        isSolvent(msg.sender)\n        returns (uint256 _totalCollateralBalance)\n    {\n        _addInterest();\n        _updateExchangeRate();\n\n        IERC20 _assetContract = assetContract;\n        IERC20 _collateralContract = collateralContract;\n\n        if (!swappers[_swapperAddress]) {\n            revert BadSwapper();\n        }\n        if (_path[0] != address(_assetContract)) {\n            revert InvalidPath(address(_assetContract), _path[0]);\n        }\n        if (_path[_path.length - 1] != address(_collateralContract)) {\n            revert InvalidPath(address(_collateralContract), _path[_path.length - 1]);\n        }\n\n        // Add initial collateral\n        if (_initialCollateralAmount > 0) {\n            _addCollateral(msg.sender, _initialCollateralAmount, msg.sender);\n        }\n\n        // Debit borrowers account\n        // setting recipient to address(this) means no transfer will happen\n        uint256 _borrowShares = _borrowAsset(_borrowAmount.toUint128(), address(this));\n\n        // Interactions\n        _assetContract.approve(_swapperAddress, _borrowAmount);\n\n        // Even though swappers are trusted, we verify the balance before and after swap\n        uint256 _initialCollateralBalance = _collateralContract.balanceOf(address(this));\n        ISwapper(_swapperAddress).swapExactTokensForTokens(\n            _borrowAmount,\n            _amountCollateralOutMin,\n            _path,\n            address(this),\n            block.timestamp\n        );\n        uint256 _finalCollateralBalance = _collateralContract.balanceOf(address(this));\n\n        // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT\n        // Effects: bookkeeping & write to state\n        uint256 _amountCollateralOut = _finalCollateralBalance - _initialCollateralBalance;\n        if (_amountCollateralOut < _amountCollateralOutMin) {\n            revert SlippageTooHigh(_amountCollateralOutMin, _amountCollateralOut);\n        }\n\n        // address(this) as _sender means no transfer occurs as the pair has already received the collateral during swap\n        _addCollateral(address(this), _amountCollateralOut, msg.sender);\n\n        _totalCollateralBalance = _initialCollateralAmount + _amountCollateralOut;\n        emit LeveragedPosition(\n            msg.sender,\n            _swapperAddress,\n            _borrowAmount,\n            _borrowShares,\n            _initialCollateralAmount,\n            _amountCollateralOut\n        );\n    }\n\n    /// @notice The ```RepayAssetWithCollateral``` event is emitted whenever ```repayAssetWithCollateral()``` is invoked\n    /// @param _borrower The borrower account for which the repayment is taking place\n    /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps\n    /// @param _collateralToSwap The amount of Collateral Token to swap and use for repayment\n    /// @param _amountAssetOut The amount of Asset Token which was repaid\n    /// @param _sharesRepaid The number of Borrow Shares which were repaid\n    event RepayAssetWithCollateral(\n        address indexed _borrower,\n        address _swapperAddress,\n        uint256 _collateralToSwap,\n        uint256 _amountAssetOut,\n        uint256 _sharesRepaid\n    );\n\n    /// @notice The ```repayAssetWithCollateral``` function allows a borrower to repay their debt using existing collateral in contract\n    /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps\n    /// @param _collateralToSwap The amount of Collateral Tokens to swap for Asset Tokens\n    /// @param _amountAssetOutMin The minimum amount of Asset Tokens to receive during the swap\n    /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.\n    /// @return _amountAssetOut The amount of Asset Tokens received for the Collateral Tokens, the amount the borrowers account was credited\n    function repayAssetWithCollateral(\n        address _swapperAddress,\n        uint256 _collateralToSwap,\n        uint256 _amountAssetOutMin,\n        address[] calldata _path\n    ) external nonReentrant isSolvent(msg.sender) returns (uint256 _amountAssetOut) {\n        _addInterest();\n        _updateExchangeRate();\n\n        IERC20 _assetContract = assetContract;\n        IERC20 _collateralContract = collateralContract;\n\n        if (!swappers[_swapperAddress]) {\n            revert BadSwapper();\n        }\n        if (_path[0] != address(_collateralContract)) {\n            revert InvalidPath(address(_collateralContract), _path[0]);\n        }\n        if (_path[_path.length - 1] != address(_assetContract)) {\n            revert InvalidPath(address(_assetContract), _path[_path.length - 1]);\n        }\n\n        // Effects: bookkeeping & write to state\n        // Debit users collateral balance in preparation for swap, setting _recipient to address(this) means no transfer occurs\n        _removeCollateral(_collateralToSwap, address(this), msg.sender);\n\n        // Interactions\n        _collateralContract.approve(_swapperAddress, _collateralToSwap);\n\n        // Even though swappers are trusted, we verify the balance before and after swap\n        uint256 _initialAssetBalance = _assetContract.balanceOf(address(this));\n        ISwapper(_swapperAddress).swapExactTokensForTokens(\n            _collateralToSwap,\n            _amountAssetOutMin,\n            _path,\n            address(this),\n            block.timestamp\n        );\n        uint256 _finalAssetBalance = _assetContract.balanceOf(address(this));\n\n        // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT\n        // Effects: bookkeeping\n        _amountAssetOut = _finalAssetBalance - _initialAssetBalance;\n        if (_amountAssetOut < _amountAssetOutMin) {\n            revert SlippageTooHigh(_amountAssetOutMin, _amountAssetOut);\n        }\n\n        VaultAccount memory _totalBorrow = totalBorrow;\n        uint256 _sharesToRepay = _totalBorrow.toShares(_amountAssetOut, false);\n\n        // Effects: write to state\n        // Note: setting _payer to address(this) means no actual transfer will occur.  Contract already has funds\n        _repayAsset(_totalBorrow, _amountAssetOut.toUint128(), _sharesToRepay.toUint128(), address(this), msg.sender);\n\n        emit RepayAssetWithCollateral(msg.sender, _swapperAddress, _collateralToSwap, _amountAssetOut, _sharesToRepay);\n    }\n}\n\n\n",
        "CodeNames": [
            "FraxlendPairCore.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FraxlendPairCore.sol line 536",
                "Type": "Decimals limitation",
                "Description": "The decimals limitation prevents certain combinations of tokens from being deployed, limiting the tokens that can be used.",
                "Repair": "Modify the oracleNormalization calculation to handle tokens with decimals greater than 18"
            },
            {
                "Location": "FraxlendPairCore.sol",
                "Type": "Incorrect percent calculation",
                "Description": "Wrong percent for FraxlendPairCore.dirtyLiquidationFee.",
                "Repair": "Change 9000 to 90000 in the dirtyLiquidationFee calculation"
            },
            {
                "Location": "FraxlendPairCore.sol",
                "Type": "Re-entrancy vulnerability",
                "Description": "Any borrower with bad debt can be liquidated multiple times to lock funds in the lending pair.",
                "Repair": "Add _sharesToLiquidate += _sharesToAdjust; after line 1012"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "liquidate() function",
                "Type": "Last lender to withdraw loses",
                "Description": "When there's bad debt which wasn't marked off yet, the totalAssets.amount is higher than the actual (solvent) amount the pair has, leading to a 'last lender to withdraw loses' scenario.",
                "Repair": "Mark off bad debt as soon as possible, and consider marking off also in case of near-zero collateral left. Add a check to ensure that the amount of shares the liquidator repays are covered by the collateral available."
            },
            {
                "Location": "liquidateClean() function",
                "Type": "Overpayment",
                "Description": "liquidators might end up paying assets that are worth much more than the collateral they received.",
                "Repair": "Check that the shares intended to be repaid are worth the collateral + fee, if not reduce the amount of shares to be repaid accordingly."
            },
            {
                "Location": "FracLendPairCore.sol",
                "Type": "No incentives to write off bad debt",
                "Description": "When a position only has a bit of collateral left (e.g., because a previous liquidateClean call provided just too little shares or the exchange rate just changed), there is no incentive anymore to call liquidateClean again. The maximum amount that a user will get is the remaining collateral balance, which does not cover the gas fees in such cases. Therefore, the bad debt is never written off, meaning that the mechanism does not work in such cases and these pairs become toxic.",
                "Repair": "Introduce an upper limit, e.g. 95%. Above this limit, no dirty liquidations would be allowed."
            },
            {
                "Location": "_addInterest() function",
                "Type": "Penalty rate is used for pre-maturity date as well",
                "Description": "When _addInterest() is called post maturity, the penalty rate is applied since the last time _addInterest() was called, including the period before maturity. Borrowers will be charged with higher interest rates, when maturity date passes.",
                "Repair": "When maturity date passes and the last time _addInterest() was called was before maturity date, calculate first the interest rate for that interval as normal interest rate, and then calculate penalty rate for the remaining time."
            },
            {
                "Location": "FracxlendPairDeployer.sol",
                "Type": "Deployment/Initialization",
                "Description": "It is impossible to setCreationCode() with code size less than 13K.",
                "Repair": "If the code of the pair gets smaller (e.g. optimization, moving part of the code to a library etc.) to 13K or less, it'd be impossible to set it as the new creation code (or in the case of the 2nd issue, it'd be impossible to deploy it)."
            },
            {
                "Location": "addInterest() function",
                "Type": "Interest miscalculation",
                "Description": "Not calling addInterest() frequently enough can lead to lower interest rates, which can affect lenders who might end up gaining less interest than expected.",
                "Repair": "Divide the interest calculation into small periods of time in case a long period has passed since the last time addInterest() ran"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================== FraxlendPair ============================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./FraxlendPairConstants.sol\";\nimport \"./FraxlendPairCore.sol\";\nimport \"./libraries/VaultAccount.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/ISwapper.sol\";\n\ncontract FraxlendPair is FraxlendPairCore {\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    )\n        FraxlendPairCore(\n            _configData,\n            _immutables,\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate,\n            _penaltyRate,\n            _isBorrowerWhitelistActive,\n            _isLenderWhitelistActive\n        )\n        ERC20(\"\", \"\")\n        Ownable()\n        Pausable()\n    {}\n\n    // ============================================================================================\n    // ERC20 Metadata\n    // ============================================================================================\n\n    function name() public view override(ERC20, IERC20Metadata) returns (string memory) {\n        return nameOfContract;\n    }\n\n    function symbol() public view override(ERC20, IERC20Metadata) returns (string memory) {\n        // prettier-ignore\n        // solhint-disable-next-line max-line-length\n        return string(abi.encodePacked(\"FraxlendV1 - \", collateralContract.safeSymbol(), \"/\", assetContract.safeSymbol()));\n    }\n\n    function decimals() public pure override(ERC20, IERC20Metadata) returns (uint8) {\n        return 18;\n    }\n\n    // totalSupply for fToken ERC20 compatibility\n    function totalSupply() public view override(ERC20, IERC20) returns (uint256) {\n        return totalAsset.shares;\n    }\n\n    // ============================================================================================\n    // ERC4626 Views\n    // ============================================================================================\n    function asset() external view returns (address) {\n        return address(assetContract);\n    }\n\n    function totalAssets() public view virtual returns (uint256) {\n        return totalAsset.amount;\n    }\n\n    function assetsPerShare() external view returns (uint256 _assetsPerUnitShare) {\n        _assetsPerUnitShare = totalAsset.toAmount(1e18, false);\n    }\n\n    function assetsOf(address _depositor) external view returns (uint256 _assets) {\n        _assets = totalAsset.toAmount(balanceOf(_depositor), false);\n    }\n\n    function convertToShares(uint256 _amount) external view returns (uint256) {\n        return totalAsset.toShares(_amount, false);\n    }\n\n    function convertToAssets(uint256 _shares) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, false);\n    }\n\n    function previewDeposit(uint256 _amount) external view returns (uint256) {\n        return totalAsset.toShares(_amount, false);\n    }\n\n    function previewMint(uint256 _shares) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, true);\n    }\n\n    function previewWithdraw(uint256 _amount) external view returns (uint256) {\n        return totalAsset.toShares(_amount, true);\n    }\n\n    function previewRedeem(uint256 _shares) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, false);\n    }\n\n    function maxDeposit(address) external pure returns (uint256) {\n        return type(uint128).max;\n    }\n\n    function maxMint(address) external pure returns (uint256) {\n        return type(uint128).max;\n    }\n\n    function maxWithdraw(address owner) external view returns (uint256) {\n        return totalAsset.toAmount(balanceOf(owner), false);\n    }\n\n    function maxRedeem(address owner) external view returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    // ============================================================================================\n    // Functions: Helpers\n    // ============================================================================================\n\n    function getConstants()\n        external\n        pure\n        returns (\n            uint256 _LTV_PRECISION,\n            uint256 _LIQ_PRECISION,\n            uint256 _UTIL_PREC,\n            uint256 _FEE_PRECISION,\n            uint256 _EXCHANGE_PRECISION,\n            uint64 _DEFAULT_INT,\n            uint16 _DEFAULT_PROTOCOL_FEE,\n            uint256 _MAX_PROTOCOL_FEE\n        )\n    {\n        _LTV_PRECISION = LTV_PRECISION;\n        _LIQ_PRECISION = LIQ_PRECISION;\n        _UTIL_PREC = UTIL_PREC;\n        _FEE_PRECISION = FEE_PRECISION;\n        _EXCHANGE_PRECISION = EXCHANGE_PRECISION;\n        _DEFAULT_INT = DEFAULT_INT;\n        _DEFAULT_PROTOCOL_FEE = DEFAULT_PROTOCOL_FEE;\n        _MAX_PROTOCOL_FEE = MAX_PROTOCOL_FEE;\n    }\n\n    /// @notice The ```toBorrowShares``` function converts a given amount of borrow debt into the number of shares\n    /// @param _amount Amount of borrow\n    /// @param _roundUp Whether to roundup during division\n    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toShares(_amount, _roundUp);\n    }\n\n    /// @notice The ```toBorrtoBorrowAmountowShares``` function converts a given amount of borrow debt into the number of shares\n    /// @param _shares Shares of borrow\n    /// @param _roundUp Whether to roundup during division\n    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toAmount(_shares, _roundUp);\n    }\n\n    // ============================================================================================\n    // Functions: Protocol Configuration (Fees & Swap Contracts)\n    // ============================================================================================\n    /// @notice The ```SetTimeLock``` event fires when the TIME_LOCK_ADDRESS is set\n    /// @param _oldAddress The original address\n    /// @param _newAddress The new address\n    event SetTimeLock(address _oldAddress, address _newAddress);\n\n    /// @notice The ```setTimeLock``` function sets the TIME_LOCK address\n    /// @param _newAddress the new time lock address\n    function setTimeLock(address _newAddress) external onlyOwner {\n        emit SetTimeLock(TIME_LOCK_ADDRESS, _newAddress);\n        TIME_LOCK_ADDRESS = _newAddress;\n    }\n\n    /// @notice The ```ChangeFee``` event first when the fee is changed\n    /// @param _newFee The new fee\n    event ChangeFee(uint32 _newFee);\n\n    /// @notice The ```changeFee``` function changes the protocol fee, max 50%\n    /// @param _newFee The new fee\n    function changeFee(uint32 _newFee) external whenNotPaused {\n        if (msg.sender != TIME_LOCK_ADDRESS) revert OnlyTimeLock();\n        if (_newFee > MAX_PROTOCOL_FEE) {\n            revert BadProtocolFee();\n        }\n        currentRateInfo.feeToProtocolRate = _newFee;\n        emit ChangeFee(_newFee);\n    }\n\n    /// @notice The ```WithdrawFees``` event fires when the fees are withdrawn\n    /// @param _shares Number of _shares (fTokens) redeemed\n    /// @param _recipient To whom the assets were sent\n    /// @param _amountToTransfer The amount of fees redeemed\n    event WithdrawFees(uint128 _shares, address _recipient, uint256 _amountToTransfer);\n\n    /// @notice The ```withdrawFees``` function withdraws fees accumulated\n    /// @param _shares Number of fTokens to redeem\n    /// @param _recipient Address to send the assets\n    /// @return _amountToTransfer Amount of assets sent to recipient\n    function withdrawFees(uint128 _shares, address _recipient) external onlyOwner returns (uint256 _amountToTransfer) {\n        // Grab some data from state to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Take all available if 0 value passed\n        if (_shares == 0) _shares = uint128(balanceOf(address(this)));\n\n        // We must calculate this before we subtract from _totalAsset or invoke _burn\n        _amountToTransfer = _totalAsset.toAmount(_shares, true);\n\n        // Check for sufficient withdraw liquidity\n        uint256 _assetsAvailable = _totalAssetAvailable(_totalAsset, _totalBorrow);\n        if (_assetsAvailable < _amountToTransfer) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _amountToTransfer);\n        }\n\n        // Effects: bookkeeping\n        _totalAsset.amount -= uint128(_amountToTransfer);\n        _totalAsset.shares -= _shares;\n\n        // Effects: write to states\n        // NOTE: will revert if _shares > balanceOf(address(this))\n        _burn(address(this), _shares);\n        totalAsset = _totalAsset;\n\n        // Interactions\n        assetContract.safeTransfer(_recipient, _amountToTransfer);\n        emit WithdrawFees(_shares, _recipient, _amountToTransfer);\n    }\n\n    /// @notice The ```SetSwapper``` event fires whenever a swapper is black or whitelisted\n    /// @param _swapper The swapper address\n    /// @param _approval The approval\n    event SetSwapper(address _swapper, bool _approval);\n\n    /// @notice The ```setSwapper``` function is called to black or whitelist a given swapper address\n    /// @dev\n    /// @param _swapper The swapper address\n    /// @param _approval The approval\n    function setSwapper(address _swapper, bool _approval) external onlyOwner {\n        swappers[_swapper] = _approval;\n        emit SetSwapper(_swapper, _approval);\n    }\n\n    /// @notice The ```SetApprovedLender``` event fires when a lender is black or whitelisted\n    /// @param _address The address\n    /// @param _approval The approval\n    event SetApprovedLender(address indexed _address, bool _approval);\n\n    /// @notice The ```setApprovedLenders``` function sets a given set of addresses to the whitelist\n    /// @dev Cannot black list self\n    /// @param _lenders The addresses whos status will be set\n    /// @param _approval The approcal status\n    function setApprovedLenders(address[] calldata _lenders, bool _approval) external approvedLender(msg.sender) {\n        for (uint256 i = 0; i < _lenders.length; i++) {\n            // Do not set when _approval == false and _lender == msg.sender\n            if (_approval || _lenders[i] != msg.sender) {\n                approvedLenders[_lenders[i]] = _approval;\n                emit SetApprovedLender(_lenders[i], _approval);\n            }\n        }\n    }\n\n    /// @notice The ```SetApprovedBorrower``` event fires when a borrower is black or whitelisted\n    /// @param _address The address\n    /// @param _approval The approval\n    event SetApprovedBorrower(address indexed _address, bool _approval);\n\n    /// @notice The ```setApprovedBorrowers``` function sets a given array of addresses to the whitelist\n    /// @dev Cannot black list self\n    /// @param _borrowers The addresses whos status will be set\n    /// @param _approval The approcal status\n    function setApprovedBorrowers(address[] calldata _borrowers, bool _approval) external approvedBorrower {\n        for (uint256 i = 0; i < _borrowers.length; i++) {\n            // Do not set when _approval == false and _borrower == msg.sender\n            if (_approval || _borrowers[i] != msg.sender) {\n                approvedBorrowers[_borrowers[i]] = _approval;\n                emit SetApprovedBorrower(_borrowers[i], _approval);\n            }\n        }\n    }\n\n    function pause() external {\n        if (\n            msg.sender != CIRCUIT_BREAKER_ADDRESS &&\n            msg.sender != COMPTROLLER_ADDRESS &&\n            msg.sender != owner() &&\n            msg.sender != DEPLOYER_ADDRESS\n        ) {\n            revert ProtocolOrOwnerOnly();\n        }\n        _addInterest(); // accrue any interest prior to pausing as it won't accrue during pause\n        _pause();\n    }\n\n    function unpause() external {\n        if (msg.sender != COMPTROLLER_ADDRESS && msg.sender != owner()) {\n            revert ProtocolOrOwnerOnly();\n        }\n        // Resets the lastTimestamp which has the effect of no interest accruing over the pause period\n        _addInterest();\n        _unpause();\n    }\n}\n\n\n",
        "CodeNames": [
            "FraxlendPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FraxlendPair.sol",
                "Type": "EIP-4626 compliance issue",
                "Description": "FraxlendPair.sol is not fully EIP-4626 compliant, variation from the standard could break composability and potentially lead to loss of funds.",
                "Repair": "Update maxDeposit and maxMint functions to return 0 when the contract is paused"
            },
            {
                "Location": "FraxlendPair.changeFee()",
                "Type": "Interest calculation issue",
                "Description": "FraxlendPair.changeFee() doesn't update interest before changing fee.",
                "Repair": "Add _addInterest() before changing the fee"
            },
            {
                "Location": "FraxlendPair.sol#L206",
                "Type": "Arbitrary time lock address",
                "Description": "The owner of a deployed Fraxlend pair can change the currently used time lock contract address with the FraxlendPair.setTimeLock function, which can be used to circumvent the time lock on the FraxlendPair.changeFee function.",
                "Repair": "Add a bool which acts as a mutex if TIME_LOCK_ADDRESS has already been set, and modify setTimeLock function in FraxlendPair contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ====================== FraxlendPairDeployer ========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@rari-capital/solmate/src/utils/SSTORE2.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IFraxlendPair.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\n// solhint-disable no-inline-assembly\n\n/// @title FraxlendPairDeployer\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice Deploys and initializes new FraxlendPairs\n/// @dev Uses create2 to deploy the pairs, logs an event, and records a list of all deployed pairs\ncontract FraxlendPairDeployer is Ownable {\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    // Constants\n    uint256 public DEFAULT_MAX_LTV = 75000; // 75% with 1e5 precision\n    uint256 public GLOBAL_MAX_LTV = 1e8; // 1000x (100,000%) with 1e5 precision, protects from rounding errors in LTV calc\n    uint256 public DEFAULT_LIQ_FEE = 10000; // 10% with 1e5 precision\n\n    address private contractAddress1;\n    address private contractAddress2;\n\n    // Admin contracts\n    address public CIRCUIT_BREAKER_ADDRESS;\n    address public COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address private immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    /// @notice Emits when a new pair is deployed\n    /// @notice The ```LogDeploy``` event is emitted when a new Pair is deployed\n    /// @param _name The name of the Pair\n    /// @param _address The address of the pair\n    /// @param _asset The address of the Asset Token contract\n    /// @param _collateral The address of the Collateral Token contract\n    /// @param _oracleMultiply The address of the numerator price Oracle\n    /// @param _oracleDivide The address of the denominator price Oracle\n    /// @param _rateContract The address of the Rate Calculator contract\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    event LogDeploy(\n        string indexed _name,\n        address _address,\n        address indexed _asset,\n        address indexed _collateral,\n        address _oracleMultiply,\n        address _oracleDivide,\n        address _rateContract,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate\n    );\n\n    /// @notice CREATE2 salt => deployed address\n    mapping(bytes32 => address) public deployedPairsBySalt;\n    /// @notice hash of name => deployed address\n    mapping(string => address) public deployedPairsByName;\n    /// @notice address => isCustom boolean\n    mapping(address => bool) public deployedPairCustomStatusByAddress;\n    /// @notice List of the names of all deployed Pairs\n    string[] public deployedPairsArray;\n\n    constructor(\n        address _circuitBreaker,\n        address _comptroller,\n        address _timelock,\n        address _fraxlendWhitelist\n    ) Ownable() {\n        CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n        COMPTROLLER_ADDRESS = _comptroller;\n        TIME_LOCK_ADDRESS = _timelock;\n        FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelist;\n    }\n\n    // ============================================================================================\n    // Functions: View Functions\n    // ============================================================================================\n\n    /// @notice The ```deployedPairsLength``` function returns the length of the deployedPairsArray\n    /// @return length of array\n    function deployedPairsLength() external view returns (uint256) {\n        return deployedPairsArray.length;\n    }\n\n    /// @notice The ```getAllPairAddresses``` function returns all pair addresses in deployedPairsArray\n    /// @return memory All deployed pair addresses\n    function getAllPairAddresses() external view returns (address[] memory) {\n        string[] memory _deployedPairsArray = deployedPairsArray;\n        uint256 _lengthOfArray = _deployedPairsArray.length;\n        address[] memory _addresses = new address[](_lengthOfArray);\n        uint256 i;\n        for (i = 0; i < _lengthOfArray; ) {\n            _addresses[i] = deployedPairsByName[_deployedPairsArray[i]];\n            unchecked {\n                i++;\n            }\n        }\n        return _addresses;\n    }\n\n    struct PairCustomStatus {\n        address _address;\n        bool _isCustom;\n    }\n\n    /// @notice The ```getCustomStatuses``` function returns an array of structs which contain the address and custom status\n    /// @param _addresses Addresses to check for custom status\n    /// @return _pairCustomStatuses memory Array of structs containing information\n    function getCustomStatuses(address[] calldata _addresses)\n        external\n        view\n        returns (PairCustomStatus[] memory _pairCustomStatuses)\n    {\n        uint256 _lengthOfArray = _addresses.length;\n        uint256 i;\n        _pairCustomStatuses = new PairCustomStatus[](_lengthOfArray);\n        for (i = 0; i < _lengthOfArray; ) {\n            _pairCustomStatuses[i] = PairCustomStatus({\n                _address: _addresses[i],\n                _isCustom: deployedPairCustomStatusByAddress[_addresses[i]]\n            });\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    // ============================================================================================\n    // Functions: Setters\n    // ============================================================================================\n\n    /// @notice The ```setCreationCode``` function sets the bytecode for the fraxlendPair\n    /// @dev splits the data if necessary to accomodate creation code that is slightly larger than 24kb\n    /// @param _creationCode The creationCode for the Fraxlend Pair\n    function setCreationCode(bytes calldata _creationCode) external onlyOwner {\n        bytes memory _firstHalf = BytesLib.slice(_creationCode, 0, 13000);\n        contractAddress1 = SSTORE2.write(_firstHalf);\n        if (_creationCode.length > 13000) {\n            bytes memory _secondHalf = BytesLib.slice(_creationCode, 13000, _creationCode.length - 13000);\n            contractAddress2 = SSTORE2.write(_secondHalf);\n        }\n    }\n\n    // ============================================================================================\n    // Functions: Internal Methods\n    // ============================================================================================\n\n    /// @notice The ```_deployFirst``` function is an internal function with deploys the pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    /// @return _pairAddress The address to which the Pair was deployed\n    function _deployFirst(\n        bytes32 _saltSeed,\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    ) private returns (address _pairAddress) {\n        {\n            // _saltSeed is the same for all public pairs so duplicates cannot be created\n            bytes32 salt = keccak256(abi.encodePacked(_saltSeed, _configData));\n            require(deployedPairsBySalt[salt] == address(0), \"FraxlendPairDeployer: Pair already deployed\");\n\n            bytes memory _creationCode = BytesLib.concat(\n                SSTORE2.read(contractAddress1),\n                SSTORE2.read(contractAddress2)\n            );\n            bytes memory bytecode = abi.encodePacked(\n                _creationCode,\n                abi.encode(\n                    _configData,\n                    _immutables,\n                    _maxLTV,\n                    _liquidationFee,\n                    _maturityDate,\n                    _penaltyRate,\n                    _isBorrowerWhitelistActive,\n                    _isLenderWhitelistActive\n                )\n            );\n\n            assembly {\n                _pairAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\n            }\n            require(_pairAddress != address(0), \"FraxlendPairDeployer: create2 failed\");\n\n            deployedPairsBySalt[salt] = _pairAddress;\n        }\n\n        return _pairAddress;\n    }\n\n    /// @notice The ```_deploySecond``` function is the second part of deployment, it invoked the initialize() on the Pair\n    /// @param _name The name of the Pair\n    /// @param _pairAddress The address of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    function _deploySecond(\n        string memory _name,\n        address _pairAddress,\n        bytes memory _configData,\n        address[] memory _approvedBorrowers,\n        address[] memory _approvedLenders\n    ) private {\n        (, , , , , , bytes memory _rateInitData) = abi.decode(\n            _configData,\n            (address, address, address, address, uint256, address, bytes)\n        );\n        require(deployedPairsByName[_name] == address(0), \"FraxlendPairDeployer: Pair name must be unique\");\n        deployedPairsByName[_name] = _pairAddress;\n        deployedPairsArray.push(_name);\n\n        // Set additional values for FraxlendPair\n        IFraxlendPair _fraxlendPair = IFraxlendPair(_pairAddress);\n        _fraxlendPair.initialize(_name, _approvedBorrowers, _approvedLenders, _rateInitData);\n\n        // Transfer Ownership of FraxlendPair\n        _fraxlendPair.transferOwnership(COMPTROLLER_ADDRESS);\n    }\n\n    /// @notice The ```_logDeploy``` function emits a LogDeploy event\n    /// @param _name The name of the Pair\n    /// @param _pairAddress The address of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    function _logDeploy(\n        string memory _name,\n        address _pairAddress,\n        bytes memory _configData,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate\n    ) private {\n        (\n            address _asset,\n            address _collateral,\n            address _oracleMultiply,\n            address _oracleDivide,\n            ,\n            address _rateContract,\n\n        ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n        emit LogDeploy(\n            _name,\n            _pairAddress,\n            _asset,\n            _collateral,\n            _oracleMultiply,\n            _oracleDivide,\n            _rateContract,\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate\n        );\n    }\n\n    // ============================================================================================\n    // Functions: External Deploy Methods\n    // ============================================================================================\n\n    /// @notice The ```deploy``` function allows anyone to create a custom lending market between an Asset and Collateral Token\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @return _pairAddress The address to which the Pair was deployed\n    function deploy(bytes memory _configData) external returns (address _pairAddress) {\n        (address _asset, address _collateral, , , , address _rateContract, ) = abi.decode(\n            _configData,\n            (address, address, address, address, uint256, address, bytes)\n        );\n        string memory _name = string(\n            abi.encodePacked(\n                \"FraxlendV1 - \",\n                IERC20(_collateral).safeName(),\n                \"/\",\n                IERC20(_asset).safeName(),\n                \" - \",\n                IRateCalculator(_rateContract).name(),\n                \" - \",\n                (deployedPairsArray.length + 1).toString()\n            )\n        );\n\n        _pairAddress = _deployFirst(\n            keccak256(abi.encodePacked(\"public\")),\n            _configData,\n            abi.encode(CIRCUIT_BREAKER_ADDRESS, COMPTROLLER_ADDRESS, TIME_LOCK_ADDRESS, FRAXLEND_WHITELIST_ADDRESS),\n            DEFAULT_MAX_LTV,\n            DEFAULT_LIQ_FEE,\n            0,\n            0,\n            false,\n            false\n        );\n\n        _deploySecond(_name, _pairAddress, _configData, new address[](0), new address[](0));\n\n        _logDeploy(_name, _pairAddress, _configData, DEFAULT_MAX_LTV, DEFAULT_LIQ_FEE, 0);\n    }\n\n    /// @notice The ```deployCustom``` function allows whitelisted users to deploy custom Term Sheets for OTC debt structuring\n    /// @dev Caller must be added to FraxLedWhitelist\n    /// @param _name The name of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    /// @return _pairAddress The address to which the Pair was deployed\n    function deployCustom(\n        string memory _name,\n        bytes memory _configData,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        address[] memory _approvedBorrowers,\n        address[] memory _approvedLenders\n    ) external returns (address _pairAddress) {\n        require(_maxLTV <= GLOBAL_MAX_LTV, \"FraxlendPairDeployer: _maxLTV is too large\");\n        require(\n            IFraxlendWhitelist(FRAXLEND_WHITELIST_ADDRESS).fraxlendDeployerWhitelist(msg.sender),\n            \"FraxlendPairDeployer: Only whitelisted addresses\"\n        );\n\n        _pairAddress = _deployFirst(\n            keccak256(abi.encodePacked(_name)),\n            _configData,\n            abi.encode(CIRCUIT_BREAKER_ADDRESS, COMPTROLLER_ADDRESS, TIME_LOCK_ADDRESS, FRAXLEND_WHITELIST_ADDRESS),\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate,\n            _penaltyRate,\n            _approvedBorrowers.length > 0,\n            _approvedLenders.length > 0\n        );\n\n        _deploySecond(_name, _pairAddress, _configData, _approvedBorrowers, _approvedLenders);\n\n        deployedPairCustomStatusByAddress[_pairAddress] = true;\n\n        _logDeploy(_name, _pairAddress, _configData, _maxLTV, _liquidationFee, _maturityDate);\n    }\n\n    // ============================================================================================\n    // Functions: Admin\n    // ============================================================================================\n\n    /// @notice The ```globalPause``` function calls the pause() function on a given set of pair addresses\n    /// @dev Ignores reverts when calling pause()\n    /// @param _addresses Addresses to attempt to pause()\n    /// @return _updatedAddresses Addresses for which pause() was successful\n    function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {\n        require(msg.sender == CIRCUIT_BREAKER_ADDRESS, \"Circuit Breaker only\");\n        address _pairAddress;\n        uint256 _lengthOfArray = _addresses.length;\n        for (uint256 i = 0; i < _lengthOfArray; ) {\n            _pairAddress = _addresses[i];\n            try IFraxlendPair(_pairAddress).pause() {\n                _updatedAddresses[i] = _addresses[i];\n            } catch {}\n            unchecked {\n                i = i + 1;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "FraxlendPairDeployer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FraxlendPairDeployer.sol",
                "Type": "Front-running",
                "Description": "The FraxlendPairDeployer contract used to deploy Fraxlend pairs prevents deploying pairs with the same salt and _configData, making it vulnerable to front-running pair deployments and preventing deploying honest Fraxlend pairs.",
                "Repair": "Validate the _name parameter in the FraxlendPairDeployer.deployCustom function to not equal the string public, thus preventing the usage of the same salt as a standard pair deployment. Additionally, consider prefixing the name of a custom pair deployment to also prevent front-running this way."
            },
            {
                "Location": "FraxlendPairDeployer.sol#L405",
                "Type": "Denial of service",
                "Description": "The globalPause method is not tested and it doesn't work as expected. When you want to set the value of the _updatedAddresses array, it fails because it has never been initialized.",
                "Repair": "Initialize the _updatedAddresses array before setting its value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================= FraxlendPairCore =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./FraxlendPairConstants.sol\";\nimport \"./libraries/VaultAccount.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/ISwapper.sol\";\n\n/// @title FraxlendPairCore\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice  An abstract contract which contains the core logic and storage for the FraxlendPair\nabstract contract FraxlendPairCore is FraxlendPairConstants, IERC4626, ERC20, Ownable, Pausable, ReentrancyGuard {\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    string public version = \"1.0.0\";\n\n    // ============================================================================================\n    // Settings set by constructor() & initialize()\n    // ============================================================================================\n\n    // Asset and collateral contracts\n    IERC20 internal immutable assetContract;\n    IERC20 public immutable collateralContract;\n\n    // Oracle wrapper contract and oracleData\n    address public immutable oracleMultiply;\n    address public immutable oracleDivide;\n    uint256 public immutable oracleNormalization;\n\n    // LTV Settings\n    uint256 public immutable maxLTV;\n\n    // Liquidation Fee\n    uint256 public immutable cleanLiquidationFee;\n    uint256 public immutable dirtyLiquidationFee;\n\n    // Interest Rate Calculator Contract\n    IRateCalculator public immutable rateContract; // For complex rate calculations\n    bytes public rateInitCallData; // Optional extra data from init function to be passed to rate calculator\n\n    // Swapper\n    mapping(address => bool) public swappers; // approved swapper addresses\n\n    // Deployer\n    address public immutable DEPLOYER_ADDRESS;\n\n    // Admin contracts\n    address public immutable CIRCUIT_BREAKER_ADDRESS;\n    address public immutable COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address public immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    // ERC20 token name, accessible via name()\n    string internal nameOfContract;\n\n    // Maturity Date & Penalty Interest Rate (per Sec)\n    uint256 public immutable maturityDate;\n    uint256 public immutable penaltyRate;\n\n    // ============================================================================================\n    // Storage\n    // ============================================================================================\n\n    /// @notice Stores information about the current interest rate\n    /// @dev struct is packed to reduce SLOADs. feeToProtocolRate is 1e5 precision, ratePerSec is 1e18 precision\n    CurrentRateInfo public currentRateInfo;\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 feeToProtocolRate; // Fee amount 1e5 precision\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @notice Stores information about the current exchange rate. Collateral:Asset ratio\n    /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token\n    ExchangeRateInfo public exchangeRateInfo;\n    struct ExchangeRateInfo {\n        uint32 lastTimestamp;\n        uint224 exchangeRate; // collateral:asset ratio. i.e. how much collateral to buy 1e18 asset\n    }\n\n    // Contract Level Accounting\n    VaultAccount public totalAsset; // amount = total amount of assets, shares = total shares outstanding\n    VaultAccount public totalBorrow; // amount = total borrow amount with interest accrued, shares = total shares outstanding\n    uint256 public totalCollateral; // total amount of collateral in contract\n\n    // User Level Accounting\n    /// @notice Stores the balance of collateral for each user\n    mapping(address => uint256) public userCollateralBalance; // amount of collateral each user is backed\n    /// @notice Stores the balance of borrow shares for each user\n    mapping(address => uint256) public userBorrowShares; // represents the shares held by individuals\n    // NOTE: user shares of assets are represented as ERC-20 tokens and accessible via balanceOf()\n\n    // Internal Whitelists\n    bool public immutable borrowerWhitelistActive;\n    mapping(address => bool) public approvedBorrowers;\n\n    bool public immutable lenderWhitelistActive;\n    mapping(address => bool) public approvedLenders;\n\n    // ============================================================================================\n    // Initialize\n    // ============================================================================================\n\n    /// @notice The ```constructor``` function is called on deployment\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate date of the Pair\n    /// @param _penaltyRate The interest rate after maturity date\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    constructor(\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    ) {\n        // Handle Immutables Configuration\n        {\n            (\n                address _circuitBreaker,\n                address _comptrollerAddress,\n                address _timeLockAddress,\n                address _fraxlendWhitelistAddress\n            ) = abi.decode(_immutables, (address, address, address, address));\n\n            // Deployer contract\n            DEPLOYER_ADDRESS = msg.sender;\n            CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n            COMPTROLLER_ADDRESS = _comptrollerAddress;\n            TIME_LOCK_ADDRESS = _timeLockAddress;\n            FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelistAddress;\n        }\n\n        {\n            (\n                address _asset,\n                address _collateral,\n                address _oracleMultiply,\n                address _oracleDivide,\n                uint256 _oracleNormalization,\n                address _rateContract,\n\n            ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n\n            // Pair Settings\n            assetContract = IERC20(_asset);\n            collateralContract = IERC20(_collateral);\n            currentRateInfo.feeToProtocolRate = DEFAULT_PROTOCOL_FEE;\n            cleanLiquidationFee = _liquidationFee;\n            dirtyLiquidationFee = (_liquidationFee * 9000) / LIQ_PRECISION; // 90% of clean fee\n\n            if (_maxLTV >= LTV_PRECISION && !_isBorrowerWhitelistActive) revert BorrowerWhitelistRequired();\n            maxLTV = _maxLTV;\n\n            // Swapper Settings\n            swappers[FRAXSWAP_ROUTER_ADDRESS] = true;\n\n            // Oracle Settings\n            {\n                IFraxlendWhitelist _fraxlendWhitelist = IFraxlendWhitelist(FRAXLEND_WHITELIST_ADDRESS);\n                // Check that oracles are on the whitelist\n                if (_oracleMultiply != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleMultiply)) {\n                    revert NotOnWhitelist(_oracleMultiply);\n                }\n\n                if (_oracleDivide != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleDivide)) {\n                    revert NotOnWhitelist(_oracleDivide);\n                }\n\n                // Write oracleData to storage\n                oracleMultiply = _oracleMultiply;\n                oracleDivide = _oracleDivide;\n                oracleNormalization = _oracleNormalization;\n\n                // Rate Settings\n                if (!_fraxlendWhitelist.rateContractWhitelist(_rateContract)) {\n                    revert NotOnWhitelist(_rateContract);\n                }\n            }\n\n            rateContract = IRateCalculator(_rateContract);\n        }\n\n        // Set approved borrowers whitelist\n        borrowerWhitelistActive = _isBorrowerWhitelistActive;\n\n        // Set approved lenders whitlist active\n        lenderWhitelistActive = _isLenderWhitelistActive;\n\n        // Set maturity date & penalty interest rate\n        maturityDate = _maturityDate;\n        penaltyRate = _penaltyRate;\n    }\n\n    /// @notice The ```initialize``` function is called immediately after deployment\n    /// @dev This function can only be called by the deployer\n    /// @param _name The name of the contract\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    /// @param _rateInitCallData The configuration data for the Rate Calculator contract\n    function initialize(\n        string calldata _name,\n        address[] calldata _approvedBorrowers,\n        address[] calldata _approvedLenders,\n        bytes calldata _rateInitCallData\n    ) external {\n        if (msg.sender != DEPLOYER_ADDRESS) {\n            revert NotDeployer();\n        }\n        if (bytes(_name).length == 0) {\n            revert NameEmpty();\n        }\n        if (bytes(nameOfContract).length != 0) {\n            revert AlreadyInitialized();\n        }\n\n        // Set name\n        nameOfContract = _name;\n\n        // Set approved borrowers\n        for (uint256 i = 0; i < _approvedBorrowers.length; ++i) {\n            approvedBorrowers[_approvedBorrowers[i]] = true;\n        }\n\n        // Set approved lenders\n        for (uint256 i = 0; i < _approvedLenders.length; ++i) {\n            approvedLenders[_approvedLenders[i]] = true;\n        }\n\n        // Reverts if init data is not valid\n        IRateCalculator(rateContract).requireValidInitData(_rateInitCallData);\n\n        // Set rate init Data\n        rateInitCallData = _rateInitCallData;\n\n        // Instantiate Interest\n        _addInterest();\n\n        // Instantiate Exchange Rate\n        _updateExchangeRate();\n    }\n\n    // ============================================================================================\n    // Internal Helpers\n    // ============================================================================================\n\n    /// @notice The ```_totalAssetAvailable``` function returns the total balance of Asset Tokens in the contract\n    /// @param _totalAsset VaultAccount struct which stores total amount and shares for assets\n    /// @param _totalBorrow VaultAccount struct which stores total amount and shares for borrows\n    /// @return The balance of Asset Tokens held by contract\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _totalAsset.amount - _totalBorrow.amount;\n    }\n\n    /// @notice The ```_isSolvent``` function determines if a given borrower is solvent given an exchange rate\n    /// @param _borrower The borrower address to check\n    /// @param _exchangeRate The exchange rate, i.e. the amount of collateral to buy 1e18 asset\n    /// @return Whether borrower is solvent\n    function _isSolvent(address _borrower, uint256 _exchangeRate) internal view returns (bool) {\n        if (maxLTV == 0) return true;\n        uint256 _borrowerAmount = totalBorrow.toAmount(userBorrowShares[_borrower], true);\n        if (_borrowerAmount == 0) return true;\n        uint256 _collateralAmount = userCollateralBalance[_borrower];\n        if (_collateralAmount == 0) return false;\n\n        uint256 _ltv = (((_borrowerAmount * _exchangeRate) / EXCHANGE_PRECISION) * LTV_PRECISION) / _collateralAmount;\n        return _ltv <= maxLTV;\n    }\n\n    /// @notice The ```_isPastMaturity``` function determines if the current block timestamp is past the maturityDate date\n    /// @return Whether or not the debt is past maturity\n    function _isPastMaturity() internal view returns (bool) {\n        return maturityDate != 0 && block.timestamp > maturityDate;\n    }\n\n    // ============================================================================================\n    // Modifiers\n    // ============================================================================================\n\n    /// @notice Checks for solvency AFTER executing contract code\n    /// @param _borrower The borrower whose solvency we will check\n    modifier isSolvent(address _borrower) {\n        _;\n        if (!_isSolvent(_borrower, exchangeRateInfo.exchangeRate)) {\n            revert Insolvent(\n                totalBorrow.toAmount(userBorrowShares[_borrower], true),\n                userCollateralBalance[_borrower],\n                exchangeRateInfo.exchangeRate\n            );\n        }\n    }\n\n    /// @notice Checks if msg.sender is an approved Borrower\n    modifier approvedBorrower() {\n        if (borrowerWhitelistActive && !approvedBorrowers[msg.sender]) {\n            revert OnlyApprovedBorrowers();\n        }\n        _;\n    }\n\n    /// @notice Checks if msg.sender and _receiver are both an approved Lender\n    /// @param _receiver An additional receiver address to check\n    modifier approvedLender(address _receiver) {\n        if (lenderWhitelistActive && (!approvedLenders[msg.sender] || !approvedLenders[_receiver])) {\n            revert OnlyApprovedLenders();\n        }\n        _;\n    }\n\n    /// @notice Ensure function is not called when passed maturity\n    modifier isNotPastMaturity() {\n        if (_isPastMaturity()) {\n            revert PastMaturity();\n        }\n        _;\n    }\n\n    // ============================================================================================\n    // Functions: Interest Accumulation and Adjustment\n    // ============================================================================================\n\n    /// @notice The ```AddInterest``` event is emitted when interest is accrued by borrowers\n    /// @param _interestEarned The total interest accrued by all borrowers\n    /// @param _rate The interest rate used to calculate accrued interest\n    /// @param _deltaTime The time elapsed since last interest accrual\n    /// @param _feesAmount The amount of fees paid to protocol\n    /// @param _feesShare The amount of shares distributed to protocol\n    event AddInterest(\n        uint256 _interestEarned,\n        uint256 _rate,\n        uint256 _deltaTime,\n        uint256 _feesAmount,\n        uint256 _feesShare\n    );\n\n    /// @notice The ```UpdateRate``` event is emitted when the interest rate is updated\n    /// @param _ratePerSec The old interest rate (per second)\n    /// @param _deltaTime The time elapsed since last update\n    /// @param _utilizationRate The utilization of assets in the Pair\n    /// @param _newRatePerSec The new interest rate (per second)\n    event UpdateRate(uint256 _ratePerSec, uint256 _deltaTime, uint256 _utilizationRate, uint256 _newRatePerSec);\n\n    /// @notice The ```addInterest``` function is a public implementation of _addInterest and allows 3rd parties to trigger interest accrual\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function addInterest()\n        external\n        nonReentrant\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        return _addInterest();\n    }\n\n    /// @notice The ```_addInterest``` function is invoked prior to every external function and is used to accrue interest and update interest rate\n    /// @dev Can only called once per block\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function _addInterest()\n        internal\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        // Add interest only once per block\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\n            _newRate = _currentRateInfo.ratePerSec;\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\n        }\n\n        // Pull some data from storage to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // If there are no borrows or contract is paused, no interest accrues and we reset interest rate\n        if (_totalBorrow.shares == 0 || paused()) {\n            if (!paused()) {\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\n            }\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Effects: write to storage\n            currentRateInfo = _currentRateInfo;\n        } else {\n            // We know totalBorrow.shares > 0\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\n\n            // NOTE: Violates Checks-Effects-Interactions pattern\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\n            // Calc new rate\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\n            if (_isPastMaturity()) {\n                _newRate = uint64(penaltyRate);\n            } else {\n                bytes memory _rateData = abi.encode(\n                    _currentRateInfo.ratePerSec,\n                    _deltaTime,\n                    _utilizationRate,\n                    block.number - _currentRateInfo.lastBlock\n                );\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\n            }\n\n            // Event must be here to use non-mutated values\n            emit UpdateRate(_currentRateInfo.ratePerSec, _deltaTime, _utilizationRate, _newRate);\n\n            // Effects: bookkeeping\n            _currentRateInfo.ratePerSec = _newRate;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Calculate interest accrued\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\n\n            // Accumulate interest and fees, only if no overflow upon casting\n            if (\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\n                _interestEarned + _totalAsset.amount <= type(uint128).max\n            ) {\n                _totalBorrow.amount += uint128(_interestEarned);\n                _totalAsset.amount += uint128(_interestEarned);\n                if (_currentRateInfo.feeToProtocolRate > 0) {\n                    _feesAmount = (_interestEarned * _currentRateInfo.feeToProtocolRate) / FEE_PRECISION;\n\n                    _feesShare = (_feesAmount * _totalAsset.shares) / (_totalAsset.amount - _feesAmount);\n\n                    // Effects: Give new shares to this contract, effectively diluting lenders an amount equal to the fees\n                    // We can safely cast because _feesShare < _feesAmount < interestEarned which is always less than uint128\n                    _totalAsset.shares += uint128(_feesShare);\n\n                    // Effects: write to storage\n                    _mint(address(this), _feesShare);\n                }\n                emit AddInterest(_interestEarned, _currentRateInfo.ratePerSec, _deltaTime, _feesAmount, _feesShare);\n            }\n\n            // Effects: write to storage\n            totalAsset = _totalAsset;\n            currentRateInfo = _currentRateInfo;\n            totalBorrow = _totalBorrow;\n        }\n    }\n\n    // ============================================================================================\n    // Functions: ExchangeRate\n    // ============================================================================================\n    /// @notice The ```UpdateExchangeRate``` event is emitted when the Collateral:Asset exchange rate is updated\n    /// @param _rate The new rate given as the amount of Collateral Token to buy 1e18 Asset Token\n    event UpdateExchangeRate(uint256 _rate);\n\n    /// @notice The ```updateExchangeRate``` function is the external implementation of _updateExchangeRate.\n    /// @dev This function is invoked at most once per block as these queries can be expensive\n    /// @return _exchangeRate The new exchange rate\n    function updateExchangeRate() external nonReentrant returns (uint256 _exchangeRate) {\n        _exchangeRate = _updateExchangeRate();\n    }\n\n    /// @notice The ```_updateExchangeRate``` function retrieves the latest exchange rate. i.e how much collateral to buy 1e18 asset.\n    /// @dev This function is invoked at most once per block as these queries can be expensive\n    /// @return _exchangeRate The new exchange rate\n    function _updateExchangeRate() internal returns (uint256 _exchangeRate) {\n        ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;\n        if (_exchangeRateInfo.lastTimestamp == block.timestamp) {\n            return _exchangeRate = _exchangeRateInfo.exchangeRate;\n        }\n\n        uint256 _price = uint256(1e36);\n        if (oracleMultiply != address(0)) {\n            (, int256 _answer, , , ) = AggregatorV3Interface(oracleMultiply).latestRoundData();\n            if (_answer <= 0) {\n                revert OracleLTEZero(oracleMultiply);\n            }\n            _price = _price * uint256(_answer);\n        }\n\n        if (oracleDivide != address(0)) {\n            (, int256 _answer, , , ) = AggregatorV3Interface(oracleDivide).latestRoundData();\n            if (_answer <= 0) {\n                revert OracleLTEZero(oracleDivide);\n            }\n            _price = _price / uint256(_answer);\n        }\n\n        _exchangeRate = _price / oracleNormalization;\n\n        // write to storage, if no overflow\n        if (_exchangeRate > type(uint224).max) revert PriceTooLarge();\n        _exchangeRateInfo.exchangeRate = uint224(_exchangeRate);\n        _exchangeRateInfo.lastTimestamp = uint32(block.timestamp);\n        exchangeRateInfo = _exchangeRateInfo;\n        emit UpdateExchangeRate(_exchangeRate);\n    }\n\n    // ============================================================================================\n    // Functions: Lending\n    // ============================================================================================\n\n    /// @notice The ```_deposit``` function is the internal implementation for lending assets\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _totalAsset An in memory VaultAccount struct representing the total amounts and shares for the Asset Token\n    /// @param _amount The amount of Asset Token to be transferred\n    /// @param _shares The amount of Asset Shares (fTokens) to be minted\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    function _deposit(\n        VaultAccount memory _totalAsset,\n        uint128 _amount,\n        uint128 _shares,\n        address _receiver\n    ) internal {\n        // Effects: bookkeeping\n        _totalAsset.amount += _amount;\n        _totalAsset.shares += _shares;\n\n        // Effects: write back to storage\n        _mint(_receiver, _shares);\n        totalAsset = _totalAsset;\n\n        // Interactions\n        assetContract.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Deposit(msg.sender, _receiver, _amount, _shares);\n    }\n\n    /// @notice The ```deposit``` function allows a user to Lend Assets by specifying the amount of Asset Tokens to lend\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _amount The amount of Asset Token to transfer to Pair\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _sharesReceived The number of fTokens received for the deposit\n    function deposit(uint256 _amount, address _receiver)\n        external\n        nonReentrant\n        isNotPastMaturity\n        whenNotPaused\n        approvedLender(_receiver)\n        returns (uint256 _sharesReceived)\n    {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _sharesReceived = _totalAsset.toShares(_amount, false);\n        _deposit(_totalAsset, _amount.toUint128(), _sharesReceived.toUint128(), _receiver);\n    }\n\n    /// @notice The ```mint``` function allows a user to Lend assets by specifying the number of Assets Shares (fTokens) to mint\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _shares The number of Asset Shares (fTokens) that a user wants to mint\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _amountReceived The amount of Asset Tokens transferred to the Pair\n    function mint(uint256 _shares, address _receiver)\n        external\n        nonReentrant\n        isNotPastMaturity\n        whenNotPaused\n        approvedLender(_receiver)\n        returns (uint256 _amountReceived)\n    {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _amountReceived = _totalAsset.toAmount(_shares, true);\n        _deposit(_totalAsset, _amountReceived.toUint128(), _shares.toUint128(), _receiver);\n    }\n\n    /// @notice The ```_redeem``` function is an internal implementation which allows a Lender to pull their Asset Tokens out of the Pair\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _totalAsset An in-memory VaultAccount struct which holds the total amount of Asset Tokens and the total number of Asset Shares (fTokens)\n    /// @param _amountToReturn The number of Asset Tokens to return\n    /// @param _shares The number of Asset Shares (fTokens) to burn\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    function _redeem(\n        VaultAccount memory _totalAsset,\n        uint128 _amountToReturn,\n        uint128 _shares,\n        address _receiver,\n        address _owner\n    ) internal {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance(_owner, msg.sender);\n            // NOTE: This will revert on underflow ensuring that allowance > shares\n            if (allowed != type(uint256).max) _approve(_owner, msg.sender, allowed - _shares);\n        }\n\n        // Check for sufficient withdraw liquidity\n        uint256 _assetsAvailable = _totalAssetAvailable(_totalAsset, totalBorrow);\n        if (_assetsAvailable < _amountToReturn) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _amountToReturn);\n        }\n\n        // Effects: bookkeeping\n        _totalAsset.amount -= _amountToReturn;\n        _totalAsset.shares -= _shares;\n\n        // Effects: write to storage\n        totalAsset = _totalAsset;\n        _burn(_owner, _shares);\n\n        // Interactions\n        assetContract.safeTransfer(_receiver, _amountToReturn);\n        emit Withdraw(msg.sender, _receiver, _owner, _amountToReturn, _shares);\n    }\n\n    /// @notice The ```redeem``` function allows the caller to redeem their Asset Shares for Asset Tokens\n    /// @param _shares The number of Asset Shares (fTokens) to burn for Asset Tokens\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _amountToReturn The amount of Asset Tokens to be transferred\n    function redeem(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) external nonReentrant returns (uint256 _amountToReturn) {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _amountToReturn = _totalAsset.toAmount(_shares, false);\n        _redeem(_totalAsset, _amountToReturn.toUint128(), _shares.toUint128(), _receiver, _owner);\n    }\n\n    /// @notice The ```withdraw``` function allows a user to redeem their Asset Shares for a specified amount of Asset Tokens\n    /// @param _amount The amount of Asset Tokens to be transferred in exchange for burning Asset Shares\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _shares The number of Asset Shares (fTokens) burned\n    function withdraw(\n        uint256 _amount,\n        address _receiver,\n        address _owner\n    ) external nonReentrant returns (uint256 _shares) {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _shares = _totalAsset.toShares(_amount, true);\n        _redeem(_totalAsset, _amount.toUint128(), _shares.toUint128(), _receiver, _owner);\n    }\n\n    // ============================================================================================\n    // Functions: Borrowing\n    // ============================================================================================\n\n    /// @notice The ```BorrowAsset``` event is emitted when a borrower increases their position\n    /// @param _borrower The borrower whose account was debited\n    /// @param _receiver The address to which the Asset Tokens were transferred\n    /// @param _borrowAmount The amount of Asset Tokens transferred\n    /// @param _sharesAdded The number of Borrow Shares the borrower was debited\n    event BorrowAsset(\n        address indexed _borrower,\n        address indexed _receiver,\n        uint256 _borrowAmount,\n        uint256 _sharesAdded\n    );\n\n    /// @notice The ```_borrowAsset``` function is the internal implementation for borrowing assets\n    /// @param _borrowAmount The amount of the Asset Token to borrow\n    /// @param _receiver The address to receive the Asset Tokens\n    /// @return _sharesAdded The amount of borrow shares the msg.sender will be debited\n    function _borrowAsset(uint128 _borrowAmount, address _receiver) internal returns (uint256 _sharesAdded) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Check available capital\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _borrowAmount);\n        }\n\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\n        _sharesAdded = _totalBorrow.toShares(_borrowAmount, true);\n        _totalBorrow.amount += _borrowAmount;\n        _totalBorrow.shares += uint128(_sharesAdded);\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\n\n        // Effects: write back to storage\n        totalBorrow = _totalBorrow;\n        userBorrowShares[msg.sender] += _sharesAdded;\n\n        // Interactions\n        if (_receiver != address(this)) {\n            assetContract.safeTransfer(_receiver, _borrowAmount);\n        }\n        emit BorrowAsset(msg.sender, _receiver, _borrowAmount, _sharesAdded);\n    }\n\n    /// @notice The ```borrowAsset``` function allows a user to open/increase a borrow position\n    /// @dev Borrower must call ```ERC20.approve``` on the Collateral Token contract if applicable\n    /// @param _borrowAmount The amount of Asset Token to borrow\n    /// @param _collateralAmount The amount of Collateral Token to transfer to Pair\n    /// @param _receiver The address which will receive the Asset Tokens\n    /// @return _shares The number of borrow Shares the msg.sender will be debited\n    function borrowAsset(\n        uint256 _borrowAmount,\n        uint256 _collateralAmount,\n        address _receiver\n    )\n        external\n        isNotPastMaturity\n        whenNotPaused\n        nonReentrant\n        isSolvent(msg.sender)\n        approvedBorrower\n        returns (uint256 _shares)\n    {\n        _addInterest();\n        _updateExchangeRate();\n        if (_collateralAmount > 0) {\n            _addCollateral(msg.sender, _collateralAmount, msg.sender);\n        }\n        _shares = _borrowAsset(_borrowAmount.toUint128(), _receiver);\n    }\n\n    event AddCollateral(address indexed _sender, address indexed _borrower, uint256 _collateralAmount);\n\n    /// @notice The ```_addCollateral``` function is an internal implementation for adding collateral to a borrowers position\n    /// @param _sender The source of funds for the new collateral\n    /// @param _collateralAmount The amount of Collateral Token to be transferred\n    /// @param _borrower The borrower account for which the collateral should be credited\n    function _addCollateral(\n        address _sender,\n        uint256 _collateralAmount,\n        address _borrower\n    ) internal {\n        // Effects: write to state\n        userCollateralBalance[_borrower] += _collateralAmount;\n        totalCollateral += _collateralAmount;\n\n        // Interactions\n        if (_sender != address(this)) {\n            collateralContract.safeTransferFrom(_sender, address(this), _collateralAmount);\n        }\n        emit AddCollateral(_sender, _borrower, _collateralAmount);\n    }\n\n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\n    /// @param _borrower The account to be credited\n    function addCollateral(uint256 _collateralAmount, address _borrower) external nonReentrant isNotPastMaturity {\n        _addInterest();\n        _addCollateral(msg.sender, _collateralAmount, _borrower);\n    }\n\n    /// @notice The ```RemoveCollateral``` event is emitted when collateral is removed from a borrower's position\n    /// @param _sender The account from which funds are transferred\n    /// @param _collateralAmount The amount of Collateral Token to be transferred\n    /// @param _receiver The address to which Collateral Tokens will be transferred\n    event RemoveCollateral(\n        address indexed _sender,\n        uint256 _collateralAmount,\n        address indexed _receiver,\n        address indexed _borrower\n    );\n\n    /// @notice The ```_removeCollateral``` function is the internal implementation for removing collateral from a borrower's position\n    /// @param _collateralAmount The amount of Collateral Token to remove from the borrower's position\n    /// @param _receiver The address to receive the Collateral Token transferred\n    /// @param _borrower The borrower whose account will be debited the Collateral amount\n    function _removeCollateral(\n        uint256 _collateralAmount,\n        address _receiver,\n        address _borrower\n    ) internal {\n        // Effects: write to state\n        // Following line will revert on underflow if _collateralAmount > userCollateralBalance\n        userCollateralBalance[_borrower] -= _collateralAmount;\n        // Following line will revert on underflow if totalCollateral < _collateralAmount\n        totalCollateral -= _collateralAmount;\n\n        // Interactions\n        if (_receiver != address(this)) {\n            collateralContract.safeTransfer(_receiver, _collateralAmount);\n        }\n        emit RemoveCollateral(msg.sender, _collateralAmount, _receiver, _borrower);\n    }\n\n    /// @notice The ```removeCollateral``` function is used to remove collateral from msg.sender's borrow position\n    /// @dev msg.sender must be solvent after invocation or transaction will revert\n    /// @param _collateralAmount The amount of Collateral Token to transfer\n    /// @param _receiver The address to receive the transferred funds\n    function removeCollateral(uint256 _collateralAmount, address _receiver)\n        external\n        nonReentrant\n        isSolvent(msg.sender)\n    {\n        _addInterest();\n        // Note: exchange rate is irrelevant when borrower has no debt shares\n        if (userBorrowShares[msg.sender] > 0) {\n            _updateExchangeRate();\n        }\n        _removeCollateral(_collateralAmount, _receiver, msg.sender);\n    }\n\n    /// @notice The ```RepayAsset``` event is emitted whenever a debt position is repaid\n    /// @param _sender The msg.sender of the transaction\n    /// @param _borrower The borrower whose account will be credited\n    /// @param _amountToRepay The amount of Asset token to be transferred\n    /// @param _shares The amount of Borrow Shares which will be debited from the borrower after repayment\n    event RepayAsset(address indexed _sender, address indexed _borrower, uint256 _amountToRepay, uint256 _shares);\n\n    /// @notice The ```_repayAsset``` function is the internal implementation for repaying a borrow position\n    /// @dev The payer must have called ERC20.approve() on the Asset Token contract prior to invocation\n    /// @param _totalBorrow An in memory copy of the totalBorrow VaultAccount struct\n    /// @param _amountToRepay The amount of Asset Token to transfer\n    /// @param _shares The number of Borrow Shares the sender is repaying\n    /// @param _payer The address from which funds will be transferred\n    /// @param _borrower The borrower account which will be credited\n    function _repayAsset(\n        VaultAccount memory _totalBorrow,\n        uint128 _amountToRepay,\n        uint128 _shares,\n        address _payer,\n        address _borrower\n    ) internal {\n        // Effects: Bookkeeping\n        _totalBorrow.amount -= _amountToRepay;\n        _totalBorrow.shares -= _shares;\n\n        // Effects: write to state\n        userBorrowShares[_borrower] -= _shares;\n        totalBorrow = _totalBorrow;\n\n        // Interactions\n        if (_payer != address(this)) {\n            assetContract.safeTransferFrom(_payer, address(this), _amountToRepay);\n        }\n        emit RepayAsset(msg.sender, _borrower, _amountToRepay, _shares);\n    }\n\n    /// @notice The ```repayAsset``` function allows the caller to pay down the debt for a given borrower.\n    /// @dev Caller must first invoke ```ERC20.approve()``` for the Asset Token contract\n    /// @param _shares The number of Borrow Shares which will be repaid by the call\n    /// @param _borrower The account for which the debt will be reduced\n    /// @return _amountToRepay The amount of Asset Tokens which were transferred in order to repay the Borrow Shares\n    function repayAsset(uint256 _shares, address _borrower) external nonReentrant returns (uint256 _amountToRepay) {\n        _addInterest();\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        _repayAsset(_totalBorrow, _amountToRepay.toUint128(), _shares.toUint128(), msg.sender, _borrower);\n    }\n\n    // ============================================================================================\n    // Functions: Liquidations\n    // ============================================================================================\n    /// @notice The ```Liquidate``` event is emitted when a liquidation occurs\n    /// @param _borrower The borrower account for which the liquidation occured\n    /// @param _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    /// @param _sharesToLiquidate The number of Borrow Shares the liquidator repaid on behalf of the borrower\n    /// @param _sharesToAdjust The number of Borrow Shares that were adjusted on liabilites and assets (a writeoff)\n    event Liquidate(\n        address indexed _borrower,\n        uint256 _collateralForLiquidator,\n        uint256 _sharesToLiquidate,\n        uint256 _amountLiquidatorToRepay,\n        uint256 _sharesToAdjust,\n        uint256 _amountToAdjust\n    );\n\n    /// @notice The ```liquidate``` function allows a third party to repay a borrower's debt if they have become insolvent\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling ```Liquidate()```\n    /// @param _shares The number of Borrow Shares repaid by the liquidator\n    /// @param _borrower The account for which the repayment is credited and from whom collateral will be taken\n    /// @return _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    function liquidate(uint256 _shares, address _borrower)\n        external\n        whenNotPaused\n        nonReentrant\n        approvedLender(msg.sender)\n        returns (uint256 _collateralForLiquidator)\n    {\n        _addInterest();\n\n        // Get best available exchange rate\n        uint256 _exchangeRate = _updateExchangeRate();\n        if (_isSolvent(_borrower, _exchangeRate)) {\n            revert BorrowerSolvent();\n        }\n\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Determine how much of the borrow and collateral will be repaid\n        _collateralForLiquidator =\n            (((_totalBorrow.toAmount(_shares, false) * _exchangeRate) / EXCHANGE_PRECISION) *\n                (LIQ_PRECISION + cleanLiquidationFee)) /\n            LIQ_PRECISION;\n\n        // Effects & Interactions\n        // NOTE: reverts if _shares > userBorrowShares\n        uint256 _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        _repayAsset(_totalBorrow, _amountToRepay.toUint128(), _shares.toUint128(), msg.sender, _borrower); // liquidator repays shares on behalf of borrower\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        // Collateral is removed on behalf of borrower and sent to liquidator\n        _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);\n        emit Liquidate(_borrower, _collateralForLiquidator, _shares, 0, 0, 0);\n    }\n\n    /// @notice The ```liquidateClean``` function allows a third party to repay a borrower's debt if they have become insolvent\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling ```Liquidate()```\n    /// @param _sharesToLiquidate The number of Borrow Shares repaid by the liquidator\n    /// @param _deadline The timestamp after which tx will revert\n    /// @param _borrower The account for which the repayment is credited and from whom collateral will be taken\n    /// @return _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    function liquidateClean(\n        uint128 _sharesToLiquidate,\n        uint256 _deadline,\n        address _borrower\n    ) external whenNotPaused nonReentrant approvedLender(msg.sender) returns (uint256 _collateralForLiquidator) {\n        if (block.timestamp > _deadline) revert PastDeadline(block.timestamp, _deadline);\n\n        _addInterest();\n        uint256 _exchangeRate = _updateExchangeRate();\n\n        if (_isSolvent(_borrower, _exchangeRate)) {\n            revert BorrowerSolvent();\n        }\n\n        // Read from state\n        VaultAccount memory _totalBorrow = totalBorrow;\n        uint256 _userCollateralBalance = userCollateralBalance[_borrower];\n        uint128 _borrowerShares = userBorrowShares[_borrower].toUint128();\n\n        // Prevent stack-too-deep\n        int256 _leftoverCollateral;\n        {\n            // Checks & Calculations\n            // Determine the liquidation amount in collateral units (i.e. how much debt is liquidator going to repay)\n            uint256 _liquidationAmountInCollateralUnits = ((_totalBorrow.toAmount(_sharesToLiquidate, false) *\n                _exchangeRate) / EXCHANGE_PRECISION);\n\n            // We first optimistically calculate the amount of collateral to give the liquidator based on the higher clean liquidation fee\n            // This fee only applies if the liquidator does a full liquidation\n            uint256 _optimisticCollateralForLiquidator = (_liquidationAmountInCollateralUnits *\n                (LIQ_PRECISION + cleanLiquidationFee)) / LIQ_PRECISION;\n\n            // Because interest accrues every block, _liquidationAmountInCollateralUnits from a few lines up is an ever increasing value\n            // This means that leftoverCollateral can occasionally go negative by a few hundred wei (cleanLiqFee premium covers this for liquidator)\n            _leftoverCollateral = (_userCollateralBalance.toInt256() - _optimisticCollateralForLiquidator.toInt256());\n\n            // If cleanLiquidation fee results in no leftover collateral, give liquidator all the collateral\n            // This will only be true when there liquidator is cleaning out the position\n            _collateralForLiquidator = _leftoverCollateral <= 0\n                ? _userCollateralBalance\n                : (_liquidationAmountInCollateralUnits * (LIQ_PRECISION + dirtyLiquidationFee)) / LIQ_PRECISION;\n        }\n        // Calced here for use during repayment, grouped with other calcs before effects start\n        uint128 _amountLiquidatorToRepay = (_totalBorrow.toAmount(_sharesToLiquidate, true)).toUint128();\n\n        // Determine if and how much debt to writeoff\n        // Note: ensures that sharesToLiquidate is never larger than borrowerShares\n        uint128 _sharesToAdjust;\n        uint128 _amountToAdjust;\n        {\n            if (_leftoverCollateral <= 0) {\n                uint128 _leftoverBorrowShares = _borrowerShares - _sharesToLiquidate;\n                if (_leftoverBorrowShares > 0) {\n                    // Write off bad debt\n                    _sharesToAdjust = _leftoverBorrowShares;\n                    _amountToAdjust = (_totalBorrow.toAmount(_sharesToAdjust, false)).toUint128();\n\n                    // Effects: write to state\n                    totalAsset.amount -= _amountToAdjust;\n\n                    // Note: Ensure this memory stuct will be passed to _repayAsset for write to state\n                    _totalBorrow.amount -= _amountToAdjust;\n                    _totalBorrow.shares -= _sharesToAdjust;\n                }\n            }\n        }\n\n        // Effects & Interactions\n        // NOTE: reverts if _shares > userBorrowShares\n        _repayAsset(_totalBorrow, _amountLiquidatorToRepay, _sharesToLiquidate, msg.sender, _borrower); // liquidator repays shares on behalf of borrower\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        // Collateral is removed on behalf of borrower and sent to liquidator\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);\n        emit Liquidate(\n            _borrower,\n            _collateralForLiquidator,\n            _sharesToLiquidate,\n            _amountLiquidatorToRepay,\n            _sharesToAdjust,\n            _amountToAdjust\n        );\n    }\n\n    // ============================================================================================\n    // Functions: Leverage\n    // ============================================================================================\n\n    /// @notice The ```LeveragedPosition``` event is emitted when a borrower takes out a new leveraged position\n    /// @param _borrower The account for which the debt is debited\n    /// @param _swapperAddress The address of the swapper which conforms the FraxSwap interface\n    /// @param _borrowAmount The amount of Asset Token to be borrowed to be borrowed\n    /// @param _borrowShares The number of Borrow Shares the borrower is credited\n    /// @param _initialCollateralAmount The amount of initial Collateral Tokens supplied by the borrower\n    /// @param _amountCollateralOut The amount of Collateral Token which was received for the Asset Tokens\n    event LeveragedPosition(\n        address indexed _borrower,\n        address _swapperAddress,\n        uint256 _borrowAmount,\n        uint256 _borrowShares,\n        uint256 _initialCollateralAmount,\n        uint256 _amountCollateralOut\n    );\n\n    /// @notice The ```leveragedPosition``` function allows a user to enter a leveraged borrow position with minimal upfront Collateral\n    /// @dev Caller must invoke ```ERC20.approve()``` on the Collateral Token contract prior to calling function\n    /// @param _swapperAddress The address of the whitelisted swapper to use to swap borrowed Asset Tokens for Collateral Tokens\n    /// @param _borrowAmount The amount of Asset Tokens borrowed\n    /// @param _initialCollateralAmount The initial amount of Collateral Tokens supplied by the borrower\n    /// @param _amountCollateralOutMin The minimum amount of Collateral Tokens to be received in exchange for the borrowed Asset Tokens\n    /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.\n    /// @return _totalCollateralBalance The total amount of Collateral Tokens added to a users account (initial + swap)\n    function leveragedPosition(\n        address _swapperAddress,\n        uint256 _borrowAmount,\n        uint256 _initialCollateralAmount,\n        uint256 _amountCollateralOutMin,\n        address[] memory _path\n    )\n        external\n        isNotPastMaturity\n        nonReentrant\n        whenNotPaused\n        approvedBorrower\n        isSolvent(msg.sender)\n        returns (uint256 _totalCollateralBalance)\n    {\n        _addInterest();\n        _updateExchangeRate();\n\n        IERC20 _assetContract = assetContract;\n        IERC20 _collateralContract = collateralContract;\n\n        if (!swappers[_swapperAddress]) {\n            revert BadSwapper();\n        }\n        if (_path[0] != address(_assetContract)) {\n            revert InvalidPath(address(_assetContract), _path[0]);\n        }\n        if (_path[_path.length - 1] != address(_collateralContract)) {\n            revert InvalidPath(address(_collateralContract), _path[_path.length - 1]);\n        }\n\n        // Add initial collateral\n        if (_initialCollateralAmount > 0) {\n            _addCollateral(msg.sender, _initialCollateralAmount, msg.sender);\n        }\n\n        // Debit borrowers account\n        // setting recipient to address(this) means no transfer will happen\n        uint256 _borrowShares = _borrowAsset(_borrowAmount.toUint128(), address(this));\n\n        // Interactions\n        _assetContract.approve(_swapperAddress, _borrowAmount);\n\n        // Even though swappers are trusted, we verify the balance before and after swap\n        uint256 _initialCollateralBalance = _collateralContract.balanceOf(address(this));\n        ISwapper(_swapperAddress).swapExactTokensForTokens(\n            _borrowAmount,\n            _amountCollateralOutMin,\n            _path,\n            address(this),\n            block.timestamp\n        );\n        uint256 _finalCollateralBalance = _collateralContract.balanceOf(address(this));\n\n        // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT\n        // Effects: bookkeeping & write to state\n        uint256 _amountCollateralOut = _finalCollateralBalance - _initialCollateralBalance;\n        if (_amountCollateralOut < _amountCollateralOutMin) {\n            revert SlippageTooHigh(_amountCollateralOutMin, _amountCollateralOut);\n        }\n\n        // address(this) as _sender means no transfer occurs as the pair has already received the collateral during swap\n        _addCollateral(address(this), _amountCollateralOut, msg.sender);\n\n        _totalCollateralBalance = _initialCollateralAmount + _amountCollateralOut;\n        emit LeveragedPosition(\n            msg.sender,\n            _swapperAddress,\n            _borrowAmount,\n            _borrowShares,\n            _initialCollateralAmount,\n            _amountCollateralOut\n        );\n    }\n\n    /// @notice The ```RepayAssetWithCollateral``` event is emitted whenever ```repayAssetWithCollateral()``` is invoked\n    /// @param _borrower The borrower account for which the repayment is taking place\n    /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps\n    /// @param _collateralToSwap The amount of Collateral Token to swap and use for repayment\n    /// @param _amountAssetOut The amount of Asset Token which was repaid\n    /// @param _sharesRepaid The number of Borrow Shares which were repaid\n    event RepayAssetWithCollateral(\n        address indexed _borrower,\n        address _swapperAddress,\n        uint256 _collateralToSwap,\n        uint256 _amountAssetOut,\n        uint256 _sharesRepaid\n    );\n\n    /// @notice The ```repayAssetWithCollateral``` function allows a borrower to repay their debt using existing collateral in contract\n    /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps\n    /// @param _collateralToSwap The amount of Collateral Tokens to swap for Asset Tokens\n    /// @param _amountAssetOutMin The minimum amount of Asset Tokens to receive during the swap\n    /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.\n    /// @return _amountAssetOut The amount of Asset Tokens received for the Collateral Tokens, the amount the borrowers account was credited\n    function repayAssetWithCollateral(\n        address _swapperAddress,\n        uint256 _collateralToSwap,\n        uint256 _amountAssetOutMin,\n        address[] calldata _path\n    ) external nonReentrant isSolvent(msg.sender) returns (uint256 _amountAssetOut) {\n        _addInterest();\n        _updateExchangeRate();\n\n        IERC20 _assetContract = assetContract;\n        IERC20 _collateralContract = collateralContract;\n\n        if (!swappers[_swapperAddress]) {\n            revert BadSwapper();\n        }\n        if (_path[0] != address(_collateralContract)) {\n            revert InvalidPath(address(_collateralContract), _path[0]);\n        }\n        if (_path[_path.length - 1] != address(_assetContract)) {\n            revert InvalidPath(address(_assetContract), _path[_path.length - 1]);\n        }\n\n        // Effects: bookkeeping & write to state\n        // Debit users collateral balance in preparation for swap, setting _recipient to address(this) means no transfer occurs\n        _removeCollateral(_collateralToSwap, address(this), msg.sender);\n\n        // Interactions\n        _collateralContract.approve(_swapperAddress, _collateralToSwap);\n\n        // Even though swappers are trusted, we verify the balance before and after swap\n        uint256 _initialAssetBalance = _assetContract.balanceOf(address(this));\n        ISwapper(_swapperAddress).swapExactTokensForTokens(\n            _collateralToSwap,\n            _amountAssetOutMin,\n            _path,\n            address(this),\n            block.timestamp\n        );\n        uint256 _finalAssetBalance = _assetContract.balanceOf(address(this));\n\n        // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT\n        // Effects: bookkeeping\n        _amountAssetOut = _finalAssetBalance - _initialAssetBalance;\n        if (_amountAssetOut < _amountAssetOutMin) {\n            revert SlippageTooHigh(_amountAssetOutMin, _amountAssetOut);\n        }\n\n        VaultAccount memory _totalBorrow = totalBorrow;\n        uint256 _sharesToRepay = _totalBorrow.toShares(_amountAssetOut, false);\n\n        // Effects: write to state\n        // Note: setting _payer to address(this) means no actual transfer will occur.  Contract already has funds\n        _repayAsset(_totalBorrow, _amountAssetOut.toUint128(), _sharesToRepay.toUint128(), address(this), msg.sender);\n\n        emit RepayAssetWithCollateral(msg.sender, _swapperAddress, _collateralToSwap, _amountAssetOut, _sharesToRepay);\n    }\n}\n\n\n// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================== FraxlendPair ============================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./FraxlendPairConstants.sol\";\nimport \"./FraxlendPairCore.sol\";\nimport \"./libraries/VaultAccount.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/ISwapper.sol\";\n\ncontract FraxlendPair is FraxlendPairCore {\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    )\n        FraxlendPairCore(\n            _configData,\n            _immutables,\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate,\n            _penaltyRate,\n            _isBorrowerWhitelistActive,\n            _isLenderWhitelistActive\n        )\n        ERC20(\"\", \"\")\n        Ownable()\n        Pausable()\n    {}\n\n    // ============================================================================================\n    // ERC20 Metadata\n    // ============================================================================================\n\n    function name() public view override(ERC20, IERC20Metadata) returns (string memory) {\n        return nameOfContract;\n    }\n\n    function symbol() public view override(ERC20, IERC20Metadata) returns (string memory) {\n        // prettier-ignore\n        // solhint-disable-next-line max-line-length\n        return string(abi.encodePacked(\"FraxlendV1 - \", collateralContract.safeSymbol(), \"/\", assetContract.safeSymbol()));\n    }\n\n    function decimals() public pure override(ERC20, IERC20Metadata) returns (uint8) {\n        return 18;\n    }\n\n    // totalSupply for fToken ERC20 compatibility\n    function totalSupply() public view override(ERC20, IERC20) returns (uint256) {\n        return totalAsset.shares;\n    }\n\n    // ============================================================================================\n    // ERC4626 Views\n    // ============================================================================================\n    function asset() external view returns (address) {\n        return address(assetContract);\n    }\n\n    function totalAssets() public view virtual returns (uint256) {\n        return totalAsset.amount;\n    }\n\n    function assetsPerShare() external view returns (uint256 _assetsPerUnitShare) {\n        _assetsPerUnitShare = totalAsset.toAmount(1e18, false);\n    }\n\n    function assetsOf(address _depositor) external view returns (uint256 _assets) {\n        _assets = totalAsset.toAmount(balanceOf(_depositor), false);\n    }\n\n    function convertToShares(uint256 _amount) external view returns (uint256) {\n        return totalAsset.toShares(_amount, false);\n    }\n\n    function convertToAssets(uint256 _shares) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, false);\n    }\n\n    function previewDeposit(uint256 _amount) external view returns (uint256) {\n        return totalAsset.toShares(_amount, false);\n    }\n\n    function previewMint(uint256 _shares) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, true);\n    }\n\n    function previewWithdraw(uint256 _amount) external view returns (uint256) {\n        return totalAsset.toShares(_amount, true);\n    }\n\n    function previewRedeem(uint256 _shares) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, false);\n    }\n\n    function maxDeposit(address) external pure returns (uint256) {\n        return type(uint128).max;\n    }\n\n    function maxMint(address) external pure returns (uint256) {\n        return type(uint128).max;\n    }\n\n    function maxWithdraw(address owner) external view returns (uint256) {\n        return totalAsset.toAmount(balanceOf(owner), false);\n    }\n\n    function maxRedeem(address owner) external view returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    // ============================================================================================\n    // Functions: Helpers\n    // ============================================================================================\n\n    function getConstants()\n        external\n        pure\n        returns (\n            uint256 _LTV_PRECISION,\n            uint256 _LIQ_PRECISION,\n            uint256 _UTIL_PREC,\n            uint256 _FEE_PRECISION,\n            uint256 _EXCHANGE_PRECISION,\n            uint64 _DEFAULT_INT,\n            uint16 _DEFAULT_PROTOCOL_FEE,\n            uint256 _MAX_PROTOCOL_FEE\n        )\n    {\n        _LTV_PRECISION = LTV_PRECISION;\n        _LIQ_PRECISION = LIQ_PRECISION;\n        _UTIL_PREC = UTIL_PREC;\n        _FEE_PRECISION = FEE_PRECISION;\n        _EXCHANGE_PRECISION = EXCHANGE_PRECISION;\n        _DEFAULT_INT = DEFAULT_INT;\n        _DEFAULT_PROTOCOL_FEE = DEFAULT_PROTOCOL_FEE;\n        _MAX_PROTOCOL_FEE = MAX_PROTOCOL_FEE;\n    }\n\n    /// @notice The ```toBorrowShares``` function converts a given amount of borrow debt into the number of shares\n    /// @param _amount Amount of borrow\n    /// @param _roundUp Whether to roundup during division\n    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toShares(_amount, _roundUp);\n    }\n\n    /// @notice The ```toBorrtoBorrowAmountowShares``` function converts a given amount of borrow debt into the number of shares\n    /// @param _shares Shares of borrow\n    /// @param _roundUp Whether to roundup during division\n    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toAmount(_shares, _roundUp);\n    }\n\n    // ============================================================================================\n    // Functions: Protocol Configuration (Fees & Swap Contracts)\n    // ============================================================================================\n    /// @notice The ```SetTimeLock``` event fires when the TIME_LOCK_ADDRESS is set\n    /// @param _oldAddress The original address\n    /// @param _newAddress The new address\n    event SetTimeLock(address _oldAddress, address _newAddress);\n\n    /// @notice The ```setTimeLock``` function sets the TIME_LOCK address\n    /// @param _newAddress the new time lock address\n    function setTimeLock(address _newAddress) external onlyOwner {\n        emit SetTimeLock(TIME_LOCK_ADDRESS, _newAddress);\n        TIME_LOCK_ADDRESS = _newAddress;\n    }\n\n    /// @notice The ```ChangeFee``` event first when the fee is changed\n    /// @param _newFee The new fee\n    event ChangeFee(uint32 _newFee);\n\n    /// @notice The ```changeFee``` function changes the protocol fee, max 50%\n    /// @param _newFee The new fee\n    function changeFee(uint32 _newFee) external whenNotPaused {\n        if (msg.sender != TIME_LOCK_ADDRESS) revert OnlyTimeLock();\n        if (_newFee > MAX_PROTOCOL_FEE) {\n            revert BadProtocolFee();\n        }\n        currentRateInfo.feeToProtocolRate = _newFee;\n        emit ChangeFee(_newFee);\n    }\n\n    /// @notice The ```WithdrawFees``` event fires when the fees are withdrawn\n    /// @param _shares Number of _shares (fTokens) redeemed\n    /// @param _recipient To whom the assets were sent\n    /// @param _amountToTransfer The amount of fees redeemed\n    event WithdrawFees(uint128 _shares, address _recipient, uint256 _amountToTransfer);\n\n    /// @notice The ```withdrawFees``` function withdraws fees accumulated\n    /// @param _shares Number of fTokens to redeem\n    /// @param _recipient Address to send the assets\n    /// @return _amountToTransfer Amount of assets sent to recipient\n    function withdrawFees(uint128 _shares, address _recipient) external onlyOwner returns (uint256 _amountToTransfer) {\n        // Grab some data from state to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Take all available if 0 value passed\n        if (_shares == 0) _shares = uint128(balanceOf(address(this)));\n\n        // We must calculate this before we subtract from _totalAsset or invoke _burn\n        _amountToTransfer = _totalAsset.toAmount(_shares, true);\n\n        // Check for sufficient withdraw liquidity\n        uint256 _assetsAvailable = _totalAssetAvailable(_totalAsset, _totalBorrow);\n        if (_assetsAvailable < _amountToTransfer) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _amountToTransfer);\n        }\n\n        // Effects: bookkeeping\n        _totalAsset.amount -= uint128(_amountToTransfer);\n        _totalAsset.shares -= _shares;\n\n        // Effects: write to states\n        // NOTE: will revert if _shares > balanceOf(address(this))\n        _burn(address(this), _shares);\n        totalAsset = _totalAsset;\n\n        // Interactions\n        assetContract.safeTransfer(_recipient, _amountToTransfer);\n        emit WithdrawFees(_shares, _recipient, _amountToTransfer);\n    }\n\n    /// @notice The ```SetSwapper``` event fires whenever a swapper is black or whitelisted\n    /// @param _swapper The swapper address\n    /// @param _approval The approval\n    event SetSwapper(address _swapper, bool _approval);\n\n    /// @notice The ```setSwapper``` function is called to black or whitelist a given swapper address\n    /// @dev\n    /// @param _swapper The swapper address\n    /// @param _approval The approval\n    function setSwapper(address _swapper, bool _approval) external onlyOwner {\n        swappers[_swapper] = _approval;\n        emit SetSwapper(_swapper, _approval);\n    }\n\n    /// @notice The ```SetApprovedLender``` event fires when a lender is black or whitelisted\n    /// @param _address The address\n    /// @param _approval The approval\n    event SetApprovedLender(address indexed _address, bool _approval);\n\n    /// @notice The ```setApprovedLenders``` function sets a given set of addresses to the whitelist\n    /// @dev Cannot black list self\n    /// @param _lenders The addresses whos status will be set\n    /// @param _approval The approcal status\n    function setApprovedLenders(address[] calldata _lenders, bool _approval) external approvedLender(msg.sender) {\n        for (uint256 i = 0; i < _lenders.length; i++) {\n            // Do not set when _approval == false and _lender == msg.sender\n            if (_approval || _lenders[i] != msg.sender) {\n                approvedLenders[_lenders[i]] = _approval;\n                emit SetApprovedLender(_lenders[i], _approval);\n            }\n        }\n    }\n\n    /// @notice The ```SetApprovedBorrower``` event fires when a borrower is black or whitelisted\n    /// @param _address The address\n    /// @param _approval The approval\n    event SetApprovedBorrower(address indexed _address, bool _approval);\n\n    /// @notice The ```setApprovedBorrowers``` function sets a given array of addresses to the whitelist\n    /// @dev Cannot black list self\n    /// @param _borrowers The addresses whos status will be set\n    /// @param _approval The approcal status\n    function setApprovedBorrowers(address[] calldata _borrowers, bool _approval) external approvedBorrower {\n        for (uint256 i = 0; i < _borrowers.length; i++) {\n            // Do not set when _approval == false and _borrower == msg.sender\n            if (_approval || _borrowers[i] != msg.sender) {\n                approvedBorrowers[_borrowers[i]] = _approval;\n                emit SetApprovedBorrower(_borrowers[i], _approval);\n            }\n        }\n    }\n\n    function pause() external {\n        if (\n            msg.sender != CIRCUIT_BREAKER_ADDRESS &&\n            msg.sender != COMPTROLLER_ADDRESS &&\n            msg.sender != owner() &&\n            msg.sender != DEPLOYER_ADDRESS\n        ) {\n            revert ProtocolOrOwnerOnly();\n        }\n        _addInterest(); // accrue any interest prior to pausing as it won't accrue during pause\n        _pause();\n    }\n\n    function unpause() external {\n        if (msg.sender != COMPTROLLER_ADDRESS && msg.sender != owner()) {\n            revert ProtocolOrOwnerOnly();\n        }\n        // Resets the lastTimestamp which has the effect of no interest accruing over the pause period\n        _addInterest();\n        _unpause();\n    }\n}\n\n\n",
        "CodeNames": [
            "FraxlendPairCore.sol",
            "FraxlendPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FraxlendPairCore.sol#L84-L86, FraxlendPair.sol#L204-L207",
                "Type": "Resetting constant value",
                "Description": "The setTimeLock function in the FraxlendPair contract allows the owner to reset the TIME_LOCK_ADDRESS value multiple times, which does not seem to be the expected behavior.",
                "Repair": "Add a bool which acts as a mutex if TIME_LOCK_ADDRESS has already been set, and modify setTimeLock function in FraxlendPair contract"
            }
        ]
    }
]