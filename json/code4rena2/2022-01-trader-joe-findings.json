[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "[M-15] Lack of input checks (withrawal penalties should always be greater than 0)",
                "Type": "Lack of input checks",
                "Description": "If penalties are set to 0 the protocol would be vulnerable to price manipulations like the one described in the contest documentation.",
                "Repair": "Require penalties to be greater than 0 either in the initializer function or in the factory."
            },
            {
                "Location": "[M-10] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom",
                "Type": "Failure to check return value",
                "Description": "It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin\u2019s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure.",
                "Repair": "Consider using safeTransfer/safeTransferFrom or require() consistently."
            },
            {
                "Location": "[M-13] ERC20 return values not checked",
                "Type": "Failure to check return value",
                "Description": "The ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success.",
                "Repair": "We recommend checking the success boolean of all .transfer and .transferFrom calls for the unknown token contract."
            },
            {
                "Location": "[M-11] Re-enterable Code When Making a Deposit to Stake",
                "Type": "Re-entrancy",
                "Description": "This vulnerability would allow the entire rJoe balance to be drained from the contract.",
                "Repair": "There are two possible mitigations. First is to use the openzeppelin reentrancy guard over the deposit() function which will prevent multiple deposits being made simultaneously. The second mitigation is to follow the checks-effects-interactions pattern."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\n// Copyright (c) 2022 Trader Joe - All rights reserved\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent is Ownable {\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public PHASE_ONE_DURATION;\n    uint256 public PHASE_ONE_NO_FEE_DURATION;\n    uint256 public PHASE_TWO_DURATION;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20Metadata public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool private initialized;\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of wavax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 private wavaxAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev wavaxReserve is the exact amount of WAVAX that needs to be kept inside the contract in order to send everyone's\n    /// WAVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private wavaxReserve;\n\n    event IssuingTokenDeposited(address indexed token, uint256 amount);\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(address indexed user, uint256 avaxAmount);\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Receive AVAX from the WAVAX contract\n    /// @dev Needed for withdrawing from WAVAX contract\n    receive() external payable {\n        require(\n            msg.sender == address(WAVAX),\n            \"LaunchEvent: you can't send AVAX directly to this contract\"\n        );\n    }\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        uint256 phase3Start = auctionStart +\n            PHASE_ONE_DURATION +\n            PHASE_TWO_DURATION;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n        _;\n    }\n\n    /// @notice Initialise the launch event with needed paramaters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(!initialized, \"LaunchEvent: already initialized\");\n\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();\n        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();\n        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();\n\n        token = IERC20Metadata(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n        initialized = true;\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (block.timestamp < auctionStart || auctionStart == 0) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp <\n            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    /// @dev Checks are done in the `_depositWAVAX` function\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Burn tokens and update allocation.\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        wavaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        WAVAX.deposit{value: msg.value}();\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) public isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        wavaxReserve -= _amount;\n\n        WAVAX.withdraw(_amount);\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        require(\n            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||\n                IJoePair(\n                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)\n                ).totalSupply() ==\n                0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(wavaxReserve > 0, \"LaunchEvent: no wavax balance\");\n\n        uint256 tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (\n            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated\n        ) {\n            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        WAVAX.approve(address(router), wavaxReserve);\n        token.approve(address(router), tokenAllocated);\n\n        /// We can't trust the output cause of reflect tokens\n        (, , lpSupply) = router.addLiquidity(\n            wavaxAddress, // tokenA\n            tokenAddress, // tokenB\n            wavaxReserve, // amountADesired\n            tokenAllocated, // amountBDesired\n            wavaxReserve, // amountAMin\n            tokenAllocated, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));\n        wavaxAllocated = wavaxReserve;\n        wavaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            wavaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnPair,\n            \"LaunchEvent: liquidity already withdrawn\"\n        );\n\n        uint256 balance = pairBalance(msg.sender);\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            balance = lpSupply / 2;\n\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n\n            if (tokenReserve > 0) {\n                uint256 amount = tokenReserve;\n                tokenReserve = 0;\n                token.transfer(msg.sender, amount);\n            }\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external isStopped(false) {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnIncentives,\n            \"LaunchEvent: incentives already withdrawn\"\n        );\n\n        user.hasWithdrawnIncentives = true;\n        uint256 amount;\n\n        if (msg.sender == issuer) {\n            amount = tokenIncentiveIssuerRefund;\n        } else {\n            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;\n        }\n\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        tokenIncentivesBalance -= amount;\n\n        token.transfer(msg.sender, amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (msg.sender != issuer) {\n            UserInfo storage user = getUserInfo[msg.sender];\n            require(\n                user.balance > 0,\n                \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n            );\n\n            uint256 balance = user.balance;\n            user.balance = 0;\n            wavaxReserve -= balance;\n            WAVAX.withdraw(balance);\n\n            _safeTransferAVAX(msg.sender, balance);\n\n            emit AvaxEmergencyWithdraw(msg.sender, balance);\n        } else {\n            uint256 balance = tokenReserve + tokenIncentivesBalance;\n            tokenReserve = 0;\n            tokenIncentivesBalance = 0;\n            token.transfer(issuer, balance);\n            emit TokenEmergencyWithdraw(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.transfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;\n        if (excessWavax > 0) {\n            WAVAX.transfer(penaltyCollector, excessWavax);\n        }\n\n        uint256 excessAvax = address(this).balance;\n        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {\n            return 0;\n        } else if (timeElapsed < PHASE_ONE_DURATION) {\n            return\n                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *\n                    maxWithdrawPenalty) /\n                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the current balance of the pool\n    /// @return The balances of WAVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return _avaxAmount * rJoePerAvax;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        return (user.balance * lpSupply) / wavaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier.\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        if (_phase == Phase.NotStarted) {\n            require(\n                currentPhase() == Phase.NotStarted,\n                \"LaunchEvent: not in not started\"\n            );\n        } else if (_phase == Phase.PhaseOne) {\n            require(\n                currentPhase() == Phase.PhaseOne,\n                \"LaunchEvent: not in phase one\"\n            );\n        } else if (_phase == Phase.PhaseTwo) {\n            require(\n                currentPhase() == Phase.PhaseTwo,\n                \"LaunchEvent: not in phase two\"\n            );\n        } else if (_phase == Phase.PhaseThree) {\n            require(\n                currentPhase() == Phase.PhaseThree,\n                \"LaunchEvent: not in phase three\"\n            );\n        } else {\n            revert(\"LaunchEvent: unknown state\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "LaunchEvent.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "[M-02] Owner of LaunchEvent token has the ability to DOS attack the event",
                "Type": "DOS attack",
                "Description": "The owner of the token for which the LaunchEvent was created, has the ability to DOS attack the event.",
                "Repair": "If a LaunchEvent for a token has started, only the LaunchEvent contract should be able to create a JoePair for that token."
            },
            {
                "Location": "LaunchEvent.allowEmergencyWithdraw()",
                "Type": "Users can lose value in emergency state",
                "Description": "Users can lose their entire deposit in emergency state as they cannot withdraw their LP tokens and the WAVAX reserve was already used to provide liquidity.",
                "Repair": "Consider paying out LP tokens in emergencyWithdraw"
            },
            {
                "Location": "LaunchEvent.createPair()",
                "Type": "createPair() expects zero slippage",
                "Description": "createPair() function expects zero slippage which can cause the addLiquidity() function to revert and prevent users from using the createPair() function.",
                "Repair": "Add an input parameter to handle a slippage allowance or add support for deflationary/rebasing/inflationary tokens"
            },
            {
                "Location": "LaunchEvent.createPair()",
                "Type": "Pair creation can be denied",
                "Description": "A griefer can create a pool for the WAVAX < _token pair by calling JoeFactory.createPair(WAVAX, _token) while the launch event phase 1 or 2 is running.",
                "Repair": "Add a standard min. LP return 'slippage' check or add special privileges to the function"
            },
            {
                "Location": "_safeTransferAVAX() in LaunchEvent.sol",
                "Type": "Failed transfer with low level call could be overlooked",
                "Description": "The _safeTransferAVAX() function may not notice if the address rocketJoeFactory.penaltyCollector() is a deleted contract, which could cause problems.",
                "Repair": "Check for contract existence on low-level calls"
            },
            {
                "Location": "LaunchEvent.sol#L520",
                "Type": "LP Tokens Locking",
                "Description": "The function allowEmergencyWithdraw() may be called by the rocketJoeFactory.owner() at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.",
                "Repair": "Add the requirement 'require(address(pair) != address(0), 'LaunchEvent: pair not created')' to the function allowEmergencyWithdraw()"
            },
            {
                "Location": "LaunchEvent.sol#L368",
                "Type": "Reentrancy",
                "Description": "The withdrawAVAX() function makes an external call to the msg.sender by way of _safeTransferAVAX. This allows the caller to reenter this and other functions in this and other protocol files.",
                "Repair": "Add reentrancy guard modifier to withdrawAVAX() function"
            },
            {
                "Location": "LaunchEvent.createPair",
                "Type": "Wrong Token Allocation Computation",
                "Description": "In LaunchEvent.createPair, when the floor price is not reached, the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price. The tokenAllocated computation involves the token decimals, which does not work for tokens that don't have 18 decimals.",
                "Repair": "Change the tokenAllocated computation to tokenAllocated = wavaxReserve * 1e18 / floorPrice;"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\n// Copyright (c) 2022 Trader Joe - All rights reserved\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/ILaunchEvent.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\n\n/// @title Rocket Joe Factory\n/// @author Trader Joe\n/// @notice Factory that creates Rocket Joe events\ncontract RocketJoeFactory is IRocketJoeFactory, Ownable {\n    address public override penaltyCollector;\n    address public override eventImplementation;\n\n    address public override rJoe;\n    uint256 public override rJoePerAvax;\n    address public override wavax;\n    address public override router;\n    address public override factory;\n\n    uint256 public override PHASE_ONE_DURATION = 2 days;\n    uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days;\n    uint256 public override PHASE_TWO_DURATION = 1 days;\n\n    mapping(address => address) public override getRJLaunchEvent;\n    mapping(address => bool) public override isRJLaunchEvent;\n    address[] public override allRJLaunchEvents;\n\n    /// @notice Creates the launch event factory\n    /// @dev Uses clone factory pattern to save space\n    /// @param _eventImplementation Implementation of launch event contract\n    /// @param _rJoe rJOE token address\n    /// @param _wavax WAVAX token address\n    /// @param _penaltyCollector Address that collects all withdrawal penalties\n    /// @param _router Router used to create LP on Trader Joe AMM\n    /// @param _factory Factory used to get info of JoePairs\n    constructor(\n        address _eventImplementation,\n        address _rJoe,\n        address _wavax,\n        address _penaltyCollector,\n        address _router,\n        address _factory\n    ) {\n        require(\n            _eventImplementation != address(0) &&\n                _rJoe != address(0) &&\n                _wavax != address(0) &&\n                _penaltyCollector != address(0) &&\n                _router != address(0) &&\n                _factory != address(0),\n            \"RJFactory: Addresses can't be null address\"\n        );\n        IRocketJoeToken(_rJoe).initialize();\n\n        eventImplementation = _eventImplementation;\n        rJoe = _rJoe;\n\n        wavax = _wavax;\n        penaltyCollector = _penaltyCollector;\n        router = _router;\n        factory = _factory;\n        rJoePerAvax = 100;\n    }\n\n    /// @notice Returns the number of launch events\n    /// @return The number of launch events ever created\n    function numLaunchEvents() external view override returns (uint256) {\n        return allRJLaunchEvents.length;\n    }\n\n    /// @notice Creates a launch event contract\n    /// @param _issuer Address of the project issuing tokens for auction\n    /// @param _phaseOneStartTime Timestamp of when launch event will start\n    /// @param _token Token that will be issued through this launch event\n    /// @param _tokenAmount Amount of tokens that will be issued\n    /// @param _tokenIncentivesPercent Additional tokens that will be given as\n    /// incentive for locking up LPs during phase 3 expressed as a percentage\n    /// of the issuing tokens for sale, scaled to 1e18\n    /// @param _floorPrice Price of each token in AVAX, scaled to 1e18\n    /// @param _maxWithdrawPenalty Maximum withdrawal penalty that can be met\n    /// during phase 1\n    /// @param _fixedWithdrawPenalty Withdrawal penalty during phase 2\n    /// @param _maxAllocation Maximum number of AVAX each participant can commit\n    /// @param _userTimelock Amount of time users' LPs will be locked for\n    /// during phase 3\n    /// @param _issuerTimelock Amount of time issuer's LP will be locked for\n    /// during phase 3\n    /// @return Address of launch event contract\n    function createRJLaunchEvent(\n        address _issuer,\n        uint256 _phaseOneStartTime,\n        address _token,\n        uint256 _tokenAmount,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external override returns (address) {\n        require(\n            getRJLaunchEvent[_token] == address(0),\n            \"RJFactory: token has already been issued\"\n        );\n        require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");\n        require(_token != address(0), \"RJFactory: token can't be 0 address\");\n        require(_token != wavax, \"RJFactory: token can't be wavax\");\n        require(\n            _tokenAmount > 0,\n            \"RJFactory: token amount needs to be greater than 0\"\n        );\n        require(\n            IJoeFactory(factory).getPair(_token, wavax) == address(0) ||\n                IJoePair(IJoeFactory(factory).getPair(_token, wavax))\n                    .totalSupply() ==\n                0,\n            \"RJFactory: liquid pair already exists\"\n        );\n\n        address launchEvent = Clones.clone(eventImplementation);\n\n        // msg.sender needs to approve RocketJoeFactory\n        IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);\n\n        ILaunchEvent(payable(launchEvent)).initialize(\n            _issuer,\n            _phaseOneStartTime,\n            _token,\n            _tokenIncentivesPercent,\n            _floorPrice,\n            _maxWithdrawPenalty,\n            _fixedWithdrawPenalty,\n            _maxAllocation,\n            _userTimelock,\n            _issuerTimelock\n        );\n\n        getRJLaunchEvent[_token] = launchEvent;\n        isRJLaunchEvent[launchEvent] = true;\n        allRJLaunchEvents.push(launchEvent);\n\n        _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);\n\n        return launchEvent;\n    }\n\n    /// @notice Set rJOE address\n    /// @param _rJoe New rJOE address\n    function setRJoe(address _rJoe) external override onlyOwner {\n        IRocketJoeToken(_rJoe).initialize();\n        rJoe = _rJoe;\n        emit SetRJoe(_rJoe);\n    }\n\n    /// @notice Set address to collect withdrawal penalties\n    /// @param _penaltyCollector New penalty collector address\n    function setPenaltyCollector(address _penaltyCollector)\n        external\n        override\n        onlyOwner\n    {\n        penaltyCollector = _penaltyCollector;\n        emit SetPenaltyCollector(_penaltyCollector);\n    }\n\n    /// @notice Set JoeRouter address\n    /// @param _router New router address\n    function setRouter(address _router) external override onlyOwner {\n        router = _router;\n        emit SetRouter(_router);\n    }\n\n    /// @notice Set JoeFactory address\n    /// @param _factory New factory address\n    function setFactory(address _factory) external override onlyOwner {\n        factory = _factory;\n        emit SetFactory(_factory);\n    }\n\n    /// @notice Set amount of rJOE required to deposit 1 AVAX into launch event\n    /// @dev Configured by team between launch events to control inflation\n    function setRJoePerAvax(uint256 _rJoePerAvax) external override onlyOwner {\n        rJoePerAvax = _rJoePerAvax;\n        emit SetRJoePerAvax(_rJoePerAvax);\n    }\n\n    /// @notice Set duration of each of the three phases\n    /// @param _phaseNumber Can be only 1 or 2\n    /// @param _duration Duration of phase in seconds\n    function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)\n        external\n        override\n        onlyOwner\n    {\n        if (_phaseNumber == 1) {\n            require(\n                _duration > PHASE_ONE_NO_FEE_DURATION,\n                \"RJFactory: phase one duration lower than no fee duration\"\n            );\n            PHASE_ONE_DURATION = _duration;\n        } else if (_phaseNumber == 2) {\n            PHASE_TWO_DURATION = _duration;\n        }\n    }\n\n    /// @notice Set the no fee duration of phase 1\n    /// @param _noFeeDuration Duration of no fee phase\n    function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _noFeeDuration < PHASE_ONE_DURATION,\n            \"RJFactory: no fee duration bigger than phase one duration\"\n        );\n        PHASE_ONE_NO_FEE_DURATION = _noFeeDuration;\n    }\n\n    /// @dev This function emits an event after a new launch event has been created\n    /// It is only seperated out due to `createRJLaunchEvent` having too many local variables\n    function _emitLaunchedEvent(\n        address _issuer,\n        address _token,\n        uint256 _phaseOneStartTime\n    ) internal {\n        uint256 _phaseTwoStartTime = _phaseOneStartTime + PHASE_ONE_DURATION;\n        uint256 _phaseThreeStartTime = _phaseTwoStartTime + PHASE_TWO_DURATION;\n\n        emit RJLaunchEventCreated(\n            _issuer,\n            _token,\n            _phaseOneStartTime,\n            _phaseTwoStartTime,\n            _phaseThreeStartTime,\n            rJoe,\n            rJoePerAvax\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: None\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./RocketJoeToken.sol\";\n\n/// @title Rocket Joe Staking\n/// @author Trader Joe\n/// @notice Stake JOE to earn rJOE\ncontract RocketJoeStaking is Initializable, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct UserInfo {\n        uint256 amount; // How many JOE tokens the user has provided\n        uint256 rewardDebt; // Reward debt. See explanation below\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of JOEs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * accRJoePerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. `accRJoePerShare` (and `lastRewardTimestamp`) gets updated\n        //   2. User receives the pending reward sent to his/her address\n        //   3. User's `amount` gets updated\n        //   4. User's `rewardDebt` gets updated\n    }\n\n    IERC20Upgradeable public joe;\n    uint256 public lastRewardTimestamp;\n\n    /// @dev Accumulated rJOE per share, times PRECISION. See above\n    uint256 public accRJoePerShare;\n    /// @notice Precision of accRJoePerShare\n    uint256 private PRECISION;\n\n    RocketJoeToken public rJoe;\n    uint256 public rJoePerSec;\n\n    /// @dev Info of each user that stakes LP tokens\n    mapping(address => UserInfo) public userInfo;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);\n\n    /// @notice Initialize with needed parameters\n    /// @param _joe Address of the JOE token contract\n    /// @param _rJoe Address of the rJOE token contract\n    /// @param _rJoePerSec Number of rJOE tokens created per second\n    /// @param _startTime Timestamp at which rJOE rewards starts\n    function initialize(\n        IERC20Upgradeable _joe,\n        RocketJoeToken _rJoe,\n        uint256 _rJoePerSec,\n        uint256 _startTime\n    ) public initializer {\n        __Ownable_init();\n\n        require(\n            _startTime > block.timestamp,\n            \"RocketJoeStaking: rJOE minting needs to start after the current timestamp\"\n        );\n\n        PRECISION = 1e18;\n\n        joe = _joe;\n        rJoe = _rJoe;\n        rJoePerSec = _rJoePerSec;\n        lastRewardTimestamp = _startTime;\n    }\n\n    /// @notice Get pending rJoe for a given `_user`\n    /// @param _user The user to lookup\n    /// @return The number of pending rJOE tokens for `_user`\n    function pendingRJoe(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 joeSupply = joe.balanceOf(address(this));\n        uint256 _accRJoePerShare = accRJoePerShare;\n\n        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {\n            uint256 multiplier = block.timestamp - lastRewardTimestamp;\n            uint256 rJoeReward = multiplier * rJoePerSec;\n            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;\n        }\n        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;\n    }\n\n    /// @notice Deposit joe to RocketJoeStaking for rJoe allocation\n    /// @param _amount Amount of JOE to deposit\n    function deposit(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n\n        updatePool();\n\n        if (user.amount > 0) {\n            uint256 pending = (user.amount * accRJoePerShare) /\n                PRECISION -\n                user.rewardDebt;\n            _safeRJoeTransfer(msg.sender, pending);\n        }\n        user.amount = user.amount + _amount;\n        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n        joe.safeTransferFrom(address(msg.sender), address(this), _amount);\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw JOE and accumulated rJOE from RocketJoeStaking\n    /// @param _amount Amount of JOE to withdraw\n    function withdraw(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n        require(\n            user.amount >= _amount,\n            \"RocketJoeStaking: withdraw amount exceeds balance\"\n        );\n\n        updatePool();\n\n        uint256 pending = (user.amount * accRJoePerShare) /\n            PRECISION -\n            user.rewardDebt;\n\n        user.amount = user.amount - _amount;\n        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n        _safeRJoeTransfer(msg.sender, pending);\n        joe.safeTransfer(address(msg.sender), _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY\n    function emergencyWithdraw() external {\n        UserInfo storage user = userInfo[msg.sender];\n\n        uint256 _amount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        joe.safeTransfer(address(msg.sender), _amount);\n        emit EmergencyWithdraw(msg.sender, _amount);\n    }\n\n    /// @notice Update emission rate\n    /// @param _rJoePerSec The new value for rJoePerSec\n    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {\n        updatePool();\n        rJoePerSec = _rJoePerSec;\n        emit UpdateEmissionRate(msg.sender, _rJoePerSec);\n    }\n\n    /// @notice Update reward variables of the given pool with latest data\n    function updatePool() public {\n        if (block.timestamp <= lastRewardTimestamp) {\n            return;\n        }\n        uint256 joeSupply = joe.balanceOf(address(this));\n        if (joeSupply == 0) {\n            lastRewardTimestamp = block.timestamp;\n            return;\n        }\n        uint256 multiplier = block.timestamp - lastRewardTimestamp;\n        uint256 rJoeReward = multiplier * rJoePerSec;\n        accRJoePerShare =\n            accRJoePerShare +\n            (rJoeReward * PRECISION) /\n            joeSupply;\n        lastRewardTimestamp = block.timestamp;\n\n        rJoe.mint(address(this), rJoeReward);\n    }\n\n    /// @notice Safe rJoe transfer function, just in case if rounding error causes pool to not have enough JOEs\n    /// @param _to Address that wil receive rJoe\n    /// @param _amount The amount to send\n    function _safeRJoeTransfer(address _to, uint256 _amount) internal {\n        uint256 rJoeBal = rJoe.balanceOf(address(this));\n        if (_amount > rJoeBal) {\n            rJoe.transfer(_to, rJoeBal);\n        } else {\n            rJoe.transfer(_to, _amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "RocketJoeFactory.sol",
            "RocketJoeStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RocketJoeStaking.sol and RocketJoeFactory.sol",
                "Type": "Incompatibility with rebasing/deflationary/inflationary tokens",
                "Description": "The protocol does not support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time.",
                "Repair": "Ensure to check previous balance/after balance equals to amount for any rebasing/inflation/deflation or add support in contracts for such tokens before accepting user-supplied tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./RocketJoeToken.sol\";\n\n/// @title Rocket Joe Staking\n/// @author Trader Joe\n/// @notice Stake JOE to earn rJOE\ncontract RocketJoeStaking is Initializable, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct UserInfo {\n        uint256 amount; // How many JOE tokens the user has provided\n        uint256 rewardDebt; // Reward debt. See explanation below\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of JOEs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * accRJoePerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. `accRJoePerShare` (and `lastRewardTimestamp`) gets updated\n        //   2. User receives the pending reward sent to his/her address\n        //   3. User's `amount` gets updated\n        //   4. User's `rewardDebt` gets updated\n    }\n\n    IERC20Upgradeable public joe;\n    uint256 public lastRewardTimestamp;\n\n    /// @dev Accumulated rJOE per share, times PRECISION. See above\n    uint256 public accRJoePerShare;\n    /// @notice Precision of accRJoePerShare\n    uint256 private PRECISION;\n\n    RocketJoeToken public rJoe;\n    uint256 public rJoePerSec;\n\n    /// @dev Info of each user that stakes LP tokens\n    mapping(address => UserInfo) public userInfo;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);\n\n    /// @notice Initialize with needed parameters\n    /// @param _joe Address of the JOE token contract\n    /// @param _rJoe Address of the rJOE token contract\n    /// @param _rJoePerSec Number of rJOE tokens created per second\n    /// @param _startTime Timestamp at which rJOE rewards starts\n    function initialize(\n        IERC20Upgradeable _joe,\n        RocketJoeToken _rJoe,\n        uint256 _rJoePerSec,\n        uint256 _startTime\n    ) public initializer {\n        __Ownable_init();\n\n        require(\n            _startTime > block.timestamp,\n            \"RocketJoeStaking: rJOE minting needs to start after the current timestamp\"\n        );\n\n        PRECISION = 1e18;\n\n        joe = _joe;\n        rJoe = _rJoe;\n        rJoePerSec = _rJoePerSec;\n        lastRewardTimestamp = _startTime;\n    }\n\n    /// @notice Get pending rJoe for a given `_user`\n    /// @param _user The user to lookup\n    /// @return The number of pending rJOE tokens for `_user`\n    function pendingRJoe(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 joeSupply = joe.balanceOf(address(this));\n        uint256 _accRJoePerShare = accRJoePerShare;\n\n        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {\n            uint256 multiplier = block.timestamp - lastRewardTimestamp;\n            uint256 rJoeReward = multiplier * rJoePerSec;\n            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;\n        }\n        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;\n    }\n\n    /// @notice Deposit joe to RocketJoeStaking for rJoe allocation\n    /// @param _amount Amount of JOE to deposit\n    function deposit(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n\n        updatePool();\n\n        if (user.amount > 0) {\n            uint256 pending = (user.amount * accRJoePerShare) /\n                PRECISION -\n                user.rewardDebt;\n            _safeRJoeTransfer(msg.sender, pending);\n        }\n        user.amount = user.amount + _amount;\n        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n        joe.safeTransferFrom(address(msg.sender), address(this), _amount);\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw JOE and accumulated rJOE from RocketJoeStaking\n    /// @param _amount Amount of JOE to withdraw\n    function withdraw(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n        require(\n            user.amount >= _amount,\n            \"RocketJoeStaking: withdraw amount exceeds balance\"\n        );\n\n        updatePool();\n\n        uint256 pending = (user.amount * accRJoePerShare) /\n            PRECISION -\n            user.rewardDebt;\n\n        user.amount = user.amount - _amount;\n        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n        _safeRJoeTransfer(msg.sender, pending);\n        joe.safeTransfer(address(msg.sender), _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY\n    function emergencyWithdraw() external {\n        UserInfo storage user = userInfo[msg.sender];\n\n        uint256 _amount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        joe.safeTransfer(address(msg.sender), _amount);\n        emit EmergencyWithdraw(msg.sender, _amount);\n    }\n\n    /// @notice Update emission rate\n    /// @param _rJoePerSec The new value for rJoePerSec\n    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {\n        updatePool();\n        rJoePerSec = _rJoePerSec;\n        emit UpdateEmissionRate(msg.sender, _rJoePerSec);\n    }\n\n    /// @notice Update reward variables of the given pool with latest data\n    function updatePool() public {\n        if (block.timestamp <= lastRewardTimestamp) {\n            return;\n        }\n        uint256 joeSupply = joe.balanceOf(address(this));\n        if (joeSupply == 0) {\n            lastRewardTimestamp = block.timestamp;\n            return;\n        }\n        uint256 multiplier = block.timestamp - lastRewardTimestamp;\n        uint256 rJoeReward = multiplier * rJoePerSec;\n        accRJoePerShare =\n            accRJoePerShare +\n            (rJoeReward * PRECISION) /\n            joeSupply;\n        lastRewardTimestamp = block.timestamp;\n\n        rJoe.mint(address(this), rJoeReward);\n    }\n\n    /// @notice Safe rJoe transfer function, just in case if rounding error causes pool to not have enough JOEs\n    /// @param _to Address that wil receive rJoe\n    /// @param _amount The amount to send\n    function _safeRJoeTransfer(address _to, uint256 _amount) internal {\n        uint256 rJoeBal = rJoe.balanceOf(address(this));\n        if (_amount > rJoeBal) {\n            rJoe.transfer(_to, rJoeBal);\n        } else {\n            rJoe.transfer(_to, _amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "RocketJoeStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RocketJoeStaking.sol#L151",
                "Type": "Improper Upper Bound Definition",
                "Description": "The rJoePerSec does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.",
                "Repair": "Define upper and lower bounds on the rJoePerSec"
            },
            {
                "Location": "RocketJoeStaking.lastRewardTimestamp",
                "Type": "Uninitialized variable",
                "Description": "If a user first directly transfers Joe tokens to the contract before the first updatePool call, the block.timestamp lastRewardTimestamp = block.timestamp will be a large timestamp value and lots of rJoe will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the rJoe total supply might not be desired.",
                "Repair": "Track the actual total deposits in a storage variable and use this value instead of the current balance for joeSupply"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\n\n/// @title Rocket Joe Token - rJOE\n/// @author Trader Joe\n/// @notice Infinite supply, but burned to join launch event\ncontract RocketJoeToken is ERC20(\"RocketJoeToken\", \"rJOE\"), Ownable {\n    IRocketJoeFactory public rocketJoeFactory;\n\n    /// @notice Modifier which checks if message.sender is a launch event\n    modifier onlyRJLaunchEvent() {\n        require(\n            rocketJoeFactory.isRJLaunchEvent(msg.sender),\n            \"RocketJoeToken: caller is not a RJLaunchEvent\"\n        );\n        _;\n    }\n\n    /// @notice Initialise the rocketJoeFactory address\n    function initialize() external {\n        require(\n            address(rocketJoeFactory) == address(0),\n            \"RocketJoeToken: already initialized\"\n        );\n\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n    }\n\n    /// @dev Creates `_amount` token to `_to`. Must only be called by the owner (RocketJoeStaking)\n    /// @param _to The address that will receive the mint\n    /// @param _amount The amount to be minted\n    function mint(address _to, uint256 _amount) external onlyOwner {\n        _mint(_to, _amount);\n    }\n\n    /// @dev Destroys `_amount` tokens from `_from`. Callable only by a RJLaunchEvent\n    /// this doesn't need any approval in order to avoid double approval before entering each launch event\n    /// @param _from The address that will burn tokens\n    /// @param _amount The amount to be burned\n    function burnFrom(address _from, uint256 _amount)\n        external\n        onlyRJLaunchEvent\n    {\n        _burn(_from, _amount);\n    }\n\n    /// @dev Hook that is called before any transfer of tokens. This includes\n    /// minting and burning\n    /// @param _from The address that will transfer the tokens\n    /// @param _to The address that will receive the tokens\n    /// @param _amount The amount of token to send\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override {\n        require(\n            _from == address(0) || _to == address(0) || _from == owner(),\n            \"RocketJoeToken: can't send token\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "RocketJoeToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RocketJoeToken.sol#L37",
                "Type": "Minting Tokens Before Ownership Transfer",
                "Description": "There is a possibility of the rJOE tokens in RocketJoeToken.sol to be minted by original owner without staking any JOE, before the ownership is transferred to RocketJoeStakingContract.",
                "Repair": "Define and override the transferOwnership(address) function with an additional check that the totalSupply <= 0"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\n// Copyright (c) 2022 Trader Joe - All rights reserved\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/ILaunchEvent.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\n\n/// @title Rocket Joe Factory\n/// @author Trader Joe\n/// @notice Factory that creates Rocket Joe events\ncontract RocketJoeFactory is IRocketJoeFactory, Ownable {\n    address public override penaltyCollector;\n    address public override eventImplementation;\n\n    address public override rJoe;\n    uint256 public override rJoePerAvax;\n    address public override wavax;\n    address public override router;\n    address public override factory;\n\n    uint256 public override PHASE_ONE_DURATION = 2 days;\n    uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days;\n    uint256 public override PHASE_TWO_DURATION = 1 days;\n\n    mapping(address => address) public override getRJLaunchEvent;\n    mapping(address => bool) public override isRJLaunchEvent;\n    address[] public override allRJLaunchEvents;\n\n    /// @notice Creates the launch event factory\n    /// @dev Uses clone factory pattern to save space\n    /// @param _eventImplementation Implementation of launch event contract\n    /// @param _rJoe rJOE token address\n    /// @param _wavax WAVAX token address\n    /// @param _penaltyCollector Address that collects all withdrawal penalties\n    /// @param _router Router used to create LP on Trader Joe AMM\n    /// @param _factory Factory used to get info of JoePairs\n    constructor(\n        address _eventImplementation,\n        address _rJoe,\n        address _wavax,\n        address _penaltyCollector,\n        address _router,\n        address _factory\n    ) {\n        require(\n            _eventImplementation != address(0) &&\n                _rJoe != address(0) &&\n                _wavax != address(0) &&\n                _penaltyCollector != address(0) &&\n                _router != address(0) &&\n                _factory != address(0),\n            \"RJFactory: Addresses can't be null address\"\n        );\n        IRocketJoeToken(_rJoe).initialize();\n\n        eventImplementation = _eventImplementation;\n        rJoe = _rJoe;\n\n        wavax = _wavax;\n        penaltyCollector = _penaltyCollector;\n        router = _router;\n        factory = _factory;\n        rJoePerAvax = 100;\n    }\n\n    /// @notice Returns the number of launch events\n    /// @return The number of launch events ever created\n    function numLaunchEvents() external view override returns (uint256) {\n        return allRJLaunchEvents.length;\n    }\n\n    /// @notice Creates a launch event contract\n    /// @param _issuer Address of the project issuing tokens for auction\n    /// @param _phaseOneStartTime Timestamp of when launch event will start\n    /// @param _token Token that will be issued through this launch event\n    /// @param _tokenAmount Amount of tokens that will be issued\n    /// @param _tokenIncentivesPercent Additional tokens that will be given as\n    /// incentive for locking up LPs during phase 3 expressed as a percentage\n    /// of the issuing tokens for sale, scaled to 1e18\n    /// @param _floorPrice Price of each token in AVAX, scaled to 1e18\n    /// @param _maxWithdrawPenalty Maximum withdrawal penalty that can be met\n    /// during phase 1\n    /// @param _fixedWithdrawPenalty Withdrawal penalty during phase 2\n    /// @param _maxAllocation Maximum number of AVAX each participant can commit\n    /// @param _userTimelock Amount of time users' LPs will be locked for\n    /// during phase 3\n    /// @param _issuerTimelock Amount of time issuer's LP will be locked for\n    /// during phase 3\n    /// @return Address of launch event contract\n    function createRJLaunchEvent(\n        address _issuer,\n        uint256 _phaseOneStartTime,\n        address _token,\n        uint256 _tokenAmount,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external override returns (address) {\n        require(\n            getRJLaunchEvent[_token] == address(0),\n            \"RJFactory: token has already been issued\"\n        );\n        require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");\n        require(_token != address(0), \"RJFactory: token can't be 0 address\");\n        require(_token != wavax, \"RJFactory: token can't be wavax\");\n        require(\n            _tokenAmount > 0,\n            \"RJFactory: token amount needs to be greater than 0\"\n        );\n        require(\n            IJoeFactory(factory).getPair(_token, wavax) == address(0) ||\n                IJoePair(IJoeFactory(factory).getPair(_token, wavax))\n                    .totalSupply() ==\n                0,\n            \"RJFactory: liquid pair already exists\"\n        );\n\n        address launchEvent = Clones.clone(eventImplementation);\n\n        // msg.sender needs to approve RocketJoeFactory\n        IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);\n\n        ILaunchEvent(payable(launchEvent)).initialize(\n            _issuer,\n            _phaseOneStartTime,\n            _token,\n            _tokenIncentivesPercent,\n            _floorPrice,\n            _maxWithdrawPenalty,\n            _fixedWithdrawPenalty,\n            _maxAllocation,\n            _userTimelock,\n            _issuerTimelock\n        );\n\n        getRJLaunchEvent[_token] = launchEvent;\n        isRJLaunchEvent[launchEvent] = true;\n        allRJLaunchEvents.push(launchEvent);\n\n        _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);\n\n        return launchEvent;\n    }\n\n    /// @notice Set rJOE address\n    /// @param _rJoe New rJOE address\n    function setRJoe(address _rJoe) external override onlyOwner {\n        IRocketJoeToken(_rJoe).initialize();\n        rJoe = _rJoe;\n        emit SetRJoe(_rJoe);\n    }\n\n    /// @notice Set address to collect withdrawal penalties\n    /// @param _penaltyCollector New penalty collector address\n    function setPenaltyCollector(address _penaltyCollector)\n        external\n        override\n        onlyOwner\n    {\n        penaltyCollector = _penaltyCollector;\n        emit SetPenaltyCollector(_penaltyCollector);\n    }\n\n    /// @notice Set JoeRouter address\n    /// @param _router New router address\n    function setRouter(address _router) external override onlyOwner {\n        router = _router;\n        emit SetRouter(_router);\n    }\n\n    /// @notice Set JoeFactory address\n    /// @param _factory New factory address\n    function setFactory(address _factory) external override onlyOwner {\n        factory = _factory;\n        emit SetFactory(_factory);\n    }\n\n    /// @notice Set amount of rJOE required to deposit 1 AVAX into launch event\n    /// @dev Configured by team between launch events to control inflation\n    function setRJoePerAvax(uint256 _rJoePerAvax) external override onlyOwner {\n        rJoePerAvax = _rJoePerAvax;\n        emit SetRJoePerAvax(_rJoePerAvax);\n    }\n\n    /// @notice Set duration of each of the three phases\n    /// @param _phaseNumber Can be only 1 or 2\n    /// @param _duration Duration of phase in seconds\n    function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)\n        external\n        override\n        onlyOwner\n    {\n        if (_phaseNumber == 1) {\n            require(\n                _duration > PHASE_ONE_NO_FEE_DURATION,\n                \"RJFactory: phase one duration lower than no fee duration\"\n            );\n            PHASE_ONE_DURATION = _duration;\n        } else if (_phaseNumber == 2) {\n            PHASE_TWO_DURATION = _duration;\n        }\n    }\n\n    /// @notice Set the no fee duration of phase 1\n    /// @param _noFeeDuration Duration of no fee phase\n    function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _noFeeDuration < PHASE_ONE_DURATION,\n            \"RJFactory: no fee duration bigger than phase one duration\"\n        );\n        PHASE_ONE_NO_FEE_DURATION = _noFeeDuration;\n    }\n\n    /// @dev This function emits an event after a new launch event has been created\n    /// It is only seperated out due to `createRJLaunchEvent` having too many local variables\n    function _emitLaunchedEvent(\n        address _issuer,\n        address _token,\n        uint256 _phaseOneStartTime\n    ) internal {\n        uint256 _phaseTwoStartTime = _phaseOneStartTime + PHASE_ONE_DURATION;\n        uint256 _phaseThreeStartTime = _phaseTwoStartTime + PHASE_TWO_DURATION;\n\n        emit RJLaunchEventCreated(\n            _issuer,\n            _token,\n            _phaseOneStartTime,\n            _phaseTwoStartTime,\n            _phaseThreeStartTime,\n            rJoe,\n            rJoePerAvax\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "RocketJoeFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RocketJoeFactory.sol#createRJLaunchEvent()",
                "Type": "Calling Function with Minimal Cost",
                "Description": "In the current implementation, RocketJoeFactory.sol#createRJLaunchEvent() can be called by anyone with at least 1 Wei of _token. This allows a malicious user or attacker to call createRJLaunchEvent() with minimal cost and stop others, especially the platform itself or the rightful issuer of the token from creating the RJLaunchEvent.",
                "Repair": "Consider making createRJLaunchEvent() only callable by the owner of RocketJoeFactory"
            }
        ]
    }
]