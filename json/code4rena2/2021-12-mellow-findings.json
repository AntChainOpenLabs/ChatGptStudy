[
    {
        "Code": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/IAaveVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Aave protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the\n/// last `deposit` / `withdraw`\n///\n/// ### aTokens\n/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.\n/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,\n/// the AaveVault cannot be created.\n///\n/// ### Push / Pull\n/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.\n/// The contract's vaultTokens are fully allowed to Aave Lending Pool.\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\n\n\n",
        "CodeNames": [
            "AaveVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AaveVault does not update TVL on deposit/withdraw",
                "Type": "High Severity",
                "Description": "Allows an attacker to deposit tokens, get a fair share of the old TVL, update the TVL to include the interest, and then withdraw the LP tokens receiving a larger share of the new TVL, receiving back their initial deposit + the share of the interest.",
                "Repair": "Update the TVL when depositing and withdrawing before doing anything else"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Users can avoid paying vault fees",
                "Type": "Medium Severity",
                "Description": "Allows a user to avoid paying any fees if they deposit right after a charge fee interaction and withdraw within again managementFeeChargeDelay time period.",
                "Repair": "Fees must always be charged on each deposit and withdrawal, even within the same block as it could be that a huge interest 'harvest' comes in that an attacker sandwiches"
            },
            {
                "Location": "Bad redirects can make it impossible to deposit & withdraw",
                "Type": "Medium Severity",
                "Description": "If the redirects array is misconfigured, it's possible that all amountsByVault are set to zero. There are many misconfigurations that can lead to not being able to deposit to the pool anymore.",
                "Repair": "The redirects[i] = j matrix needs to be restricted. If i is redirected to j, j may not redirect itself. Check for this when setting the redirects array."
            },
            {
                "Location": "UniswapV3's path issue for swapExactOutput",
                "Type": "Medium Severity",
                "Description": "The UniV3Trader.swapExactOutput function with multi-hops is broken and cannot be used.",
                "Repair": "Don't reverse the path byte-by-byte but element-by-element."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/external/univ3/INonfungiblePositionManager.sol\";\nimport \"./interfaces/external/univ3/IUniswapV3Pool.sol\";\nimport \"./interfaces/external/univ3/IUniswapV3Factory.sol\";\nimport \"./interfaces/IUniV3VaultGovernance.sol\";\nimport \"./libraries/external/TickMath.sol\";\nimport \"./libraries/external/LiquidityAmounts.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.\ncontract UniV3Vault is IERC721Receiver, Vault {\n    struct Options {\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct Pair {\n        uint256 a0;\n        uint256 a1;\n    }\n\n    IUniswapV3Pool public immutable pool;\n\n    uint256 public uniV3Nft;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param fee Fee of the underlying UniV3 pool\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        uint24 fee\n    ) Vault(vaultGovernance_, vaultTokens_) {\n        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);\n        pool = IUniswapV3Pool(\n            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)\n        );\n    }\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {\n        require(msg.sender == address(_positionManager()), \"SNFT\");\n        require(_isStrategy(operator), \"STR\");\n        (\n            , ,\n            address token0,\n            address token1,\n            , , , , , , ,\n        ) = _positionManager().positions(tokenId);\n        // new position should have vault tokens\n        require(\n            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],\n            \"VT\"\n        );\n\n        if (uniV3Nft != 0) {\n            (\n                , , , , , , ,\n                uint128 liquidity,\n                , ,\n                uint128 tokensOwed0,\n                uint128 tokensOwed1\n            ) = _positionManager().positions(uniV3Nft);\n            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, \"TVL\");\n            // return previous uni v3 position nft\n            _positionManager().transferFrom(address(this), from, uniV3Nft);\n        }\n\n        uniV3Nft = tokenId;\n        return this.onERC721Received.selector;\n    }\n\n    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {\n        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        address owner = registry.ownerOf(_nft);\n        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);\n        collectedEarnings = new uint256[](2);\n        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n        collectedEarnings[0] = collectedEarnings0;\n        collectedEarnings[1] = collectedEarnings1;\n        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        if (uniV3Nft == 0)\n            return tokenAmounts;\n        (\n            , , , , , \n            int24 tickLower, \n            int24 tickUpper, \n            uint128 liquidity,\n            , , ,\n        ) = _positionManager().positions(uniV3Nft);\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            sqrtPriceAX96,\n            sqrtPriceBX96,\n            liquidity\n        );\n        tokenAmounts[0] = amount0;\n        tokenAmounts[1] = amount1;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < tokens.length; i++)\n            _allowTokenIfNecessary(tokens[i]);\n\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = Pair({\n            a0: tokenAmounts[0],\n            a1: tokenAmounts[1]\n        });\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                amount0Desired: amounts.a0,\n                amount1Desired: amounts.a1,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        actualTokenAmounts[0] = amount0;\n        actualTokenAmounts[1] = amount1;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);\n        actualTokenAmounts[0] = amounts.a0;\n        actualTokenAmounts[1] = amounts.a1;\n    }\n\n    function _pullUniV3Nft(\n        uint256[] memory tokenAmounts,\n        address to,\n        Options memory opts\n    ) internal returns (Pair memory) {\n        uint128 liquidityToPull;\n        // scope the code below to avoid stack-too-deep exception\n        {\n            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);\n            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]\n            );\n            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;\n            if (liquidityToPull == 0) {\n                return Pair({a0: 0, a1: 0});\n            }\n        }\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                liquidity: liquidityToPull,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: uint128(amount0),\n                amount1Max: uint128(amount1)\n            })\n        );\n        return Pair({a0: amount0Collected, a1: amount1Collected});\n    }\n\n    function _postReclaimTokens(address, address[] memory tokens) internal view override {}\n\n    /// TODO: make a virtual function here? Or other better approach\n    function _positionManager() internal view returns (INonfungiblePositionManager) {\n        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)\n            IERC20(token).approve(address(_positionManager()), type(uint256).max);\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (Options memory) {\n        if (options.length == 0)\n            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});\n\n        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);\n        return abi.decode(options, (Options));\n    }\n\n    function _isStrategy(address addr) internal view returns (bool) {\n        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;\n    }\n\n    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);\n}\n\n\n",
        "CodeNames": [
            "UniV3Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniV3Vault.sol#collectEarnings() can be front run",
                "Type": "High Severity",
                "Description": "In the current implementation, unharvested yields are not included in tvl(), making it vulnerable to front-run attacks that steal pending yields.",
                "Repair": "Consider including fees in tvl()."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/external/yearn/IYearnVault.sol\";\nimport \"./interfaces/IYearnVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Yearn protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Yearn since the\n/// last `deposit` / `withdraw`\n///\n/// ### yTokens\n/// yTokens are fixed at the token creation and addresses are taken from YearnVault governance and if missing there\n/// - in YearnVaultRegistry.\n/// So essentially each yToken is fixed for life of the YearnVault. If the yToken is missing for some vaultToken,\n/// the YearnVault cannot be created.\n///\n/// ### Push / Pull\n/// There are some deposit limits imposed by Yearn vaults.\n/// The contract's vaultTokens are fully allowed to corresponding yTokens.\n\ncontract YearnVault is Vault {\n    address[] private _yTokens;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _yTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            _yTokens[i] = IYearnVaultGovernance(address(vaultGovernance_)).yTokenForToken(_vaultTokens[i]);\n            require(_yTokens[i] != address(0), \"YV\");\n        }\n    }\n\n    /// @notice Yearn protocol vaults used by this contract\n    function yTokens() external view returns (address[] memory) {\n        return _yTokens;\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        tokenAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            tokenAmounts[i] = (yToken.balanceOf(address(this)) * yToken.pricePerShare()) / (10**yToken.decimals());\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n\n            address token = tokens[i];\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            _allowTokenIfNecessary(token, address(yToken));\n            yToken.deposit(tokenAmounts[i], address(this));\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        uint256 maxLoss = abi.decode(options, (uint256));\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());\n            uint256 balance = yToken.balanceOf(address(this));\n            if (yTokenAmount > balance) {\n                yTokenAmount = balance;\n            }\n            if (yTokenAmount == 0) {\n                continue;\n            }\n            yToken.withdraw(yTokenAmount, to, maxLoss);\n            (tokenAmounts[i], address(this));\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _allowTokenIfNecessary(address token, address yToken) internal {\n        if (IERC20(token).allowance(address(this), yToken) < type(uint256).max / 2) {\n            IERC20(token).approve(yToken, type(uint256).max);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "YearnVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "YearnVault.sol#pull()",
                "Type": "Precision Loss",
                "Description": "The actual token withdrew from yToken.withdraw() will most certainly be less than the tokenAmounts[i], due to precision loss in the calculation of yTokenAmount. As a result, IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]); in LpIssuer.sol#withdraw() will revert due to insufficient balance.",
                "Repair": "Change the code to withdraw the actual token amount from the YearnVault contract instead of relying on the calculated token amount."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./libraries/CommonLibrary.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IProtocolGovernance.sol\";\nimport \"./interfaces/ILpIssuer.sol\";\nimport \"./DefaultAccessControl.sol\";\nimport \"./LpIssuerGovernance.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.\ncontract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    uint256 private _subvaultNft;\n    IVaultGovernance internal _vaultGovernance;\n    address[] internal _vaultTokens;\n    mapping(address => bool) internal _vaultTokensIndex;\n    uint256 private _nft;\n    uint256[] private _lpPriceHighWaterMarks;\n    uint256[] private _existentials;\n\n    uint256 public lastFeeCharge;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param name_ Name of the ERC-721 token\n    /// @param symbol_ Symbol of the ERC-721 token\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) {\n        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);\n        _vaultGovernance = vaultGovernance_;\n        _vaultTokens = vaultTokens_;\n        for (uint256 i = 0; i < vaultTokens_.length; i++) {\n            address token = vaultTokens_[i];\n            _vaultTokensIndex[token] = true;\n            _lpPriceHighWaterMarks.push(0);\n            _existentials.push(10**(ERC20(token).decimals() / 2));\n        }\n        lastFeeCharge = block.timestamp;\n    }\n\n    function vaultGovernance() external view returns (IVaultGovernance) {\n        return _vaultGovernance;\n    }\n\n    function vaultTokens() external view returns (address[] memory) {\n        return _vaultTokens;\n    }\n\n    function existentials() external view returns (uint256[] memory) {\n        return _existentials;\n    }\n\n    /// @inheritdoc ILpIssuer\n    function subvaultNft() external view returns (uint256) {\n        return _subvaultNft;\n    }\n\n    function nft() external view returns (uint256) {\n        return _nft;\n    }\n\n    function initialize(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);\n        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);\n        _nft = nft_;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        registry.setApprovalForAll(address(registry), true);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 thisNft = _nft;\n        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);\n        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);\n        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);\n        IVault subvault = _subvault();\n        uint256[] memory existentials_ = _existentials;\n        uint256[] memory tvl = subvault.tvl(); //pre-money\n        uint256 supply = totalSupply();\n        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;\n        if (supply > 0) {\n            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR\n            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);\n        }\n\n        // If with that big supply we don't reveive any lps then it doesn't make sense to continue\n        require(balanceFactor > 0, \"BF\");\n        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);\n\n        // Making sure the proportion between tokenAmounts and tvl are the same\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);\n            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));\n            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);\n        }\n\n        uint256[] memory actualTokenAmounts = subvault.transferAndPush(\n            address(this),\n            _vaultTokens,\n            balancedAmounts,\n            options\n        );\n        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);\n\n        require(amountToMint > 0, \"ZLP\");\n\n        require(\n            amountToMint + balanceOf(msg.sender) <=\n                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,\n            ExceptionsLibrary.LIMIT_PER_ADDRESS\n        );\n\n        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);\n        _mint(msg.sender, amountToMint);\n\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (balancedAmounts[i] > actualTokenAmounts[i]) {\n                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);\n            }\n        }\n\n        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function withdraw(\n        address to,\n        uint256 lpTokenAmount,\n        bytes memory options\n    ) external nonReentrant {\n        uint256 supply = totalSupply();\n        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);\n        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);\n        uint256[] memory tvl = _subvault().tvl();\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;\n        }\n        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (actualTokenAmounts[i] == 0) {\n                continue;\n            }\n            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);\n        }\n        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);\n        _burn(msg.sender, lpTokenAmount);\n        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function addSubvault(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n        _subvaultNft = nft_;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _subvault() internal view returns (IVault) {\n        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));\n    }\n\n    /// @dev We don't charge on any deposit / withdraw to save gas.\n    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)\n    /// So the error results in slightly lower management fees than in exact case\n    function _chargeFees(\n        uint256 thisNft,\n        uint256[] memory tvls,\n        uint256 supply,\n        uint256[] memory deltaTvls,\n        uint256 deltaSupply,\n        bool isWithdraw\n    ) internal {\n        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));\n        uint256 elapsed = block.timestamp - lastFeeCharge;\n        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n            return;\n        }\n        lastFeeCharge = block.timestamp;\n        uint256 baseSupply = supply;\n        if (isWithdraw) {\n            baseSupply = 0;\n            if (supply > deltaSupply) {\n                baseSupply = supply - deltaSupply;\n            }\n        }\n\n        if (baseSupply == 0) {\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;\n            }\n            return;\n        }\n\n        uint256[] memory baseTvls = new uint256[](tvls.length);\n        for (uint256 i = 0; i < baseTvls.length; i++) {\n            if (isWithdraw) {\n                baseTvls[i] = tvls[i] - deltaTvls[i];\n            } else {\n                baseTvls[i] = tvls[i];\n            }\n        }\n\n        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);\n        if (strategyParams.managementFee > 0) {\n            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /\n                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(strategyParams.strategyTreasury, toMint);\n            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);\n        }\n        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;\n        if (protocolFee > 0) {\n            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();\n            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(treasury, toMint);\n            emit ProtocolFeesCharged(treasury, protocolFee, toMint);\n        }\n        uint256 performanceFee = strategyParams.performanceFee;\n        uint256[] memory hwms = _lpPriceHighWaterMarks;\n        if (performanceFee > 0) {\n            uint256 minLpPriceFactor = type(uint256).max;\n            for (uint256 i = 0; i < baseTvls.length; i++) {\n                uint256 hwm = hwms[i];\n                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;\n                if (lpPrice > hwm) {\n                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;\n                    if (delta < minLpPriceFactor) {\n                        minLpPriceFactor = delta;\n                    }\n                } else {\n                    // not eligible for performance fees\n                    return;\n                }\n            }\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            }\n            address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);\n            emit PerformanceFeesCharged(treasury, performanceFee, toMint);\n        }\n    }\n\n    function _getLpAmount(\n        uint256[] memory tvl,\n        uint256[] memory amounts,\n        uint256[] memory existentials_,\n        uint256 supply\n    ) internal pure returns (uint256 lpAmount) {\n        lpAmount = 0;\n        if (supply == 0) {\n            // On init lpToken = max(tokenAmounts)\n            for (uint256 i = 0; i < tvl.length; i++) {\n                if (amounts[i] > lpAmount) {\n                    lpAmount = amounts[i];\n                }\n            }\n            return lpAmount;\n        }\n        for (uint256 i = 0; i < tvl.length; i++) {\n            if (amounts[i] <= existentials_[i]) {\n                // skip existential deposits for lp share calculation\n                continue;\n            }\n            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];\n            // take min of meaningful tokenLp amounts\n            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {\n                lpAmount = tokenLpAmount;\n            }\n        }\n    }\n\n    function _getBalancedAmount(\n        uint256 tvl,\n        uint256 amount,\n        uint256 existential,\n        uint256 balanceFactor,\n        uint256 supply\n    ) internal pure returns (uint256) {\n        if (supply == 0) {\n            // skip normalization on init\n            return amount;\n        }\n        if (amount < existential) {\n            // avoid putting small amounts as it can introduce unnecessary harsh errors\n            // one should provide amount > existential deposit each time tvl is not 0\n            require(tvl == 0, \"PN\");\n            return 0;\n        }\n        // normalize amount\n        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;\n        if (res > amount) {\n            res = amount;\n        }\n        return res;\n    }\n\n    /// @notice Emitted when management fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when protocol fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when performance fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when liquidity is deposited\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens deposited\n    /// @param actualTokenAmounts Token amounts deposited\n    /// @param lpTokenMinted LP tokens received by the liquidity provider\n    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);\n\n    /// @notice Emitted when liquidity is withdrawn\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens withdrawn\n    /// @param actualTokenAmounts Token amounts withdrawn\n    /// @param lpTokenBurned LP tokens burned from the liquidity provider\n    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);\n}\n\n\n",
        "CodeNames": [
            "LpIssuer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LpIssuer.sol#withdraw()",
                "Type": "Cache Invalidation",
                "Description": "AaveVault cache tvl and update it at the end of each _push and _pull. When withdrawing from LpIssuer, tokenAmounts is calculated using the cached tvl to be pulled from AaveVault. This will lead to user missing out their share of the accrued interest / donations to Aave since the last updateTvls.",
                "Repair": "Call updateTvls at the beginning of withdraw function if the _subvault will cache tvl"
            },
            {
                "Location": "LpIssuer.deposit()",
                "Type": "Front-running",
                "Description": "The LPIssuer.deposit first computes balanced amounts on the user's defined tokenAmounts. The idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be balanced, meaning, the depositAmount / tvl ratio should be equal for all vault tokens. But the strategist can front-run the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance. This front-run can happen accidentally whenever the strategist rebalances. Users can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.",
                "Repair": "Add minimum return amount checks. Accept a function parameter that can be chosen by the user indicating their expected LP amount for their deposit tokenAmounts, then check that the actually minted LP token amount is above this parameter."
            },
            {
                "Location": "LpIssuer.sol#_chargeFees()",
                "Type": "Incorrect Formula",
                "Description": "A certain amount of lp tokens (shares of the vault) will be minted to the strategyPerformanceTreasury as performanceFee, the amount is calculated based on the minLpPriceFactor. However, the current formula for toMint is wrong, which issues more than 100% of the current totalSupply of the lp token to the strategyPerformanceTreasury each time. Causing users to lose 50% to 100% of their funds after a few times.",
                "Repair": "Change the formula to calculate toMint to (baseSupply * (minLpPriceFactor * performanceFee) / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/IProtocolGovernance.sol\";\nimport \"./DefaultAccessControl.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Governance that manages all params common for Mellow Permissionless Vaults protocol.\ncontract ProtocolGovernance is IProtocolGovernance, DefaultAccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    uint256 public constant MAX_GOVERNANCE_DELAY = 7 days;\n\n    EnumerableSet.AddressSet private _claimAllowlist;\n    address[] private _pendingClaimAllowlistAdd;\n    uint256 public pendingClaimAllowlistAddTimestamp;\n\n    address[] private _tokenWhitelist;\n    address[] private _pendingTokenWhitelistAdd;\n    uint256 private _numberOfValidTokens;\n    mapping(address => bool) _tokensAllowed;\n    mapping(address => bool) _tokenEverAdded;\n    uint256 public pendingTokenWhitelistAddTimestamp;\n\n    EnumerableSet.AddressSet private _vaultGovernances;\n    address[] private _pendingVaultGovernancesAdd;\n    uint256 public pendingVaultGovernancesAddTimestamp;\n\n    IProtocolGovernance.Params public params;\n    Params public pendingParams;\n\n    uint256 public pendingParamsTimestamp;\n\n    /// @notice Creates a new contract.\n    /// @param admin Initial admin of the contract\n    constructor(address admin) DefaultAccessControl(admin) {\n        _tokenWhitelist = new address[](0);\n        _numberOfValidTokens = 0;\n    }\n\n    // -------------------  PUBLIC, VIEW  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function claimAllowlist() external view returns (address[] memory) {\n        uint256 l = _claimAllowlist.length();\n        address[] memory res = new address[](l);\n        for (uint256 i = 0; i < l; i++) {\n            res[i] = _claimAllowlist.at(i);\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function tokenWhitelist() external view returns (address[] memory) {\n        uint256 l = _tokenWhitelist.length;\n        address[] memory res = new address[](_numberOfValidTokens);\n        uint256 j = 0;\n        for (uint256 i = 0; i < l; i++) {\n            if (!_tokensAllowed[_tokenWhitelist[i]] && _tokenEverAdded[_tokenWhitelist[i]]) {\n                continue;\n            }\n            res[j] = _tokenWhitelist[i];\n            j += 1;\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function vaultGovernances() external view returns (address[] memory) {\n        uint256 l = _vaultGovernances.length();\n        address[] memory res = new address[](l);\n        for (uint256 i = 0; i < l; i++) {\n            res[i] = _vaultGovernances.at(i);\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingClaimAllowlistAdd() external view returns (address[] memory) {\n        return _pendingClaimAllowlistAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingTokenWhitelistAdd() external view returns (address[] memory) {\n        return _pendingTokenWhitelistAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingVaultGovernancesAdd() external view returns (address[] memory) {\n        return _pendingVaultGovernancesAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isAllowedToClaim(address addr) external view returns (bool) {\n        return _claimAllowlist.contains(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isAllowedToken(address addr) external view returns (bool) {\n        return _tokenEverAdded[addr] && _tokensAllowed[addr];\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isVaultGovernance(address addr) external view returns (bool) {\n        return _vaultGovernances.contains(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function permissionless() external view returns (bool) {\n        return params.permissionless;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function maxTokensPerVault() external view returns (uint256) {\n        return params.maxTokensPerVault;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function governanceDelay() external view returns (uint256) {\n        return params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function protocolTreasury() external view returns (address) {\n        return params.protocolTreasury;\n    }\n\n    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingClaimAllowlistAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        _pendingClaimAllowlistAdd = addresses;\n        pendingClaimAllowlistAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromClaimAllowlist(address addr) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        if (!_claimAllowlist.contains(addr)) {\n            return;\n        }\n        _claimAllowlist.remove(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingTokenWhitelistAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), \"ADM\");\n        _pendingTokenWhitelistAdd = addresses;\n        pendingTokenWhitelistAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromTokenWhitelist(address addr) external {\n        require(isAdmin(msg.sender), \"ADM\");\n        _tokensAllowed[addr] = false;\n        if (_tokenEverAdded[addr]) {\n            --_numberOfValidTokens;\n        }\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingVaultGovernancesAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        _pendingVaultGovernancesAdd = addresses;\n        pendingVaultGovernancesAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromVaultGovernances(address addr) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        if (!_vaultGovernances.contains(addr)) {\n            return;\n        }\n        _vaultGovernances.remove(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingParams(IProtocolGovernance.Params memory newParams) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(params.governanceDelay <= MAX_GOVERNANCE_DELAY, ExceptionsLibrary.MAX_GOVERNANCE_DELAY);\n        pendingParams = newParams;\n        pendingParamsTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function commitClaimAllowlistAdd() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(\n            (block.timestamp >= pendingClaimAllowlistAddTimestamp) && (pendingClaimAllowlistAddTimestamp > 0),\n            ExceptionsLibrary.TIMESTAMP\n        );\n        for (uint256 i = 0; i < _pendingClaimAllowlistAdd.length; i++) {\n            _claimAllowlist.add(_pendingClaimAllowlistAdd[i]);\n        }\n        delete _pendingClaimAllowlistAdd;\n        delete pendingClaimAllowlistAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitTokenWhitelistAdd() external {\n        require(isAdmin(msg.sender), \"ADM\");\n        require(\n            (block.timestamp >= pendingTokenWhitelistAddTimestamp) && (pendingTokenWhitelistAddTimestamp > 0),\n            \"TS\"\n        );\n        for (uint256 i = 0; i < _pendingTokenWhitelistAdd.length; i++) {\n            if (!_tokenEverAdded[_pendingTokenWhitelistAdd[i]]) {\n                _numberOfValidTokens += 1;\n                _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;\n                _tokenWhitelist.push(_pendingTokenWhitelistAdd[i]);\n                _tokenEverAdded[_pendingTokenWhitelistAdd[i]] = true;\n            } else {\n                if (!_tokensAllowed[_pendingTokenWhitelistAdd[i]]) {\n                    _numberOfValidTokens += 1;\n                    _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;\n                }\n            }\n        }\n        delete _pendingTokenWhitelistAdd;\n        delete pendingTokenWhitelistAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitVaultGovernancesAdd() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(\n            (block.timestamp >= pendingVaultGovernancesAddTimestamp) && (pendingVaultGovernancesAddTimestamp > 0),\n            ExceptionsLibrary.TIMESTAMP\n        );\n        for (uint256 i = 0; i < _pendingVaultGovernancesAdd.length; i++) {\n            _vaultGovernances.add(_pendingVaultGovernancesAdd[i]);\n        }\n        delete _pendingVaultGovernancesAdd;\n        delete pendingVaultGovernancesAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitParams() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(block.timestamp >= pendingParamsTimestamp, ExceptionsLibrary.TIMESTAMP);\n        require(pendingParams.maxTokensPerVault > 0 || pendingParams.governanceDelay > 0, ExceptionsLibrary.EMPTY_PARAMS); // sanity check for empty params\n        params = pendingParams;\n        delete pendingParams;\n        delete pendingParamsTimestamp;\n    }\n}\n\n\n",
        "CodeNames": [
            "ProtocolGovernance.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ProtocolGovernance.removeFromTokenWhitelist function",
                "Type": "Decrease in _numberOfValidTokens by admin",
                "Description": "The admin can repeatedly call the removeFromTokenWhitelist function and decrease _numberOfValidTokens to zero, even if the token was never allowed before. This leads to an incorrect tokenWhitelist.",
                "Repair": "Decrease _numberOfValidTokens only if the token was previously allowed"
            }
        ]
    }
]