[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n",
        "CodeNames": [
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Market.sol#L281-L283",
                "Type": "Avoidable misconfiguration",
                "Description": "If a user creates a market with the INVEscrow implementation as escrowImplementation and false as callOnDepositCallback, the deposits made by users in the escrow (through the market) would not mint xINV tokens for them.",
                "Repair": "Make callOnDepositCallback a configurable parameter in Market.sol or always call the onDeposit callback and leave it empty in case there's no extra functionality that needs to be executed for that escrow."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n",
        "CodeNames": [
            "Oracle.sol",
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Oracle.sol#L78-L105, Oracle.sol#L112-L144, Market.sol#L344-L347, Market.sol#L323-L327",
                "Type": "Denial of Service (DoS)",
                "Description": "When Chainlink's multisigs block access to price feeds, executing feeds[token].feed.latestAnswer() will revert, causing denial of service when calling functions like getCollateralValueInternal and getWithdrawalLimitInternal.",
                "Repair": "Update the Oracle contract's viewPrice and getPrice functions to refactor feeds[token].feed.latestAnswer() into try feeds[token].feed.latestAnswer() returns (int256 price) { ... } catch Error(string memory) { ... }. The logic for getting the collateral token's price from the Chainlink oracle data feed should be placed in the try block while some fallback logic when the access to the Chainlink oracle data feed is denied should be placed in the catch block. If getting the fixed price for the collateral token is considered as a fallback logic, then setting the fixed price for the token should become mandatory, which is different from the current implementation. Otherwise, fallback logic for getting the token's price from a fallback oracle is needed."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function accrueDueTokens(address user) public",
                "Type": "Accrued Interest Avoidance",
                "Description": "Users can avoid paying fees if they manage to update their accrued fees periodically.",
                "Repair": "Do not update the lastUpdated timestamp of the user if the computed accrued amount was zero."
            },
            {
                "Location": "repay() function",
                "Type": "DOS attack",
                "Description": "The repay function can be DOSed by an attacker who frontruns the victim's transaction and reduces the debt of the victim user to a value less than the amount provided, causing the require function to fail and preventing the victim from calling the repay function.",
                "Repair": "Implement DOS protection"
            },
            {
                "Location": "Market::forceReplenish",
                "Type": "DoS",
                "Description": "If a user wants to completely forceReplenish a borrower with deficit, the borrower or any other malicious party can front run this with a dust amount to prevent the replenish.",
                "Repair": "Use min(deficit,amount) as amount to replenish."
            },
            {
                "Location": "Oracle's viewPrice function",
                "Type": "Incorrect Calculation",
                "Description": "Oracle's viewPrice function doesn't report a dampened price until getPrice is called and today's price is updated. This will impact the public read-only functions that call it.",
                "Repair": "Update the viewPrice function to report a dampened price"
            },
            {
                "Location": "function forceReplenish(address user, uint amount) public",
                "Type": "Over-collateralization vulnerability",
                "Description": "Users could get some DOLA even if they are on liquidation position.",
                "Repair": "Limit the debt increase in the function forceReplenish so that the new debt after replenish will not be over the threshold"
            },
            {
                "Location": "function liquidate(address user, uint repaidDebt) public",
                "Type": "Liquidation vulnerability",
                "Description": "Liquidation should make a borrower healthier.",
                "Repair": "Make sure the liquidation does not decrease the health index in the function liquidate"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"./FiRMTest.sol\";\nimport \"../BorrowController.sol\";\nimport \"../DBR.sol\";\nimport \"../Fed.sol\";\nimport {SimpleERC20Escrow} from \"../escrows/SimpleERC20Escrow.sol\";\nimport \"../Market.sol\";\nimport \"../Oracle.sol\";\n\nimport \"./mocks/ERC20.sol\";\nimport \"./mocks/WETH9.sol\";\nimport \"./mocks/BorrowContract.sol\";\nimport {EthFeed} from \"./mocks/EthFeed.sol\";\n\ncontract MarketTest is FiRMTest {\n    bytes onlyGovUnpause = \"Only governance can unpause\";\n    bytes onlyPauseGuardianOrGov = \"Only pause guardian or governance can pause\";\n\n    BorrowContract borrowContract;\n\n    function setUp() public {\n        initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), 1_000_000e18);\n        vm.stopPrank();\n\n        borrowContract = new BorrowContract(address(market), payable(address(WETH)));\n    }\n\n    function testDeposit() public {\n        gibWeth(user, wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), wethTestAmount, \"Escrow balance did not increase\");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n    }\n\n    function testDeposit2() public {\n        gibWeth(user, wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n\n        vm.startPrank(user);\n        WETH.approve(address(market), wethTestAmount);\n        market.deposit(user2, wethTestAmount);\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), 0, \"User balance not 0\");\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user2))), wethTestAmount, \"User2 escrow balance did not increase \");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n        assertEq(WETH.balanceOf(user2), 0, \"User2 not 0\");\n    }\n\n    function testBorrow() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n        uint initialDolaBalance = DOLA.balanceOf(user);\n        deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        assertEq(DOLA.balanceOf(user), initialDolaBalance + borrowAmount, \"User balance did not increase by borrowAmount\");\n    }\n\n    function testDepositAndBorrow() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        uint initialDolaBalance = DOLA.balanceOf(user);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n        WETH.approve(address(market), wethTestAmount);\n        market.depositAndBorrow(wethTestAmount, borrowAmount);\n\n        assertEq(DOLA.balanceOf(user), initialDolaBalance + borrowAmount, \"User balance did not increase by borrowAmount\");\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), wethTestAmount, \"Escrow balance did not increase\");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n    }\n\n    function testBorrowOnBehalf() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        vm.stopPrank();\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(userPk), 0, \"failed to deposit WETH\");\n\n        vm.startPrank(user2);\n        market.borrowOnBehalf(userPk, maxBorrowAmount, block.timestamp, v, r, s);\n\n        assertEq(DOLA.balanceOf(userPk), 0, \"borrowed DOLA went to the wrong user\");\n        assertEq(DOLA.balanceOf(user2), maxBorrowAmount, \"failed to borrow DOLA\");\n    }\n\n    function testBorrowOnBehalf_Fails_When_InvalidateNonceCalledPrior() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.expectRevert(\"INVALID_SIGNER\");\n        market.borrowOnBehalf(userPk, maxBorrowAmount, block.timestamp, v, r, s);\n    }\n\n    function testBorrowOnBehalf_Fails_When_DeadlineHasPassed() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n\n        uint timestamp = block.timestamp;\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.warp(block.timestamp + 1);\n        vm.expectRevert(\"DEADLINE_EXPIRED\");\n        market.borrowOnBehalf(userPk, maxBorrowAmount, timestamp, v, r, s);\n    }\n\n    function testBorrow_Fails_When_BorrowingPaused() public {\n        vm.startPrank(gov);\n        market.pauseBorrows(true);\n        vm.stopPrank();\n\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        vm.expectRevert(\"Borrowing is paused\");\n        market.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_DeniedByBorrowController() public {\n        vm.startPrank(gov);\n        market.setBorrowController(IBorrowController(address(borrowController)));\n        vm.stopPrank();\n\n        gibWeth(address(borrowContract), wethTestAmount);\n        gibDBR(address(borrowContract), wethTestAmount);\n        vm.startPrank(user);\n\n        borrowContract.deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        vm.expectRevert(\"Denied by borrow controller\");\n        borrowContract.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_AmountGTCreditLimit() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        uint borrowAmount = convertWethToDola(wethTestAmount);\n        vm.expectRevert(\"Exceeded credit limit\");\n        market.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_NotEnoughDolaInMarket() public {\n        vm.startPrank(market.lender());\n        market.recall(DOLA.balanceOf(address(market)));\n        vm.stopPrank();\n\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        \n        deposit(wethTestAmount);\n\n        vm.expectRevert(\"SafeMath: subtraction underflow\");\n        market.borrow(1 ether);\n    }\n\n    function testLiquidate_NoLiquidationFee(uint depositAmount, uint liqAmount, uint16 borrowMulti_) public {\n        depositAmount = bound(depositAmount, 1e18, 100_000e18);\n        liqAmount = bound(liqAmount, 500e18, 200_000_000e18);\n        uint borrowMulti = bound(borrowMulti_, 0, 100);\n\n        uint maxBorrowAmount = convertWethToDola(depositAmount) * market.collateralFactorBps() / 10_000;\n        uint borrowAmount = maxBorrowAmount * borrowMulti / 100;\n\n        gibWeth(user, depositAmount);\n        gibDBR(user, depositAmount);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), convertWethToDola(depositAmount));\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        deposit(depositAmount);\n        market.borrow(borrowAmount);\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, liqAmount);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint marketDolaBal = DOLA.balanceOf(address(market));\n        uint govDolaBal = DOLA.balanceOf(gov);\n        uint repayAmount = market.debts(user) * market.liquidationFactorBps() / 10_000;\n\n        if (market.debts(user) <= market.getCreditLimit(user)) {\n            vm.expectRevert(\"User debt is healthy\");\n            market.liquidate(user, liqAmount);\n        } else if (repayAmount < liqAmount) {\n            vm.expectRevert(\"Exceeded liquidation factor\");\n            market.liquidate(user, liqAmount);\n        } else {\n            //Successful liquidation\n            market.liquidate(user, liqAmount);\n\n            uint expectedReward = convertDolaToWeth(liqAmount);\n            expectedReward += expectedReward * market.liquidationIncentiveBps() / 10_000;\n            assertEq(expectedReward, WETH.balanceOf(user2), \"user2 didn't receive proper liquidation reward\");\n            assertEq(DOLA.balanceOf(address(market)), marketDolaBal + liqAmount, \"market didn't receive repaid DOLA\");\n            assertEq(DOLA.balanceOf(gov), govDolaBal, \"gov should not receive liquidation fee when it's set to 0\");\n        }\n    }\n\n    function testLiquidate_WithLiquidationFee(uint depositAmount, uint liqAmount, uint256 liquidationFeeBps, uint16 borrowMulti_) public {\n        depositAmount = bound(depositAmount, 1e18, 100_000e18);\n        liqAmount = bound(liqAmount, 500e18, 200_000_000e18);\n        uint borrowMulti = bound(borrowMulti_, 0, 100);\n\n        gibWeth(user, depositAmount);\n        gibDBR(user, depositAmount);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), convertWethToDola(depositAmount));\n        vm.stopPrank();\n\n        vm.startPrank(gov);\n        liquidationFeeBps = bound(liquidationFeeBps, 1, 10_000);\n        vm.assume(liquidationFeeBps > 0 && liquidationFeeBps + market.liquidationIncentiveBps() < 10000);\n        market.setLiquidationFeeBps(liquidationFeeBps);\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        deposit(depositAmount);\n        uint maxBorrowAmount = convertWethToDola(depositAmount) * market.collateralFactorBps() / 10_000;\n        uint borrowAmount = maxBorrowAmount * borrowMulti / 100;\n        market.borrow(borrowAmount);\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, liqAmount);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint marketDolaBal = DOLA.balanceOf(address(market));\n        uint govWethBal = WETH.balanceOf(gov);\n        uint repayAmount = market.debts(user) * market.liquidationFactorBps() / 10_000;\n\n        if (market.debts(user) <= market.getCreditLimit(user)) {\n            vm.expectRevert(\"User debt is healthy\");\n            market.liquidate(user, liqAmount);\n        } else if (repayAmount < liqAmount) {\n            vm.expectRevert(\"Exceeded liquidation factor\");\n            market.liquidate(user, liqAmount);\n        } else {\n            //Successful liquidation\n            market.liquidate(user, liqAmount);\n\n            uint expectedReward = convertDolaToWeth(liqAmount);\n            expectedReward += expectedReward * market.liquidationIncentiveBps() / 10_000;\n            uint expectedLiquidationFee = convertDolaToWeth(liqAmount) * market.liquidationFeeBps() / 10_000;\n            assertEq(expectedReward, WETH.balanceOf(user2), \"user2 didn't receive proper liquidation reward\");\n            assertEq(DOLA.balanceOf(address(market)), marketDolaBal + liqAmount, \"market didn't receive repaid DOLA\");\n            assertEq(WETH.balanceOf(gov), govWethBal + expectedLiquidationFee, \"gov didn't receive proper liquidation fee\");\n        }\n    }\n\n    function testLiquidate_Fails_When_repaidDebtIs0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n        vm.expectRevert(\"Must repay positive debt\");\n        market.liquidate(user, 0);\n    }\n\n    function testLiquidate_Fails_When_repaidDebtGtLiquidatableDebt() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint liquidationAmount = (market.debts(user) * market.liquidationFactorBps() / 10_000) + 1;\n        vm.expectRevert(\"Exceeded liquidation factor\");\n        market.liquidate(user, liquidationAmount);\n    }\n\n    function testLiquidate_Fails_When_UserDebtIsHealthy() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint liquidationAmount = market.debts(user);\n        vm.expectRevert(\"User debt is healthy\");\n        market.liquidate(user, liquidationAmount);\n    }\n\n    function testRepay_Successful_OwnBorrow_FullAmount() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        \n        uint initialMarketBal = DOLA.balanceOf(address(market));\n        uint initialUserDebt = market.debts(user);\n        uint initialDolaBal = DOLA.balanceOf(user);\n\n        market.repay(user, market.debts(user));\n\n        assertEq(market.debts(user), 0, \"user's debt was not paid\");\n        assertEq(initialDolaBal - initialUserDebt, DOLA.balanceOf(user), \"DOLA was not subtracted from user\");\n        assertEq(initialMarketBal + initialUserDebt, DOLA.balanceOf(address(market)), \"Market DOLA balance did not increase\");\n    }\n\n    function testRepay_Successful_OtherUserBorrow_FullAmount() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n        vm.startPrank(user2);\n\n        uint initialUserDebt = market.debts(user);\n        uint initialDolaBal = initialUserDebt * 2;\n        gibDOLA(user2, initialDolaBal);\n\n        market.repay(user, market.debts(user));\n\n        assertEq(market.debts(user), 0, \"user's debt was not paid\");\n        assertEq(initialDolaBal - initialUserDebt, DOLA.balanceOf(user2), \"DOLA was not subtracted from user2\");\n    }\n\n    function testRepay_Fails_WhenAmountGtDebt() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        gibDOLA(user, 500e18);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.expectRevert(\"Insufficient debt\");\n        market.repay(user, borrowAmount + 1);\n    }\n\n    function testForceReplenish() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n        uint initialReplenisherDola = DOLA.balanceOf(replenisher);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint initialUserDebt = market.debts(user);\n        uint initialMarketDola = DOLA.balanceOf(address(market));\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + 5 days);\n        uint deficitBefore = dbr.deficitOf(user);\n        vm.startPrank(replenisher);\n\n        market.forceReplenish(user, deficitBefore);\n        assertGt(DOLA.balanceOf(replenisher), initialReplenisherDola, \"DOLA balance of replenisher did not increase\");\n        assertLt(DOLA.balanceOf(address(market)), initialMarketDola, \"DOLA balance of market did not decrease\");\n        assertEq(DOLA.balanceOf(replenisher) - initialReplenisherDola, initialMarketDola - DOLA.balanceOf(address(market)), \"DOLA balance of market did not decrease by amount paid to replenisher\");\n        assertEq(dbr.deficitOf(user), 0, \"Deficit of borrower was not fully replenished\");\n        assertEq(market.debts(user) - initialUserDebt, deficitBefore * replenishmentPriceBps / 10000, \"Debt of borrower did not increase by replenishment price\");\n    }\n\n    function testForceReplenish_Fails_When_UserHasNoDbrDeficit() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount * 100);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint deficit = dbr.deficitOf(user);\n\n        vm.stopPrank();\n        vm.startPrank(user2);\n\n        vm.expectRevert(\"No DBR deficit\");\n        market.forceReplenish(user, deficit);\n    }\n\n    function testForceReplenish_Fails_When_NotEnoughDolaInMarket() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.warp(block.timestamp + 5 days);\n        vm.stopPrank();\n        vm.startPrank(market.lender());\n        market.recall(DOLA.balanceOf(address(market)));\n        uint deficit = dbr.deficitOf(user);\n        vm.stopPrank();\n        vm.startPrank(replenisher);   \n        vm.expectRevert(\"SafeMath: subtraction underflow\");\n        market.forceReplenish(user, deficit);   \n    }\n\n    function testForceReplenish_Fails_When_DebtWouldExceedCollateralValue() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.warp(block.timestamp + 10000 days);\n        uint deficit = dbr.deficitOf(user);\n        vm.stopPrank();\n\n        vm.startPrank(replenisher);   \n        vm.expectRevert(\"Exceeded collateral value\");\n        market.forceReplenish(user, deficit);   \n    }\n\n    function testGetWithdrawalLimit_Returns_CollateralBalance() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n        assertEq(market.getWithdrawalLimit(user), collateralBalance, \"Should return collateralBalance when user's escrow balance > 0 & debts = 0\");\n    }\n\n    function testGetWithdrawalLimit_Returns_CollateralBalanceAdjustedForDebts() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint collateralBalance = market.escrows(user).balance();\n        uint collateralFactor = market.collateralFactorBps();\n        uint minimumCollateral = borrowAmount * 1 ether / oracle.viewPrice(address(WETH), collateralFactor) * 10000 / collateralFactor;\n        assertEq(market.getWithdrawalLimit(user), collateralBalance - minimumCollateral, \"Should return collateral balance adjusted for debt\");\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenEscrowBalanceIs0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n\n        market.withdraw(wethTestAmount);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user's escrow balance is 0\");\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenCollateralValueLtDebts() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n        market.withdraw(wethTestAmount);\n\n        uint ethPrice = ethFeed.latestAnswer();\n        ethFeed.changeAnswer(ethPrice * 6 / 10);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user's collateral value is less than debts\");\n        ethFeed.changeAnswer(ethPrice);\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenMarketCollateralFactoris0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(1);\n        vm.stopPrank();\n\n        vm.startPrank(gov);\n        market.setCollateralFactorBps(0);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user has non-zero debt & collateralFactorBps = 0\");\n    }\n\n    function testGetLiquidatableDebt_Returns_0_WhenUserHasNoDebt() public {\n        assertEq(market.getLiquidatableDebt(user), 0, \"Should return 0 when user has no debt\");\n    }\n\n    function testGetLiquidatableDebt_Returns_0_WhenUserCreditEqualsDebt() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        assertEq(market.getLiquidatableDebt(user), 0, \"Should return 0 when user credit = debt\");\n    }\n\n    function testGetLiquidatableDebt_Returns_LiquidatableDebt_WhenUserDebtGtCredit() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 5 / 10);\n\n        assertGt(market.getLiquidatableDebt(user), 0, \"Should return liquidatable debt when user debt > credit\");\n    }\n\n    function testPauseBorrows() public {\n        vm.startPrank(gov);\n\n        market.pauseBorrows(true);\n        assertEq(market.borrowPaused(), true, \"Market wasn't paused\");\n        market.pauseBorrows(false);\n        assertEq(market.borrowPaused(), false, \"Market wasn't unpaused\");\n\n        vm.stopPrank();\n        vm.startPrank(pauseGuardian);\n        market.pauseBorrows(true);\n        assertEq(market.borrowPaused(), true, \"Market wasn't paused\");\n        vm.expectRevert(onlyGovUnpause);\n        market.pauseBorrows(false);\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        vm.expectRevert(onlyPauseGuardianOrGov);\n        market.pauseBorrows(true);\n\n        vm.expectRevert(onlyGovUnpause);\n        market.pauseBorrows(false);\n    }\n\n    function testWithdraw() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"failed to deposit WETH\");\n\n        market.withdraw(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), 0, \"failed to withdraw WETH\");\n        assertEq(WETH.balanceOf(user), wethTestAmount, \"failed to withdraw WETH\");\n    }\n\n    function testWithdraw_Fail_When_WithdrawingCollateralBelowCF() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"failed to deposit WETH\");\n\n        market.borrow(1 ether);\n\n        vm.expectRevert(\"Insufficient withdrawal limit\");\n        market.withdraw(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"successfully withdrew WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"successfully withdrew WETH\");\n    }\n\n    function testWithdrawOnBehalf() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        vm.stopPrank();\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(userPk), 0, \"failed to deposit WETH\");\n\n        vm.startPrank(user2);\n        market.withdrawOnBehalf(userPk, wethTestAmount, block.timestamp, v, r, s);\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), 0, \"failed to withdraw WETH\");\n        assertEq(WETH.balanceOf(user2), wethTestAmount, \"failed to withdraw WETH\");\n    }\n\n    function testWithdrawOnBehalf_When_InvalidateNonceCalledPrior() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.expectRevert(\"INVALID_SIGNER\");\n        market.withdrawOnBehalf(userPk, wethTestAmount, block.timestamp, v, r, s);\n    }\n\n    function testWithdrawOnBehalf_When_DeadlineHasPassed() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n\n        uint timestamp = block.timestamp;\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.warp(block.timestamp + 1);\n        vm.expectRevert(\"DEADLINE_EXPIRED\");\n        market.withdrawOnBehalf(userPk, wethTestAmount, timestamp, v, r, s);\n    }\n\n    //Access Control Tests\n\n    function test_accessControl_setOracle() public {\n        vm.startPrank(gov);\n        market.setOracle(IOracle(address(0)));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setOracle(IOracle(address(0)));\n    }\n\n    function test_accessControl_setBorrowController() public {\n        vm.startPrank(gov);\n        market.setBorrowController(IBorrowController(address(0)));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setBorrowController(IBorrowController(address(0)));\n    }\n\n    function test_accessControl_setGov() public {\n        vm.startPrank(gov);\n        market.setGov(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setGov(address(0));\n    }\n\n    function test_accessControl_setLender() public {\n        vm.startPrank(gov);\n        market.setLender(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLender(address(0));\n    }\n\n    function test_accessControl_setPauseGuardian() public {\n        vm.startPrank(gov);\n        market.setPauseGuardian(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setPauseGuardian(address(0));\n    }\n\n    function test_accessControl_setCollateralFactorBps() public {\n        vm.startPrank(gov);\n        market.setCollateralFactorBps(100);\n\n        vm.expectRevert(\"Invalid collateral factor\");\n        market.setCollateralFactorBps(10001);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setCollateralFactorBps(100);\n    }\n\n    function test_accessControl_setReplenismentIncentiveBps() public {\n        vm.startPrank(gov);\n        market.setReplenismentIncentiveBps(100);\n\n        vm.expectRevert(\"Invalid replenishment incentive\");\n        market.setReplenismentIncentiveBps(10001);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setReplenismentIncentiveBps(100);\n    }\n\n    function test_accessControl_setLiquidationIncentiveBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationIncentiveBps(100);\n\n        vm.expectRevert(\"Invalid liquidation incentive\");\n        market.setLiquidationIncentiveBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationIncentiveBps(100);\n    }\n\n    function test_accessControl_setLiquidationFactorBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationFactorBps(100);\n\n        vm.expectRevert(\"Invalid liquidation factor\");\n        market.setLiquidationFactorBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationFactorBps(100);\n    }\n\n    function test_accessControl_setLiquidationFeeBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationFeeBps(100);\n\n        vm.expectRevert(\"Invalid liquidation fee\");\n        market.setLiquidationFeeBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationFeeBps(100);\n    }\n\n    function test_accessControl_recall() public {\n        vm.startPrank(address(fed));\n        market.recall(100e18);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyLender);\n        market.recall(100e18);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n",
        "CodeNames": [
            "Market.t.sol",
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "withdrawInternal function in Market.sol",
                "Type": "Reentrancy",
                "Description": "ERC777 reentrancy when withdrawing can be used to withdraw all collateral",
                "Repair": "Mark the affected functions as nonReentrant"
            },
            {
                "Location": "Market.liquidate() function",
                "Type": "Oracle attack",
                "Description": "The usage of the 2 day low exchange rate in the liquidation process makes the system highly vulnerable to an oracle attack, where an attacker can manipulate the price feed for a short period of time and liquidate any escrow, leading to more collateral released than expected.",
                "Repair": "Instead of using the 2 day lowest price during the liquidation, the team could either take the current oracle price, while still using the 2 day period for any direct agent interaction to minimise attacks both from users side and liquidators side"
            },
            {
                "Location": "transfer and transferFrom functions in Market.sol",
                "Type": "Unhandled return values",
                "Description": "Some implementations of transfer and transferFrom could return \u2018false\u2019 on failure instead of reverting.",
                "Repair": "Wrap transfer and transferFrom calls into require() statements to check for failures or use OpenZeppelin\u2019s SafeERC20 wrapper functions"
            },
            {
                "Location": "repay and withdraw functions in Market.sol",
                "Type": "Insufficient debt repayment",
                "Description": "When the forceReplenish function is not called while it could be called, the Market contract would receive less DOLA if the user decides to repay the debt and withdraw the collateral both in full.",
                "Repair": "Adjust the amount input of the repay function to account for the user's DBR deficit or ensure that the forceReplenish function is always called when necessary"
            },
            {
                "Location": "Market.getWithdrawalLimitInternal()",
                "Type": "Unexpected Locking",
                "Description": "The function Market.getWithdrawalLimitInternal() contains a check that would cause the user to not be able to withdraw any tokens, so long as they had any non-0 amount of debt and the collateralFactorBps was 0. This could be caused if governance sets the collateralFactorBps to 0, which could disproportionately affect users whose debt values were low compared to their deposited collateral. The contract only overtly contains locking for new borrowing, so this implicit lock on withdraws seems like an unnecessary risk.",
                "Repair": "Consider a minimum for the collateralFactorBps value, to go along with the maximum value check already present in the setter function. Alternatively, an explicit withdrawal lock could be implemented, making the semantic clear. This function could have modified access controls to enable faster reactions vs governance alone. An 'escape hatch' function could be enacted by users when a 'defaulted' state is set on the Market."
            },
            {
                "Location": "Market.sol",
                "Type": "Escrow balance manipulation",
                "Description": "User can free from liquidation fee if its escrow balance is less than the calculated liquidation fee.",
                "Repair": "Allow replenishing to push the debt under the water and disallow repaying the debt with an outstanding DBR deficit"
            },
            {
                "Location": "Market.sol",
                "Type": "Indefinite borrowing",
                "Description": "User can borrow DOLA indefinitely without settling DBR deficit by keeping their debt close to the allowed maximum.",
                "Repair": "Disallow repaying the debt with an outstanding DBR deficit"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}\n\n\n",
        "CodeNames": [
            "Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Oracle.sol#L124",
                "Type": "Oracle manipulation",
                "Description": "The two-day feature of the oracle can be gamed where you only have to manipulate the oracle for ~2 blocks.",
                "Repair": "Increase the interval to at least three days"
            },
            {
                "Location": "Oracle.sol#L87, Oracle.sol#L121",
                "Type": "Assuming limited decimals",
                "Description": "The Oracle contract normalizes prices in both viewPrices and getPrices functions to adjust for potential decimal differences between feed and token decimals and the expected return value. However, these functions assume that feedDecimals and tokenDecimals won't exceed 18.",
                "Repair": "Divide the price by 10^decimals if feedDecimals + tokenDecimals > 36"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"./FiRMTest.sol\";\nimport \"../Oracle.sol\";\n\nimport {EthFeed} from \"./mocks/EthFeed.sol\";\nimport \"./mocks/WETH9.sol\";\n\ncontract OracleTest is FiRMTest {\n    address operator;\n    \n    bytes onlyPendingOperator = \"ONLY PENDING OPERATOR\";\n\n    function setUp() public {\n        vm.label(gov, \"operator\");\n        operator = gov;\n\n        initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);\n    }\n\n    function test_getPrice_recordsDailyLow() public {\n        uint day = block.timestamp / 1 days;\n        uint collateralFactor = market.collateralFactorBps();\n        uint feedPrice = ethFeed.latestAnswer();\n        uint oraclePrice = oracle.getPrice(address(WETH), collateralFactor);\n\n        assertEq(oraclePrice, feedPrice);\n        assertEq(oracle.dailyLows(address(WETH), day), feedPrice, \"Oracle didn't record daily low on call to getPrice\");\n\n        uint newPrice = 1200e18;\n        ethFeed.changeAnswer(newPrice);\n        oraclePrice = oracle.getPrice(address(WETH), collateralFactor);\n\n        assertEq(oraclePrice, newPrice, \"Oracle didn't update when feed did\");\n        assertEq(oracle.dailyLows(address(WETH), day), newPrice, \"Oracle didn't record daily low on call to getPrice\");\n    }\n\n    function test_viewPrice_returnsDampenedPrice() public {\n        uint collateralFactor = market.collateralFactorBps();\n        uint day = block.timestamp / 1 days;\n        uint feedPrice = ethFeed.latestAnswer();\n\n        //1600e18 price saved as daily low\n        oracle.getPrice(address(WETH), collateralFactor);\n        assertEq(oracle.dailyLows(address(WETH), day), feedPrice, \"Oracle didn't record daily low on call to getPrice\");\n\n        vm.warp(block.timestamp + 1 days);\n        uint newPrice = 1200e18;\n        ethFeed.changeAnswer(newPrice);\n        //1200e18 price saved as daily low\n        oracle.getPrice(address(WETH), collateralFactor);\n        assertEq(oracle.dailyLows(address(WETH), ++day), newPrice, \"Oracle didn't record daily low on call to getPrice\");\n\n        vm.warp(block.timestamp + 1 days);\n        newPrice = 3000e18;\n        ethFeed.changeAnswer(newPrice);\n\n        //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.\n        uint price = oracle.getPrice(address(WETH), collateralFactor);\n        uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);\n        assertEq(oracle.dailyLows(address(WETH), ++day), newPrice, \"Oracle didn't record daily low on call to getPrice\");\n\n        assertEq(price, 1200e18 * 10_000 / collateralFactor, \"Oracle did not dampen price correctly\");\n        assertEq(viewPrice, 1200e18 * 10_000 / collateralFactor, \"Oracle did not dampen view price correctly\");\n    }\n\n    function test_viewPrice_reverts_whenNoPriceSet() public {\n        uint collateralFactor = market.collateralFactorBps();\n\n        vm.expectRevert(\"Price not found\");\n        oracle.viewPrice(address(0), collateralFactor);\n    }\n\n    function test_getPrice_reverts_whenNoPriceSet() public {\n        uint collateralFactor = market.collateralFactorBps();\n\n        vm.expectRevert(\"Price not found\");\n        oracle.getPrice(address(0), collateralFactor);\n    }\n\n    function test_viewPrice_returnsFixedPrice_whenFixedPriceAndOracleSet() public {\n        uint collateralFactor = market.collateralFactorBps();\n\n        //WETH feed is already set in FiRMTest.sol's `initialize()`\n        assertEq(oracle.viewPrice(address(WETH), collateralFactor), ethFeed.latestAnswer(), \"WETH feed not set\");\n\n        vm.startPrank(operator);\n        oracle.setFixedPrice(address(WETH), 1_000e18);\n        assertEq(oracle.viewPrice(address(WETH), collateralFactor), 1_000e18, \"Fixed price should overwrite feed\");\n    }\n\n    function test_getPrice_returnsFixedPrice_whenFixedPriceAndOracleSet() public {\n        uint collateralFactor = market.collateralFactorBps();\n\n        //WETH feed is already set in FiRMTest.sol's `initialize()`\n        assertEq(oracle.getPrice(address(WETH), collateralFactor), ethFeed.latestAnswer(), \"WETH feed not set\");\n\n        vm.startPrank(operator);\n        oracle.setFixedPrice(address(WETH), 1_000e18);\n        assertEq(oracle.getPrice(address(WETH), collateralFactor), 1_000e18, \"Fixed price should overwrite feed\");\n    }\n\n    function test_viewPrice_reverts_whenFeedPriceReturns0() public {\n        ethFeed.changeAnswer(0);\n        uint collateralFactor = market.collateralFactorBps();\n\n        vm.expectRevert(\"Invalid feed price\");\n\n        oracle.viewPrice(address(WETH), collateralFactor);\n    }\n\n    function test_getPrice_reverts_whenFeedPriceReturns0() public {\n        ethFeed.changeAnswer(0);\n        uint collateralFactor = market.collateralFactorBps();\n\n        vm.expectRevert(\"Invalid feed price\");\n\n        oracle.getPrice(address(WETH), collateralFactor);\n    }\n    \n    //Access Control\n\n    function test_accessControl_setPendingOperator() public {\n        vm.startPrank(operator);\n        oracle.setPendingOperator(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyOperator);\n        oracle.setPendingOperator(address(0));\n    }\n\n    function test_accessControl_claimOperator() public {\n        vm.startPrank(operator);\n        oracle.setPendingOperator(user);\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.expectRevert(onlyPendingOperator);\n        oracle.claimOperator();\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        oracle.claimOperator();\n        assertEq(oracle.operator(), user, \"Call to claimOperator failed\");\n    }\n\n    function test_accessControl_setFeed() public {\n        vm.startPrank(operator);\n        oracle.setFeed(address(WETH), IChainlinkFeed(address(ethFeed)), 18);\n        uint collateralFactor = market.collateralFactorBps();\n        assertEq(oracle.viewPrice(address(WETH), collateralFactor), ethFeed.latestAnswer(), \"Feed failed to set\");\n        vm.stopPrank();\n\n        vm.expectRevert(onlyOperator);\n        oracle.setFeed(address(WETH), IChainlinkFeed(address(ethFeed)), 18);\n    }\n\n    function test_accessControl_setFixedPrice() public {\n        vm.startPrank(operator);\n        uint collateralFactor = market.collateralFactorBps();\n        oracle.setFixedPrice(address(WETH), 1200e18);\n        assertEq(oracle.viewPrice(address(WETH), collateralFactor), 1200e18, \"Fixed price failed to set\");\n        vm.stopPrank();\n\n        vm.expectRevert(onlyOperator);\n        oracle.setFixedPrice(address(WETH), 1200e18);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}\n\n\n",
        "CodeNames": [
            "Oracle.t.sol",
            "Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Oracle.sol",
                "Type": "Stale Price",
                "Description": "The Chainlink oracle data feed is not sufficiently validated and can return a stale price, which can cause inaccurate calculations for credit and withdrawal limits and result in unexpected liquidation of a user's debt.",
                "Repair": "Update the code to use latestRoundData function and validate the roundId and updatedAt values to ensure the returned price is not stale."
            }
        ]
    }
]