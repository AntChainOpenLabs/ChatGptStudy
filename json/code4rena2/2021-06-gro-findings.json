[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "switchEoaOnly() function",
                "Type": "optional flash loan risk mitigation",
                "Description": "The current mitigation is to optionally prevent contracts, except whitelisted partner ones, from interacting with the protocol to prevent any flash loan manipulations. A more robust approach would be to add logic preventing multiple txs to the protocol from the same address/tx.origin within the same block when smart contracts are allowed.",
                "Repair": "Add logic preventing multiple txs to the protocol from the same address/tx.origin within the same block when smart contracts are allowed"
            },
            {
                "Location": "addSafeAddress() function",
                "Type": "safe address cannot be removed",
                "Description": "If there is a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern.",
                "Repair": "Change addSafeAddress() to isSafeAddress() with an additional bool parameter to allow both the enabling AND disabling of safe addresses"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {FixedStablecoins} from \"contracts/common/FixedContracts.sol\";\nimport {ICurve3Pool} from \"contracts/interfaces/ICurve.sol\";\n\nimport \"contracts/common/Controllable.sol\";\n\nimport \"contracts/interfaces/IBuoy.sol\";\nimport \"contracts/interfaces/IChainPrice.sol\";\nimport \"contracts/interfaces/IChainlinkAggregator.sol\";\nimport \"contracts/interfaces/IERC20Detailed.sol\";\n\n/// @notice Contract for calculating prices of underlying assets and LP tokens in Curve pool. Also\n///     used to sanity check pool against external oracle, to ensure that pools underlying coin ratios\n///     are within a specific range (measued in BP) of the external oracles coin price ratios.\n///     Sanity check:\n///         The Buoy checks previously recorded (cached) curve coin dy, which it compares against current curve dy,\n///         blocking any interaction that is outside a certain tolerance (BASIS_POINTS). When updting the cached\n///         value, the buoy uses chainlink to ensure that curves prices arent off peg.\ncontract Buoy3Pool is FixedStablecoins, Controllable, IBuoy, IChainPrice {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 TIME_LIMIT = 3000;\n    uint256 public BASIS_POINTS = 20;\n    uint256 constant CHAIN_FACTOR = 100;\n\n    ICurve3Pool public immutable override curvePool;\n    IERC20 public immutable lpToken;\n\n    mapping(uint256 => uint256) lastRatio;\n\n    // Chianlink price feed\n    address public immutable daiUsdAgg;\n    address public immutable usdcUsdAgg;\n    address public immutable usdtUsdAgg;\n\n    mapping(address => mapping(address => uint256)) public tokenRatios;\n\n    event LogNewBasisPointLimit(uint256 oldLimit, uint256 newLimit);\n\n    constructor(\n        address _crv3pool,\n        address poolToken,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals,\n        address[N_COINS] memory aggregators\n    ) public FixedStablecoins(_tokens, _decimals) {\n        curvePool = ICurve3Pool(_crv3pool);\n        lpToken = IERC20(poolToken);\n        daiUsdAgg = aggregators[0];\n        usdcUsdAgg = aggregators[1];\n        usdtUsdAgg = aggregators[2];\n    }\n\n    /// @notice Set limit for how much Curve pool and external oracle is allowed\n    ///     to deviate before failing transactions\n    /// @param newLimit New limit in BP\n    function setBasisPointsLmit(uint256 newLimit) external onlyOwner {\n        uint256 oldLimit = BASIS_POINTS;\n        BASIS_POINTS = newLimit;\n        emit LogNewBasisPointLimit(oldLimit, newLimit);\n    }\n\n    /// @notice Check the health of the Curve pool:\n    ///     Ratios are checked by the following heuristic:\n    ///     Orcale A - Curve\n    ///     Oracle B - External oracle\n    ///     Both oracles establish ratios for a set of stable coins\n    ///         (a, b, c)\n    ///     and product the following set of ratios:\n    ///         (a/a, a/b, a/c), (b/b, b/a, b/c), (c/c, c/a, c/b)\n    ///     It's simply to reduce the number of comparisons to be made\n    ///     in order to have complete coverage of the system ratios:\n    ///         1) ratios between a stable coin and itself can be discarded\n    ///         2) inverted ratios, a/b bs b/a, while producing different results\n    ///             should both reflect the same change in any one of the two\n    ///             underlying assets, but in opposite directions\n    ///     This mean that the following set should provide the necessary coverage checks\n    ///     to establish that the coins pricing is healthy:\n    ///         (a/b, a/c)\n    function safetyCheck() external view override returns (bool) {\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            _ratio = abs(int256(_ratio - lastRatio[i]));\n            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Updated cached curve value with a custom tolerance towards chainlink\n    /// @param tolerance How much difference between curve and chainlink can be tolerated\n    function updateRatiosWithTolerance(uint256 tolerance) external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatiosWithTolerance: !authorized\");\n        return _updateRatios(tolerance);\n    }\n\n    /// @notice Updated cached curve values\n    function updateRatios() external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatios: !authorized\");\n        return _updateRatios(BASIS_POINTS);\n    }\n\n    /// @notice Get USD value for a specific input amount of tokens, slippage included\n    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToUsd(inAmounts, deposit);\n    }\n\n    /// @notice Get estimate USD price of a stablecoin amount\n    /// @param inAmount Token amount\n    /// @param i Index of token\n    function singleStableToUsd(uint256 inAmount, uint256 i) external view override returns (uint256) {\n        uint256[N_COINS] memory inAmounts;\n        inAmounts[i] = inAmount;\n        return _stableToUsd(inAmounts, true);\n    }\n\n    /// @notice Get LP token value of input amount of tokens\n    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToLp(tokenAmounts, deposit);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromUsd(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(_usdToLp(inAmount), i);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromLp(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(inAmount, i);\n    }\n\n    /// @notice Get USD price of LP tokens you receive for a specific input amount of tokens, slippage included\n    function lpToUsd(uint256 inAmount) external view override returns (uint256) {\n        return _lpToUsd(inAmount);\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function usdToLp(uint256 inAmount) external view override returns (uint256) {\n        return _usdToLp(inAmount);\n    }\n\n    /// @notice Split LP token amount to balance of pool tokens\n    /// @param inAmount Amount of LP tokens\n    /// @param totalBalance Total balance of pool\n    function poolBalances(uint256 inAmount, uint256 totalBalance)\n        internal\n        view\n        returns (uint256[N_COINS] memory balances)\n    {\n        uint256[N_COINS] memory _balances;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _balances[i] = (IERC20(getToken(i)).balanceOf(address(curvePool)).mul(inAmount)).div(totalBalance);\n        }\n        balances = _balances;\n    }\n\n    function getVirtualPrice() external view override returns (uint256) {\n        return curvePool.get_virtual_price();\n    }\n\n    // Internal functions\n    function _lpToUsd(uint256 inAmount) internal view returns (uint256) {\n        return inAmount.mul(curvePool.get_virtual_price()).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {\n        require(tokenAmounts.length == N_COINS, \"deposit: !length\");\n        uint256[N_COINS] memory _tokenAmounts;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _tokenAmounts[i] = tokenAmounts[i];\n        }\n        uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);\n        return _lpToUsd(lpAmount);\n    }\n\n    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {\n        require(tokenAmounts.length == N_COINS, \"deposit: !length\");\n        uint256[N_COINS] memory _tokenAmounts;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _tokenAmounts[i] = tokenAmounts[i];\n        }\n        return curvePool.calc_token_amount(_tokenAmounts, deposit);\n    }\n\n    function _singleStableFromLp(uint256 inAmount, int128 i) internal view returns (uint256) {\n        uint256 result = curvePool.calc_withdraw_one_coin(inAmount, i);\n        return result;\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function _usdToLp(uint256 inAmount) internal view returns (uint256) {\n        return inAmount.mul(DEFAULT_DECIMALS_FACTOR).div(curvePool.get_virtual_price());\n    }\n\n    /// @notice Calculate price ratios for stablecoins\n    ///     Get USD price data for stablecoin\n    /// @param i Stablecoin to get USD price for\n    function getPriceFeed(uint256 i) external view override returns (uint256 _price) {\n        _price = uint256(IChainlinkAggregator(getAggregator(i)).latestAnswer());\n    }\n\n    /// @notice Fetch chainlink token ratios\n    /// @param i Token in\n    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) {\n        uint256[3] memory _prices;\n        _prices[0] = uint256(IChainlinkAggregator(getAggregator(0)).latestAnswer());\n        _prices[1] = uint256(IChainlinkAggregator(getAggregator(1)).latestAnswer());\n        _prices[2] = uint256(IChainlinkAggregator(getAggregator(2)).latestAnswer());\n        for (uint256 j = 0; j < 3; j++) {\n            if (i == j) {\n                _ratios[i] = CHAINLINK_PRICE_DECIMAL_FACTOR;\n            } else {\n                _ratios[j] = _prices[i].mul(CHAINLINK_PRICE_DECIMAL_FACTOR).div(_prices[j]);\n            }\n        }\n        return _ratios;\n    }\n\n    function getAggregator(uint256 index) private view returns (address) {\n        if (index == 0) {\n            return daiUsdAgg;\n        } else if (index == 1) {\n            return usdcUsdAgg;\n        } else {\n            return usdtUsdAgg;\n        }\n    }\n\n    /// @notice Get absolute value\n    function abs(int256 x) private pure returns (uint256) {\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n\n    function _updateRatios(uint256 tolerance) private returns (bool) {\n        uint256[N_COINS] memory chainRatios = getTokenRatios(0);\n        uint256[N_COINS] memory newRatios;\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            uint256 check = abs(int256(_ratio) - int256(chainRatios[i].div(CHAIN_FACTOR)));\n            if (check.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > tolerance) {\n                return false;\n            } else {\n                newRatios[i] = _ratio;\n            }\n        }\n        for (uint256 i = 1; i < N_COINS; i++) {\n            lastRatio[i] = newRatios[i];\n        }\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../common/StructDefinitions.sol\";\nimport \"../common/Constants.sol\";\nimport \"../common/Controllable.sol\";\nimport \"../common/Whitelist.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../interfaces/ILifeGuard.sol\";\nimport \"../interfaces/IExposure.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IBuoy.sol\";\n\n/// @notice Contract for calculating current protocol exposures on a stablecoin and\n///     protocol level. This contract can be upgraded if the systems underlying protocols\n///     or tokens have changed. Protocol exposure are calculated at a high level, as any\n///     additional exposures from underlying protocol exposures should at most be equal to\n///     the high level exposure.\n///     For example: harvest finance stablecoin vaults (fTokens)\n///         - High level exposure\n///             - Harvest finance\n///         - Low level exposures (from fToken investments):\n///             - Compound\n///             - Idle finance\n///     Neither of these two low level exposures should matter as long as there arent\n///     additional exposure to these protocol elsewhere. So by desing, the protocols\n///     are given indexes based on the strategies in the stablecoin vaults, which need\n///     to be symetrical for this to work - e.g. all vaults needs to have the same exposure\n///     profile, and non of these exposure profiles can overlap. In the case where the\n///     additional exposure needs to be taken into account (maker has USDC collateral,\n///     Curve adds exposure to all stablecoins in a liquidity pool), they will be calculated\n///     and added ontop of the base exposure from vaults and strategies.\n///\n///     --------------------------------------------------------\n///     Current protocol setup:\n///     --------------------------------------------------------\n///     Stablecoins: DAI, USDC, USDT\n///     LP tokens: 3Crv\n///     Vaults: DAIVault, USDCVault, USDTVault, 3Crv vault\n///     Strategy (exposures):\n///         - Compound\n///         - Idle finance\n///         - Yearn Generic Lender:\n///             - Cream\n///         - CurveXpool:\n///             - Curve3Pool\n///             - CurveMetaPool\n///             - Yearn\ncontract Exposure is Constants, Controllable, Whitelist, IExposure {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public protocolCount;\n    uint256 public makerUSDCExposure;\n\n    event LogNewProtocolCount(uint256 count);\n    event LogNewMakerExposure(uint256 exposure);\n\n    /// @notice Add protocol for the exposure calculations\n    /// @dev Currently set to:\n    ///     1 - Harvest finance\n    ///     2 - Cream\n    ///     Curve exposure is calculated separately as it has wider system impact\n    function setProtocolCount(uint256 _protocolCount) external onlyOwner {\n        protocolCount = _protocolCount;\n        emit LogNewProtocolCount(_protocolCount);\n    }\n\n    /// @notice Specify additional USDC exposure to Maker\n    /// @param _makerUSDCExposure Exposure amount to Maker\n    function setMakerUSDCExposure(uint256 _makerUSDCExposure) external onlyOwner {\n        makerUSDCExposure = _makerUSDCExposure;\n        emit LogNewMakerExposure(_makerUSDCExposure);\n    }\n\n    function getExactRiskExposure(SystemState calldata sysState)\n        external\n        view\n        override\n        returns (ExposureState memory expState)\n    {\n        expState = _calcRiskExposure(sysState, false);\n        ILifeGuard lifeguard = ILifeGuard(_controller().lifeGuard());\n        IBuoy buoy = IBuoy(_controller().buoy());\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 assets = lifeguard.assets(i);\n            uint256 assetsUsd = buoy.singleStableToUsd(assets, i);\n            expState.stablecoinExposure[i] = expState.stablecoinExposure[i].add(\n                assetsUsd.mul(PERCENTAGE_DECIMAL_FACTOR).div(sysState.totalCurrentAssetsUsd)\n            );\n        }\n    }\n\n    /// @notice Calculate stablecoin and protocol level risk exposure\n    /// @param sysState Struct holding info about systems current state\n    /// @dev This loops through all the vaults, checks the amount of assets in them\n    ///     and their underlying strategies to understand stablecoin exposure\n    ///     - Any assets invested in Curve or similar AMM will have additional stablecoin exposure.\n    ///     The protocol exposure is calculated by assessing the amount of assets each\n    ///     vault has invested in a strategy.\n    function calcRiskExposure(SystemState calldata sysState)\n        external\n        view\n        override\n        returns (ExposureState memory expState)\n    {\n        expState = _calcRiskExposure(sysState, true);\n\n        // Establish if any stablecoin/protocol is over exposed\n        (expState.stablecoinExposed, expState.protocolExposed) = isExposed(\n            sysState.rebalanceThreshold,\n            expState.stablecoinExposure,\n            expState.protocolExposure,\n            expState.curveExposure\n        );\n    }\n\n    /// @notice Do a rough USD dollar calculation by treating every stablecoin as\n    ///     worth 1 USD and set all Decimals to 18\n    function getUnifiedAssets(address[N_COINS] calldata vaults)\n        public\n        view\n        override\n        returns (uint256 unifiedTotalAssets, uint256[N_COINS] memory unifiedAssets)\n    {\n        // unify all assets to 18 decimals, treat each stablecoin as being worth 1 USD\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 assets = IVault(vaults[i]).totalAssets();\n            unifiedAssets[i] = assets.mul(DEFAULT_DECIMALS_FACTOR).div(\n                uint256(10)**IERC20Detailed(IVault(vaults[i]).token()).decimals()\n            );\n            unifiedTotalAssets = unifiedTotalAssets.add(unifiedAssets[i]);\n        }\n    }\n\n    /// @notice Rough delta calculation - assumes each stablecoin is priced at 1 USD,\n    ///     and looks at differences between current allocations and target allocations\n    /// @param targets Stable coin allocation targest\n    /// @param vaults Stablecoin vaults\n    /// @param withdrawUsd USD value of withdrawals\n    function calcRoughDelta(\n        uint256[N_COINS] calldata targets,\n        address[N_COINS] calldata vaults,\n        uint256 withdrawUsd\n    ) external view override returns (uint256[N_COINS] memory delta) {\n        (uint256 totalAssets, uint256[N_COINS] memory vaultTotalAssets) = getUnifiedAssets(vaults);\n\n        require(totalAssets > withdrawUsd, \"totalAssets < withdrawalUsd\");\n        totalAssets = totalAssets.sub(withdrawUsd);\n        uint256 totalDelta;\n        for (uint256 i; i < N_COINS; i++) {\n            uint256 target = totalAssets.mul(targets[i]).div(PERCENTAGE_DECIMAL_FACTOR);\n            if (vaultTotalAssets[i] > target) {\n                delta[i] = vaultTotalAssets[i].sub(target);\n                totalDelta = totalDelta.add(delta[i]);\n            }\n        }\n        uint256 percent = PERCENTAGE_DECIMAL_FACTOR;\n        for (uint256 i; i < N_COINS - 1; i++) {\n            if (delta[i] > 0) {\n                delta[i] = delta[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(totalDelta);\n                percent = percent.sub(delta[i]);\n            }\n        }\n        delta[N_COINS - 1] = percent;\n        return delta;\n    }\n\n    /// @notice Sort vaults by the delta of target asset - current asset,\n    ///     only support 3 vaults now\n    /// @param bigFirst Return array order most exposed -> least exposed\n    /// @param unifiedTotalAssets Estimated system USD assets\n    /// @param unifiedAssets Estimated vault USD assets\n    /// @param targetPercents Vault target percent array\n    function sortVaultsByDelta(\n        bool bigFirst,\n        uint256 unifiedTotalAssets,\n        uint256[N_COINS] calldata unifiedAssets,\n        uint256[N_COINS] calldata targetPercents\n    ) external pure override returns (uint256[N_COINS] memory vaultIndexes) {\n        uint256 maxIndex;\n        uint256 minIndex;\n        int256 maxDelta;\n        int256 minDelta;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            // Get difference between vault current assets and vault target\n            int256 delta = int256(\n                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)\n            );\n            // Establish order\n            if (delta > maxDelta) {\n                maxDelta = delta;\n                maxIndex = i;\n            } else if (delta < minDelta) {\n                minDelta = delta;\n                minIndex = i;\n            }\n        }\n        if (bigFirst) {\n            vaultIndexes[0] = maxIndex;\n            vaultIndexes[2] = minIndex;\n        } else {\n            vaultIndexes[0] = minIndex;\n            vaultIndexes[2] = maxIndex;\n        }\n        vaultIndexes[1] = N_COINS - maxIndex - minIndex;\n    }\n\n    /// @notice Calculate what percentage of system total assets the assets in a strategy make up\n    /// @param vault Address of target vault that holds the strategy\n    /// @param index Index of strategy\n    /// @param vaultAssetsPercent Percentage of system assets\n    /// @param vaultAssets Total assets in vaults\n    function calculatePercentOfSystem(\n        address vault,\n        uint256 index,\n        uint256 vaultAssetsPercent,\n        uint256 vaultAssets\n    ) private view returns (uint256 percentOfSystem) {\n        if (vaultAssets == 0) return 0;\n        uint256 strategyAssetsPercent = IVault(vault).getStrategyAssets(index).mul(PERCENTAGE_DECIMAL_FACTOR).div(\n            vaultAssets\n        );\n\n        percentOfSystem = vaultAssetsPercent.mul(strategyAssetsPercent).div(PERCENTAGE_DECIMAL_FACTOR);\n    }\n\n    /// @notice Calculate the net stablecoin exposure\n    /// @param directlyExposure Amount of stablecoin in vault+strategies\n    /// @param curveExposure Percent of assets in Curve\n    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure)\n        private\n        view\n        returns (uint256[N_COINS] memory stableCoinExposure)\n    {\n        uint256 maker = directlyExposure[0].mul(makerUSDCExposure).div(PERCENTAGE_DECIMAL_FACTOR);\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 indirectExposure = curveExposure;\n            if (i == 1) {\n                indirectExposure = indirectExposure.add(maker);\n            }\n            stableCoinExposure[i] = directlyExposure[i].add(indirectExposure);\n        }\n    }\n\n    /// @notice Determine if an assets or protocol is overexposed\n    /// @param rebalanceThreshold Threshold for triggering a rebalance due to overexposure\n    /// @param stableCoinExposure Current stable coin exposures\n    /// @param protocolExposure Current prtocol exposures\n    /// @param curveExposure Current Curve exposure\n    function isExposed(\n        uint256 rebalanceThreshold,\n        uint256[N_COINS] memory stableCoinExposure,\n        uint256[] memory protocolExposure,\n        uint256 curveExposure\n    ) private pure returns (bool stablecoinExposed, bool protocolExposed) {\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (stableCoinExposure[i] > rebalanceThreshold) {\n                stablecoinExposed = true;\n                break;\n            }\n        }\n        for (uint256 i = 0; i < protocolExposure.length; i++) {\n            if (protocolExposure[i] > rebalanceThreshold) {\n                protocolExposed = true;\n                break;\n            }\n        }\n        if (!protocolExposed && curveExposure > rebalanceThreshold) protocolExposed = true;\n        return (stablecoinExposed, protocolExposed);\n    }\n\n    function _calcRiskExposure(SystemState memory sysState, bool treatLifeguardAsCurve)\n        private\n        view\n        returns (ExposureState memory expState)\n    {\n        address[N_COINS] memory vaults = _controller().vaults();\n        uint256 pCount = protocolCount;\n        expState.protocolExposure = new uint256[](pCount);\n        if (sysState.totalCurrentAssetsUsd == 0) {\n            return expState;\n        }\n        // Stablecoin exposure\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 vaultAssetsPercent = sysState.vaultCurrentAssetsUsd[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(\n                sysState.totalCurrentAssetsUsd\n            );\n            expState.stablecoinExposure[i] = vaultAssetsPercent;\n            // Protocol exposure\n            for (uint256 j = 0; j < pCount; j++) {\n                uint256 percentOfSystem = calculatePercentOfSystem(\n                    vaults[i],\n                    j,\n                    vaultAssetsPercent,\n                    sysState.vaultCurrentAssets[i]\n                );\n                expState.protocolExposure[j] = expState.protocolExposure[j].add(percentOfSystem);\n            }\n        }\n        if (treatLifeguardAsCurve) {\n            // Curve exposure is calculated by adding the Curve vaults total assets and any\n            // assets in the lifeguard which are poised to be invested into the Curve vault\n            expState.curveExposure = sysState.curveCurrentAssetsUsd.add(sysState.lifeguardCurrentAssetsUsd);\n        } else {\n            expState.curveExposure = sysState.curveCurrentAssetsUsd;\n        }\n        expState.curveExposure = expState.curveExposure.mul(PERCENTAGE_DECIMAL_FACTOR).div(\n            sysState.totalCurrentAssetsUsd\n        );\n\n        // Calculate stablecoin exposures\n        expState.stablecoinExposure = calculateStableCoinExposure(expState.stablecoinExposure, expState.curveExposure);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IPnL.sol\";\nimport \"../common/Controllable.sol\";\nimport \"../interfaces/IPnL.sol\";\nimport \"../common/Constants.sol\";\nimport {FixedGTokens} from \"../common/FixedContracts.sol\";\n\n/// @notice Contract for calculating protocol profit and loss. The PnL contract stores snapshots\n///     of total assets in pwrd and gvt, which are used to calculate utilisation ratio and establish\n///     changes in underling pwrd and gvt factors. The protocol will allow these values to drift as long\n///     as they stay within a certain threshold of protocol actuals, or large amounts of assets are being\n///     deposited or withdrawn from the protocol. The PnL contract ensures that any profits are distributed\n///     between pwrd and gvt based on the utilisation ratio - as this ratio movese towards 1, a larger\n///     amount of the pwrd profit is shifted to gvt. Protocol losses are on the other hand soaked up\n///     by gvt, ensuring that pwrd never lose value.\n///\n///     ###############################################\n///     PnL variables and calculations\n///     ###############################################\n///\n///     yield - system gains and losses from assets invested into strategies are realised once\n///         a harvest is run. Yield is ditributed to pwrd and gvt based on the utilisation ratio of the\n///         two tokens (see _calcProfit).\n///\n///     PerformanceFee - The performance fee is deducted from any yield profits, and is used to\n///         buy back and distribute governance tokens to users.\n///\n///     hodler Fee - Withdrawals experience a hodler fee that is socialized to all other holders.\n///         Like other gains, this isn't realised on withdrawal, but rather when a critical amount\n///         has amassed in the system (totalAssetsPercentThreshold).\n///\n///     ###############################################\n///     PnL Actions\n///     ###############################################\n///\n///     Pnl has two trigger mechanisms:\n///         - Harvest:\n///             - It will realize any loss/profit from the strategy\n///             - It will atempt to update lastest cached curve stable coin dy\n///                 - if successfull, it will try to realize any price changes (pre tvl vs current)\n///         - Withdrawals\n///             - Any user withdrawals are distributing the holder fee to the other users\ncontract PnL is Controllable, Constants, FixedGTokens, IPnL {\n    using SafeMath for uint256;\n\n    uint256 public override lastGvtAssets;\n    uint256 public override lastPwrdAssets;\n    bool public rebase = true;\n\n    uint256 public performanceFee; // Amount of gains to use to buy back and distribute gov tokens\n\n    event LogRebaseSwitch(bool status);\n    event LogNewPerfromanceFee(uint256 fee);\n    event LogNewGtokenChange(bool pwrd, int256 change);\n    event LogPnLExecution(\n        uint256 deductedAssets,\n        int256 totalPnL,\n        int256 investPnL,\n        int256 pricePnL,\n        uint256 withdrawalBonus,\n        uint256 performanceBonus,\n        uint256 beforeGvtAssets,\n        uint256 beforePwrdAssets,\n        uint256 afterGvtAssets,\n        uint256 afterPwrdAssets\n    );\n\n    constructor(\n        address pwrd,\n        address gvt,\n        uint256 pwrdAssets,\n        uint256 gvtAssets\n    ) public FixedGTokens(pwrd, gvt) {\n        lastPwrdAssets = pwrdAssets;\n        lastGvtAssets = gvtAssets;\n    }\n\n    /// @notice Turn pwrd rebasing on/off - This stops yield/ hodler bonuses to be distributed to the pwrd\n    ///     token, which effectively stops it from rebasing any further.\n    function setRebase(bool _rebase) external onlyOwner {\n        rebase = _rebase;\n        emit LogRebaseSwitch(_rebase);\n    }\n\n    /// @notice Fee taken from gains to be redistributed to users who stake their tokens\n    /// @param _performanceFee Amount to remove from gains (%BP)\n    function setPerformanceFee(uint256 _performanceFee) external onlyOwner {\n        performanceFee = _performanceFee;\n        emit LogNewPerfromanceFee(_performanceFee);\n    }\n\n    /// @notice Increase previously recorded GToken assets by specific amount\n    /// @param pwrd pwrd/gvt\n    /// @param dollarAmount Amount to increase by\n    function increaseGTokenLastAmount(bool pwrd, uint256 dollarAmount) external override {\n        require(msg.sender == controller, \"increaseGTokenLastAmount: !controller\");\n        if (!pwrd) {\n            lastGvtAssets = lastGvtAssets.add(dollarAmount);\n        } else {\n            lastPwrdAssets = lastPwrdAssets.add(dollarAmount);\n        }\n        emit LogNewGtokenChange(pwrd, int256(dollarAmount));\n    }\n\n    /// @notice Decrease previously recorded GToken assets by specific amount\n    /// @param pwrd pwrd/gvt\n    /// @param dollarAmount Amount to decrease by\n    /// @param bonus hodler bonus\n    function decreaseGTokenLastAmount(\n        bool pwrd,\n        uint256 dollarAmount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == controller, \"decreaseGTokenLastAmount: !controller\");\n        uint256 lastGA = lastGvtAssets;\n        uint256 lastPA = lastPwrdAssets;\n        if (!pwrd) {\n            lastGA = dollarAmount > lastGA ? 0 : lastGA.sub(dollarAmount);\n        } else {\n            lastPA = dollarAmount > lastPA ? 0 : lastPA.sub(dollarAmount);\n        }\n        if (bonus > 0) {\n            uint256 preGABeforeBonus = lastGA;\n            uint256 prePABeforeBonus = lastPA;\n            uint256 preTABeforeBonus = preGABeforeBonus.add(prePABeforeBonus);\n            if (rebase) {\n                lastGA = preGABeforeBonus.add(bonus.mul(preGABeforeBonus).div(preTABeforeBonus));\n                lastPA = prePABeforeBonus.add(bonus.mul(prePABeforeBonus).div(preTABeforeBonus));\n            } else {\n                lastGA = preGABeforeBonus.add(bonus);\n            }\n            emit LogPnLExecution(0, int256(bonus), 0, 0, bonus, 0, preGABeforeBonus, prePABeforeBonus, lastGA, lastPA);\n        }\n\n        lastGvtAssets = lastGA;\n        lastPwrdAssets = lastPA;\n        emit LogNewGtokenChange(pwrd, int256(-dollarAmount));\n    }\n\n    /// @notice Return latest system asset states\n    function calcPnL() external view override returns (uint256, uint256) {\n        return (lastGvtAssets, lastPwrdAssets);\n    }\n\n    /// @notice Calculate utilisation ratio between gvt and pwrd\n    function utilisationRatio() external view override returns (uint256) {\n        return lastGvtAssets != 0 ? lastPwrdAssets.mul(PERCENTAGE_DECIMAL_FACTOR).div(lastGvtAssets) : 0;\n    }\n\n    /// @notice Update assets after entering emergency state\n    function emergencyPnL() external override {\n        require(msg.sender == controller, \"emergencyPnL: !controller\");\n        forceDistribute();\n    }\n\n    /// @notice Recover system from emergency state\n    function recover() external override {\n        require(msg.sender == controller, \"recover: !controller\");\n        forceDistribute();\n    }\n\n    /// @notice Distribute yield based on utilisation ratio\n    /// @param gvtAssets Total gvt assets\n    /// @param pwrdAssets Total pwrd assets\n    /// @param profit Amount of profit to distribute\n    /// @param reward Rewards contract\n    function handleInvestGain(\n        uint256 gvtAssets,\n        uint256 pwrdAssets,\n        uint256 profit,\n        address reward\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 performanceBonus;\n        if (performanceFee > 0 && reward != address(0)) {\n            performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);\n            profit = profit.sub(performanceBonus);\n        }\n        if (rebase) {\n            uint256 totalAssets = gvtAssets.add(pwrdAssets);\n            uint256 gvtProfit = profit.mul(gvtAssets).div(totalAssets);\n            uint256 pwrdProfit = profit.mul(pwrdAssets).div(totalAssets);\n\n            uint256 factor = pwrdAssets.mul(10000).div(gvtAssets);\n            if (factor > 10000) factor = 10000;\n            if (factor < 8000) {\n                factor = factor.mul(3).div(8).add(3000);\n            } else {\n                factor = factor.sub(8000).mul(2).add(6000);\n            }\n\n            uint256 portionFromPwrdProfit = pwrdProfit.mul(factor).div(10000);\n            gvtAssets = gvtAssets.add(gvtProfit.add(portionFromPwrdProfit));\n            pwrdAssets = pwrdAssets.add(pwrdProfit.sub(portionFromPwrdProfit));\n        } else {\n            gvtAssets = gvtAssets.add(profit);\n        }\n        return (gvtAssets, pwrdAssets, performanceBonus);\n    }\n\n    /// @notice Distribute losses\n    /// @param gvtAssets Total gvt assets\n    /// @param pwrdAssets Total pwrd assets\n    /// @param loss Amount of loss to distribute\n    function handleLoss(\n        uint256 gvtAssets,\n        uint256 pwrdAssets,\n        uint256 loss\n    ) private pure returns (uint256, uint256) {\n        uint256 maxGvtLoss = gvtAssets.sub(DEFAULT_DECIMALS_FACTOR);\n        if (loss > maxGvtLoss) {\n            gvtAssets = DEFAULT_DECIMALS_FACTOR;\n            pwrdAssets = pwrdAssets.sub(loss.sub(maxGvtLoss));\n        } else {\n            gvtAssets = gvtAssets - loss;\n        }\n        return (gvtAssets, pwrdAssets);\n    }\n\n    function forceDistribute() private {\n        uint256 total = _controller().totalAssets();\n\n        if (total > lastPwrdAssets.add(DEFAULT_DECIMALS_FACTOR)) {\n            lastGvtAssets = total - lastPwrdAssets;\n        } else {\n            lastGvtAssets = DEFAULT_DECIMALS_FACTOR;\n            lastPwrdAssets = total.sub(DEFAULT_DECIMALS_FACTOR);\n        }\n    }\n\n    function distributeStrategyGainLoss(\n        uint256 gain,\n        uint256 loss,\n        address reward\n    ) external override {\n        require(msg.sender == controller, \"!Controller\");\n        uint256 lastGA = lastGvtAssets;\n        uint256 lastPA = lastPwrdAssets;\n        uint256 performanceBonus;\n        uint256 gvtAssets;\n        uint256 pwrdAssets;\n        int256 investPnL;\n        if (gain > 0) {\n            (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);\n            if (performanceBonus > 0) {\n                gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);\n                gvtAssets = gvtAssets.add(performanceBonus);\n            }\n\n            lastGvtAssets = gvtAssets;\n            lastPwrdAssets = pwrdAssets;\n            investPnL = int256(gain);\n        } else if (loss > 0) {\n            (lastGvtAssets, lastPwrdAssets) = handleLoss(lastGA, lastPA, loss);\n            investPnL = -int256(loss);\n        }\n\n        emit LogPnLExecution(\n            0,\n            investPnL,\n            investPnL,\n            0,\n            0,\n            performanceBonus,\n            lastGA,\n            lastPA,\n            lastGvtAssets,\n            lastPwrdAssets\n        );\n    }\n\n    function distributePriceChange(uint256 currentTotalAssets) external override {\n        require(msg.sender == controller, \"!Controller\");\n        uint256 gvtAssets = lastGvtAssets;\n        uint256 pwrdAssets = lastPwrdAssets;\n        uint256 totalAssets = gvtAssets.add(pwrdAssets);\n\n        if (currentTotalAssets > totalAssets) {\n            lastGvtAssets = gvtAssets.add(currentTotalAssets.sub(totalAssets));\n        } else if (currentTotalAssets < totalAssets) {\n            (lastGvtAssets, lastPwrdAssets) = handleLoss(gvtAssets, pwrdAssets, totalAssets.sub(currentTotalAssets));\n        }\n        int256 priceChange = int256(currentTotalAssets) - int256(totalAssets);\n\n        emit LogPnLExecution(\n            0,\n            priceChange,\n            0,\n            priceChange,\n            0,\n            0,\n            gvtAssets,\n            pwrdAssets,\n            lastGvtAssets,\n            lastPwrdAssets\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Buoy3Pool.sol",
            "Exposure.sol",
            "PnL.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Exposure.sol L178, PnL.sol L112, Buoy3Pool.sol L87",
                "Type": "implicit underflows",
                "Description": "There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert.",
                "Repair": "Replace int256(a-b) with int256(a)-int256(b), and replace int256(-x) with -int256(x)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport {FixedStablecoins, FixedGTokens} from \"./common/FixedContracts.sol\";\nimport \"./common/Whitelist.sol\";\n\nimport \"./interfaces/IBuoy.sol\";\nimport \"./interfaces/IChainPrice.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IInsurance.sol\";\nimport \"./interfaces/ILifeGuard.sol\";\nimport \"./interfaces/IPnL.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/// @notice The main hub for Gro protocol - The controller links up the other contracts,\n///     and acts a route for the other contracts to call one another. It holds global states\n///     such as paused and emergency. Contracts that depend on the controller implement\n///     Controllable.\n///\n///     *****************************************************************************\n///     System tokens - GTokens:\n///     gvt - high yield, uninsured\n///     pwrd - insured by gvt, pays part of its yield to gvt (depending on utilisation)\n///\n///     Tokens order is DAI, USDC, USDT.\n///     Index 0 - DAI, 1 - USDC, 2 - USDT\n///\n///     System vaults:\n///     Stablecoin vaults: One per stablecoin\n///     Curve vault: Vault for LP (liquidity pool) token\ncontract Controller is Pausable, Ownable, Whitelist, FixedStablecoins, FixedGTokens, IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public override curveVault; // LP token vault\n\n    bool public preventSmartContracts = false;\n\n    address public override insurance; // Insurance logic\n    address public override pnl; // Profit and loss calculations\n    address public override lifeGuard; // Asset swapping\n    address public override buoy; // Oracle\n    address public override depositHandler;\n    address public override withdrawHandler;\n    address public override emergencyHandler;\n\n    uint256 public override deadCoin = 99;\n    bool public override emergencyState;\n    // Lower bound for how many gvt can be burned before getting to close to the utilisation ratio\n    uint256 public utilisationRatioLimitGvt;\n    uint256 public utilisationRatioLimitPwrd;\n\n    /// Limits for what deposits/withdrawals that are considered 'large', and thus will be handled with\n    ///     a different logic - limits are checked against total assets locked in etiher of the two tokens (pwrd, gvt)\n    uint256 public bigFishThreshold = 100; // %Basis Points limit\n    uint256 public bigFishAbsoluteThreshold = 0; // Absolute limit\n    address public override reward;\n\n    mapping(address => bool) public safeAddresses; // Some integrations need to be exempt from flashloan checks\n    mapping(uint256 => address) public override underlyingVaults; // Protocol stablecoin vaults\n    mapping(address => uint256) public vaultIndexes;\n\n    mapping(address => address) public override referrals;\n\n    // Pwrd (true) and gvt (false) mapped to respective withdrawal fee\n    mapping(bool => uint256) public override withdrawalFee;\n\n    event LogNewWithdrawHandler(address tokens);\n    event LogNewDepositHandler(address tokens);\n    event LogNewVault(uint256 index, address vault);\n    event LogNewCurveVault(address curveVault);\n    event LogNewLifeguard(address lifeguard);\n    event LogNewInsurance(address insurance);\n    event LogNewPnl(address pnl);\n    event LogNewBigFishThreshold(uint256 percent, uint256 absolute);\n    event LogFlashSwitchUpdated(bool status);\n    event LogNewSafeAddress(address account);\n    event LogNewRewardsContract(address reward);\n    event LogNewUtilLimit(bool indexed pwrd, uint256 limit);\n    event LogNewCurveToStableDistribution(uint256 amount, uint256[N_COINS] amounts, uint256[N_COINS] delta);\n    event LogNewWithdrawalFee(address user, bool pwrd, uint256 newFee);\n\n    constructor(\n        address pwrd,\n        address gvt,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals\n    ) public FixedStablecoins(_tokens, _decimals) FixedGTokens(pwrd, gvt) {}\n\n    function pause() external onlyWhitelist {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {\n        require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");\n        withdrawHandler = _withdrawHandler;\n        emergencyHandler = _emergencyHandler;\n        emit LogNewWithdrawHandler(_withdrawHandler);\n    }\n\n    function setDepositHandler(address _depositHandler) external onlyOwner {\n        require(_depositHandler != address(0), \"setDepositHandler: 0x\");\n        depositHandler = _depositHandler;\n        emit LogNewDepositHandler(_depositHandler);\n    }\n\n    function stablecoins() external view override returns (address[N_COINS] memory) {\n        return underlyingTokens();\n    }\n\n    /// @notice Returns amount to skim of larger deposits for alternative vault (Curve)\n    function getSkimPercent() external view override returns (uint256) {\n        return IInsurance(insurance).calcSkim();\n    }\n\n    /// @notice Returns list of all the underling protocol vaults\n    function vaults() external view override returns (address[N_COINS] memory) {\n        address[N_COINS] memory result;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = underlyingVaults[i];\n        }\n        return result;\n    }\n\n    /// @notice Set system vaults, vault index should match its underlying token\n    function setVault(uint256 index, address vault) external onlyOwner {\n        require(vault != address(0), \"setVault: 0x\");\n        require(index < N_COINS, \"setVault: !index\");\n        underlyingVaults[index] = vault;\n        vaultIndexes[vault] = index + 1;\n        emit LogNewVault(index, vault);\n    }\n\n    function setCurveVault(address _curveVault) external onlyOwner {\n        require(_curveVault != address(0), \"setCurveVault: 0x\");\n        curveVault = _curveVault;\n        vaultIndexes[_curveVault] = N_COINS + 1;\n        emit LogNewCurveVault(_curveVault);\n    }\n\n    function setLifeGuard(address _lifeGuard) external onlyOwner {\n        require(_lifeGuard != address(0), \"setLifeGuard: 0x\");\n        lifeGuard = _lifeGuard;\n        buoy = ILifeGuard(_lifeGuard).getBuoy();\n        emit LogNewLifeguard(_lifeGuard);\n    }\n\n    function setInsurance(address _insurance) external onlyOwner {\n        require(_insurance != address(0), \"setInsurance: 0x\");\n        insurance = _insurance;\n        emit LogNewInsurance(_insurance);\n    }\n\n    function setPnL(address _pnl) external onlyOwner {\n        require(_pnl != address(0), \"setPnl: 0x\");\n        pnl = _pnl;\n        emit LogNewPnl(_pnl);\n    }\n\n    function addSafeAddress(address account) external onlyOwner {\n        safeAddresses[account] = true;\n        emit LogNewSafeAddress(account);\n    }\n\n    function switchEoaOnly(bool check) external onlyOwner {\n        preventSmartContracts = check;\n    }\n\n    /// @notice Set limit for when a deposit will be rerouted for alternative logic\n    /// @param _percent %BP limit\n    /// @param _absolute Absolute limit\n    /// @dev The two limits should be used as an upper and lower bound - the % limit\n    ///     considers the current TVL in the token interacted with (gvt or pwrd) and will\n    ///     act as the upper bound when the TVL is low. The absolute value will be the lower bound,\n    ///     ensuring that small deposits won't suffer higher gas costs.\n    function setBigFishThreshold(uint256 _percent, uint256 _absolute) external onlyOwner {\n        require(_percent > 0, \"_whaleLimit is 0\");\n        bigFishThreshold = _percent;\n        bigFishAbsoluteThreshold = _absolute;\n        emit LogNewBigFishThreshold(_percent, _absolute);\n    }\n\n    function setReward(address _reward) external onlyOwner {\n        require(_reward != address(0), \"setReward: 0x\");\n        reward = _reward;\n        emit LogNewRewardsContract(_reward);\n    }\n\n    function addReferral(address account, address referral) external override {\n        require(msg.sender == depositHandler, \"!depositHandler\");\n        if (account != address(0) && referral != address(0) && referrals[account] == address(0)) {\n            referrals[account] = referral;\n        }\n    }\n\n    /// @notice Set withdrawal fee for token\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param newFee New token fee\n    function setWithdrawalFee(bool pwrd, uint256 newFee) external onlyOwner {\n        withdrawalFee[pwrd] = newFee;\n        emit LogNewWithdrawalFee(msg.sender, pwrd, newFee);\n    }\n\n    /// @notice Calculate system total assets\n    function totalAssets() external view override returns (uint256) {\n        return emergencyState ? _totalAssetsEmergency() : _totalAssets();\n    }\n\n    /// @notice Calculate pwrd/gro vault total assets\n    function gTokenTotalAssets() public view override returns (uint256) {\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        if (msg.sender == address(gvt)) {\n            return gvtAssets;\n        }\n        if (msg.sender == address(pwrd)) {\n            return pwrdAssets;\n        }\n        return 0;\n    }\n\n    function gToken(bool isPWRD) external view override returns (address) {\n        return isPWRD ? address(pwrd) : address(gvt);\n    }\n\n    /// @notice Check if the deposit/withdrawal needs to go through alternate logic\n    /// @param amount USD amount of deposit/withdrawal\n    /// @dev Larger deposits are handled differently than small deposits in order\n    ///     to guarantee that the system isn't overexposed to any one stablecoin\n    function isValidBigFish(\n        bool pwrd,\n        bool deposit,\n        uint256 amount\n    ) external view override returns (bool) {\n        if (deposit && pwrd) {\n            require(validGTokenIncrease(amount), \"isBigFish: !validGTokenIncrease\");\n        } else if (!pwrd && !deposit) {\n            require(validGTokenDecrease(amount), \"isBigFish: !validGTokenDecrease\");\n        }\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        uint256 assets = pwrdAssets.add(gvtAssets);\n        if (amount < bigFishAbsoluteThreshold) {\n            return false;\n        } else if (amount > assets) {\n            return true;\n        } else {\n            return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);\n        }\n    }\n\n    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist {\n        uint256[N_COINS] memory amounts = ILifeGuard(lifeGuard).distributeCurveVault(amount, delta);\n        emit LogNewCurveToStableDistribution(amount, amounts, delta);\n    }\n\n    /// @notice Block if not an EOA or whitelisted\n    /// @param sender Address of contract to check\n    function eoaOnly(address sender) public override {\n        if (preventSmartContracts && !safeAddresses[tx.origin]) {\n            require(sender == tx.origin, \"EOA only\");\n        }\n    }\n\n    /// @notice TotalAssets = lifeguard + stablecoin vaults + LP vault\n    function _totalAssets() private view returns (uint256) {\n        require(IBuoy(buoy).safetyCheck(), \"!buoy.safetyCheck\");\n        uint256[N_COINS] memory lgAssets = ILifeGuard(lifeGuard).getAssets();\n        uint256[N_COINS] memory vaultAssets;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            vaultAssets[i] = lgAssets[i].add(IVault(underlyingVaults[i]).totalAssets());\n        }\n        uint256 totalLp = IVault(curveVault).totalAssets();\n        totalLp = totalLp.add(IBuoy(buoy).stableToLp(vaultAssets, true));\n        uint256 vp = IBuoy(buoy).getVirtualPrice();\n\n        return totalLp.mul(vp).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    /// @notice Same as _totalAssets function, but excluding curve vault + 1 stablecoin\n    ///             and uses chianlink as a price oracle\n    function _totalAssetsEmergency() private view returns (uint256) {\n        IChainPrice chainPrice = IChainPrice(buoy);\n        uint256 total;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (i != deadCoin) {\n                address tokenAddress = getToken(i);\n                uint256 decimals = getDecimal(i);\n                IERC20 token = IERC20(tokenAddress);\n                uint256 price = chainPrice.getPriceFeed(i);\n                uint256 assets = IVault(underlyingVaults[i]).totalAssets().add(token.balanceOf(lifeGuard));\n                assets = assets.mul(price).div(CHAINLINK_PRICE_DECIMAL_FACTOR);\n                assets = assets.mul(DEFAULT_DECIMALS_FACTOR).div(decimals);\n                total = total.add(assets);\n            }\n        }\n        return total;\n    }\n\n    /// @notice Set protocol into emergency mode, disabling the use of a give stablecoin.\n    ///             This state assumes:\n    ///                 - Stablecoin of excessively of peg\n    ///                 - Curve3Pool has failed\n    ///             Swapping wil be disabled and the allocation target will be set to\n    ///             100 % for the disabled stablecoin, effectively stopping the system from\n    ///             returning any to the user. Deposit are disable in this mode.\n    /// @param coin Stable coin to disable\n    function emergency(uint256 coin) external onlyWhitelist {\n        require(coin < N_COINS, \"invalid coin\");\n        if (!paused()) {\n            _pause();\n        }\n        deadCoin = coin;\n        emergencyState = true;\n\n        uint256 percent;\n        for (uint256 i; i < N_COINS; i++) {\n            if (i == coin) {\n                percent = 10000;\n            } else {\n                percent = 0;\n            }\n            IInsurance(insurance).setUnderlyingTokenPercent(i, percent);\n        }\n        IPnL(pnl).emergencyPnL();\n    }\n\n    /// @notice Recover the system after emergency mode -\n    /// @param allocations New system target allocations\n    /// @dev Will recalculate system assets and atempt to give back any\n    ///     recovered assets to the GVT side\n    function restart(uint256[] calldata allocations) external onlyOwner whenPaused {\n        _unpause();\n        deadCoin = 99;\n        emergencyState = false;\n\n        for (uint256 i; i < N_COINS; i++) {\n            IInsurance(insurance).setUnderlyingTokenPercent(i, allocations[i]);\n        }\n        IPnL(pnl).recover();\n    }\n\n    /// @notice Distribute any gains or losses generated from a harvest\n    /// @param gain harvset gains\n    /// @param loss harvest losses\n    function distributeStrategyGainLoss(uint256 gain, uint256 loss) external override {\n        uint256 index = vaultIndexes[msg.sender];\n        require(index > 0 || index <= N_COINS + 1, \"!VaultAdaptor\");\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        uint256 gainUsd;\n        uint256 lossUsd;\n        index = index - 1;\n        if (index < N_COINS) {\n            if (gain > 0) {\n                gainUsd = ibuoy.singleStableToUsd(gain, index);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.singleStableToUsd(loss, index);\n            }\n        } else {\n            if (gain > 0) {\n                gainUsd = ibuoy.lpToUsd(gain);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.lpToUsd(loss);\n            }\n        }\n        ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);\n        // Check if curve spot price within tollerance, if so update them\n        if (ibuoy.updateRatios()) {\n            // If the curve ratios were successfully updated, realize system price changes\n            ipnl.distributePriceChange(_totalAssets());\n        }\n    }\n\n    function realizePriceChange(uint256 tolerance) external onlyOwner {\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        if (emergencyState) {\n            ipnl.distributePriceChange(_totalAssetsEmergency());\n        } else {\n            // Check if curve spot price within tollerance, if so update them\n            if (ibuoy.updateRatiosWithTolerance(tolerance)) {\n                // If the curve ratios were successfully updated, realize system price changes\n                ipnl.distributePriceChange(_totalAssets());\n            }\n        }\n    }\n\n    function burnGToken(\n        bool pwrd,\n        bool all,\n        address account,\n        uint256 amount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == withdrawHandler || msg.sender == emergencyHandler, \"burnGToken: !withdrawHandler\");\n        IToken gt = gTokens(pwrd);\n        if (!all) {\n            gt.burn(account, gt.factor(), amount);\n        } else {\n            gt.burnAll(account);\n        }\n        // Update underlying assets held in pwrd/gvt\n        IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount, bonus);\n    }\n\n    function mintGToken(\n        bool pwrd,\n        address account,\n        uint256 amount\n    ) external override {\n        require(msg.sender == depositHandler, \"burnGToken: !depositHandler\");\n        IToken gt = gTokens(pwrd);\n        gt.mint(account, gt.factor(), amount);\n        IPnL(pnl).increaseGTokenLastAmount(pwrd, amount);\n    }\n\n    /// @notice Calcualte withdrawal value when withdrawing all\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param account User account\n    function getUserAssets(bool pwrd, address account) external view override returns (uint256 deductUsd) {\n        IToken gt = gTokens(pwrd);\n        deductUsd = gt.getAssets(account);\n        require(deductUsd > 0, \"!minAmount\");\n    }\n\n    /// @notice Check if it's OK to mint the specified amount of tokens, this affects\n    ///     pwrds, as they have an upper bound set by the amount of gvt\n    /// @param amount Amount of token to mint\n    function validGTokenIncrease(uint256 amount) private view returns (bool) {\n        return\n            gTokens(false).totalAssets().mul(utilisationRatioLimitPwrd).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            amount.add(gTokens(true).totalAssets());\n    }\n\n    /// @notice Check if it's OK to burn the specified amount of tokens, this affects\n    ///     gvt, as they have a lower bound set by the amount of pwrds\n    /// @param amount Amount of token to burn\n    function validGTokenDecrease(uint256 amount) public view override returns (bool) {\n        return\n            gTokens(false).totalAssets().sub(amount).mul(utilisationRatioLimitGvt).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            gTokens(true).totalAssets();\n    }\n\n    /// @notice Set the lower bound for when to stop accepting deposits for pwrd - this allows for a bit of legroom\n    ///     for gvt to be sold (if this limit is reached, this contract only accepts deposits for gvt)\n    /// @param _utilisationRatioLimitPwrd Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitPwrd(uint256 _utilisationRatioLimitPwrd) external onlyOwner {\n        utilisationRatioLimitPwrd = _utilisationRatioLimitPwrd;\n        emit LogNewUtilLimit(true, _utilisationRatioLimitPwrd);\n    }\n\n    /// @notice Set the lower bound for when to stop accepting gvt withdrawals\n    /// @param _utilisationRatioLimitGvt Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitGvt(uint256 _utilisationRatioLimitGvt) external onlyOwner {\n        utilisationRatioLimitGvt = _utilisationRatioLimitGvt;\n        emit LogNewUtilLimit(false, _utilisationRatioLimitGvt);\n    }\n\n    function getStrategiesTargetRatio() external view override returns (uint256[] memory) {\n        uint256 utilRatio = IPnL(pnl).utilisationRatio();\n        return IInsurance(insurance).getStrategiesTargetRatio(utilRatio);\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "require() on L357 of Controller.sol",
                "Type": "incorrect use of operator",
                "Description": "The operator used in the require() is || instead of &&, which allows an arbitrary msg.sender, i.e. attacker, to bypass the check.",
                "Repair": "Change || to && in require() on L357 of Controller.sol to prevent arbitrary addresses from going past this check. Or, consider exercising explicit access control for the authorized vault adaptors."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"./GERC20.sol\";\nimport \"../common/Constants.sol\";\nimport \"../common/Whitelist.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../interfaces/IToken.sol\";\n\n/// @notice Base contract for gro protocol tokens - The Gro token specifies some additional functionality\n///     shared by both tokens (Rebasing, NonRebasing).\n///     - Factor:\n///         The GToken factor. The two tokens are associated with a factor that controls their price (NonRebasing),\n///         or their amount (Rebasing). The factor is defined by the totalSupply / total assets lock in token.\n///     - Base:\n///         The base amount of minted tokens, this affects the Rebasing token as the totalSupply is defined by:\n///         BASE amount / factor\n///     - Total assets:\n///         Total assets is the dollarvalue of the underlying assets used to mint Gtokens. The Gtoken\n///         depends on an external contract (Controller.sol) to get this value (retrieved from PnL calculations)\nabstract contract GToken is GERC20, Constants, Whitelist, IToken {\n    uint256 public constant BASE = DEFAULT_DECIMALS_FACTOR;\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IController public ctrl;\n\n    constructor(string memory name, string memory symbol) public GERC20(name, symbol, DEFAULT_DECIMALS) {}\n\n    function setController(address controller) external onlyOwner {\n        ctrl = IController(controller);\n    }\n\n    function factor() public view override returns (uint256) {\n        return factor(totalAssets());\n    }\n\n    function applyFactor(\n        uint256 a,\n        uint256 b,\n        bool base\n    ) internal pure returns (uint256 resultant) {\n        uint256 _BASE = BASE;\n        uint256 diff;\n        if (base) {\n            diff = a.mul(b) % _BASE;\n            resultant = a.mul(b).div(_BASE);\n        } else {\n            diff = a.mul(_BASE) % b;\n            resultant = a.mul(_BASE).div(b);\n        }\n        if (diff >= 5E17) {\n            resultant = resultant.add(1);\n        }\n    }\n\n    function factor(uint256 totalAssets) public view override returns (uint256) {\n        if (totalSupplyBase() == 0) {\n            return getInitialBase();\n        }\n\n        if (totalAssets > 0) {\n            return totalSupplyBase().mul(BASE).div(totalAssets);\n        }\n\n        // This case is totalSupply > 0 && totalAssets == 0, and only occurs on system loss\n        return 0;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return ctrl.gTokenTotalAssets();\n    }\n\n    function getInitialBase() internal pure virtual returns (uint256) {\n        return BASE;\n    }\n}\n\n\n",
        "CodeNames": [
            "GToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GToken.factor() function",
                "Type": "early user can break minting",
                "Description": "The first user can manipulate the factor such that it always returns 0. This means all deposits and future value accrues to the attacker who holds the only base tokens.",
                "Repair": "On first mint (total base supply == 0), lock some of the first minter's tokens by minting ~1% of the initial amount to the zero address instead of to the first minter"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../common/StructDefinitions.sol\";\nimport \"../common/Constants.sol\";\nimport \"../common/Controllable.sol\";\nimport \"../common/Whitelist.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../interfaces/ILifeGuard.sol\";\nimport \"../interfaces/IExposure.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IBuoy.sol\";\n\n/// @notice Contract for calculating current protocol exposures on a stablecoin and\n///     protocol level. This contract can be upgraded if the systems underlying protocols\n///     or tokens have changed. Protocol exposure are calculated at a high level, as any\n///     additional exposures from underlying protocol exposures should at most be equal to\n///     the high level exposure.\n///     For example: harvest finance stablecoin vaults (fTokens)\n///         - High level exposure\n///             - Harvest finance\n///         - Low level exposures (from fToken investments):\n///             - Compound\n///             - Idle finance\n///     Neither of these two low level exposures should matter as long as there arent\n///     additional exposure to these protocol elsewhere. So by desing, the protocols\n///     are given indexes based on the strategies in the stablecoin vaults, which need\n///     to be symetrical for this to work - e.g. all vaults needs to have the same exposure\n///     profile, and non of these exposure profiles can overlap. In the case where the\n///     additional exposure needs to be taken into account (maker has USDC collateral,\n///     Curve adds exposure to all stablecoins in a liquidity pool), they will be calculated\n///     and added ontop of the base exposure from vaults and strategies.\n///\n///     --------------------------------------------------------\n///     Current protocol setup:\n///     --------------------------------------------------------\n///     Stablecoins: DAI, USDC, USDT\n///     LP tokens: 3Crv\n///     Vaults: DAIVault, USDCVault, USDTVault, 3Crv vault\n///     Strategy (exposures):\n///         - Compound\n///         - Idle finance\n///         - Yearn Generic Lender:\n///             - Cream\n///         - CurveXpool:\n///             - Curve3Pool\n///             - CurveMetaPool\n///             - Yearn\ncontract Exposure is Constants, Controllable, Whitelist, IExposure {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public protocolCount;\n    uint256 public makerUSDCExposure;\n\n    event LogNewProtocolCount(uint256 count);\n    event LogNewMakerExposure(uint256 exposure);\n\n    /// @notice Add protocol for the exposure calculations\n    /// @dev Currently set to:\n    ///     1 - Harvest finance\n    ///     2 - Cream\n    ///     Curve exposure is calculated separately as it has wider system impact\n    function setProtocolCount(uint256 _protocolCount) external onlyOwner {\n        protocolCount = _protocolCount;\n        emit LogNewProtocolCount(_protocolCount);\n    }\n\n    /// @notice Specify additional USDC exposure to Maker\n    /// @param _makerUSDCExposure Exposure amount to Maker\n    function setMakerUSDCExposure(uint256 _makerUSDCExposure) external onlyOwner {\n        makerUSDCExposure = _makerUSDCExposure;\n        emit LogNewMakerExposure(_makerUSDCExposure);\n    }\n\n    function getExactRiskExposure(SystemState calldata sysState)\n        external\n        view\n        override\n        returns (ExposureState memory expState)\n    {\n        expState = _calcRiskExposure(sysState, false);\n        ILifeGuard lifeguard = ILifeGuard(_controller().lifeGuard());\n        IBuoy buoy = IBuoy(_controller().buoy());\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 assets = lifeguard.assets(i);\n            uint256 assetsUsd = buoy.singleStableToUsd(assets, i);\n            expState.stablecoinExposure[i] = expState.stablecoinExposure[i].add(\n                assetsUsd.mul(PERCENTAGE_DECIMAL_FACTOR).div(sysState.totalCurrentAssetsUsd)\n            );\n        }\n    }\n\n    /// @notice Calculate stablecoin and protocol level risk exposure\n    /// @param sysState Struct holding info about systems current state\n    /// @dev This loops through all the vaults, checks the amount of assets in them\n    ///     and their underlying strategies to understand stablecoin exposure\n    ///     - Any assets invested in Curve or similar AMM will have additional stablecoin exposure.\n    ///     The protocol exposure is calculated by assessing the amount of assets each\n    ///     vault has invested in a strategy.\n    function calcRiskExposure(SystemState calldata sysState)\n        external\n        view\n        override\n        returns (ExposureState memory expState)\n    {\n        expState = _calcRiskExposure(sysState, true);\n\n        // Establish if any stablecoin/protocol is over exposed\n        (expState.stablecoinExposed, expState.protocolExposed) = isExposed(\n            sysState.rebalanceThreshold,\n            expState.stablecoinExposure,\n            expState.protocolExposure,\n            expState.curveExposure\n        );\n    }\n\n    /// @notice Do a rough USD dollar calculation by treating every stablecoin as\n    ///     worth 1 USD and set all Decimals to 18\n    function getUnifiedAssets(address[N_COINS] calldata vaults)\n        public\n        view\n        override\n        returns (uint256 unifiedTotalAssets, uint256[N_COINS] memory unifiedAssets)\n    {\n        // unify all assets to 18 decimals, treat each stablecoin as being worth 1 USD\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 assets = IVault(vaults[i]).totalAssets();\n            unifiedAssets[i] = assets.mul(DEFAULT_DECIMALS_FACTOR).div(\n                uint256(10)**IERC20Detailed(IVault(vaults[i]).token()).decimals()\n            );\n            unifiedTotalAssets = unifiedTotalAssets.add(unifiedAssets[i]);\n        }\n    }\n\n    /// @notice Rough delta calculation - assumes each stablecoin is priced at 1 USD,\n    ///     and looks at differences between current allocations and target allocations\n    /// @param targets Stable coin allocation targest\n    /// @param vaults Stablecoin vaults\n    /// @param withdrawUsd USD value of withdrawals\n    function calcRoughDelta(\n        uint256[N_COINS] calldata targets,\n        address[N_COINS] calldata vaults,\n        uint256 withdrawUsd\n    ) external view override returns (uint256[N_COINS] memory delta) {\n        (uint256 totalAssets, uint256[N_COINS] memory vaultTotalAssets) = getUnifiedAssets(vaults);\n\n        require(totalAssets > withdrawUsd, \"totalAssets < withdrawalUsd\");\n        totalAssets = totalAssets.sub(withdrawUsd);\n        uint256 totalDelta;\n        for (uint256 i; i < N_COINS; i++) {\n            uint256 target = totalAssets.mul(targets[i]).div(PERCENTAGE_DECIMAL_FACTOR);\n            if (vaultTotalAssets[i] > target) {\n                delta[i] = vaultTotalAssets[i].sub(target);\n                totalDelta = totalDelta.add(delta[i]);\n            }\n        }\n        uint256 percent = PERCENTAGE_DECIMAL_FACTOR;\n        for (uint256 i; i < N_COINS - 1; i++) {\n            if (delta[i] > 0) {\n                delta[i] = delta[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(totalDelta);\n                percent = percent.sub(delta[i]);\n            }\n        }\n        delta[N_COINS - 1] = percent;\n        return delta;\n    }\n\n    /// @notice Sort vaults by the delta of target asset - current asset,\n    ///     only support 3 vaults now\n    /// @param bigFirst Return array order most exposed -> least exposed\n    /// @param unifiedTotalAssets Estimated system USD assets\n    /// @param unifiedAssets Estimated vault USD assets\n    /// @param targetPercents Vault target percent array\n    function sortVaultsByDelta(\n        bool bigFirst,\n        uint256 unifiedTotalAssets,\n        uint256[N_COINS] calldata unifiedAssets,\n        uint256[N_COINS] calldata targetPercents\n    ) external pure override returns (uint256[N_COINS] memory vaultIndexes) {\n        uint256 maxIndex;\n        uint256 minIndex;\n        int256 maxDelta;\n        int256 minDelta;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            // Get difference between vault current assets and vault target\n            int256 delta = int256(\n                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)\n            );\n            // Establish order\n            if (delta > maxDelta) {\n                maxDelta = delta;\n                maxIndex = i;\n            } else if (delta < minDelta) {\n                minDelta = delta;\n                minIndex = i;\n            }\n        }\n        if (bigFirst) {\n            vaultIndexes[0] = maxIndex;\n            vaultIndexes[2] = minIndex;\n        } else {\n            vaultIndexes[0] = minIndex;\n            vaultIndexes[2] = maxIndex;\n        }\n        vaultIndexes[1] = N_COINS - maxIndex - minIndex;\n    }\n\n    /// @notice Calculate what percentage of system total assets the assets in a strategy make up\n    /// @param vault Address of target vault that holds the strategy\n    /// @param index Index of strategy\n    /// @param vaultAssetsPercent Percentage of system assets\n    /// @param vaultAssets Total assets in vaults\n    function calculatePercentOfSystem(\n        address vault,\n        uint256 index,\n        uint256 vaultAssetsPercent,\n        uint256 vaultAssets\n    ) private view returns (uint256 percentOfSystem) {\n        if (vaultAssets == 0) return 0;\n        uint256 strategyAssetsPercent = IVault(vault).getStrategyAssets(index).mul(PERCENTAGE_DECIMAL_FACTOR).div(\n            vaultAssets\n        );\n\n        percentOfSystem = vaultAssetsPercent.mul(strategyAssetsPercent).div(PERCENTAGE_DECIMAL_FACTOR);\n    }\n\n    /// @notice Calculate the net stablecoin exposure\n    /// @param directlyExposure Amount of stablecoin in vault+strategies\n    /// @param curveExposure Percent of assets in Curve\n    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure)\n        private\n        view\n        returns (uint256[N_COINS] memory stableCoinExposure)\n    {\n        uint256 maker = directlyExposure[0].mul(makerUSDCExposure).div(PERCENTAGE_DECIMAL_FACTOR);\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 indirectExposure = curveExposure;\n            if (i == 1) {\n                indirectExposure = indirectExposure.add(maker);\n            }\n            stableCoinExposure[i] = directlyExposure[i].add(indirectExposure);\n        }\n    }\n\n    /// @notice Determine if an assets or protocol is overexposed\n    /// @param rebalanceThreshold Threshold for triggering a rebalance due to overexposure\n    /// @param stableCoinExposure Current stable coin exposures\n    /// @param protocolExposure Current prtocol exposures\n    /// @param curveExposure Current Curve exposure\n    function isExposed(\n        uint256 rebalanceThreshold,\n        uint256[N_COINS] memory stableCoinExposure,\n        uint256[] memory protocolExposure,\n        uint256 curveExposure\n    ) private pure returns (bool stablecoinExposed, bool protocolExposed) {\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (stableCoinExposure[i] > rebalanceThreshold) {\n                stablecoinExposed = true;\n                break;\n            }\n        }\n        for (uint256 i = 0; i < protocolExposure.length; i++) {\n            if (protocolExposure[i] > rebalanceThreshold) {\n                protocolExposed = true;\n                break;\n            }\n        }\n        if (!protocolExposed && curveExposure > rebalanceThreshold) protocolExposed = true;\n        return (stablecoinExposed, protocolExposed);\n    }\n\n    function _calcRiskExposure(SystemState memory sysState, bool treatLifeguardAsCurve)\n        private\n        view\n        returns (ExposureState memory expState)\n    {\n        address[N_COINS] memory vaults = _controller().vaults();\n        uint256 pCount = protocolCount;\n        expState.protocolExposure = new uint256[](pCount);\n        if (sysState.totalCurrentAssetsUsd == 0) {\n            return expState;\n        }\n        // Stablecoin exposure\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 vaultAssetsPercent = sysState.vaultCurrentAssetsUsd[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(\n                sysState.totalCurrentAssetsUsd\n            );\n            expState.stablecoinExposure[i] = vaultAssetsPercent;\n            // Protocol exposure\n            for (uint256 j = 0; j < pCount; j++) {\n                uint256 percentOfSystem = calculatePercentOfSystem(\n                    vaults[i],\n                    j,\n                    vaultAssetsPercent,\n                    sysState.vaultCurrentAssets[i]\n                );\n                expState.protocolExposure[j] = expState.protocolExposure[j].add(percentOfSystem);\n            }\n        }\n        if (treatLifeguardAsCurve) {\n            // Curve exposure is calculated by adding the Curve vaults total assets and any\n            // assets in the lifeguard which are poised to be invested into the Curve vault\n            expState.curveExposure = sysState.curveCurrentAssetsUsd.add(sysState.lifeguardCurrentAssetsUsd);\n        } else {\n            expState.curveExposure = sysState.curveCurrentAssetsUsd;\n        }\n        expState.curveExposure = expState.curveExposure.mul(PERCENTAGE_DECIMAL_FACTOR).div(\n            sysState.totalCurrentAssetsUsd\n        );\n\n        // Calculate stablecoin exposures\n        expState.stablecoinExposure = calculateStableCoinExposure(expState.stablecoinExposure, expState.curveExposure);\n    }\n}\n\n\n",
        "CodeNames": [
            "Exposure.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Exposure.sol L178",
                "Type": "High Severity",
                "Description": "The function sortVaultsByDelta doesn't always work as expected.",
                "Repair": "Initializing maxDelta and minDelta, Check that maxIndex and minIndex are not the same, require (maxIndex != minIndex)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {FixedStablecoins} from \"contracts/common/FixedContracts.sol\";\nimport {ICurve3Pool} from \"contracts/interfaces/ICurve.sol\";\n\nimport \"contracts/common/Controllable.sol\";\n\nimport \"contracts/interfaces/IBuoy.sol\";\nimport \"contracts/interfaces/IChainPrice.sol\";\nimport \"contracts/interfaces/IChainlinkAggregator.sol\";\nimport \"contracts/interfaces/IERC20Detailed.sol\";\n\n/// @notice Contract for calculating prices of underlying assets and LP tokens in Curve pool. Also\n///     used to sanity check pool against external oracle, to ensure that pools underlying coin ratios\n///     are within a specific range (measued in BP) of the external oracles coin price ratios.\n///     Sanity check:\n///         The Buoy checks previously recorded (cached) curve coin dy, which it compares against current curve dy,\n///         blocking any interaction that is outside a certain tolerance (BASIS_POINTS). When updting the cached\n///         value, the buoy uses chainlink to ensure that curves prices arent off peg.\ncontract Buoy3Pool is FixedStablecoins, Controllable, IBuoy, IChainPrice {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 TIME_LIMIT = 3000;\n    uint256 public BASIS_POINTS = 20;\n    uint256 constant CHAIN_FACTOR = 100;\n\n    ICurve3Pool public immutable override curvePool;\n    IERC20 public immutable lpToken;\n\n    mapping(uint256 => uint256) lastRatio;\n\n    // Chianlink price feed\n    address public immutable daiUsdAgg;\n    address public immutable usdcUsdAgg;\n    address public immutable usdtUsdAgg;\n\n    mapping(address => mapping(address => uint256)) public tokenRatios;\n\n    event LogNewBasisPointLimit(uint256 oldLimit, uint256 newLimit);\n\n    constructor(\n        address _crv3pool,\n        address poolToken,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals,\n        address[N_COINS] memory aggregators\n    ) public FixedStablecoins(_tokens, _decimals) {\n        curvePool = ICurve3Pool(_crv3pool);\n        lpToken = IERC20(poolToken);\n        daiUsdAgg = aggregators[0];\n        usdcUsdAgg = aggregators[1];\n        usdtUsdAgg = aggregators[2];\n    }\n\n    /// @notice Set limit for how much Curve pool and external oracle is allowed\n    ///     to deviate before failing transactions\n    /// @param newLimit New limit in BP\n    function setBasisPointsLmit(uint256 newLimit) external onlyOwner {\n        uint256 oldLimit = BASIS_POINTS;\n        BASIS_POINTS = newLimit;\n        emit LogNewBasisPointLimit(oldLimit, newLimit);\n    }\n\n    /// @notice Check the health of the Curve pool:\n    ///     Ratios are checked by the following heuristic:\n    ///     Orcale A - Curve\n    ///     Oracle B - External oracle\n    ///     Both oracles establish ratios for a set of stable coins\n    ///         (a, b, c)\n    ///     and product the following set of ratios:\n    ///         (a/a, a/b, a/c), (b/b, b/a, b/c), (c/c, c/a, c/b)\n    ///     It's simply to reduce the number of comparisons to be made\n    ///     in order to have complete coverage of the system ratios:\n    ///         1) ratios between a stable coin and itself can be discarded\n    ///         2) inverted ratios, a/b bs b/a, while producing different results\n    ///             should both reflect the same change in any one of the two\n    ///             underlying assets, but in opposite directions\n    ///     This mean that the following set should provide the necessary coverage checks\n    ///     to establish that the coins pricing is healthy:\n    ///         (a/b, a/c)\n    function safetyCheck() external view override returns (bool) {\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            _ratio = abs(int256(_ratio - lastRatio[i]));\n            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Updated cached curve value with a custom tolerance towards chainlink\n    /// @param tolerance How much difference between curve and chainlink can be tolerated\n    function updateRatiosWithTolerance(uint256 tolerance) external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatiosWithTolerance: !authorized\");\n        return _updateRatios(tolerance);\n    }\n\n    /// @notice Updated cached curve values\n    function updateRatios() external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatios: !authorized\");\n        return _updateRatios(BASIS_POINTS);\n    }\n\n    /// @notice Get USD value for a specific input amount of tokens, slippage included\n    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToUsd(inAmounts, deposit);\n    }\n\n    /// @notice Get estimate USD price of a stablecoin amount\n    /// @param inAmount Token amount\n    /// @param i Index of token\n    function singleStableToUsd(uint256 inAmount, uint256 i) external view override returns (uint256) {\n        uint256[N_COINS] memory inAmounts;\n        inAmounts[i] = inAmount;\n        return _stableToUsd(inAmounts, true);\n    }\n\n    /// @notice Get LP token value of input amount of tokens\n    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToLp(tokenAmounts, deposit);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromUsd(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(_usdToLp(inAmount), i);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromLp(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(inAmount, i);\n    }\n\n    /// @notice Get USD price of LP tokens you receive for a specific input amount of tokens, slippage included\n    function lpToUsd(uint256 inAmount) external view override returns (uint256) {\n        return _lpToUsd(inAmount);\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function usdToLp(uint256 inAmount) external view override returns (uint256) {\n        return _usdToLp(inAmount);\n    }\n\n    /// @notice Split LP token amount to balance of pool tokens\n    /// @param inAmount Amount of LP tokens\n    /// @param totalBalance Total balance of pool\n    function poolBalances(uint256 inAmount, uint256 totalBalance)\n        internal\n        view\n        returns (uint256[N_COINS] memory balances)\n    {\n        uint256[N_COINS] memory _balances;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _balances[i] = (IERC20(getToken(i)).balanceOf(address(curvePool)).mul(inAmount)).div(totalBalance);\n        }\n        balances = _balances;\n    }\n\n    function getVirtualPrice() external view override returns (uint256) {\n        return curvePool.get_virtual_price();\n    }\n\n    // Internal functions\n    function _lpToUsd(uint256 inAmount) internal view returns (uint256) {\n        return inAmount.mul(curvePool.get_virtual_price()).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {\n        require(tokenAmounts.length == N_COINS, \"deposit: !length\");\n        uint256[N_COINS] memory _tokenAmounts;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _tokenAmounts[i] = tokenAmounts[i];\n        }\n        uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);\n        return _lpToUsd(lpAmount);\n    }\n\n    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {\n        require(tokenAmounts.length == N_COINS, \"deposit: !length\");\n        uint256[N_COINS] memory _tokenAmounts;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _tokenAmounts[i] = tokenAmounts[i];\n        }\n        return curvePool.calc_token_amount(_tokenAmounts, deposit);\n    }\n\n    function _singleStableFromLp(uint256 inAmount, int128 i) internal view returns (uint256) {\n        uint256 result = curvePool.calc_withdraw_one_coin(inAmount, i);\n        return result;\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function _usdToLp(uint256 inAmount) internal view returns (uint256) {\n        return inAmount.mul(DEFAULT_DECIMALS_FACTOR).div(curvePool.get_virtual_price());\n    }\n\n    /// @notice Calculate price ratios for stablecoins\n    ///     Get USD price data for stablecoin\n    /// @param i Stablecoin to get USD price for\n    function getPriceFeed(uint256 i) external view override returns (uint256 _price) {\n        _price = uint256(IChainlinkAggregator(getAggregator(i)).latestAnswer());\n    }\n\n    /// @notice Fetch chainlink token ratios\n    /// @param i Token in\n    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) {\n        uint256[3] memory _prices;\n        _prices[0] = uint256(IChainlinkAggregator(getAggregator(0)).latestAnswer());\n        _prices[1] = uint256(IChainlinkAggregator(getAggregator(1)).latestAnswer());\n        _prices[2] = uint256(IChainlinkAggregator(getAggregator(2)).latestAnswer());\n        for (uint256 j = 0; j < 3; j++) {\n            if (i == j) {\n                _ratios[i] = CHAINLINK_PRICE_DECIMAL_FACTOR;\n            } else {\n                _ratios[j] = _prices[i].mul(CHAINLINK_PRICE_DECIMAL_FACTOR).div(_prices[j]);\n            }\n        }\n        return _ratios;\n    }\n\n    function getAggregator(uint256 index) private view returns (address) {\n        if (index == 0) {\n            return daiUsdAgg;\n        } else if (index == 1) {\n            return usdcUsdAgg;\n        } else {\n            return usdtUsdAgg;\n        }\n    }\n\n    /// @notice Get absolute value\n    function abs(int256 x) private pure returns (uint256) {\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n\n    function _updateRatios(uint256 tolerance) private returns (bool) {\n        uint256[N_COINS] memory chainRatios = getTokenRatios(0);\n        uint256[N_COINS] memory newRatios;\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            uint256 check = abs(int256(_ratio) - int256(chainRatios[i].div(CHAIN_FACTOR)));\n            if (check.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > tolerance) {\n                return false;\n            } else {\n                newRatios[i] = _ratio;\n            }\n        }\n        for (uint256 i = 1; i < N_COINS; i++) {\n            lastRatio[i] = newRatios[i];\n        }\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "Buoy3Pool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Buoy3Pool.sol L207 and L214-L216",
                "Type": "Medium Severity",
                "Description": "Use of deprecated Chainlink function latestAnswer.",
                "Repair": "Use the latestRoundData function to get the price instead, add checks on the return data with proper revert messages if the price is stale or the round is incomplete"
            },
            {
                "Location": "Buoy3Pool",
                "Type": "Medium Severity",
                "Description": "Usage of deprecated ChainLink API in Buoy3Pool.",
                "Repair": "Add checks similar to latestTimestamp and latestRoundare, make calculateShare an abstract function that is implemented in the specific adaptors"
            },
            {
                "Location": "Buoy3Pool.safetyCheck",
                "Type": "High Severity",
                "Description": "safetyCheck function has several issues that impact how precise the checks are.",
                "Repair": "Check if b/c is within BASIS_POINTS"
            }
        ]
    }
]