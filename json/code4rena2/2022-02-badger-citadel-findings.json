[
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.11;\n\nimport \"ds-test/test.sol\";\nimport \"forge-std/Vm.sol\";\nimport \"forge-std/stdlib.sol\";\n\nimport \"./utils/StdERC20.sol\";\nimport \"./utils/StdProxy.sol\";\n\nimport \"openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/proxy/transparent/ProxyAdmin.sol\";\n\nimport \"../TokenSaleUpgradeable.sol\";\nimport \"../utils/MockERC20.sol\";\nimport \"../utils/VipGuestListUpgradeable.sol\";\n\ncontract CTDL is MockERC20 {\n    constructor() MockERC20(\"Citadel Token\", \"CTDL\", 9) {}\n}\n\ncontract TestToken is MockERC20 {\n    constructor() MockERC20(\"Test Token\", \"TEST\", 8) {}\n}\n\ncontract TokenSaleUpgradeableTest is DSTest, stdCheats, StdProxy {\n    /// ==============\n    /// ===== Vm =====\n    /// ==============\n\n    Vm constant vm = Vm(HEVM_ADDRESS);\n    using StdERC20 for ERC20;\n\n    /// =====================\n    /// ===== Constants =====\n    /// =====================\n\n    uint64 constant DURATION = 24 hours;\n\n    uint256 constant TOKEN_IN_PRICE_USD = 2;\n    uint256 constant TOKEN_OUT_PRICE_USD = 1;\n\n    uint256 constant TOKEN_IN_LIMIT_USD = 10;\n\n    address constant rando = address(uint160(uint256(keccak256(\"rando\"))));\n\n    /// =================\n    /// ===== State =====\n    /// =================\n\n    ERC20 immutable tokenIn = ERC20(address(new TestToken()));\n    ERC20 immutable tokenOut = ERC20(address(new CTDL()));\n\n    ProxyAdmin immutable proxyAdmin = new ProxyAdmin();\n\n    TokenSaleUpgradeable tokenSale;\n    VipGuestListUpgradeable guestlist;\n\n    address treasury = address(uint160(uint256(keccak256(\"treasury\"))));\n\n    uint256 price;\n    uint256 tokenInLimit;\n\n    /// ==================\n    /// ===== Set up =====\n    /// ==================\n\n    function setUp() public {\n        price =\n            (TOKEN_OUT_PRICE_USD * 10**tokenIn.decimals()) /\n            TOKEN_IN_PRICE_USD;\n\n        tokenInLimit =\n            (TOKEN_IN_LIMIT_USD * 10**tokenIn.decimals()) /\n            TOKEN_IN_PRICE_USD;\n\n        guestlist = VipGuestListUpgradeable(\n            deployProxy(\n                type(VipGuestListUpgradeable).creationCode,\n                address(proxyAdmin),\n                abi.encodeWithSelector(\n                    VipGuestListUpgradeable.initialize.selector\n                )\n            )\n        );\n\n        tokenSale = TokenSaleUpgradeable(\n            deployProxy(\n                type(TokenSaleUpgradeable).creationCode,\n                address(proxyAdmin),\n                abi.encodeWithSelector(\n                    TokenSaleUpgradeable.initialize.selector,\n                    address(tokenOut),\n                    address(tokenIn),\n                    uint64(block.timestamp),\n                    DURATION,\n                    price,\n                    treasury,\n                    address(guestlist),\n                    tokenInLimit\n                )\n            )\n        );\n\n        // Add this address to guestlist\n        guestlist.setGuestRoot(bytes32(uint256(1)));\n        address[] memory guests = new address[](1);\n        bool[] memory invited = new bool[](1);\n        guests[0] = address(this);\n        invited[0] = true;\n        guestlist.setGuests(guests, invited);\n    }\n\n    /// ======================\n    /// ===== Unit Tests =====\n    /// ======================\n\n    function testInitializeMultiple() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n\n        tokenSale.initialize(\n            address(tokenOut),\n            address(tokenIn),\n            uint64(block.timestamp),\n            DURATION,\n            price,\n            treasury,\n            address(0),\n            type(uint256).max\n        );\n    }\n\n    function testOwner() public {\n        assertEq(tokenSale.owner(), address(this));\n    }\n\n    function testTransferOwnership() public {\n        address owner = address(uint160(uint256(keccak256(\"owner\"))));\n        tokenSale.transferOwnership(owner);\n\n        assertEq(tokenSale.owner(), owner);\n    }\n\n    function testPause() public {\n        tokenSale.pause();\n\n        assertTrue(tokenSale.paused());\n    }\n\n    function testUnpause() public {\n        tokenSale.pause();\n        tokenSale.unpause();\n\n        assertTrue(!tokenSale.paused());\n    }\n\n    // TODO: Probably not the best way to test this\n    //       How to restrict _amountIn to a range?\n    function testAmountOut(uint128 _amountIn) public {\n        uint256 amountOut = tokenSale.getAmountOut(_amountIn);\n        uint256 expectedOut = getAmountOut(_amountIn);\n\n        assertEq(amountOut, expectedOut);\n    }\n\n    function testBuyFailsBeforeStart() public {\n        tokenSale.setSaleStart(uint64(block.timestamp + 60));\n\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        vm.expectRevert(\"TokenSale: not started\");\n        tokenSale.buy(amountIn, 0, new bytes32[](0));\n    }\n\n    function testBuyOnce() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        buyChecked(amountIn, 0, new bytes32[](0));\n    }\n\n    function testBuyTwice() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        uint256 expectedOut = getAmountOut(amountIn);\n\n        uint256 amountOut1 = buyChecked(amountIn / 2, 0, new bytes32[](0));\n        uint256 amountOut2 = buyChecked(amountIn / 2, 0, new bytes32[](0));\n\n        assertEq(amountOut1 + amountOut2, expectedOut);\n    }\n\n    function testBuyZero() public {\n        vm.expectRevert(\"_tokenInAmount should be > 0\");\n        tokenSale.buy(0, 0, new bytes32[](0));\n    }\n\n    function testBuyTwiceFailsForDifferentDaos() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        buyChecked(amountIn, 0, new bytes32[](0));\n\n        vm.expectRevert(\"can't vote for multiple daos\");\n        tokenSale.buy(amountIn, 1, new bytes32[](0));\n    }\n\n    function testBuyFailsWhenPaused() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        tokenSale.pause();\n\n        vm.expectRevert(\"Pausable: paused\");\n        tokenSale.buy(amountIn, 0, new bytes32[](0));\n    }\n\n    function testTokenInLimitLeft(uint256 _amountIn) public {\n        uint256 amountIn = _amountIn % tokenInLimit;\n\n        buyChecked(amountIn, 0, new bytes32[](0));\n\n        assertEq(tokenSale.getTokenInLimitLeft(), tokenInLimit - amountIn);\n    }\n\n    function testBuyFailsIfMoreThanLimit() public {\n        tokenIn.forceMint(tokenInLimit + 1);\n\n        vm.expectRevert(\"total amount exceeded\");\n        tokenSale.buy(tokenInLimit + 1, 0, new bytes32[](0));\n    }\n\n    function testBuyFailsIfLimitExceeded() public {\n        buyChecked(tokenInLimit, 0, new bytes32[](0));\n\n        tokenIn.forceMint(1);\n\n        vm.expectRevert(\"total amount exceeded\");\n        tokenSale.buy(1, 0, new bytes32[](0));\n    }\n\n    function testBuyFailsAfterEnd() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        skip(DURATION);\n\n        vm.expectRevert(\"TokenSale: already ended\");\n        tokenSale.buy(amountIn, 0, new bytes32[](0));\n    }\n\n    function testBuyFailsIfNotInGuestlist() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        vm.startPrank(rando);\n        vm.expectRevert(\"not authorized\");\n        tokenSale.buy(amountIn, 0, new bytes32[](0));\n    }\n\n    function testBuyWhenNoGuestlist() public {\n        tokenSale.setGuestlist(address(0));\n\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        buyCheckedFrom(rando, amountIn, 0, new bytes32[](0));\n    }\n\n    event GuestlistUpdated(address indexed guestlist);\n\n    function testGuestlistUpdate() public {\n        vm.expectEmit(true, false, false, false);\n        emit GuestlistUpdated(address(0));\n\n        tokenSale.setGuestlist(address(0));\n\n        assertEq(address(tokenSale.guestlist()), address(0));\n    }\n\n    function testBuyMultipleBuyers() public {\n        tokenSale.setGuestlist(address(0));\n\n        uint256 amountIn1 = 10**tokenIn.decimals();\n        uint256 amountIn2 = 2 * 10**tokenIn.decimals();\n\n        buyChecked(amountIn1, 0, new bytes32[](0));\n        buyCheckedFrom(rando, amountIn2, 0, new bytes32[](0));\n    }\n\n    function testFinalize() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        uint256 amountOut = buyChecked(amountIn, 0, new bytes32[](0));\n\n        skip(DURATION);\n\n        finalizeChecked(amountOut);\n    }\n\n    function testFinalizeFailsBeforeSaleEnds() public {\n        skip(DURATION - 1);\n\n        vm.expectRevert(\"TokenSale: not finished\");\n        tokenSale.finalize();\n    }\n\n    function testFinalizeFailsIfCalledAgain() public {\n        skip(DURATION);\n\n        finalizeChecked(0);\n\n        vm.expectRevert(\"TokenSale: already finalized\");\n        tokenSale.finalize();\n    }\n\n    function testFinalizeFailsIfNotEnoughTokenIn() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        buyChecked(amountIn, 0, new bytes32[](0));\n\n        skip(DURATION);\n\n        vm.expectRevert(\"TokenSale: not enough balance\");\n        tokenSale.finalize();\n    }\n\n    function testClaim() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        uint256 amountOut = buyChecked(amountIn, 0, new bytes32[](0));\n\n        skip(DURATION);\n\n        finalizeChecked(amountOut);\n\n        claimChecked(amountOut);\n    }\n\n    function testClaimMultipleBuyers() public {\n        tokenSale.setGuestlist(address(0));\n\n        uint256 amountIn1 = 10**tokenIn.decimals();\n        uint256 amountIn2 = 2 * 10**tokenIn.decimals();\n\n        uint256 amountOut1 = buyChecked(amountIn1, 0, new bytes32[](0));\n        uint256 amountOut2 = buyCheckedFrom(\n            rando,\n            amountIn2,\n            0,\n            new bytes32[](0)\n        );\n\n        skip(DURATION);\n\n        finalizeChecked(amountOut1 + amountOut2);\n\n        claimChecked(amountOut1);\n        claimCheckedFrom(rando, amountOut2);\n    }\n\n    function testClaimAfterMultipleBuys() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        // TODO: Do I need this?\n        uint256 expectedOut = getAmountOut(amountIn);\n\n        uint256 amountOut1 = buyChecked(amountIn / 2, 0, new bytes32[](0));\n        uint256 amountOut2 = buyChecked(amountIn / 2, 0, new bytes32[](0));\n\n        skip(DURATION);\n\n        finalizeChecked(expectedOut);\n\n        claimChecked(amountOut1 + amountOut2);\n    }\n\n    function testClaimFailsWhenPaused() public {\n        tokenSale.pause();\n\n        vm.expectRevert(\"Pausable: paused\");\n        tokenSale.claim();\n    }\n\n    function testClaimFailsBeforeFinalize() public {\n        vm.expectRevert(\"sale not finalized\");\n        tokenSale.claim();\n    }\n\n    function testClaimFailsWhenNothingToClaim() public {\n        skip(DURATION);\n\n        finalizeChecked(0);\n\n        vm.startPrank(rando);\n        vm.expectRevert(\"nothing to claim\");\n        tokenSale.claim();\n    }\n\n    function testClaimFailsIfCalledAgain() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        uint256 amountOut = buyChecked(amountIn, 0, new bytes32[](0));\n\n        skip(DURATION);\n\n        finalizeChecked(amountOut);\n\n        claimChecked(amountOut);\n\n        vm.expectRevert(\"already claimed\");\n        tokenSale.claim();\n    }\n\n    // TODO: Maybe move to separate functions\n    function testPermissions() public {\n        vm.startPrank(rando);\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.transferOwnership(rando);\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.finalize();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.setSaleStart(uint64(block.timestamp + 10));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.setSaleDuration(1);\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.setTokenOutPrice(1);\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.setSaleRecipient(rando);\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.setGuestlist(address(0));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.setTokenInLimit(1);\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.sweep(address(tokenIn));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.pause();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        tokenSale.unpause();\n    }\n\n    function testSaleEndedAfterDuration() public {\n        assertTrue(!tokenSale.saleEnded());\n\n        skip(DURATION);\n\n        assertTrue(tokenSale.saleEnded());\n    }\n\n    function testSaleEndedAfterLimit() public {\n        buyChecked(tokenInLimit, 0, new bytes32[](0));\n\n        assertTrue(tokenSale.saleEnded());\n    }\n\n    event SaleStartUpdated(uint64 saleStart);\n\n    function testSetSaleStart() public {\n        uint64 saleStart = uint64(block.timestamp + 10);\n\n        vm.expectEmit(false, false, false, true);\n        emit SaleStartUpdated(saleStart);\n\n        tokenSale.setSaleStart(saleStart);\n\n        assertEq(tokenSale.saleStart(), saleStart);\n    }\n\n    event SaleDurationUpdated(uint64 saleDuration);\n\n    function testSetSaleDuration() public {\n        uint64 saleDuration = 2 hours;\n\n        vm.expectEmit(false, false, false, true);\n        emit SaleDurationUpdated(saleDuration);\n\n        tokenSale.setSaleDuration(saleDuration);\n\n        assertEq(tokenSale.saleDuration(), saleDuration);\n    }\n\n    function testExtendSaleDuration() public {\n        skip(DURATION);\n        assertTrue(tokenSale.saleEnded());\n\n        uint64 saleDuration = 2 * DURATION;\n\n        tokenSale.setSaleDuration(saleDuration);\n\n        assertTrue(!tokenSale.saleEnded());\n\n        skip(2 * DURATION);\n\n        assertTrue(tokenSale.saleEnded());\n    }\n\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n\n    function testSetTokenOutPrice() public {\n        vm.expectEmit(false, false, false, true);\n        emit TokenOutPriceUpdated(2 * price);\n\n        tokenSale.setTokenOutPrice(2 * price);\n\n        assertEq(tokenSale.tokenOutPrice(), 2 * price);\n    }\n\n    event SaleRecipientUpdated(address indexed recipient);\n\n    function testSetSaleRecipient() public {\n        vm.expectEmit(true, false, false, false);\n        emit SaleRecipientUpdated(rando);\n\n        tokenSale.setSaleRecipient(rando);\n\n        assertEq(tokenSale.saleRecipient(), rando);\n    }\n\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    function testSetTokenInLimit() public {\n        uint256 newTokenInLimit = 100 * 10**tokenIn.decimals();\n\n        vm.expectEmit(false, false, false, true);\n        emit TokenInLimitUpdated(newTokenInLimit);\n\n        tokenSale.setTokenInLimit(newTokenInLimit);\n\n        assertEq(newTokenInLimit, tokenSale.tokenInLimit());\n    }\n\n    event Sweeped(address indexed token, uint256 amount);\n\n    function testSweepExceptTokenOut() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n        tokenIn.forceMint(amountIn);\n\n        tokenIn.transfer(address(tokenSale), amountIn);\n\n        assertEq(tokenIn.balanceOf(address(this)), 0);\n\n        vm.expectEmit(true, false, false, true);\n        emit Sweeped(address(tokenIn), amountIn);\n\n        tokenSale.sweep(address(tokenIn));\n\n        assertEq(tokenIn.balanceOf(address(this)), amountIn);\n    }\n\n    function testSweepTokenOut() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        uint256 amountOut = buyChecked(amountIn, 0, new bytes32[](0));\n\n        skip(DURATION);\n\n        uint256 extraMint = 2 * 10**tokenIn.decimals();\n        tokenOut.forceMintTo(address(tokenSale), amountOut + extraMint);\n\n        tokenSale.sweep(address(tokenOut));\n\n        assertEq(tokenOut.balanceOf(address(tokenSale)), amountOut);\n        assertEq(tokenOut.balanceOf(address(this)), extraMint);\n    }\n\n    /// ===========================\n    /// ===== Lifecycle Tests =====\n    /// ===========================\n\n    function testBuyAfterTokenInLimitUpdated() public {\n        buyChecked(tokenInLimit, 0, new bytes32[](0));\n\n        assertEq(tokenSale.getTokenInLimitLeft(), 0);\n\n        uint256 newTokenInLimit = 100 * 10**tokenIn.decimals();\n        tokenSale.setTokenInLimit(newTokenInLimit);\n\n        assertEq(\n            tokenSale.getTokenInLimitLeft(),\n            newTokenInLimit - tokenInLimit\n        );\n\n        buyChecked(1, 0, new bytes32[](0));\n    }\n\n    function testTokenOutPriceDoubledDuringSale() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        uint256 amountOut1 = buyChecked(amountIn / 2, 0, new bytes32[](0));\n\n        setTokenOutPrice(2 * price);\n\n        uint256 amountOut2 = buyChecked(amountIn / 2, 0, new bytes32[](0));\n\n        assertEq(amountOut1, 2 * amountOut2);\n    }\n\n    function testSaleRecipientChangedDuringSale() public {\n        uint256 amountIn = 10**tokenIn.decimals();\n\n        buyChecked(amountIn / 2, 0, new bytes32[](0));\n\n        setSaleRecipient(rando);\n\n        buyChecked(amountIn / 2, 0, new bytes32[](0));\n    }\n\n    /// ============================\n    /// ===== Internal helpers =====\n    /// ============================\n\n    function getAmountOut(uint256 _amountIn)\n        internal\n        returns (uint256 amountOut_)\n    {\n        amountOut_ = (_amountIn * 10**tokenOut.decimals()) / price;\n    }\n\n    function setTokenOutPrice(uint256 _price) internal {\n        price = _price;\n        tokenSale.setTokenOutPrice(_price);\n    }\n\n    function setSaleRecipient(address _saleRecipient) internal {\n        treasury = _saleRecipient;\n        tokenSale.setSaleRecipient(_saleRecipient);\n    }\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    function buyCheckedFrom(\n        address _from,\n        uint256 _amountIn,\n        uint8 _daoId,\n        bytes32[] memory _proof\n    ) internal returns (uint256 amountOut_) {\n        // Get tokenIn\n        tokenIn.forceMintTo(_from, _amountIn);\n\n        // Approve\n        vm.startPrank(_from);\n        tokenIn.approve(address(tokenSale), _amountIn);\n\n        // State before\n        uint256 beforeFromBalance = tokenIn.balanceOf(_from);\n        uint256 beforeRecipientBalance = tokenIn.balanceOf(treasury);\n\n        uint256 beforeBoughtAmounts = tokenSale.boughtAmounts(_from);\n        uint256 beforeDaoCommitments = tokenSale.daoCommitments(_daoId);\n        uint256 beforeTotalTokenIn = tokenSale.totalTokenIn();\n        uint256 beforeTotalTokenOutBought = tokenSale.totalTokenOutBought();\n\n        // Expected output\n        uint256 expectedOut = getAmountOut(_amountIn);\n\n        vm.expectEmit(true, true, false, true);\n        emit Sale(_from, 0, _amountIn, expectedOut);\n\n        amountOut_ = tokenSale.buy(_amountIn, _daoId, _proof);\n\n        assertEq(amountOut_, expectedOut);\n\n        assertEq(tokenIn.balanceOf(_from), beforeFromBalance - _amountIn);\n        assertEq(\n            tokenIn.balanceOf(treasury),\n            beforeRecipientBalance + _amountIn\n        );\n\n        assertEq(\n            tokenSale.boughtAmounts(_from),\n            beforeBoughtAmounts + amountOut_\n        );\n        assertEq(\n            tokenSale.daoCommitments(_daoId),\n            beforeDaoCommitments + amountOut_\n        );\n        assertEq(tokenSale.totalTokenIn(), beforeTotalTokenIn + _amountIn);\n        assertEq(\n            tokenSale.totalTokenOutBought(),\n            beforeTotalTokenOutBought + amountOut_\n        );\n\n        assertEq(tokenSale.daoVotedFor(_from), _daoId);\n\n        vm.stopPrank();\n    }\n\n    function buyChecked(\n        uint256 _amountIn,\n        uint8 _daoId,\n        bytes32[] memory _proof\n    ) internal returns (uint256 amountOut_) {\n        amountOut_ = buyCheckedFrom(address(this), _amountIn, _daoId, _proof);\n    }\n\n    event Finalized();\n\n    function finalizeChecked(uint256 _expectedOut) internal {\n        tokenOut.forceMintTo(address(tokenSale), _expectedOut);\n\n        vm.expectEmit(false, false, false, false);\n        emit Finalized();\n\n        tokenSale.finalize();\n\n        assertTrue(tokenSale.finalized());\n    }\n\n    event Claim(address indexed claimer, uint256 amount);\n\n    function claimCheckedFrom(address _from, uint256 _expectedOut)\n        internal\n        returns (uint256 amountOut_)\n    {\n        // State before\n        uint256 beforeFromBalance = tokenOut.balanceOf(_from);\n        uint256 beforeTokenSaleBalance = tokenOut.balanceOf(address(tokenSale));\n        uint256 beforeTokenOutClaimed = tokenSale.totalTokenOutClaimed();\n\n        vm.prank(_from);\n        vm.expectEmit(true, false, false, true);\n\n        emit Claim(_from, _expectedOut);\n\n        amountOut_ = tokenSale.claim();\n\n        assertEq(amountOut_, _expectedOut);\n\n        assertTrue(tokenSale.hasClaimed(_from));\n        assertEq(\n            tokenSale.totalTokenOutClaimed(),\n            beforeTokenOutClaimed + amountOut_\n        );\n\n        assertEq(tokenOut.balanceOf(_from), beforeFromBalance + amountOut_);\n        assertEq(\n            tokenOut.balanceOf(address(tokenSale)),\n            beforeTokenSaleBalance - amountOut_\n        );\n    }\n\n    function claimChecked(uint256 _expectedOut)\n        internal\n        returns (uint256 amountOut_)\n    {\n        amountOut_ = claimCheckedFrom(address(this), _expectedOut);\n    }\n}\n\n// TODO:\n// - See if there's a way to avoid event duplication\n// - Replace abi.encodeWithSelector with abi.encodeCall(..) when Contract.initialize is implemented in 0.8.12\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/BadgerGuestlistApi.sol\";\n\n/**\n * @notice Sells a token at a predetermined price to whitelisted buyers.\n * TODO: Better revert strings\n */\ncontract TokenSaleUpgradeable is OwnableUpgradeable, PausableUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint64 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint64 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    /// Whitelist\n    BadgerGuestListAPI public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint64 saleStart);\n    event SaleDurationUpdated(uint64 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweeped(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenIn per tokenOut price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _tokenOut,\n        address _tokenIn,\n        uint64 _saleStart,\n        uint64 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"TokenSale: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"TokenSale: the sale duration must not be zero\"\n        );\n        require(_tokenOutPrice > 0, \"TokenSale: the price must not be zero\");\n        require(\n            _saleRecipient != address(0),\n            \"TokenSale: sale recipient should not be zero\"\n        );\n\n        __Ownable_init();\n        __Pausable_init();\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = BadgerGuestListAPI(_guestlist);\n        tokenInLimit = _tokenInLimit;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external whenNotPaused returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"TokenSale: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"TokenSale: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] += tokenOutAmount_;\n\n        totalTokenIn += _tokenInAmount;\n        totalTokenOutBought += tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external whenNotPaused returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed += tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * 10**tokenOut.decimals()) /\n            tokenOutPrice;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ===============================\n    /// ===== Permissioned: owner =====\n    /// ===============================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyOwner {\n        require(!finalized, \"TokenSale: already finalized\");\n        require(saleEnded(), \"TokenSale: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"TokenSale: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint64 _saleStart) external onlyOwner {\n        require(\n            _saleStart >= block.timestamp,\n            \"TokenSale: start date may not be in the past\"\n        );\n        require(!finalized, \"TokenSale: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint64 _saleDuration) external onlyOwner {\n        require(\n            _saleDuration > 0,\n            \"TokenSale: the sale duration must not be zero\"\n        );\n        require(!finalized, \"TokenSale: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice) external onlyOwner {\n        require(_tokenOutPrice > 0, \"TokenSale: the price must not be zero\");\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient) external onlyOwner {\n        require(\n            _saleRecipient != address(0),\n            \"TokenSale: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist) external onlyOwner {\n        guestlist = BadgerGuestListAPI(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit) external onlyOwner {\n        require(!finalized, \"TokenSale: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external onlyOwner {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount -= amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        ERC20Upgradeable(_token).safeTransfer(msg.sender, amount);\n\n        emit Sweeped(_token, amount);\n    }\n\n    /**\n     * @notice Pause the sale. Can only be called by owner\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the sale. Can only be called by owner\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n\n\n",
        "CodeNames": [
            "TokenSaleUpgradeable.t.sol",
            "TokenSaleUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TokenSaleUpgradeable.sol",
                "Type": "Rug Vectors",
                "Description": "The Owner and Proxy Admin can make users lose funds by rug vectors.",
                "Repair": "Use OpenZeppelin's crowdsale contract, enforce that the contract is funded with enough CTDL tokens before the sale starts, remove the onlyOwner modifier on the finalize() function, reduce the extent to which the owner can change the sale conditions during the sale, leave the tokens of the buyer in the contract and implement an emergencyWithdraw function, allow the owner to call sweep only after the sale is finalized, do not allow to change the token price during the token sale, do not deploy the contract as a proxy at all"
            },
            {
                "Location": "TokenSaleUpgradeable.sol",
                "Type": "Admin Privilege",
                "Description": "saleRecipient can rug buyers by not transferring tokenOut and finalizing the sale.",
                "Repair": "Transfer the tokenIn into the contract, require a sufficient amount of tokenOut to be transferred into the contract first before the amount of tokenIn can be released to the saleRecipient"
            },
            {
                "Location": "TokenSaleUpgradeable.sol",
                "Type": "Admin Privilege",
                "Description": "Changing a token buy price during the sale by front-running buyers by forcing them to purchase at an unfair token price.",
                "Repair": "Do not let changing sale price after the sale has started, do not let changing sale start if the sale has already started"
            }
        ]
    }
]