[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Multiple locations in the contract",
                "Type": "Rug Vectors",
                "Description": "The owner and proxy admin can make users lose funds through various means such as inactivity, griefing attacks, and rug pulls.",
                "Repair": "Use OpenZeppelin's crowdsale contract, enforce that the contract is funded with enough CTDL tokens before the sale starts, remove the onlyOwner modifier on the finalize() function, reduce the extent to which the owner can change the sale conditions during the sale, leave the tokens of the buyer in the contract and implement an emergencyWithdraw function, allow the owner to call sweep only after the sale is finalized, do not allow to change the token price during the token sale, do not deploy the contract as a proxy at all"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/BadgerGuestlistApi.sol\";\n\n/**\n * @notice Sells a token at a predetermined price to whitelisted buyers.\n * TODO: Better revert strings\n */\ncontract TokenSaleUpgradeable is OwnableUpgradeable, PausableUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint64 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint64 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    /// Whitelist\n    BadgerGuestListAPI public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint64 saleStart);\n    event SaleDurationUpdated(uint64 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweeped(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenIn per tokenOut price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _tokenOut,\n        address _tokenIn,\n        uint64 _saleStart,\n        uint64 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"TokenSale: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"TokenSale: the sale duration must not be zero\"\n        );\n        require(_tokenOutPrice > 0, \"TokenSale: the price must not be zero\");\n        require(\n            _saleRecipient != address(0),\n            \"TokenSale: sale recipient should not be zero\"\n        );\n\n        __Ownable_init();\n        __Pausable_init();\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = BadgerGuestListAPI(_guestlist);\n        tokenInLimit = _tokenInLimit;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external whenNotPaused returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"TokenSale: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"TokenSale: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] += tokenOutAmount_;\n\n        totalTokenIn += _tokenInAmount;\n        totalTokenOutBought += tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external whenNotPaused returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed += tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * 10**tokenOut.decimals()) /\n            tokenOutPrice;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ===============================\n    /// ===== Permissioned: owner =====\n    /// ===============================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyOwner {\n        require(!finalized, \"TokenSale: already finalized\");\n        require(saleEnded(), \"TokenSale: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"TokenSale: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint64 _saleStart) external onlyOwner {\n        require(\n            _saleStart >= block.timestamp,\n            \"TokenSale: start date may not be in the past\"\n        );\n        require(!finalized, \"TokenSale: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint64 _saleDuration) external onlyOwner {\n        require(\n            _saleDuration > 0,\n            \"TokenSale: the sale duration must not be zero\"\n        );\n        require(!finalized, \"TokenSale: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice) external onlyOwner {\n        require(_tokenOutPrice > 0, \"TokenSale: the price must not be zero\");\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient) external onlyOwner {\n        require(\n            _saleRecipient != address(0),\n            \"TokenSale: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist) external onlyOwner {\n        guestlist = BadgerGuestListAPI(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit) external onlyOwner {\n        require(!finalized, \"TokenSale: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external onlyOwner {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount -= amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        ERC20Upgradeable(_token).safeTransfer(msg.sender, amount);\n\n        emit Sweeped(_token, amount);\n    }\n\n    /**\n     * @notice Pause the sale. Can only be called by owner\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the sale. Can only be called by owner\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n\n\n",
        "CodeNames": [
            "TokenSaleUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TokenSaleUpgradeable.sol#buy()",
                "Type": "Funds transferred to saleRecipient before settlement",
                "Description": "The saleRecipient can rug buyers by not transferring tokenOut and finalizing the sale, causing users to lose all their funds.",
                "Repair": "Transfer tokenIn into the contract instead of directly to the saleRecipient, require a sufficient amount of tokenOut to be transferred into the contract first before the amount of tokenIn can be released to the saleRecipient"
            },
            {
                "Location": "TokenSaleUpgradeable.sol#buy()",
                "Type": "Changing a token buy price during the sale by front-running buyers by forcing them to purchase at an unfair token price",
                "Description": "An owner can front-run a buy transaction and change the price to a very high value, causing the bought tokens to be close to zero and consuming the tokens to the owner-selected address saleRecipient.",
                "Repair": "Do not let changing sale price after the sale has started, do not let changing sale start if the sale has already started"
            }
        ]
    }
]