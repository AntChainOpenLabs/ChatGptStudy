[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n    using CastI128U128 for int128;\n\n    event AuctionIntervalSet(uint32 indexed auctionInterval);\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n    uint32                                                      public auctionInterval;// Time that vaults in liquidation are protected from being grabbed by a different engine.\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n    mapping (bytes12 => uint32)                                 public auctions;        // If grater than zero, time that a vault was timestamped. Used for liquidation.\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine\n    function setAuctionInterval(uint32 auctionInterval_)\n        external\n        auth\n    {\n        auctionInterval = auctionInterval_;\n        emit AuctionIntervalSet(auctionInterval_);\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete auctions[vaultId];\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give a non-timestamped vault to another user, and timestamp it.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        uint32 now_ = uint32(block.timestamp);\n        require (auctions[vaultId] + auctionInterval <= now_, \"Vault under auction\");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\n\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n\n        auctions[vaultId] = now_;\n        _give(vaultId, receiver);\n\n        emit VaultLocked(vaultId, now_);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) public returns (int256) {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        public\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n    \n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        public\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n",
        "CodeNames": [
            "Cauldron.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "build() function in Cauldron.sol",
                "Type": "DoS",
                "Description": "An attacker can front-run a valid batch transaction in the mempool by constructing a malicious batch transaction with only the build operation with the same vaultID, causing the valid batch transaction to fail and preventing users from opening a vault and interacting with the protocol.",
                "Repair": "Assign the vaultID by Cauldron instead of user specifying it in the build() operation or add validation logic in Ladle's batching to revert batches that have only build or a subset of the operations that do not make sense to the protocol's operations per valid recipes"
            },
            {
                "Location": "Cauldron",
                "Type": "Uninitialized or Incorrectly set",
                "Description": "The grab() function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized.",
                "Repair": "Initialize auctionInterval  at declaration with a reasonable default value and add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value"
            },
            {
                "Location": "stir function of the Cauldron contract",
                "Type": "Duplication of Balance",
                "Description": "It is possible to duplicate currently held ink or art within a Cauldron, thereby breaking the contract's accounting system and minting units out of thin air.",
                "Repair": "Imposing a require check prohibiting the from and to variables to be equivalent"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./utils/access/AccessControl.sol\";\nimport \"./interfaces/vault/ILadle.sol\";\nimport \"./interfaces/vault/ICauldron.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/WDivUp.sol\";\nimport \"./math/CastU256U128.sol\";\n\n\ncontract Witch is AccessControl() {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using WDivUp for uint256;\n    using CastU256U128 for uint256;\n\n    event AuctionTimeSet(uint128 indexed auctionTime);\n    event InitialProportionSet(uint128 indexed initialProportion);\n    event Bought(bytes12 indexed vaultId, address indexed buyer, uint256 ink, uint256 art);\n  \n    uint128 public auctionTime = 4 * 60 * 60; // Time that auctions take to go to minimal price and stay there.\n    uint128 public initialProportion = 5e17;  // Proportion of collateral that is sold at auction start.\n\n    ICauldron immutable public cauldron;\n    ILadle immutable public ladle;\n    mapping(bytes12 => address) public vaultOwners;\n\n    constructor (ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    /// @dev Set the auction time to calculate liquidation prices\n    function setAuctionTime(uint128 auctionTime_) public auth {\n        auctionTime = auctionTime_;\n        emit AuctionTimeSet(auctionTime_);\n    }\n\n    /// @dev Set the proportion of the collateral that will be sold at auction start\n    function setInitialProportion(uint128 initialProportion_) public auth {\n        require (initialProportion_ <= 1e18, \"Only at or under 100%\");\n        initialProportion = initialProportion_;\n        emit InitialProportionSet(initialProportion_);\n    }\n\n    /// @dev Put an undercollateralized vault up for liquidation.\n    function grab(bytes12 vaultId) public {\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n        vaultOwners[vaultId] = vault.owner;\n        cauldron.grab(vaultId, address(this));\n    }\n\n    /// @dev Buy an amount of collateral off a vault in liquidation, paying at most `max` underlying.\n    function buy(bytes12 vaultId, uint128 art, uint128 min) public {\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n\n        require (balances_.art > 0, \"Nothing to buy\");                                      // Cheapest way of failing gracefully if given a non existing vault\n        uint256 elapsed = uint32(block.timestamp) - cauldron.auctions(vaultId);           // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.\n        uint256 price;\n        {\n            // Price of a collateral unit, in underlying, at the present moment, for a given vault\n            //\n            //                ink                     min(auction, elapsed)\n            // price = 1 / (------- * (p + (1 - p) * -----------------------))\n            //                art                          auction\n            (uint256 auctionTime_, uint256 initialProportion_) = (auctionTime, initialProportion);\n            uint256 term1 = uint256(balances_.ink).wdiv(balances_.art);\n            uint256 dividend2 = auctionTime_ < elapsed ? auctionTime_ : elapsed;\n            uint256 divisor2 = auctionTime_;\n            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2));\n            price = uint256(1e18).wdiv(term1.wmul(term2));\n        }\n        uint256 ink = uint256(art).wdivup(price);                                                    // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n        require (ink >= min, \"Not enough bought\");\n\n        ladle.settle(vaultId, msg.sender, ink.u128(), art);                                        // Move the assets\n        if (balances_.art - art == 0) {                                                             // If there is no debt left, return the vault with the collateral to the owner\n            cauldron.give(vaultId, vaultOwners[vaultId]);\n            delete vaultOwners[vaultId];\n        }\n\n        emit Bought(vaultId, msg.sender, ink, art);\n    }\n}\n\n",
        "CodeNames": [
            "Witch.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "buy function in Witch.sol",
                "Type": "Interest Avoidance",
                "Description": "A user can avoid paying borrowing interest after the fyToken matures by giving their vault to Witch and buying all their collateral using underlying tokens, which is sold at a price of balances_.art/balances_.ink and does not include borrowing fees.",
                "Repair": "Disallow users to give vaults to Witch or require vaultOwners[vaultId] and cauldron.auctions(vaultId) to be non-zero at the beginning of function buy"
            },
            {
                "Location": "grab function in Witch.sol",
                "Type": "Ownership",
                "Description": "After the second grab, the information of the original owner of the vault is lost, and the vault can't be returned to the original owner once the debt has been sold. The grab function stores the previous owner in vaultOwners[vaultId], and then the contract itself is the new owner, overwriting vaultOwners[vaultId] at the second grab.",
                "Repair": "Store the original owner in Cauldron.auctions along with the time at which the auction was started or remove the feature of allowing multiple competing liquidation engines and move the auctions mapping to the Witch"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >= 0.8.0;\n\nimport \"./interfaces/vault/IJoinFactory.sol\";\nimport \"./Join.sol\";\n\n\n/// @dev The JoinFactory can deterministically create new join instances.\ncontract JoinFactory is IJoinFactory {\n  /// Pre-hashing the bytecode allows calculateJoinAddress to be cheaper, and\n  /// makes client-side address calculation easier\n  bytes32 public constant override JOIN_BYTECODE_HASH = keccak256(type(Join).creationCode);\n\n  address private _nextAsset;\n\n  /// @dev Returns true if `account` is a contract.\n  function isContract(address account) internal view returns (bool) {\n      // This method relies on extcodesize, which returns 0 for contracts in\n      // construction, since the code is only stored at the end of the\n      // constructor execution.\n\n      uint256 size;\n      // solhint-disable-next-line no-inline-assembly\n      assembly { size := extcodesize(account) }\n      return size > 0;\n  }\n\n  /// @dev Calculate the deterministic addreess of a join, based on the asset token.\n  /// @param asset Address of the asset token.\n  /// @return The calculated join address.\n  function calculateJoinAddress(address asset) external view override returns (address) {\n    return _calculateJoinAddress(asset);\n  }\n\n  /// @dev Create2 calculation\n  function _calculateJoinAddress(address asset)\n    private view returns (address calculatedAddress)\n  {\n    calculatedAddress = address(uint160(uint256(keccak256(abi.encodePacked(\n      bytes1(0xff),\n      address(this),\n      keccak256(abi.encodePacked(asset)),\n      JOIN_BYTECODE_HASH\n    )))));\n  }\n\n  /// @dev Calculate the address of a join, and return address(0) if not deployed.\n  /// @param asset Address of the asset token.\n  /// @return join The deployed join address.\n  function getJoin(address asset) external view override returns (address join) {\n    join = _calculateJoinAddress(asset);\n\n    if(!isContract(join)) {\n      join = address(0);\n    }\n  }\n\n  /// @dev Deploys a new join.\n  /// The asset address is written to a temporary storage slot to allow for simpler\n  /// address calculation, while still allowing the Join contract to store the values as\n  /// immutable.\n  /// @param asset Address of the asset token.\n  /// @return join The join address.\n  function createJoin(address asset) external override returns (address) {\n    _nextAsset = asset;\n    Join join = new Join{salt: keccak256(abi.encodePacked(asset))}();\n    _nextAsset = address(0);\n\n    join.grantRole(join.ROOT(), msg.sender);\n    join.renounceRole(join.ROOT(), address(this));\n    \n    emit JoinCreated(asset, address(join));\n\n    return address(join);\n  }\n\n  /// @dev Only used by the Join constructor.\n  /// @return The address token for the currently-constructing join.\n  function nextAsset() external view override returns (address) {\n    return _nextAsset;\n  }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/ICauldronGov.sol\";\nimport \"./interfaces/vault/ILadleGov.sol\";\nimport \"./interfaces/vault/IMultiOracleGov.sol\";\nimport \"./interfaces/vault/IJoinFactory.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./interfaces/yieldspace/IPoolFactory.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./FYToken.sol\";\n\n\ninterface IOwnable {\n    function transferOwnership(address) external;\n}\n\n/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient governance features.\ncontract Wand is AccessControl {\n\n    bytes4 public constant JOIN = bytes4(keccak256(\"join(address,uint128)\"));\n    bytes4 public constant EXIT = bytes4(keccak256(\"exit(address,uint128)\"));\n    bytes4 public constant MINT = bytes4(keccak256(\"mint(address,uint256)\"));\n    bytes4 public constant BURN = bytes4(keccak256(\"burn(address,uint256)\"));\n    \n    bytes6 public constant CHI = \"chi\";\n    bytes6 public constant RATE = \"rate\";\n\n    ICauldronGov public immutable cauldron;\n    ILadleGov public immutable ladle;\n    IPoolFactory public immutable poolFactory;\n    IJoinFactory public immutable joinFactory;\n\n    constructor (ICauldronGov cauldron_, ILadleGov ladle_, IPoolFactory poolFactory_, IJoinFactory joinFactory_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n        poolFactory = poolFactory_;\n        joinFactory = joinFactory_;\n    }\n\n    /// @dev Add an existing asset to the protocol, meaning:\n    ///  - Add the asset to the cauldron\n    ///  - Deploy a new Join, and integrate it with the Ladle\n    ///  - If the asset is a base, integrate its rate source\n    ///  - If the asset is a base, integrate a spot source and set a debt ceiling for any provided ilks\n    function addAsset(\n        bytes6 assetId,\n        address asset\n    ) public auth {\n        // Add asset to cauldron, deploy new Join, and add it to the ladle\n        require (address(asset) != address(0), \"Asset required\");\n        cauldron.addAsset(assetId, asset);\n        AccessControl join = AccessControl(joinFactory.createJoin(asset));  // We need the access control methods of Join\n        bytes4[] memory sigs = new bytes4[](2);\n        sigs[0] = JOIN;\n        sigs[1] = EXIT;\n        join.grantRoles(sigs, address(ladle));\n        join.grantRole(join.ROOT(), msg.sender);\n        // join.renounceRole(join.ROOT(), address(this));  // If Wand gives up ownership it can't create fyToken\n        ladle.addJoin(assetId, address(join));\n    }\n\n    /// @dev Make a base asset out of a generic asset, by adding rate and chi oracles.\n    /// This assumes CompoundMultiOracles, which deliver both rate and chi.\n    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) public auth {\n        require (address(oracle) != address(0), \"Oracle required\");\n        require (rateSource != address(0), \"Rate source required\");\n        require (chiSource != address(0), \"Chi source required\");\n\n        oracle.setSource(assetId, RATE, rateSource);\n        oracle.setSource(assetId, CHI, chiSource);\n        cauldron.setRateOracle(assetId, IOracle(address(oracle))); // TODO: Consider adding a registry of chi oracles in cauldron as well\n    }\n\n    /// @dev Make an ilk asset out of a generic asset, by adding a spot oracle against a base asset, collateralization ratio, and debt ceiling.\n    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) public auth {\n        oracle.setSource(baseId, ilkId, spotSource);\n        cauldron.setSpotOracle(baseId, ilkId, IOracle(address(oracle)), ratio);\n        cauldron.setDebtLimits(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Add an existing series to the protocol, by deploying a FYToken, and registering it in the cauldron with the approved ilks\n    /// This must be followed by a call to addPool\n    function addSeries(\n        bytes6 seriesId,\n        bytes6 baseId,\n        uint32 maturity,\n        bytes6[] memory ilkIds,\n        string memory name,\n        string memory symbol\n    ) public auth {\n        address base = cauldron.assets(baseId);\n        require(base != address(0), \"Base not found\");\n\n        IJoin baseJoin = ladle.joins(baseId);\n        require(address(baseJoin) != address(0), \"Join not found\");\n\n        IOracle oracle = cauldron.rateOracles(baseId);\n        require(address(oracle) != address(0), \"Chi oracle not found\");\n\n        FYToken fyToken = new FYToken(\n            baseId,\n            oracle,\n            baseJoin,\n            maturity,\n            name,     // Derive from base and maturity, perhaps\n            symbol    // Derive from base and maturity, perhaps\n        ); // TODO: Use a FYTokenFactory to make Wand deployable at 20000 runs\n\n        // Allow the fyToken to pull from the base join for redemption\n        bytes4[] memory sigs = new bytes4[](1);\n        sigs[0] = EXIT;\n        AccessControl(address(baseJoin)).grantRoles(sigs, address(fyToken));\n\n        // Allow the ladle to issue and cancel fyToken\n        sigs = new bytes4[](2);\n        sigs[0] = MINT;\n        sigs[1] = BURN;\n        fyToken.grantRoles(sigs, address(ladle));\n\n        // Pass ownership of the fyToken to msg.sender\n        fyToken.grantRole(fyToken.ROOT(), msg.sender);\n        fyToken.renounceRole(fyToken.ROOT(), address(this));\n\n        // Add fyToken/series to the Cauldron and approve ilks for the series\n        cauldron.addSeries(seriesId, baseId, fyToken);\n        cauldron.addIlks(seriesId, ilkIds);\n\n        // Create the pool for the base and fyToken\n        poolFactory.createPool(base, address(fyToken));\n        IOwnable pool = IOwnable(poolFactory.calculatePoolAddress(base, address(fyToken)));\n        \n\n        // Pass ownership of pool to msg.sender\n        pool.transferOwnership(msg.sender);\n\n        // Register pool in Ladle\n        ladle.addPool(seriesId, address(pool));\n    }\n}\n\n",
        "CodeNames": [
            "JoinFactory.sol",
            "Wand.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "createJoin function in JoinFactory.sol and Wand.sol",
                "Type": "DoS",
                "Description": "An attacker can create fake Joins corresponding to specific tokens beforehand to make Wand unable to deploy the actual Join, causing a DoS attack. The attacker can also perform DoS attacks on newly added assets by front-running transactions calling the function addAsset of Wand and creating the corresponding Join to make the benign transaction fail.",
                "Repair": "Deploy Joins using CREATE instead of CREATE2 or add access control in createJoin and allow only Wand to call it"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >= 0.8.0;\n\nimport \"./Math64x64.sol\";\n\nlibrary Exp64x64 {\n  /**\n   * Raise given number x into power specified as a simple fraction y/z and then\n   * multiply the result by the normalization factor 2^(128 * (1 - y/z)).\n   * Revert if z is zero, or if both x and y are zeros.\n   *\n   * @param x number to raise into given power y/z\n   * @param y numerator of the power to raise x into\n   * @param z denominator of the power to raise x into\n   * @return x raised into power y/z and then multiplied by 2^(128 * (1 - y/z))\n   */\n  function pow(uint128 x, uint128 y, uint128 z)\n  internal pure returns(uint128) {\n    unchecked {\n      require(z != 0);\n\n      if(x == 0) {\n        require(y != 0);\n        return 0;\n      } else {\n        uint256 l =\n          uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - log_2(x)) * y / z;\n        if(l > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return 0;\n        else return pow_2(uint128(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - l));\n      }\n    }\n  }\n\n  /**\n   * Calculate base 2 logarithm of an unsigned 128-bit integer number.  Revert\n   * in case x is zero.\n   *\n   * @param x number to calculate base 2 logarithm of\n   * @return base 2 logarithm of x, multiplied by 2^121\n   */\n  function log_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      require(x != 0);\n\n      uint b = x;\n\n      uint l = 0xFE000000000000000000000000000000;\n\n      if(b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\n      if(b < 0x1000000000000000000000000) {l -= 0x40000000000000000000000000000000; b <<= 32;}\n      if(b < 0x10000000000000000000000000000) {l -= 0x20000000000000000000000000000000; b <<= 16;}\n      if(b < 0x1000000000000000000000000000000) {l -= 0x10000000000000000000000000000000; b <<= 8;}\n      if(b < 0x10000000000000000000000000000000) {l -= 0x8000000000000000000000000000000; b <<= 4;}\n      if(b < 0x40000000000000000000000000000000) {l -= 0x4000000000000000000000000000000; b <<= 2;}\n      if(b < 0x80000000000000000000000000000000) {l -= 0x2000000000000000000000000000000; b <<= 1;}\n\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000;} /*\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) l |= 0x1; */\n\n      return uint128(l);\n    }\n  }\n\n  /**\n   * Calculate 2 raised into given power.\n   *\n   * @param x power to raise 2 into, multiplied by 2^121\n   * @return 2 raised into given power\n   */\n  function pow_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      uint r = 0x80000000000000000000000000000000;\n      if(x & 0x1000000000000000000000000000000 > 0) r = r * 0xb504f333f9de6484597d89b3754abe9f >> 127;\n      if(x & 0x800000000000000000000000000000 > 0) r = r * 0x9837f0518db8a96f46ad23182e42f6f6 >> 127;\n      if(x & 0x400000000000000000000000000000 > 0) r = r * 0x8b95c1e3ea8bd6e6fbe4628758a53c90 >> 127;\n      if(x & 0x200000000000000000000000000000 > 0) r = r * 0x85aac367cc487b14c5c95b8c2154c1b2 >> 127;\n      if(x & 0x100000000000000000000000000000 > 0) r = r * 0x82cd8698ac2ba1d73e2a475b46520bff >> 127;\n      if(x & 0x80000000000000000000000000000 > 0) r = r * 0x8164d1f3bc0307737be56527bd14def4 >> 127;\n      if(x & 0x40000000000000000000000000000 > 0) r = r * 0x80b1ed4fd999ab6c25335719b6e6fd20 >> 127;\n      if(x & 0x20000000000000000000000000000 > 0) r = r * 0x8058d7d2d5e5f6b094d589f608ee4aa2 >> 127;\n      if(x & 0x10000000000000000000000000000 > 0) r = r * 0x802c6436d0e04f50ff8ce94a6797b3ce >> 127;\n      if(x & 0x8000000000000000000000000000 > 0) r = r * 0x8016302f174676283690dfe44d11d008 >> 127;\n      if(x & 0x4000000000000000000000000000 > 0) r = r * 0x800b179c82028fd0945e54e2ae18f2f0 >> 127;\n      if(x & 0x2000000000000000000000000000 > 0) r = r * 0x80058baf7fee3b5d1c718b38e549cb93 >> 127;\n      if(x & 0x1000000000000000000000000000 > 0) r = r * 0x8002c5d00fdcfcb6b6566a58c048be1f >> 127;\n      if(x & 0x800000000000000000000000000 > 0) r = r * 0x800162e61bed4a48e84c2e1a463473d9 >> 127;\n      if(x & 0x400000000000000000000000000 > 0) r = r * 0x8000b17292f702a3aa22beacca949013 >> 127;\n      if(x & 0x200000000000000000000000000 > 0) r = r * 0x800058b92abbae02030c5fa5256f41fe >> 127;\n      if(x & 0x100000000000000000000000000 > 0) r = r * 0x80002c5c8dade4d71776c0f4dbea67d6 >> 127;\n      if(x & 0x80000000000000000000000000 > 0) r = r * 0x8000162e44eaf636526be456600bdbe4 >> 127;\n      if(x & 0x40000000000000000000000000 > 0) r = r * 0x80000b1721fa7c188307016c1cd4e8b6 >> 127;\n      if(x & 0x20000000000000000000000000 > 0) r = r * 0x8000058b90de7e4cecfc487503488bb1 >> 127;\n      if(x & 0x10000000000000000000000000 > 0) r = r * 0x800002c5c8678f36cbfce50a6de60b14 >> 127;\n      if(x & 0x8000000000000000000000000 > 0) r = r * 0x80000162e431db9f80b2347b5d62e516 >> 127;\n      if(x & 0x4000000000000000000000000 > 0) r = r * 0x800000b1721872d0c7b08cf1e0114152 >> 127;\n      if(x & 0x2000000000000000000000000 > 0) r = r * 0x80000058b90c1aa8a5c3736cb77e8dff >> 127;\n      if(x & 0x1000000000000000000000000 > 0) r = r * 0x8000002c5c8605a4635f2efc2362d978 >> 127;\n      if(x & 0x800000000000000000000000 > 0) r = r * 0x800000162e4300e635cf4a109e3939bd >> 127;\n      if(x & 0x400000000000000000000000 > 0) r = r * 0x8000000b17217ff81bef9c551590cf83 >> 127;\n      if(x & 0x200000000000000000000000 > 0) r = r * 0x800000058b90bfdd4e39cd52c0cfa27c >> 127;\n      if(x & 0x100000000000000000000000 > 0) r = r * 0x80000002c5c85fe6f72d669e0e76e411 >> 127;\n      if(x & 0x80000000000000000000000 > 0) r = r * 0x8000000162e42ff18f9ad35186d0df28 >> 127;\n      if(x & 0x40000000000000000000000 > 0) r = r * 0x80000000b17217f84cce71aa0dcfffe7 >> 127;\n      if(x & 0x20000000000000000000000 > 0) r = r * 0x8000000058b90bfc07a77ad56ed22aaa >> 127;\n      if(x & 0x10000000000000000000000 > 0) r = r * 0x800000002c5c85fdfc23cdead40da8d6 >> 127;\n      if(x & 0x8000000000000000000000 > 0) r = r * 0x80000000162e42fefc25eb1571853a66 >> 127;\n      if(x & 0x4000000000000000000000 > 0) r = r * 0x800000000b17217f7d97f692baacded5 >> 127;\n      if(x & 0x2000000000000000000000 > 0) r = r * 0x80000000058b90bfbead3b8b5dd254d7 >> 127;\n      if(x & 0x1000000000000000000000 > 0) r = r * 0x8000000002c5c85fdf4eedd62f084e67 >> 127;\n      if(x & 0x800000000000000000000 > 0) r = r * 0x800000000162e42fefa58aef378bf586 >> 127;\n      if(x & 0x400000000000000000000 > 0) r = r * 0x8000000000b17217f7d24a78a3c7ef02 >> 127;\n      if(x & 0x200000000000000000000 > 0) r = r * 0x800000000058b90bfbe9067c93e474a6 >> 127;\n      if(x & 0x100000000000000000000 > 0) r = r * 0x80000000002c5c85fdf47b8e5a72599f >> 127;\n      if(x & 0x80000000000000000000 > 0) r = r * 0x8000000000162e42fefa3bdb315934a2 >> 127;\n      if(x & 0x40000000000000000000 > 0) r = r * 0x80000000000b17217f7d1d7299b49c46 >> 127;\n      if(x & 0x20000000000000000000 > 0) r = r * 0x8000000000058b90bfbe8e9a8d1c4ea0 >> 127;\n      if(x & 0x10000000000000000000 > 0) r = r * 0x800000000002c5c85fdf4745969ea76f >> 127;\n      if(x & 0x8000000000000000000 > 0) r = r * 0x80000000000162e42fefa3a0df5373bf >> 127;\n      if(x & 0x4000000000000000000 > 0) r = r * 0x800000000000b17217f7d1cff4aac1e1 >> 127;\n      if(x & 0x2000000000000000000 > 0) r = r * 0x80000000000058b90bfbe8e7db95a2f1 >> 127;\n      if(x & 0x1000000000000000000 > 0) r = r * 0x8000000000002c5c85fdf473e61ae1f8 >> 127;\n      if(x & 0x800000000000000000 > 0) r = r * 0x800000000000162e42fefa39f121751c >> 127;\n      if(x & 0x400000000000000000 > 0) r = r * 0x8000000000000b17217f7d1cf815bb96 >> 127;\n      if(x & 0x200000000000000000 > 0) r = r * 0x800000000000058b90bfbe8e7bec1e0d >> 127;\n      if(x & 0x100000000000000000 > 0) r = r * 0x80000000000002c5c85fdf473dee5f17 >> 127;\n      if(x & 0x80000000000000000 > 0) r = r * 0x8000000000000162e42fefa39ef5438f >> 127;\n      if(x & 0x40000000000000000 > 0) r = r * 0x80000000000000b17217f7d1cf7a26c8 >> 127;\n      if(x & 0x20000000000000000 > 0) r = r * 0x8000000000000058b90bfbe8e7bcf4a4 >> 127;\n      if(x & 0x10000000000000000 > 0) r = r * 0x800000000000002c5c85fdf473de72a2 >> 127; /*\n      if(x & 0x8000000000000000 > 0) r = r * 0x80000000000000162e42fefa39ef3765 >> 127;\n      if(x & 0x4000000000000000 > 0) r = r * 0x800000000000000b17217f7d1cf79b37 >> 127;\n      if(x & 0x2000000000000000 > 0) r = r * 0x80000000000000058b90bfbe8e7bcd7d >> 127;\n      if(x & 0x1000000000000000 > 0) r = r * 0x8000000000000002c5c85fdf473de6b6 >> 127;\n      if(x & 0x800000000000000 > 0) r = r * 0x800000000000000162e42fefa39ef359 >> 127;\n      if(x & 0x400000000000000 > 0) r = r * 0x8000000000000000b17217f7d1cf79ac >> 127;\n      if(x & 0x200000000000000 > 0) r = r * 0x800000000000000058b90bfbe8e7bcd6 >> 127;\n      if(x & 0x100000000000000 > 0) r = r * 0x80000000000000002c5c85fdf473de6a >> 127;\n      if(x & 0x80000000000000 > 0) r = r * 0x8000000000000000162e42fefa39ef35 >> 127;\n      if(x & 0x40000000000000 > 0) r = r * 0x80000000000000000b17217f7d1cf79a >> 127;\n      if(x & 0x20000000000000 > 0) r = r * 0x8000000000000000058b90bfbe8e7bcd >> 127;\n      if(x & 0x10000000000000 > 0) r = r * 0x800000000000000002c5c85fdf473de6 >> 127;\n      if(x & 0x8000000000000 > 0) r = r * 0x80000000000000000162e42fefa39ef3 >> 127;\n      if(x & 0x4000000000000 > 0) r = r * 0x800000000000000000b17217f7d1cf79 >> 127;\n      if(x & 0x2000000000000 > 0) r = r * 0x80000000000000000058b90bfbe8e7bc >> 127;\n      if(x & 0x1000000000000 > 0) r = r * 0x8000000000000000002c5c85fdf473de >> 127;\n      if(x & 0x800000000000 > 0) r = r * 0x800000000000000000162e42fefa39ef >> 127;\n      if(x & 0x400000000000 > 0) r = r * 0x8000000000000000000b17217f7d1cf7 >> 127;\n      if(x & 0x200000000000 > 0) r = r * 0x800000000000000000058b90bfbe8e7b >> 127;\n      if(x & 0x100000000000 > 0) r = r * 0x80000000000000000002c5c85fdf473d >> 127;\n      if(x & 0x80000000000 > 0) r = r * 0x8000000000000000000162e42fefa39e >> 127;\n      if(x & 0x40000000000 > 0) r = r * 0x80000000000000000000b17217f7d1cf >> 127;\n      if(x & 0x20000000000 > 0) r = r * 0x8000000000000000000058b90bfbe8e7 >> 127;\n      if(x & 0x10000000000 > 0) r = r * 0x800000000000000000002c5c85fdf473 >> 127;\n      if(x & 0x8000000000 > 0) r = r * 0x80000000000000000000162e42fefa39 >> 127;\n      if(x & 0x4000000000 > 0) r = r * 0x800000000000000000000b17217f7d1c >> 127;\n      if(x & 0x2000000000 > 0) r = r * 0x80000000000000000000058b90bfbe8e >> 127;\n      if(x & 0x1000000000 > 0) r = r * 0x8000000000000000000002c5c85fdf47 >> 127;\n      if(x & 0x800000000 > 0) r = r * 0x800000000000000000000162e42fefa3 >> 127;\n      if(x & 0x400000000 > 0) r = r * 0x8000000000000000000000b17217f7d1 >> 127;\n      if(x & 0x200000000 > 0) r = r * 0x800000000000000000000058b90bfbe8 >> 127;\n      if(x & 0x100000000 > 0) r = r * 0x80000000000000000000002c5c85fdf4 >> 127;\n      if(x & 0x80000000 > 0) r = r * 0x8000000000000000000000162e42fefa >> 127;\n      if(x & 0x40000000 > 0) r = r * 0x80000000000000000000000b17217f7d >> 127;\n      if(x & 0x20000000 > 0) r = r * 0x8000000000000000000000058b90bfbe >> 127;\n      if(x & 0x10000000 > 0) r = r * 0x800000000000000000000002c5c85fdf >> 127;\n      if(x & 0x8000000 > 0) r = r * 0x80000000000000000000000162e42fef >> 127;\n      if(x & 0x4000000 > 0) r = r * 0x800000000000000000000000b17217f7 >> 127;\n      if(x & 0x2000000 > 0) r = r * 0x80000000000000000000000058b90bfb >> 127;\n      if(x & 0x1000000 > 0) r = r * 0x8000000000000000000000002c5c85fd >> 127;\n      if(x & 0x800000 > 0) r = r * 0x800000000000000000000000162e42fe >> 127;\n      if(x & 0x400000 > 0) r = r * 0x8000000000000000000000000b17217f >> 127;\n      if(x & 0x200000 > 0) r = r * 0x800000000000000000000000058b90bf >> 127;\n      if(x & 0x100000 > 0) r = r * 0x80000000000000000000000002c5c85f >> 127;\n      if(x & 0x80000 > 0) r = r * 0x8000000000000000000000000162e42f >> 127;\n      if(x & 0x40000 > 0) r = r * 0x80000000000000000000000000b17217 >> 127;\n      if(x & 0x20000 > 0) r = r * 0x8000000000000000000000000058b90b >> 127;\n      if(x & 0x10000 > 0) r = r * 0x800000000000000000000000002c5c85 >> 127;\n      if(x & 0x8000 > 0) r = r * 0x80000000000000000000000000162e42 >> 127;\n      if(x & 0x4000 > 0) r = r * 0x800000000000000000000000000b1721 >> 127;\n      if(x & 0x2000 > 0) r = r * 0x80000000000000000000000000058b90 >> 127;\n      if(x & 0x1000 > 0) r = r * 0x8000000000000000000000000002c5c8 >> 127;\n      if(x & 0x800 > 0) r = r * 0x800000000000000000000000000162e4 >> 127;\n      if(x & 0x400 > 0) r = r * 0x8000000000000000000000000000b172 >> 127;\n      if(x & 0x200 > 0) r = r * 0x800000000000000000000000000058b9 >> 127;\n      if(x & 0x100 > 0) r = r * 0x80000000000000000000000000002c5c >> 127;\n      if(x & 0x80 > 0) r = r * 0x8000000000000000000000000000162e >> 127;\n      if(x & 0x40 > 0) r = r * 0x80000000000000000000000000000b17 >> 127;\n      if(x & 0x20 > 0) r = r * 0x8000000000000000000000000000058b >> 127;\n      if(x & 0x10 > 0) r = r * 0x800000000000000000000000000002c5 >> 127;\n      if(x & 0x8 > 0) r = r * 0x80000000000000000000000000000162 >> 127;\n      if(x & 0x4 > 0) r = r * 0x800000000000000000000000000000b1 >> 127;\n      if(x & 0x2 > 0) r = r * 0x80000000000000000000000000000058 >> 127;\n      if(x & 0x1 > 0) r = r * 0x8000000000000000000000000000002c >> 127; */\n\n      r >>= 127 -(x >> 121);\n\n      return uint128(r);\n    }\n  }\n}\n\n/**\n * Ethereum smart contract library implementing Yield Math model.\n */\nlibrary YieldMath {\n  using Math64x64 for int128;\n  using Math64x64 for uint128;\n  using Math64x64 for int256;\n  using Math64x64 for uint256;\n  using Exp64x64 for uint128;\n\n  uint128 public constant ONE = 0x10000000000000000; // In 64.64\n  uint256 public constant MAX = type(uint128).max;   // Used for overflow checks\n\n  /**\n   * Calculate the amount of fyToken a user would get for given amount of Base.\n   * https://www.desmos.com/calculator/5nf2xuy6yb\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param baseAmount base amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of fyToken a user would get for given amount of Base\n   */\n  function fyTokenOutForBaseIn(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 baseAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // zx = baseReserves + baseAmount\n      uint256 zx = uint256(baseReserves) + uint256(baseAmount);\n      require(zx <= MAX, \"YieldMath: Too much base in\");\n\n      // zxa = zx ** a\n      uint256 zxa = uint128(zx).pow(a, ONE);\n\n      // sum = za + ya - zxa\n      uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Insufficient fyToken reserves\");\n\n      // result = fyTokenReserves - (sum ** (1/a))\n      uint256 result = uint256(fyTokenReserves) - uint256(uint128(sum).pow(ONE, a));\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of base a user would get for certain amount of fyToken.\n   * https://www.desmos.com/calculator/6jlrre7ybt\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param fyTokenAmount fyToken amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of Base a user would get for given amount of fyToken\n   */\n  function baseOutForFYTokenIn(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 fyTokenAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // yx = fyDayReserves + fyTokenAmount\n      uint256 yx = uint256(fyTokenReserves) + uint256(fyTokenAmount);\n      require(yx <= MAX, \"YieldMath: Too much fyToken in\");\n\n      // yxa = yx ** a\n      uint256 yxa = uint128(yx).pow(a, ONE);\n\n      // sum = za + ya - yxa\n      uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Insufficient base reserves\");\n\n      // result = baseReserves - (sum ** (1/a))\n      uint256 result = uint256(baseReserves) - uint256(uint128(sum).pow(ONE, a));\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of fyToken a user could sell for given amount of Base.\n   * https://www.desmos.com/calculator/0rgnmtckvy\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param baseAmount Base amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of fyToken a user could sell for given amount of Base\n   */\n  function fyTokenInForBaseOut(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 baseAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // zx = baseReserves - baseAmount\n      uint256 zx = uint256(baseReserves) - uint256(baseAmount);\n      require(zx <= MAX, \"YieldMath: Too much base out\");\n\n      // zxa = zx ** a\n      uint256 zxa = uint128(zx).pow(a, ONE);\n\n      // sum = za + ya - zxa\n      uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Resulting fyToken reserves too high\");\n\n      // result = (sum ** (1/a)) - fyTokenReserves\n      uint256 result = uint256(uint128(sum).pow(ONE, a)) - uint256(fyTokenReserves);\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of base a user would have to pay for certain amount of fyToken.\n   * https://www.desmos.com/calculator/ws5oqj8x5i\n   * @param baseReserves Base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param fyTokenAmount fyToken amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of base a user would have to pay for given amount of\n   *         fyToken\n   */\n  function baseInForFYTokenOut(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 fyTokenAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // yx = baseReserves - baseAmount\n      uint256 yx = uint256(fyTokenReserves) - uint256(fyTokenAmount);\n      require(yx <= MAX, \"YieldMath: Too much fyToken out\");\n\n      // yxa = yx ** a\n      uint256 yxa = uint128(yx).pow(a, ONE);\n\n      // sum = za + ya - yxa\n      uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Resulting base reserves too high\");\n\n      // result = (sum ** (1/a)) - baseReserves\n      uint256 result = uint256(uint128(sum).pow(ONE, a)) - uint256(baseReserves);\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max\n\n      return uint128(result);\n    }\n  }\n\n  function _computeA(uint128 timeTillMaturity, int128 k, int128 g) private pure returns (uint128) {\n    unchecked {\n      // t = k * timeTillMaturity\n      int128 t = k.mul(timeTillMaturity.fromUInt());\n      require(t >= 0, \"YieldMath: t must be positive\"); // Meaning neither T or k can be negative\n\n      // a = (1 - gt)\n      int128 a = int128(ONE).sub(g.mul(t));\n      require(a > 0, \"YieldMath: Too far from maturity\");\n      require(a <= int128(ONE), \"YieldMath: g must be positive\");\n\n      return uint128(a);\n    }\n  }\n\n  /**\n   * Estimate in Base the value of reserves at protocol initialization time.\n   *\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param c0 price of base in terms of Base, multiplied by 2^64\n   * @return estimated value of reserves\n   */\n  function initialReservesValue(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 timeTillMaturity,\n    int128 k, int128 c0)\n  external pure returns(uint128) {\n    unchecked {\n      uint256 normalizedBaseReserves = c0.mulu(baseReserves);\n      require(normalizedBaseReserves <= MAX);\n\n      // a = (1 - k * timeTillMaturity)\n      int128 a = int128(ONE).sub(k.mul(timeTillMaturity.fromUInt()));\n      require(a > 0);\n\n      uint256 sum =\n        uint256(uint128(normalizedBaseReserves).pow(uint128(a), ONE)) +\n        uint256(fyTokenReserves.pow(uint128(a), ONE)) >> 1;\n      require(sum <= MAX);\n\n      uint256 result = uint256(uint128(sum).pow(ONE, uint128(a))) << 1;\n      require(result <= MAX);\n\n      return uint128(result);\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "CodeNames": [
            "YieldMath.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "log_2 function in YieldMath.sol",
                "Type": "Logic",
                "Description": "The V1 version of YieldMath.sol contains >= (larger or equal), while the V2 version of YieldMath.sol contains > (larger) in the log_2 function, which might lead to miss calculations.",
                "Repair": "Check which version is the correct version and fix the incorrect version"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes4` identifier. These are expected to be the \n * signatures for all the functions in the contract. Special roles should be exposed\n * in the external API and be unique:\n *\n * ```\n * bytes4 public constant ROOT = 0x00000000;\n * ```\n *\n * Roles represent restricted access to a function call. For that purpose, use {auth}:\n *\n * ```\n * function foo() public auth {\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `ROOT`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {setRoleAdmin}.\n *\n * WARNING: The `ROOT` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\ncontract AccessControl {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes4 adminRole;\n    }\n\n    mapping (bytes4 => RoleData) private _roles;\n\n    bytes4 public constant ROOT = 0x00000000;\n    bytes4 public constant LOCK = 0xFFFFFFFF; // Used to disable further permissioning of a function\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role\n     *\n     * `ROOT` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call.\n     */\n    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. \n     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.\n     */\n    constructor () {\n        _grantRole(ROOT, msg.sender);   // Grant ROOT to msg.sender\n        _setRoleAdmin(LOCK, LOCK);      // Create the LOCK role by setting itself as its own admin, creating an independent role tree\n    }\n\n    /**\n     * @dev Each function in the contract has its own role, identified by their msg.sig signature.\n     * ROOT can give and remove access to each function, lock any further access being granted to\n     * a specific action, or even create other roles to delegate admin control over a function.\n     */\n    modifier auth() {\n        require (_hasRole(msg.sig, msg.sender), \"Access denied\");\n        _;\n    }\n\n    /**\n     * @dev Allow only if the caller has been granted the admin role of `role`.\n     */\n    modifier admin(bytes4 role) {\n        require (_hasRole(_getRoleAdmin(role), msg.sender), \"Only admin\");\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes4 role, address account) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes4 role) external view returns (bytes4) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n\n     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes4 role, address account) external virtual admin(role) {\n        _grantRole(role, account);\n    }\n\n    \n    /**\n     * @dev Grants all of `role` in `roles` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\n     */\n    function grantRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _grantRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.\n\n     * Emits a {RoleAdminChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function lockRole(bytes4 role) external virtual admin(role) {\n        _setRoleAdmin(role, LOCK);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes4 role, address account) external virtual admin(role) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes all of `role` in `roles` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\n     */\n    function revokeRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _revokeRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes4 role, address account) external virtual {\n        require(account == msg.sender, \"Renounce only for self\");\n\n        _revokeRole(role, account);\n    }\n\n    function _hasRole(bytes4 role, address account) internal view returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {\n        return _roles[role].adminRole;\n    }\n\n    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {\n        if (_getRoleAdmin(role) != adminRole) {\n            _roles[role].adminRole = adminRole;\n            emit RoleAdminChanged(role, adminRole);\n        }\n    }\n\n    function _grantRole(bytes4 role, address account) internal {\n        if (!_hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes4 role, address account) internal {\n        if (_hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "AccessControl.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AccessControl.sol",
                "Type": "auth collision",
                "Description": "The auth mechanism of AccessControl.sol uses function selectors (msg.sig) as a (unique) role definition. Also the _moduleCall allows the code to be extended.",
                "Repair": "Add explicit checks for giving ROOT access and implement CI checks for signature collisions"
            },
            {
                "Location": "AccessControl.sol",
                "Type": "auth only works well with external functions",
                "Description": "The auth modifier of AccessControl.sol doesn't work as you would expect.",
                "Repair": "Make sure all auth functions use external or change the modifier to check for the correct selector"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/ICauldron.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./interfaces/yieldspace/IPool.sol\";\nimport \"./interfaces/external/IERC20.sol\";\nimport \"./interfaces/external/IERC2612.sol\";\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./utils/token/TransferHelper.sol\";\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./LadleStorage.sol\";\n\n\n/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient user oriented features.\ncontract Ladle is LadleStorage, AccessControl() {\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n    using CastU128I128 for uint128;\n    using TransferHelper for IERC20;\n    using TransferHelper for address payable;\n\n    IWETH9 public immutable weth;\n\n    constructor (ICauldron cauldron, IWETH9 weth_) LadleStorage(cauldron) {\n        weth = weth_;\n    }\n\n    // ---- Data sourcing ----\n    /// @dev Obtains a vault by vaultId from the Cauldron, and verifies that msg.sender is the owner\n    function getOwnedVault(bytes12 vaultId)\n        internal view returns(DataTypes.Vault memory vault)\n    {\n        vault = cauldron.vaults(vaultId);\n        require (vault.owner == msg.sender, \"Only vault owner\");\n    }\n\n    /// @dev Obtains a series by seriesId from the Cauldron, and verifies that it exists\n    function getSeries(bytes6 seriesId)\n        internal view returns(DataTypes.Series memory series)\n    {\n        series = cauldron.series(seriesId);\n        require (series.fyToken != IFYToken(address(0)), \"Series not found\");\n    }\n\n    /// @dev Obtains a join by assetId, and verifies that it exists\n    function getJoin(bytes6 assetId)\n        internal view returns(IJoin join)\n    {\n        join = joins[assetId];\n        require (join != IJoin(address(0)), \"Join not found\");\n    }\n\n    /// @dev Obtains a pool by seriesId, and verifies that it exists\n    function getPool(bytes6 seriesId)\n        internal view returns(IPool pool)\n    {\n        pool = pools[seriesId];\n        require (pool != IPool(address(0)), \"Pool not found\");\n    }\n\n    // ---- Administration ----\n\n    /// @dev Add a new Join for an Asset, or replace an existing one for a new one.\n    /// There can be only one Join per Asset. Until a Join is added, no tokens of that Asset can be posted or withdrawn.\n    function addJoin(bytes6 assetId, IJoin join)\n        external\n        auth\n    {\n        address asset = cauldron.assets(assetId);\n        require (asset != address(0), \"Asset not found\");\n        require (join.asset() == asset, \"Mismatched asset and join\");\n        joins[assetId] = join;\n        emit JoinAdded(assetId, address(join));\n    }\n\n    /// @dev Add a new Pool for a Series, or replace an existing one for a new one.\n    /// There can be only one Pool per Series. Until a Pool is added, it is not possible to borrow Base.\n    function addPool(bytes6 seriesId, IPool pool)\n        external\n        auth\n    {\n        IFYToken fyToken = getSeries(seriesId).fyToken;\n        require (fyToken == pool.fyToken(), \"Mismatched pool fyToken and series\");\n        require (fyToken.underlying() == address(pool.base()), \"Mismatched pool base and series\");\n        pools[seriesId] = pool;\n        emit PoolAdded(seriesId, address(pool));\n    }\n\n    /// @dev Add or remove a module.\n    function setModule(address module, bool set)\n        external\n        auth\n    {\n        modules[module] = set;\n        emit ModuleSet(module, set);\n    }\n\n    /// @dev Set the fee parameter\n    function setFee(uint256 fee)\n        public\n        auth    \n    {\n        borrowingFee = fee;\n        emit FeeSet(fee);\n    }\n\n    // ---- Batching ----\n\n\n    /// @dev Submit a series of calls for execution.\n    /// Unlike `batch`, this function calls private functions, saving a CALL per function.\n    /// It also caches the vault, which is useful in `build` + `pour` and `build` + `serve` combinations.\n    function batch(\n        Operation[] calldata operations,\n        bytes[] calldata data\n    ) external payable {\n        require(operations.length == data.length, \"Mismatched operation data\");\n        bytes12 cachedId;\n        DataTypes.Vault memory vault;\n\n        // Execute all operations in the batch. Conditionals ordered by expected frequency.\n        for (uint256 i = 0; i < operations.length; i += 1) {\n\n            Operation operation = operations[i];\n\n            if (operation == Operation.BUILD) {\n                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n                (cachedId, vault) = (vaultId, _build(vaultId, seriesId, ilkId));   // Cache the vault that was just built\n            \n            } else if (operation == Operation.FORWARD_PERMIT) {\n                (bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(data[i], (bytes6, bool, address, uint256, uint256, uint8, bytes32, bytes32));\n                _forwardPermit(id, isAsset, spender, amount, deadline, v, r, s);\n            \n            } else if (operation == Operation.JOIN_ETHER) {\n                (bytes6 etherId) = abi.decode(data[i], (bytes6));\n                _joinEther(etherId);\n            \n            } else if (operation == Operation.POUR) {\n                (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _pour(vaultId, vault, to, ink, art);\n            \n            } else if (operation == Operation.SERVE) {\n                (bytes12 vaultId, address to, uint128 ink, uint128 base, uint128 max) = abi.decode(data[i], (bytes12, address, uint128, uint128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _serve(vaultId, vault, to, ink, base, max);\n\n            } else if (operation == Operation.ROLL) {\n                (bytes12 vaultId, bytes6 newSeriesId, uint8 loan, uint128 max) = abi.decode(data[i], (bytes12, bytes6, uint8, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                (vault,) = _roll(vaultId, vault, newSeriesId, loan, max);\n            \n            } else if (operation == Operation.FORWARD_DAI_PERMIT) {\n                (bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(data[i], (bytes6, bool, address, uint256, uint256, bool, uint8, bytes32, bytes32));\n                _forwardDaiPermit(id, isAsset, spender, nonce, deadline, allowed, v, r, s);\n            \n            } else if (operation == Operation.TRANSFER_TO_POOL) {\n                (bytes6 seriesId, bool base, uint128 wad) =\n                    abi.decode(data[i], (bytes6, bool, uint128));\n                IPool pool = getPool(seriesId);\n                _transferToPool(pool, base, wad);\n            \n            } else if (operation == Operation.ROUTE) {\n                (bytes6 seriesId, bytes memory poolCall) =\n                    abi.decode(data[i], (bytes6, bytes));\n                IPool pool = getPool(seriesId);\n                _route(pool, poolCall);\n            \n            } else if (operation == Operation.EXIT_ETHER) {\n                (address to) = abi.decode(data[i], (address));\n                _exitEther(payable(to));\n            \n            } else if (operation == Operation.CLOSE) {\n                (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _close(vaultId, vault, to, ink, art);\n            \n            } else if (operation == Operation.REPAY) {\n                (bytes12 vaultId, address to, int128 ink, uint128 min) = abi.decode(data[i], (bytes12, address, int128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repay(vaultId, vault, to, ink, min);\n            \n            } else if (operation == Operation.REPAY_VAULT) {\n                (bytes12 vaultId, address to, int128 ink, uint128 max) = abi.decode(data[i], (bytes12, address, int128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repayVault(vaultId, vault, to, ink, max);\n\n            } else if (operation == Operation.REPAY_LADLE) {\n                (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repayLadle(vaultId, vault);\n\n            } else if (operation == Operation.RETRIEVE) {\n                (bytes6 assetId, bool isAsset, address to) = abi.decode(data[i], (bytes6, bool, address));\n                _retrieve(assetId, isAsset, to);\n\n            } else if (operation == Operation.TRANSFER_TO_FYTOKEN) {\n                (bytes6 seriesId, uint256 amount) = abi.decode(data[i], (bytes6, uint256));\n                IFYToken fyToken = getSeries(seriesId).fyToken;\n                _transferToFYToken(fyToken, amount);\n            \n            } else if (operation == Operation.REDEEM) {\n                (bytes6 seriesId, address to, uint256 amount) = abi.decode(data[i], (bytes6, address, uint256));\n                IFYToken fyToken = getSeries(seriesId).fyToken;\n                _redeem(fyToken, to, amount);\n            \n            } else if (operation == Operation.STIR) {\n                (bytes12 from, bytes12 to, uint128 ink, uint128 art) = abi.decode(data[i], (bytes12, bytes12, uint128, uint128));\n                _stir(from, to, ink, art);  // Too complicated to use caching here\n            \n            } else if (operation == Operation.TWEAK) {\n                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                vault = _tweak(vaultId, seriesId, ilkId);\n\n            } else if (operation == Operation.GIVE) {\n                (bytes12 vaultId, address to) = abi.decode(data[i], (bytes12, address));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                vault = _give(vaultId, to);\n                delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore\n                cachedId = bytes12(0);\n\n            } else if (operation == Operation.DESTROY) {\n                (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _destroy(vaultId);\n                delete vault;   // Clear the cache\n                cachedId = bytes12(0);\n            \n            } else if (operation == Operation.MODULE) {\n                (address module, bytes memory moduleCall) = abi.decode(data[i], (address, bytes));\n                _moduleCall(module, moduleCall);\n            \n            }\n        }\n    }\n\n    // ---- Vault management ----\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function _build(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        return cauldron.build(msg.sender, vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Change a vault series or collateral.\n    function _tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        // tweak checks that the series and the collateral both exist and that the collateral is approved for the series\n        return cauldron.tweak(vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Give a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        return cauldron.give(vaultId, receiver);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function _destroy(bytes12 vaultId)\n        private\n    {\n        cauldron.destroy(vaultId);\n    }\n\n    // ---- Asset and debt management ----\n\n    /// @dev Move collateral and debt between vaults.\n    function _stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        private\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        if (ink > 0) require (cauldron.vaults(from).owner == msg.sender, \"Only origin vault owner\");\n        if (art > 0) require (cauldron.vaults(to).owner == msg.sender, \"Only destination vault owner\");\n        return cauldron.stir(from, to, ink, art);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    /// Borrow only before maturity.\n    function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        DataTypes.Series memory series;\n        if (art != 0) series = getSeries(vault.seriesId);\n\n        int128 fee;\n        if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, ink, art + fee);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage debt tokens\n        if (art != 0) {\n            if (art > 0) series.fyToken.mint(to, uint128(art));\n            else series.fyToken.burn(msg.sender, uint128(-art));\n        }\n    }\n\n    /// @dev Add collateral and borrow from vault, so that a precise amount of base is obtained by the user.\n    /// The base is obtained by borrowing fyToken and buying base with it in a pool.\n    /// Only before maturity.\n    function _serve(bytes12 vaultId, DataTypes.Vault memory vault, address to, uint128 ink, uint128 base, uint128 max)\n        private\n        returns (DataTypes.Balances memory balances, uint128 art)\n    {\n        IPool pool = getPool(vault.seriesId);\n        \n        art = pool.buyBasePreview(base);\n        balances = _pour(vaultId, vault, address(pool), ink.i128(), art.i128());\n        pool.buyBase(to, base, max);\n    }\n\n    /// @dev Repay vault debt using underlying token at a 1:1 exchange rate, without trading in a pool.\n    /// It can add or remove collateral at the same time.\n    /// The debt to repay is denominated in fyToken, even if the tokens pulled from the user are underlying.\n    /// The debt to repay must be entered as a negative number, as with `pour`.\n    /// Debt cannot be acquired with this function.\n    function _close(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        require (art < 0, \"Only repay debt\");                                          // When repaying debt in `frob`, art is a negative value. Here is the same for consistency.\n\n        // Calculate debt in fyToken terms\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art));\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, ink, art);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage underlying\n        IJoin baseJoin = getJoin(series.baseId);\n        baseJoin.join(msg.sender, amt);\n    }\n\n    /// @dev Calculate a debt amount for a series in base terms\n    function _debtInBase(bytes6 seriesId, DataTypes.Series memory series, uint128 art)\n        private\n        returns (uint128 amt)\n    {\n        if (uint32(block.timestamp) >= series.maturity) {\n            amt = uint256(art).wmul(cauldron.accrual(seriesId)).u128();\n        } else {\n            amt = art;\n        }\n    }\n\n    /// @dev Repay debt by selling base in a pool and using the resulting fyToken\n    /// The base tokens need to be already in the pool, unaccounted for.\n    /// Only before maturity. After maturity use close.\n    function _repay(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, uint128 min)\n        private\n        returns (DataTypes.Balances memory balances, uint128 art)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        art = pool.sellBase(address(series.fyToken), min);\n        balances = _pour(vaultId, vault, to, ink, -(art.i128()));\n    }\n\n    /// @dev Repay all debt in a vault by buying fyToken from a pool with base.\n    /// The base tokens need to be already in the pool, unaccounted for. The surplus base will be returned to msg.sender.\n    /// Only before maturity. After maturity use close.\n    function _repayVault(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, uint128 max)\n        private\n        returns (DataTypes.Balances memory balances, uint128 base)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        balances = cauldron.balances(vaultId);\n        base = pool.buyFYToken(address(series.fyToken), balances.art, max);\n        balances = _pour(vaultId, vault, to, ink, -(balances.art.i128()));\n        pool.retrieveBase(msg.sender);\n    }\n\n    /// @dev Change series and debt of a vault.\n    function _roll(bytes12 vaultId, DataTypes.Vault memory vault, bytes6 newSeriesId, uint8 loan, uint128 max)\n        private\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Series memory newSeries = getSeries(newSeriesId);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        \n        uint128 newDebt;\n        {\n            IPool pool = getPool(newSeriesId);\n            IFYToken fyToken = IFYToken(newSeries.fyToken);\n            IJoin baseJoin = getJoin(series.baseId);\n\n            // Calculate debt in fyToken terms\n            uint128 amt = _debtInBase(vault.seriesId, series, balances.art);\n\n            // Mint fyToken to the pool, as a kind of flash loan\n            fyToken.mint(address(pool), amt * loan);                // Loan is the size of the flash loan relative to the debt amount, 2 should be safe most of the time\n\n            // Buy the base required to pay off the debt in series 1, and find out the debt in series 2\n            newDebt = pool.buyBase(address(baseJoin), amt, max);\n            baseJoin.join(address(baseJoin), amt);                  // Repay the old series debt\n\n            pool.retrieveFYToken(address(fyToken));                 // Get the surplus fyToken\n            fyToken.burn(address(fyToken), (amt * loan) - newDebt);    // Burn the surplus\n        }\n\n        newDebt += ((newSeries.maturity - block.timestamp) * uint256(newDebt).wmul(borrowingFee)).u128();  // Add borrowing fee, also stops users form rolling to a mature series\n\n        return cauldron.roll(vaultId, newSeriesId, newDebt.i128() - balances.art.i128()); // Change the series and debt for the vault\n    }\n\n    // ---- Ladle as a token holder ----\n\n    /// @dev Use fyToken in the Ladle to repay debt.\n    function _repayLadle(bytes12 vaultId, DataTypes.Vault memory vault)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        balances = cauldron.balances(vaultId);\n        \n        uint256 amount = series.fyToken.balanceOf(address(this));\n        amount = amount <= balances.art ? amount : balances.art;\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, 0, -(amount.u128().i128()));\n        series.fyToken.burn(address(this), amount);\n    }\n\n    /// @dev Retrieve any asset or fyToken in the Ladle\n    function _retrieve(bytes6 id, bool isAsset, address to) \n        private\n        returns (uint256 amount)\n    {\n        IERC20 token = IERC20(findToken(id, isAsset));\n        amount = token.balanceOf(address(this));\n        token.safeTransfer(to, amount);\n    }\n\n    // ---- Liquidations ----\n\n    /// @dev Allow liquidation contracts to move assets to wind down vaults\n    function settle(bytes12 vaultId, address user, uint128 ink, uint128 art)\n        external\n        auth\n    {\n        DataTypes.Vault memory vault = getOwnedVault(vaultId);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n\n        cauldron.slurp(vaultId, ink, art);                                                  // Remove debt and collateral from the vault\n\n        if (ink != 0) {                                                                     // Give collateral to the user\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            ilkJoin.exit(user, ink);\n        }\n        if (art != 0) {                                                                     // Take underlying from user\n            IJoin baseJoin = getJoin(series.baseId);\n            baseJoin.join(user, art);\n        }\n    }\n\n    // ---- Permit management ----\n\n    /// @dev From an id, which can be an assetId or a seriesId, find the resulting asset or fyToken\n    function findToken(bytes6 id, bool isAsset)\n        private view returns (address token)\n    {\n        token = isAsset ? cauldron.assets(id) : address(getSeries(id).fyToken);\n        require (token != address(0), \"Token not found\");\n    }\n\n    /// @dev Execute an ERC2612 permit for the selected asset or fyToken\n    function _forwardPermit(bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        IERC2612 token = IERC2612(findToken(id, isAsset));\n        token.permit(msg.sender, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Execute a Dai-style permit for the selected asset or fyToken\n    function _forwardDaiPermit(bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        DaiAbstract token = DaiAbstract(findToken(id, isAsset));\n        token.permit(msg.sender, spender, nonce, deadline, allowed, v, r, s);\n    }\n\n    // ---- Ether management ----\n\n    /// @dev The WETH9 contract will send ether to BorrowProxy on `weth.withdraw` using this function.\n    receive() external payable { }\n\n    /// @dev Accept Ether, wrap it and forward it to the WethJoin\n    /// This function should be called first in a batch, and the Join should keep track of stored reserves\n    /// Passing the id for a join that doesn't link to a contract implemnting IWETH9 will fail\n    function _joinEther(bytes6 etherId)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = address(this).balance;\n        IJoin wethJoin = getJoin(etherId);\n        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo`\n        IERC20(address(weth)).safeTransfer(address(wethJoin), ethTransferred);\n    }\n\n    /// @dev Unwrap Wrapped Ether held by this Ladle, and send the Ether\n    /// This function should be called last in a batch, and the Ladle should have no reason to keep an WETH balance\n    function _exitEther(address payable to)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = weth.balanceOf(address(this));\n        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo`\n        to.safeTransferETH(ethTransferred);\n    }\n\n    // ---- Pool router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function _transferToPool(IPool pool, bool base, uint128 wad)\n        private\n    {\n        IERC20 token = base ? pool.base() : pool.fyToken();\n        token.safeTransferFrom(msg.sender, address(pool), wad);\n    }\n\n    /// @dev Allow users to route calls to a pool, to be used with batch\n    function _route(IPool pool, bytes memory data)\n        private\n        returns (bool success, bytes memory result)\n    {\n        (success, result) = address(pool).call(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n\n    // ---- FYToken router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function _transferToFYToken(IFYToken fyToken, uint256 wad)\n        private\n    {\n        IERC20(fyToken).safeTransferFrom(msg.sender, address(fyToken), wad);\n    }\n\n    /// @dev Allow users to redeem fyToken, to be used with batch.\n    /// If 0 is passed as the amount to redeem, it redeems the fyToken balance of the Ladle instead.\n    function _redeem(IFYToken fyToken, address to, uint256 wad)\n        private\n        returns (uint256)\n    {\n        return fyToken.redeem(to, wad != 0 ? wad : fyToken.balanceOf(address(this)));\n    }\n\n    // ---- Module router ----\n\n    /// @dev Allow users to use functionality coded in a module, to be used with batch\n    function _moduleCall(address module, bytes memory moduleCall)\n        private\n        returns (bool success, bytes memory result)\n    {\n        require (modules[module], \"Unregistered module\");\n        (success, result) = module.delegatecall(moduleCall);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n}\n\n",
        "CodeNames": [
            "Ladle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Ladle",
                "Type": "Violation of implicit constraints",
                "Description": "The Ladle batching of operations is a complex task with implicit constraints on what operations can be bundled together in a batch.",
                "Repair": "Enforce batch operation constraints explicitly in the code along with documentation and onboarding validation"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"./utils/token/ERC20Permit.sol\";\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\n\n\ncontract FYToken is IFYToken, IERC3156FlashLender, AccessControl(), ERC20Permit {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event SeriesMatured(uint256 chiAtMaturity);\n    event Redeemed(address indexed from, address indexed to, uint256 amount, uint256 redeemed);\n    event OracleSet(address indexed oracle);\n\n    bytes32 constant CHI = \"chi\";\n\n    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IOracle public oracle;                                      // Oracle for the savings rate.\n    IJoin public immutable join;                                // Source of redemption funds.\n    address public immutable override underlying;\n    bytes6 public immutable underlyingId;                             // Needed to access the oracle\n    uint256 public immutable override maturity;\n    uint256 public chiAtMaturity = type(uint256).max;           // Spot price (exchange rate) between the base and an interest accruing token at maturity \n\n    constructor(\n        bytes6 underlyingId_,\n        IOracle oracle_, // Underlying vs its interest-bearing version\n        IJoin join_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    ) ERC20Permit(name, symbol, IERC20Metadata(address(IJoin(join_).asset())).decimals()) { // The join asset is this fyToken's underlying, from which we inherit the decimals\n        uint256 now_ = block.timestamp;\n        require(\n            maturity_ > now_ &&\n            maturity_ < now_ + MAX_TIME_TO_MATURITY &&\n            maturity_ < type(uint32).max,\n            \"Invalid maturity\"\n        );\n\n        underlyingId = underlyingId_;\n        join = join_;\n        maturity = maturity_;\n        underlying = address(IJoin(join_).asset());\n        setOracle(oracle_);\n    }\n\n    modifier afterMaturity() {\n        require(\n            uint32(block.timestamp) >= maturity,\n            \"Only after maturity\"\n        );\n        _;\n    }\n\n    modifier beforeMaturity() {\n        require(\n            uint32(block.timestamp) < maturity,\n            \"Only before maturity\"\n        );\n        _;\n    }\n\n    /// @dev Set the oracle parameter\n    function setOracle(IOracle oracle_)\n        public\n        auth    \n    {\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    /// If called more than once, it will revert.\n    function mature()\n        external override\n        afterMaturity\n    {\n        require (chiAtMaturity == type(uint256).max, \"Already matured\");\n        _mature();\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    function _mature() \n        private\n        returns (uint256 _chiAtMaturity)\n    {\n        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);\n        chiAtMaturity = _chiAtMaturity;\n        emit SeriesMatured(_chiAtMaturity);\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    function accrual()\n        external\n        afterMaturity\n        returns (uint256)\n    {\n        return _accrual();\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual()\n        private\n        returns (uint256 accrual_)\n    {\n        if (chiAtMaturity == type(uint256).max) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\n            _mature();\n        } else {\n            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);\n            accrual_ = chi.wdiv(chiAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Burn the fyToken after maturity for an amount that increases according to `chi`\n    function redeem(address to, uint256 amount)\n        external override\n        afterMaturity\n        returns (uint256 redeemed)\n    {\n        _burn(msg.sender, amount);\n        redeemed = amount.wmul(_accrual());\n        join.exit(to, redeemed.u128());\n        \n        emit Redeemed(msg.sender, to, amount, redeemed);\n        return amount;\n    }\n\n    /// @dev Mint fyTokens.\n    function mint(address to, uint256 amount)\n        external override\n        beforeMaturity\n        auth\n    {\n        _mint(to, amount);\n    }\n\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them. \n    function burn(address from, uint256 amount)\n        external override\n        auth\n    {\n        _burn(from, amount);\n    }\n\n    /// @dev Burn fyTokens. \n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\n    function _burn(address from, uint256 amount)\n        internal override\n        returns (bool)\n    {\n        // First use any tokens locked in this contract\n        uint256 available = _balanceOf[address(this)];\n        if (available >= amount) {\n            unchecked { return super._burn(address(this), amount); }\n        } else {\n            if (available > 0 ) super._burn(address(this), available);\n            unchecked { _decreaseAllowance(from, amount - available); }\n            unchecked { return super._burn(from, amount - available); }\n        }\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be a FYDai.\n     * param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        return 0;\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        beforeMaturity\n        returns(bool)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n        _burn(address(receiver), amount);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "FYToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FYToken.sol",
                "Type": "User can redeem more tokens by artificially increasing the chi accrual",
                "Description": "A user can artificially increase the chi accrual (after maturity) by flash borrow on Compound, which affects the exchange rate used by the chi oracle.",
                "Repair": "Make the chi accrual time-weighted to mitigate the manipulation caused by flash borrow and repay"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Uniswap oracle contract",
                "Type": "Uniswap Oracle uses wrong prices",
                "Description": "The Uniswap oracle uses a mock contract with hard-coded prices to retrieve the price, which is not feasible in production.",
                "Repair": "Using cumulativeTicks and applying equation 5.5 from the Uniswap V3 whitepaper to compute the token0 TWAP"
            }
        ]
    }
]