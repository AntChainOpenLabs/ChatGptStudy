[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "startDraw() and redraw() functions",
                "Type": "Rigging the draw",
                "Description": "The draw organizer can rig the draw to favor certain participants by using an underfunded subscription ID to invalidate the assumption of fairness in the random selection process. This can be done by waiting until the redraw cooldown has passed, funding the subscription ID, and then frontrunning the Chainlink TX with a redraw() call if they don't like the response.",
                "Repair": "Enforce a minimum cooldown of 24 hours before allowing redraws"
            },
            {
                "Location": "VRFNFtRandomDraw.sol",
                "Type": "Protocol safeguards for time durations are skewed by a factor of 7",
                "Description": "In VRFNFtRandomDraw.sol initialize(), the MONTH_IN_SECONDS variable is used to validate two values. The issue is that MONTH_IN_SECONDS is calculated incorrectly, multiplies by 7 incorrectly, as it was copied from WEEK_IN_SECONDS. Therefore, actual seconds calculated is equivalent of 7 months.",
                "Repair": "Fix MONTH_IN_SECONDS calculation: uint256 immutable MONTH_IN_SECONDS = (3600 * 24) * 30;"
            },
            {
                "Location": "lastResortTimelockOwnerClaimNFT() function",
                "Type": "Timelock bypass",
                "Description": "The admin can call lastResortTimelockOwnerClaimNFT() before the specified time due to recoverTimelock not being updated properly.",
                "Repair": "Update recoverTimelock for each dice roll and add a recoverBufferTime"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {OwnableUpgradeable} from \"./ownable/OwnableUpgradeable.sol\";\nimport {IERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2, VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/VRFCoordinatorV2.sol\";\n\nimport {IVRFNFTRandomDraw} from \"./interfaces/IVRFNFTRandomDraw.sol\";\nimport {Version} from \"./utils/Version.sol\";\n\n/// @notice VRFNFTRandom Draw with NFT Tickets\n/// @author @isiain\ncontract VRFNFTRandomDraw is\n    IVRFNFTRandomDraw,\n    VRFConsumerBaseV2,\n    OwnableUpgradeable,\n    Version(1)\n{\n    /// @notice Our callback is just setting a few variables, 200k should be more than enough gas.\n    uint32 immutable callbackGasLimit = 200_000;\n    /// @notice Chainlink request confirmations, left at the default\n    uint16 immutable minimumRequestConfirmations = 3;\n    /// @notice Number of words requested in a drawing\n    uint16 immutable wordsRequested = 1;\n\n    /// @dev 60 seconds in a min, 60 mins in an hour\n    uint256 immutable HOUR_IN_SECONDS = 60 * 60;\n    /// @dev 24 hours in a day 7 days in a week\n    uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7);\n    // @dev about 30 days in a month\n    uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n\n\n    /// @notice Reference to chain-specific coordinator contract\n    VRFCoordinatorV2Interface immutable coordinator;\n\n    /// @notice Settings used for the contract.\n    IVRFNFTRandomDraw.Settings public settings;\n\n    /// @notice Details about the current request to chainlink\n    IVRFNFTRandomDraw.CurrentRequest public request;\n\n    /// @dev Save the coordinator to the contract\n    /// @param _coordinator Address for VRF Coordinator V2 Interface\n    constructor(VRFCoordinatorV2Interface _coordinator)\n        VRFConsumerBaseV2(address(_coordinator))\n        initializer\n    {\n        coordinator = _coordinator;\n    }\n\n    /// @notice Getter for request details, does not include picked tokenID\n    /// @return currentChainlinkRequestId Current Chainlink Request ID\n    /// @return hasChosenRandomNumber If the random number for the drawing has been chosen\n    /// @return drawTimelock block.timestamp when a redraw can be issued\n    function getRequestDetails()\n        external\n        view\n        returns (\n            uint256 currentChainlinkRequestId,\n            bool hasChosenRandomNumber,\n            uint256 drawTimelock\n        )\n    {\n        currentChainlinkRequestId = request.currentChainlinkRequestId;\n        hasChosenRandomNumber = request.hasChosenRandomNumber;\n        drawTimelock = request.drawTimelock;\n    }\n\n    /// @notice Initialize the contract with settings and an admin\n    /// @param admin initial admin user\n    /// @param _settings initial settings for draw\n    function initialize(address admin, Settings memory _settings)\n        public\n        initializer\n    {\n        // Set new settings\n        settings = _settings;\n\n        // Check values in memory:\n        if (_settings.drawBufferTime < HOUR_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n        }\n        if (_settings.drawBufferTime > MONTH_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n        }\n\n        if (_settings.recoverTimelock < block.timestamp + WEEK_IN_SECONDS) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n        }\n        if (\n            _settings.recoverTimelock >\n            block.timestamp + (MONTH_IN_SECONDS * 12)\n        ) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n        }\n\n        // If NFT contract address is not a contract\n        if (_settings.token.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.token);\n        }\n\n        // If drawing token is not a contract\n        if (_settings.drawingToken.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.drawingToken);\n        }\n\n        // Validate token range: end needs to be greater than start\n        // and the size of the range needs to be at least 2 (end is exclusive)\n        if (\n            _settings.drawingTokenEndId < _settings.drawingTokenStartId ||\n            _settings.drawingTokenEndId - _settings.drawingTokenStartId < 2\n        ) {\n            revert DRAWING_TOKEN_RANGE_INVALID();\n        }\n\n        // Setup owner as admin\n        __Ownable_init(admin);\n\n        // Emit initialized event for indexing\n        emit InitializedDraw(msg.sender, settings);\n\n        // Get owner of raffled tokenId and ensure the current owner is the admin\n        try\n            IERC721EnumerableUpgradeable(_settings.token).ownerOf(\n                _settings.tokenId\n            )\n        returns (address nftOwner) {\n            // Check if address is the admin address\n            if (nftOwner != admin) {\n                revert DOES_NOT_OWN_NFT();\n            }\n        } catch {\n            revert TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n        }\n    }\n\n    /// @notice Internal function to request entropy\n    function _requestRoll() internal {\n        // Chainlink request cannot be currently in flight.\n        // Request is cleared in re-roll if conditions are correct.\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // If the number has been drawn and\n        if (\n            request.hasChosenRandomNumber &&\n            // Draw timelock not yet used\n            request.drawTimelock != 0 &&\n            request.drawTimelock > block.timestamp\n        ) {\n            revert STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n        }\n\n        // Setup re-draw timelock\n        request.drawTimelock = block.timestamp + settings.drawBufferTime;\n\n        // Request first random round\n        request.currentChainlinkRequestId = coordinator.requestRandomWords({\n            keyHash: settings.keyHash,\n            subId: settings.subscriptionId,\n            minimumRequestConfirmations: minimumRequestConfirmations,\n            callbackGasLimit: callbackGasLimit,\n            numWords: wordsRequested\n        });\n    }\n\n    /// @notice Call this to start the raffle drawing\n    /// @return chainlink request id\n    function startDraw() external onlyOwner returns (uint256) {\n        // Only can be called on first drawing\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // Emit setup draw user event\n        emit SetupDraw(msg.sender, settings);\n\n        // Request initial roll\n        _requestRoll();\n\n        // Attempt to transfer token into this address\n        try\n            IERC721EnumerableUpgradeable(settings.token).transferFrom(\n                msg.sender,\n                address(this),\n                settings.tokenId\n            )\n        {} catch {\n            revert TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n        }\n\n        // Return the current chainlink request id\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Call this to re-draw the raffle\n    /// @return chainlink request ID\n    /// @dev Only callable by the owner\n    function redraw() external onlyOwner returns (uint256) {\n        if (request.drawTimelock >= block.timestamp) {\n            revert TOO_SOON_TO_REDRAW();\n        }\n\n        // Reset request\n        delete request;\n\n        // Re-roll\n        _requestRoll();\n\n        // Owner of token to raffle needs to be this contract\n        if (\n            IERC721EnumerableUpgradeable(settings.token).ownerOf(\n                settings.tokenId\n            ) != address(this)\n        ) {\n            revert DOES_NOT_OWN_NFT();\n        }\n\n        // Return current chainlink request ID\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Function called by chainlink to resolve random words\n    /// @param _requestId ID of request sent to chainlink VRF\n    /// @param _randomWords List of uint256 words of random entropy\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        // Validate request ID\n        if (_requestId != request.currentChainlinkRequestId) {\n            revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n        }\n\n        // Validate number of words returned\n        // Words requested is an immutable set to 1\n        if (_randomWords.length != wordsRequested) {\n            revert WRONG_LENGTH_FOR_RANDOM_WORDS();\n        }\n\n        // Set request details\n        request.hasChosenRandomNumber = true;\n\n        // Get total token range\n        uint256 tokenRange = settings.drawingTokenEndId -\n            settings.drawingTokenStartId;\n\n        // Store a number from it here (reduce number here to reduce gas usage)\n        // We know there will only be 1 word sent at this point.\n        request.currentChosenTokenId =\n            (_randomWords[0] % tokenRange) +\n            settings.drawingTokenStartId;\n\n        // Emit completed event.\n        emit DiceRollComplete(msg.sender, request);\n    }\n\n    /// @notice Function to determine if the user has won in the current drawing\n    /// @param user address for the user to check if they have won in the current drawing\n    function hasUserWon(address user) public view returns (bool) {\n        if (!request.hasChosenRandomNumber) {\n            revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n        }\n\n        return\n            user ==\n            IERC721EnumerableUpgradeable(settings.drawingToken).ownerOf(\n                request.currentChosenTokenId\n            );\n    }\n\n    /// @notice Function for the winner to call to retrieve their NFT\n    function winnerClaimNFT() external {\n        // Assume (potential) winner calls this fn, cache.\n        address user = msg.sender;\n\n        // Check if this user has indeed won.\n        if (!hasUserWon(user)) {\n            revert USER_HAS_NOT_WON();\n        }\n\n        // Emit a celebratory event\n        emit WinnerSentNFT(\n            user,\n            address(settings.token),\n            settings.tokenId,\n            settings\n        );\n\n        // Transfer token to the winter.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            msg.sender,\n            settings.tokenId\n        );\n    }\n\n    /// @notice Optional last resort admin reclaim nft function\n    /// @dev Only callable by the owner\n    function lastResortTimelockOwnerClaimNFT() external onlyOwner {\n        // If recoverTimelock is not setup, or if not yet occurred\n        if (settings.recoverTimelock > block.timestamp) {\n            // Stop the withdraw\n            revert RECOVERY_IS_NOT_YET_POSSIBLE();\n        }\n\n        // Send event for indexing that the owner reclaimed the NFT\n        emit OwnerReclaimedNFT(owner());\n\n        // Transfer token to the admin/owner.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            owner(),\n            settings.tokenId\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console2.sol\";\n\nimport {VRFCoordinatorV2Mock} from \"@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol\";\nimport {VRFCoordinatorV2} from \"@chainlink/contracts/src/v0.8/VRFCoordinatorV2.sol\";\nimport {VRFNFTRandomDraw} from \"../src/VRFNFTRandomDraw.sol\";\nimport {VRFNFTRandomDrawFactory} from \"../src/VRFNFTRandomDrawFactory.sol\";\n\nimport {IOwnableUpgradeable} from \"../src/ownable/IOwnableUpgradeable.sol\";\n\nimport {IERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {IVRFNFTRandomDraw} from \"../src/interfaces/IVRFNFTRandomDraw.sol\";\nimport {IVRFNFTRandomDrawFactory} from \"../src/interfaces/IVRFNFTRandomDrawFactory.sol\";\n\nimport {MockNFT} from \"./mocks/MockNFT.sol\";\nimport {MockERC20} from \"./mocks/MockERC20.sol\";\n\ncontract VRFNFTRandomDrawTest is Test {\n    MockNFT targetNFT;\n    MockNFT drawingNFT;\n    MockERC20 linkTokens;\n    VRFNFTRandomDrawFactory factory;\n\n    VRFCoordinatorV2Mock mockCoordinator;\n\n    address user = address(0x2134);\n    address admin = address(0x0132);\n\n    uint64 subscriptionId;\n\n    VRFNFTRandomDraw currentDraw;\n\n    function setUp() public {\n        vm.label(user, \"USER\");\n        vm.label(admin, \"ADMIN\");\n\n        subscriptionId = 1337;\n\n        targetNFT = new MockNFT(\"target\", \"target\");\n        vm.label(address(targetNFT), \"TargetNFT\");\n        drawingNFT = new MockNFT(\"drawing\", \"drawing\");\n        vm.label(address(drawingNFT), \"DrawingNFT\");\n        linkTokens = new MockERC20(\"link\", \"link\");\n        vm.label(address(linkTokens), \"LINK\");\n\n        mockCoordinator = new VRFCoordinatorV2Mock(0.1 ether, 1000);\n\n        VRFNFTRandomDraw drawImpl = new VRFNFTRandomDraw(mockCoordinator);\n        // Unproxied/unowned factory\n        factory = new VRFNFTRandomDrawFactory(address(drawImpl));\n\n        vm.prank(admin);\n        subscriptionId = mockCoordinator.createSubscription();\n    }\n\n    function test_Version() public {\naddress sender = address(0x994);\n        IVRFNFTRandomDraw.Settings memory settings;\n        settings.drawBufferTime = 6000;\n        settings.recoverTimelock = 2 weeks;\n        settings.token = address(targetNFT);\n        settings.tokenId = 0;\n        settings.drawingTokenStartId = 0;\n        settings.drawingTokenEndId = 2;\n        settings.drawingToken = address(drawingNFT);\n        settings.subscriptionId = subscriptionId;\n\n        vm.prank(sender);\n        targetNFT.mint();\n\n        vm.prank(sender);\n        VRFNFTRandomDraw draw = VRFNFTRandomDraw(factory.makeNewDraw(settings));\n        assertEq(draw.contractVersion(), 1);\n    }\n\n    function test_InvalidOptionTime() public {\n        IVRFNFTRandomDraw.Settings memory settings;\n        settings.drawBufferTime = 0;\n        // invalid time for drawing\n        vm.expectRevert(\n            IVRFNFTRandomDraw\n                .REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR\n                .selector\n        );\n        factory.makeNewDraw(settings);\n\n        // fix this issue\n        settings.drawBufferTime = 2 hours;\n        settings.recoverTimelock = block.timestamp + 1000;\n        \n        // recovery timelock too soon\n        vm.expectRevert(\n            IVRFNFTRandomDraw\n                .RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK\n                .selector\n        );\n        factory.makeNewDraw(settings);\n\n        // fix recovery issue\n        settings.drawBufferTime = 2 hours;\n        settings.recoverTimelock = 2 weeks;\n        \n        vm.expectRevert(\n            abi.encodeWithSelector(IVRFNFTRandomDraw.TOKEN_NEEDS_TO_BE_A_CONTRACT.selector, address(0x0))\n        );\n        factory.makeNewDraw(settings);\n    }\n\n    function test_InvalidRecoverTimelock() public {\n        VRFNFTRandomDraw.Settings memory settings;\n        settings.drawBufferTime = 6000;\n        settings.recoverTimelock = 1000;\n        // recovery timelock too soon\n        vm.expectRevert(\n            IVRFNFTRandomDraw\n                .RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK\n                .selector\n        );\n        factory.makeNewDraw(settings);\n    }\n\n    function test_ZeroTokenContract() public {\n        VRFNFTRandomDraw.Settings memory settings;\n        settings.drawBufferTime = 6000;\n        settings.recoverTimelock = block.timestamp + 604800;\n        // Token is not a contract\n        vm.expectRevert(abi.encodeWithSelector(IVRFNFTRandomDraw.TOKEN_NEEDS_TO_BE_A_CONTRACT.selector, address(0x0)));\n        factory.makeNewDraw(settings);\n    }\n\n    function test_NoTokenOwner() public {\n        VRFNFTRandomDraw.Settings memory settings;\n        settings.drawBufferTime = 6000;\n        settings.recoverTimelock = 2 weeks;\n        settings.token = address(targetNFT);\n        settings.drawingTokenStartId = 0;\n        settings.drawingTokenEndId = 4;\n        settings.drawingToken = address(drawingNFT);\n\n        // recovery timelock too soon\n        vm.expectRevert(IVRFNFTRandomDraw.TOKEN_BEING_OFFERED_NEEDS_TO_EXIST.selector);\n        factory.makeNewDraw(settings);\n    }\n\n    function test_BadDrawingRange() public {\n        address sender = address(0x994);\n        vm.startPrank(sender);\n        IVRFNFTRandomDraw.Settings memory settings;\n        settings.drawBufferTime = 6000;\n        settings.recoverTimelock = 2 weeks;\n        settings.token = address(targetNFT);\n        settings.drawingToken = address(drawingNFT);\n        settings.tokenId = 0;\n        settings.drawingTokenStartId = 2;\n        targetNFT.mint();\n\n        // recovery timelock too soon\n        vm.expectRevert(IVRFNFTRandomDraw.DRAWING_TOKEN_RANGE_INVALID.selector);\n        factory.makeNewDraw(settings);\n    }\n\n    function test_TokenNotApproved() public {\n       address sender = address(0x994);\n        IVRFNFTRandomDraw.Settings memory settings;\n        settings.drawBufferTime = 6000;\n        settings.recoverTimelock = 2 weeks;\n        settings.token = address(targetNFT);\n        settings.tokenId = 0;\n        settings.drawingTokenStartId = 0;\n        settings.drawingTokenEndId = 2;\n        settings.drawingToken = address(drawingNFT);\n        settings.subscriptionId = subscriptionId;\n\n        vm.prank(sender);\n        targetNFT.mint();\n\n        vm.prank(sender);\n        IVRFNFTRandomDraw draw = VRFNFTRandomDraw(factory.makeNewDraw(settings));\n\n        vm.prank(admin);\n        mockCoordinator.addConsumer(subscriptionId, address(draw));\n        vm.prank(admin);\n        mockCoordinator.fundSubscription(subscriptionId, 100 ether);\n\n        // Token needs to be approved\n        vm.expectRevert(IVRFNFTRandomDraw.TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT.selector);\n        vm.prank(sender);\n        draw.startDraw();\n    }\n\n    function test_CannotRerollInFlight() public {\n        address winner = address(0x1337);\n        vm.label(winner, \"winner\");\n\n        vm.startPrank(winner);\n        for (uint256 tokensCount = 0; tokensCount < 10; tokensCount++) {\n            drawingNFT.mint();\n        }\n        vm.stopPrank();\n\n        vm.startPrank(admin);\n        targetNFT.mint();\n\n        address consumerAddress = factory.makeNewDraw(\n            IVRFNFTRandomDraw.Settings({\n                token: address(targetNFT),\n                tokenId: 0,\n                drawingToken: address(drawingNFT),\n                drawingTokenStartId: 0,\n                drawingTokenEndId: 10,\n                drawBufferTime: 1 hours,\n                recoverTimelock: 2 weeks,\n                keyHash: bytes32(\n                    0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15\n                ),\n                subscriptionId: subscriptionId\n            })\n        );\n        vm.label(consumerAddress, \"drawing instance\");\n\n        mockCoordinator.addConsumer(subscriptionId, consumerAddress);\n        mockCoordinator.fundSubscription(subscriptionId, 100 ether);\n\n        VRFNFTRandomDraw drawing = VRFNFTRandomDraw(consumerAddress);\n\n        vm.expectRevert(IVRFNFTRandomDraw.TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT.selector);\n        drawing.startDraw();\n\n        targetNFT.setApprovalForAll(consumerAddress, true);\n\n        uint256 drawingId = drawing.startDraw();\n\n        vm.expectRevert(IVRFNFTRandomDraw.REQUEST_IN_FLIGHT.selector);\n        drawing.startDraw();\n    }\n\n\n    function test_ValidateRequestID() public {\n        address winner = address(0x1337);\n        vm.label(winner, \"winner\");\n\n        vm.startPrank(winner);\n        for (uint256 tokensCount = 0; tokensCount < 10; tokensCount++) {\n            drawingNFT.mint();\n        }\n        vm.stopPrank();\n\n        vm.startPrank(admin);\n        targetNFT.mint();\n\n        address consumerAddress = factory.makeNewDraw(\n            IVRFNFTRandomDraw.Settings({\n                token: address(targetNFT),\n                tokenId: 0,\n                drawingToken: address(drawingNFT),\n                drawingTokenStartId: 0,\n                drawingTokenEndId: 10,\n                drawBufferTime: 1 hours,\n                recoverTimelock: 2 weeks,\n                keyHash: bytes32(\n                    0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15\n                ),\n                subscriptionId: subscriptionId\n            })\n        );\n        vm.label(consumerAddress, \"drawing instance\");\n\n        mockCoordinator.addConsumer(subscriptionId, consumerAddress);\n        mockCoordinator.fundSubscription(subscriptionId, 100 ether);\n\n        vm.stopPrank();\n        vm.prank(consumerAddress);\n        uint256 otherRequestId = VRFCoordinatorV2(address(mockCoordinator)).requestRandomWords({\n            keyHash: bytes32(0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15),\n            subId: subscriptionId,\n            requestConfirmations: uint16(1),\n            callbackGasLimit: 100000,\n            numWords: 3\n        });\n\n        vm.startPrank(admin);\n\n        VRFNFTRandomDraw drawing = VRFNFTRandomDraw(consumerAddress);\n\n        targetNFT.setApprovalForAll(consumerAddress, true);\n\n        uint256 drawingId = drawing.startDraw();\n\n        mockCoordinator.fulfillRandomWords(otherRequestId, consumerAddress);\n        (uint256 requestId, bool hasChosenNumber, ) = drawing.getRequestDetails();\n        assert(!hasChosenNumber);\n\n        mockCoordinator.fulfillRandomWords(drawingId, consumerAddress);\n        (requestId, hasChosenNumber, ) = drawing.getRequestDetails();\n        assert(hasChosenNumber);\n\n        assertTrue(drawing.hasUserWon(winner));\n    }\n\n    function test_FullDrawing() public {\n        address winner = address(0x1337);\n        vm.label(winner, \"winner\");\n\n        vm.startPrank(winner);\n        for (uint256 tokensCount = 0; tokensCount < 10; tokensCount++) {\n            drawingNFT.mint();\n        }\n        vm.stopPrank();\n\n        vm.startPrank(admin);\n        targetNFT.mint();\n\n        address consumerAddress = factory.makeNewDraw(\n            IVRFNFTRandomDraw.Settings({\n                token: address(targetNFT),\n                tokenId: 0,\n                drawingToken: address(drawingNFT),\n                drawingTokenStartId: 0,\n                drawingTokenEndId: 10,\n                drawBufferTime: 1 hours,\n                recoverTimelock: 2 weeks,\n                keyHash: bytes32(\n                    0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15\n                ),\n                subscriptionId: subscriptionId\n            })\n        );\n        vm.label(consumerAddress, \"drawing instance\");\n\n        mockCoordinator.addConsumer(subscriptionId, consumerAddress);\n        mockCoordinator.fundSubscription(subscriptionId, 100 ether);\n\n        VRFNFTRandomDraw drawing = VRFNFTRandomDraw(consumerAddress);\n\n        targetNFT.setApprovalForAll(consumerAddress, true);\n\n        uint256 drawingId = drawing.startDraw();\n\n        mockCoordinator.fulfillRandomWords(drawingId, consumerAddress);\n\n        vm.stopPrank();\n\n        assertEq(targetNFT.balanceOf(winner), 0);\n        assertEq(targetNFT.balanceOf(consumerAddress), 1);\n\n        // should be able to call nft\n        vm.prank(winner);\n        drawing.winnerClaimNFT();\n        assertEq(targetNFT.balanceOf(winner), 1);\n        assertEq(targetNFT.balanceOf(consumerAddress), 0);\n    }\n\n    function test_DrawingUserCheck() public {\n        address winner = address(0x1337);\n        vm.label(winner, \"winner\");\n\n        vm.startPrank(winner);\n        for (uint256 tokensCount = 0; tokensCount < 10; tokensCount++) {\n            drawingNFT.mint();\n        }\n        vm.stopPrank();\n\n        vm.startPrank(admin);\n        targetNFT.mint();\n\n        address consumerAddress = factory.makeNewDraw(\n            IVRFNFTRandomDraw.Settings({\n                token: address(targetNFT),\n                tokenId: 0,\n                drawingToken: address(drawingNFT),\n                drawingTokenStartId: 0,\n                drawingTokenEndId: 10,\n                drawBufferTime: 1 hours,\n                recoverTimelock: 2 weeks,\n                keyHash: bytes32(\n                    0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15\n                ),\n                subscriptionId: subscriptionId\n            })\n        );\n        vm.label(consumerAddress, \"drawing instance\");\n\n        mockCoordinator.addConsumer(subscriptionId, consumerAddress);\n        mockCoordinator.fundSubscription(subscriptionId, 100 ether);\n\n        VRFNFTRandomDraw drawing = VRFNFTRandomDraw(consumerAddress);\n\n        targetNFT.setApprovalForAll(consumerAddress, true);\n\n        uint256 drawingId = drawing.startDraw();\n\n        mockCoordinator.fulfillRandomWords(drawingId, consumerAddress);\n\n        (, , uint256 drawTimelock) = drawing.getRequestDetails();\n        assertEq(drawTimelock, 3601);\n        assertEq(block.timestamp, 1);\n\n        vm.expectRevert(IVRFNFTRandomDraw.TOO_SOON_TO_REDRAW.selector);\n        drawing.redraw();\n\n        vm.warp(2 hours);\n\n        drawingId = drawing.redraw();\n\n        mockCoordinator.fulfillRandomWords(drawingId, consumerAddress);\n\n        vm.warp(30 days);\n\n        assertEq(targetNFT.balanceOf(admin), 0);\n        assertEq(targetNFT.balanceOf(consumerAddress), 1);\n\n        drawing.lastResortTimelockOwnerClaimNFT();\n\n        // should be able to call nft\n        assertEq(targetNFT.balanceOf(admin), 1);\n        assertEq(targetNFT.balanceOf(consumerAddress), 0);\n    }\n\n    function test_LoserCannotWithdraw() public {\n        address winner = address(0x1337);\n        vm.label(winner, \"winner\");\n\n        address loser = address(0x019);\n        vm.label(loser, \"loser\");\n\n        vm.startPrank(winner);\n        for (uint256 tokensCount = 0; tokensCount < 10; tokensCount++) {\n            drawingNFT.mint();\n        }\n        vm.stopPrank();\n\n        vm.startPrank(loser);\n        for (uint256 tokensCount = 0; tokensCount < 80; tokensCount++) {\n            drawingNFT.mint();\n        }\n        vm.stopPrank();\n\n        vm.startPrank(admin);\n        targetNFT.mint();\n\n        address consumerAddress = factory.makeNewDraw(\n            IVRFNFTRandomDraw.Settings({\n                token: address(targetNFT),\n                tokenId: 0,\n                drawingToken: address(drawingNFT),\n                drawingTokenStartId: 0,\n                drawingTokenEndId: 10,\n                drawBufferTime: 1 hours,\n                recoverTimelock: 2 weeks,\n                keyHash: bytes32(\n                    0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15\n                ),\n                subscriptionId: subscriptionId\n            })\n        );\n        vm.label(consumerAddress, \"drawing instance\");\n\n        mockCoordinator.addConsumer(subscriptionId, consumerAddress);\n        mockCoordinator.fundSubscription(subscriptionId, 100 ether);\n\n        VRFNFTRandomDraw drawing = VRFNFTRandomDraw(consumerAddress);\n\n        vm.stopPrank();\n\n        vm.prank(loser);\n        vm.expectRevert(IVRFNFTRandomDraw.NEEDS_TO_HAVE_CHOSEN_A_NUMBER.selector);\n        drawing.winnerClaimNFT();\n\n        vm.prank(admin);\n        targetNFT.setApprovalForAll(consumerAddress, true);\n\n        vm.prank(admin);\n        uint256 drawingId = drawing.startDraw();\n\n        vm.prank(loser);\n        vm.expectRevert();\n        drawing.winnerClaimNFT();\n\n        mockCoordinator.fulfillRandomWords(drawingId, consumerAddress);\n\n        vm.prank(loser);\n        vm.expectRevert();\n        drawing.winnerClaimNFT();\n\n        vm.prank(winner);\n        drawing.winnerClaimNFT();\n\n        assertEq(targetNFT.balanceOf(admin), 0);\n        assertEq(targetNFT.balanceOf(winner), 1);\n\n        vm.prank(loser);\n        vm.expectRevert(IOwnableUpgradeable.ONLY_OWNER.selector);\n        drawing.lastResortTimelockOwnerClaimNFT();\n\n        // should be able to call nft\n        assertEq(targetNFT.balanceOf(admin), 0);\n        assertEq(targetNFT.balanceOf(winner), 1);\n    }\n\n    function test_NFTNotApproved() public {\n        address winner = address(0x1337);\n        vm.label(winner, \"winner\");\n\n        vm.startPrank(winner);\n        for (uint256 tokensCount = 0; tokensCount < 10; tokensCount++) {\n            drawingNFT.mint();\n        }\n        vm.stopPrank();\n\n        vm.startPrank(admin);\n        targetNFT.mint();\n\n        address consumerAddress = factory.makeNewDraw(\n            IVRFNFTRandomDraw.Settings({\n                token: address(targetNFT),\n                tokenId: 0,\n                drawingToken: address(drawingNFT),\n                drawingTokenStartId: 0,\n                drawingTokenEndId: 10,\n                drawBufferTime: 1 hours,\n                recoverTimelock: 2 weeks,\n                keyHash: bytes32(\n                    0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15\n                ),\n                subscriptionId: subscriptionId\n            })\n        );\n        vm.label(consumerAddress, \"drawing instance\");\n\n        mockCoordinator.addConsumer(subscriptionId, consumerAddress);\n        mockCoordinator.fundSubscription(subscriptionId, 100 ether);\n\n        VRFNFTRandomDraw drawing = VRFNFTRandomDraw(consumerAddress);\n\n        vm.expectRevert();\n        uint256 drawingId = drawing.startDraw();\n    }\n}\n\n\n",
        "CodeNames": [
            "VRFNFTRandomDraw.sol",
            "VRFNFTRandomDraw.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VRFNFTRandomDraw.sol",
                "Type": "Raffle creator might not start raffle draw",
                "Description": "The raffle creator is not required to actually give the NFT away. The NFT that is used for the raffle is transferred to the contract when startDraw is executed. Before that, the NFT is in the hands of the creator.",
                "Repair": "Transfer the NFT to the contract at the time of creation of the raffle. Add a check in lastResortTimelockOwnerClaimNFT if a winner was drawn. Allow anyone to execute startDraw function, but limit the time window of when startDraw can be executed. Introduce a new state variable firstDrawTime that acts as a timestamp after which drawing can happen. Add a role that has the power to change the VRF subscription or restore the NFT in cases where the winner is not picked in reasonable time."
            },
            {
                "Location": "VRFNFTRandomDraw.sol",
                "Type": "VRFNFTRandomDraw admin can prevent created or started raffle from taking place",
                "Description": "The admin/owner of VRFNFTRandomDraw can start a raffle, including emitting the SetupDraw event, but in a way that ensures fulfillRandomWords() is never called.",
                "Repair": "Ensure that keyHash is validated within coordinator.requestRandomWords(). Ensure that the owner-provided chain.link VRF subscription has sufficient funds to pay at the time the oracle attempts to supply random values in fulfillRandomWords()."
            }
        ]
    }
]