[
    {
        "Code": "pragma solidity ^0.8.13;\n\nimport \"forge-std/console.sol\";\n\nimport { MockLiquidStakingManager } from \"../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol\";\nimport { MockSavETHVault } from \"../../contracts/testing/liquid-staking/MockSavETHVault.sol\";\nimport { LPTokenFactory } from \"../../contracts/liquid-staking/LPTokenFactory.sol\";\nimport { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SyndicateMock } from \"../../contracts/testing/syndicate/SyndicateMock.sol\";\nimport { MockBrandNFT } from \"../../contracts/testing/stakehouse/MockBrandNFT.sol\";\nimport { MockLSDNFactory } from \"../../contracts/testing/liquid-staking/MockLSDNFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../../contracts/smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { SavETHVaultDeployer } from \"../../contracts/liquid-staking/SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"../../contracts/liquid-staking/StakingFundsVaultDeployer.sol\";\nimport { OptionalGatekeeperFactory } from \"../../contracts/liquid-staking/OptionalGatekeeperFactory.sol\";\nimport { TestUtils } from \"../utils/TestUtils.sol\";\n\ncontract SavETHVaultTest is TestUtils {\n\n    LPTokenFactory tokenFactory;\n    MockLiquidStakingManager liquidStakingManager;\n\n    function setUp() public {\n        vm.startPrank(accountFive); // this will mean it gets dETH initial supply\n        factory = createMockLSDNFactory();\n        vm.stopPrank();\n\n        liquidStakingManager = deployDefaultLiquidStakingNetwork(factory, admin);\n\n        savETHVault = MockSavETHVault(address(liquidStakingManager.savETHVault()));\n        assertEq(savETHVault.dETHToken().balanceOf(accountFive), 125_000 ether);\n    }\n\n    function testSetupWasSuccessful() public {\n        assertEq(address(savETHVault.accountMan()), factory.accountMan()); // to ensure dependency injection is correct\n        assertEq(savETHVault.dETHToken().balanceOf(accountFive), 125_000 ether);\n        assertEq(savETHVault.indexOwnedByTheVault(), 1);\n        assertEq(savETHVault.numberOfLPTokensIssued(), 0);\n    }\n\n    function testDepositETHForStakingRevertsWhenInitialsNotRegisteredForBLSKey() public {\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n        vm.expectRevert(\"Lifecycle status must be one\");\n        savETHVault.depositETHForStaking{value: 0}(blsPubKeyOne, 0);\n    }\n\n    function testDepositETHForStakingRevertsWhenAmountIsZero() public {\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n        vm.expectRevert(\"Min amount not reached\");\n        savETHVault.depositETHForStaking{value: 0}(blsPubKeyOne, 0);\n    }\n\n    function testDepositETHForStakingRevertsWhenAmountDoesNotMatchValue() public {\n        vm.deal(accountOne, 5 ether);\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        vm.startPrank(accountOne);\n        vm.expectRevert(\"Must provide correct amount of ETH\");\n        savETHVault.depositETHForStaking{value: 5}(blsPubKeyOne, 2 ether);\n        vm.stopPrank();\n    }\n\n    function testFirstDepositDeploysAnLPToken() public {\n        uint256 stakeAmount = 24 ether;\n        vm.deal(accountOne, stakeAmount);\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n\n        LPToken token = savETHVault.lpTokenForKnot(blsPubKeyOne);\n        assertEq(token.balanceOf(accountOne), stakeAmount);\n        assertEq(accountOne.balance, 0);\n        assertEq(savETHVault.KnotAssociatedWithLPToken(token), blsPubKeyOne);\n        assertEq(savETHVault.numberOfLPTokensIssued(), 1);\n    }\n\n    // Fuzz deposits\n    function testFirstDepositsForKnotAreBetweenOneAndTwentyFour(uint256 stakeAmount) public {\n        vm.assume(stakeAmount >= 0.001 ether);\n        vm.assume(stakeAmount <= 24 ether);\n        vm.deal(accountOne, stakeAmount);\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n\n        LPToken token = savETHVault.lpTokenForKnot(blsPubKeyOne);\n        assertEq(token.balanceOf(accountOne), stakeAmount);\n        assertEq(accountOne.balance, 0);\n        assertEq(savETHVault.KnotAssociatedWithLPToken(token), blsPubKeyOne);\n        assertEq(savETHVault.numberOfLPTokensIssued(), 1);\n    }\n\n    function testSecondDepositForKnotMintsSameLP() public {\n        uint256 stakeAmount = 12 ether;\n        vm.deal(accountOne, stakeAmount);\n\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n\n        LPToken token = savETHVault.lpTokenForKnot(blsPubKeyOne);\n        assertEq(token.balanceOf(accountOne), stakeAmount);\n\n        vm.deal(accountTwo, stakeAmount);\n        vm.prank(accountTwo);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n        assertEq(token.balanceOf(accountOne), stakeAmount);\n        assertEq(token.balanceOf(accountTwo), stakeAmount);\n        assertEq(token.totalSupply(), stakeAmount * 2);\n        assertEq(savETHVault.numberOfLPTokensIssued(), 1);\n\n        // try staking again and expect revert\n        vm.deal(accountOne, stakeAmount);\n        vm.expectRevert(\"Amount exceeds the staking limit for the validator\");\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n    }\n\n    function testBurnLPRevertsWhenAmountIsZero() public {\n        vm.expectRevert(\"Amount cannot be zero\");\n        savETHVault.burnLPToken(LPToken(address(0)), 0);\n    }\n\n    function testBurnLPRevertsWhenBalanceIsZero() public {\n        uint256 stakeAmount = 12 ether;\n        vm.deal(accountOne, stakeAmount);\n\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n\n        LPToken token = savETHVault.lpTokenForKnot(blsPubKeyOne);\n\n        vm.expectRevert(\"Not enough balance\");\n        savETHVault.burnLPToken(token, 14 ether);\n    }\n\n    function testBurnLPRevertsWhenETHIsStaked() public {\n        uint256 stakeAmount = 12 ether;\n        vm.deal(accountOne, stakeAmount);\n\n        // set BLS lifecycle to initials registered\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n\n        LPToken token = savETHVault.lpTokenForKnot(blsPubKeyOne);\n\n        // set BLS lifecycle to deposited\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 2);\n\n        vm.expectRevert(\"Cannot burn LP tokens\");\n        vm.prank(accountOne);\n        savETHVault.burnLPToken(token, stakeAmount);\n    }\n\n    function testBurnLPBeforeETHIsStaked() public {\n        uint256 stakeAmount = 12 ether;\n        vm.deal(accountOne, stakeAmount);\n\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n\n        LPToken token = savETHVault.lpTokenForKnot(blsPubKeyOne);\n\n        // Fast forward time 3 hours ahead to allow for ETH withrawal\n        vm.warp(block.timestamp + 3 hours);\n\n        assertEq(accountOne.balance, 0);\n\n        vm.startPrank(accountOne);\n        savETHVault.burnLPToken(token, stakeAmount);\n        vm.stopPrank();\n\n        assertEq(accountOne.balance, stakeAmount);\n    }\n\n    function testWithdrawETHForStakingRevertsWhenNotManager() public {\n        vm.expectRevert(\"Not the savETH vault manager\");\n        savETHVault.withdrawETHForStaking(accountOne, 24 ether);\n    }\n\n    function testWithdrawETHForStakingRevertsWhenAmountIsZero() public {\n        vm.prank(address(liquidStakingManager));\n        vm.expectRevert(\"Amount cannot be less than 24 ether\");\n        savETHVault.withdrawETHForStaking(accountOne, 22 ether);\n    }\n\n    function testWithdrawETHForStakingWorksAsExpected() public {\n        MockLiquidStakingManager newLiquidStakingManager = MockLiquidStakingManager(payable(factory.deployNewMockLiquidStakingDerivativeNetwork(\n                admin,\n                true,\n                \"LSD\"\n            )));\n\n        MockSavETHVault savETHVault2 = MockSavETHVault(address(newLiquidStakingManager.savETHVault()));\n\n        uint256 stakeAmount = 24 ether;\n\n        address savETHVaultAddress = address(savETHVault2);\n        assertEq(savETHVaultAddress.balance, 0);\n\n        vm.deal(savETHVaultAddress, stakeAmount);\n\n        address lsm = address(newLiquidStakingManager);\n        assertEq(lsm.balance, 0);\n        assertEq(savETHVaultAddress.balance, stakeAmount);\n        assertEq(lsm, address(savETHVault2.liquidStakingManager()));\n\n        assertEq(accountTwo.balance, 0);\n\n        vm.prank(lsm);\n        savETHVault2.withdrawETHForStaking(accountTwo, stakeAmount);\n\n        assertEq(accountTwo.balance, stakeAmount);\n        assertEq(savETHVaultAddress.balance, 0);\n    }\n\n    function testBurnLPForDerivativeETHFromStakehouseAfterKnotFormation() public {\n        // First supply ETH when validator is at initials registered phase\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        uint256 stakeAmount = 24 ether;\n        vm.deal(accountOne, stakeAmount);\n\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n\n        LPToken lp = savETHVault.lpTokenForKnot(blsPubKeyOne);\n\n        // Move lifecycle straight to tokens minted i.e. knot has been created and savETH added to vault\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 3);\n\n        // send dETH to the vault as if the vault has withdrawn\n        IERC20 dETHToken = savETHVault.dETHToken();\n        assertEq(dETHToken.balanceOf(accountFive), 125_000 ether);\n        vm.startPrank(accountFive);\n        dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether);\n        vm.stopPrank();\n        assertEq(dETHToken.balanceOf(address(savETHVault.saveETHRegistry())), 24 ether);\n        assertEq(dETHToken.balanceOf(accountOne), 0);\n\n        assertEq(lp.balanceOf(accountOne), 24 ether);\n        vm.prank(accountOne);\n        savETHVault.burnLPToken(lp, stakeAmount);\n        assertEq(dETHToken.balanceOf(accountOne), 24 ether);\n        assertEq(lp.balanceOf(accountOne), 0);\n\n        (uint256 balance, bool withdrawn) = savETHVault.dETHForKnot(blsPubKeyOne);\n        assertEq(withdrawn, true);\n        assertEq(balance, 24 ether);\n    }\n\n    function testBurnLPForDerivativeETHFromStakehouseAfterKnotFormationAndBalIncrease() public {\n        // First supply ETH when validator is at initials registered phase\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 1);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n\n        uint256 stakeAmount = 24 ether;\n        vm.deal(accountOne, stakeAmount);\n\n        vm.prank(accountOne);\n        savETHVault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n\n        LPToken lp = savETHVault.lpTokenForKnot(blsPubKeyOne);\n\n        // Move lifecycle straight to tokens minted i.e. knot has been created and savETH added to vault\n        savETHVault.accountMan().setLifecycleStatus(blsPubKeyOne, 3);\n\n        // send dETH to the vault as if the vault has withdrawn\n        IERC20 dETHToken = savETHVault.dETHToken();\n        vm.startPrank(accountFive);\n        dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24.1 ether);\n        vm.stopPrank();\n        assertEq(dETHToken.balanceOf(address(savETHVault.saveETHRegistry())), 24.1 ether);\n        assertEq(dETHToken.balanceOf(accountOne), 0);\n\n        savETHVault.saveETHRegistry().setBalInIndex(1, blsPubKeyOne, 24.1 ether);\n\n        assertEq(lp.balanceOf(accountOne), 24 ether);\n        vm.prank(accountOne);\n        savETHVault.burnLPToken(lp, stakeAmount);\n        assertEq(dETHToken.balanceOf(accountOne), 24.1 ether);\n        assertEq(lp.balanceOf(accountOne), 0);\n\n        (uint256 balance, bool withdrawn) = savETHVault.dETHForKnot(blsPubKeyOne);\n        assertEq(withdrawn, true);\n        assertEq(balance, 24.1 ether);\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\n\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\n\ncontract SavETHVault is Initializable, ETHPoolLPFactory, ReentrancyGuard {\n\n    /// @notice signalize transfer of dETH to depositor\n    event DETHRedeemed(address depositor, uint256 amount);\n\n    /// @notice signalize withdrawal of ETH for staking\n    event ETHWithdrawnForStaking(address withdrawalAddress, address liquidStakingManager, uint256 amount);\n\n    /// @notice Liquid staking manager instance\n    ILiquidStakingManager public liquidStakingManager;\n\n    /// @notice index id of the savETH index owned by the vault\n    uint256 public indexOwnedByTheVault;\n\n    /// @notice dETH related details for a KNOT\n    /// @dev If dETH is not withdrawn, then for a non-existing dETH balance\n    /// the structure would result in zero balance even though dETH isn't withdrawn for KNOT\n    /// withdrawn parameter tracks the status of dETH for a KNOT\n    struct KnotDETHDetails {\n        uint256 savETHBalance;\n        bool withdrawn;\n    }\n\n    /// @notice dETH associated with the KNOT\n    mapping(bytes => KnotDETHDetails) public dETHForKnot;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function init(address _liquidStakingManagerAddress, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(_liquidStakingManagerAddress, _lpTokenFactory);\n    }\n\n    modifier onlyManager {\n        require(msg.sender == address(liquidStakingManager), \"Not the savETH vault manager\");\n        _;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys and specify the amount of ETH being supplied for each key\n    /// @param _blsPublicKeyOfKnots BLS public key of the validators being staked and that are registered with the LSD network\n    /// @param _amounts Amount of ETH being supplied for the BLS public key at the same array index\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, false);\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice function to allow users to deposit any amount of ETH for staking\n    /// @param _blsPublicKeyOfKnot BLS Public Key of the potential KNOT for which user is contributing\n    /// @param _amount number of ETH (input in wei) contributed by the user for staking\n    /// @return amount of ETH contributed for staking by the user\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, false);\n\n        return _amount;\n    }\n\n    /// @notice Burn multiple LP tokens in a batch to claim either ETH (if not staked) or dETH (if derivatives minted)\n    /// @param _blsPublicKeys List of BLS public keys that have received liquidity\n    /// @param _amounts Amount of each LP token that the user wants to burn in exchange for either ETH (if not staked) or dETH (if derivatives minted)\n    function burnLPTokensByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            burnLPToken(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn multiple LP tokens in a batch to claim either ETH (if not staked) or dETH (if derivatives minted)\n    /// @param _lpTokens List of LP token addresses held by the caller\n    /// @param _amounts Amount of each LP token that the user wants to burn in exchange for either ETH (if not staked) or dETH (if derivatives minted)\n    function burnLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsisent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPToken(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    event CurrentStamp(uint256 stamp, uint256 last, bool isConditionTrue);\n    /// @notice function to allow users to burn LP token in exchange of ETH or dETH\n    /// @param _lpToken instance of LP token to be burnt\n    /// @param _amount number of LP tokens the user wants to burn\n    /// @return amount of ETH withdrawn\n    function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n\n        // get BLS public key for the LP token\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);\n\n        require(\n            validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||\n            validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n            \"Cannot burn LP tokens\"\n        );\n\n        // before burning, check the last LP token interaction and make sure its more than 30 mins old before permitting ETH withdrawals\n        bool isStaleLiquidity = _lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp;\n\n        // burn the amount of LP token from depositor's wallet\n        _lpToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n\n        if(validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            // return dETH\n            // amount of dETH redeemed by user for given LP token\n            uint256 redemptionValue;\n\n            KnotDETHDetails storage dETHDetails = dETHForKnot[blsPublicKeyOfKnot];\n\n            if(!dETHDetails.withdrawn) {\n                // withdraw dETH if not done already\n\n                // get dETH balance for the KNOT\n                uint256 dETHBalance = getSavETHRegistry().knotDETHBalanceInIndex(indexOwnedByTheVault, blsPublicKeyOfKnot);\n                uint256 savETHBalance = getSavETHRegistry().dETHToSavETH(dETHBalance);\n                // This require should never fail but is there for sanity purposes\n                require(dETHBalance >= 24 ether, \"Nothing to withdraw\");\n\n                // withdraw savETH from savETH index to the savETH vault\n                // contract gets savETH and not the dETH\n                getSavETHRegistry().addKnotToOpenIndex(liquidStakingManager.stakehouse(), blsPublicKeyOfKnot, address(this));\n\n                // update mapping\n                dETHDetails.withdrawn = true;\n                dETHDetails.savETHBalance = savETHBalance;\n                dETHForKnot[blsPublicKeyOfKnot] = dETHDetails;\n            }\n\n            // redeem savETH from the vault\n            redemptionValue = (dETHDetails.savETHBalance * _amount) / 24 ether;\n\n            // withdraw dETH (after burning the savETH)\n            getSavETHRegistry().withdraw(msg.sender, uint128(redemptionValue));\n\n            uint256 dETHRedeemed = getSavETHRegistry().savETHToDETH(redemptionValue);\n\n            emit DETHRedeemed(msg.sender, dETHRedeemed);\n            return redemptionValue;\n        }\n\n        // Before allowing ETH withdrawals we check the value of isStaleLiquidity fetched before burn\n        require(isStaleLiquidity, \"Liquidity is still fresh\");\n\n        // return ETH for LifecycleStatus.INITIALS_REGISTERED\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice function to allow liquid staking manager to withdraw ETH for staking\n    /// @param _smartWallet address of the smart wallet that receives ETH\n    /// @param _amount amount of ETH to be withdrawn\n    /// @return amount of ETH withdrawn\n    function withdrawETHForStaking(\n        address _smartWallet,\n        uint256 _amount\n    ) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 24 ether, \"Amount cannot be less than 24 ether\");\n        require(address(this).balance >= _amount, \"Insufficient withdrawal amount\");\n        require(_smartWallet != address(0), \"Zero address\");\n        require(_smartWallet != address(this), \"This address\");\n\n        (bool result,) = _smartWallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawnForStaking(_smartWallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Utility function that proxies through to the liquid staking manager to check whether the BLS key ever registered with the network\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return liquidStakingManager.isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot);\n    }\n\n    /// @notice Utility function that proxies through to the liquid staking manager to check whether the BLS key ever registered with the network but is now banned\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public view returns (bool) {\n        return liquidStakingManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot);\n    }\n\n    /// @notice Utility function that determins whether an LP can be burned for dETH if the associated derivatives have been minted\n    function isDETHReadyForWithdrawal(address _lpTokenAddress) external view returns (bool) {\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[LPToken(_lpTokenAddress)];\n        IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);\n        return validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED;\n    }\n\n    /// @dev Logic required for initialization\n    function _init(address _liquidStakingManagerAddress, LPTokenFactory _lpTokenFactory) internal {\n        require(_liquidStakingManagerAddress != address(0), \"Zero address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero address\");\n\n        lpTokenFactory = _lpTokenFactory;\n        liquidStakingManager = ILiquidStakingManager(_liquidStakingManagerAddress);\n\n        baseLPTokenName = \"dstETHToken_\";\n        baseLPTokenSymbol = \"dstETH_\";\n        maxStakingAmountPerValidator = 24 ether;\n\n        // create a savETH index owned by the vault\n        indexOwnedByTheVault = getSavETHRegistry().createIndex(address(this));\n    }\n}\n\n",
        "CodeNames": [
            "SavETHVault.t.sol",
            "SavETHVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SavETHVault.sol",
                "Type": "smart contract vulnerability",
                "Description": "The smartWallet address is not guaranteed correct, and ETH may be lost.",
                "Repair": "Verify the smartWallet is a valid existent smartWallet before ETH transfer by checking its owner"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GiantMevAndFeesPool.sol",
                "Type": "smart contract vulnerability",
                "Description": "The bringUnusedETHBackIntoGiantPool function can be used to steal LPTokens.",
                "Repair": "Always pass the liquid staking manager address, check its real and then request either the savETH vault or staking funds vault to prove the validity of vaults"
            },
            {
                "Location": "GiantMevAndFeesPool.withdrawETH()",
                "Type": "Reentrancy",
                "Description": "GiantMevAndFeesPool.withdrawETH() is vulnerable to reentrancy attack as GiantMevAndFeesPool.claimRewards() does not have the nonReentrant modifier. This allows the user to call any function in the fallback.",
                "Repair": "Add 'idleETH -= _amount' before sending ETH to the user"
            },
            {
                "Location": "GiantMevAndFeesPool.sol",
                "Type": "Loss of Funds",
                "Description": "When users transfer GiantLP, some rewards may be lost due to beforeTokenTransfer not calling StakingFundsVault.claimRewards to claim the latest rewards.",
                "Repair": "Encourage users to claim rewards before transferring tokens and document this limitation in detail"
            },
            {
                "Location": "GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool function",
                "Type": "Stealing ETH from Giant Pool",
                "Description": "The attacker can steal most of the ETH from the Giant Pool by exploiting the vulnerability in the function bringUnusedETHBackIntoGiantPool.",
                "Repair": "Increase idleETH in the function bringUnusedETHBackIntoGiantPool when sending ETH back to the Giant Pool"
            },
            {
                "Location": "function withdrawETH from GiantMevAndFeesPool",
                "Type": "stealing ETH",
                "Description": "The function withdrawETH from GiantMevAndFeesPool can steal most of eth because of idleETH is reduced before burning token.",
                "Repair": "Modify the code to decrease the idleETH after burning lpTokenETH"
            },
            {
                "Location": "function totalRewardsReceived in GiantMevAndFeesPool",
                "Type": "unfair reward distribution",
                "Description": "Any user being the first to claim rewards from GiantMevAndFeesPool can unexpectedly collect them all.",
                "Repair": "Rework the way accumulatedETHPerLPShare and claimed is used"
            },
            {
                "Location": "GiantMevAndFeesPool.previewAccumulatedETH",
                "Type": "Incorrect Calculation",
                "Description": "The formula for calculating the accumulated ETH value is not correct, causing any third-party contract that relies on this calculation to behave incorrectly.",
                "Repair": "Calculate the accumulated ETH value for all stakingFundVaults, not only for one stakingFundsVault."
            },
            {
                "Location": "GiantMevAndFeesPool.sol",
                "Type": "User griefing",
                "Description": "batchRotateLPTokens allows any user to rotate LP tokens of stakingFundsVaults around. There is a check that sender has over 0.5 ether of lpTokenETH, to prevent griefing. However, this check is unsatisfactory as user can at any stage deposit ETH to receive lpTokenETH and burn it to receive back ETH.",
                "Repair": "batchRotateLPTokens should have logic to enforce that this specific rotation is logical"
            },
            {
                "Location": "_onDepositETH() function in GiantMevAndFeesPool contract",
                "Type": "Loss of Funds",
                "Description": "When _onDepositETH() is called in giant pool, it calls _setClaimedToMax() to make sure new ETH stakers are not entitled to ETH earned by previous stakers, but this can cause users to lose their remaining rewards when they deposit.",
                "Repair": "When deposit happens, contract should first send remaining rewards, then increase the user's balance and then set the user claim to max."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "GiantSavETHVaultPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GiantSavETHVaultPool.sol",
                "Type": "smart contract vulnerability",
                "Description": "Giant pools can be drained due to weak vault authenticity check.",
                "Repair": "Take a list of LiquidStakingManager addresses instead of vault addresses"
            },
            {
                "Location": "GiantSavETHVaultPool.bringUnusedETHBackIntoGiantPool()",
                "Type": "Fund loss",
                "Description": "The value of 'idleETH' does not get increased in the function 'bringUnusedETHBackIntoGiantPool()', causing the contract to lose track of the real idle ETH balance of the contract.",
                "Repair": "Update the value of 'idleETH' in the function 'bringUnusedETHBackIntoGiantPool()'"
            },
            {
                "Location": "function withdrawDETH in GiantSavETHVaultPool",
                "Type": "reentrancy and fund theft",
                "Description": "Possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defense.",
                "Repair": "Check the provided addresses and have some reentrancy defense mechanism"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_distributeETHRewardsToUserForToken function",
                "Type": "reentrancy attack",
                "Description": "The recipient can execute a reentrancy attack calling several times the different function to steal funds or take advantage of other users/protocol.",
                "Repair": "Implement checks-effects-interactions pattern to prevent reentrancy attacks"
            },
            {
                "Location": "_depositETHForStaking function",
                "Type": "griefing attack",
                "Description": "Vaults can be griefed and made impossible to use for depositing by constantly making sure the remaining amount to be added to complete the deposit to the maxStakingAmountPerValidator, is under MIN_STAKING_AMOUNT.",
                "Repair": "Handle the case where the remaining amount to be completed is smaller than MIN_STAKING_AMOUNT, and allow the deposit in that case."
            },
            {
                "Location": "N/A",
                "Type": "depegging of tokens",
                "Description": "dETH / ETH / LPTokenETH can become depegged due to ETH 2.0 reward slashing.",
                "Repair": "Add mechanism to ensure the dETH is pegged via burning if case the ETH got slashed. Consider when the node do not maintain a minimum 32 ETH staking balance, who is in charge of adding the ETH balance to increase the staking balance or withdraw the ETH and distribute the fund."
            },
            {
                "Location": "deployLPToken function",
                "Type": "Cross-chain replay attacks",
                "Description": "Mistakes made on one chain can be re-applied to a new chain. If a user does deployLPToken using the wrong network, an attacker can replay the action on the correct chain, and steal the funds.",
                "Repair": "Include the chain.id in the data"
            },
            {
                "Location": "rotateLPTokens function",
                "Type": "Rotating LPTokens to banned BLS public key",
                "Description": "It is possible to rotate LPTokens to a banned BLS public key. This is not a safe action, because it can result in insolvency of the project (specially if the banned BLS public key was malicious).",
                "Repair": "Add a check to ensure that the new LPToken is not related to a banned BLS public key"
            },
            {
                "Location": "unstaking function",
                "Type": "Unstaking does not update the mapping",
                "Description": "If a user stakes some sETH, and after some time decides to unstake some amount of sETH, later s/he will not be qualified or be less qualified to claim ETH on the remaining staked sETH.",
                "Repair": "Update the mapping sETHUserClaimForKnot to the correct value"
            },
            {
                "Location": "claimRewards function",
                "Type": "Funds are not claimed from syndicate for valid BLS keys of first key is invalid",
                "Description": "If the first BLS public key is not part of the syndicate, then _claimFundsFromSyndicateForDistribution will not be called, even on BLS keys that are eligible for syndicate rewards. This leads to reduced rewards for user.",
                "Repair": "Drop the i==0 requirement and use a hasClaimed boolean instead"
            },
            {
                "Location": "deployNewLiquidStakingDerivativeNetwork function, updateDAOAddress function, rotateEOARepresentativeOfNodeRunner function, rotateNodeRunnerOfSmartWallet function, withdrawETHForKnot function",
                "Type": "Compromised or malicious DAO",
                "Description": "A compromised or malicious DAO can restrict actions of node runners who are not malicious, causing severe consequences including ETH losses.",
                "Repair": "Deploy a configurable governance contract as the DAO instead of explicitly setting the DAO's address. Implement a two-step procedure for transferring the DAO's role. Implement additional checks to prevent unauthorized actions by a compromised or malicious DAO."
            },
            {
                "Location": "_assertUserHasEnoughGiantLPToClaimVaultLP()",
                "Type": "Incorrect checking",
                "Description": "The batch operations of withdrawDETH() in GiantSavETHVaultPool.sol and withdrawLPTokens() in GiantPoolBase.sol are meaningless because they will fail whenever more than one lpToken is passed.",
                "Repair": "Check the LPToken being operated on for lastInteractedTimestamp rather than lpTokenETH"
            },
            {
                "Location": "_updateDAORevenueCommission()",
                "Type": "DAO commission",
                "Description": "Node runners can have all their stake rewards taken by the DAO as commissions can be set to a 100%.",
                "Repair": "Add a maximum cap on how much commission DAO can take from node runners"
            },
            {
                "Location": "batchRotateLPTokens()",
                "Type": "Minimum balance",
                "Description": "The GiantSavETHVaultPool and GiantMevAndFeesPool both have a batchRotateLPTokens function that allows to move staked ETH to another key.",
                "Repair": "Dynamically calculate the minimum balance for rotating LP Tokens"
            },
            {
                "Location": "withdrawETH()",
                "Type": "ETH amount check",
                "Description": "The GiantPoolBase.withdrawETH function requires that the amount to withdraw is at least as big as the MIN_STAKING_AMOUNT.",
                "Repair": "Remove the require(_amount = MIN_STAKING_AMOUNT, \"Invalid amount\"); statement"
            },
            {
                "Location": "registerBLSPublicKeys()",
                "Type": "Address check",
                "Description": "The underlying assumption of eoaRepresentative being an EOA can be untrue.",
                "Repair": "Build the protocol with the assumption that _eoaRepresentative == EOA"
            },
            {
                "Location": "registerBLSPublicKeys function",
                "Type": "Authorization",
                "Description": "Banned BLS public keys can still be registered as the function isBLSPublicKeyPartOfLSDNetwork only checks if the public key is part of the LSD network and not if it is banned.",
                "Repair": "Use isBLSPublicKeyBanned instead of isBLSPublicKeyPartOfLSDNetwork"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "GiantPoolBase.sol",
            "GiantSavETHVaultPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GiantPoolBase.sol, GiantSavETHVaultPool.sol",
                "Type": "Freezing of funds",
                "Description": "A hacker can prevent users from withdrawing dETH or LPTokens in giant pools. This bug causes a revert in WithdrawLP GiantMevAndFeesPool, WithdrawLP GiantSavETHVaultPool, and WithdrawDETH GiantSavETHVaultPool. The giant pools will become insolvent to returning ETH, dETH or vault LPTokens.",
                "Repair": "Add a check to ensure that the user has interacted with Giant LP Token at least one day before the withdrawal command is executed"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport { console } from \"forge-std/console.sol\";\n\nimport { MockERC20 } from \"../../contracts/testing/MockERC20.sol\";\nimport { SyndicateMock } from \"../../contracts/testing/syndicate/SyndicateMock.sol\";\n\nimport { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";\nimport { MockTransactionRouter } from \"../../contracts/testing/stakehouse/MockTransactionRouter.sol\";\nimport { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\nimport { MockStakeHouseUniverse } from \"../../contracts/testing/stakehouse/MockStakeHouseUniverse.sol\";\n\nimport { SyndicateFactoryMock } from \"../../contracts/testing/syndicate/SyndicateFactoryMock.sol\";\nimport {\n    KnotIsFullyStakedWithFreeFloatingSlotTokens,\n    KnotIsAlreadyRegistered\n} from \"../../contracts/syndicate/SyndicateErrors.sol\";\n\nimport { TestUtils } from \"../utils/TestUtils.sol\";\n\ncontract SyndicateTest is TestUtils {\n\n    MockERC20 public sETH;\n\n    SyndicateFactoryMock public syndicateFactory;\n\n    SyndicateMock public syndicate;\n\n    function blsPubKeyOneAsArray() public view returns (bytes[] memory) {\n        bytes[] memory keys = new bytes[](1);\n        keys[0] = blsPubKeyOne;\n        return keys;\n    }\n\n    function sendEIP1559RewardsToSyndicate(uint256 eip1559Reward) public {\n        (bool success, ) = address(syndicate).call{value: eip1559Reward}(\"\");\n        assertEq(success, true);\n        assertEq(address(syndicate).balance, eip1559Reward);\n    }\n\n    function setUp() public {\n        // Deploy an sETH token for an arbitrary stakehouse\n        sETH = new MockERC20(\"sETH\", \"sETH\", accountOne);\n\n        // Deploy the syndicate but no priority stakers are required\n        address[] memory priorityStakers = new address[](0);\n\n        // Create and inject mock stakehouse dependencies\n        address accountMan = address(new MockAccountManager());\n        address txRouter = address(new MockTransactionRouter());\n        address uni = address(new MockStakeHouseUniverse());\n        address slot = address(new MockSlotRegistry());\n        syndicateFactory = new SyndicateFactoryMock(\n            accountMan,\n            txRouter,\n            uni,\n            slot\n        );\n\n        address payable _syndicate = payable(syndicateFactory.deployMockSyndicate(\n            admin,\n            0, // No priority staking block\n            priorityStakers,\n            blsPubKeyOneAsArray()\n        ));\n\n        syndicate = SyndicateMock(_syndicate);\n\n        // Config mock stakehouse contracts\n        MockSlotRegistry(syndicate.slotReg()).setShareTokenForHouse(houseOne, address(sETH));\n\n        MockStakeHouseUniverse(syndicate.uni()).setAssociatedHouseForKnot(blsPubKeyOne, houseOne);\n        MockStakeHouseUniverse(syndicate.uni()).setAssociatedHouseForKnot(blsPubKeyTwo, houseOne);\n        MockStakeHouseUniverse(syndicate.uni()).setAssociatedHouseForKnot(blsPubKeyThree, houseOne);\n\n        MockSlotRegistry(syndicate.slotReg()).setNumberOfCollateralisedSlotOwnersForKnot(blsPubKeyOne, 1);\n        MockSlotRegistry(syndicate.slotReg()).setNumberOfCollateralisedSlotOwnersForKnot(blsPubKeyTwo, 1);\n        MockSlotRegistry(syndicate.slotReg()).setNumberOfCollateralisedSlotOwnersForKnot(blsPubKeyThree, 1);\n\n        MockSlotRegistry(syndicate.slotReg()).setCollateralisedOwnerAtIndex(blsPubKeyOne, 0, accountTwo);\n        MockSlotRegistry(syndicate.slotReg()).setCollateralisedOwnerAtIndex(blsPubKeyTwo, 0, accountFour);\n        MockSlotRegistry(syndicate.slotReg()).setCollateralisedOwnerAtIndex(blsPubKeyThree, 0, accountFive);\n\n        MockSlotRegistry(syndicate.slotReg()).setUserCollateralisedSLOTBalanceForKnot(houseOne, accountTwo, blsPubKeyOne, 4 ether);\n        MockSlotRegistry(syndicate.slotReg()).setUserCollateralisedSLOTBalanceForKnot(houseOne, accountFour, blsPubKeyTwo, 4 ether);\n        MockSlotRegistry(syndicate.slotReg()).setUserCollateralisedSLOTBalanceForKnot(houseOne, accountFive, blsPubKeyThree, 4 ether);\n    }\n\n    function testSupply() public {\n        assertEq(sETH.totalSupply(), 125_000 * 10 ** 18);\n        assertEq(sETH.balanceOf(accountOne), 125_000 * 10 ** 18);\n    }\n\n    function testThreeKnotsMultipleStakers() public {\n        // Set up test - distribute sETH and register additional knot to syndicate\n        vm.prank(admin);\n        syndicate.registerKnotsToSyndicate(getBytesArrayFromBytes(blsPubKeyTwo));\n\n        vm.startPrank(accountOne);\n        sETH.transfer(accountThree, 500 ether);\n        sETH.transfer(accountFive, 500 ether);\n        vm.stopPrank();\n\n        // for bls pub key one we will have 2 stakers staking 50% each\n        uint256 stakingAmount = 6 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakingAmount;\n\n        vm.startPrank(accountOne);\n        sETH.approve(address(syndicate), stakingAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n        vm.stopPrank();\n\n        vm.startPrank(accountThree);\n        sETH.approve(address(syndicate), stakingAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountThree);\n        vm.stopPrank();\n\n        sETHAmounts[0] = 12 ether;\n        vm.startPrank(accountFive);\n        sETH.approve(address(syndicate), sETHAmounts[0]);\n        syndicate.stake(getBytesArrayFromBytes(blsPubKeyTwo), sETHAmounts, accountFive);\n        vm.stopPrank();\n\n        // send some rewards\n        uint256 eipRewards = 0.0943 ether;\n        sendEIP1559RewardsToSyndicate(eipRewards);\n\n        vm.prank(accountOne);\n        vm.expectRevert(KnotIsFullyStakedWithFreeFloatingSlotTokens.selector);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n\n        // Check syndicate state\n        assertEq(syndicate.totalETHReceived(), eipRewards);\n\n        // claim\n        uint256[] memory indexes = new uint256[](1);\n        indexes[0] = 0;\n\n        assertEq(accountTwo.balance, 0);\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, getBytesArrayFromBytes(blsPubKeyOne));\n        assertEq(accountTwo.balance, eipRewards / 4);\n\n        assertEq(accountFour.balance, 0);\n        vm.prank(accountFour);\n        syndicate.claimAsCollateralizedSLOTOwner(accountFour, getBytesArrayFromBytes(blsPubKeyTwo));\n        assertEq(accountFour.balance, eipRewards / 4);\n\n        assertEq(accountFive.balance, 0);\n        vm.prank(accountFive);\n        syndicate.claimAsStaker(accountFive, getBytesArrayFromBytes(blsPubKeyTwo));\n        assertEq(accountFive.balance, (eipRewards / 4) - 1);\n\n        assertEq(accountOne.balance, 0);\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, getBytesArrayFromBytes(blsPubKeyOne));\n        assertEq(accountOne.balance, (eipRewards / 8) - 1);\n\n        assertEq(accountThree.balance, 0);\n        vm.prank(accountThree);\n        syndicate.claimAsStaker(accountThree, getBytesArrayFromBytes(blsPubKeyOne));\n        assertEq(accountThree.balance, (eipRewards / 8) - 1);\n\n        // Check syndicate state\n        assertEq(syndicate.totalETHReceived(), eipRewards);\n        assertEq(address(syndicate).balance, 3); // Dust is left behind due to Solidity calc issues\n\n        vm.prank(admin);\n        vm.expectRevert(KnotIsAlreadyRegistered.selector);\n        syndicate.registerKnotsToSyndicate(getBytesArrayFromBytes(blsPubKeyOne));\n\n        vm.prank(admin);\n        syndicate.registerKnotsToSyndicate(getBytesArrayFromBytes(blsPubKeyThree));\n    }\n\n    function testOneKnotWithMultipleFreeFloatingStakers() public {\n        // account two is the collateralized owner for bls pub key one. Everyone else can be free floating staker but they need sETH\n        vm.startPrank(accountOne);\n        sETH.transfer(accountThree, 500 ether);\n        sETH.transfer(accountFour, 500 ether);\n        vm.stopPrank();\n\n        // Stake free floating slot\n        uint256 stakeAmount = 4 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakeAmount;\n\n        vm.startPrank(accountOne);\n        sETH.approve(address(syndicate), stakeAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n        vm.stopPrank();\n\n        vm.startPrank(accountThree);\n        sETH.approve(address(syndicate), stakeAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountThree);\n        vm.stopPrank();\n\n        vm.startPrank(accountFour);\n        sETH.approve(address(syndicate), stakeAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountFour);\n        vm.stopPrank();\n\n        // send some eip rewards to syndicate\n        uint256 eipRewards = 0.54 ether;\n        sendEIP1559RewardsToSyndicate(eipRewards);\n\n        // Claim as free floating\n        assertEq(accountOne.balance, 0);\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(accountOne.balance, 0.09 ether);\n\n        assertEq(accountThree.balance, 0);\n        vm.prank(accountThree);\n        syndicate.claimAsStaker(accountThree, blsPubKeyOneAsArray());\n        assertEq(accountThree.balance, 0.09 ether);\n\n        assertEq(accountFour.balance, 0);\n        vm.prank(accountFour);\n        syndicate.claimAsStaker(accountFour, blsPubKeyOneAsArray());\n        assertEq(accountFour.balance, 0.09 ether);\n\n        // Now as the collateralized SLOT owner has not claimed, 0.27 out of 0.54 should still be with syndicate\n        assertEq(address(syndicate).balance, 0.27 ether);\n\n        // Collateralized owner claims\n        uint256[] memory indexes = new uint256[](1);\n        indexes[0] = 0;\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n        assertEq(address(syndicate).balance, 0);\n        assertEq(accountTwo.balance, 0.27 ether);\n\n        // nothing should happen by claiming again\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n        assertEq(address(syndicate).balance, 0);\n        assertEq(accountTwo.balance, 0.27 ether);\n\n        assertEq(accountOne.balance, 0.09 ether);\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(accountOne.balance, 0.09 ether);\n\n        assertEq(accountThree.balance, 0.09 ether);\n        vm.prank(accountThree);\n        syndicate.claimAsStaker(accountThree, blsPubKeyOneAsArray());\n        assertEq(accountThree.balance, 0.09 ether);\n\n        assertEq(accountFour.balance, 0.09 ether);\n        vm.prank(accountFour);\n        syndicate.claimAsStaker(accountFour, blsPubKeyOneAsArray());\n        assertEq(accountFour.balance, 0.09 ether);\n    }\n\n    function testExpansionOfKnotSet() public {\n        // Testing scenario where:\n        // - syn is deployed\n        // - it accrues ETH\n        // - no one claims\n        // - new knots are added to syn\n        // - old ones claim successfully\n        // - new ones have nothing to claim\n        // - when ETH comes in again, then the full set can claim that additional ETH\n\n        // Start test\n        // Check that one knot is registered\n        assertEq(syndicate.numberOfRegisteredKnots(), 1);\n        assertEq(syndicate.isKnotRegistered(blsPubKeyOne), true);\n\n        // Distribute some rewards, stake, no one claims and check claim amounts\n        uint256 eip1559Reward = 0.165 ether;\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        uint256 collateralizedIndex = 0;\n        uint256[] memory collateralizedIndexes = new uint256[](1);\n        collateralizedIndexes[0] = collateralizedIndex;\n\n        uint256 stakeAmount = 12 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakeAmount;\n\n        vm.startPrank(accountOne);\n        sETH.approve(address(syndicate), 12 ether);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n        vm.stopPrank();\n\n        // Without claiming ensure free floating staker and collateralized owners can claim correct amount of rewards\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        assertEq(\n            syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        assertEq(syndicate.totalETHReceived(), eip1559Reward);\n\n        // Expand KNOT set\n        vm.prank(admin);\n        syndicate.registerKnotsToSyndicate(getBytesArrayFromBytes(blsPubKeyTwo));\n\n        assertEq(syndicate.numberOfRegisteredKnots(), 2);\n        assertEq(syndicate.isKnotRegistered(blsPubKeyOne), true);\n        assertEq(syndicate.isKnotRegistered(blsPubKeyTwo), true);\n\n        // Check claim amount for previous stakers is still correct\n        assertEq(syndicate.totalClaimed(), 0);\n        assertEq(address(syndicate).balance, eip1559Reward);\n        assertEq(syndicate.totalETHReceived(), eip1559Reward);\n        assertEq(syndicate.accumulatedETHPerFreeFloatingShare(), 6875000000000000000000);\n        assertEq(syndicate.calculateNewAccumulatedETHPerFreeFloatingShare(), 0);\n        assertEq(syndicate.sETHTotalStakeForKnot(blsPubKeyOne), stakeAmount);\n        assertEq(syndicate.sETHStakedBalanceForKnot(blsPubKeyOne, accountOne), stakeAmount);\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        assertEq(\n            syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(accountOne.balance, eip1559Reward / 2);\n        assertEq(syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne), 0);\n        assertEq(\n            syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n        assertEq(syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne), 0);\n        assertEq(accountTwo.balance, eip1559Reward / 2);\n        assertEq(address(syndicate).balance, 0);\n\n        // introduce a third staker for free floating\n        vm.prank(accountOne);\n        sETH.transfer(accountThree, stakeAmount);\n\n        vm.startPrank(accountThree);\n        sETHAmounts[0] = stakeAmount;\n        sETH.approve(address(syndicate), stakeAmount);\n        syndicate.stake(\n            getBytesArrayFromBytes(blsPubKeyTwo),\n            sETHAmounts,\n            accountThree\n        );\n        vm.stopPrank();\n\n        // send some more rewards again\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        assertEq(syndicate.totalClaimed(), eip1559Reward);\n        assertEq(syndicate.totalFreeFloatingShares(), stakeAmount * 2);\n        assertEq(sETH.balanceOf(address(syndicate)), stakeAmount * 2);\n\n        uint256 ethPerKnot = eip1559Reward / 2;\n        uint256 ethPerFreeFloatingOrCollateralized = ethPerKnot;\n        uint256 unclaimedFreeFloatingAccountOne = syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne);\n        uint256 unclaimedFreeFloatingAccountThree = syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountThree, blsPubKeyTwo);\n        assertEq(\n            unclaimedFreeFloatingAccountOne + unclaimedFreeFloatingAccountThree,\n            ethPerFreeFloatingOrCollateralized\n        );\n\n        uint256 accountOneBalBeforeClaim = accountOne.balance;\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(accountOne.balance - accountOneBalBeforeClaim, unclaimedFreeFloatingAccountOne);\n\n        uint256 accountThreeBalBeforeClaim = accountThree.balance;\n        vm.prank(accountThree);\n        syndicate.claimAsStaker(accountThree, getBytesArrayFromBytes(blsPubKeyTwo));\n        assertEq(accountThree.balance - accountThreeBalBeforeClaim, unclaimedFreeFloatingAccountThree);\n\n        assertEq(syndicate.getUnprocessedETHForAllCollateralizedSlot(), 0);\n        assertEq(syndicate.getUnprocessedETHForAllFreeFloatingSlot(), 0);\n\n        uint256 unclaimedCollateralizedAccountTwo = syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne);\n        uint256 unclaimedCollateralizedAccountFour = syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountFour, blsPubKeyTwo);\n        assertEq(\n            unclaimedCollateralizedAccountTwo + unclaimedCollateralizedAccountFour,\n            ethPerFreeFloatingOrCollateralized\n        );\n\n        uint256 accountTwoBalBefore = accountTwo.balance;\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n        assertEq(accountTwo.balance - accountTwoBalBefore, unclaimedCollateralizedAccountTwo);\n\n        vm.prank(accountFour);\n        syndicate.claimAsCollateralizedSLOTOwner(accountFour, getBytesArrayFromBytes(blsPubKeyTwo));\n        assertEq(accountFour.balance, unclaimedCollateralizedAccountFour);\n\n        assertEq(address(syndicate).balance, 0);\n    }\n\n    function testClaimAsCollateralizedSlotOwner() public {\n        uint256 eip1559Reward = 0.165 ether;\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        uint256 collateralizedIndex = 0;\n        uint256[] memory collateralizedIndexes = new uint256[](1);\n        collateralizedIndexes[0] = collateralizedIndex;\n\n        assertEq(accountTwo.balance, 0);\n\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n\n        assertEq(accountTwo.balance, eip1559Reward / 2);\n        assertEq(address(syndicate).balance, eip1559Reward / 2);\n    }\n\n    function testStakeFreeFloatingReceiveETHAndThenClaim() public {\n        uint256 stakeAmount = 12 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakeAmount;\n\n        // Assume account one as message sender\n        vm.startPrank(accountOne);\n\n        // issue allowance to stake\n        sETH.approve(address(syndicate), sETHAmounts[0]);\n\n        // stake\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n\n        // End impersonation\n        vm.stopPrank();\n\n        assertEq(sETH.balanceOf(address(syndicate)), stakeAmount);\n        assertEq(syndicate.totalFreeFloatingShares(), stakeAmount);\n        assertEq(syndicate.sETHTotalStakeForKnot(blsPubKeyOne), stakeAmount);\n        assertEq(syndicate.sETHStakedBalanceForKnot(blsPubKeyOne, accountOne), stakeAmount);\n        assertEq(syndicate.sETHUserClaimForKnot(blsPubKeyOne, accountOne), 0);\n        assertEq(syndicate.accumulatedETHPerFreeFloatingShare(), 0);\n        assertEq(syndicate.lastSeenETHPerFreeFloating(), 0);\n        //assertEq(syndicate.lastSeenETHPerCollateralizedSlot(), 0);\n\n        uint256 eip1559Reward = 0.04 ether;\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        // Preview amount of unclaimed ETH before updating contract state\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n            0.02 ether - 1\n        );\n\n        syndicate.updateAccruedETHPerShares();\n\n        assertEq(syndicate.lastSeenETHPerFreeFloating(), eip1559Reward / 2);\n        //assertEq(syndicate.lastSeenETHPerCollateralizedSlot(), eip1559Reward / 2);\n        assertEq(syndicate.totalETHReceived(), eip1559Reward);\n        assertEq(syndicate.calculateETHForFreeFloatingOrCollateralizedHolders(), eip1559Reward / 2);\n        assertEq(syndicate.accumulatedETHPerFreeFloatingShare(), ((eip1559Reward / 2) * 1e24) / stakeAmount);\n        assertEq(syndicate.sETHUserClaimForKnot(blsPubKeyOne, accountOne), 0);\n\n        assertEq(address(syndicate).balance, 0.04 ether);\n\n        // Preview amount of unclaimed ETH post updating contract state\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n                0.02 ether - 1\n        );\n\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n\n        // Contract balance should have reduced\n        // Solidity precision loss of 1 wei\n        assertEq(address(syndicate).balance, 0.02 ether + 1);\n\n        // Unclaimed ETH amount should now be zero\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n            0\n        );\n\n        // user ETH balance should now be 0.02 ether minus 1 due to precision loss\n        assertEq(accountOne.balance, 0.02 ether - 1);\n\n        // try to claim again and fail\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(address(syndicate).balance, 0.02 ether + 1);\n\n        vm.prank(accountOne);\n        syndicate.unstake(accountOne, accountOne, blsPubKeyOneAsArray(), sETHAmounts);\n        assertEq(address(syndicate).balance, 0.02 ether + 1);\n\n        vm.startPrank(accountOne);\n\n        // issue allowance to stake\n        sETH.approve(address(syndicate), sETHAmounts[0]);\n\n        uint256 expectedDebt = (syndicate.accumulatedETHPerFreeFloatingShare() * stakeAmount) / syndicate.PRECISION();\n\n        // stake\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n\n        // Check user was assigned the correct debt on re-staking so they cannot double claim\n        assertEq(syndicate.sETHUserClaimForKnot(blsPubKeyOne, accountOne), expectedDebt);\n\n        // try to claim again and fail\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n\n        // End impersonation\n        vm.stopPrank();\n\n        assertEq(address(syndicate).balance, 0.02 ether + 1);\n    }\n\n    // TODO - fuzz claiming\n    function testBothCollateralizedAndSlotClaim() public {\n        uint256 eip1559Reward = 0.165 ether;\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        uint256 collateralizedIndex = 0;\n        uint256[] memory collateralizedIndexes = new uint256[](1);\n        collateralizedIndexes[0] = collateralizedIndex;\n\n        // set up collateralized knot\n        MockSlotRegistry(syndicate.slotReg()).setCollateralisedOwnerAtIndex(blsPubKeyOne, collateralizedIndex, accountTwo);\n        MockSlotRegistry(syndicate.slotReg()).setUserCollateralisedSLOTBalanceForKnot(houseOne, accountTwo, blsPubKeyOne, 4 ether);\n\n        assertEq(accountTwo.balance, 0);\n        assertEq(\n            syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(\n                accountTwo,\n                blsPubKeyOne\n            ),\n            eip1559Reward / 2\n        );\n\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n\n        assertEq(accountTwo.balance, eip1559Reward / 2);\n        assertEq(address(syndicate).balance, eip1559Reward / 2);\n\n        // now let free floating guy come in and stake sETH\n        vm.startPrank(accountOne);\n\n        uint256 stakeAmount = 12 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakeAmount;\n\n        sETH.approve(address(syndicate), stakeAmount);\n\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n\n        assertEq(accountOne.balance, 0);\n        assertEq(address(syndicate).balance, eip1559Reward / 2);\n\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n\n        vm.stopPrank();\n\n        assertEq(syndicate.sETHStakedBalanceForKnot(blsPubKeyOne, accountOne), 12 ether);\n        assertEq(syndicate.sETHUserClaimForKnot(blsPubKeyOne, accountOne), eip1559Reward / 2);\n\n        assertEq(accountOne.balance, (eip1559Reward / 2));\n        assertEq(address(syndicate).balance, 0);\n    }\n\n    // todo - use fuzz to continually add eip1559 rewards and then have users randomly draw down\n}\n\n\npragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ISyndicateInit } from \"../interfaces/ISyndicateInit.sol\";\nimport {\n    ZeroAddress,\n    EmptyArray,\n    InconsistentArrayLengths,\n    InvalidBLSPubKey,\n    InvalidNumberOfCollateralizedOwners,\n    KnotSlashed,\n    FreeFloatingStakeAmountTooSmall,\n    KnotIsNotRegisteredWithSyndicate,\n    NotPriorityStaker,\n    KnotIsFullyStakedWithFreeFloatingSlotTokens,\n    InvalidStakeAmount,\n    KnotIsNotAssociatedWithAStakeHouse,\n    UnableToStakeFreeFloatingSlot,\n    NothingStaked,\n    TransferFailed,\n    NotCollateralizedOwnerAtIndex,\n    InactiveKnot,\n    DuplicateArrayElements,\n    KnotIsAlreadyRegistered,\n    KnotHasAlreadyBeenDeRegistered\n} from \"./SyndicateErrors.sol\";\n\n/// @notice Syndicate registry and funds splitter for EIP1559 execution layer transaction tips across SLOT shares\n/// @dev This contract can be extended to allow lending and borrowing of time slots for borrower to redeem any revenue generated within the specified window\ncontract Syndicate is ISyndicateInit, Initializable, Ownable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice Emitted when the contract is initially deployed\n    event ContractDeployed();\n\n    /// @notice Emitted when accrued ETH per SLOT share type is updated\n    event UpdateAccruedETH(uint256 unprocessed);\n\n    /// @notice Emitted when new collateralized SLOT owners for a knot prompts re-calibration\n    event CollateralizedSLOTReCalibrated(bytes BLSPubKey);\n\n    /// @notice Emitted when a new KNOT is associated with the syndicate contract\n    event KNOTRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a KNOT is de-registered from the syndicate\n    event KnotDeRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a priority staker is added to the syndicate\n    event PriorityStakerRegistered(address indexed staker);\n\n    /// @notice Emitted when a user stakes free floating sETH tokens\n    event Staked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when a user unstakes free floating sETH tokens\n    event UnStaked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when either an sETH staker or collateralized SLOT owner claims ETH\n    event ETHClaimed(bytes BLSPubKey, address indexed user, address recipient, uint256 claim, bool indexed isCollateralizedClaim);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accrued ETH per free floating share for new and old stakers\n    uint256 public accumulatedETHPerFreeFloatingShare;\n\n    /// @notice Total accrued ETH for all collateralized SLOT holders per knot which is then distributed based on individual balances\n    uint256 public accumulatedETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all collateralized shares\n    uint256 public lastSeenETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all free floating shares\n    uint256 public lastSeenETHPerFreeFloating;\n\n    /// @notice Total number of sETH token shares staked across all houses\n    uint256 public totalFreeFloatingShares;\n\n    /// @notice Total amount of ETH drawn down by syndicate beneficiaries regardless of SLOT type\n    uint256 public totalClaimed;\n\n    /// @notice Number of knots registered with the syndicate which can be across any house\n    uint256 public numberOfRegisteredKnots;\n\n    /// @notice Informational - is the knot registered to this syndicate or not - the node should point to this contract\n    mapping(bytes => bool) public isKnotRegistered;\n\n    /// @notice Block number after which if there are sETH staking slots available, it can be supplied by anyone on the market\n    uint256 public priorityStakingEndBlock;\n\n    /// @notice Syndicate deployer can highlight addresses that get priority for staking free floating house sETH up to a certain block before anyone can do it\n    mapping(address => bool) public isPriorityStaker;\n\n    /// @notice Total amount of free floating sETH staked\n    mapping(bytes => uint256) public sETHTotalStakeForKnot;\n\n    /// @notice Amount of sETH staked by user against a knot\n    mapping(bytes => mapping(address => uint256)) public sETHStakedBalanceForKnot;\n\n    /// @notice Amount of ETH claimed by user from sETH staking\n    mapping(bytes => mapping(address => uint256)) public sETHUserClaimForKnot;\n\n    /// @notice Total amount of ETH that has been allocated to the collateralized SLOT owners of a KNOT\n    mapping(bytes => uint256) public totalETHProcessedPerCollateralizedKnot;\n\n    /// @notice Total amount of ETH accrued for the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public accruedEarningPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Total amount of ETH claimed by the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public claimedPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Whether a BLS public key, that has been previously registered, is no longer part of the syndicate and its shares (free floating or SLOT) cannot earn any more rewards\n    mapping(bytes => bool) public isNoLongerPartOfSyndicate;\n\n    /// @notice Once a BLS public key is no longer part of the syndicate, the accumulated ETH per free floating SLOT share is snapshotted so historical earnings can be drawn down correctly\n    mapping(bytes => uint256) public lastAccumulatedETHPerFreeFloatingShare;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _contractOwner Ethereum public key that will receive management rights of the contract\n    /// @param _priorityStakingEndBlock Block number when priority sETH staking ends and anyone can stake\n    /// @param _priorityStakers Optional list of addresses that will have priority for staking sETH against each knot registered\n    /// @param _blsPubKeysForSyndicateKnots List of BLS public keys of Stakehouse protocol registered KNOTs participating in syndicate\n    function initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) external virtual override initializer {\n        _initialize(\n            _contractOwner,\n            _priorityStakingEndBlock,\n            _priorityStakers,\n            _blsPubKeysForSyndicateKnots\n        );\n    }\n\n    /// @notice Allows the contract owner to append to the list of knots that are part of the syndicate\n    /// @param _newBLSPublicKeyBeingRegistered List of BLS public keys being added to the syndicate\n    function registerKnotsToSyndicate(\n        bytes[] calldata _newBLSPublicKeyBeingRegistered\n    ) external onlyOwner {\n        // update accrued ETH per SLOT type\n        updateAccruedETHPerShares();\n        _registerKnotsToSyndicate(_newBLSPublicKeyBeingRegistered);\n    }\n\n    /// @notice Make knot shares of a registered list of BLS public keys inactive - the action cannot be undone and no further ETH accrued\n    function deRegisterKnots(bytes[] calldata _blsPublicKeys) external onlyOwner {\n        updateAccruedETHPerShares();\n        _deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice Allows the contract owner to append to the list of priority sETH stakers\n    /// @param _priorityStakers List of staker addresses eligible for sETH staking\n    function addPriorityStakers(address[] calldata _priorityStakers) external onlyOwner {\n        updateAccruedETHPerShares();\n        _addPriorityStakers(_priorityStakers);\n    }\n\n    /// @notice Should this block be in the future, it means only those listed in the priority staker list can stake sETH\n    /// @param _endBlock Arbitrary block number after which anyone can stake up to 4 SLOT in sETH per KNOT\n    function updatePriorityStakingBlock(uint256 _endBlock) external onlyOwner {\n        updateAccruedETHPerShares();\n        priorityStakingEndBlock = _endBlock;\n    }\n\n    /// @notice Update accrued ETH per SLOT share without distributing ETH as users of the syndicate individually pull funds\n    function updateAccruedETHPerShares() public {\n        // Ensure there are registered KNOTs. Syndicates are deployed with at least 1 registered but this can fall to zero.\n        // Fee recipient should be re-assigned in the event that happens as any further ETH can be collected by owner\n        if (numberOfRegisteredKnots > 0) {\n            // All time, total ETH that was earned per slot type (free floating or collateralized)\n            uint256 totalEthPerSlotType = calculateETHForFreeFloatingOrCollateralizedHolders();\n\n            // Process free floating if there are staked shares\n            uint256 freeFloatingUnprocessed;\n            if (totalFreeFloatingShares > 0) {\n                freeFloatingUnprocessed = getUnprocessedETHForAllFreeFloatingSlot();\n                accumulatedETHPerFreeFloatingShare += _calculateNewAccumulatedETHPerFreeFloatingShare(freeFloatingUnprocessed);\n                lastSeenETHPerFreeFloating = totalEthPerSlotType;\n            }\n\n            uint256 collateralizedUnprocessed = ((totalEthPerSlotType - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n            accumulatedETHPerCollateralizedSlotPerKnot += collateralizedUnprocessed;\n            lastSeenETHPerCollateralizedSlotPerKnot = totalEthPerSlotType;\n\n            emit UpdateAccruedETH(freeFloatingUnprocessed + collateralizedUnprocessed);\n        } else {\n            // todo - check else case for any ETH lost\n        }\n    }\n\n    /// @notice Stake up to 4 collateralized SLOT worth of sETH per KNOT to get a portion of syndicate rewards\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be staked (up to 4 collateralized SLOT per KNOT)\n    /// @param _onBehalfOf Allows a caller to specify an address that will be assigned stake ownership and rights to claim\n    function stake(bytes[] calldata _blsPubKeys, uint256[] calldata _sETHAmounts, address _onBehalfOf) external {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_onBehalfOf == address(0)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n\n            if (_sETHAmount < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n            if (!isKnotRegistered[_blsPubKey] || isNoLongerPartOfSyndicate[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            if (block.number < priorityStakingEndBlock && !isPriorityStaker[_onBehalfOf]) revert NotPriorityStaker();\n\n            uint256 totalStaked = sETHTotalStakeForKnot[_blsPubKey];\n            if (totalStaked == 12 ether) revert KnotIsFullyStakedWithFreeFloatingSlotTokens();\n\n            if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount();\n\n            totalFreeFloatingShares += _sETHAmount;\n            sETHTotalStakeForKnot[_blsPubKey] += _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][_onBehalfOf] += _sETHAmount;\n            sETHUserClaimForKnot[_blsPubKey][_onBehalfOf] = (_sETHAmount * accumulatedETHPerFreeFloatingShare) / PRECISION;\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            if (stakeHouse == address(0)) revert KnotIsNotAssociatedWithAStakeHouse();\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n            bool transferResult = sETH.transferFrom(msg.sender, address(this), _sETHAmount);\n            if (!transferResult) revert UnableToStakeFreeFloatingSlot();\n\n            emit Staked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Unstake an sETH position against a particular KNOT and claim ETH on exit\n    /// @param _unclaimedETHRecipient The address that will receive any unclaimed ETH received to the syndicate\n    /// @param _sETHRecipient The address that will receive the sETH that is being unstaked\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be unstaked\n    function unstake(\n        address _unclaimedETHRecipient,\n        address _sETHRecipient,\n        bytes[] calldata _blsPubKeys,\n        uint256[] calldata _sETHAmounts\n    ) external nonReentrant {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_unclaimedETHRecipient == address(0)) revert ZeroAddress();\n        if (_sETHRecipient == address(0)) revert ZeroAddress();\n\n        // Claim all ETH owed before unstaking but even if nothing is owed `updateAccruedETHPerShares` will be called\n        _claimAsStaker(_unclaimedETHRecipient, _blsPubKeys);\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n            if (sETHStakedBalanceForKnot[_blsPubKey][msg.sender] < _sETHAmount) revert NothingStaked();\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n\n            // Only decrease totalFreeFloatingShares in the event that the knot is still active in the syndicate\n            if (!isNoLongerPartOfSyndicate[_blsPubKey]) {\n                totalFreeFloatingShares -= _sETHAmount;\n            }\n\n            sETHTotalStakeForKnot[_blsPubKey] -= _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][msg.sender] -= _sETHAmount;\n\n            bool transferResult = sETH.transfer(_sETHRecipient, _sETHAmount);\n            if (!transferResult) revert TransferFailed();\n\n            emit UnStaked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Claim ETH cashflow from the syndicate as an sETH staker proportional to how much the user has staked\n    /// @param _recipient Address that will receive the share of ETH funds\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) public nonReentrant {\n        _claimAsStaker(_recipient, _blsPubKeys);\n    }\n\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsCollateralizedSLOTOwner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information for all shares\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            // process newly accrued ETH and distribute it to collateralized SLOT owners for the given knot\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n\n            // Calculate total amount of unclaimed ETH\n            uint256 userShare = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // This is designed to cope with falling SLOT balances i.e. when collateralized SLOT is burnt after applying penalties\n            uint256 unclaimedUserShare = userShare - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // Send ETH to the user if there is an unclaimed amount\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed and claimed at the user level\n                totalClaimed += unclaimedUserShare;\n                claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender] = userShare;\n\n                // Send ETH to user\n                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");\n                if (!success) revert TransferFailed();\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    true\n                );\n            }\n        }\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner\n    /// @param _blsPubKey BLS public key relating to the collateralized owners that need updating\n    function updateCollateralizedSlotOwnersAccruedETH(bytes memory _blsPubKey) external {\n        _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner and do it for a batch of knots\n    /// @param _blsPubKeys List of BLS public keys related to the collateralized owners that need updating\n    function batchUpdateCollateralizedSlotOwnersAccruedETH(bytes[] memory _blsPubKeys) external {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKeys[i]);\n        }\n    }\n\n    /// @notice Syndicate contract can receive ETH\n    receive() external payable {\n        // No logic here because one cannot assume that more than 21K GAS limit is forwarded\n    }\n\n    /// @notice Calculate the amount of unclaimed ETH for a given BLS publice key + free floating SLOT staker without factoring in unprocessed rewards\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _user The address of a user that has staked sETH against the BLS public key\n    function calculateUnclaimedFreeFloatingETHShare(bytes memory _blsPubKey, address _user) public view returns (uint256) {\n        // Check the user has staked sETH for the KNOT\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_user];\n        if (stakedBal < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n\n        // Get the amount of ETH eligible for the user based on their staking amount\n        uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n        uint256 userShare = (accumulatedETHPerShare * stakedBal) / PRECISION;\n\n        // Calculate how much their unclaimed share of ETH is based on total ETH claimed so far\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_user];\n    }\n\n    /// @notice Using `highestSeenBalance`, this is the amount that is separately allocated to either free floating or collateralized SLOT holders\n    function calculateETHForFreeFloatingOrCollateralizedHolders() public view returns (uint256) {\n        // Get total amount of ETH that can be drawn down by all SLOT holders associated with a knot\n        uint256 ethPerKnot = totalETHReceived();\n\n        // Get the amount of ETH eligible for free floating sETH or collateralized SLOT stakers\n        return ethPerKnot / 2;\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for an sETH staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _staker The address of a user that has staked sETH against the BLS public key\n    function previewUnclaimedETHAsFreeFloatingStaker(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) external view returns (uint256) {\n        uint256 currentAccumulatedETHPerFreeFloatingShare = accumulatedETHPerFreeFloatingShare;\n        uint256 updatedAccumulatedETHPerFreeFloatingShare =\n                            currentAccumulatedETHPerFreeFloatingShare + calculateNewAccumulatedETHPerFreeFloatingShare();\n\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_staker];\n        uint256 userShare = (updatedAccumulatedETHPerFreeFloatingShare * stakedBal) / PRECISION;\n\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for a collatearlized SLOT staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _staker Address of a collateralized SLOT owner for a KNOT\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    function previewUnclaimedETHAsCollateralizedSlotOwner(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) external view returns (uint256) {\n        // Per collateralized SLOT per KNOT before distributing to individual collateralized owners\n        uint256 accumulatedSoFar = accumulatedETHPerCollateralizedSlotPerKnot\n                    + ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n\n        uint256 unprocessedForKnot = accumulatedSoFar - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Fetch information on what has been processed so far against the ECDSA address of the collateralized SLOT owner\n        uint256 currentAccrued = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n\n        // Fetch information about the knot including total slashed amount\n        uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n        uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n        (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Find the collateralized SLOT owner and work out how much they're owed\n        for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n            address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n            if (collateralizedOwnerAtIndex == _staker) {\n                uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                    stakeHouse,\n                    collateralizedOwnerAtIndex,\n                    _blsPubKey\n                );\n\n                if (currentSlashedAmount < 4 ether) {\n                    currentAccrued +=\n                        balance * unprocessedForKnot / (4 ether - currentSlashedAmount);\n                }\n                break;\n            }\n        }\n\n        return currentAccrued - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Amount of ETH per free floating share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllFreeFloatingSlot() public view returns (uint256) {\n        return calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerFreeFloating;\n    }\n\n    /// @notice Amount of ETH per collateralized share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllCollateralizedSlot() public view returns (uint256) {\n        return ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n    }\n\n    /// @notice New accumulated ETH per free floating share that hasn't yet been applied\n    /// @dev The return value is scaled by 1e24\n    function calculateNewAccumulatedETHPerFreeFloatingShare() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllFreeFloatingSlot();\n        return _calculateNewAccumulatedETHPerFreeFloatingShare(ethSinceLastUpdate);\n    }\n\n    /// @notice New accumulated ETH per collateralized share per knot that hasn't yet been applied\n    function calculateNewAccumulatedETHPerCollateralizedSharePerKnot() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllCollateralizedSlot();\n        return accumulatedETHPerCollateralizedSlotPerKnot + ethSinceLastUpdate;\n    }\n\n    /// @notice Total amount of ETH received by the contract\n    function totalETHReceived() public view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @dev Internal logic for initializing the syndicate contract\n    function _initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) internal {\n        // Transfer ownership from the deployer to the address specified as the owner\n        _transferOwnership(_contractOwner);\n\n        // Add the initial set of knots to the syndicate\n        _registerKnotsToSyndicate(_blsPubKeysForSyndicateKnots);\n\n        // Optionally process priority staking if the required params and array is configured\n        if (_priorityStakingEndBlock > block.number) {\n            priorityStakingEndBlock = _priorityStakingEndBlock;\n            _addPriorityStakers(_priorityStakers);\n        }\n\n        emit ContractDeployed();\n    }\n\n    /// Given an amount of ETH allocated to the collateralized SLOT owners of a KNOT, distribute this amongs the current set of collateralized owners (a dynamic set of addresses and balances)\n    function _updateCollateralizedSlotOwnersLiabilitySnapshot(bytes memory _blsPubKey) internal {\n        // Establish how much new ETH is for the new KNOT\n        uint256 unprocessedETHForCurrentKnot =\n                    accumulatedETHPerCollateralizedSlotPerKnot - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Get information about the knot i.e. associated house and whether its active\n        (address stakeHouse,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Assuming that there is unprocessed ETH and the knot is still part of the syndicate\n        if (unprocessedETHForCurrentKnot > 0 && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n\n            // Don't allocate ETH when the current slashed amount is four. Syndicate will wait until ETH is topped up to claim revenue\n            if (currentSlashedAmount < 4 ether) {\n                // This copes with increasing numbers of collateralized slot owners and also copes with SLOT that has been slashed but not topped up\n                uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n\n                if (numberOfCollateralisedSlotOwnersForKnot == 1) {\n                    // For only 1 collateralized SLOT owner, they get the full amount of unprocessed ETH for the knot\n                    address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, 0);\n                    accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] += unprocessedETHForCurrentKnot;\n                } else {\n                    for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n                        address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n                        uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                            stakeHouse,\n                            collateralizedOwnerAtIndex,\n                            _blsPubKey\n                        );\n\n                        accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] +=\n                            balance * unprocessedETHForCurrentKnot / (4 ether - currentSlashedAmount);\n                    }\n                }\n\n                // record so unprocessed goes to zero\n                totalETHProcessedPerCollateralizedKnot[_blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n            }\n        }\n\n        // if the knot is no longer active, no further accrual of rewards are possible snapshots are possible but ETH accrued up to that point\n        // Basically, under a rage quit or voluntary withdrawal from the beacon chain, the knot kick is auto-propagated to syndicate\n        if (!isActive && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            _deRegisterKnot(_blsPubKey);\n        }\n    }\n\n    function _calculateCollateralizedETHOwedPerKnot() internal view returns (uint256) {\n        uint256 collateralizedSLOTShareOfETH = calculateETHForFreeFloatingOrCollateralizedHolders();\n        uint256 collateralizedSLOTShareOfETHPerKnot = (collateralizedSLOTShareOfETH / numberOfRegisteredKnots);\n        return collateralizedSLOTShareOfETHPerKnot;\n    }\n\n    /// @dev Business logic for calculating per collateralized share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerCollateralizedShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return (_ethSinceLastUpdate * PRECISION) / (numberOfRegisteredKnots * 4 ether);\n    }\n\n    /// @dev Business logic for calculating per free floating share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerFreeFloatingShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return totalFreeFloatingShares > 0 ? (_ethSinceLastUpdate * PRECISION) / totalFreeFloatingShares : 0;\n    }\n\n    /// @dev Business logic for adding a new set of knots to the syndicate for collecting revenue\n    function _registerKnotsToSyndicate(bytes[] memory _blsPubKeysForSyndicateKnots) internal {\n        uint256 knotsToRegister = _blsPubKeysForSyndicateKnots.length;\n        if (knotsToRegister == 0) revert EmptyArray();\n        numberOfRegisteredKnots += knotsToRegister;\n\n        for (uint256 i; i < knotsToRegister; ++i) {\n            bytes memory blsPubKey = _blsPubKeysForSyndicateKnots[i];\n\n            if (isKnotRegistered[blsPubKey]) revert KnotIsAlreadyRegistered();\n\n            // incomming knot collateralized SLOT holders do not get historical earnings\n            totalETHProcessedPerCollateralizedKnot[blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n\n            // Health check - if knot is inactive or slashed, should it really be part of the syndicate?\n            // KNOTs closer to 32 effective at all times is the target\n            (,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(blsPubKey);\n            if (!isActive) revert InactiveKnot();\n\n            uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(blsPubKey);\n            if (numberOfCollateralisedSlotOwnersForKnot < 1) revert InvalidNumberOfCollateralizedOwners();\n            if (getSlotRegistry().currentSlashedAmountOfSLOTForKnot(blsPubKey) != 0) revert InvalidNumberOfCollateralizedOwners();\n\n            isKnotRegistered[blsPubKey] = true;\n            emit KNOTRegistered(blsPubKey);\n        }\n    }\n\n    /// @dev Business logic for adding priority stakers to the syndicate\n    function _addPriorityStakers(address[] memory _priorityStakers) internal {\n        if (_priorityStakers.length == 0) revert EmptyArray();\n        for (uint256 i; i < _priorityStakers.length; ++i) {\n            address staker = _priorityStakers[i];\n\n            if (i > 0 && staker < _priorityStakers[i-1]) revert DuplicateArrayElements();\n\n            isPriorityStaker[staker] = true;\n\n            emit PriorityStakerRegistered(staker);\n        }\n    }\n\n    /// @dev Business logic for de-registering a set of knots from the syndicate and doing the required snapshots to ensure historical earnings are preserved\n    function _deRegisterKnots(bytes[] calldata _blsPublicKeys) internal {\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            bytes memory blsPublicKey = _blsPublicKeys[i];\n\n            // Do one final snapshot of ETH owed to the collateralized SLOT owners so they can claim later\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(blsPublicKey);\n\n            // Execute the business logic for de-registering the single knot\n            _deRegisterKnot(blsPublicKey);\n        }\n    }\n\n    /// @dev Business logic for de-registering a specific knots assuming all accrued ETH has been processed\n    function _deRegisterKnot(bytes memory _blsPublicKey) internal {\n        if (isKnotRegistered[_blsPublicKey] == false) revert KnotIsNotRegisteredWithSyndicate();\n        if (isNoLongerPartOfSyndicate[_blsPublicKey] == true) revert KnotHasAlreadyBeenDeRegistered();\n\n        // We flag that the knot is no longer part of the syndicate\n        isNoLongerPartOfSyndicate[_blsPublicKey] = true;\n\n        // For the free floating and collateralized SLOT of the knot, snapshot the accumulated ETH per share\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] = accumulatedETHPerFreeFloatingShare;\n\n        // We need to reduce `totalFreeFloatingShares` in order to avoid further ETH accruing to shares of de-registered knot\n        totalFreeFloatingShares -= sETHTotalStakeForKnot[_blsPublicKey];\n\n        // Total number of registered knots with the syndicate reduces by one\n        numberOfRegisteredKnots -= 1;\n\n        emit KnotDeRegistered(_blsPublicKey);\n    }\n\n    /// @dev Work out the accumulated ETH per free floating share value that must be used for distributing ETH\n    function _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(\n        bytes memory _blsPublicKey\n    ) internal view returns (uint256) {\n        return\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] > 0 ?\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] :\n        accumulatedETHPerFreeFloatingShare;\n    }\n\n    /// @dev Business logic for allowing a free floating SLOT holder to claim their share of ETH\n    function _claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) internal {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            uint256 unclaimedUserShare = calculateUnclaimedFreeFloatingETHShare(_blsPubKey, msg.sender);\n\n            // this means that user can call the funtion even if there is nothing to claim but the\n            // worst that will happen is that they will just waste gas. this is needed for unstaking\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed at the contract level\n                totalClaimed += unclaimedUserShare;\n\n                // Work out which accumulated ETH per free floating share value was used\n                uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n\n                // Update the total ETH claimed by the free floating SLOT holder based on their share of sETH\n                sETHUserClaimForKnot[_blsPubKey][msg.sender] =\n                (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION;\n\n                // Send ETH to user\n                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");\n                if (!success) revert TransferFailed();\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    false\n                );\n            }\n        }\n    }\n}\n\n",
        "CodeNames": [
            "Syndicate.t.sol",
            "Syndicate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Syndicate.sol",
                "Type": "Theft of ETH",
                "Description": "A malicious user can steal all claimable ETH belonging to free floating SLOT holders. The logic for keeping the rewards up-to-date is also quite complex in my opinion. The main thing that triggered it for me was the lazy call to updateAccruedETHPerShares. Why not keep the state updated after each operation instead?",
                "Repair": "Use += operator instead of = in the updateAccruedETHPerShares function and keep the state updated after each operation instead of using a lazy call"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}\n\n",
        "CodeNames": [
            "GiantPoolBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GiantPoolBase.withdrawLPTokens function",
                "Type": "loss of funds",
                "Description": "Withdrawing wrong LPToken from GiantPool leads to loss of funds.",
                "Repair": "The GiantPool should store information about which LP tokens it receives for staking ETH. When calling the GiantPoolBase.withdrawLPTokens function it can then be checked if the LP tokens to be withdrawn were indeed transferred to the GiantPool in exchange for staking ETH."
            },
            {
                "Location": "function withdrawETH() in GiantPoolBase",
                "Type": "failure to distribute rewards",
                "Description": "Function withdrawETH() in GiantPoolBase does not call _distributeETHRewardsToUserForToken() or _onWithdraw() which would make users lose their remaining rewards.",
                "Repair": "Calculate and transfer user's unclaimed funds before any actions that change user's balance"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\nimport \"forge-std/console.sol\";\n\nimport { StakingFundsVault } from \"../../contracts/liquid-staking/StakingFundsVault.sol\";\nimport { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\nimport {\n    TestUtils,\n    MockLSDNFactory,\n    MockLiquidStakingManager,\n    MockAccountManager,\n    IDataStructures\n} from \"../utils/TestUtils.sol\";\n\ncontract StakingFundsVaultTest is TestUtils {\n\n    address operations = accountOne;\n\n    MockLiquidStakingManager liquidStakingManager;\n    StakingFundsVault vault;\n\n    uint256 maxStakingAmountPerValidator;\n\n    function maxETHDeposit(address _user, bytes[] memory _blsPubKeys) public {\n        uint256[] memory amounts = new uint256[](_blsPubKeys.length);\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            amounts[i] = maxStakingAmountPerValidator;\n        }\n\n        depositETH(_user, _blsPubKeys.length * maxStakingAmountPerValidator, amounts, _blsPubKeys);\n    }\n\n    function depositETH(address _user, uint256 _totalETH, uint256[] memory _amounts, bytes[] memory _blsPubKeys) public {\n        require(_blsPubKeys.length > 0, \"Empty array\");\n\n        // Give the user ETH\n        vm.deal(_user, _totalETH);\n\n        uint256 vaultBalanceBefore = address(vault).balance;\n\n        // Impersonate the user and deposit ETH for all of the BLS keys\n        vm.startPrank(_user);\n        vault.batchDepositETHForStaking{value: _totalETH}(_blsPubKeys, _amounts);\n        vm.stopPrank();\n\n        // Check that the deposit worked\n        assertEq(address(vault).balance - vaultBalanceBefore, _totalETH);\n    }\n\n    function setUp() public {\n        factory = createMockLSDNFactory();\n        liquidStakingManager = deployDefaultLiquidStakingNetwork(factory, admin);\n        manager = liquidStakingManager;\n        vault = liquidStakingManager.stakingFundsVault();\n        maxStakingAmountPerValidator = vault.maxStakingAmountPerValidator();\n\n        // set up BLS keys required to initials registered\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 1);\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyThree, 1);\n\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, true);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyTwo, true);\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyThree, true);\n    }\n\n    function setSetupIsCorrect() public {\n        assertEq(maxStakingAmountPerValidator, 4 ether);\n    }\n\n    function testCanReceiveETHAndWithdraw() public {\n        vm.deal(address(vault), 4 ether);\n        assertEq(address(vault).balance, 4 ether);\n\n        assertEq(operations.balance, 0);\n\n        vm.prank(address(liquidStakingManager));\n        vault.withdrawETH(operations, 4 ether);\n        assertEq(operations.balance, 4 ether);\n    }\n\n    function testBatchDepositETHForStakingRevertsWhenETHNotAttached() public {\n        vm.expectRevert(\"Invalid ETH amount attached\");\n        vault.batchDepositETHForStaking(\n            getBytesArrayFromBytes(blsPubKeyOne, blsPubKeyTwo, blsPubKeyThree),\n            getUint256ArrayFromValues(maxStakingAmountPerValidator, maxStakingAmountPerValidator, maxStakingAmountPerValidator)\n        );\n    }\n\n    function testBatchDepositETHForStakingRevertsWhenEmptyArraysAreSupplied() public {\n        vm.expectRevert(\"Empty arrays\");\n        vault.batchDepositETHForStaking(\n            getEmptyBytesArray(),\n            getEmptyUint256Array()\n        );\n    }\n\n    function testBatchDepositETHForStakingRevertsWhenInconsistentArrayLengthsAreSupplied() public {\n        vm.expectRevert(\"Inconsistent array lengths\");\n        vault.batchDepositETHForStaking(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            getEmptyUint256Array()\n        );\n    }\n\n    function testBatchDepositETHForStakingRevertsWhenBLSNotRegisteredWithNetwork() public {\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, false);\n        assertEq(liquidStakingManager.isBLSPublicKeyPartOfLSDNetwork(blsPubKeyOne), false);\n        assertEq(liquidStakingManager.isBLSPublicKeyBanned(blsPubKeyOne), true);\n        vm.expectRevert(\"BLS public key is not part of LSD network\");\n        vault.batchDepositETHForStaking{ value: maxStakingAmountPerValidator }(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            getUint256ArrayFromValues(maxStakingAmountPerValidator)\n        );\n    }\n\n    function testBatchDepositETHForStakingRevertsWhenBLSNotLifecycleStatusOne() public {\n        assertEq(liquidStakingManager.isBLSPublicKeyPartOfLSDNetwork(blsPubKeyOne), true);\n        assertEq(liquidStakingManager.isBLSPublicKeyBanned(blsPubKeyOne), false);\n\n        MockAccountManager(liquidStakingManager.accountMan()).setLifecycleStatus(blsPubKeyOne, 0);\n\n        vm.expectRevert(\"Lifecycle status must be one\");\n        vault.batchDepositETHForStaking{ value: maxStakingAmountPerValidator }(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            getUint256ArrayFromValues(maxStakingAmountPerValidator)\n        );\n    }\n\n    function testBatchDepositETHForStakingCanSuccessfullyDepositForMultipleValidators() public {\n        bytes[] memory blsKeys = getBytesArrayFromBytes(blsPubKeyOne, blsPubKeyTwo, blsPubKeyThree);\n\n        vm.deal(accountThree, 3 * maxStakingAmountPerValidator);\n        vm.prank(accountThree);\n        vault.batchDepositETHForStaking{ value: 3 * maxStakingAmountPerValidator }(\n            blsKeys,\n            getUint256ArrayFromValues(maxStakingAmountPerValidator, maxStakingAmountPerValidator, maxStakingAmountPerValidator)\n        );\n\n        assertEq(address(vault).balance, 3 * maxStakingAmountPerValidator);\n\n        for (uint256 i; i < blsKeys.length; ++i) {\n            bytes memory blsKey = blsKeys[i];\n            LPToken token = vault.lpTokenForKnot(blsKey);\n            assertTrue(address(token) != address(0));\n            assertEq(token.totalSupply(), maxStakingAmountPerValidator);\n            assertEq(token.balanceOf(accountThree), maxStakingAmountPerValidator);\n        }\n    }\n\n    function testDepositETHForStaking() public {\n        vm.deal(accountOne, maxStakingAmountPerValidator);\n        vm.deal(accountTwo, maxStakingAmountPerValidator);\n        vm.deal(accountThree, maxStakingAmountPerValidator);\n\n        uint256 stakeAmount = maxStakingAmountPerValidator / 2;\n        vm.prank(accountOne);\n        vault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n        assertEq(vault.lpTokenForKnot(blsPubKeyOne).balanceOf(accountOne), stakeAmount);\n        assertEq(vault.lpTokenForKnot(blsPubKeyOne).totalSupply(), stakeAmount);\n\n        vm.prank(accountTwo);\n        vault.depositETHForStaking{value: stakeAmount}(blsPubKeyTwo, stakeAmount);\n        assertEq(vault.lpTokenForKnot(blsPubKeyOne).balanceOf(accountOne), stakeAmount);\n        assertEq(vault.lpTokenForKnot(blsPubKeyTwo).balanceOf(accountTwo), stakeAmount);\n        assertEq(vault.lpTokenForKnot(blsPubKeyOne).totalSupply(), stakeAmount);\n        assertEq(vault.lpTokenForKnot(blsPubKeyTwo).totalSupply(), stakeAmount);\n\n        vm.prank(accountThree);\n        vault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n        assertEq(vault.lpTokenForKnot(blsPubKeyOne).totalSupply(), maxStakingAmountPerValidator);\n        assertEq(vault.lpTokenForKnot(blsPubKeyTwo).totalSupply(), stakeAmount);\n\n        assertEq(address(vault).balance, maxStakingAmountPerValidator + maxStakingAmountPerValidator / 2);\n\n        vm.expectRevert(\"Amount exceeds the staking limit for the validator\");\n        vm.prank(accountThree);\n        vault.depositETHForStaking{value: stakeAmount}(blsPubKeyOne, stakeAmount);\n    }\n\n    function testDepositETHForStakingRevertsWhenBLSKeyIsNotRegistered() public {\n        liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, false);\n        vm.expectRevert(\"BLS public key is banned or not a part of LSD network\");\n        vault.depositETHForStaking(\n            blsPubKeyOne,\n            maxStakingAmountPerValidator\n        );\n    }\n\n    function testDepositETHForStakingRevertsWhenBLSKeyIsBanned() public {\n        liquidStakingManager.setIsBanned(blsPubKeyTwo, true);\n        vm.expectRevert(\"BLS public key is banned or not a part of LSD network\");\n        vault.depositETHForStaking(\n            blsPubKeyTwo,\n            maxStakingAmountPerValidator\n        );\n    }\n\n    function testDepositETHForStakingRevertsWhenLifecycleIsNotInitialsRegistered() public {\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 3);\n        vm.expectRevert(\"Lifecycle status must be one\");\n        vault.depositETHForStaking(\n            blsPubKeyTwo,\n            maxStakingAmountPerValidator\n        );\n    }\n\n    function testDepositETHForStakingRevertsWhenNoETHAttached() public {\n        vm.expectRevert(\"Must provide correct amount of ETH\");\n        vault.depositETHForStaking(\n            blsPubKeyTwo,\n            maxStakingAmountPerValidator\n        );\n    }\n\n    function testBurnLPTokensByBLSRevertsWhenArraysAreEmpty() public {\n        vm.expectRevert(\"Empty arrays\");\n        vault.burnLPTokensForETHByBLS(\n            getEmptyBytesArray(),\n            getEmptyUint256Array()\n        );\n    }\n\n    function testBurnLPTokensByBLSRevertsWhenArraysAreInconsistentLength() public {\n        vm.expectRevert(\"Inconsistent array length\");\n        vault.burnLPTokensForETHByBLS(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            getEmptyUint256Array()\n        );\n    }\n\n    function testBurnLPTokensByBLSRevertsWhenNothingStakedForBLS() public {\n        vm.expectRevert(\"No ETH staked for specified BLS key\");\n        vault.burnLPTokensForETHByBLS(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            getUint256ArrayFromValues(maxStakingAmountPerValidator)\n        );\n    }\n\n    function testBurnLPTokensRevertsWhenArrayIsEmpty() public {\n        LPToken[] memory tokens = new LPToken[](0);\n        vm.expectRevert(\"Empty arrays\");\n        vault.burnLPTokensForETH(\n            tokens,\n            getEmptyUint256Array()\n        );\n    }\n\n    function testBurnLPTokensRevertsWhenArrayLengthsAreInconsistent() public {\n        LPToken[] memory tokens = new LPToken[](1);\n        tokens[0] = LPToken(msg.sender);\n        vm.expectRevert(\"Inconsistent array length\");\n        vault.burnLPTokensForETH(\n            tokens,\n            getEmptyUint256Array()\n        );\n    }\n\n    function testBurnLPTokensWorksAsExpectedForMultipleValidators() public {\n        maxETHDeposit(accountThree, getBytesArrayFromBytes(blsPubKeyOne, blsPubKeyTwo, blsPubKeyThree));\n\n        assertEq(address(vault).balance, 3 * 4 ether);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        vm.prank(accountThree);\n        vault.burnLPTokensForETHByBLS(\n            getBytesArrayFromBytes(blsPubKeyOne, blsPubKeyTwo, blsPubKeyThree),\n            getUint256ArrayFromValues(maxStakingAmountPerValidator, maxStakingAmountPerValidator, maxStakingAmountPerValidator)\n        );\n\n        assertEq(address(vault).balance, 0);\n    }\n\n    function testBurnLPForETHWorksAsExpected() public {\n        maxETHDeposit(accountFive, getBytesArrayFromBytes(blsPubKeyOne));\n\n        // warp speed ahead\n        vm.warp(block.timestamp + 3 hours);\n\n        vm.startPrank(accountFive);\n        vault.burnLPForETH(vault.lpTokenForKnot(blsPubKeyOne), maxStakingAmountPerValidator);\n        vm.stopPrank();\n\n        assertEq(vault.lpTokenForKnot(blsPubKeyOne).totalSupply(), 0);\n        assertEq(vault.lpTokenForKnot(blsPubKeyOne).balanceOf(accountFive), 0);\n        assertEq(address(vault).balance, 0);\n        assertEq(accountFive.balance, maxStakingAmountPerValidator);\n    }\n\n    function testReceiveETHAndDistributeToLPsLinkedToKnotsThatMintedDerivatives() public {\n        // register BLS key with the network\n        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive);\n\n        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool\n        maxETHDeposit(accountTwo, getBytesArrayFromBytes(blsPubKeyFour));\n\n        // Do a deposit of 24 ETH for savETH pool\n        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether);\n\n        stakeAndMintDerivativesSingleKey(blsPubKeyFour);\n\n        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // Deal ETH to the staking funds vault\n        uint256 rewardsAmount = 1.2 ether;\n        vm.deal(address(vault), rewardsAmount);\n        assertEq(address(vault).balance, rewardsAmount);\n        assertEq(vault.previewAccumulatedETH(accountTwo, lpTokenBLSPubKeyFour), rewardsAmount);\n\n        vm.prank(accountTwo);\n        vault.claimRewards(accountThree, getBytesArrayFromBytes(blsPubKeyFour));\n\n        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), 0);\n        assertEq(address(vault).balance, 0);\n        assertEq(accountThree.balance, rewardsAmount);\n        assertEq(vault.claimed(accountTwo, address(lpTokenBLSPubKeyFour)), rewardsAmount);\n        assertEq(vault.claimed(accountThree, address(lpTokenBLSPubKeyFour)), 0);\n    }\n\n    function testReceiveETHAndDistributeToMultipleLPs() public {\n        // register BLS key with the network\n        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive);\n\n        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool\n        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n\n        // Do a deposit of 24 ETH for savETH pool\n        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether);\n\n        stakeAndMintDerivativesSingleKey(blsPubKeyFour);\n\n        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // Deal ETH to the staking funds vault\n        uint256 rewardsAmount = 1.2 ether;\n        vm.deal(address(vault), rewardsAmount);\n        assertEq(address(vault).balance, rewardsAmount);\n        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n\n        vm.prank(accountTwo);\n        vault.claimRewards(accountThree, getBytesArrayFromBytes(blsPubKeyFour));\n\n        assertEq(vault.previewAccumulatedETH(accountTwo, lpTokenBLSPubKeyFour), 0);\n        assertEq(address(vault).balance, rewardsAmount / 2);\n        assertEq(accountThree.balance, rewardsAmount / 2);\n        assertEq(vault.claimed(accountTwo, address(lpTokenBLSPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.claimed(accountThree, address(lpTokenBLSPubKeyFour)), 0);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        vm.prank(accountOne);\n        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n\n        assertEq(accountOne.balance, rewardsAmount / 2);\n        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), 0);\n        assertEq(address(vault).balance, 0);\n        assertEq(vault.claimed(accountOne, address(lpTokenBLSPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.claimed(accountTwo, address(lpTokenBLSPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.totalClaimed(), rewardsAmount);\n        assertEq(vault.totalRewardsReceived(), rewardsAmount);\n    }\n\n    function testReceiveETHAndDistributeDuringLPTransfers() public {\n        // register BLS key with the network\n        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive);\n\n        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool\n        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n\n        // Do a deposit of 24 ETH for savETH pool\n        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether);\n\n        stakeAndMintDerivativesSingleKey(blsPubKeyFour);\n\n        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // Deal ETH to the staking funds vault\n        uint256 rewardsAmount = 1.2 ether;\n        vm.deal(address(vault), rewardsAmount);\n        assertEq(address(vault).balance, rewardsAmount);\n        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n\n        vm.prank(accountTwo);\n        vault.claimRewards(accountThree, getBytesArrayFromBytes(blsPubKeyFour));\n\n        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), 0);\n        assertEq(address(vault).balance, rewardsAmount / 2);\n        assertEq(accountThree.balance, rewardsAmount / 2);\n        assertEq(vault.claimed(accountTwo, address(lpTokenBLSPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.claimed(accountThree, address(lpTokenBLSPubKeyFour)), 0);\n        assertEq(vault.claimed(accountFive, address(lpTokenBLSPubKeyFour)), 0);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        vm.startPrank(accountOne);\n        lpTokenBLSPubKeyFour.transfer(accountFive, 2 ether);\n        vm.stopPrank();\n\n        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), 0);\n        assertEq(address(vault).balance, 0);\n        assertEq(accountOne.balance, rewardsAmount / 2);\n        assertEq(vault.claimed(accountOne, address(lpTokenBLSPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.claimed(accountTwo, address(lpTokenBLSPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.claimed(accountFive, address(lpTokenBLSPubKeyFour)), rewardsAmount / 2);\n        assertEq(vault.totalClaimed(), rewardsAmount);\n        assertEq(vault.totalRewardsReceived(), rewardsAmount);\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LiquidStakingManager } from \"./LiquidStakingManager.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\n\n/// @title MEV and fees vault for a specified liquid staking network\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, SyndicateRewardsProcessor, ReentrancyGuard\n{\n\n    /// @notice signalize that the vault received ETH\n    event ETHDeposited(address sender, uint256 amount);\n\n    /// @notice signalize ETH withdrawal from the vault\n    event ETHWithdrawn(address receiver, address admin, uint256 amount);\n\n    /// @notice signalize ERC20 token recovery by the admin\n    event ERC20Recovered(address admin, address recipient, uint256 amount);\n\n    /// @notice signalize unwrapping of WETH in the vault\n    event WETHUnwrapped(address admin, uint256 amount);\n\n    /// @notice Address of the network manager\n    LiquidStakingManager public liquidStakingNetworkManager;\n\n    /// @notice Total number of LP tokens issued in WEI\n    uint256 public totalShares;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _liquidStakingNetworkManager address of the liquid staking network manager\n    function init(address _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(LiquidStakingManager(payable(_liquidStakingNetworkManager)), _lpTokenFactory);\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == address(liquidStakingNetworkManager), \"Only network manager\");\n        _;\n    }\n\n    /// @notice Allows the liquid staking manager to notify funds vault about new derivatives minted to enable MEV claiming\n    function updateDerivativesMinted() external onlyManager {\n        // We know 4 ETH for the KNOT came from this vault so increase the shares to get a % of vault rewards\n        totalShares += 4 ether;\n    }\n\n    /// @notice For knots that have minted derivatives, update accumulated ETH per LP\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(totalShares);\n    }\n\n    /// @notice Batch deposit ETH for staking against multiple BLS public keys\n    /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n    /// @param _amounts Amounts of ETH being staked for each BLS public key\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            if (address(tokenForKnot) != address(0)) {\n                // Give anything owed to the user before making updates to user state\n                _distributeETHRewardsToUserForToken(\n                    msg.sender,\n                    address(tokenForKnot),\n                    tokenForKnot.balanceOf(msg.sender),\n                    msg.sender\n                );\n            }\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);\n\n            // Ensure user cannot get historical rewards\n            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice Deposit ETH against a BLS public key for staking\n    /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n    /// @param _amount Amount of ETH being staked\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        // Give anything owed to the user before making updates to user state\n        LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if (address(tokenForKnot) != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                msg.sender,\n                address(tokenForKnot),\n                tokenForKnot.balanceOf(msg.sender),\n                msg.sender\n            );\n        }\n\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, true);\n\n        // Ensure user cannot get historical rewards\n        tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n\n        return _amount;\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked by BLS public key\n    /// @param _blsPublicKeys List of BLS public keys that received ETH for staking\n    /// @param _amounts List of amounts of LP tokens being burnt\n    function burnLPTokensForETHByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            require(address(token) != address(0), \"No ETH staked for specified BLS key\");\n            burnLPForETH(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked\n    /// @param _lpTokens Address of LP tokens being burnt\n    /// @param _amounts Amount of LP tokens being burnt\n    function burnLPTokensForETH(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice For a user that has deposited ETH that has not been staked, allow them to burn LP to get ETH back\n    /// @param _lpToken Address of the LP token being burnt\n    /// @param _amount Amount of LP token being burnt\n    function burnLPForETH(LPToken _lpToken, uint256 _amount) public nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(address(_lpToken) != address(0), \"Zero address specified\");\n\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Cannot burn LP tokens\"\n        );\n        require(_lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Too new\");\n\n        updateAccumulatedETHPerLP();\n\n        _lpToken.burn(msg.sender, _amount);\n\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n    }\n\n    /// @notice Any LP tokens for BLS keys that have had their derivatives minted can claim ETH from the syndicate contract\n    /// @param _blsPubKeys List of BLS public keys being processed\n    function claimRewards(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            require(\n                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,\n                \"Unknown BLS public key\"\n            );\n\n            // Ensure that the BLS key has its derivatives minted\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Derivatives not minted\"\n            );\n\n            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n                _claimFundsFromSyndicateForDistribution(\n                    liquidStakingNetworkManager.syndicate(),\n                    _blsPubKeys\n                );\n\n                // Distribute ETH per LP\n                updateAccumulatedETHPerLP();\n            }\n\n            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            require(address(token) != address(0), \"Invalid BLS key\");\n            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n        }\n    }\n\n    /// @notice function to allow admins to withdraw ETH from the vault for staking purpose\n    /// @param _wallet address of the smart wallet that receives ETH\n    /// @param _amount number of ETH withdrawn\n    /// @return number of ETH withdrawn\n    function withdrawETH(address _wallet, uint256 _amount) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 4 ether, \"Amount cannot be less than 4 ether\");\n        require(_amount <= address(this).balance, \"Not enough ETH to withdraw\");\n        require(_wallet != address(0), \"Zero address\");\n\n        (bool result,) = _wallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawn(_wallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice For any knots that are no longer part of syndicate facilitate unstaking so that knot can rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function unstakeSyndicateSharesForRageQuit(\n        address _sETHRecipient,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyManager nonReentrant {\n        Syndicate syndicate = Syndicate(payable(liquidStakingNetworkManager.syndicate()));\n\n        _claimFundsFromSyndicateForDistribution(address(syndicate), _blsPublicKeys);\n\n        updateAccumulatedETHPerLP();\n\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            require(syndicate.isNoLongerPartOfSyndicate(_blsPublicKeys[i]), \"Knot is still active in syndicate\");\n        }\n\n        syndicate.unstake(address(this), _sETHRecipient, _blsPublicKeys, _amounts);\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETHByBLSKeys(address _user, bytes[] calldata _blsPubKeys) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            totalAccumulated += previewAccumulatedETH(_user, token);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETH(address _user, LPToken[] calldata _token) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _token.length; ++i) {\n            totalAccumulated += previewAccumulatedETH(_user, _token[i]);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with a KNOT that has minted derivatives\n    function previewAccumulatedETH(address _user, LPToken _token) public view returns (uint256) {\n        // if token maps to BLS public key that has not been minted derivatives then return zero as it's not eligible\n        bytes memory associatedBLSPublicKeyOfLpToken = KnotAssociatedWithLPToken[_token];\n        if (getAccountManager().blsPublicKeyToLifecycleStatus(associatedBLSPublicKeyOfLpToken) != IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            return 0;\n        }\n\n        // Looking at this contract balance and the ETH that is yet to be transferred from the syndicate, then tell the user how much ETH they have earned\n        address payable syndicate = payable(liquidStakingNetworkManager.syndicate());\n        return _previewAccumulatedETH(\n            _user,\n            address(_token),\n            _token.balanceOf(_user),\n            totalShares,\n            Syndicate(syndicate).previewUnclaimedETHAsFreeFloatingStaker(\n                address(this),\n                associatedBLSPublicKeyOfLpToken\n            )\n        );\n    }\n\n    /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n    function beforeTokenTransfer(address _from, address _to, uint256) external override {\n        address syndicate = liquidStakingNetworkManager.syndicate();\n        if (syndicate != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            bytes memory blsPubKey = KnotAssociatedWithLPToken[token];\n            require(blsPubKey.length > 0, \"Invalid token\");\n\n            if (getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n                // Claim any ETH for the BLS key mapped to this token\n                bytes[] memory keys = new bytes[](1);\n                keys[0] = blsPubKey;\n                _claimFundsFromSyndicateForDistribution(syndicate, keys);\n\n                // Update the accumulated ETH per minted derivative LP share\n                updateAccumulatedETHPerLP();\n\n                // distribute any due rewards for the `from` user\n                if (_from != address(0)) {\n                    _distributeETHRewardsToUserForToken(_from, address(token), token.balanceOf(_from), _from);\n                }\n\n                // in case the new user has existing rewards - give it to them so that the after transfer hook does not wipe pending rewards\n                _distributeETHRewardsToUserForToken(_to, address(token), token.balanceOf(_to), _to);\n            }\n        }\n    }\n\n    /// @notice After an LP token is transferred, ensure that the new account cannot claim historical rewards\n    function afterTokenTransfer(address, address _to, uint256) external override {\n        if (LiquidStakingManager(payable(liquidStakingNetworkManager)).syndicate() != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            require(KnotAssociatedWithLPToken[token].length > 0, \"Invalid token\");\n\n            // claim is calculated on full balance not amount being transferred so that double claims are not possible\n            claimed[_to][address(token)] = (token.balanceOf(_to) * accumulatedETHPerLPShare) / PRECISION;\n        }\n    }\n\n    /// @notice Claim ETH to this contract from the syndicate that was accrued by a list of actively staked validators\n    /// @param _blsPubKeys List of BLS public key identifiers of validators that have sETH staked in the syndicate for the vault\n    function claimFundsFromSyndicateForDistribution(bytes[] memory _blsPubKeys) external {\n        _claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(), _blsPubKeys);\n    }\n\n    /// @dev Claim ETH from syndicate for a list of BLS public keys for later distribution amongst LPs\n    function _claimFundsFromSyndicateForDistribution(address _syndicate, bytes[] memory _blsPubKeys) internal {\n        require(_syndicate != address(0), \"Invalid configuration\");\n\n        // Claim all of the ETH due from the syndicate for the auto-staked sETH\n        Syndicate syndicateContract = Syndicate(payable(_syndicate));\n        syndicateContract.claimAsStaker(address(this), _blsPubKeys);\n\n        updateAccumulatedETHPerLP();\n    }\n\n    /// @dev Initialization logic\n    function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {\n        require(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero Address\");\n\n        liquidStakingNetworkManager = _liquidStakingNetworkManager;\n        lpTokenFactory = _lpTokenFactory;\n\n        baseLPTokenName = \"ETHLPToken_\";\n        baseLPTokenSymbol = \"ETHLP_\";\n        maxStakingAmountPerValidator = 4 ether;\n    }\n}\n\n",
        "CodeNames": [
            "StakingFundsVault.t.sol",
            "StakingFundsVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StakingFundsVault contract",
                "Type": "Stealing deposits",
                "Description": "Old stakers can steal deposits of new stakers in StakingFundsVault.",
                "Repair": "Exclude newly staked amounts in the accumulatedETHPerLPShare calculations"
            },
            {
                "Location": "StakingFundsVault.sol",
                "Type": "User receives less rewards than they are eligible for",
                "Description": "The issue is that updateAccumulatedETHPerLP() is not guaranteed to be called, which means the ETH reward distribution in _distribute would use stale value, and users will not receive as many rewards as they should.",
                "Repair": "Call updateAccumulatedETHPerLP() at the start of the function."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @notice Allows a contract to receive rewards from a syndicate and distribute it amongst LP holders\nabstract contract SyndicateRewardsProcessor {\n\n    /// @notice Emitted when ETH is received by the contract and processed\n    event ETHReceived(uint256 amount);\n\n    /// @notice Emitted when ETH from syndicate is distributed to a user\n    event ETHDistributed(address indexed user, address indexed recipient, uint256 amount);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accumulated ETH per share of LP<>KNOT that has minted derivatives scaled to 'PRECISION'\n    uint256 public accumulatedETHPerLPShare;\n\n    /// @notice Total ETH claimed by all users of the contract\n    uint256 public totalClaimed;\n\n    /// @notice Last total rewards seen by the contract\n    uint256 public totalETHSeen;\n\n    /// @notice Total ETH claimed by a given address for a given token\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @dev Internal logic for previewing accumulated ETH for an LP user\n    function _previewAccumulatedETH(\n        address _sender,\n        address _token,\n        uint256 _balanceOfSender,\n        uint256 _numOfShares,\n        uint256 _unclaimedETHFromSyndicate\n    ) internal view returns (uint256) {\n        if (_balanceOfSender > 0) {\n            uint256 claim = claimed[_sender][_token];\n\n            uint256 received = totalRewardsReceived() + _unclaimedETHFromSyndicate;\n            uint256 unprocessed = received - totalETHSeen;\n\n            uint256 newAccumulatedETH = accumulatedETHPerLPShare + ((unprocessed * PRECISION) / _numOfShares);\n\n            return ((newAccumulatedETH * _balanceOfSender) / PRECISION) - claim;\n        }\n        return 0;\n    }\n\n    /// @dev Any due rewards from node running can be distributed to msg.sender if they have an LP balance\n    function _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance > 0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n            if (due > 0) {\n                claimed[_user][_token] = due;\n\n                totalClaimed += due;\n\n                (bool success, ) = _recipient.call{value: due}(\"\");\n                require(success, \"Failed to transfer\");\n\n                emit ETHDistributed(_user, _recipient, due);\n            }\n        }\n    }\n\n    /// @dev Internal logic for tracking accumulated ETH per share\n    function _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n        if (_numOfShares > 0) {\n            uint256 received = totalRewardsReceived();\n            uint256 unprocessed = received - totalETHSeen;\n\n            if (unprocessed > 0) {\n                emit ETHReceived(unprocessed);\n\n                // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n                accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n                totalETHSeen = received;\n            }\n        }\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate\n    function totalRewardsReceived() public virtual view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @notice Allow the contract to receive ETH\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "SyndicateRewardsProcessor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SyndicateRewardsProcessor contract",
                "Type": "Incorrect accounting",
                "Description": "The claimed amount is set equal to the calculated due amount instead of being increased by the due amount, allowing LP token holders to repeatedly claim rewards and steal other LP token holders' ETH from the fees and MEV vault.",
                "Repair": "Increase the claimed amount by the due amount instead of setting it equal to the due amount"
            },
            {
                "Location": "SyndicateRewardsProcessor contract, afterTokenTransfer() function",
                "Type": "Integer Overflow",
                "Description": "When a user transfers away GiantMevAndFeesPool tokens, the pool's claimed[] computed is left unchanged and still corresponds to what they had claimed with their old (higher) number of tokens. The erroneous claimed value can cause an integer overflow when the claimed[] value is subtracted, leading to inability for this user to access some functions of the GiantMevAndFeesPool including such things as being able to transfer their tokens (overflow is triggered in a callback attempting to pay out their rewards). These overflows will occur in SyndicateRewardsProcessor's _previewAccumulatedETH() and _distributeETHRewardsToUserForToken(), the latter of which is called in a number of places. When rewards are later accumulated in the pool, the user will not be able to claim certain rewards owed to them because of the incorrect (high) claimed[] value. The excess rewards will be orphaned in the pool.",
                "Repair": "Reduce 'claimed[]' when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[]."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper) {\n            gatekeeper = OptionalGatekeeperFactory(_optionalGatekeeperDeployer).deploy(address(this));\n        }\n    }\n\n    /// @dev function checks if a node runner is valid depending upon whitelisting status\n    /// @param _nodeRunner address of the user requesting to become node runner\n    /// @return true if eligible. reverts with message if not eligible\n    function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {\n        require(_nodeRunner != address(0), \"Zero address\");\n\n        if(enableWhitelisting) {\n            require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");\n        }\n\n        return true;\n    }\n\n    /// @dev Manage the removal and appointing of smart wallet representatives including managing state\n    function _authorizeRepresentative(\n        address _smartWallet, \n        address _eoaRepresentative, \n        bool _isEnabled\n    ) internal {\n        if(!_isEnabled && smartWalletRepresentative[_smartWallet] != address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // delete the mapping\n            delete smartWalletRepresentative[_smartWallet];\n\n            emit RepresentativeRemoved(_smartWallet, _eoaRepresentative);\n        }\n        else if(_isEnabled && smartWalletRepresentative[_smartWallet] == address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // store EOA to the wallet mapping\n            smartWalletRepresentative[_smartWallet] = _eoaRepresentative;\n\n            emit RepresentativeAppointed(_smartWallet, _eoaRepresentative);\n        } else {\n            revert(\"Unexpected state\");\n        }\n    }\n\n    /// @dev Internal method for doing just staking - pre-checks done outside this method to avoid stack too deep\n    function _stake(\n        bytes calldata _blsPublicKey,\n        bytes calldata _cipherText,\n        bytes calldata _aesEncryptorKey,\n        IDataStructures.EIP712Signature calldata _encryptionSignature,\n        bytes32 dataRoot\n    ) internal {\n        address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n        // send 24 ether from savETH vault to smart wallet\n        savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n        // send 4 ether from DAO staking funds vault\n        stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n        // interact with transaction router using smart wallet to deposit 32 ETH\n        IOwnableSmartWallet(smartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.registerValidator.selector,\n                smartWallet,\n                _blsPublicKey,\n                _cipherText,\n                _aesEncryptorKey,\n                _encryptionSignature,\n                dataRoot\n            ),\n            32 ether\n        );\n\n        // increment number of staked KNOTs in the wallet\n        stakedKnotsOfSmartWallet[smartWallet] += 1;\n\n        emit KnotStaked(_blsPublicKey, msg.sender);\n    }\n\n    /// @dev The second knot onwards will join the LSDN stakehouse and expand the registered syndicate knots\n    function _joinLSDNStakehouse(\n        bytes calldata _blsPubKey,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // total number of knots created with the syndicate increases\n        numberOfKnots += 1;\n\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPubKey];\n\n        // Join the LSDN stakehouse\n        string memory lowerTicker = IBrandNFT(brand).toLowerCase(stakehouseTicker);\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.joinStakehouse.selector,\n                associatedSmartWallet,\n                _blsPubKey,\n                stakehouse,\n                IBrandNFT(brand).lowercaseBrandTickerToTokenId(lowerTicker),\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Register the knot to the syndicate\n        bytes[] memory _blsPublicKeyOfKnots = new bytes[](1);\n        _blsPublicKeyOfKnots[0] = _blsPubKey;\n        Syndicate(payable(syndicate)).registerKnotsToSyndicate(_blsPublicKeyOfKnots);\n\n        // Autostake DAO sETH with the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPubKey);\n\n        emit StakehouseJoined(_blsPubKey);\n    }\n\n    /// @dev Perform all the steps required to create the LSDN stakehouse that other knots will join\n    function _createLSDNStakehouse(\n        bytes calldata _blsPublicKeyOfKnot,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // create stakehouse and mint derivative for first bls key - the others are just used to create the syndicate\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.createStakehouse.selector,\n                associatedSmartWallet,\n                _blsPublicKeyOfKnot,\n                stakehouseTicker,\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Number of knots has increased\n        numberOfKnots += 1;\n\n        // Capture the address of the Stakehouse for future knots to join\n        stakehouse = getStakeHouseUniverse().memberKnotToStakeHouse(_blsPublicKeyOfKnot);\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        // Give liquid staking manager ability to manage keepers and set a house keeper if decided by the network\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            stakehouse,\n            abi.encodeWithSelector(\n                Ownable.transferOwnership.selector,\n                address(this)\n            )\n        );\n\n        if (address(gatekeeper) != address(0)) {\n            IStakeHouseRegistry(stakehouse).setGateKeeper(address(gatekeeper));\n        }\n\n        // Deploy the EIP1559 transaction reward sharing contract but no priority required because sETH will be auto staked\n        address[] memory priorityStakers = new address[](0);\n        bytes[] memory initialKnots = new bytes[](1);\n        initialKnots[0] = _blsPublicKeyOfKnot;\n        syndicate = syndicateFactory.deploySyndicate(\n            address(this),\n            0,\n            priorityStakers,\n            initialKnots\n        );\n\n        // Contract approves syndicate to take sETH on behalf of the DAO\n        sETH.approve(syndicate, (2 ** 256) - 1);\n\n        // Auto-stake sETH by pulling sETH out the smart wallet and staking in the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPublicKeyOfKnot);\n\n        emit StakehouseCreated(stakehouseTicker, stakehouse);\n    }\n\n    /// @dev Remove the sETH from the node runner smart wallet in order to auto-stake the sETH in the syndicate\n    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        uint256 stakeAmount = 12 ether;\n        IOwnableSmartWallet(_associatedSmartWallet).execute(\n            address(sETH),\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                address(this),\n                stakeAmount\n            )\n        );\n\n        // Create the payload for staking\n        bytes[] memory stakingKeys = new bytes[](1);\n        stakingKeys[0] = _blsPubKey;\n\n        uint256[] memory stakeAmounts = new uint256[](1);\n        stakeAmounts[0] = stakeAmount;\n\n        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)\n        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));\n    }\n\n    /// @dev Something that can be overriden during testing\n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n\n    function _initStakingFundsVault(address _stakingFundsVaultDeployer, address _tokenFactory) internal virtual {\n        stakingFundsVault = StakingFundsVault(\n            payable(StakingFundsVaultDeployer(_stakingFundsVaultDeployer).deployStakingFundsVault(\n                address(this),\n                _tokenFactory\n            ))\n        );\n    }\n\n    /// @dev This can be overriden to customise fee percentages\n    function _calculateCommission(uint256 _received) internal virtual view returns (uint256 _nodeRunner, uint256 _dao) {\n        require(_received > 0, \"Nothing received\");\n\n        if (daoCommissionPercentage > 0) {\n            uint256 daoAmount = (_received * daoCommissionPercentage) / MODULO;\n            uint256 rest = _received - daoAmount;\n            return (rest, daoAmount);\n        }\n\n        return (_received, 0);\n    }\n\n    /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\n    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n    }\n\n    /// @dev Internal method for dao to trigger updating commission it takes of node runner revenue\n    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {\n        require(_commissionPercentage <= MODULO, \"Invalid commission\");\n\n        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);\n\n        daoCommissionPercentage = _commissionPercentage;\n    }\n}\n\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport \"forge-std/console.sol\";\n\nimport { TestUtils } from \"../utils/TestUtils.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\nimport { MockSavETHRegistry } from \"../../contracts/testing/stakehouse/MockSavETHRegistry.sol\";\n\ncontract LiquidStakingManagerTests is TestUtils {\n\n    function setUp() public {\n        vm.startPrank(accountFive); // this will mean it gets dETH initial supply\n        factory = createMockLSDNFactory();\n        vm.stopPrank();\n\n        // Deploy 1 network and get default dependencies\n        manager = deployNewLiquidStakingNetwork(\n            factory,\n            admin,\n            true,\n            \"LSDN\"\n        );\n\n        savETHVault = getSavETHVaultFromManager(manager);\n        stakingFundsVault = getStakingFundsVaultFromManager(manager);\n\n        // make 'admin' the 'DAO'\n        vm.prank(address(factory));\n        manager.updateDAOAddress(admin);\n    }\n\n    // todo - test for multiple knots\n    function testDAOCanCoordinateRageQuitOfOnlyKnotInNetwork() public {\n        // Set up users and ETH\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n        // Do everything from funding a validator within default LSDN to minting derivatives\n        depositStakeAndMintDerivativesForDefaultNetwork(\n            nodeRunner,\n            feesAndMevUser,\n            savETHUser,\n            blsPubKeyFour\n        );\n\n        // Send syndicate some EIP1559 rewards\n        uint256 eip1559Tips = 0.6743 ether;\n        sendEIP1559RewardsToSyndicateAtAddress(eip1559Tips, manager.syndicate());\n\n        // Claim dETH as savETH user\n        IERC20 dETHToken = savETHVault.dETHToken();\n        vm.startPrank(accountFive);\n        dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether * 2);\n        vm.stopPrank();\n\n        vm.startPrank(savETHUser);\n        savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyFour), getUint256ArrayFromValues(24 ether));\n        vm.stopPrank();\n        assertEq(dETHToken.balanceOf(savETHUser), 24 ether);\n\n        // Check there are some rewards to claim by staking funds vault\n        assertEq(\n            manager.stakingFundsVault().previewAccumulatedETH(feesAndMevUser, stakingFundsVault.lpTokenForKnot(blsPubKeyFour)),\n            (eip1559Tips / 2) - 1\n        );\n\n        // now de-register knot from syndicate to send sETH back to smart wallet\n        IERC20 sETH = IERC20(MockSlotRegistry(factory.slot()).stakeHouseShareTokens(manager.stakehouse()));\n        uint256 sETHBalanceBefore = sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner));\n        vm.startPrank(admin);\n        manager.deRegisterKnotFromSyndicate(getBytesArrayFromBytes(blsPubKeyFour));\n        manager.restoreFreeFloatingSharesToSmartWalletForRageQuit(\n            manager.smartWalletOfNodeRunner(nodeRunner),\n            getBytesArrayFromBytes(blsPubKeyFour),\n            getUint256ArrayFromValues(12 ether)\n        );\n        vm.stopPrank();\n\n        assertEq(\n            sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner)) - sETHBalanceBefore,\n            12 ether\n        );\n\n        // As long as the smart wallet has free floating and collateralized SLOT + dETH isolated, then we assume rage quit will work at stakehouse level\n        // We execute an arbitrary transaction here to confirm `executeAsSmartWallet` is working as if rage quit took place\n        assertEq(savETHVault.saveETHRegistry().knotDETHBalanceInIndex(1, blsPubKeyFour), 24 ether);\n        savETHVault.saveETHRegistry().setBalInIndex(1, blsPubKeyFour, 1);\n        vm.startPrank(admin);\n        manager.executeAsSmartWallet(\n            nodeRunner,\n            address(savETHVault.saveETHRegistry()),\n            abi.encodeWithSelector(\n                MockSavETHRegistry.setBalInIndex.selector,\n                1,\n                blsPubKeyFour,\n                1\n            ),\n            0\n        );\n        vm.stopPrank();\n        assertEq(savETHVault.saveETHRegistry().knotDETHBalanceInIndex(1, blsPubKeyFour), 1);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // Now, as Staking funds vault LP holder you should be able to claim rewards accrued up to point of pulling the plug\n        vm.startPrank(feesAndMevUser);\n        stakingFundsVault.claimRewards(feesAndMevUser, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(feesAndMevUser.balance, (eip1559Tips / 2) - 1);\n\n        // As collateralized SLOT holder for BLS pub key four, you should be able to claim rewards accrued up to point of pulling the plug\n        vm.startPrank(nodeRunner);\n        manager.claimRewardsAsNodeRunner(nodeRunner, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(nodeRunner.balance, (eip1559Tips / 2));\n    }\n}\n\n",
        "CodeNames": [
            "LiquidStakingManager.sol",
            "LiquidStakingManager.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LiquidStakingManager.rotateNodeRunnerOfSmartWallet()",
                "Type": "Funds theft",
                "Description": "DAO or LSD network owner can swap node runner of the smart contract to their own EOA, allowing them to withdraw ETH or claim rewards from node runner. There are no checks done when swapping the node runner whether there are funds in the smart contract that belongs to the node runner.",
                "Repair": "Restrict the 'rotateNodeRunnerOfSmartWallet()' function to DAO only with the 'onlyDAO' modifier"
            },
            {
                "Location": "LiquidStakingManager.rotateNodeRunnerOfSmartWallet()",
                "Type": "Frontrun attack",
                "Description": "rotateNodeRunnerOfSmartWallet() is vulnerable to a frontrun attack if the current node runner is malicious. If that is the case, the DAO would purposely call the same function with the '_wasPreviousNodeRunnerMalicious' flag turned on. An actual node runner that has been malicious could monitor the mempool and frontrun the DAO transaction that wanted to slash it and submit the transaction before the DAO to avoid getting banned and rotate their EOA representation of the node.",
                "Repair": "Restrict the 'rotateNodeRunnerOfSmartWallet()' function to DAO only with the 'onlyDAO' modifier"
            },
            {
                "Location": "LiquidStakingManager.sol",
                "Type": "Functionality",
                "Description": "Calling updateNodeRunnerWhitelistStatus function always reverts, preventing the DAO from whitelisting any trusted node runners and limiting the protocol's usability.",
                "Repair": "Update the require statement in updateNodeRunnerWhitelistStatus function to check for isNodeRunnerWhitelisted[_nodeRunner] != isWhitelisted"
            },
            {
                "Location": "withdrawETHForKnot function in LiquidStakingManager.sol",
                "Type": "Reentrancy",
                "Description": "The reentrancy bug in the withdrawETHForKnot function allows a node runner to reenter the LiquidStakingManager and stake deposited funds from the vaults before the BLS key is banned, causing a permanent freeze of user funds and making the protocol insolvent.",
                "Repair": "Use mutex locks to prevent reentrancy or use the Checks-Effects-Interactions pattern to ensure that all state changes are made before any external calls are made"
            },
            {
                "Location": "LiquidStakingManager.sol",
                "Type": "Arbitrary Execution",
                "Description": "DAO admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution.",
                "Repair": "Disallow DAO admin from performing arbitrary execution to access user's fund"
            },
            {
                "Location": "LiquidStakingManager.sol",
                "Type": "Adding non-EOA representative",
                "Description": "It is not allowed to add non-EOA representative to the smart wallet. But, this limitation can be bypassed by rotating representatives.",
                "Repair": "Add a check to ensure that _newRepresentative is an EOA in functions rotateEOARepresentative and rotateEOARepresentativeOfNodeRunner"
            },
            {
                "Location": "function registerBLSPublicKeys() and function rotateNodeRunnerOfSmartWallet() in LiquidStakingManager.sol",
                "Type": "ineffective banning of malicious node runner",
                "Description": "Node runner who is already known to be malicious cannot be banned before corresponding smart wallet is created.",
                "Repair": "Add a function that can directly set bannedNodeRunners for a node runner and can only be called by the DAO"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "GiantSavETHVaultPool.sol",
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GiantSavETHVaultPool.sol, GiantMevAndFeesPool.sol",
                "Type": "Functionality",
                "Description": "Giant pools cannot receive ETH from vaults, causing an insolvency issue when many users want to withdraw ETH and there is not enough liquidity inside the giant pools.",
                "Repair": "Add a fallback or receive function to the pools and increase idleETH with the received ETH"
            },
            {
                "Location": "GiantMevAndFeesPool.sol, GiantSavETHVaultPool.sol",
                "Type": "Stuck ether funds",
                "Description": "idleETH variable is not updated. idleETH  is the available ETH for withdrawing and depositing eth for staking. Since there is no other places that updates idleETH other than depositing eth for staking and withdrawing eth, the eth withdrawn from the vault will be stuck forever.",
                "Repair": "Update idleETH in withdrawUnusedETHToGiantPool"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport { ILPTokenInit } from \"../interfaces/ILPTokenInit.sol\";\nimport { ILiquidStakingManagerChildContract } from \"../interfaces/ILiquidStakingManagerChildContract.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\ncontract LPToken is ILPTokenInit, ILiquidStakingManagerChildContract, Initializable, ERC20PermitUpgradeable {\n\n    /// @notice Contract deployer that can control minting and burning but is associated with a liquid staking manager\n    address public deployer;\n\n    /// @notice Optional hook for processing transfers\n    ITransferHookProcessor transferHookProcessor;\n\n    /// @notice Whenever the address last interacted with a token\n    mapping(address => uint256) public lastInteractedTimestamp;\n\n    modifier onlyDeployer {\n        require(msg.sender == deployer, \"Only savETH vault\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _deployer Address of the account deploying the LP token\n    /// @param _transferHookProcessor Optional contract account that can be notified about transfer hooks\n    function init(\n        address _deployer,\n        address _transferHookProcessor,\n        string calldata _tokenSymbol,\n        string calldata _tokenName\n    ) external override initializer {\n        deployer = _deployer;\n        transferHookProcessor = ITransferHookProcessor(_transferHookProcessor);\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __ERC20Permit_init(_tokenName);\n    }\n\n    /// @notice Mints a given amount of LP tokens\n    /// @dev Only savETH vault can mint\n    function mint(address _recipient, uint256 _amount) external onlyDeployer {\n        _mint(_recipient, _amount);\n    }\n\n    /// @notice Allows a LP token owner to burn their tokens\n    function burn(address _recipient, uint256 _amount) external onlyDeployer {\n        _burn(_recipient, _amount);\n    }\n\n    /// @notice In order to know the liquid staking network and manager associated with the LP token, call this\n    function liquidStakingManager() external view returns (address) {\n        return ILiquidStakingManagerChildContract(deployer).liquidStakingManager();\n    }\n\n    /// @dev If set, notify the transfer hook processor before token transfer\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        if (address(transferHookProcessor) != address(0)) transferHookProcessor.beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    /// @dev If set, notify the transfer hook processor after token transfer\n    function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        lastInteractedTimestamp[_from] = block.timestamp;\n        lastInteractedTimestamp[_to] = block.timestamp;\n        if (address(transferHookProcessor) != address(0)) transferHookProcessor.afterTokenTransfer(_from, _to, _amount);\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "LPToken.sol",
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GiantMevAndFeesPool and LPToken contracts",
                "Type": "Locking Rewards for All Users",
                "Description": "Any malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users by exploiting the vulnerability in the inherited functions of the ERC20 tokens.",
                "Repair": "Protect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because transfer is not protected and can trigger the before and after hooks"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper) {\n            gatekeeper = OptionalGatekeeperFactory(_optionalGatekeeperDeployer).deploy(address(this));\n        }\n    }\n\n    /// @dev function checks if a node runner is valid depending upon whitelisting status\n    /// @param _nodeRunner address of the user requesting to become node runner\n    /// @return true if eligible. reverts with message if not eligible\n    function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {\n        require(_nodeRunner != address(0), \"Zero address\");\n\n        if(enableWhitelisting) {\n            require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");\n        }\n\n        return true;\n    }\n\n    /// @dev Manage the removal and appointing of smart wallet representatives including managing state\n    function _authorizeRepresentative(\n        address _smartWallet, \n        address _eoaRepresentative, \n        bool _isEnabled\n    ) internal {\n        if(!_isEnabled && smartWalletRepresentative[_smartWallet] != address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // delete the mapping\n            delete smartWalletRepresentative[_smartWallet];\n\n            emit RepresentativeRemoved(_smartWallet, _eoaRepresentative);\n        }\n        else if(_isEnabled && smartWalletRepresentative[_smartWallet] == address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // store EOA to the wallet mapping\n            smartWalletRepresentative[_smartWallet] = _eoaRepresentative;\n\n            emit RepresentativeAppointed(_smartWallet, _eoaRepresentative);\n        } else {\n            revert(\"Unexpected state\");\n        }\n    }\n\n    /// @dev Internal method for doing just staking - pre-checks done outside this method to avoid stack too deep\n    function _stake(\n        bytes calldata _blsPublicKey,\n        bytes calldata _cipherText,\n        bytes calldata _aesEncryptorKey,\n        IDataStructures.EIP712Signature calldata _encryptionSignature,\n        bytes32 dataRoot\n    ) internal {\n        address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n        // send 24 ether from savETH vault to smart wallet\n        savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n        // send 4 ether from DAO staking funds vault\n        stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n        // interact with transaction router using smart wallet to deposit 32 ETH\n        IOwnableSmartWallet(smartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.registerValidator.selector,\n                smartWallet,\n                _blsPublicKey,\n                _cipherText,\n                _aesEncryptorKey,\n                _encryptionSignature,\n                dataRoot\n            ),\n            32 ether\n        );\n\n        // increment number of staked KNOTs in the wallet\n        stakedKnotsOfSmartWallet[smartWallet] += 1;\n\n        emit KnotStaked(_blsPublicKey, msg.sender);\n    }\n\n    /// @dev The second knot onwards will join the LSDN stakehouse and expand the registered syndicate knots\n    function _joinLSDNStakehouse(\n        bytes calldata _blsPubKey,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // total number of knots created with the syndicate increases\n        numberOfKnots += 1;\n\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPubKey];\n\n        // Join the LSDN stakehouse\n        string memory lowerTicker = IBrandNFT(brand).toLowerCase(stakehouseTicker);\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.joinStakehouse.selector,\n                associatedSmartWallet,\n                _blsPubKey,\n                stakehouse,\n                IBrandNFT(brand).lowercaseBrandTickerToTokenId(lowerTicker),\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Register the knot to the syndicate\n        bytes[] memory _blsPublicKeyOfKnots = new bytes[](1);\n        _blsPublicKeyOfKnots[0] = _blsPubKey;\n        Syndicate(payable(syndicate)).registerKnotsToSyndicate(_blsPublicKeyOfKnots);\n\n        // Autostake DAO sETH with the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPubKey);\n\n        emit StakehouseJoined(_blsPubKey);\n    }\n\n    /// @dev Perform all the steps required to create the LSDN stakehouse that other knots will join\n    function _createLSDNStakehouse(\n        bytes calldata _blsPublicKeyOfKnot,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // create stakehouse and mint derivative for first bls key - the others are just used to create the syndicate\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.createStakehouse.selector,\n                associatedSmartWallet,\n                _blsPublicKeyOfKnot,\n                stakehouseTicker,\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Number of knots has increased\n        numberOfKnots += 1;\n\n        // Capture the address of the Stakehouse for future knots to join\n        stakehouse = getStakeHouseUniverse().memberKnotToStakeHouse(_blsPublicKeyOfKnot);\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        // Give liquid staking manager ability to manage keepers and set a house keeper if decided by the network\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            stakehouse,\n            abi.encodeWithSelector(\n                Ownable.transferOwnership.selector,\n                address(this)\n            )\n        );\n\n        if (address(gatekeeper) != address(0)) {\n            IStakeHouseRegistry(stakehouse).setGateKeeper(address(gatekeeper));\n        }\n\n        // Deploy the EIP1559 transaction reward sharing contract but no priority required because sETH will be auto staked\n        address[] memory priorityStakers = new address[](0);\n        bytes[] memory initialKnots = new bytes[](1);\n        initialKnots[0] = _blsPublicKeyOfKnot;\n        syndicate = syndicateFactory.deploySyndicate(\n            address(this),\n            0,\n            priorityStakers,\n            initialKnots\n        );\n\n        // Contract approves syndicate to take sETH on behalf of the DAO\n        sETH.approve(syndicate, (2 ** 256) - 1);\n\n        // Auto-stake sETH by pulling sETH out the smart wallet and staking in the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPublicKeyOfKnot);\n\n        emit StakehouseCreated(stakehouseTicker, stakehouse);\n    }\n\n    /// @dev Remove the sETH from the node runner smart wallet in order to auto-stake the sETH in the syndicate\n    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        uint256 stakeAmount = 12 ether;\n        IOwnableSmartWallet(_associatedSmartWallet).execute(\n            address(sETH),\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                address(this),\n                stakeAmount\n            )\n        );\n\n        // Create the payload for staking\n        bytes[] memory stakingKeys = new bytes[](1);\n        stakingKeys[0] = _blsPubKey;\n\n        uint256[] memory stakeAmounts = new uint256[](1);\n        stakeAmounts[0] = stakeAmount;\n\n        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)\n        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));\n    }\n\n    /// @dev Something that can be overriden during testing\n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n\n    function _initStakingFundsVault(address _stakingFundsVaultDeployer, address _tokenFactory) internal virtual {\n        stakingFundsVault = StakingFundsVault(\n            payable(StakingFundsVaultDeployer(_stakingFundsVaultDeployer).deployStakingFundsVault(\n                address(this),\n                _tokenFactory\n            ))\n        );\n    }\n\n    /// @dev This can be overriden to customise fee percentages\n    function _calculateCommission(uint256 _received) internal virtual view returns (uint256 _nodeRunner, uint256 _dao) {\n        require(_received > 0, \"Nothing received\");\n\n        if (daoCommissionPercentage > 0) {\n            uint256 daoAmount = (_received * daoCommissionPercentage) / MODULO;\n            uint256 rest = _received - daoAmount;\n            return (rest, daoAmount);\n        }\n\n        return (_received, 0);\n    }\n\n    /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\n    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n    }\n\n    /// @dev Internal method for dao to trigger updating commission it takes of node runner revenue\n    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {\n        require(_commissionPercentage <= MODULO, \"Invalid commission\");\n\n        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);\n\n        daoCommissionPercentage = _commissionPercentage;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport { console } from \"forge-std/console.sol\";\n\nimport { MockERC20 } from \"../../contracts/testing/MockERC20.sol\";\nimport { SyndicateMock } from \"../../contracts/testing/syndicate/SyndicateMock.sol\";\n\nimport { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";\nimport { MockTransactionRouter } from \"../../contracts/testing/stakehouse/MockTransactionRouter.sol\";\nimport { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\nimport { MockStakeHouseUniverse } from \"../../contracts/testing/stakehouse/MockStakeHouseUniverse.sol\";\n\nimport { SyndicateFactoryMock } from \"../../contracts/testing/syndicate/SyndicateFactoryMock.sol\";\nimport {\n    KnotIsFullyStakedWithFreeFloatingSlotTokens,\n    KnotIsAlreadyRegistered\n} from \"../../contracts/syndicate/SyndicateErrors.sol\";\n\nimport { TestUtils } from \"../utils/TestUtils.sol\";\n\ncontract SyndicateTest is TestUtils {\n\n    MockERC20 public sETH;\n\n    SyndicateFactoryMock public syndicateFactory;\n\n    SyndicateMock public syndicate;\n\n    function blsPubKeyOneAsArray() public view returns (bytes[] memory) {\n        bytes[] memory keys = new bytes[](1);\n        keys[0] = blsPubKeyOne;\n        return keys;\n    }\n\n    function sendEIP1559RewardsToSyndicate(uint256 eip1559Reward) public {\n        (bool success, ) = address(syndicate).call{value: eip1559Reward}(\"\");\n        assertEq(success, true);\n        assertEq(address(syndicate).balance, eip1559Reward);\n    }\n\n    function setUp() public {\n        // Deploy an sETH token for an arbitrary stakehouse\n        sETH = new MockERC20(\"sETH\", \"sETH\", accountOne);\n\n        // Deploy the syndicate but no priority stakers are required\n        address[] memory priorityStakers = new address[](0);\n\n        // Create and inject mock stakehouse dependencies\n        address accountMan = address(new MockAccountManager());\n        address txRouter = address(new MockTransactionRouter());\n        address uni = address(new MockStakeHouseUniverse());\n        address slot = address(new MockSlotRegistry());\n        syndicateFactory = new SyndicateFactoryMock(\n            accountMan,\n            txRouter,\n            uni,\n            slot\n        );\n\n        address payable _syndicate = payable(syndicateFactory.deployMockSyndicate(\n            admin,\n            0, // No priority staking block\n            priorityStakers,\n            blsPubKeyOneAsArray()\n        ));\n\n        syndicate = SyndicateMock(_syndicate);\n\n        // Config mock stakehouse contracts\n        MockSlotRegistry(syndicate.slotReg()).setShareTokenForHouse(houseOne, address(sETH));\n\n        MockStakeHouseUniverse(syndicate.uni()).setAssociatedHouseForKnot(blsPubKeyOne, houseOne);\n        MockStakeHouseUniverse(syndicate.uni()).setAssociatedHouseForKnot(blsPubKeyTwo, houseOne);\n        MockStakeHouseUniverse(syndicate.uni()).setAssociatedHouseForKnot(blsPubKeyThree, houseOne);\n\n        MockSlotRegistry(syndicate.slotReg()).setNumberOfCollateralisedSlotOwnersForKnot(blsPubKeyOne, 1);\n        MockSlotRegistry(syndicate.slotReg()).setNumberOfCollateralisedSlotOwnersForKnot(blsPubKeyTwo, 1);\n        MockSlotRegistry(syndicate.slotReg()).setNumberOfCollateralisedSlotOwnersForKnot(blsPubKeyThree, 1);\n\n        MockSlotRegistry(syndicate.slotReg()).setCollateralisedOwnerAtIndex(blsPubKeyOne, 0, accountTwo);\n        MockSlotRegistry(syndicate.slotReg()).setCollateralisedOwnerAtIndex(blsPubKeyTwo, 0, accountFour);\n        MockSlotRegistry(syndicate.slotReg()).setCollateralisedOwnerAtIndex(blsPubKeyThree, 0, accountFive);\n\n        MockSlotRegistry(syndicate.slotReg()).setUserCollateralisedSLOTBalanceForKnot(houseOne, accountTwo, blsPubKeyOne, 4 ether);\n        MockSlotRegistry(syndicate.slotReg()).setUserCollateralisedSLOTBalanceForKnot(houseOne, accountFour, blsPubKeyTwo, 4 ether);\n        MockSlotRegistry(syndicate.slotReg()).setUserCollateralisedSLOTBalanceForKnot(houseOne, accountFive, blsPubKeyThree, 4 ether);\n    }\n\n    function testSupply() public {\n        assertEq(sETH.totalSupply(), 125_000 * 10 ** 18);\n        assertEq(sETH.balanceOf(accountOne), 125_000 * 10 ** 18);\n    }\n\n    function testThreeKnotsMultipleStakers() public {\n        // Set up test - distribute sETH and register additional knot to syndicate\n        vm.prank(admin);\n        syndicate.registerKnotsToSyndicate(getBytesArrayFromBytes(blsPubKeyTwo));\n\n        vm.startPrank(accountOne);\n        sETH.transfer(accountThree, 500 ether);\n        sETH.transfer(accountFive, 500 ether);\n        vm.stopPrank();\n\n        // for bls pub key one we will have 2 stakers staking 50% each\n        uint256 stakingAmount = 6 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakingAmount;\n\n        vm.startPrank(accountOne);\n        sETH.approve(address(syndicate), stakingAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n        vm.stopPrank();\n\n        vm.startPrank(accountThree);\n        sETH.approve(address(syndicate), stakingAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountThree);\n        vm.stopPrank();\n\n        sETHAmounts[0] = 12 ether;\n        vm.startPrank(accountFive);\n        sETH.approve(address(syndicate), sETHAmounts[0]);\n        syndicate.stake(getBytesArrayFromBytes(blsPubKeyTwo), sETHAmounts, accountFive);\n        vm.stopPrank();\n\n        // send some rewards\n        uint256 eipRewards = 0.0943 ether;\n        sendEIP1559RewardsToSyndicate(eipRewards);\n\n        vm.prank(accountOne);\n        vm.expectRevert(KnotIsFullyStakedWithFreeFloatingSlotTokens.selector);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n\n        // Check syndicate state\n        assertEq(syndicate.totalETHReceived(), eipRewards);\n\n        // claim\n        uint256[] memory indexes = new uint256[](1);\n        indexes[0] = 0;\n\n        assertEq(accountTwo.balance, 0);\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, getBytesArrayFromBytes(blsPubKeyOne));\n        assertEq(accountTwo.balance, eipRewards / 4);\n\n        assertEq(accountFour.balance, 0);\n        vm.prank(accountFour);\n        syndicate.claimAsCollateralizedSLOTOwner(accountFour, getBytesArrayFromBytes(blsPubKeyTwo));\n        assertEq(accountFour.balance, eipRewards / 4);\n\n        assertEq(accountFive.balance, 0);\n        vm.prank(accountFive);\n        syndicate.claimAsStaker(accountFive, getBytesArrayFromBytes(blsPubKeyTwo));\n        assertEq(accountFive.balance, (eipRewards / 4) - 1);\n\n        assertEq(accountOne.balance, 0);\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, getBytesArrayFromBytes(blsPubKeyOne));\n        assertEq(accountOne.balance, (eipRewards / 8) - 1);\n\n        assertEq(accountThree.balance, 0);\n        vm.prank(accountThree);\n        syndicate.claimAsStaker(accountThree, getBytesArrayFromBytes(blsPubKeyOne));\n        assertEq(accountThree.balance, (eipRewards / 8) - 1);\n\n        // Check syndicate state\n        assertEq(syndicate.totalETHReceived(), eipRewards);\n        assertEq(address(syndicate).balance, 3); // Dust is left behind due to Solidity calc issues\n\n        vm.prank(admin);\n        vm.expectRevert(KnotIsAlreadyRegistered.selector);\n        syndicate.registerKnotsToSyndicate(getBytesArrayFromBytes(blsPubKeyOne));\n\n        vm.prank(admin);\n        syndicate.registerKnotsToSyndicate(getBytesArrayFromBytes(blsPubKeyThree));\n    }\n\n    function testOneKnotWithMultipleFreeFloatingStakers() public {\n        // account two is the collateralized owner for bls pub key one. Everyone else can be free floating staker but they need sETH\n        vm.startPrank(accountOne);\n        sETH.transfer(accountThree, 500 ether);\n        sETH.transfer(accountFour, 500 ether);\n        vm.stopPrank();\n\n        // Stake free floating slot\n        uint256 stakeAmount = 4 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakeAmount;\n\n        vm.startPrank(accountOne);\n        sETH.approve(address(syndicate), stakeAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n        vm.stopPrank();\n\n        vm.startPrank(accountThree);\n        sETH.approve(address(syndicate), stakeAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountThree);\n        vm.stopPrank();\n\n        vm.startPrank(accountFour);\n        sETH.approve(address(syndicate), stakeAmount);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountFour);\n        vm.stopPrank();\n\n        // send some eip rewards to syndicate\n        uint256 eipRewards = 0.54 ether;\n        sendEIP1559RewardsToSyndicate(eipRewards);\n\n        // Claim as free floating\n        assertEq(accountOne.balance, 0);\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(accountOne.balance, 0.09 ether);\n\n        assertEq(accountThree.balance, 0);\n        vm.prank(accountThree);\n        syndicate.claimAsStaker(accountThree, blsPubKeyOneAsArray());\n        assertEq(accountThree.balance, 0.09 ether);\n\n        assertEq(accountFour.balance, 0);\n        vm.prank(accountFour);\n        syndicate.claimAsStaker(accountFour, blsPubKeyOneAsArray());\n        assertEq(accountFour.balance, 0.09 ether);\n\n        // Now as the collateralized SLOT owner has not claimed, 0.27 out of 0.54 should still be with syndicate\n        assertEq(address(syndicate).balance, 0.27 ether);\n\n        // Collateralized owner claims\n        uint256[] memory indexes = new uint256[](1);\n        indexes[0] = 0;\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n        assertEq(address(syndicate).balance, 0);\n        assertEq(accountTwo.balance, 0.27 ether);\n\n        // nothing should happen by claiming again\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n        assertEq(address(syndicate).balance, 0);\n        assertEq(accountTwo.balance, 0.27 ether);\n\n        assertEq(accountOne.balance, 0.09 ether);\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(accountOne.balance, 0.09 ether);\n\n        assertEq(accountThree.balance, 0.09 ether);\n        vm.prank(accountThree);\n        syndicate.claimAsStaker(accountThree, blsPubKeyOneAsArray());\n        assertEq(accountThree.balance, 0.09 ether);\n\n        assertEq(accountFour.balance, 0.09 ether);\n        vm.prank(accountFour);\n        syndicate.claimAsStaker(accountFour, blsPubKeyOneAsArray());\n        assertEq(accountFour.balance, 0.09 ether);\n    }\n\n    function testExpansionOfKnotSet() public {\n        // Testing scenario where:\n        // - syn is deployed\n        // - it accrues ETH\n        // - no one claims\n        // - new knots are added to syn\n        // - old ones claim successfully\n        // - new ones have nothing to claim\n        // - when ETH comes in again, then the full set can claim that additional ETH\n\n        // Start test\n        // Check that one knot is registered\n        assertEq(syndicate.numberOfRegisteredKnots(), 1);\n        assertEq(syndicate.isKnotRegistered(blsPubKeyOne), true);\n\n        // Distribute some rewards, stake, no one claims and check claim amounts\n        uint256 eip1559Reward = 0.165 ether;\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        uint256 collateralizedIndex = 0;\n        uint256[] memory collateralizedIndexes = new uint256[](1);\n        collateralizedIndexes[0] = collateralizedIndex;\n\n        uint256 stakeAmount = 12 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakeAmount;\n\n        vm.startPrank(accountOne);\n        sETH.approve(address(syndicate), 12 ether);\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n        vm.stopPrank();\n\n        // Without claiming ensure free floating staker and collateralized owners can claim correct amount of rewards\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        assertEq(\n            syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        assertEq(syndicate.totalETHReceived(), eip1559Reward);\n\n        // Expand KNOT set\n        vm.prank(admin);\n        syndicate.registerKnotsToSyndicate(getBytesArrayFromBytes(blsPubKeyTwo));\n\n        assertEq(syndicate.numberOfRegisteredKnots(), 2);\n        assertEq(syndicate.isKnotRegistered(blsPubKeyOne), true);\n        assertEq(syndicate.isKnotRegistered(blsPubKeyTwo), true);\n\n        // Check claim amount for previous stakers is still correct\n        assertEq(syndicate.totalClaimed(), 0);\n        assertEq(address(syndicate).balance, eip1559Reward);\n        assertEq(syndicate.totalETHReceived(), eip1559Reward);\n        assertEq(syndicate.accumulatedETHPerFreeFloatingShare(), 6875000000000000000000);\n        assertEq(syndicate.calculateNewAccumulatedETHPerFreeFloatingShare(), 0);\n        assertEq(syndicate.sETHTotalStakeForKnot(blsPubKeyOne), stakeAmount);\n        assertEq(syndicate.sETHStakedBalanceForKnot(blsPubKeyOne, accountOne), stakeAmount);\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        assertEq(\n            syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(accountOne.balance, eip1559Reward / 2);\n        assertEq(syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne), 0);\n        assertEq(\n            syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne),\n            eip1559Reward / 2\n        );\n\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n        assertEq(syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne), 0);\n        assertEq(accountTwo.balance, eip1559Reward / 2);\n        assertEq(address(syndicate).balance, 0);\n\n        // introduce a third staker for free floating\n        vm.prank(accountOne);\n        sETH.transfer(accountThree, stakeAmount);\n\n        vm.startPrank(accountThree);\n        sETHAmounts[0] = stakeAmount;\n        sETH.approve(address(syndicate), stakeAmount);\n        syndicate.stake(\n            getBytesArrayFromBytes(blsPubKeyTwo),\n            sETHAmounts,\n            accountThree\n        );\n        vm.stopPrank();\n\n        // send some more rewards again\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        assertEq(syndicate.totalClaimed(), eip1559Reward);\n        assertEq(syndicate.totalFreeFloatingShares(), stakeAmount * 2);\n        assertEq(sETH.balanceOf(address(syndicate)), stakeAmount * 2);\n\n        uint256 ethPerKnot = eip1559Reward / 2;\n        uint256 ethPerFreeFloatingOrCollateralized = ethPerKnot;\n        uint256 unclaimedFreeFloatingAccountOne = syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne);\n        uint256 unclaimedFreeFloatingAccountThree = syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountThree, blsPubKeyTwo);\n        assertEq(\n            unclaimedFreeFloatingAccountOne + unclaimedFreeFloatingAccountThree,\n            ethPerFreeFloatingOrCollateralized\n        );\n\n        uint256 accountOneBalBeforeClaim = accountOne.balance;\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(accountOne.balance - accountOneBalBeforeClaim, unclaimedFreeFloatingAccountOne);\n\n        uint256 accountThreeBalBeforeClaim = accountThree.balance;\n        vm.prank(accountThree);\n        syndicate.claimAsStaker(accountThree, getBytesArrayFromBytes(blsPubKeyTwo));\n        assertEq(accountThree.balance - accountThreeBalBeforeClaim, unclaimedFreeFloatingAccountThree);\n\n        assertEq(syndicate.getUnprocessedETHForAllCollateralizedSlot(), 0);\n        assertEq(syndicate.getUnprocessedETHForAllFreeFloatingSlot(), 0);\n\n        uint256 unclaimedCollateralizedAccountTwo = syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountTwo, blsPubKeyOne);\n        uint256 unclaimedCollateralizedAccountFour = syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(accountFour, blsPubKeyTwo);\n        assertEq(\n            unclaimedCollateralizedAccountTwo + unclaimedCollateralizedAccountFour,\n            ethPerFreeFloatingOrCollateralized\n        );\n\n        uint256 accountTwoBalBefore = accountTwo.balance;\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n        assertEq(accountTwo.balance - accountTwoBalBefore, unclaimedCollateralizedAccountTwo);\n\n        vm.prank(accountFour);\n        syndicate.claimAsCollateralizedSLOTOwner(accountFour, getBytesArrayFromBytes(blsPubKeyTwo));\n        assertEq(accountFour.balance, unclaimedCollateralizedAccountFour);\n\n        assertEq(address(syndicate).balance, 0);\n    }\n\n    function testClaimAsCollateralizedSlotOwner() public {\n        uint256 eip1559Reward = 0.165 ether;\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        uint256 collateralizedIndex = 0;\n        uint256[] memory collateralizedIndexes = new uint256[](1);\n        collateralizedIndexes[0] = collateralizedIndex;\n\n        assertEq(accountTwo.balance, 0);\n\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n\n        assertEq(accountTwo.balance, eip1559Reward / 2);\n        assertEq(address(syndicate).balance, eip1559Reward / 2);\n    }\n\n    function testStakeFreeFloatingReceiveETHAndThenClaim() public {\n        uint256 stakeAmount = 12 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakeAmount;\n\n        // Assume account one as message sender\n        vm.startPrank(accountOne);\n\n        // issue allowance to stake\n        sETH.approve(address(syndicate), sETHAmounts[0]);\n\n        // stake\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n\n        // End impersonation\n        vm.stopPrank();\n\n        assertEq(sETH.balanceOf(address(syndicate)), stakeAmount);\n        assertEq(syndicate.totalFreeFloatingShares(), stakeAmount);\n        assertEq(syndicate.sETHTotalStakeForKnot(blsPubKeyOne), stakeAmount);\n        assertEq(syndicate.sETHStakedBalanceForKnot(blsPubKeyOne, accountOne), stakeAmount);\n        assertEq(syndicate.sETHUserClaimForKnot(blsPubKeyOne, accountOne), 0);\n        assertEq(syndicate.accumulatedETHPerFreeFloatingShare(), 0);\n        assertEq(syndicate.lastSeenETHPerFreeFloating(), 0);\n        //assertEq(syndicate.lastSeenETHPerCollateralizedSlot(), 0);\n\n        uint256 eip1559Reward = 0.04 ether;\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        // Preview amount of unclaimed ETH before updating contract state\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n            0.02 ether - 1\n        );\n\n        syndicate.updateAccruedETHPerShares();\n\n        assertEq(syndicate.lastSeenETHPerFreeFloating(), eip1559Reward / 2);\n        //assertEq(syndicate.lastSeenETHPerCollateralizedSlot(), eip1559Reward / 2);\n        assertEq(syndicate.totalETHReceived(), eip1559Reward);\n        assertEq(syndicate.calculateETHForFreeFloatingOrCollateralizedHolders(), eip1559Reward / 2);\n        assertEq(syndicate.accumulatedETHPerFreeFloatingShare(), ((eip1559Reward / 2) * 1e24) / stakeAmount);\n        assertEq(syndicate.sETHUserClaimForKnot(blsPubKeyOne, accountOne), 0);\n\n        assertEq(address(syndicate).balance, 0.04 ether);\n\n        // Preview amount of unclaimed ETH post updating contract state\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n                0.02 ether - 1\n        );\n\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n\n        // Contract balance should have reduced\n        // Solidity precision loss of 1 wei\n        assertEq(address(syndicate).balance, 0.02 ether + 1);\n\n        // Unclaimed ETH amount should now be zero\n        assertEq(\n            syndicate.previewUnclaimedETHAsFreeFloatingStaker(accountOne, blsPubKeyOne),\n            0\n        );\n\n        // user ETH balance should now be 0.02 ether minus 1 due to precision loss\n        assertEq(accountOne.balance, 0.02 ether - 1);\n\n        // try to claim again and fail\n        vm.prank(accountOne);\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n        assertEq(address(syndicate).balance, 0.02 ether + 1);\n\n        vm.prank(accountOne);\n        syndicate.unstake(accountOne, accountOne, blsPubKeyOneAsArray(), sETHAmounts);\n        assertEq(address(syndicate).balance, 0.02 ether + 1);\n\n        vm.startPrank(accountOne);\n\n        // issue allowance to stake\n        sETH.approve(address(syndicate), sETHAmounts[0]);\n\n        uint256 expectedDebt = (syndicate.accumulatedETHPerFreeFloatingShare() * stakeAmount) / syndicate.PRECISION();\n\n        // stake\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n\n        // Check user was assigned the correct debt on re-staking so they cannot double claim\n        assertEq(syndicate.sETHUserClaimForKnot(blsPubKeyOne, accountOne), expectedDebt);\n\n        // try to claim again and fail\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n\n        // End impersonation\n        vm.stopPrank();\n\n        assertEq(address(syndicate).balance, 0.02 ether + 1);\n    }\n\n    // TODO - fuzz claiming\n    function testBothCollateralizedAndSlotClaim() public {\n        uint256 eip1559Reward = 0.165 ether;\n        sendEIP1559RewardsToSyndicate(eip1559Reward);\n\n        uint256 collateralizedIndex = 0;\n        uint256[] memory collateralizedIndexes = new uint256[](1);\n        collateralizedIndexes[0] = collateralizedIndex;\n\n        // set up collateralized knot\n        MockSlotRegistry(syndicate.slotReg()).setCollateralisedOwnerAtIndex(blsPubKeyOne, collateralizedIndex, accountTwo);\n        MockSlotRegistry(syndicate.slotReg()).setUserCollateralisedSLOTBalanceForKnot(houseOne, accountTwo, blsPubKeyOne, 4 ether);\n\n        assertEq(accountTwo.balance, 0);\n        assertEq(\n            syndicate.previewUnclaimedETHAsCollateralizedSlotOwner(\n                accountTwo,\n                blsPubKeyOne\n            ),\n            eip1559Reward / 2\n        );\n\n        vm.prank(accountTwo);\n        syndicate.claimAsCollateralizedSLOTOwner(accountTwo, blsPubKeyOneAsArray());\n\n        assertEq(accountTwo.balance, eip1559Reward / 2);\n        assertEq(address(syndicate).balance, eip1559Reward / 2);\n\n        // now let free floating guy come in and stake sETH\n        vm.startPrank(accountOne);\n\n        uint256 stakeAmount = 12 ether;\n        uint256[] memory sETHAmounts = new uint256[](1);\n        sETHAmounts[0] = stakeAmount;\n\n        sETH.approve(address(syndicate), stakeAmount);\n\n        syndicate.stake(blsPubKeyOneAsArray(), sETHAmounts, accountOne);\n\n        assertEq(accountOne.balance, 0);\n        assertEq(address(syndicate).balance, eip1559Reward / 2);\n\n        syndicate.claimAsStaker(accountOne, blsPubKeyOneAsArray());\n\n        vm.stopPrank();\n\n        assertEq(syndicate.sETHStakedBalanceForKnot(blsPubKeyOne, accountOne), 12 ether);\n        assertEq(syndicate.sETHUserClaimForKnot(blsPubKeyOne, accountOne), eip1559Reward / 2);\n\n        assertEq(accountOne.balance, (eip1559Reward / 2));\n        assertEq(address(syndicate).balance, 0);\n    }\n\n    // todo - use fuzz to continually add eip1559 rewards and then have users randomly draw down\n}\n\n\npragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ISyndicateInit } from \"../interfaces/ISyndicateInit.sol\";\nimport {\n    ZeroAddress,\n    EmptyArray,\n    InconsistentArrayLengths,\n    InvalidBLSPubKey,\n    InvalidNumberOfCollateralizedOwners,\n    KnotSlashed,\n    FreeFloatingStakeAmountTooSmall,\n    KnotIsNotRegisteredWithSyndicate,\n    NotPriorityStaker,\n    KnotIsFullyStakedWithFreeFloatingSlotTokens,\n    InvalidStakeAmount,\n    KnotIsNotAssociatedWithAStakeHouse,\n    UnableToStakeFreeFloatingSlot,\n    NothingStaked,\n    TransferFailed,\n    NotCollateralizedOwnerAtIndex,\n    InactiveKnot,\n    DuplicateArrayElements,\n    KnotIsAlreadyRegistered,\n    KnotHasAlreadyBeenDeRegistered\n} from \"./SyndicateErrors.sol\";\n\n/// @notice Syndicate registry and funds splitter for EIP1559 execution layer transaction tips across SLOT shares\n/// @dev This contract can be extended to allow lending and borrowing of time slots for borrower to redeem any revenue generated within the specified window\ncontract Syndicate is ISyndicateInit, Initializable, Ownable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice Emitted when the contract is initially deployed\n    event ContractDeployed();\n\n    /// @notice Emitted when accrued ETH per SLOT share type is updated\n    event UpdateAccruedETH(uint256 unprocessed);\n\n    /// @notice Emitted when new collateralized SLOT owners for a knot prompts re-calibration\n    event CollateralizedSLOTReCalibrated(bytes BLSPubKey);\n\n    /// @notice Emitted when a new KNOT is associated with the syndicate contract\n    event KNOTRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a KNOT is de-registered from the syndicate\n    event KnotDeRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a priority staker is added to the syndicate\n    event PriorityStakerRegistered(address indexed staker);\n\n    /// @notice Emitted when a user stakes free floating sETH tokens\n    event Staked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when a user unstakes free floating sETH tokens\n    event UnStaked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when either an sETH staker or collateralized SLOT owner claims ETH\n    event ETHClaimed(bytes BLSPubKey, address indexed user, address recipient, uint256 claim, bool indexed isCollateralizedClaim);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accrued ETH per free floating share for new and old stakers\n    uint256 public accumulatedETHPerFreeFloatingShare;\n\n    /// @notice Total accrued ETH for all collateralized SLOT holders per knot which is then distributed based on individual balances\n    uint256 public accumulatedETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all collateralized shares\n    uint256 public lastSeenETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all free floating shares\n    uint256 public lastSeenETHPerFreeFloating;\n\n    /// @notice Total number of sETH token shares staked across all houses\n    uint256 public totalFreeFloatingShares;\n\n    /// @notice Total amount of ETH drawn down by syndicate beneficiaries regardless of SLOT type\n    uint256 public totalClaimed;\n\n    /// @notice Number of knots registered with the syndicate which can be across any house\n    uint256 public numberOfRegisteredKnots;\n\n    /// @notice Informational - is the knot registered to this syndicate or not - the node should point to this contract\n    mapping(bytes => bool) public isKnotRegistered;\n\n    /// @notice Block number after which if there are sETH staking slots available, it can be supplied by anyone on the market\n    uint256 public priorityStakingEndBlock;\n\n    /// @notice Syndicate deployer can highlight addresses that get priority for staking free floating house sETH up to a certain block before anyone can do it\n    mapping(address => bool) public isPriorityStaker;\n\n    /// @notice Total amount of free floating sETH staked\n    mapping(bytes => uint256) public sETHTotalStakeForKnot;\n\n    /// @notice Amount of sETH staked by user against a knot\n    mapping(bytes => mapping(address => uint256)) public sETHStakedBalanceForKnot;\n\n    /// @notice Amount of ETH claimed by user from sETH staking\n    mapping(bytes => mapping(address => uint256)) public sETHUserClaimForKnot;\n\n    /// @notice Total amount of ETH that has been allocated to the collateralized SLOT owners of a KNOT\n    mapping(bytes => uint256) public totalETHProcessedPerCollateralizedKnot;\n\n    /// @notice Total amount of ETH accrued for the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public accruedEarningPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Total amount of ETH claimed by the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public claimedPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Whether a BLS public key, that has been previously registered, is no longer part of the syndicate and its shares (free floating or SLOT) cannot earn any more rewards\n    mapping(bytes => bool) public isNoLongerPartOfSyndicate;\n\n    /// @notice Once a BLS public key is no longer part of the syndicate, the accumulated ETH per free floating SLOT share is snapshotted so historical earnings can be drawn down correctly\n    mapping(bytes => uint256) public lastAccumulatedETHPerFreeFloatingShare;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _contractOwner Ethereum public key that will receive management rights of the contract\n    /// @param _priorityStakingEndBlock Block number when priority sETH staking ends and anyone can stake\n    /// @param _priorityStakers Optional list of addresses that will have priority for staking sETH against each knot registered\n    /// @param _blsPubKeysForSyndicateKnots List of BLS public keys of Stakehouse protocol registered KNOTs participating in syndicate\n    function initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) external virtual override initializer {\n        _initialize(\n            _contractOwner,\n            _priorityStakingEndBlock,\n            _priorityStakers,\n            _blsPubKeysForSyndicateKnots\n        );\n    }\n\n    /// @notice Allows the contract owner to append to the list of knots that are part of the syndicate\n    /// @param _newBLSPublicKeyBeingRegistered List of BLS public keys being added to the syndicate\n    function registerKnotsToSyndicate(\n        bytes[] calldata _newBLSPublicKeyBeingRegistered\n    ) external onlyOwner {\n        // update accrued ETH per SLOT type\n        updateAccruedETHPerShares();\n        _registerKnotsToSyndicate(_newBLSPublicKeyBeingRegistered);\n    }\n\n    /// @notice Make knot shares of a registered list of BLS public keys inactive - the action cannot be undone and no further ETH accrued\n    function deRegisterKnots(bytes[] calldata _blsPublicKeys) external onlyOwner {\n        updateAccruedETHPerShares();\n        _deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice Allows the contract owner to append to the list of priority sETH stakers\n    /// @param _priorityStakers List of staker addresses eligible for sETH staking\n    function addPriorityStakers(address[] calldata _priorityStakers) external onlyOwner {\n        updateAccruedETHPerShares();\n        _addPriorityStakers(_priorityStakers);\n    }\n\n    /// @notice Should this block be in the future, it means only those listed in the priority staker list can stake sETH\n    /// @param _endBlock Arbitrary block number after which anyone can stake up to 4 SLOT in sETH per KNOT\n    function updatePriorityStakingBlock(uint256 _endBlock) external onlyOwner {\n        updateAccruedETHPerShares();\n        priorityStakingEndBlock = _endBlock;\n    }\n\n    /// @notice Update accrued ETH per SLOT share without distributing ETH as users of the syndicate individually pull funds\n    function updateAccruedETHPerShares() public {\n        // Ensure there are registered KNOTs. Syndicates are deployed with at least 1 registered but this can fall to zero.\n        // Fee recipient should be re-assigned in the event that happens as any further ETH can be collected by owner\n        if (numberOfRegisteredKnots > 0) {\n            // All time, total ETH that was earned per slot type (free floating or collateralized)\n            uint256 totalEthPerSlotType = calculateETHForFreeFloatingOrCollateralizedHolders();\n\n            // Process free floating if there are staked shares\n            uint256 freeFloatingUnprocessed;\n            if (totalFreeFloatingShares > 0) {\n                freeFloatingUnprocessed = getUnprocessedETHForAllFreeFloatingSlot();\n                accumulatedETHPerFreeFloatingShare += _calculateNewAccumulatedETHPerFreeFloatingShare(freeFloatingUnprocessed);\n                lastSeenETHPerFreeFloating = totalEthPerSlotType;\n            }\n\n            uint256 collateralizedUnprocessed = ((totalEthPerSlotType - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n            accumulatedETHPerCollateralizedSlotPerKnot += collateralizedUnprocessed;\n            lastSeenETHPerCollateralizedSlotPerKnot = totalEthPerSlotType;\n\n            emit UpdateAccruedETH(freeFloatingUnprocessed + collateralizedUnprocessed);\n        } else {\n            // todo - check else case for any ETH lost\n        }\n    }\n\n    /// @notice Stake up to 4 collateralized SLOT worth of sETH per KNOT to get a portion of syndicate rewards\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be staked (up to 4 collateralized SLOT per KNOT)\n    /// @param _onBehalfOf Allows a caller to specify an address that will be assigned stake ownership and rights to claim\n    function stake(bytes[] calldata _blsPubKeys, uint256[] calldata _sETHAmounts, address _onBehalfOf) external {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_onBehalfOf == address(0)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n\n            if (_sETHAmount < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n            if (!isKnotRegistered[_blsPubKey] || isNoLongerPartOfSyndicate[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            if (block.number < priorityStakingEndBlock && !isPriorityStaker[_onBehalfOf]) revert NotPriorityStaker();\n\n            uint256 totalStaked = sETHTotalStakeForKnot[_blsPubKey];\n            if (totalStaked == 12 ether) revert KnotIsFullyStakedWithFreeFloatingSlotTokens();\n\n            if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount();\n\n            totalFreeFloatingShares += _sETHAmount;\n            sETHTotalStakeForKnot[_blsPubKey] += _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][_onBehalfOf] += _sETHAmount;\n            sETHUserClaimForKnot[_blsPubKey][_onBehalfOf] = (_sETHAmount * accumulatedETHPerFreeFloatingShare) / PRECISION;\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            if (stakeHouse == address(0)) revert KnotIsNotAssociatedWithAStakeHouse();\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n            bool transferResult = sETH.transferFrom(msg.sender, address(this), _sETHAmount);\n            if (!transferResult) revert UnableToStakeFreeFloatingSlot();\n\n            emit Staked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Unstake an sETH position against a particular KNOT and claim ETH on exit\n    /// @param _unclaimedETHRecipient The address that will receive any unclaimed ETH received to the syndicate\n    /// @param _sETHRecipient The address that will receive the sETH that is being unstaked\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be unstaked\n    function unstake(\n        address _unclaimedETHRecipient,\n        address _sETHRecipient,\n        bytes[] calldata _blsPubKeys,\n        uint256[] calldata _sETHAmounts\n    ) external nonReentrant {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_unclaimedETHRecipient == address(0)) revert ZeroAddress();\n        if (_sETHRecipient == address(0)) revert ZeroAddress();\n\n        // Claim all ETH owed before unstaking but even if nothing is owed `updateAccruedETHPerShares` will be called\n        _claimAsStaker(_unclaimedETHRecipient, _blsPubKeys);\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n            if (sETHStakedBalanceForKnot[_blsPubKey][msg.sender] < _sETHAmount) revert NothingStaked();\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n\n            // Only decrease totalFreeFloatingShares in the event that the knot is still active in the syndicate\n            if (!isNoLongerPartOfSyndicate[_blsPubKey]) {\n                totalFreeFloatingShares -= _sETHAmount;\n            }\n\n            sETHTotalStakeForKnot[_blsPubKey] -= _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][msg.sender] -= _sETHAmount;\n\n            bool transferResult = sETH.transfer(_sETHRecipient, _sETHAmount);\n            if (!transferResult) revert TransferFailed();\n\n            emit UnStaked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Claim ETH cashflow from the syndicate as an sETH staker proportional to how much the user has staked\n    /// @param _recipient Address that will receive the share of ETH funds\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) public nonReentrant {\n        _claimAsStaker(_recipient, _blsPubKeys);\n    }\n\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsCollateralizedSLOTOwner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information for all shares\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            // process newly accrued ETH and distribute it to collateralized SLOT owners for the given knot\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n\n            // Calculate total amount of unclaimed ETH\n            uint256 userShare = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // This is designed to cope with falling SLOT balances i.e. when collateralized SLOT is burnt after applying penalties\n            uint256 unclaimedUserShare = userShare - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // Send ETH to the user if there is an unclaimed amount\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed and claimed at the user level\n                totalClaimed += unclaimedUserShare;\n                claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender] = userShare;\n\n                // Send ETH to user\n                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");\n                if (!success) revert TransferFailed();\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    true\n                );\n            }\n        }\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner\n    /// @param _blsPubKey BLS public key relating to the collateralized owners that need updating\n    function updateCollateralizedSlotOwnersAccruedETH(bytes memory _blsPubKey) external {\n        _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner and do it for a batch of knots\n    /// @param _blsPubKeys List of BLS public keys related to the collateralized owners that need updating\n    function batchUpdateCollateralizedSlotOwnersAccruedETH(bytes[] memory _blsPubKeys) external {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKeys[i]);\n        }\n    }\n\n    /// @notice Syndicate contract can receive ETH\n    receive() external payable {\n        // No logic here because one cannot assume that more than 21K GAS limit is forwarded\n    }\n\n    /// @notice Calculate the amount of unclaimed ETH for a given BLS publice key + free floating SLOT staker without factoring in unprocessed rewards\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _user The address of a user that has staked sETH against the BLS public key\n    function calculateUnclaimedFreeFloatingETHShare(bytes memory _blsPubKey, address _user) public view returns (uint256) {\n        // Check the user has staked sETH for the KNOT\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_user];\n        if (stakedBal < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n\n        // Get the amount of ETH eligible for the user based on their staking amount\n        uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n        uint256 userShare = (accumulatedETHPerShare * stakedBal) / PRECISION;\n\n        // Calculate how much their unclaimed share of ETH is based on total ETH claimed so far\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_user];\n    }\n\n    /// @notice Using `highestSeenBalance`, this is the amount that is separately allocated to either free floating or collateralized SLOT holders\n    function calculateETHForFreeFloatingOrCollateralizedHolders() public view returns (uint256) {\n        // Get total amount of ETH that can be drawn down by all SLOT holders associated with a knot\n        uint256 ethPerKnot = totalETHReceived();\n\n        // Get the amount of ETH eligible for free floating sETH or collateralized SLOT stakers\n        return ethPerKnot / 2;\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for an sETH staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _staker The address of a user that has staked sETH against the BLS public key\n    function previewUnclaimedETHAsFreeFloatingStaker(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) external view returns (uint256) {\n        uint256 currentAccumulatedETHPerFreeFloatingShare = accumulatedETHPerFreeFloatingShare;\n        uint256 updatedAccumulatedETHPerFreeFloatingShare =\n                            currentAccumulatedETHPerFreeFloatingShare + calculateNewAccumulatedETHPerFreeFloatingShare();\n\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_staker];\n        uint256 userShare = (updatedAccumulatedETHPerFreeFloatingShare * stakedBal) / PRECISION;\n\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for a collatearlized SLOT staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _staker Address of a collateralized SLOT owner for a KNOT\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    function previewUnclaimedETHAsCollateralizedSlotOwner(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) external view returns (uint256) {\n        // Per collateralized SLOT per KNOT before distributing to individual collateralized owners\n        uint256 accumulatedSoFar = accumulatedETHPerCollateralizedSlotPerKnot\n                    + ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n\n        uint256 unprocessedForKnot = accumulatedSoFar - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Fetch information on what has been processed so far against the ECDSA address of the collateralized SLOT owner\n        uint256 currentAccrued = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n\n        // Fetch information about the knot including total slashed amount\n        uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n        uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n        (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Find the collateralized SLOT owner and work out how much they're owed\n        for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n            address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n            if (collateralizedOwnerAtIndex == _staker) {\n                uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                    stakeHouse,\n                    collateralizedOwnerAtIndex,\n                    _blsPubKey\n                );\n\n                if (currentSlashedAmount < 4 ether) {\n                    currentAccrued +=\n                        balance * unprocessedForKnot / (4 ether - currentSlashedAmount);\n                }\n                break;\n            }\n        }\n\n        return currentAccrued - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Amount of ETH per free floating share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllFreeFloatingSlot() public view returns (uint256) {\n        return calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerFreeFloating;\n    }\n\n    /// @notice Amount of ETH per collateralized share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllCollateralizedSlot() public view returns (uint256) {\n        return ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n    }\n\n    /// @notice New accumulated ETH per free floating share that hasn't yet been applied\n    /// @dev The return value is scaled by 1e24\n    function calculateNewAccumulatedETHPerFreeFloatingShare() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllFreeFloatingSlot();\n        return _calculateNewAccumulatedETHPerFreeFloatingShare(ethSinceLastUpdate);\n    }\n\n    /// @notice New accumulated ETH per collateralized share per knot that hasn't yet been applied\n    function calculateNewAccumulatedETHPerCollateralizedSharePerKnot() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllCollateralizedSlot();\n        return accumulatedETHPerCollateralizedSlotPerKnot + ethSinceLastUpdate;\n    }\n\n    /// @notice Total amount of ETH received by the contract\n    function totalETHReceived() public view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @dev Internal logic for initializing the syndicate contract\n    function _initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) internal {\n        // Transfer ownership from the deployer to the address specified as the owner\n        _transferOwnership(_contractOwner);\n\n        // Add the initial set of knots to the syndicate\n        _registerKnotsToSyndicate(_blsPubKeysForSyndicateKnots);\n\n        // Optionally process priority staking if the required params and array is configured\n        if (_priorityStakingEndBlock > block.number) {\n            priorityStakingEndBlock = _priorityStakingEndBlock;\n            _addPriorityStakers(_priorityStakers);\n        }\n\n        emit ContractDeployed();\n    }\n\n    /// Given an amount of ETH allocated to the collateralized SLOT owners of a KNOT, distribute this amongs the current set of collateralized owners (a dynamic set of addresses and balances)\n    function _updateCollateralizedSlotOwnersLiabilitySnapshot(bytes memory _blsPubKey) internal {\n        // Establish how much new ETH is for the new KNOT\n        uint256 unprocessedETHForCurrentKnot =\n                    accumulatedETHPerCollateralizedSlotPerKnot - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Get information about the knot i.e. associated house and whether its active\n        (address stakeHouse,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Assuming that there is unprocessed ETH and the knot is still part of the syndicate\n        if (unprocessedETHForCurrentKnot > 0 && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n\n            // Don't allocate ETH when the current slashed amount is four. Syndicate will wait until ETH is topped up to claim revenue\n            if (currentSlashedAmount < 4 ether) {\n                // This copes with increasing numbers of collateralized slot owners and also copes with SLOT that has been slashed but not topped up\n                uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n\n                if (numberOfCollateralisedSlotOwnersForKnot == 1) {\n                    // For only 1 collateralized SLOT owner, they get the full amount of unprocessed ETH for the knot\n                    address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, 0);\n                    accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] += unprocessedETHForCurrentKnot;\n                } else {\n                    for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n                        address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n                        uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                            stakeHouse,\n                            collateralizedOwnerAtIndex,\n                            _blsPubKey\n                        );\n\n                        accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] +=\n                            balance * unprocessedETHForCurrentKnot / (4 ether - currentSlashedAmount);\n                    }\n                }\n\n                // record so unprocessed goes to zero\n                totalETHProcessedPerCollateralizedKnot[_blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n            }\n        }\n\n        // if the knot is no longer active, no further accrual of rewards are possible snapshots are possible but ETH accrued up to that point\n        // Basically, under a rage quit or voluntary withdrawal from the beacon chain, the knot kick is auto-propagated to syndicate\n        if (!isActive && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            _deRegisterKnot(_blsPubKey);\n        }\n    }\n\n    function _calculateCollateralizedETHOwedPerKnot() internal view returns (uint256) {\n        uint256 collateralizedSLOTShareOfETH = calculateETHForFreeFloatingOrCollateralizedHolders();\n        uint256 collateralizedSLOTShareOfETHPerKnot = (collateralizedSLOTShareOfETH / numberOfRegisteredKnots);\n        return collateralizedSLOTShareOfETHPerKnot;\n    }\n\n    /// @dev Business logic for calculating per collateralized share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerCollateralizedShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return (_ethSinceLastUpdate * PRECISION) / (numberOfRegisteredKnots * 4 ether);\n    }\n\n    /// @dev Business logic for calculating per free floating share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerFreeFloatingShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return totalFreeFloatingShares > 0 ? (_ethSinceLastUpdate * PRECISION) / totalFreeFloatingShares : 0;\n    }\n\n    /// @dev Business logic for adding a new set of knots to the syndicate for collecting revenue\n    function _registerKnotsToSyndicate(bytes[] memory _blsPubKeysForSyndicateKnots) internal {\n        uint256 knotsToRegister = _blsPubKeysForSyndicateKnots.length;\n        if (knotsToRegister == 0) revert EmptyArray();\n        numberOfRegisteredKnots += knotsToRegister;\n\n        for (uint256 i; i < knotsToRegister; ++i) {\n            bytes memory blsPubKey = _blsPubKeysForSyndicateKnots[i];\n\n            if (isKnotRegistered[blsPubKey]) revert KnotIsAlreadyRegistered();\n\n            // incomming knot collateralized SLOT holders do not get historical earnings\n            totalETHProcessedPerCollateralizedKnot[blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n\n            // Health check - if knot is inactive or slashed, should it really be part of the syndicate?\n            // KNOTs closer to 32 effective at all times is the target\n            (,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(blsPubKey);\n            if (!isActive) revert InactiveKnot();\n\n            uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(blsPubKey);\n            if (numberOfCollateralisedSlotOwnersForKnot < 1) revert InvalidNumberOfCollateralizedOwners();\n            if (getSlotRegistry().currentSlashedAmountOfSLOTForKnot(blsPubKey) != 0) revert InvalidNumberOfCollateralizedOwners();\n\n            isKnotRegistered[blsPubKey] = true;\n            emit KNOTRegistered(blsPubKey);\n        }\n    }\n\n    /// @dev Business logic for adding priority stakers to the syndicate\n    function _addPriorityStakers(address[] memory _priorityStakers) internal {\n        if (_priorityStakers.length == 0) revert EmptyArray();\n        for (uint256 i; i < _priorityStakers.length; ++i) {\n            address staker = _priorityStakers[i];\n\n            if (i > 0 && staker < _priorityStakers[i-1]) revert DuplicateArrayElements();\n\n            isPriorityStaker[staker] = true;\n\n            emit PriorityStakerRegistered(staker);\n        }\n    }\n\n    /// @dev Business logic for de-registering a set of knots from the syndicate and doing the required snapshots to ensure historical earnings are preserved\n    function _deRegisterKnots(bytes[] calldata _blsPublicKeys) internal {\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            bytes memory blsPublicKey = _blsPublicKeys[i];\n\n            // Do one final snapshot of ETH owed to the collateralized SLOT owners so they can claim later\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(blsPublicKey);\n\n            // Execute the business logic for de-registering the single knot\n            _deRegisterKnot(blsPublicKey);\n        }\n    }\n\n    /// @dev Business logic for de-registering a specific knots assuming all accrued ETH has been processed\n    function _deRegisterKnot(bytes memory _blsPublicKey) internal {\n        if (isKnotRegistered[_blsPublicKey] == false) revert KnotIsNotRegisteredWithSyndicate();\n        if (isNoLongerPartOfSyndicate[_blsPublicKey] == true) revert KnotHasAlreadyBeenDeRegistered();\n\n        // We flag that the knot is no longer part of the syndicate\n        isNoLongerPartOfSyndicate[_blsPublicKey] = true;\n\n        // For the free floating and collateralized SLOT of the knot, snapshot the accumulated ETH per share\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] = accumulatedETHPerFreeFloatingShare;\n\n        // We need to reduce `totalFreeFloatingShares` in order to avoid further ETH accruing to shares of de-registered knot\n        totalFreeFloatingShares -= sETHTotalStakeForKnot[_blsPublicKey];\n\n        // Total number of registered knots with the syndicate reduces by one\n        numberOfRegisteredKnots -= 1;\n\n        emit KnotDeRegistered(_blsPublicKey);\n    }\n\n    /// @dev Work out the accumulated ETH per free floating share value that must be used for distributing ETH\n    function _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(\n        bytes memory _blsPublicKey\n    ) internal view returns (uint256) {\n        return\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] > 0 ?\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] :\n        accumulatedETHPerFreeFloatingShare;\n    }\n\n    /// @dev Business logic for allowing a free floating SLOT holder to claim their share of ETH\n    function _claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) internal {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            uint256 unclaimedUserShare = calculateUnclaimedFreeFloatingETHShare(_blsPubKey, msg.sender);\n\n            // this means that user can call the funtion even if there is nothing to claim but the\n            // worst that will happen is that they will just waste gas. this is needed for unstaking\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed at the contract level\n                totalClaimed += unclaimedUserShare;\n\n                // Work out which accumulated ETH per free floating share value was used\n                uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n\n                // Update the total ETH claimed by the free floating SLOT holder based on their share of sETH\n                sETHUserClaimForKnot[_blsPubKey][msg.sender] =\n                (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION;\n\n                // Send ETH to user\n                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");\n                if (!success) revert TransferFailed();\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    false\n                );\n            }\n        }\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport \"forge-std/console.sol\";\n\nimport { TestUtils } from \"../utils/TestUtils.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\nimport { MockSavETHRegistry } from \"../../contracts/testing/stakehouse/MockSavETHRegistry.sol\";\n\ncontract LiquidStakingManagerTests is TestUtils {\n\n    function setUp() public {\n        vm.startPrank(accountFive); // this will mean it gets dETH initial supply\n        factory = createMockLSDNFactory();\n        vm.stopPrank();\n\n        // Deploy 1 network and get default dependencies\n        manager = deployNewLiquidStakingNetwork(\n            factory,\n            admin,\n            true,\n            \"LSDN\"\n        );\n\n        savETHVault = getSavETHVaultFromManager(manager);\n        stakingFundsVault = getStakingFundsVaultFromManager(manager);\n\n        // make 'admin' the 'DAO'\n        vm.prank(address(factory));\n        manager.updateDAOAddress(admin);\n    }\n\n    // todo - test for multiple knots\n    function testDAOCanCoordinateRageQuitOfOnlyKnotInNetwork() public {\n        // Set up users and ETH\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n        // Do everything from funding a validator within default LSDN to minting derivatives\n        depositStakeAndMintDerivativesForDefaultNetwork(\n            nodeRunner,\n            feesAndMevUser,\n            savETHUser,\n            blsPubKeyFour\n        );\n\n        // Send syndicate some EIP1559 rewards\n        uint256 eip1559Tips = 0.6743 ether;\n        sendEIP1559RewardsToSyndicateAtAddress(eip1559Tips, manager.syndicate());\n\n        // Claim dETH as savETH user\n        IERC20 dETHToken = savETHVault.dETHToken();\n        vm.startPrank(accountFive);\n        dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether * 2);\n        vm.stopPrank();\n\n        vm.startPrank(savETHUser);\n        savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyFour), getUint256ArrayFromValues(24 ether));\n        vm.stopPrank();\n        assertEq(dETHToken.balanceOf(savETHUser), 24 ether);\n\n        // Check there are some rewards to claim by staking funds vault\n        assertEq(\n            manager.stakingFundsVault().previewAccumulatedETH(feesAndMevUser, stakingFundsVault.lpTokenForKnot(blsPubKeyFour)),\n            (eip1559Tips / 2) - 1\n        );\n\n        // now de-register knot from syndicate to send sETH back to smart wallet\n        IERC20 sETH = IERC20(MockSlotRegistry(factory.slot()).stakeHouseShareTokens(manager.stakehouse()));\n        uint256 sETHBalanceBefore = sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner));\n        vm.startPrank(admin);\n        manager.deRegisterKnotFromSyndicate(getBytesArrayFromBytes(blsPubKeyFour));\n        manager.restoreFreeFloatingSharesToSmartWalletForRageQuit(\n            manager.smartWalletOfNodeRunner(nodeRunner),\n            getBytesArrayFromBytes(blsPubKeyFour),\n            getUint256ArrayFromValues(12 ether)\n        );\n        vm.stopPrank();\n\n        assertEq(\n            sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner)) - sETHBalanceBefore,\n            12 ether\n        );\n\n        // As long as the smart wallet has free floating and collateralized SLOT + dETH isolated, then we assume rage quit will work at stakehouse level\n        // We execute an arbitrary transaction here to confirm `executeAsSmartWallet` is working as if rage quit took place\n        assertEq(savETHVault.saveETHRegistry().knotDETHBalanceInIndex(1, blsPubKeyFour), 24 ether);\n        savETHVault.saveETHRegistry().setBalInIndex(1, blsPubKeyFour, 1);\n        vm.startPrank(admin);\n        manager.executeAsSmartWallet(\n            nodeRunner,\n            address(savETHVault.saveETHRegistry()),\n            abi.encodeWithSelector(\n                MockSavETHRegistry.setBalInIndex.selector,\n                1,\n                blsPubKeyFour,\n                1\n            ),\n            0\n        );\n        vm.stopPrank();\n        assertEq(savETHVault.saveETHRegistry().knotDETHBalanceInIndex(1, blsPubKeyFour), 1);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // Now, as Staking funds vault LP holder you should be able to claim rewards accrued up to point of pulling the plug\n        vm.startPrank(feesAndMevUser);\n        stakingFundsVault.claimRewards(feesAndMevUser, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(feesAndMevUser.balance, (eip1559Tips / 2) - 1);\n\n        // As collateralized SLOT holder for BLS pub key four, you should be able to claim rewards accrued up to point of pulling the plug\n        vm.startPrank(nodeRunner);\n        manager.claimRewardsAsNodeRunner(nodeRunner, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(nodeRunner.balance, (eip1559Tips / 2));\n    }\n}\n\n",
        "CodeNames": [
            "LiquidStakingManager.sol",
            "Syndicate.t.sol",
            "Syndicate.sol",
            "LiquidStakingManager.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LiquidStakingManager.sol, Syndicate.sol",
                "Type": "Loss of EIP1559 rewards",
                "Description": "EIP1559 rewards received by the syndicate during the period when it has no registered knots can be lost.",
                "Repair": "Update the updateAccruedETHPerShares function to handle EIP1559 rewards received by the syndicate during the period when it has no registered knots. Node runners should index the chain when the knot is removed from the LSD network and update their fee recipient."
            },
            {
                "Location": "LiquidStakingManager.sol, Syndicate.sol",
                "Type": "Attacker can grift syndicate staking",
                "Description": "LiquidStakingManager._autoStakeWithSyndicate always stakes a fixed amount of 12 ETH. However, Syndicate.stake only allows a total staking amount of 12 ETH and reverts otherwise.",
                "Repair": "Only allow staking through the LiquidStakingManager, i.e. add access control to Syndicate.stake."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper) {\n            gatekeeper = OptionalGatekeeperFactory(_optionalGatekeeperDeployer).deploy(address(this));\n        }\n    }\n\n    /// @dev function checks if a node runner is valid depending upon whitelisting status\n    /// @param _nodeRunner address of the user requesting to become node runner\n    /// @return true if eligible. reverts with message if not eligible\n    function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {\n        require(_nodeRunner != address(0), \"Zero address\");\n\n        if(enableWhitelisting) {\n            require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");\n        }\n\n        return true;\n    }\n\n    /// @dev Manage the removal and appointing of smart wallet representatives including managing state\n    function _authorizeRepresentative(\n        address _smartWallet, \n        address _eoaRepresentative, \n        bool _isEnabled\n    ) internal {\n        if(!_isEnabled && smartWalletRepresentative[_smartWallet] != address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // delete the mapping\n            delete smartWalletRepresentative[_smartWallet];\n\n            emit RepresentativeRemoved(_smartWallet, _eoaRepresentative);\n        }\n        else if(_isEnabled && smartWalletRepresentative[_smartWallet] == address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // store EOA to the wallet mapping\n            smartWalletRepresentative[_smartWallet] = _eoaRepresentative;\n\n            emit RepresentativeAppointed(_smartWallet, _eoaRepresentative);\n        } else {\n            revert(\"Unexpected state\");\n        }\n    }\n\n    /// @dev Internal method for doing just staking - pre-checks done outside this method to avoid stack too deep\n    function _stake(\n        bytes calldata _blsPublicKey,\n        bytes calldata _cipherText,\n        bytes calldata _aesEncryptorKey,\n        IDataStructures.EIP712Signature calldata _encryptionSignature,\n        bytes32 dataRoot\n    ) internal {\n        address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n        // send 24 ether from savETH vault to smart wallet\n        savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n        // send 4 ether from DAO staking funds vault\n        stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n        // interact with transaction router using smart wallet to deposit 32 ETH\n        IOwnableSmartWallet(smartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.registerValidator.selector,\n                smartWallet,\n                _blsPublicKey,\n                _cipherText,\n                _aesEncryptorKey,\n                _encryptionSignature,\n                dataRoot\n            ),\n            32 ether\n        );\n\n        // increment number of staked KNOTs in the wallet\n        stakedKnotsOfSmartWallet[smartWallet] += 1;\n\n        emit KnotStaked(_blsPublicKey, msg.sender);\n    }\n\n    /// @dev The second knot onwards will join the LSDN stakehouse and expand the registered syndicate knots\n    function _joinLSDNStakehouse(\n        bytes calldata _blsPubKey,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // total number of knots created with the syndicate increases\n        numberOfKnots += 1;\n\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPubKey];\n\n        // Join the LSDN stakehouse\n        string memory lowerTicker = IBrandNFT(brand).toLowerCase(stakehouseTicker);\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.joinStakehouse.selector,\n                associatedSmartWallet,\n                _blsPubKey,\n                stakehouse,\n                IBrandNFT(brand).lowercaseBrandTickerToTokenId(lowerTicker),\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Register the knot to the syndicate\n        bytes[] memory _blsPublicKeyOfKnots = new bytes[](1);\n        _blsPublicKeyOfKnots[0] = _blsPubKey;\n        Syndicate(payable(syndicate)).registerKnotsToSyndicate(_blsPublicKeyOfKnots);\n\n        // Autostake DAO sETH with the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPubKey);\n\n        emit StakehouseJoined(_blsPubKey);\n    }\n\n    /// @dev Perform all the steps required to create the LSDN stakehouse that other knots will join\n    function _createLSDNStakehouse(\n        bytes calldata _blsPublicKeyOfKnot,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // create stakehouse and mint derivative for first bls key - the others are just used to create the syndicate\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.createStakehouse.selector,\n                associatedSmartWallet,\n                _blsPublicKeyOfKnot,\n                stakehouseTicker,\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Number of knots has increased\n        numberOfKnots += 1;\n\n        // Capture the address of the Stakehouse for future knots to join\n        stakehouse = getStakeHouseUniverse().memberKnotToStakeHouse(_blsPublicKeyOfKnot);\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        // Give liquid staking manager ability to manage keepers and set a house keeper if decided by the network\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            stakehouse,\n            abi.encodeWithSelector(\n                Ownable.transferOwnership.selector,\n                address(this)\n            )\n        );\n\n        if (address(gatekeeper) != address(0)) {\n            IStakeHouseRegistry(stakehouse).setGateKeeper(address(gatekeeper));\n        }\n\n        // Deploy the EIP1559 transaction reward sharing contract but no priority required because sETH will be auto staked\n        address[] memory priorityStakers = new address[](0);\n        bytes[] memory initialKnots = new bytes[](1);\n        initialKnots[0] = _blsPublicKeyOfKnot;\n        syndicate = syndicateFactory.deploySyndicate(\n            address(this),\n            0,\n            priorityStakers,\n            initialKnots\n        );\n\n        // Contract approves syndicate to take sETH on behalf of the DAO\n        sETH.approve(syndicate, (2 ** 256) - 1);\n\n        // Auto-stake sETH by pulling sETH out the smart wallet and staking in the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPublicKeyOfKnot);\n\n        emit StakehouseCreated(stakehouseTicker, stakehouse);\n    }\n\n    /// @dev Remove the sETH from the node runner smart wallet in order to auto-stake the sETH in the syndicate\n    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        uint256 stakeAmount = 12 ether;\n        IOwnableSmartWallet(_associatedSmartWallet).execute(\n            address(sETH),\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                address(this),\n                stakeAmount\n            )\n        );\n\n        // Create the payload for staking\n        bytes[] memory stakingKeys = new bytes[](1);\n        stakingKeys[0] = _blsPubKey;\n\n        uint256[] memory stakeAmounts = new uint256[](1);\n        stakeAmounts[0] = stakeAmount;\n\n        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)\n        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));\n    }\n\n    /// @dev Something that can be overriden during testing\n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n\n    function _initStakingFundsVault(address _stakingFundsVaultDeployer, address _tokenFactory) internal virtual {\n        stakingFundsVault = StakingFundsVault(\n            payable(StakingFundsVaultDeployer(_stakingFundsVaultDeployer).deployStakingFundsVault(\n                address(this),\n                _tokenFactory\n            ))\n        );\n    }\n\n    /// @dev This can be overriden to customise fee percentages\n    function _calculateCommission(uint256 _received) internal virtual view returns (uint256 _nodeRunner, uint256 _dao) {\n        require(_received > 0, \"Nothing received\");\n\n        if (daoCommissionPercentage > 0) {\n            uint256 daoAmount = (_received * daoCommissionPercentage) / MODULO;\n            uint256 rest = _received - daoAmount;\n            return (rest, daoAmount);\n        }\n\n        return (_received, 0);\n    }\n\n    /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\n    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n    }\n\n    /// @dev Internal method for dao to trigger updating commission it takes of node runner revenue\n    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {\n        require(_commissionPercentage <= MODULO, \"Invalid commission\");\n\n        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);\n\n        daoCommissionPercentage = _commissionPercentage;\n    }\n}\n\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport \"forge-std/console.sol\";\n\nimport { TestUtils } from \"../utils/TestUtils.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\nimport { MockSavETHRegistry } from \"../../contracts/testing/stakehouse/MockSavETHRegistry.sol\";\n\ncontract LiquidStakingManagerTests is TestUtils {\n\n    function setUp() public {\n        vm.startPrank(accountFive); // this will mean it gets dETH initial supply\n        factory = createMockLSDNFactory();\n        vm.stopPrank();\n\n        // Deploy 1 network and get default dependencies\n        manager = deployNewLiquidStakingNetwork(\n            factory,\n            admin,\n            true,\n            \"LSDN\"\n        );\n\n        savETHVault = getSavETHVaultFromManager(manager);\n        stakingFundsVault = getStakingFundsVaultFromManager(manager);\n\n        // make 'admin' the 'DAO'\n        vm.prank(address(factory));\n        manager.updateDAOAddress(admin);\n    }\n\n    // todo - test for multiple knots\n    function testDAOCanCoordinateRageQuitOfOnlyKnotInNetwork() public {\n        // Set up users and ETH\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n        // Do everything from funding a validator within default LSDN to minting derivatives\n        depositStakeAndMintDerivativesForDefaultNetwork(\n            nodeRunner,\n            feesAndMevUser,\n            savETHUser,\n            blsPubKeyFour\n        );\n\n        // Send syndicate some EIP1559 rewards\n        uint256 eip1559Tips = 0.6743 ether;\n        sendEIP1559RewardsToSyndicateAtAddress(eip1559Tips, manager.syndicate());\n\n        // Claim dETH as savETH user\n        IERC20 dETHToken = savETHVault.dETHToken();\n        vm.startPrank(accountFive);\n        dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether * 2);\n        vm.stopPrank();\n\n        vm.startPrank(savETHUser);\n        savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyFour), getUint256ArrayFromValues(24 ether));\n        vm.stopPrank();\n        assertEq(dETHToken.balanceOf(savETHUser), 24 ether);\n\n        // Check there are some rewards to claim by staking funds vault\n        assertEq(\n            manager.stakingFundsVault().previewAccumulatedETH(feesAndMevUser, stakingFundsVault.lpTokenForKnot(blsPubKeyFour)),\n            (eip1559Tips / 2) - 1\n        );\n\n        // now de-register knot from syndicate to send sETH back to smart wallet\n        IERC20 sETH = IERC20(MockSlotRegistry(factory.slot()).stakeHouseShareTokens(manager.stakehouse()));\n        uint256 sETHBalanceBefore = sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner));\n        vm.startPrank(admin);\n        manager.deRegisterKnotFromSyndicate(getBytesArrayFromBytes(blsPubKeyFour));\n        manager.restoreFreeFloatingSharesToSmartWalletForRageQuit(\n            manager.smartWalletOfNodeRunner(nodeRunner),\n            getBytesArrayFromBytes(blsPubKeyFour),\n            getUint256ArrayFromValues(12 ether)\n        );\n        vm.stopPrank();\n\n        assertEq(\n            sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner)) - sETHBalanceBefore,\n            12 ether\n        );\n\n        // As long as the smart wallet has free floating and collateralized SLOT + dETH isolated, then we assume rage quit will work at stakehouse level\n        // We execute an arbitrary transaction here to confirm `executeAsSmartWallet` is working as if rage quit took place\n        assertEq(savETHVault.saveETHRegistry().knotDETHBalanceInIndex(1, blsPubKeyFour), 24 ether);\n        savETHVault.saveETHRegistry().setBalInIndex(1, blsPubKeyFour, 1);\n        vm.startPrank(admin);\n        manager.executeAsSmartWallet(\n            nodeRunner,\n            address(savETHVault.saveETHRegistry()),\n            abi.encodeWithSelector(\n                MockSavETHRegistry.setBalInIndex.selector,\n                1,\n                blsPubKeyFour,\n                1\n            ),\n            0\n        );\n        vm.stopPrank();\n        assertEq(savETHVault.saveETHRegistry().knotDETHBalanceInIndex(1, blsPubKeyFour), 1);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // Now, as Staking funds vault LP holder you should be able to claim rewards accrued up to point of pulling the plug\n        vm.startPrank(feesAndMevUser);\n        stakingFundsVault.claimRewards(feesAndMevUser, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(feesAndMevUser.balance, (eip1559Tips / 2) - 1);\n\n        // As collateralized SLOT holder for BLS pub key four, you should be able to claim rewards accrued up to point of pulling the plug\n        vm.startPrank(nodeRunner);\n        manager.claimRewardsAsNodeRunner(nodeRunner, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(nodeRunner.balance, (eip1559Tips / 2));\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {IOwnableSmartWallet} from \"./interfaces/IOwnableSmartWallet.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title Ownable smart wallet\n/// @notice Ownable and transferrable smart wallet that allows the owner to\n///         interact with any contracts the same way as from an EOA. The\n///         main intended use is to make non-transferrable positions and assets\n///         liquid and usable in strategies.\n/// @notice Intended to be used with a factory and the cloning pattern.\ncontract OwnableSmartWallet is IOwnableSmartWallet, Ownable, Initializable {\n    using Address for address;\n\n    /// @dev A map from owner and spender to transfer approval. Determines whether\n    ///      the spender can transfer this wallet from the owner. Can be used\n    ///      to put this wallet in possession of a strategy (e.g., as collateral).\n    mapping(address => mapping(address => bool)) internal _isTransferApproved;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc IOwnableSmartWallet\n    function initialize(address initialOwner)\n        external\n        override\n        initializer // F: [OSW-1]\n    {\n        require(\n            initialOwner != address(0),\n            \"OwnableSmartWallet: Attempting to initialize with zero address owner\"\n        );\n        _transferOwnership(initialOwner); // F: [OSW-1]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function execute(address target, bytes memory callData)\n        external\n        override\n        payable\n        onlyOwner // F: [OSW-6A]\n        returns (bytes memory)\n    {\n        return target.functionCallWithValue(callData, msg.value); // F: [OSW-6]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function execute(\n        address target,\n        bytes memory callData,\n        uint256 value\n    )\n        external\n        override\n        payable\n        onlyOwner // F: [OSW-6A]\n        returns (bytes memory)\n    {\n        return target.functionCallWithValue(callData, value); // F: [OSW-6]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function rawExecute(\n        address target,\n        bytes memory callData,\n        uint256 value\n    )\n    external\n    override\n    payable\n    onlyOwner\n    returns (bytes memory)\n    {\n        (bool result, bytes memory message) = target.call{value: value}(callData);\n        require(result, \"Failed to execute\");\n        return message;\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function owner()\n        public\n        view\n        override(IOwnableSmartWallet, Ownable)\n        returns (address)\n    {\n        return Ownable.owner(); // F: [OSW-1]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function transferOwnership(address newOwner)\n        public\n        override(IOwnableSmartWallet, Ownable)\n    {\n        // Only the owner themselves or an address that is approved for transfers\n        // is authorized to do this\n        require(\n            isTransferApproved(owner(), msg.sender),\n            \"OwnableSmartWallet: Transfer is not allowed\"\n        ); // F: [OSW-4]\n\n        // Approval is revoked, in order to avoid unintended transfer allowance\n        // if this wallet ever returns to the previous owner\n        if (msg.sender != owner()) {\n            _setApproval(owner(), msg.sender, false); // F: [OSW-5]\n        }\n        _transferOwnership(newOwner); // F: [OSW-5]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function setApproval(address to, bool status) external onlyOwner override {\n        require(\n            to != address(0),\n            \"OwnableSmartWallet: Approval cannot be set for zero address\"\n        ); // F: [OSW-2A]\n        _setApproval(msg.sender, to, status);\n    }\n\n    /// @dev IMPLEMENTATION: _setApproval\n    /// @param from The owner address\n    /// @param to The spender address\n    /// @param status Status of approval\n    function _setApproval(\n        address from,\n        address to,\n        bool status\n    ) internal {\n        bool statusChanged = _isTransferApproved[from][to] != status;\n        _isTransferApproved[from][to] = status; // F: [OSW-2]\n        if (statusChanged) {\n            emit TransferApprovalChanged(from, to, status); // F: [OSW-2]\n        }\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function isTransferApproved(address from, address to)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return from == to ? true : _isTransferApproved[from][to]; // F: [OSW-2, 3]\n    }\n\n    receive() external payable {\n        // receive ETH\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidStakingManager.sol",
            "LiquidStakingManager.t.sol",
            "OwnableSmartWallet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "executeAsSmartWallet function in LiquidStakingManager.sol and execute function in OwnableSmartWallet.sol",
                "Type": "ETH sent can be lost",
                "Description": "When calling the executeAsSmartWallet function by the DAO, an ETH amount can be sent but not forwarded to the smart wallet contract, causing the sent amount to become locked in the LiquidStakingManager contract.",
                "Repair": "Update the execute function in OwnableSmartWallet.sol to revoke all approvals given by the previous owner when ownership is transferred to a new owner. Update the executeAsSmartWallet function in LiquidStakingManager.sol to forward the sent ETH amount to the smart wallet contract."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {IOwnableSmartWallet} from \"./interfaces/IOwnableSmartWallet.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title Ownable smart wallet\n/// @notice Ownable and transferrable smart wallet that allows the owner to\n///         interact with any contracts the same way as from an EOA. The\n///         main intended use is to make non-transferrable positions and assets\n///         liquid and usable in strategies.\n/// @notice Intended to be used with a factory and the cloning pattern.\ncontract OwnableSmartWallet is IOwnableSmartWallet, Ownable, Initializable {\n    using Address for address;\n\n    /// @dev A map from owner and spender to transfer approval. Determines whether\n    ///      the spender can transfer this wallet from the owner. Can be used\n    ///      to put this wallet in possession of a strategy (e.g., as collateral).\n    mapping(address => mapping(address => bool)) internal _isTransferApproved;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc IOwnableSmartWallet\n    function initialize(address initialOwner)\n        external\n        override\n        initializer // F: [OSW-1]\n    {\n        require(\n            initialOwner != address(0),\n            \"OwnableSmartWallet: Attempting to initialize with zero address owner\"\n        );\n        _transferOwnership(initialOwner); // F: [OSW-1]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function execute(address target, bytes memory callData)\n        external\n        override\n        payable\n        onlyOwner // F: [OSW-6A]\n        returns (bytes memory)\n    {\n        return target.functionCallWithValue(callData, msg.value); // F: [OSW-6]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function execute(\n        address target,\n        bytes memory callData,\n        uint256 value\n    )\n        external\n        override\n        payable\n        onlyOwner // F: [OSW-6A]\n        returns (bytes memory)\n    {\n        return target.functionCallWithValue(callData, value); // F: [OSW-6]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function rawExecute(\n        address target,\n        bytes memory callData,\n        uint256 value\n    )\n    external\n    override\n    payable\n    onlyOwner\n    returns (bytes memory)\n    {\n        (bool result, bytes memory message) = target.call{value: value}(callData);\n        require(result, \"Failed to execute\");\n        return message;\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function owner()\n        public\n        view\n        override(IOwnableSmartWallet, Ownable)\n        returns (address)\n    {\n        return Ownable.owner(); // F: [OSW-1]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function transferOwnership(address newOwner)\n        public\n        override(IOwnableSmartWallet, Ownable)\n    {\n        // Only the owner themselves or an address that is approved for transfers\n        // is authorized to do this\n        require(\n            isTransferApproved(owner(), msg.sender),\n            \"OwnableSmartWallet: Transfer is not allowed\"\n        ); // F: [OSW-4]\n\n        // Approval is revoked, in order to avoid unintended transfer allowance\n        // if this wallet ever returns to the previous owner\n        if (msg.sender != owner()) {\n            _setApproval(owner(), msg.sender, false); // F: [OSW-5]\n        }\n        _transferOwnership(newOwner); // F: [OSW-5]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function setApproval(address to, bool status) external onlyOwner override {\n        require(\n            to != address(0),\n            \"OwnableSmartWallet: Approval cannot be set for zero address\"\n        ); // F: [OSW-2A]\n        _setApproval(msg.sender, to, status);\n    }\n\n    /// @dev IMPLEMENTATION: _setApproval\n    /// @param from The owner address\n    /// @param to The spender address\n    /// @param status Status of approval\n    function _setApproval(\n        address from,\n        address to,\n        bool status\n    ) internal {\n        bool statusChanged = _isTransferApproved[from][to] != status;\n        _isTransferApproved[from][to] = status; // F: [OSW-2]\n        if (statusChanged) {\n            emit TransferApprovalChanged(from, to, status); // F: [OSW-2]\n        }\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function isTransferApproved(address from, address to)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return from == to ? true : _isTransferApproved[from][to]; // F: [OSW-2, 3]\n    }\n\n    receive() external payable {\n        // receive ETH\n    }\n}\n\n\n",
        "CodeNames": [
            "OwnableSmartWallet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "approve function in OwnableSmartWallet.sol",
                "Type": "Multiple approvals can lead to unwanted ownership transfers",
                "Description": "When ownership is transferred from one user to another, not all approvals given by the previous owner are revoked, leading to potential unwanted transfers of ownership.",
                "Repair": "Create an array to keep track of all approvals given by the previous owner and revoke all of them when ownership is transferred to a new owner."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper) {\n            gatekeeper = OptionalGatekeeperFactory(_optionalGatekeeperDeployer).deploy(address(this));\n        }\n    }\n\n    /// @dev function checks if a node runner is valid depending upon whitelisting status\n    /// @param _nodeRunner address of the user requesting to become node runner\n    /// @return true if eligible. reverts with message if not eligible\n    function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {\n        require(_nodeRunner != address(0), \"Zero address\");\n\n        if(enableWhitelisting) {\n            require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");\n        }\n\n        return true;\n    }\n\n    /// @dev Manage the removal and appointing of smart wallet representatives including managing state\n    function _authorizeRepresentative(\n        address _smartWallet, \n        address _eoaRepresentative, \n        bool _isEnabled\n    ) internal {\n        if(!_isEnabled && smartWalletRepresentative[_smartWallet] != address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // delete the mapping\n            delete smartWalletRepresentative[_smartWallet];\n\n            emit RepresentativeRemoved(_smartWallet, _eoaRepresentative);\n        }\n        else if(_isEnabled && smartWalletRepresentative[_smartWallet] == address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // store EOA to the wallet mapping\n            smartWalletRepresentative[_smartWallet] = _eoaRepresentative;\n\n            emit RepresentativeAppointed(_smartWallet, _eoaRepresentative);\n        } else {\n            revert(\"Unexpected state\");\n        }\n    }\n\n    /// @dev Internal method for doing just staking - pre-checks done outside this method to avoid stack too deep\n    function _stake(\n        bytes calldata _blsPublicKey,\n        bytes calldata _cipherText,\n        bytes calldata _aesEncryptorKey,\n        IDataStructures.EIP712Signature calldata _encryptionSignature,\n        bytes32 dataRoot\n    ) internal {\n        address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n        // send 24 ether from savETH vault to smart wallet\n        savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n        // send 4 ether from DAO staking funds vault\n        stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n        // interact with transaction router using smart wallet to deposit 32 ETH\n        IOwnableSmartWallet(smartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.registerValidator.selector,\n                smartWallet,\n                _blsPublicKey,\n                _cipherText,\n                _aesEncryptorKey,\n                _encryptionSignature,\n                dataRoot\n            ),\n            32 ether\n        );\n\n        // increment number of staked KNOTs in the wallet\n        stakedKnotsOfSmartWallet[smartWallet] += 1;\n\n        emit KnotStaked(_blsPublicKey, msg.sender);\n    }\n\n    /// @dev The second knot onwards will join the LSDN stakehouse and expand the registered syndicate knots\n    function _joinLSDNStakehouse(\n        bytes calldata _blsPubKey,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // total number of knots created with the syndicate increases\n        numberOfKnots += 1;\n\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPubKey];\n\n        // Join the LSDN stakehouse\n        string memory lowerTicker = IBrandNFT(brand).toLowerCase(stakehouseTicker);\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.joinStakehouse.selector,\n                associatedSmartWallet,\n                _blsPubKey,\n                stakehouse,\n                IBrandNFT(brand).lowercaseBrandTickerToTokenId(lowerTicker),\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Register the knot to the syndicate\n        bytes[] memory _blsPublicKeyOfKnots = new bytes[](1);\n        _blsPublicKeyOfKnots[0] = _blsPubKey;\n        Syndicate(payable(syndicate)).registerKnotsToSyndicate(_blsPublicKeyOfKnots);\n\n        // Autostake DAO sETH with the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPubKey);\n\n        emit StakehouseJoined(_blsPubKey);\n    }\n\n    /// @dev Perform all the steps required to create the LSDN stakehouse that other knots will join\n    function _createLSDNStakehouse(\n        bytes calldata _blsPublicKeyOfKnot,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // create stakehouse and mint derivative for first bls key - the others are just used to create the syndicate\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.createStakehouse.selector,\n                associatedSmartWallet,\n                _blsPublicKeyOfKnot,\n                stakehouseTicker,\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Number of knots has increased\n        numberOfKnots += 1;\n\n        // Capture the address of the Stakehouse for future knots to join\n        stakehouse = getStakeHouseUniverse().memberKnotToStakeHouse(_blsPublicKeyOfKnot);\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        // Give liquid staking manager ability to manage keepers and set a house keeper if decided by the network\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            stakehouse,\n            abi.encodeWithSelector(\n                Ownable.transferOwnership.selector,\n                address(this)\n            )\n        );\n\n        if (address(gatekeeper) != address(0)) {\n            IStakeHouseRegistry(stakehouse).setGateKeeper(address(gatekeeper));\n        }\n\n        // Deploy the EIP1559 transaction reward sharing contract but no priority required because sETH will be auto staked\n        address[] memory priorityStakers = new address[](0);\n        bytes[] memory initialKnots = new bytes[](1);\n        initialKnots[0] = _blsPublicKeyOfKnot;\n        syndicate = syndicateFactory.deploySyndicate(\n            address(this),\n            0,\n            priorityStakers,\n            initialKnots\n        );\n\n        // Contract approves syndicate to take sETH on behalf of the DAO\n        sETH.approve(syndicate, (2 ** 256) - 1);\n\n        // Auto-stake sETH by pulling sETH out the smart wallet and staking in the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPublicKeyOfKnot);\n\n        emit StakehouseCreated(stakehouseTicker, stakehouse);\n    }\n\n    /// @dev Remove the sETH from the node runner smart wallet in order to auto-stake the sETH in the syndicate\n    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        uint256 stakeAmount = 12 ether;\n        IOwnableSmartWallet(_associatedSmartWallet).execute(\n            address(sETH),\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                address(this),\n                stakeAmount\n            )\n        );\n\n        // Create the payload for staking\n        bytes[] memory stakingKeys = new bytes[](1);\n        stakingKeys[0] = _blsPubKey;\n\n        uint256[] memory stakeAmounts = new uint256[](1);\n        stakeAmounts[0] = stakeAmount;\n\n        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)\n        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));\n    }\n\n    /// @dev Something that can be overriden during testing\n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n\n    function _initStakingFundsVault(address _stakingFundsVaultDeployer, address _tokenFactory) internal virtual {\n        stakingFundsVault = StakingFundsVault(\n            payable(StakingFundsVaultDeployer(_stakingFundsVaultDeployer).deployStakingFundsVault(\n                address(this),\n                _tokenFactory\n            ))\n        );\n    }\n\n    /// @dev This can be overriden to customise fee percentages\n    function _calculateCommission(uint256 _received) internal virtual view returns (uint256 _nodeRunner, uint256 _dao) {\n        require(_received > 0, \"Nothing received\");\n\n        if (daoCommissionPercentage > 0) {\n            uint256 daoAmount = (_received * daoCommissionPercentage) / MODULO;\n            uint256 rest = _received - daoAmount;\n            return (rest, daoAmount);\n        }\n\n        return (_received, 0);\n    }\n\n    /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\n    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n    }\n\n    /// @dev Internal method for dao to trigger updating commission it takes of node runner revenue\n    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {\n        require(_commissionPercentage <= MODULO, \"Invalid commission\");\n\n        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);\n\n        daoCommissionPercentage = _commissionPercentage;\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidStakingManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LiquidStakingManager.sol#withdrawETHForKnow",
                "Type": "Reentrancy",
                "Description": "The _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.",
                "Repair": "Ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\ncontract GiantLP is ERC20 {\n\n    /// @notice Address of giant pool that deployed the giant LP token\n    address public pool;\n\n    /// @notice Optional address of contract that will process transfers of giant LP\n    ITransferHookProcessor public transferHookProcessor;\n\n    /// @notice Last interacted timestamp for a given address\n    mapping(address => uint256) public lastInteractedTimestamp;\n\n    constructor(\n        address _pool,\n        address _transferHookProcessor,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        pool = _pool;\n        transferHookProcessor = ITransferHookProcessor(_transferHookProcessor);\n    }\n\n    function mint(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _mint(_recipient, _amount);\n    }\n\n    function burn(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _burn(_recipient, _amount);\n    }\n\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        lastInteractedTimestamp[_from] = block.timestamp;\n        lastInteractedTimestamp[_to] = block.timestamp;\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);\n    }\n}\n\n",
        "CodeNames": [
            "GiantLP.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GiantLP with a transferHookProcessor",
                "Type": "Stuck Funds",
                "Description": "The transferHookProcessor in GiantLP calls beforeTokenTransfer in GiantMevAndFeesPool with a zero address check, causing any withdraw function with a burn operation to revert and leaving users' funds stuck in the Giant Pool contracts.",
                "Repair": "Update the beforeTokenTransfer function in GiantMevAndFeesPool to remove the zero address check or remove the transferHookProcessor from GiantLP"
            }
        ]
    }
]