[
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @summary: Distribution contract for Angel and Seed Contributors\n * @author: Boot Finance\n */\n\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport \"./interfaces/IVesting.sol\";\n\n/// @title InvestorDistribution\n/// @dev The investor mappings will be initialized after deployment of contract\n\ncontract InvestorDistribution is Pausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    //Investor Shares (Angel + Seed Round)\n    struct Investors {\n        uint256 amount;\n        uint256 claimed;\n        uint256 total_tokens;\n        uint256 fraction;     // with 10**18 precision\n    }\n\n    address public admin;\n    mapping(address => Investors) public investors;\n\n    uint256 private investors_supply = 11088000 * 10 ** 18;\n\n    // General constants\n    uint256 constant HOUR = 3600;\n    uint256 constant DAY = 86400;\n    uint256 constant WEEK = 86400 * 7;\n    uint256 constant YEAR = WEEK * 52;\n\n    //INITIAL_SUPPLY: constant(uint256) = 0\n    // INFLATION_DELAY: constant(uint256) = 3 * HOUR # Three Hour delay before minting may begin\n    // RATE_DENOMINATOR: constant(uint256) = 10 ** 18\n    uint256 constant RATE_TIME = WEEK;                                         // How often the rate goes to the next epoch\n    uint256 constant INITIAL_RATE = 135_994 * 10 ** 18 / WEEK;                // 2,474,410 for the first week\n    uint256 constant EPOCH_INFLATION = 98_831;                                  // 98.831 % of last week\n    uint256 constant INITIAL_RATE_EPOCH_CUTTOF = 260;                          // After 260 Weeks use the late rate\n\n    // Supply variables\n    uint256 public miningEpoch;\n    uint256 public startEpochTime;\n    uint256 public rate;\n    uint256 public initTime;\n\n    uint256 public startEpochSupply;\n   \n    event updateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n    event InvestorAdded(address indexed investor, uint256 amount, uint256 timeStamp);\n    event InvestorModified(address indexed investor, address newinvestor, uint256 timeStamp);\n    event Vested(address indexed investor, uint256 amount, uint256 timeStamp);\n    event Rugged(uint256 amount, uint256 timeStamp);\n    event AdminChanged(address newAdmin, uint256 timeStamp);\n\n    IERC20 public mainToken;\n    IVesting public vestLock;\n\n    // define all the mining calculations here so that it doesn't have to\n    // called from MainToken contract\n    constructor(IERC20 _mainToken, IVesting _vestLock) {\n        require(address(_mainToken) != address(0), \"Invalid address\");\n        require(address(_vestLock) != address(0), \"Invalid address\");\n        mainToken = _mainToken;\n        vestLock = _vestLock;\n        rate = INITIAL_RATE;\n        initTime = block.timestamp;\n        startEpochTime = block.timestamp;\n        startEpochSupply = 0;\n        admin = msg.sender;\n\n        mainToken.approve(address(vestLock), 2**256-1);\n    }\n\n\n    //Address of contributor\n    function addInvestor(address _investor, uint256 _amount) external whenNotPaused {\n        require(_investor != address(0), \"Invalid address\");\n        require(_amount > 0, \"Amount must be positive\");\n        require(msg.sender == admin, \"Unauthorized\");\n\n        Investors memory newInvestor = Investors(_amount, 0, _amount, 10**18 * _amount / investors_supply);\n        investors[_investor] = newInvestor;\n\n        emit InvestorAdded(_investor, _amount, block.timestamp);\n    }\n\n    //Fallback in case a contributor loses keys, or cannot access wallet for any other reason\n    function modifyInvestor(address _investor, address _new) external whenNotPaused nonReentrant {\n        require(_investor != address(0), \"Invalid old address\");\n        require(_new != address(0), \"Invalid new address\");\n        require(investors[_investor].amount != 0);\n        require(msg.sender == admin, \"Unauthorized\");\n\n        Investors memory newInvestor = Investors(investors[_investor].amount, investors[_investor].claimed, investors[_investor].total_tokens, investors[_investor].fraction);\n        investors[_new] = newInvestor;\n\n        Investors memory oldInvestor = Investors(0, 0, 0, 0);\n        investors[_investor] = oldInvestor;\n\n        emit InvestorModified(_investor, _new, block.timestamp);\n    }\n\n    //Claim function to calculate and withdraw claimable tokens, also lock 70% in vesting contract\n    function claim() external nonReentrant {\n        require(msg.sender != address(0));\n        require(investors[msg.sender].amount != 0);\n        \n        uint256 avail = _available_supply();\n        require(avail > 0, \"Nothing claimable (yet?)\");\n\n        uint256 claimable = avail * investors[msg.sender].fraction / 10**18;\n        assert(claimable > 0);\n        if (investors[msg.sender].claimed != 0) {\n            claimable -= investors[msg.sender].claimed;\n        }\n\n        require(investors[msg.sender].amount - claimable != 0);\n\n        investors[msg.sender].amount -= claimable;\n        investors[msg.sender].claimed += claimable;\n\n        uint256 claimable_to_send = claimable * 3 / 10;         //30% released instantly\n        mainToken.transfer(msg.sender, claimable_to_send);\n        uint256 claimable_not_yet_vested = claimable - claimable_to_send;\n        vestLock.vest(msg.sender, claimable_not_yet_vested, 0); //70% locked in vesting contract\n\n        emit Vested(msg.sender, claimable, block.timestamp);\n    }\n\n    //Allow users to claim a specific amount instead of the entire amount\n    function claimExact(uint256 _value) external nonReentrant {\n        require(msg.sender != address(0));\n        require(investors[msg.sender].amount != 0);\n        \n        uint256 avail = _available_supply();\n        uint256 claimable = avail * investors[msg.sender].fraction / 10**18;\n        if (investors[msg.sender].claimed != 0) {\n            claimable -= investors[msg.sender].claimed;\n        }\n\n        require(investors[msg.sender].amount >= claimable);\n        require(_value <= claimable);\n        investors[msg.sender].amount -= _value;\n        investors[msg.sender].claimed += _value;\n\n        uint256 claimable_to_send = _value * 3 / 10;\n        mainToken.transfer(msg.sender, claimable_to_send);\n        uint256 claimable_not_yet_vested = _value - claimable_to_send;\n        vestLock.vest(msg.sender, claimable_not_yet_vested, 0);\n\n        emit Vested(msg.sender, _value, block.timestamp);\n    }\n\n    /// @notice release of BOOT public sale tokens from this contract \n    /// based on emission rules\n    /// updates the rate the mining parameters for public sale tokens\n    /// \n\n    function _updateEmission() private {\n        if (block.timestamp >= startEpochTime + RATE_TIME) {\n            miningEpoch += 1;\n            startEpochTime = startEpochTime.add(RATE_TIME);\n            startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));\n\n            if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {\n                rate = rate.mul(EPOCH_INFLATION).div(100000);\n            }\n            else {\n                rate = 0;\n            }\n            emit updateMiningParameters(block.timestamp, rate, startEpochSupply);\n        }\n    }\n\n    //Update emission to be called at every step change to update emission inflation\n    function updateEmission() public {\n        require(block.timestamp >= startEpochTime + RATE_TIME, \"Too soon\");\n        _updateEmission();\n    }\n\n    //Internal function to calculate current available supply\n    function _available_supply() private view returns(uint256) {\n        assert(block.timestamp - startEpochTime <= RATE_TIME);\n        return startEpochSupply + (block.timestamp - startEpochTime) * rate;\n    }\n\n    //Public function to calculate current available supply\n    function available_supply() public view returns(uint256) {\n        assert(block.timestamp - startEpochTime <= RATE_TIME);\n        return startEpochSupply + (block.timestamp - startEpochTime) * rate;\n    }\n\n    //Dev can access all tokens in the contract after 5 year period, to take care of fringe cases of lost or unclaimed tokens\n    function dev_rugpull() public {\n        assert(block.timestamp - initTime >= YEAR * 5); //dev can rug the unclaimed tokens 5 years later, assuming someone lost their key, or forgot about it or whatever and figure what to do with them.\n        require(msg.sender == admin, \"Unauthorized\");   //admin-only\n        uint256 bal = mainToken.balanceOf(address(this));\n        mainToken.transfer(msg.sender, bal);\n        emit Rugged(bal, block.timestamp);\n    }\n\n    //Change admin of the contract\n    function setAdmin(address _newAdmin) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        require(address(_newAdmin) != address(0), \"Invalid address\");\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin, block.timestamp);\n    }\n\n}\n\n",
        "CodeNames": [
            "InvestorDistribution.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "addInvestor() function in InvestorDistribution.sol",
                "Type": "Missing input validation",
                "Description": "The addInvestor() function does not check how many tokens are available from investors_supply, which could allow an attacker to claim all available tokens by inputting _amount = investors_supply.",
                "Repair": "Add a require statement to check that the amount being added is less than or equal to the remaining investors_supply"
            },
            {
                "Location": "InvestorDistribution.sol#L113-L128",
                "Type": "Investor can't claim the last tokens (via claim() )",
                "Description": "Suppose you are an investor and want to claim the last part of your claimable tokens (or your entire set of claimable tokens if you haven't claimed anything yet). Then you call the function claim() of InvestorDistribution.sol, which has the following statement: require(investors[msg.sender].amount claimable != 0); This statement will prevent you from claiming your tokens because it will stop execution.",
                "Repair": "Remove the require statement."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @summary: Airdrop distribution of Swerve Active Governance Participants\n * @author: Boot Finance\n */\n\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport \"./interfaces/IVesting.sol\";\n\n/// @title AirdropDistribution\n/// @dev This contract manages the distribution of Swerve Airdrop for active Swerve Governance Participants\n///      Eligible participant addresses and their allocations are hardcoded\n\ncontract AirdropDistribution is Pausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address[210] airdropArray = [\n    0x28d6037EDEAf8ec2c91c9b2cF9A1643111d8F198,\n    0xcfc50541c3dEaf725ce738EF87Ace2Ad778Ba0C5,\n    0xF9e11762d522ea29Dd78178c9BAf83b7B093aacc,\n    0xED60d8590019e5E145ea81455c01F3e817Fe54EB,\n    0x052564eB0fd8b340803dF55dEf89c25C432f43f4,\n    0x21F3B2C8646B4fFA809406BB31dE325a3E5E9b9F,\n    0xd9A93390c487b954EB1Ad4c8a4Acc73840409869,\n    0xe15DD1510E39E9980C0dC47e404eb7298872bc64,\n    0x3BA21b6477F48273f41d241AA3722FFb9E07E247,\n    0x2326D4fb2737666DDA96bd6314e3D4418246cFE8,\n    0xa0f75491720835b36edC92D06DDc468D201e9b73,\n    0xAc6559dF1F410Feba9a6cbf395272189461D8463,\n    0xAE60C874eE07f44fB7BBbD1a5087cDB66E90BEd8,\n    0x600b8A34ec1CfD8B8aF78cFC49708419A16ea2e8,\n    0x89689dB564BF4b67BD7116B3f71e68A379FAad98,\n    0xCaEDCaaFE4C596e89704c5e6B499B8D3474F750f,\n    0xbC90B3Ce40fc3Ed921D910f3e046C65954fFF7cB,\n    0x303985ba2209b5c0c745885Fa6fdd2eC1FEB81A5,\n    0x3991ADBDf461D6817734555efDC8ef056fEfBF21,\n    0xADEEb9d09B8Bcee10943198FB6F6a4229bAB3675,\n    0xb9a954BF995bDEAcBDfE4B1F5f85cD6122c6E341,\n    0x86aF94E5E8d3D583575bBafDD2DcB6b898A555e4,\n    0x270d2924cA13F54632601647FB225DB8eb61fB49,\n    0x02e05dbBF4df5d17cb3A0140F9643fE68cc4Ae39,\n    0xd8D3d8ab22E30c5402AB2A2E216a4A53F4e09e9E,\n    0x28a55C4b4f9615FDE3CDAdDf6cc01FcF2E38A6b0,\n    0x78Bc49be7bae5e0eeC08780c86F0e8278B8B035b,\n    0xf0E12c7218cB38DF7A3A231Bb91EE82F732625b6,\n    0x99eb33756a2eAa32f5964A747722c4b59e6aF351,\n    0xB0ff496dF3860504ebdFF61590A13c1D810C97cc,\n    0x40d2Ce4C14f04bD91c59c6A1CD6e28F2A0fc81F8,\n    0xF07F2B6C340d8D303615710451C11e93fe56774D,\n    0x6979B914f3A1d8C0fec2C1FD602f0e674cdf9862,\n    0x90be4e1Da4BB2F464576749abAc99774148bC9a2,\n    0x681148725731F213b0187A3CBeF215C291D85a3E,\n    0x1678b549Be696b1DfCe9F0639D996a82409E1Ea1,\n    0x4f58985B75EeC8f14C536878A19EAdF4a1960D6c,\n    0x55b9c56668365d11f5aF18E8b7232bC6e4d20658,\n    0xA423fE4CFb811E9CF6a61a02e80E372c0970d4b0,\n    0x7432b5212F19af018b33b73a55d1996960E59c51,\n    0x0Af14239FAA4f19034f3334502ED592B0083e108,\n    0x9fA933f60BCc5E63F75F210929839f91F55b919C,\n    0xB680f628C56C8Fa368Dacbb0C27beEf8C98355b9,\n    0x4EC7CdF61405758f5cED5E454c0B4b0F4F043DF0,\n    0xFCa7C5CF95821f3D45b9949De6E2846D66aF819F,\n    0xA7758B30e93d2ED6CEA7c85e5B12a1d46F0f091f,\n    0x84740F97Aea62C5dC36756DFD9F749412534220E,\n    0xcE968c0fC101C4FB8e08EB5dB73E7E169A2A3562,\n    0xC151AE135F50AaBE78e0b9D13A90FBb2d648AAbB,\n    0x975f5ffB9C3B624351634889944355D47Ab8a367,\n    0x9B5ea8C719e29A5bd0959FaF79C9E5c8206d0499,\n    0xF1fb5dEa21337FEB46963C29d04A95F6CA8B71e6,\n    0x71F12a5b0E60d2Ff8A87FD34E7dcff3c10c914b0,\n    0x918A97AD195DD111C54Ea82E2F8B8D22E9f48726,\n    0x25431341A5800759268a6aC1d3CD91C029D7d9CA,\n    0x52Ad87832400485DE7E7dC965D8Ad890f4e82699,\n    0xF38140985B5a5746F160F133049E83F79cc0B819,\n    0xbE93d14C5dEFb8F41aF8FB092F58e3C71C712b85,\n    0xa0a6Dc36041fb386378458006FEcbDdD02555DdD,\n    0x5F82C97e9b1755237692a946aE814998Bc0e2124,\n    0xdD709cAE362972cb3B92DCeaD77127f7b8D58202,\n    0x8b7B509c01838a0D197a8154C5BF00A3F56fF615,\n    0x640E0118b2C5a3C0Ea29B94A62d9108ce2c6ced7,\n    0x1B51cCe51E2531C478daA9b68eb80D47247dCbec,\n    0xcCa71809E8870AFEB72c4720d0fe50d5C3230e05,\n    0x2dE640a18fE3480aa802aca91f70177aDA103391,\n    0x14Ce500a86F1e3aCE039571e657783E069643617,\n    0x6019D32e59Ef480F2215eE9773AE507645B47bdc,\n    0xB67D92DC830F1a24E4BFfd1a6794fCf8f497c7de,\n    0x6f9BB7e454f5B3eb2310343f0E99269dC2BB8A1d,\n    0xE95d3DAbA7495d42DCC20810f33eeb5207512a9f,\n    0x39c09fdc4E5C5AB72F6319dDbc2CAe40E67b2A60,\n    0xFadAFCE89EA2221fa33005640Acf2C923312F2b9,\n    0x7122FC3588fB9E9B93b7c42Ba02FC85ef15c442b,\n    0x25AfD857C7831C91951Cd94ba63AF237d28604D0,\n    0x6fcF92925e0281D957B0076d3751caD76916C96B,\n    0xd026bFdB74fe1bAF1E1F1058f0d008cD1EEEd8B5,\n    0xbdC38612397355e10A2d6DD697a92f35BF1C9935,\n    0x339Dab47bdD20b4c05950c4306821896CFB1Ff1A,\n    0x1EBb814C9EF016E6012bE299ED834f1dDcEd1529,\n    0xF625DCa051B5AE56f684C072c09969C9Aa91478a,\n    0x5eBdC5C097F9378c3113DC2f9E8B51246E641896,\n    0xD45FBD8F2B0A84743D2606DE8094f86Fac5B6ed3,\n    0x3e89F0eCACDC9b1f8BB892367610cAd0cE421C92,\n    0xC77C0EDc7067a76972481484B87c1226E410547C,\n    0x0F763341b448bb0f02370F4037FE4A2c84c9283f,\n    0x0035Fc5208eF989c28d47e552E92b0C507D2B318,\n    0xB8C30017B375bf675c2836c4c6B6ed5BE214739d,\n    0x286ed1111c29592cC6240194b8d66E64B1c05e50,\n    0x4Cd52B37fdDD19CcD24B0d0e9a048785C7aaFCEf,\n    0x0D779D67a428457CAbEC145A0f94703D14cd496B,\n    0x0000A441fBB1fBAADF246539BF253A42ABD31494,\n    0xECB949c68C825650fD9D0Aebe0cd3796FD126e66,\n    0x8C4d5F3eaC04072245654E0BA480f1a5e1d91Dd5,\n    0xFca32B89d0981e69C8dadCDcc0668b0E01c810CF,\n    0x22fa8Cc33a42320385Cbd3690eD60a021891Cb32,\n    0x23Be060093Db74f38B1a3daF57AfDc1a23dB0077,\n    0xfc80d0867822b8eD010bafcC195c21617C01f943,\n    0x526C7665C5dd9cD7102C6d42D407a0d9DC1e431d,\n    0x6c5384bBaE7aF65Ed1b6784213A81DaE18e528b2,\n    0xAE667Ed58c0d9198fc0b9261156d48296C1bB3da,\n    0xe1DE283EAb72A68f7Ff972fcA13f8953c6e15e51,\n    0xdae88e81e10d848BA6b0Ad64B19783e807064696,\n    0x0a8A06071c878DF9Ec2B5f9663A4b08B0F8c08f4,\n    0x3E95fEF1176acF5e5d2EF67D9C856E4ECAc73E1F,\n    0x9C3c75c9D269aa8282BDE7BE3352D81CC91C2b6A,\n    0xD72B03B7F2E0b8D92b868E73e12b1f888BEFBeDA,\n    0xC23ef3AdF050f4Ca50b30998D37Eb6464e387577,\n    0xD56705548111F08CCB3e1A73806c53Dc706F2e75,\n    0x32802F989B4348A51DD0E61D23B78BE1a0543469,\n    0xc7ca02DC88A2750031DC04515438C3a505bcC994,\n    0x1eccd61c9fa53a8D2e823A26cD72A7efD7D0E92e,\n    0xa53A6fE2d8Ad977aD926C485343Ba39f32D3A3F6,\n    0x6b30E020E9517c519C408f51C2593E12D55B55fA,\n    0x57d1E246D2E32F6F9D10EC55Fc41E8B2E2988308,\n    0xEd557994671DddA053a582e73F2e8aa32bDE7D68,\n    0xceA077172675bf31e879Bba71fb46C3188591070,\n    0x3fC925E779F148f2d843cfD63296E5E12C36d632,\n    0xC369B30c8eC960260631E20081A32e4c61E5Ea9d,\n    0x8d4BfE71379a197ae0c3ea8B41b75f30294d6afb,\n    0x455d7Eb74860d0937423b9184f9e8461aa354Ebb,\n    0x14559df3FBe66Cab6F893D8dD53F7BFE68DE9C65,\n    0x238F24101876377E9178d125D0747DE7fad9C3b2,\n    0x4BB633f0e7E0F3FbC95a7f7fd223652882977573,\n    0x9BdFAeB9CB28DC05b09B37c0F14ECBc9A876CEe0,\n    0x7904aDB48351aF7b835Cb061316795d5226b7f1a,\n    0xF96dA4775776ea43c42795b116C7a6eCcd6e71b5,\n    0x418Efa84214F9810AF9119909D5bEe2c56ebd5Eb,\n    0x2c9dB5597a4a9d2ba6780CD9722e25A9140552EE,\n    0xe1163DCFb598F74da146a83CC878731d553abBfe,\n    0x0991D02f28a5283338e9591CBf7dE2eb25da46Cd,\n    0x7374bB48A5FDc16C9b216F3fCc60b105c73D1806,\n    0xe4f9E812Fe379128f17258A2b3Db7CF28613f190,\n    0x2CA3a2b525E75b2F20f59dEcCaE3ffa4bdf3EAa2,\n    0x8522885d735F75b3FAEEa5CD39ab3d1291dA2C77,\n    0xA4bd4E4D2e8c72720839823f6c20f411f7DDb1f1,\n    0x1729f93e3c3C74B503B8130516984CED70bF47D9,\n    0x94Da725DBA289B96f115ec955aDcAAA806d2085d,\n    0x38857Ed3a8fC5951289E58e20fB56A00e88f0BBD,\n    0x767D222a509D107522e50161CA17FfCF0e5AA3dE,\n    0xA4f2b2557D78E31D48E1ffa8AF8b25Db8524Ea3c,\n    0xDEC1BcdF22A6e77F10e3bF7df8a5F6A6a38E6376,\n    0xC1a0fC4a40253B04a1aE2F40655d73b16CAf268c,\n    0x285E4f019a531e20f673B634D31922d408970798,\n    0x2848b9f2D4FaEBaA4838c41071684c70688B455d,\n    0xa734288DA3aCE7F9a5e5CAa6Df929126f2e67d52,\n    0xD18001F022154654149ed45888C9c29Def6d3CE6,\n    0x7ea1a45f0657D2Dbd77839a916AB83112bdB5590,\n    0x058B10CbE1872ad139b00326686EE8CCef274C58,\n    0xc78CE4E51611ed720eC96bf584bf1b1658FD2379,\n    0xFbEd5277E524113Df313F9f6B29fDE8677F4E936,\n    0xA652565dB815Ad3B138fD98830D14Cfd1826693A,\n    0x43E553fC1D064C125764E9D534a4F7D89B9bb1BE,\n    0x1712fdDC84EFa346D51261f0fa5a809fF457aBDc,\n    0xD0a5266b2515c3b575e30cBC0cfC775FA4fC6660,\n    0x507E964A2fabE1921278b640b0813a5626844145,\n    0x51A7EaD10340AF963C3124b026b86dd2807c2b1C,\n    0x215D67998DaCd9DA4118E4a4899bec60b79987A0,\n    0x8fC548B6B071bf0f2Fe64aD1Aa6032A6d2037366,\n    0x102902245322aAd61D55cfAD8213472A5702a593,\n    0x4B4De68ef03aE45c0d1026801Da71258DDC6BCF6,\n    0x32a59b87352e980dD6aB1bAF462696D28e63525D,\n    0xE582794320FA7424A1f9db360A46446244065Cb5,\n    0xD71C552a4954673a30893BF1Db0A77f1aFA1accD,\n    0xEE4a267E98260aCf829Ca9dC6c9f3d5d82183Bce,\n    0x54683a50f0D2B3F3d1b32780524AE01AA1A583c2,\n    0xdc34F2a567dFE0E7512108b24EcEa2d92754751C,\n    0xD09c6b71b1a7841e7dFb244D90d2a146201BF78B,\n    0xbB48c430C3cA821755547E514A8Fe9CC82BDD975,\n    0x7F326eA697EF0dd2BbD628B62F569017c1D43FCB,\n    0x7f048Fe4176AB39E225907F777F658a6eFDD42ce,\n    0x66EA1467282FFf8df570a1f732F0C6Ab8749154E,\n    0xc1cAd6df277106222Dd45cF5B0300fBd4d1193D5,\n    0x963D071201275fD5FA3dC9bB34fd3d0275ba97a7,\n    0x0707FD320C96b54182475B22a9D47b4045E74668,\n    0xfE2353C808F2409cCb81508005A62cef29457706,\n    0xE580aB95EBE6156c9717e20D513dD788B341934c,\n    0x4EC355d5780c9554EbdF1B40e9734A573D81052C,\n    0x3DdbbbB4C18f1e745A3F65ffC84E9197629Ac6B4,\n    0x05c0F2d1978a1Da91E5D82B8935c610b3F93f36B,\n    0x5221ce255906a61cf3DC2506143cd38D46A92be1,\n    0x573fA57407Bb0e4b761DBe801b5cbD160A8E8C21,\n    0x4Dacd010e15e220bC6C5C3210d166505d2b6c63A,\n    0x2FA26aD1BfAE9e66b5c3F364a9E8EcEc8520dB4a,\n    0xa357Cb3CE710a4f90fB9d56979C2C3634E3965bA,\n    0x1b74fcf3A084d13a9D910DB12469251988985413,\n    0xa948DE8A9205f1fE473490d2114c6616a90fD8d6,\n    0x101D5810f8841BcE68cB3e8CFbadB3f8C71fdff0,\n    0x9F7610115501abD147d1d82Ce92cea2A716690ED,\n    0xf600fd970Bc2054d81AFb1646B50531D7567b22c,\n    0x59cc72743488Aa24Caa92a521E74e633bb1f9096,\n    0x20BFFFdB086D35e1eE06b1e0Beb849eE0a0E945c,\n    0xa2040D6b10595EcBa2F751737b4A931A868f0655,\n    0x0900a13FB9382c6668a74500cccE70Eb96385e0C,\n    0x33d01F8BaA2319882440FE8Cf2978fb137B59Dc1,\n    0x7329c9ead9b5BB0AD240B75C3CFdc2828AC2EFCf,\n    0x77CB8c64e42ea076594A0C1E08115D8444Fa9fAc,\n    0x228a671629bE7a9436019AF909a1629c94bF4cAf,\n    0x7FF3552031C441f3F01AeDEb0C2C680FBA6dD5Df,\n    0x2D52F7BaE61912f7217351443eA8a226996a3Def,\n    0x6bac48867BC94Ff20B4C62b21d484a44D04d342C,\n    0xA42830eE059c77cAF8c8200B44AA9813CB0720c5,\n    0xf88d3412764873872aB1FdED5F168a6c1A3bF7bB,\n    0x3AA667D05a6aa1115cF4A533C29Bb538ACD1300c,\n    0xb92667E34cB6753449ADF464f18ce1833Caf26e0,\n    0x7BFEe91193d9Df2Ac0bFe90191D40F23c773C060,\n    0x1f0a6d7Db80E0C5Af146FDb836e04FAC0B1E8202,\n    0x2053e0218793eEc7107ec50b09B696D4431C1Ff8,\n    0xB8C2C00cC883d087C0Cbd443CeC51a4D04f8b147,\n    0xc8e99dd497ae1fc981c1dd48f49FB804FBFCB99D\n    ];\n\n    uint256[210] airdropBalances = \n\n    [\n    4297396,\n    1728358,\n    1505261,\n    1332003,\n    727506,\n    182291,\n    750722,\n    625052,\n    505013,\n    465932,\n    485597,\n    395709,\n    63621,\n    282190,\n    339931,\n    65686,\n    184250,\n    262345,\n    239002,\n    206374,\n    210330,\n    192425,\n    197415,\n    66379,\n    172905,\n    158272,\n    152257,\n    166385,\n    168117,\n    36747,\n    4760,\n    117953,\n    111187,\n    109898,\n    89898,\n    94390,\n    85323,\n    82567,\n    81233,\n    80992,\n    68640,\n    64138,\n    62431,\n    59644,\n    62799,\n    61129,\n    55179,\n    51915,\n    48305,\n    47379,\n    45361,\n    44710,\n    43459,\n    43725,\n    42692,\n    40472,\n    43858,\n    36506,\n    601,\n    33822,\n    32612,\n    542,\n    31773,\n    28432,\n    21291,\n    25655,\n    25360,\n    25258,\n    23591,\n    23366,\n    23422,\n    21365,\n    20012,\n    19919,\n    19240,\n    19638,\n    18884,\n    17133,\n    16639,\n    15337,\n    14773,\n    14824,\n    14644,\n    12760,\n    12503,\n    9,\n    12208,\n    2092,\n    11859,\n    11672,\n    11192,\n    10321,\n    1629,\n    10303,\n    9539,\n    9200,\n    9115,\n    3925,\n    8894,\n    8531,\n    8399,\n    8151,\n    7665,\n    7634,\n    165,\n    595,\n    6865,\n    6522,\n    6496,\n    6454,\n    6374,\n    3960,\n    622,\n    5993,\n    5971,\n    5930,\n    5930,\n    5722,\n    5645,\n    123,\n    5105,\n    5040,\n    813,\n    2220,\n    4618,\n    4482,\n    4448,\n    4447,\n    233,\n    4121,\n    3863,\n    3833,\n    3875,\n    3836,\n    3638,\n    3558,\n    3241,\n    2965,\n    2965,\n    34,\n    2965,\n    2965,\n    2699,\n    2687,\n    139,\n    2372,\n    2130,\n    384,\n    2172,\n    2092,\n    2083,\n    314,\n    2075,\n    475,\n    1769,\n    1769,\n    1559,\n    1511,\n    1490,\n    1482,\n    248,\n    1361,\n    1251,\n    1245,\n    1180,\n    1180,\n    222,\n    1010,\n    965,\n    947,\n    889,\n    620,\n    28,\n    810,\n    767,\n    619,\n    96,\n    593,\n    494,\n    221,\n    474,\n    84,\n    320,\n    445,\n    362,\n    56,\n    331,\n    280,\n    272,\n    38,\n    34,\n    5,\n    118,\n    17,\n    89,\n    88,\n    59,\n    8,\n    1,\n    30,\n    29,\n    504793,\n    430006,\n    39045,\n    15187,\n    8275,\n    141303,\n    195,\n    113110,\n    82615\n    ];\n\n    //Airdrop Shares\n    struct Airdrop {\n        uint256 amount;\n        uint256 claimed;\n        uint256 total_tokens;\n        uint256 fraction;     // with 10**18 precision\n    }\n\n    mapping(address => Airdrop) public airdrop;\n    mapping(address => uint256) public validated; //Are they validated to claim?\n\n    uint256 private airdrop_supply = 20160000 * 10 ** 18; //Total Allocation for Airdrop\n\n    // General constants\n    uint256 constant HOUR = 3600;\n    uint256 constant DAY = 86400;\n    uint256 constant WEEK = 86400 * 7;\n    uint256 constant YEAR = WEEK * 52;\n\n    uint256 constant RATE_TIME = WEEK;                          // How often the rate goes to the next epoch\n    uint256 constant INITIAL_RATE = 247_262 * 10 ** 18 / WEEK;  // per week\n    uint256 constant EPOCH_INFLATION = 98_831;                  // 98.831 % of prior week\n    uint256 constant INITIAL_RATE_EPOCH_CUTTOF = 260;           // airdrop stops after this many weeks\n\n    // Supply variables\n    uint256 public miningEpoch;\n    uint256 public startEpochTime;\n    uint256 public rate;\n\n    uint256 startEpochSupply;\n   \n    event updateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n    event Validated(address indexed investor, uint256 amount, uint256 timeStamp);\n    event Vested(address indexed investor, uint256 amount, uint256 timeStamp);\n\n    IERC20 public mainToken;    //BOOT token address\n    IVesting public vestLock;   //Vesting contract address\n\n    // define all the mining calculations here so that it doesn't have to\n    // called from MainToken contract\n    constructor(IERC20 _mainToken, IVesting _vestLock) {\n        require(address(_mainToken) != address(0), \"Invalid address\");\n        require(address(_vestLock) != address(0), \"Invalid address\");\n        mainToken = _mainToken;\n        vestLock = _vestLock;\n        rate = INITIAL_RATE;\n        startEpochTime = block.timestamp;\n\n        mainToken.approve(address(vestLock), 2**256-1);\n    }\n\n    //At first run, user has to validate - it checks if they are indeed in the airdrop, if yes, set the internal mappings for their address so they can claim.\n\n    function validate() external nonReentrant {\n        require(msg.sender != address(0));\n        require(airdrop[msg.sender].amount == 0, \"Already validated.\");\n        for (uint i = 0; i < airdropArray.length; i++) {\n            if (airdropArray[i] == msg.sender) {\n                uint256 airdroppable = airdropBalances[i] * 10 ** 18;\n                Airdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10**18 * airdroppable / airdrop_supply);\n                airdrop[msg.sender] = newAirdrop;\n                validated[msg.sender] = 1;\n                emit Validated(msg.sender, airdroppable, block.timestamp);\n                break;\n            }\n        }\n    }\n\n    \n    //Claim function can only be called if validated, and found to exist in hardcoded array.\n     \n    function claim() external nonReentrant {\n        require(msg.sender != address(0));\n        require(validated[msg.sender] == 1, \"Address not validated to claim.\");\n        require(airdrop[msg.sender].amount != 0);\n        \n        uint256 avail = _available_supply();\n        require(avail > 0, \"Nothing claimable (yet?)\");\n    \n        uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18;\n        assert(claimable > 0);\n        if (airdrop[msg.sender].claimed != 0) {\n            claimable -= airdrop[msg.sender].claimed;\n        }\n\n        assert(airdrop[msg.sender].amount - claimable != 0);\n\n        airdrop[msg.sender].amount -= claimable;\n        airdrop[msg.sender].claimed += claimable;\n\n        uint256 claimable_to_send = claimable * 3 / 10;         //30% released instantly\n        mainToken.transfer(msg.sender, claimable_to_send);\n        uint256 claimable_not_yet_vested = claimable - claimable_to_send; \n        vestLock.vest(msg.sender, claimable_not_yet_vested, 0); //70% locked in vesting contract\n\n        emit Vested(msg.sender, claimable, block.timestamp);\n    }\n\n\n    //Allow users to claim a specific amount instead of the entire amount\n    function claimExact(uint256 _value) external nonReentrant {\n        require(msg.sender != address(0));\n        require(airdrop[msg.sender].amount != 0);\n        \n        uint256 avail = _available_supply();\n        uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //\n        if (airdrop[msg.sender].claimed != 0){\n            claimable -= airdrop[msg.sender].claimed;\n        }\n\n        require(airdrop[msg.sender].amount >= claimable);\n        require(_value <= claimable);\n        airdrop[msg.sender].amount -= _value;\n        airdrop[msg.sender].claimed += _value;\n\n        uint256 claimable_to_send = _value * 3 / 10;\n        mainToken.transfer(msg.sender, claimable_to_send);\n        uint256 claimable_not_yet_vested = _value - claimable_to_send;\n        vestLock.vest(msg.sender, claimable_not_yet_vested, 0);\n\n        emit Vested(msg.sender, _value, block.timestamp);\n    }\n\n    /// @notice release of BOOT public sale tokens from this contract \n    /// based on emission rules\n    ///\n\n    function _updateEmission() private {\n        if (block.timestamp >= startEpochTime + RATE_TIME) {\n            miningEpoch += 1;\n            startEpochTime = startEpochTime.add(RATE_TIME);\n            startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));\n\n            if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {\n                rate = rate.mul(EPOCH_INFLATION).div(100000);\n            }\n            else {\n                rate = 0;\n            }\n            emit updateMiningParameters(block.timestamp, rate, startEpochSupply);\n        }\n    }\n\n    //Update emission to be called at every step change to update emission inflation\n    function updateEmission() public {\n        require(block.timestamp >= startEpochTime + RATE_TIME, \"Too soon\");\n        _updateEmission();\n    }\n\n     //Internal function to calculate current available supply\n    function _available_supply() private view returns(uint256) {\n        assert(block.timestamp - startEpochTime <= RATE_TIME);\n        return startEpochSupply + (block.timestamp - startEpochTime) * rate;\n    }\n\n    //Public function to calculate current available supply\n    function available_supply() public view returns(uint256) {\n        assert(block.timestamp - startEpochTime <= RATE_TIME);\n        return startEpochSupply + (block.timestamp - startEpochTime) * rate;\n    }\n\n}\n\n",
        "CodeNames": [
            "AirdropDistribution.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "claim() function in AirdropDistribution.sol",
                "Type": "Incorrect assert statement",
                "Description": "The assert statement in the claim() function prevents users from claiming their airdrop, but a workaround exists with the claimExact() function.",
                "Repair": "Remove the assert statement and add a require statement to check if the user has already claimed their airdrop"
            },
            {
                "Location": "AirdropDistribution.sol#L555-L563",
                "Type": "Claim airdrop repeatedly",
                "Description": "Suppose someone claims the last part of his airdrop via claimExact() of AirdropDistribution.sol. Then airdrop[msg.sender].amount will be set to 0. Suppose you then call validate() again. The check airdrop[msg.sender].amount == 0 will allow you to continue, because amount has just be set to 0. In the next part of the function, airdrop[msg.sender] is overwritten with fresh values and airdrop[msg.sender].claimed will be reset to 0. Now you can claim your airdrop again (as long as there are tokens present in the contract).",
                "Repair": "Add the following to validate() :require(validated[msg.sender]== 0, \"Already validated.\");"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BasicSale contract",
                "Type": "Missing approve() call",
                "Description": "The BasicSale contract is missing the approve() call, which causes the _withdrawShare() function to always revert with the message 'ERC20: transfer amount exceeds allowance' and prevents any tokens sent to the contract from being retrieved.",
                "Repair": "Add the mainToken.approve(address(vestLock), 2**256-1) call in the constructor of the BasicSale contract"
            },
            {
                "Location": "Multiple calls to transferFrom and transfer",
                "Type": "Unchecked transfers",
                "Description": "For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \u201cfalse\u201d is returned.",
                "Repair": "Check the result of transferFrom and transfer or make use of SafeERC20 library: safeTransfer and safeTransferFrom"
            },
            {
                "Location": "if (currentEra < firstPublicEra)",
                "Type": "NFT flashloans can bypass sale constraints",
                "Description": "The check for NFT holders can be easily bypassed with the help of flash loans.",
                "Repair": "Possible solutions include transferring and locking the NFT for at least 1 block, taking a snapshot of user balances, or checking that the caller is EOA"
            },
            {
                "Location": "virtualPrice function",
                "Type": "Get virtual price is not monotonically increasing",
                "Description": "The virtualPrice function is not monotonically increasing regardless of the market due to the customPrecisionMultipliers parameter.",
                "Repair": "Remove the getVirtualPrice function or set the precision multiplier as an immutable parameter"
            },
            {
                "Location": "self.balances",
                "Type": "Ideal balance is not calculated correctly when providing imbalanced liquidity",
                "Description": "The current implementation does not calculate the ideal balance correctly when providing imbalanced liquidity.",
                "Repair": "Replace self.balances with _xp(self, newBalances) or take balance's weighted pool as a reference"
            },
            {
                "Location": "MainToken.set_mint_multisig()",
                "Type": "Failure to Check Input Value",
                "Description": "The function MainToken.set_mint_multisig() doesn't check that _minting_multisig doesn't equal zero before it sets it as the new minting_multisig. This function can be invoked by mistake with the zero address as _minting_multisig, causing the system to lose its minting_multisig forever, without the option to set a new minting_multisig.",
                "Repair": "Check that _minting_multisig doesn't equal zero before setting it as the new minting_multisig."
            },
            {
                "Location": "stopRampTargetPrice()",
                "Type": "Arbitrage Opportunity",
                "Description": "stopRampTargetPrice would set the tokenPrecisionMultipliers to originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT). Once the tokenPrecisionMultipliers is changed, the price in the AMM pool would change. Arbitrager can sandwich stopRampTargetPrice to gain profit.",
                "Repair": "Ramp the tokenPrecisionMultipliers as the aPrecise is ramped. As the tokenPrecision is slowly increased/decreased, the arbitrage space would be slower and the profit would (probably) distribute evenly to lpers."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OwnerPausable.sol\";\nimport \"./SwapUtils.sol\";\nimport \"./MathUtils.sol\";\nimport \"./hardhat/console.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract Swap is OwnerPausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n    using SwapUtils for SwapUtils.Swap;\n    using SwapUtils for SwapUtils.TargetPrice;\n\n    // Structs storing data responsible for automatic market maker functionalities. In order to\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\n    SwapUtils.Swap public swapStorage;\n    SwapUtils.TargetPrice public targetPriceStorage;\n\n    // Address to allowlist contract that holds information about maximum totaly supply of lp tokens\n    // and maximum mintable amount per user address. As this is immutable, this will become a constant\n    // after initialization.\n    // IAllowlist private immutable allowlist;\n\n    // Boolean value that notates whether this pool is guarded or not. When isGuarded is true,\n    // addLiquidity function will be restricted by limits defined in allowlist contract.\n    // bool private guarded = true;\n\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\n    // getTokenIndex function also relies on this mapping to retrieve token index.\n    mapping(address => uint8) private tokenIndexes;\n\n    // uint256[2] originalPrecisionMultipliers;\n    // uint256[2] customPrecisionMultipliers;\n\n    /*** EVENTS ***/\n\n    // events replicated from SwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(\n        uint256 oldA,\n        uint256 newA,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event RampA2(\n        uint256 oldA2,\n        uint256 newA2,\n        uint256 initialA2Time,\n        uint256 futureA2Time\n    );\n    event StopRampA(uint256 currentA, uint256 time);\n    event StopRampA2(uint256 currentA2, uint256 time);\n\n    /**\n     * @notice Deploys this Swap contract with given parameters as default\n     * values. This will also deploy a LPToken that represents users\n     * LP position. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint new tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _a2 the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param _withdrawFee default withdrawFee to be initialized with\n     * @param _targetPrice default targetPrice to be initialized with\n     */\n\n    //   * @param _allowlist address of allowlist contract for guarded launch\n    constructor(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _a2,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        uint256 _targetPrice\n        // IAllowlist _allowlist\n    ) public OwnerPausable() ReentrancyGuard() {\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length == 2, \"_pooledTokens.length must be 2 in length\");\n        require(decimals.length == 2, \"decimals.length must be 2 in length\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        // uint256[] memory originalPrecisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            targetPriceStorage.originalPrecisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        uint256[2] memory customPrecisionMultipliers;\n        customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18);\n        customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1];\n        // console.log(\"customPrecisionMultipliers[0] %s\", customPrecisionMultipliers[0]);\n\n        // Check _a, _a2 _fee, _adminFee, _withdrawFee, _allowlist parameters\n        require(_a >= 0 && _a <= SwapUtils.MAX_A, \"_a not within the limits\");\n        require(_a2 >= 0 && _a2 <= SwapUtils.MAX_A, \"_a2 not within the limits\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n        require(\n            _withdrawFee < SwapUtils.MAX_WITHDRAW_FEE,\n            \"_withdrawFee exceeds maximum\"\n        );\n        // require(\n        //     _allowlist.getPoolCap(address(0x0)) == uint256(0x54dd1e),\n        //     \"Allowlist check failed\"\n        // );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = new LPToken(\n            lpTokenName,\n            lpTokenSymbol,\n            SwapUtils.POOL_PRECISION_DECIMALS\n        );\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = customPrecisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        \n        targetPriceStorage.initialTargetPrice = _targetPrice/*.mul(SwapUtils.TARGET_PRICE_PRECISION)*/;\n        targetPriceStorage.futureTargetPrice = _targetPrice/*.mul(SwapUtils.TARGET_PRICE_PRECISION)*/;\n        targetPriceStorage.initialTargetPriceTime = 0;\n        targetPriceStorage.futureTargetPriceTime = 0;\n\n        swapStorage.initialA = _a.mul(SwapUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(SwapUtils.A_PRECISION);\n        swapStorage.initialATime = 0;\n        swapStorage.futureATime = 0;\n        \n        swapStorage.initialA2 = _a2.mul(SwapUtils.A_PRECISION);\n        swapStorage.futureA2 = _a2.mul(SwapUtils.A_PRECISION);\n        swapStorage.initialA2Time = 0;\n        swapStorage.futureA2Time = 0;\n        \n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n        swapStorage.defaultWithdrawFee = _withdrawFee;\n\n        // Initialize variables related to guarding the initial deposits\n        // allowlist = _allowlist;\n        // guarded = true;\n    }\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check deadline against current timestamp\n     * @param deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 deadline) {\n        require(block.timestamp <= deadline, \"Deadline not met\");\n        _;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA() external view returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    /**\n     * @notice Return A2, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A2 parameter\n     */\n    function getA2() external view returns (uint256) {\n        return swapStorage.getA2();\n    }\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise() external view returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    /**\n     * @notice Return A2 in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A2 parameter in its raw precision form\n     */\n    function getA2Precise() external view returns (uint256) {\n        return swapStorage.getA2Precise();\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n     * @param index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 index) public view returns (IERC20) {\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\n        return swapStorage.pooledTokens[index];\n    }\n\n    /**\n     * @notice Return the index of the given token address. Reverts if no matching\n     * token is found.\n     * @param tokenAddress address of the token\n     * @return the index of the given token address\n     */\n    function getTokenIndex(address tokenAddress) external view returns (uint8) {\n        uint8 index = tokenIndexes[tokenAddress];\n        require(\n            address(getToken(index)) == tokenAddress,\n            \"Token does not exist\"\n        );\n        return index;\n    }\n\n    // /**\n    //  * @notice Reads and returns the address of the allowlist that is set during deployment of this contract\n    //  * @return the address of the allowlist contract casted to the IAllowlist interface\n    //  */\n    // function getAllowlist() external view returns (IAllowlist) {\n    //     return allowlist;\n    // }\n\n    /**\n     * @notice Return timestamp of last deposit of given address\n     * @return timestamp of the last deposit made by the given address\n     */\n    function getDepositTimestamp(address user) external view returns (uint256) {\n        return swapStorage.getDepositTimestamp(user);\n    }\n\n    /**\n     * @notice Return current balance of the pooled token at given index\n     * @param index the index of the token\n     * @return current balance of the pooled token at given index with token's native precision\n     */\n    function getTokenBalance(uint8 index) external view returns (uint256) {\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\n        return swapStorage.balances[index];\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external view returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256) {\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param account address that is depositing or withdrawing tokens\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        return swapStorage.calculateTokenAmount(account, amounts, deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param account the address that is withdrawing tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of token balances that the user will receive\n     */\n    function calculateRemoveLiquidity(address account, uint256 amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return swapStorage.calculateRemoveLiquidity(account, amount);\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param account the address that is withdrawing tokens\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount) {\n        (availableTokenAmount, ) = swapStorage.calculateWithdrawOneToken(\n            account,\n            tokenAmount,\n            tokenIndex\n        );\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee\n     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away\n     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you\n     * no additional fees.\n     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return swapStorage.calculateCurrentWithdrawFee(user);\n    }\n\n    /**\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\n     * @param index Index of the pooled token\n     * @return admin's token balance in the token's precision\n     */\n    function getAdminBalance(uint256 index) external view returns (uint256) {\n        return swapStorage.getAdminBalance(index);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of token user received on swap\n     */\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n    }\n\n    /**\n     * @notice Add liquidity to the pool with given amounts during guarded launch phase. Only users\n     * with valid address and proof can successfully call this function. When this function is called\n     * after the guarded release phase is over, the merkleProof is ignored.\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * get this data off chain. Even if the address is in the allowlist, users must include\n     * a valid proof for this call to succeed. If the pool is no longer in the guarded release phase,\n     * this parameter is ignored.\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.addLiquidity(amounts, minToMint);\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amounts of tokens user received\n     */\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external nonReentrant deadlineCheck(deadline) returns (uint256[] memory) {\n        return swapStorage.removeLiquidity(amount, minAmounts);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            swapStorage.removeLiquidityOneToken(\n                tokenAmount,\n                tokenIndex,\n                minAmount\n            );\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\n    }\n\n    /*** ADMIN FUNCTIONS ***/\n\n    /**\n     * @notice Updates the user withdraw fee. This function can only be called by\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\n     * @param recipient address of the recipient of pool token\n     * @param transferAmount amount of pool token to transfer\n     */\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n        external\n    {\n        require(\n            msg.sender == address(swapStorage.lpToken),\n            \"Only callable by pool token\"\n        );\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\n    }\n\n    /**\n     * @notice Withdraw all admin fees to the contract owner\n     */\n    function withdrawAdminFees() external onlyOwner {\n        swapStorage.withdrawAdminFees(owner());\n    }\n\n    /**\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(uint256 newAdminFee) external onlyOwner {\n        swapStorage.setAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice Update the swap fee to be applied on swaps\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(uint256 newSwapFee) external onlyOwner {\n        swapStorage.setSwapFee(newSwapFee);\n    }\n\n    /**\n     * @notice Update the withdraw fee. This fee decays linearly over 4 weeks since\n     * user's last deposit.\n     * @param newWithdrawFee new withdraw fee to be applied on future deposits\n     */\n    function setDefaultWithdrawFee(uint256 newWithdrawFee) external onlyOwner {\n        swapStorage.setDefaultWithdrawFee(newWithdrawFee);\n    }\n\n    /**\n     * @notice Start ramping up or down Target price towards given futureTargetPrice and futureTime\n     * Checks if the change is too rapid, and commits the new Target price value only when it falls under\n     * the limit range.\n     * @param futureTargetPrice the new target price to ramp towards\n     * @param futureTime timestamp when the new target price should be reached\n     */\n    function rampTargetPrice(uint256 futureTargetPrice, uint256 futureTime) external onlyOwner {\n        swapStorage.tokenPrecisionMultipliers[0] = targetPriceStorage.rampTargetPrice(futureTargetPrice, futureTime);\n    }\n\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A to ramp towards\n     * @param futureTime timestamp when the new A should be reached\n     */\n    function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {\n        swapStorage.rampA(futureA, futureTime);\n    }\n\n    /**\n     * @notice Start ramping up or down A2 parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A2 to ramp towards\n     * @param futureTime timestamp when the new A2 should be reached\n     */\n    function rampA2(uint256 futureA, uint256 futureTime) external onlyOwner {\n        swapStorage.rampA2(futureA, futureTime);\n    }\n\n    /**\n     * @notice Stop ramping Target Price immediately. Reverts if ramp Target Price is already stopped.\n     */\n    function stopRampTargetPrice() external onlyOwner {\n        swapStorage.tokenPrecisionMultipliers[0] = targetPriceStorage.stopRampTargetPrice();\n    }\n\n\n    /**\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n     */\n    function stopRampA() external onlyOwner {\n        swapStorage.stopRampA();\n    }\n\n    /**\n     * @notice Stop ramping A2 immediately. Reverts if ramp A2 is already stopped.\n     */\n    function stopRampA2() external onlyOwner {\n        swapStorage.stopRampA2();\n    }\n\n    // /**\n    //  * @notice Disables the guarded launch phase, removing any limits on deposit amounts and addresses\n    //  */\n    // function disableGuard() external onlyOwner {\n    //     guarded = false;\n    // }\n\n    // /**\n    //  * @notice Reads and returns current guarded status of the pool\n    //  * @return guarded_ boolean value indicating whether the deposits should be guarded\n    //  */\n    // function isGuarded() external view returns (bool) {\n    //     return guarded;\n    // }\n}\n\n\n",
        "CodeNames": [
            "Swap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Swap.sol#L30",
                "Type": "No Transfer Ownership Pattern",
                "Description": "The current ownership transfer process involves the current owner calling Swap.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.",
                "Repair": "Implement zero address check and consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed."
            },
            {
                "Location": "Swap.sol",
                "Type": "CustomPrecisionMultipliers Issue",
                "Description": "The customPrecisionMultipliers are set in the constructor and equal to 1 if the token's decimal = 18. If the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck.",
                "Repair": "Provide extra 10**18 in both multipliers."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./LPToken.sol\";\nimport \"./MathUtils.sol\";\nimport \"./hardhat/console.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampTargetPrice(\n        uint256 oldTargetPrice,\n        uint256 newTargetPrice,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event RampA(\n        uint256 oldA,\n        uint256 newA,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event RampA2(\n        uint256 oldA2,\n        uint256 newA2,\n        uint256 initialA2Time,\n        uint256 futureA2Time\n    );\n    event StopRampTargetPrice(uint256 currentTargetPrice, uint256 time);\n    event StopRampA(uint256 currentA, uint256 time);\n    event StopRampA2(uint256 currentA2, uint256 time);\n\n    struct Swap {\n        // variables around the ramp management of A,\n        // the amplification coefficient * n * (n - 1)\n        // see https://www.curve.fi/stableswap-paper.pdf for details\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n        // A2 \n        uint256 initialA2;\n        uint256 futureA2;\n        uint256 initialA2Time;\n        uint256 futureA2Time;\n        // fee calculation\n        uint256 swapFee;\n        uint256 adminFee;\n        uint256 defaultWithdrawFee;\n        LPToken lpToken;\n        // contract references for all tokens being pooled\n        IERC20[] pooledTokens;\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n        // has 8, so the multiplier should be 10**18 / 10 ** 8 => 10 ** 10\n        uint256[] tokenPrecisionMultipliers;\n        // uint256[2] originalPrecisionMultipliers;\n        // the pool balance of each token, in the token's precision\n        // the contract's actual token balance might differ\n        uint256[] balances;\n        mapping(address => uint256) depositTimestamp;\n        mapping(address => uint256) withdrawFeeMultiplier;\n    }\n\n    // Struct storing variables used in calculations in the\n    // rampTargetPrice, stopTargetPrice function to avoid stack too deep errors\n    struct TargetPrice {\n        uint256 initialTargetPrice;\n        uint256 futureTargetPrice;\n        uint256 initialTargetPriceTime;\n        uint256 futureTargetPriceTime;\n        \n        uint256[2] originalPrecisionMultipliers;\n    }\n\n    // Struct storing variables used in calculations in the\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 newY;\n        uint256 feePerToken;\n        uint256 preciseA;\n    }\n\n    // Struct storing variables used in calculation in addLiquidity function\n    // to avoid stack too deep error\n    struct AddLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        uint256 preciseA;\n    }\n\n    // Struct storing variables used in calculation in removeLiquidityImbalance function\n    // to avoid stack too deep error\n    struct RemoveLiquidityImbalanceInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        uint256 preciseA;\n    }\n\n    // in wei\n    uint256 private constant WEI_UNIT = 10**18;\n\n    // the precision all pools tokens will be converted to\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n\n    // Max swap fee is 1% or 100bps of each swap\n    uint256 public constant MAX_SWAP_FEE = 10**8;\n\n    // Max adminFee is 100% of the swapFee\n    // adminFee does not add additional fee on top of swapFee\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n    // users but only on the earnings of LPs\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\n\n    // Max withdrawFee is 1% of the value withdrawn\n    // Fee will be redistributed to the LPs in the pool, rewarding\n    // long term providers.\n    uint256 public constant MAX_WITHDRAW_FEE = 10**8;\n\n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    // Constant values used in ramping A, TargetPrice calculations\n    uint256 public constant TARGET_PRICE_PRECISION = 1;               // Target price will be provided in wei units. So, this value is set to 1.\n    uint256 public constant A_PRECISION = 100;\n    uint256 public constant MAX_A = 10**6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MAX_RELATIVE_PRICE_CHANGE = 10**16;     // in Wei. (0.01 * (10**18))\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter\n     */\n    function getA(Swap storage self) external view returns (uint256) {\n        return _getA(self);\n    }\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter\n     */\n    function _getA(Swap storage self) internal view returns (uint256) {\n        return _getAPrecise(self).div(A_PRECISION);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(Swap storage self) external view returns (uint256) {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * @notice Calculates and returns A based on the ramp settings\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\n        uint256 t1 = self.futureATime; // time when ramp is finished\n        uint256 a1 = self.futureA; // final A value when ramp is finished\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime; // time when ramp is started\n            uint256 a0 = self.initialA; // initial A value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                return\n                    a0.add(\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                return\n                    a0.sub(\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            }\n        } else {\n            return a1;\n        }\n    }\n\n    /**\n     * @notice Calculates and returns Target Price based on the ramp settings\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return Target Price parameter in its raw precision form\n     */\n    function _getTargetPricePrecise(TargetPrice storage self) internal view returns (uint256) {\n        uint256 t1 = self.futureTargetPriceTime; // time when ramp is finished\n        uint256 a1 = self.futureTargetPrice; // final Target Price value when ramp is finished\n        uint256 newTargetPrice;\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialTargetPriceTime; // time when ramp is started\n            uint256 a0 = self.initialTargetPrice; // initial Target Price value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                newTargetPrice = a0.add(\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                newTargetPrice = a0.sub(\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            }\n\n        } else {\n            newTargetPrice = a1;\n        }\n        \n        // console.log(\"running _getTargetPricePrecise() targetPrice of %s\", newTargetPrice);\n\n        return newTargetPrice;\n    }\n\n    /**\n     * @notice Return A2, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A2 parameter\n     */\n    function getA2(Swap storage self) external view returns (uint256) {\n        return _getA2(self);\n    }\n\n    /**\n     * @notice Return A2, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A2 parameter\n     */\n    function _getA2(Swap storage self) internal view returns (uint256) {\n        return _getA2Precise(self).div(A_PRECISION);\n    }\n\n    /**\n     * @notice Return A2 in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A2 parameter in its raw precision form\n     */\n    function getA2Precise(Swap storage self) external view returns (uint256) {\n        return _getA2Precise(self);\n    }\n\n    /**\n     * @notice Calculates and returns A2 based on the ramp settings\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A2 parameter in its raw precision form\n     */\n    function _getA2Precise(Swap storage self) internal view returns (uint256) {\n        uint256 t1 = self.futureA2Time; // time when ramp is finished\n        uint256 a1 = self.futureA2; // final A2 value when ramp is finished\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialA2Time; // time when ramp is started\n            uint256 a0 = self.initialA2; // initial A2 value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                return\n                    a0.add(\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                return\n                    a0.sub(\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            }\n        } else {\n            return a1;\n        }\n    }\n\n    /**\n     * @notice Retrieves the timestamp of last deposit made by the given address\n     * @param self Swap struct to read from\n     * @return timestamp of last deposit\n     */\n    function getDepositTimestamp(Swap storage self, address user)\n        external\n        view\n        returns (uint256)\n    {\n        return self.depositTimestamp[user];\n    }\n\n    /**\n     * @notice Calculate the dy, the amount of selected token that user receives and\n     * the fee of withdrawing in one token\n     * @param account the address that is withdrawing\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenIndex which token will be withdrawn\n     * @param self Swap struct to read from\n     * @return the amount of token user will receive and the associated swap fee\n     */\n    function calculateWithdrawOneToken(\n        Swap storage self,\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) public view returns (uint256, uint256) {\n        uint256 dy;\n        uint256 newY;\n\n        (dy, newY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount);\n\n        // dy_0 (without fees)\n        // dy, dy_0 - dy\n\n        uint256 dySwapFee =\n            _xp(self)[tokenIndex]\n                .sub(newY)\n                .div(self.tokenPrecisionMultipliers[tokenIndex])\n                .sub(dy);\n\n        dy = dy\n            .mul(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))\n        )\n            .div(FEE_DENOMINATOR);\n\n        return (dy, dySwapFee);\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param self Swap struct to read from\n     * @param tokenIndex which token will be withdrawn\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @return the d and the new y after withdrawing one token\n     */\n    function calculateWithdrawOneTokenDY(\n        Swap storage self,\n        uint8 tokenIndex,\n        uint256 tokenAmount\n    ) internal view returns (uint256, uint256) {\n        require(\n            tokenIndex < self.pooledTokens.length,\n            \"Token index out of range\"\n        );\n\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256[] memory xp = _xp(self);\n        CalculateWithdrawOneTokenDYInfo memory v =\n            CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n        v.preciseA = determineA(self, xp);\n        // calculate D based on correct A\n        v.d0 = getD(xp, v.preciseA);\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(self.lpToken.totalSupply()));\n\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n        v.newY = getYDC(self, v.preciseA, tokenIndex, xp, v.d1);\n\n        uint256[] memory xpReduced = new uint256[](xp.length);\n\n        v.feePerToken = _feePerToken(self);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 xpi = xp[i];\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n            xpReduced[i] = xpi.sub(\n                (\n                    (i == tokenIndex)\n                        ? xpi.mul(v.d1).div(v.d0).sub(v.newY)\n                        : xpi.sub(xpi.mul(v.d1).div(v.d0))\n                )\n                    .mul(v.feePerToken)\n                    .div(FEE_DENOMINATOR)\n            );\n        }\n\n        uint256 dy =\n            xpReduced[tokenIndex].sub(\n                getYDC(self, determineA(self, xpReduced), tokenIndex, xpReduced, v.d1)\n            );\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n\n        return (dy, v.newY);\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool with given\n     * precision-adjusted balances and a particular D.\n     *\n     * @dev This is accomplished via solving the invariant iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param self Swap struct to read from\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param tokenIndex Index of token we are calculating for.\n     * @param xp a precision-adjusted set of pool balances. Array should be\n     * the same cardinality as the pool.\n     * @param d the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYDC(\n        Swap storage self,\n        uint256 a,\n        uint8 tokenIndex,\n        uint256[] memory xp,\n        uint256 d\n    ) internal view returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        // calculate y\n        uint256 y = getYD(a, tokenIndex, xp, d);\n\n        // Calculate A at the resulting position\n        // tokenIndex can be either 0 or 1, and the second parameter should be the other one.\n        // x should be the amount of token at that spot in the xp, so xp[1-tokenIndex]\n        uint256 aNew = _xpCalc(self, 1-tokenIndex, tokenIndex, xp[1-tokenIndex], y);\n\n        // Check if we switched A's during the swap\n        if (aNew == a){     // We have used the correct A\n            return y;\n        } else {    // We have switched A's, do it again with the new A\n            return getYD(aNew, tokenIndex, xp, d);\n        }\n\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool with given\n     * precision-adjusted balances and a particular D.\n     *\n     * @dev This is accomplished via solving the invariant iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param tokenIndex Index of token we are calculating for.\n     * @param xp a precision-adjusted set of pool balances. Array should be\n     * the same cardinality as the pool.\n     * @param d the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYD(\n        uint256 a,\n        uint8 tokenIndex,\n        uint256[] memory xp,\n        uint256 d\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = a.mul(numTokens);\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i != tokenIndex) {\n                s = s.add(xp[i]);\n                c = c.mul(d).div(xp[i].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // c = c * D * D * D * ... overflow!\n            }\n        }\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\n\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = d;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n     * as the pool.\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n     * See the StableSwap paper for details\n     * @return the invariant, at the precision of the pool\n     */\n    function getD(uint256[] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 numTokens = xp.length;\n        uint256 s;\n        for (uint256 i = 0; i < numTokens; i++) {\n            s = s.add(xp[i]);\n        }\n        if (s == 0) {\n            return 0;\n        }\n\n        uint256 prevD;\n        uint256 d = s;\n        uint256 nA = a.mul(numTokens);\n\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = d;\n            for (uint256 j = 0; j < numTokens; j++) {\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // dP = dP * D * D * D * ... overflow!\n            }\n            prevD = d;\n            // d = nA.mul(s).div(A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\n            //     nA.sub(A_PRECISION).mul(d).div(A_PRECISION).add(\n            //         numTokens.add(1).mul(dP)\n            //     )\n            // );\n\n            d = nA.mul(s).div(A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\n                nA.mul(d).div(A_PRECISION).add(\n                    numTokens.add(1).mul(dP)).sub(d)\n            );\n            if (d.within1(prevD)) {\n                return d;\n            }\n        }\n\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n        // function which does not rely on D.\n        revert(\"D does not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on self Swap struct\n     * @param self Swap struct to read from\n     * @return The invariant, at the precision of the pool\n     */\n    function getD(Swap storage self) internal view returns (uint256) {\n        uint256 a = determineA(self, _xp(self));            // determine the correct A\n        return getD(_xp(self), a);\n    }\n\n    /**\n     * @notice Given a set of balances and precision multipliers, return the\n     * precision-adjusted balances.\n     *\n     * @param balances an array of token balances, in their native precisions.\n     * These should generally correspond with pooled tokens.\n     *\n     * @param precisionMultipliers an array of multipliers, corresponding to\n     * the amounts in the balances array. When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @return an array of amounts \"scaled\" to the pool's precision\n     */\n    function _xp(\n        uint256[] memory balances,\n        uint256[] memory precisionMultipliers\n    ) internal pure returns (uint256[] memory) {\n        uint256 numTokens = balances.length;\n        require(\n            numTokens == precisionMultipliers.length,\n            \"Balances must match multipliers\"\n        );\n        uint256[] memory xp = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; i++) {\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\n        }\n        return xp;\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @param balances array of balances to scale\n     * @return balances array \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self, uint256[] memory balances)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return _xp(balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice determine correct A whether in A1 or A2 region in customswap\n     * @param self Swap struct to read from\n     * @return a, the amplification coefficient\n     */\n    function determineA(\n        Swap storage self, \n        uint256[] memory xp)\n        internal\n        view\n        returns(uint256)\n    {\n        // Determine the correct A by comparing xp[0] and xp[1].\n        // determine if currently in the A region or in the A2 region.\n        if( xp[0] < xp[1] ) {\n            return _getAPrecise(self);\n        } else {\n            return _getA2Precise(self);        \n        }\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @param self Swap struct to read from\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice(Swap storage self)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 a = determineA(self, _xp(self));\n\n        // Calculate D based on correct A\n        uint256 d = getD(_xp(self), a);\n        uint256 supply = self.lpToken.totalSupply();\n        if (supply > 0) {\n            return\n                d.mul(10**uint256(ERC20(self.lpToken).decimals())).div(supply);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Y Custom: Calculate the new balances of the tokens given the indexes of the token\n     * that is swapped from (FROM) and the token that is swapped to (TO).\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param xp balances of the tokens in the pool\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getYC(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        // 1. Determine the correct A by comparing xp[0] and xp[1].\n        uint256 a = determineA(self, xp);\n\n        // 2. Calculate D of the initial position\n        uint256 d = getD(xp, a);\n\n        // 3. calculate y\n        uint256 y = getY(self, tokenIndexFrom, tokenIndexTo, x, xp, a, d);\n\n        // 4. Calculate A at the resulting position\n        uint256 aNew = _xpCalc(self, tokenIndexFrom, tokenIndexTo, x, y);\n\n        // 5. Check if we switched A's during the swap\n        if (aNew == a){     // We have used the correct A\n            return y;\n        } else {    // We have switched A's, do it again with the new A\n            return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d);\n        }\n\n    }\n\n\n    /**\n     * @notice Calculate the xpNew -> total balances of the token & aNew -> new amplification coefficient based on new\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param y the amount of TO token that should remain in the pool\n     * @return aNew New amplification coefficient\n     */\n    function _xpCalc(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256 y\n        ) internal view returns (uint256) \n    {\n        uint256 xpNew0;\n        uint256 xpNew1;\n\n        // Calculate xpNew, being the the balances after the trade\n        if( tokenIndexFrom == 0 && tokenIndexTo == 1) {\n            xpNew0 = x;\n            xpNew1 = y;\n        } \n        else if( tokenIndexFrom == 1 && tokenIndexTo == 0) {\n            xpNew0 = y;\n            xpNew1 = x;\n        }\n\n        // Compare xpNew[0] and xpNew[1] and determine the target A\n        if (xpNew0 < xpNew1) {\n            return _getAPrecise(self);\n        } else {\n            return _getA2Precise(self);\n        }\n    }\n\n\n    /**\n     * @notice Calculate the new balances of the tokens given the indexes of the token\n     * that is swapped from (FROM) and the token that is swapped to (TO).\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param xp balances of the tokens in the pool\n     * @param a amplification coefficient\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getY(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp,\n        uint256 a,\n        uint256 d\n    ) internal view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = numTokens.mul(a);\n\n        uint256 _x;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i == tokenIndexFrom) {\n                _x = x;\n            } else if (i != tokenIndexTo) {\n                _x = xp[i];\n            } else {\n                continue;\n            }\n            s = s.add(_x);\n            c = c.mul(d).div(_x.mul(numTokens));\n            // If we were to protect the division loss we would have to keep the denominator separate\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\n            // c = c * D * D * D * ... overflow!\n        }\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = d;\n\n        // iterative approximation\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens.\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     * @return dyFee the associated fee\n     */\n    function _calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) internal view returns (uint256 dy, uint256 dyFee) {\n        uint256[] memory xp = _xp(self);\n        require(\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n            \"Token index out of range\"\n        );\n        uint256 x =\n            dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(\n                xp[tokenIndexFrom]\n            );\n        uint256 y = getYC(self, tokenIndexFrom, tokenIndexTo, x, xp);\n        dy = xp[tokenIndexTo].sub(y).sub(1);\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n        dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of\n     * LP tokens\n     *\n     * @param account the address that is removing liquidity. required for withdraw fee calculation\n     * @param amount the amount of LP tokens that would to be burned on\n     * withdrawal\n     * @return array of amounts of tokens user will receive\n     */\n    function calculateRemoveLiquidity(\n        Swap storage self,\n        address account,\n        uint256 amount\n    ) external view returns (uint256[] memory) {\n        return _calculateRemoveLiquidity(self, account, amount);\n    }\n\n    function _calculateRemoveLiquidity(\n        Swap storage self,\n        address account,\n        uint256 amount\n    ) internal view returns (uint256[] memory) {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n        uint256 feeAdjustedAmount =\n            amount\n                .mul(\n                FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))\n            )\n                .div(FEE_DENOMINATOR);\n\n        uint256[] memory amounts = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            amounts[i] = self.balances[i].mul(feeAdjustedAmount).div(\n                totalSupply\n            );\n        }\n        return amounts;\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws.\n     * Withdraw fee decays linearly over 4 weeks.\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(Swap storage self, address user)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 endTime = self.depositTimestamp[user].add(4 weeks);\n        if (endTime > block.timestamp) {\n            uint256 timeLeftover = endTime.sub(block.timestamp);\n            return\n                self\n                    .defaultWithdrawFee\n                    .mul(self.withdrawFeeMultiplier[user])\n                    .mul(timeLeftover)\n                    .div(4 weeks)\n                    .div(FEE_DENOMINATOR);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param self Swap struct to read from\n     * @param account address of the account depositing or withdrawing tokens\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return if deposit was true, total amount of lp token that will be minted and if\n     * deposit was false, total amount of lp token that will be burned\n     */\n    function calculateTokenAmount(\n        Swap storage self,\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        // Calculate D based on correct A\n        uint256 d0 = getD(_xp(self, self.balances), determineA(self, _xp(self, self.balances)));\n        uint256[] memory balances1 = self.balances;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (deposit) {\n                balances1[i] = balances1[i].add(amounts[i]);\n            } else {\n                balances1[i] = balances1[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n        }\n        // Calculate D based on correct A\n        uint256 d1 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1)));\n        uint256 totalSupply = self.lpToken.totalSupply();\n\n        if (deposit) {\n            return d1.sub(d0).mul(totalSupply).div(d0);\n        } else {\n            return\n                d0.sub(d1).mul(totalSupply).div(d0).mul(FEE_DENOMINATOR).div(\n                    FEE_DENOMINATOR.sub(\n                        calculateCurrentWithdrawFee(self, account)\n                    )\n                );\n        }\n    }\n\n    /**\n     * @notice return accumulated amount of admin fees of the token with given index\n     * @param self Swap struct to read from\n     * @param index Index of the pooled token\n     * @return admin balance in the token's precision\n     */\n    function getAdminBalance(Swap storage self, uint256 index)\n        external\n        view\n        returns (uint256)\n    {\n        require(index < self.pooledTokens.length, \"Token index out of range\");\n        return\n            self.pooledTokens[index].balanceOf(address(this)).sub(\n                self.balances[index]\n            );\n    }\n\n    /**\n     * @notice internal helper function to calculate fee per token multiplier used in\n     * swap fee calculations\n     * @param self Swap struct to read from\n     */\n    function _feePerToken(Swap storage self) internal view returns (uint256) {\n        return\n            self.swapFee.mul(self.pooledTokens.length).div(\n                self.pooledTokens.length.sub(1).mul(4)\n            );\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param self Swap struct to read from and write to\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @return amount of token user received on swap\n     */\n    function swap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy\n    ) external returns (uint256) {\n        require(\n            dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender),\n            \"Cannot swap more than you own\"\n        );\n\n        // Transfer tokens first to see if a fee was charged on transfer\n        uint256 beforeBalance =\n            self.pooledTokens[tokenIndexFrom].balanceOf(address(this));\n        self.pooledTokens[tokenIndexFrom].safeTransferFrom(\n            msg.sender,\n            address(this),\n            dx\n        );\n\n        // Use the actual transferred amount for AMM math\n        uint256 transferredDx =\n            self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(\n                beforeBalance\n            );\n\n        (uint256 dy, uint256 dyFee) =\n            _calculateSwap(self, tokenIndexFrom, tokenIndexTo, transferredDx);\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee =\n            dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n                self.tokenPrecisionMultipliers[tokenIndexTo]\n            );\n\n        self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(\n            transferredDx\n        );\n        self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(\n            dyAdminFee\n        );\n\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n        emit TokenSwap(\n            msg.sender,\n            transferredDx,\n            dy,\n            tokenIndexFrom,\n            tokenIndexTo\n        );\n\n        return dy;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param self Swap struct to read from and write to\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n     * @return amount of LP token user received\n     */\n    function addLiquidity(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 minToMint\n    ) external returns (uint256) {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts must match pooled tokens\"\n        );\n\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        // current state\n        AddLiquidityInfo memory v = AddLiquidityInfo(0, 0, 0, 0);\n\n        if (self.lpToken.totalSupply() != 0) {\n            v.d0 = getD(self);\n        }\n\n        // console.log(\"lptoken total supply in L-1183 addLiquidity: %s\", self.lpToken.totalSupply());\n\n        // console.log(\n        //     \"d0: %s,\",\n        //     v.d0\n        // );\n        uint256[] memory newBalances = self.balances;\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            require(\n                self.lpToken.totalSupply() != 0 || amounts[i] > 0,\n                \"Must supply all tokens in pool\"\n            );\n\n            // Transfer tokens first to see if a fee was charged on transfer\n            if (amounts[i] != 0) {\n                uint256 beforeBalance =\n                    self.pooledTokens[i].balanceOf(address(this));\n                self.pooledTokens[i].safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amounts[i]\n                );\n\n                // Update the amounts[] with actual transfer amount\n                amounts[i] = self.pooledTokens[i].balanceOf(address(this)).sub(\n                    beforeBalance\n                );\n            }\n\n            newBalances[i] = self.balances[i].add(amounts[i]);\n        }\n\n        // invariant after change\n        v.preciseA = determineA(self, _xp(self, newBalances));\n        // uint256[] memory tempxp = _xp(self, newBalances);\n        // console.log(\"temp xp[0] in addLiquidity(): %s\", tempxp[0]);\n        // console.log(\"temp xp[1] in addLiquidity(): %s\", tempxp[1]);\n        // console.log(\"v.preciseA in addLiquidity(): %s\", v.preciseA);\n        // calculate D based on correct A\n        v.d1 = getD(_xp(self, newBalances), v.preciseA);\n        require(v.d1 > v.d0, \"D should increase\");\n\n        // updated to reflect fees and calculate the user's LP tokens\n        v.d2 = v.d1;\n        if (self.lpToken.totalSupply() != 0) {\n            uint256 feePerToken = _feePerToken(self);\n            // console.log(\"lptoken total supply L-1226 in addLiquidity(): %s\", self.lpToken.totalSupply());\n            for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n                fees[i] = feePerToken\n                    .mul(idealBalance.difference(newBalances[i]))\n                    .div(FEE_DENOMINATOR);\n                self.balances[i] = newBalances[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                newBalances[i] = newBalances[i].sub(fees[i]);\n            }\n            // calculate D based on correct A\n            v.d2 = getD(_xp(self, newBalances), determineA(self, _xp(self, newBalances)));\n        } else {\n            // the initial depositor doesn't pay fees\n            self.balances = newBalances;\n        }\n\n        uint256 toMint;\n        if (self.lpToken.totalSupply() == 0) {\n            toMint = v.d1;\n        } else {\n            toMint = v.d2.sub(v.d0).mul(self.lpToken.totalSupply()).div(v.d0);\n        }\n        // console.log(\"toMint: %s\", toMint);\n        // console.log(\"minToMint: %s\", minToMint);\n\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n        // mint the user's LP tokens\n        self.lpToken.mint(msg.sender, toMint);\n\n        emit AddLiquidity(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            self.lpToken.totalSupply()\n        );\n\n        return toMint;\n    }\n\n    /**\n     * @notice Update the withdraw fee for `user`. If the user is currently\n     * not providing liquidity in the pool, sets to default value. If not, recalculate\n     * the starting withdraw fee based on the last deposit's time & amount relative\n     * to the new deposit.\n     *\n     * @param self Swap struct to read from and write to\n     * @param user address of the user depositing tokens\n     * @param toMint amount of pool tokens to be minted\n     */\n    function updateUserWithdrawFee(\n        Swap storage self,\n        address user,\n        uint256 toMint\n    ) external {\n        _updateUserWithdrawFee(self, user, toMint);\n    }\n\n    function _updateUserWithdrawFee(\n        Swap storage self,\n        address user,\n        uint256 toMint\n    ) internal {\n        // If token is transferred to address 0 (or burned), don't update the fee.\n        if (user == address(0)) {\n            return;\n        }\n        if (self.defaultWithdrawFee == 0) {\n            // If current fee is set to 0%, set multiplier to FEE_DENOMINATOR\n            self.withdrawFeeMultiplier[user] = FEE_DENOMINATOR;\n        } else {\n            // Otherwise, calculate appropriate discount based on last deposit amount\n            uint256 currentFee = calculateCurrentWithdrawFee(self, user);\n            uint256 currentBalance = self.lpToken.balanceOf(user);\n\n            // ((currentBalance * currentFee) + (toMint * defaultWithdrawFee)) * FEE_DENOMINATOR /\n            // ((toMint + currentBalance) * defaultWithdrawFee)\n            self.withdrawFeeMultiplier[user] = currentBalance\n                .mul(currentFee)\n                .add(toMint.mul(self.defaultWithdrawFee))\n                .mul(FEE_DENOMINATOR)\n                .div(toMint.add(currentBalance).mul(self.defaultWithdrawFee));\n        }\n        self.depositTimestamp[user] = block.timestamp;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param self Swap struct to read from and write to\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     * acceptable for this burn. Useful as a front-running mitigation\n     * @return amounts of tokens the user received\n     */\n    function removeLiquidity(\n        Swap storage self,\n        uint256 amount,\n        uint256[] calldata minAmounts\n    ) external returns (uint256[] memory) {\n        require(amount <= self.lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(\n            minAmounts.length == self.pooledTokens.length,\n            \"minAmounts must match poolTokens\"\n        );\n\n        uint256[] memory amounts =\n            _calculateRemoveLiquidity(self, msg.sender, amount);\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n            self.balances[i] = self.balances[i].sub(amounts[i]);\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        self.lpToken.burnFrom(msg.sender, amount);\n\n        emit RemoveLiquidity(msg.sender, amounts, self.lpToken.totalSupply());\n\n        return amounts;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param self Swap struct to read from and write to\n     * @param tokenAmount the amount of the lp tokens to burn\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @return amount chosen token that user received\n     */\n    function removeLiquidityOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount\n    ) external returns (uint256) {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        uint256 numTokens = self.pooledTokens.length;\n        require(\n            tokenAmount <= self.lpToken.balanceOf(msg.sender),\n            \">LP.balanceOf\"\n        );\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 dyFee;\n        uint256 dy;\n\n        (dy, dyFee) = calculateWithdrawOneToken(\n            self,\n            msg.sender,\n            tokenAmount,\n            tokenIndex\n        );\n\n        require(dy >= minAmount, \"dy < minAmount\");\n\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\n        );\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n\n        emit RemoveLiquidityOne(\n            msg.sender,\n            tokenAmount,\n            totalSupply,\n            tokenIndex,\n            dy\n        );\n\n        return dy;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param self Swap struct to read from and write to\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @return actual amount of LP tokens burned in the withdrawal\n     */\n    function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(\n            maxBurnAmount <= self.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        RemoveLiquidityImbalanceInfo memory v =\n            RemoveLiquidityImbalanceInfo(0, 0, 0, 0);\n\n        uint256 tokenSupply = self.lpToken.totalSupply();\n        uint256 feePerToken = _feePerToken(self);\n\n        uint256[] memory balances1 = self.balances;\n\n        v.preciseA = determineA(self, _xp(self));\n        v.d0 = getD(_xp(self), v.preciseA);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            balances1[i] = balances1[i].sub(\n                amounts[i],\n                \"Cannot withdraw more than available\"\n            );\n        }\n        v.d1 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1)));\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n            uint256 difference = idealBalance.difference(balances1[i]);\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n            self.balances[i] = balances1[i].sub(\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n            );\n            balances1[i] = balances1[i].sub(fees[i]);\n        }\n\n        v.d2 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1)));\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(tokenSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            tokenSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }\n\n    /**\n     * @notice withdraw all admin fees to a given address\n     * @param self Swap struct to withdraw fees from\n     * @param to Address to send the fees to\n     */\n    function withdrawAdminFees(Swap storage self, address to) external {\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            IERC20 token = self.pooledTokens[i];\n            uint256 balance =\n                token.balanceOf(address(this)).sub(self.balances[i]);\n            if (balance != 0) {\n                token.safeTransfer(to, balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets the admin fee\n     * @dev adminFee cannot be higher than 100% of the swap fee\n     * @param self Swap struct to update\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\n        self.adminFee = newAdminFee;\n\n        emit NewAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice update the swap fee\n     * @dev fee cannot be higher than 1% of each swap\n     * @param self Swap struct to update\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\n        self.swapFee = newSwapFee;\n\n        emit NewSwapFee(newSwapFee);\n    }\n\n    /**\n     * @notice update the default withdraw fee. This also affects deposits made in the past as well.\n     * @param self Swap struct to update\n     * @param newWithdrawFee new withdraw fee to be applied\n     */\n    function setDefaultWithdrawFee(Swap storage self, uint256 newWithdrawFee)\n        external\n    {\n        require(newWithdrawFee <= MAX_WITHDRAW_FEE, \"Fee is too high\");\n        self.defaultWithdrawFee = newWithdrawFee;\n\n        emit NewWithdrawFee(newWithdrawFee);\n    }\n\n    /**\n     * @notice Start ramping up or down target price towards given futureTargetPrice_ and futureTime_\n     * Checks if the change is too rapid, and commits the new target price value only when it falls under\n     * the limit range.\n     * @param self TargetPrice struct to update\n     * @param futureTargetPrice_ the new target price to ramp towards\n     * @param futureTime_ timestamp when the new target price should be reached\n     */\n    function rampTargetPrice(\n        TargetPrice storage self,\n        uint256 futureTargetPrice_,\n        uint256 futureTime_\n    ) external returns (uint256) {\n        require(\n            block.timestamp >= self.initialTargetPriceTime.add(1 days),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureTargetPrice_ >= 0,\n            \"futureTargetPrice_ must be >= 0\"\n        );\n\n        uint256 initialTargetPricePrecise = _getTargetPricePrecise(self);\n        uint256 futureTargetPricePrecise = futureTargetPrice_.mul(TARGET_PRICE_PRECISION);\n\n        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }\n\n        self.initialTargetPrice = initialTargetPricePrecise;\n        self.futureTargetPrice = futureTargetPricePrecise;\n        self.initialTargetPriceTime = block.timestamp;\n        self.futureTargetPriceTime = futureTime_;\n        \n        // console.log(\"executing rampTargetPrice() initalTargetPrice: %s\", self.initialTargetPrice);\n        // console.log(\"futureTargetPrice: %s\", self.futureTargetPrice);\n\n        emit RampTargetPrice(\n            initialTargetPricePrecise,\n            futureTargetPricePrecise,\n            block.timestamp,\n            futureTime_\n        );\n\n        // change token multiplier to reflect new target price\n        return self.originalPrecisionMultipliers[0].mul(initialTargetPricePrecise).div(WEI_UNIT);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param self Swap struct to update\n     * @param futureA_ the new A to ramp towards\n     * @param futureTime_ timestamp when the new A should be reached\n     */\n    function rampA(\n        Swap storage self,\n        uint256 futureA_,\n        uint256 futureTime_\n    ) external {\n        require(\n            block.timestamp >= self.initialATime.add(1 days),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureA_ >= 0 && futureA_ <= MAX_A,\n            \"futureA_ must be >= 0 and <= MAX_A\"\n        );\n\n        uint256 initialAPrecise = _getAPrecise(self);\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\n\n        if (futureAPrecise < initialAPrecise) {\n            require(\n                futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise,\n                \"futureA_ is too small\"\n            );\n        } else {\n            require(\n                futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE),\n                \"futureA_ is too large\"\n            );\n        }\n\n        self.initialA = initialAPrecise;\n        self.futureA = futureAPrecise;\n        self.initialATime = block.timestamp;\n        self.futureATime = futureTime_;\n\n        emit RampA(\n            initialAPrecise,\n            futureAPrecise,\n            block.timestamp,\n            futureTime_\n        );\n    }\n\n    /**\n     * @notice Start ramping up or down A2 parameter towards given futureA2_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param self Swap struct to update\n     * @param futureA2_ the new A2 to ramp towards\n     * @param futureTime_ timestamp when the new A2 should be reached\n     */\n    function rampA2(\n        Swap storage self,\n        uint256 futureA2_,\n        uint256 futureTime_\n    ) external {\n        require(\n            block.timestamp >= self.initialA2Time.add(1 days),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureA2_ >= 0 && futureA2_ <= MAX_A,\n            \"futureA2_ must be >= 0 and <= MAX_A\"\n        );\n\n        uint256 initialA2Precise = _getA2Precise(self);\n        uint256 futureA2Precise = futureA2_.mul(A_PRECISION);\n\n        if (futureA2Precise < initialA2Precise) {\n            require(\n                futureA2Precise.mul(MAX_A_CHANGE) >= initialA2Precise,\n                \"futureA2_ is too small\"\n            );\n        } else {\n            require(\n                futureA2Precise <= initialA2Precise.mul(MAX_A_CHANGE),\n                \"futureA2_ is too large\"\n            );\n        }\n\n        self.initialA2 = initialA2Precise;\n        self.futureA2 = futureA2Precise;\n        self.initialA2Time = block.timestamp;\n        self.futureA2Time = futureTime_;\n\n        emit RampA2(\n            initialA2Precise,\n            futureA2Precise,\n            block.timestamp,\n            futureTime_\n        );\n    }\n\n    /**\n     * @notice Stops ramping Target price immediately. Once this function is called, rampTargetPrce()\n     * cannot be called for another 24 hours\n     * @param self TargetPrice struct to update\n     */\n    function stopRampTargetPrice(TargetPrice storage self) external returns (uint256) {\n        require(self.futureTargetPriceTime > block.timestamp, \"Ramp is already stopped\");\n        uint256 currentTargetPrice = _getTargetPricePrecise(self);\n\n        self.initialTargetPrice = currentTargetPrice;\n        self.futureTargetPrice = currentTargetPrice;\n        self.initialTargetPriceTime = block.timestamp;\n        self.futureTargetPriceTime = block.timestamp;\n\n        emit StopRampTargetPrice(currentTargetPrice, block.timestamp);\n\n        // change token multiplier to reflect new target price\n        return self.originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT);\n    }\n\n    /**\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\n     * cannot be called for another 24 hours\n     * @param self Swap struct to update\n     */\n    function stopRampA(Swap storage self) external {\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n        uint256 currentA = _getAPrecise(self);\n\n        self.initialA = currentA;\n        self.futureA = currentA;\n        self.initialATime = block.timestamp;\n        self.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n\n    /**\n     * @notice Stops ramping A2 immediately. Once this function is called, rampA2()\n     * cannot be called for another 24 hours\n     * @param self Swap struct to update\n     */\n    function stopRampA2(Swap storage self) external {\n        require(self.futureA2Time > block.timestamp, \"Ramp is already stopped\");\n        uint256 currentA2 = _getA2Precise(self);\n\n        self.initialA2 = currentA2;\n        self.futureA2 = currentA2;\n        self.initialA2Time = block.timestamp;\n        self.futureA2Time = block.timestamp;\n\n        emit StopRampA2(currentA2, block.timestamp);\n    }\n}\n\n\n",
        "CodeNames": [
            "SwapUtils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SwapUtils.sol#L1571-L1581",
                "Type": "Can not update target price",
                "Description": "The sanity checks in rampTargetPrice are broken. If futureTargetPricePrecise is smaller than initialTargetPricePrecise 0.01 of futureTargetPricePrecise would never larger than initialTargetPricePrecise. Admin would not be able to ramp the target price.",
                "Repair": "Update the require statements in rampTargetPrice function to allow the admin to ramp the target price."
            },
            {
                "Location": "SwapUtils.swap / _calculateSwap function",
                "Type": "Swaps are not split when trade crosses target price",
                "Description": "Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for the *entire trade*.",
                "Repair": "Split trades that cross the target price into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values"
            },
            {
                "Location": "SwapUtils.sol",
                "Type": "Wrong Implementation",
                "Description": "The tokenPrecisionMultipliers used in price calculation should be calculated in real-time based on initialTargetPrice, futureTargetPrice, futureTargetPriceTime and current time, just like getA() and getA2(). However, in the current implementation, tokenPrecisionMultipliers used in price calculation is the stored value, it will only be changed when the owner called rampTargetPrice() and stopRampTargetPrice().",
                "Repair": "Add Swap.targetPrice and change the _xp() function to calculate tokenPrecisionMultipliers in real-time based on initialTargetPrice, futureTargetPrice, futureTargetPriceTime and current time. "
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @summary: Forked & Modified Vether (vetherasset.io) contract for Public Sale\n * @author: Boot Finance\n */\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IERC721.sol\";\n\ninterface IVesting {\n   /**\n    * @dev Interface to vesting contract. 30% tokens are released instantly, 70% are locked.\n    * @param _beneficiary Beneficiary of the locked tokens.\n    * @param _amount Amount to be locked in vesting contract.\n    * @param _isRevocable Can the vesting be revoked? Only revocable for team, in case if someone leaves.\n    */\n   function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable;\n}\n\nlibrary SafeMath {\n    /**\n     * @dev SafeMath library\n     * @param a First variable\n     * @param b Second variable\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n}\n\ncontract BasicSale {\n    using SafeMath for uint;\n    IERC20 public mainToken;    //Address of the BOOT token\n    IERC721 public nft;         //Address of NFT contract, for first 4 weeks only NFT holders can access the sale\n    IVesting public vestLock;   //Address of the Vesting contract\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Public Parameters\n    uint public constant decimals = 18;\n    uint public constant coin = 10 ** decimals;\n    uint public constant secondsPerDay = 84200;\n    uint public constant firstEra = 1;\n\n    // project-specific multisig address where raised funds will be sent\n    \n    address deployer;\n    address payable burnAddress;\n\n    uint public genesis;\n    uint public daysPerEra;\n    uint public firstPublicEra;\n    uint public totalSupply;        // MainToken supply allocated to public sale\n    uint public remainingSupply;\n    uint public initialDayEmission;\n    uint public currentEra;\n    uint public currentDay;\n    uint public nextEraTime;\n    uint public nextDayTime;\n    uint public totalBurnt;\n    uint public totalEmitted;\n\n    // uncapped theoretical, public should use getDayEmission() instead\n    uint private emission;\n\n    // Public Mappings\n    mapping(uint => uint) public mapEra_Emission;                                             // Era->Emission\n    mapping(uint => mapping(uint => uint)) public mapEraDay_MemberCount;                      // Era,Days->MemberCount\n    mapping(uint => mapping(uint => address[])) public mapEraDay_Members;                     // Era,Days->Members\n    mapping(uint => mapping(uint => uint)) public mapEraDay_Units;                            // Era,Days->Units\n    mapping(uint => mapping(uint => uint)) public mapEraDay_UnitsRemaining;                   // Era,Days->TotalUnits\n    mapping(uint => mapping(uint => uint)) public mapEraDay_EmissionRemaining;                // Era,Days->Emission\n    mapping(uint => mapping(uint => mapping(address => uint))) public mapEraDay_MemberUnits;  // Era,Days,Member->Units\n    mapping(address => mapping(uint => uint[])) public mapMemberEra_Days;                     // Member,Era->Days[]\n\n    // Events\n    event NewEra(uint era, uint emission, uint time, uint totalBurnt);\n    event NewDay(uint era, uint day, uint time, uint previousDayTotal, uint previousDayMembers);\n    event Burn(address indexed payer, address indexed member, uint era, uint day, uint units, uint dailyTotal);\n    event Withdrawal(address indexed caller, address indexed member, uint era, uint day, uint value, uint vetherRemaining);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor(\n        IERC20 _mainToken,\n        IERC721 _nft,\n        IVesting _vestLock,\n        uint _daysPerEra,\n        uint _firstPublicEra,\n        uint _totalSupply,\n        uint _initialDayEmission,\n        address payable _burnAddress)\n    {\n        require(address(_mainToken) != address(0), \"Invalid ERC20 address\");\n        require(address(_nft) != address(0), \"Invalid ERC721 address\");\n        require(address(_vestLock) != address(0), \"Invalid Vesting address\");\n\n        mainToken = _mainToken;\n        nft = _nft;\n        vestLock = _vestLock;\n\n        genesis = block.timestamp;\n        currentEra = 1;\n        currentDay = 1;\n        totalBurnt = 0;\n        totalEmitted = 0;\n\n        daysPerEra = _daysPerEra;\n        firstPublicEra = _firstPublicEra;\n        totalSupply = _totalSupply;\n        initialDayEmission = _initialDayEmission;\n\n        emission = _initialDayEmission; // current day's theoretical emission regardless of actual supply\n        remainingSupply = _totalSupply; // remaining actual supply including for the current day\n\n        deployer = msg.sender;\n        burnAddress = _burnAddress;\n\n        nextEraTime = genesis + (secondsPerDay * daysPerEra);\n        nextDayTime = block.timestamp + secondsPerDay;                                       \n        mapEra_Emission[currentEra] = emission; \n        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; \n    }\n\n    // Any ETH sent is assumed to be for the token sale.\n    // Initially only accounts with the specific NFT may participate.\n    //\n    receive() external payable {\n        _updateEmission();\n        require(remainingSupply > 0, \"public sale has ended\");\n        if (currentEra < firstPublicEra) {\n            require(nft.balanceOf(msg.sender) > 0, \"You need NFT to participate in the sale.\");\n        }\n        burnAddress.call{value: msg.value}(\"\");\n        _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);\n    }\n\n    function burnEtherForMember(address member) external payable {\n        _updateEmission();\n        require(remainingSupply > 0, \"public sale has ended\");\n        if (currentEra < firstPublicEra) {\n            require(nft.balanceOf(member) > 0, \"Member needs NFT to participate in the sale.\");\n        }\n        burnAddress.call{value: msg.value}(\"\");\n        _recordBurn(msg.sender, member, currentEra, currentDay, msg.value);\n    }\n\n    // Internal - Records burn\n    function _recordBurn(address _payer, address _member, uint _era, uint _day, uint _eth) private {\n        if (mapEraDay_MemberUnits[_era][_day][_member] == 0) {                              // If hasn't contributed to this Day yet\n            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it\n            mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member\n            mapEraDay_Members[_era][_day].push(_member);                                    // Add member\n        }\n        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share\n        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals\n        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding\n        totalBurnt += _eth;                                                                 // Add to total burnt\n        emit Burn(_payer, _member, _era, _day, _eth, mapEraDay_Units[_era][_day]);          // Burn event\n    }\n\n    // efficiently tracks participation in each era\n    function getDaysContributedForEra(address member, uint era) public view returns(uint) {\n        return mapMemberEra_Days[member][era].length;\n    }\n\n    function withdrawShare(uint era, uint day) external returns (uint value) {\n        require(era >= 1, \"era must be >= 1\");\n        require(day >= 1, \"day must be >= 1\");\n        require(day <= daysPerEra, \"day must be <= daysPerEra\");\n        return _withdrawShare(era, day, msg.sender);                           \n    }\n\n    function withdrawShareForMember(uint era, uint day, address member) external returns (uint value) {\n        require(era >= 1, \"era must be >= 1\");\n        require(day >= 1, \"day must be >= 1\");\n        require(day <= daysPerEra, \"day must be <= daysPerEra\");\n        return _withdrawShare(era, day, member);\n    }\n\n    function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {\n        _updateEmission();\n        if (_era < currentEra) {                                      // Allow if in previous Era\n            value = _processWithdrawal(_era, _day, _member);          // Process Withdrawal\n        }\n        else if (_era == currentEra && _day < currentDay) {           // Allow if in current Era and previous Day\n            value = _processWithdrawal(_era, _day, _member);          // Process Withdrawal    \n        }  \n        return value;\n    }\n\n    function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {\n        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member]; // Get Member Units\n        if (memberUnits == 0) { \n            value = 0;                                                 // Do nothing if 0 (prevents revert)\n        }\n        else {\n            value = getEmissionShare(_era, _day, _member);             // Get the emission Share for Member\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;            // Set to 0 since it will be withdrawn\n            mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units\n            mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission\n            totalEmitted += value;                                     // Add to Total Emitted\n            uint256 v_value = value * 3 / 10;                          // Transfer 30%, lock the rest in vesting contract             \n            mainToken.transfer(_member, v_value);                      // ERC20 transfer function\n            vestLock.vest(_member, value - v_value, 0);\n            emit Withdrawal(msg.sender, _member, _era, _day, value, mapEraDay_EmissionRemaining[_era][_day]);\n        }\n        return value;\n    }\n\n    function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {\n        uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units\n        if (memberUnits == 0) {\n            return 0;                                                                       // If 0, return 0\n        }\n        else {\n            uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units\n            uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];                 // Get emission remaining for Day\n            uint balance = mainToken.balanceOf(address(this));\n            if (emissionRemaining > balance) {\n                emissionRemaining = balance;                                                // In case less than required emission\n            }\n            return (emissionRemaining * memberUnits) / totalUnits;                          // Calculate share\n        }\n    }\n    \n    function _updateEmission() private {\n        uint _now = block.timestamp;                                                        // Find now()\n        if (_now >= nextDayTime) {                                                          // If time passed the next Day time\n            if (remainingSupply > emission) {\n                remainingSupply -= emission;\n            }\n            else {\n                remainingSupply = 0;\n            }\n            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time\n                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day\n                nextEraTime = _now + (secondsPerDay * daysPerEra);                          // Set next Era time\n                emission = getNextEraEmission();                                            // Get correct emission\n                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era\n                emit NewEra(currentEra, emission, nextEraTime, totalBurnt);                 // Emit Event\n            }\n            currentDay += 1;                                                                // Increment Day\n            nextDayTime = _now + secondsPerDay;                                             // Set next Day time\n            emission = getDayEmission();                                                    // Check daily Dmission\n            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day\n            uint _era = currentEra;\n            uint _day = currentDay - 1;\n            if (currentDay == 1) {\n                // new era\n                _era = currentEra - 1;\n                _day = daysPerEra;\n            }\n            emit NewDay(currentEra, currentDay, nextDayTime, mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);\n        }\n    }\n\n    function updateEmission() external {\n        _updateEmission();\n    }\n\n    function getNextEraEmission() public view returns (uint) {\n        if (emission > coin) {                                          // Normal Emission Schedule\n            return emission.mul(988311938981777).div(1000000000000000); // Emissions: 2048 -> 1.0\n        }\n        else {                                                          // Enters Fee Era\n            return coin;                                                // Return 1.0 from fees\n        }\n    }\n\n    function getDayEmission() public view returns (uint) {\n        if (remainingSupply > emission) {\n            return emission;\n        }\n        else {\n            return remainingSupply;\n        }\n    }\n}\n\ncontract PublicSale is BasicSale {\n    constructor(IERC20 _mainToken, IERC721 _nft, IVesting _vestLock) \n\n        BasicSale(_mainToken, _nft, _vestLock,\n\n            7, // daysPerEra\n            5, // firstPublicEra\n\n            21_180_364_000000000000000000, // totalSupply\n                37_111_000000000000000000, // initialDayEmission\n\n            payable(address(0x03Df4ADDfB568b338f6a0266f30458045bbEFbF2)))\n    {}\n}\n\n\n",
        "CodeNames": [
            "PublicSale.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PublicSale.sol#148-156, PublicSale.sol#158-166",
                "Type": "Unchecked low-level calls",
                "Description": "The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.",
                "Repair": "Check the return value of the low-level call or log failed calls."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @summary: Vesting contract that serves as an escrow for tokens to be locked (70% of all allocations)\n * @author: Boot Finance\n */\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\n\n/// @title Vesting Contract\n/// @dev Any address can vest tokens into this contract with amount, releaseTimestamp, revocable.\n///      Anyone can claim tokens (if unlocked as per the schedule).\n\ncontract Vesting is Ownable, Pausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // State variables===================================================================================\n    IERC20 public vestingToken;\n    address public multiSig;\n\n    // uint256 public maxVestingAmount;\n    uint256 public totalVestedAmount;\n    uint256 public totalClaimedAmount;\n    uint256 private unixYear = 52 * 7 * 24 * 60 * 60;\n\n    struct Timelock {\n        uint256 amount;\n        uint256 releaseTimestamp;\n    }\n\n    mapping(address => Timelock[]) public timelocks;\n    mapping(address => uint256) public benClaimed;      //total tokens claimed\n    mapping(address => uint256[2]) public benVested;       //total tokens vested\n    mapping(address => uint256) public benTotal;        //total locked in contract for user\n    mapping(address => uint256) public benVestingIndex;     //index to start the for loop for the user ignoring completely vested timelock\n\n    // map revocability at address level vs individual timelock\n    mapping(address => bool[2]) public benRevocable;         // key: beneficiary address, value: revokeTimestamp\n\n    // ===============EVENTS============================================================================================\n    event TokenVested(address indexed sender, uint256 amount, uint256 releaseTimestamp, uint256 currentTimestamp);\n    event TokenClaimed(address indexed beneficiary, uint256 amount, uint256 currentTimestamp);\n    event TokenRevoked(address indexed beneficiary, uint256 amount, uint256 currentTimestamp);\n    event Revoke(address indexed account, uint256 currentTimestamp);\n\n    //================CONSTRUCTOR================================================================\n    /// @notice Constructor\n    /// @param _token ERC20 token\n    constructor(\n        IERC20 _token,\n        address _multiSig\n    ) {\n        require(address(_token) != address(0) && address(_multiSig) != address(0), \"Invalid address\");\n        vestingToken = _token;\n        multiSig = _multiSig;\n\n        totalVestedAmount = 0;\n        totalClaimedAmount = 0;\n    }\n    \n\n    //=================FUNCTIONS=================================================================\n    /// @notice Vest function accessed by anyone\n    /// @param _beneficiary beneficiary address\n    /// @param _amount vesting amount\n    /// @param _isRevocable revocable value either 0 or 1\n    function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {\n        require(_beneficiary != address(0), \"Invalid address\");\n        require( _amount > 0, \"amount must be positive\");\n        // require(totalVestedAmount.add(_amount) <= maxVestingAmount, 'maxVestingAmount is already vested');\n        require(_isRevocable == 0 || _isRevocable == 1, \"revocable must be 0 or 1\");\n        uint256 _unlockTimestamp = block.timestamp.add(unixYear);\n\n        Timelock memory newVesting = Timelock(_amount, _unlockTimestamp);\n        timelocks[_beneficiary].push(newVesting);\n\n        if(_isRevocable == 0){\n            benRevocable[_beneficiary] = [false,false];\n        }\n        else if(_isRevocable == 1){\n            benRevocable[_beneficiary] = [true,false];\n        }\n\n        totalVestedAmount = totalVestedAmount.add(_amount);\n        benTotal[_beneficiary] = benTotal[_beneficiary].add(_amount);\n\n        // transfer to SC using delegate transfer\n        // NOTE: the tokens has to be approved first by the caller to the SC using `approve()` method.\n        vestingToken.transferFrom(msg.sender, address(this), _amount);\n\n        emit TokenVested(_beneficiary, _amount, _unlockTimestamp, block.timestamp);\n    }\n\n    // ------------------------------------------------------------------------------------------\n    /// @notice Revoke vesting\n    /// @param _addr beneficiary address\n\n    function revoke(address _addr) public onlyOwner whenNotPaused {\n        require(benRevocable[_addr][0] == true && benRevocable[_addr][1] == false, 'Account must be revokable and not already revoked.');\n\n        uint256 amount = _claimableAmount(_addr).sub(benClaimed[_addr]);\n        assert(amount <= benTotal[_addr]);\n    \n        benClaimed[_addr] = benClaimed[_addr].add(amount);\n        totalClaimedAmount = totalClaimedAmount.add(amount);\n\n        emit TokenClaimed(_addr, amount, block.timestamp);\n\n        uint256 locked = 0;\n        for (uint256 i = 0; i < timelocks[_addr].length; i++) {\n            locked = locked.add(timelocks[_addr][i].amount);\n        }\n        delete timelocks[_addr];\n\n        uint256 bal = locked.sub(benClaimed[_addr]);\n        benRevocable[_addr][1] = true;\n        emit Revoke(_addr, block.timestamp);\n        \n        //clean slate\n        benClaimed[_addr] = 0;\n        benVested[_addr] = [0, 0];\n        benTotal[_addr] = 0;\n        benVestingIndex[_addr] = 0;\n        \n        vestingToken.safeTransfer(_addr, amount); //send vested\n\n        if (bal > 0) {\n            vestingToken.safeTransfer(multiSig, bal); //send revoked to multisig\n            emit TokenRevoked(_addr, bal, block.timestamp);\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------\n    /// @notice Calculate claimable amount for a beneficiary\n    /// @param _addr beneficiary address\n    function calcClaimableAmount(address _addr) public view returns (uint256) {\n        uint256 sum = 0;\n\n        // iterate across all the vestings\n        // & check if the releaseTimestamp is elapsed\n        // then, add all the amounts as claimable amount\n        for (uint256 i = 0; i < timelocks[_addr].length; i++) {\n            if (block.timestamp >= timelocks[_addr][i].releaseTimestamp) {\n                sum = sum.add(timelocks[_addr][i].amount);\n            }\n            else {\n                uint256 iTimeStamp = timelocks[_addr][i].releaseTimestamp.sub(unixYear);\n                uint256 claimable = block.timestamp.sub(iTimeStamp).mul(timelocks[_addr][i].amount).div(unixYear);\n                sum = sum.add(claimable);\n            }\n        }\n        return sum;\n    }\n    \n    //Calculate amount claimable by a particular address\n    function _claimableAmount(address _addr) private returns (uint256) {\n        uint256 completely_vested = 0;\n        uint256 partial_sum = 0;\n        uint256 inc = 0;\n\n        // iterate across all the vestings\n        // & check if the releaseTimestamp is elapsed\n        // then, add all the amounts as claimable amount\n        for (uint256 i = benVestingIndex[_addr]; i < timelocks[_addr].length; i++) {\n            if (block.timestamp >= timelocks[_addr][i].releaseTimestamp) {\n                inc += 1;\n                completely_vested = completely_vested.add(timelocks[_addr][i].amount);\n            }\n            else {\n                uint256 iTimeStamp = timelocks[_addr][i].releaseTimestamp.sub(unixYear);\n                uint256 claimable = block.timestamp.sub(iTimeStamp).mul(timelocks[_addr][i].amount).div(unixYear);\n                partial_sum = partial_sum.add(claimable);\n            }\n        }\n\n        benVestingIndex[_addr] +=inc;\n        benVested[_addr][0] = benVested[_addr][0].add(completely_vested);\n        benVested[_addr][1] = partial_sum;\n        uint256 s = benVested[_addr][0].add(partial_sum);\n        assert(s <= benTotal[_addr]);\n        return s;\n    }\n\n    // ------------------------------------------------------------------------------------------\n    /// @notice Claim vesting\n    /// Beneficiary can claim claimableAmount which was vested\n    function claim() external whenNotPaused nonReentrant {\n        require(benRevocable[msg.sender][1] == false, 'Account must not already be revoked.');\n        uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);\n        require(amount > 0, \"Claimable amount must be positive\");\n        require(amount <= benTotal[msg.sender], \"Cannot withdraw more than total vested amount\");\n\n        // transfer from SC\n        benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);\n        totalClaimedAmount = totalClaimedAmount.add(amount);\n        vestingToken.safeTransfer(msg.sender, amount);\n\n        emit TokenClaimed(msg.sender, amount, block.timestamp);\n    }\n\n    // ------------------------------------------------------------------------------------------\n    /// @notice Pause contract \n    function pause() public onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /// @notice Unpause contract\n    function unpause() public onlyOwner whenPaused {\n        _unpause();\n    }\n}\n\n",
        "CodeNames": [
            "Vesting.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Vesting.sol#L73-L98",
                "Type": "Overwrite benRevocable",
                "Description": "Anyone can call the function vest() of Vesting.sol, for example with a small _amount of tokens, for any _beneficiary. The function overwrites the value of benRevocable[_beneficiary], effectively erasing any previous value. So you can set any _beneficiary to Revocable. Although revoke() is only callable by the owner, this is circumventing the entire mechanism of benRevocable.",
                "Repair": "Whitelist the calling of vest() or check if values for benRevocable are already set."
            },
            {
                "Location": "Vesting.sol",
                "Type": "Unbounded Timelock Loop",
                "Description": "The timelocks for any beneficiary are unbounded, and can be vested by someone who is not the beneficiary. When the array becomes significantly big enough, the vestments will no longer be claimable for the beneficiary.",
                "Repair": "Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments. Restrict the vestment contribution of a beneficiary where require(beneficiary == msg.sender)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ISwap.sol\";\n\n/**\n * @title Liquidity Provider Token\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\n * It is used to represent user's shares when providing liquidity to swap contracts.\n */\ncontract LPToken is ERC20Burnable, Ownable {\n    using SafeMath for uint256;\n\n    // Address of the swap contract that owns this LP token. When a user adds liquidity to the swap contract,\n    // they receive a proportionate amount of this LPToken.\n    ISwap public swap;\n\n    // Maps user account to total number of LPToken minted by them. Used to limit minting during guarded release phase\n    mapping(address => uint256) public mintedAmounts;\n\n    /**\n     * @notice Deploys LPToken contract with given name, symbol, and decimals\n     * @dev the caller of this constructor will become the owner of this contract\n     * @param name_ name of this token\n     * @param symbol_ symbol of this token\n     * @param decimals_ number of decimals this token will be based on\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public ERC20(name_, symbol_) {\n        _setupDecimals(decimals_);\n        swap = ISwap(_msgSender());\n    }\n\n    /**\n     * @notice Mints the given amount of LPToken to the recipient. During the guarded release phase, the total supply\n     * and the maximum number of the tokens that a single account can mint are limited.\n     * @dev only owner can call this mint function\n     * @param recipient address of account to receive the tokens\n     * @param amount amount of tokens to mint\n     */\n    function mint(\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        require(amount != 0, \"amount == 0\");\n\n        // If the pool is in the guarded launch phase, the following checks are done to restrict deposits.\n        //   1. Check if the given merkleProof corresponds to the recipient's address in the merkle tree stored in the\n        //      allowlist contract. If the account has been already verified, merkleProof is ignored.\n        //   2. Limit the total number of this LPToken minted to recipient as defined by the allowlist contract.\n        //   3. Limit the total supply of this LPToken as defined by the allowlist contract.\n        // if (swap.isGuarded()) {\n        //     // IAllowlist allowlist = swap.getAllowlist();\n        //     // require(\n        //     //     allowlist.verifyAddress(recipient, merkleProof),\n        //     //     \"Invalid merkle proof\"\n        //     // );\n        //     uint256 totalMinted = mintedAmounts[recipient].add(amount);\n        //     require(\n        //         totalMinted <= allowlist.getPoolAccountLimit(address(swap)),\n        //         \"account deposit limit\"\n        //     );\n        //     require(\n        //         totalSupply().add(amount) <=\n        //             allowlist.getPoolCap(address(swap)),\n        //         \"pool total supply limit\"\n        //     );\n        //     mintedAmounts[recipient] = totalMinted;\n        // }\n        uint256 totalMinted = mintedAmounts[recipient].add(amount);\n        mintedAmounts[recipient] = totalMinted;\n        _mint(recipient, amount);\n    }\n\n    /**\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\n     * minting and burning. This ensures that swap.updateUserWithdrawFees are called everytime.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20) {\n        super._beforeTokenTransfer(from, to, amount);\n        swap.updateUserWithdrawFee(to, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "LPToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LPToken.set_minter()",
                "Type": "Failure to Check Input Value",
                "Description": "The function LPToken.set_minter() doesn't check that _minter doesn't equal zero before it sets it as the new minter. This function can be invoked by mistake with the zero address as _minter, causing the system to lose its minter forever, without the option to set a new minter.",
                "Repair": "Check that _minter doesn't equal zero before setting it as the new minter."
            }
        ]
    }
]