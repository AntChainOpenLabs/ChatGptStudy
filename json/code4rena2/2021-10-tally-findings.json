[
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport \"../governance/EmergencyPausable.sol\";\nimport \"../utils/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Swap is EmergencyPausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    /// @notice An address to receive swap fees. The 0 address prevents fee\n    ///         withdrawal.\n    address payable public feeRecipient;\n    /// @notice divide by the SWAP_FEE_DIVISOR to get the fee ratio, deducted\n    ///         from the proceeds of each swap.\n    uint256 public swapFee;\n    uint256 public constant SWAP_FEE_DIVISOR = 100_000;\n\n    event SwappedTokens(\n        address tokenSold,\n        address tokenBought,\n        uint256 amountSold,\n        uint256 amountBought,\n        uint256 amountBoughtFee\n    );\n\n    event NewSwapFee(\n        uint256 newSwapFee\n    );\n\n    event NewFeeRecipient(\n        address newFeeRecipient\n    );\n\n    event FeesSwept(\n        address token,\n        uint256 amount,\n        address recipient\n    );\n\n    /// @param owner_ A new contract owner, expected to implement\n    ///               TimelockGovernorWithEmergencyGovernance.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal, and can be set later by\n    ///        governance.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee\n    ///                 ratio charged for each swap.\n    constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {\n        require(owner_ != address(0), \"Swap::constructor: Owner must not be 0\");\n        transferOwnership(owner_);\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the fee taken from each swap's proceeds.\n    /// @dev Only timelocked governance can set the swap fee.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee ratio.\n    function setSwapFee(uint256 swapFee_) external onlyTimelock {\n        require(swapFee_ < SWAP_FEE_DIVISOR, \"Swap::setSwapFee: Swap fee must not exceed 100%\");\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the address permitted to receive swap fees.\n    /// @dev Only timelocked governance can set the fee recipient.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal.\n    function setFeeRecipient(address payable feeRecipient_) external onlyTimelock {\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n    }\n\n    /// @notice Swap by filling a 0x quote.\n    /// @dev Execute a swap by filling a 0x quote, as provided by the 0x API.\n    ///      Charges a governable swap fee that comes out of the bought asset,\n    ///      be it token or ETH. Unfortunately, the fee is also charged on any\n    ///      refunded ETH from 0x protocol fees due to an implementation oddity.\n    ///      This behavior shouldn't impact most users.\n    ///\n    ///      Learn more about the 0x API and quotes at https://0x.org/docs/api\n    /// @param zrxSellTokenAddress The contract address of the token to be sold,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. If selling\n    ///        unwrapped ETH included via msg.value, this should be address(0)\n    /// @param amountToSell Amount of token to sell, with the same precision as\n    ///        zrxSellTokenAddress. This information is also encoded in zrxData.\n    ///        If selling unwrapped ETH via msg.value, this should be 0.\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. To buy\n    ///        unwrapped ETH, use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    /// @param minimumAmountReceived The minimum amount expected to be received\n    ///        from filling the quote, before the swap fee is deducted, in\n    ///        zrxBuyTokenAddress. Reverts if not met\n    /// @param zrxAllowanceTarget Contract address that needs to be approved for\n    ///        zrxSellTokenAddress, as returned by the 0x `/swap/v1/quote` API\n    ///        endpoint. Should be address(0) for purchases uses unwrapped ETH\n    /// @param zrxTo Contract to fill the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param zrxData Data encoding the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param deadline Timestamp after which the swap will be reverted.\n    function swapByQuote(\n        address zrxSellTokenAddress,\n        uint256 amountToSell,\n        address zrxBuyTokenAddress,\n        uint256 minimumAmountReceived,\n        address zrxAllowanceTarget,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 deadline\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            block.timestamp <= deadline,\n            \"Swap::swapByQuote: Deadline exceeded\"\n        );\n        require(\n            !signifiesETHOrZero(zrxSellTokenAddress) || msg.value > 0,\n            \"Swap::swapByQuote: Unwrapped ETH must be swapped via msg.value\"\n        );\n\n        // if zrxAllowanceTarget is 0, this is an ETH sale\n        if (zrxAllowanceTarget != address(0)) {\n            // transfer tokens to this contract\n            IERC20(zrxSellTokenAddress).safeTransferFrom(msg.sender, address(this), amountToSell);\n            // approve token transfer to 0x contracts\n            // TODO (handle approval special cases like USDT, KNC, etc)\n            IERC20(zrxSellTokenAddress).safeIncreaseAllowance(zrxAllowanceTarget, amountToSell);\n        }\n\n        // execute 0x quote\n        (uint256 boughtERC20Amount, uint256 boughtETHAmount) = fillZrxQuote(\n            IERC20(zrxBuyTokenAddress),\n            zrxTo,\n            zrxData,\n            msg.value\n        );\n\n        require(\n            (\n                !signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtERC20Amount >= minimumAmountReceived\n            ) ||\n            (\n                signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtETHAmount >= minimumAmountReceived\n            ),\n            \"Swap::swapByQuote: Minimum swap proceeds requirement not met\"\n        );\n        if (boughtERC20Amount > 0) {\n            // take the swap fee from the ERC20 proceeds and return the rest\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n            IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n            // return any refunded ETH\n            payable(msg.sender).transfer(boughtETHAmount);\n\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtERC20Amount,\n                boughtERC20Amount.sub(toTransfer)\n            );\n        } else {\n\n            // take the swap fee from the ETH proceeds and return the rest. Note\n            // that if any 0x protocol fee is refunded in ETH, it also suffers\n            // the swap fee tax\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n            payable(msg.sender).transfer(toTransfer);\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtETHAmount,\n                boughtETHAmount.sub(toTransfer)\n            );\n        }\n        if (zrxAllowanceTarget != address(0)) {\n            // remove any dangling token allowance\n            IERC20(zrxSellTokenAddress).safeApprove(zrxAllowanceTarget, 0);\n        }\n    }\n\n    /// @notice Fill a 0x quote as provided by the API, and return any ETH or\n    ///         ERC20 proceeds.\n    /// @dev Learn more at https://0x.org/docs/api\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as provided by the 0x API. `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    ///        signifies the user is buying unwrapped ETH.\n    /// @param zrxTo Contract to fill the 0x quote, as provided by the 0x API\n    /// @param zrxData Data encoding the 0x quote, as provided by the 0x API\n    /// @param ethAmount The amount of ETH required to fill the quote, including\n    ///        any ETH being traded as well as protocol fees\n    /// @return any positive `zrxBuyTokenAddress` ERC20 balance change, as well\n    ///         as any positive ETH balance change\n    function fillZrxQuote(\n        IERC20 zrxBuyTokenAddress,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 ethAmount\n    ) internal returns (uint256, uint256) {\n        uint256 originalERC20Balance = 0;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n        }\n        uint256 originalETHBalance = address(this).balance;\n\n        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n        require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n        uint256 erc20Delta;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n            require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n        } else {\n            require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n        }\n\n        return (erc20Delta, ethDelta);\n    }\n\n    /// @notice Test whether an address is zero, or the magic address the 0x\n    ///         platform uses to signify \"unwrapped ETH\" rather than an ERC20.\n    /// @param tokenAddress An address that might point toward an ERC-20.\n    function signifiesETHOrZero(address tokenAddress) internal pure returns (bool) {\n        return (\n            tokenAddress == address(0) ||\n            tokenAddress == address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)\n        );\n    }\n\n    /// @notice Sweeps accrued ETH and ERC20 swap fees to the pre-established\n    ///         fee recipient address.\n    /// @dev Fees are tracked based on the contract's balances, rather than\n    ///      using any additional bookkeeping. If there are bugs in swap\n    ///      accounting, this function could jeopardize funds.\n    /// @param tokens An array of ERC20 contracts to withdraw token fees\n    function sweepFees(\n        address[] calldata tokens\n    ) external nonReentrant {\n        require(\n            feeRecipient != address(0),\n            \"Swap::withdrawAccruedFees: feeRecipient is not initialized\"\n        );\n        for (uint8 i = 0; i<tokens.length; i++) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(tokens[i]).safeTransfer(feeRecipient, balance);\n                emit FeesSwept(tokens[i], balance, feeRecipient);\n            }\n        }\n        feeRecipient.transfer(address(this).balance);\n        emit FeesSwept(address(0), address(this).balance, feeRecipient);\n    }\n\n    fallback() external payable {}\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "Swap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "fillZrxQuote() function in Swap.sol at L200-L212",
                "Type": "Arbitrary contract call",
                "Description": "An arbitrary contract call allows attackers to steal ERC20 from users' wallets.",
                "Repair": "Consider adding a whitelist for zrxTo addresses"
            },
            {
                "Location": "fillZrxQuote() function in Swap.sol at L200-L225",
                "Type": "Wrong calculation",
                "Description": "Wrong calculation of erc20Delta and ethDelta can result in users losing assets that they will never be able to recover.",
                "Repair": "Subtract the input amount from the originalBalance"
            },
            {
                "Location": "Swap.swapByQuote() function in Swap.sol",
                "Type": "Avoiding fees",
                "Description": "Users can execute ETH swap without paying swap fees for the ETH they got from the swap.",
                "Repair": "Charge swap fees for the 'refunded ETH' on ERC20 swaps (when boughtERC20Amount > 0), or require boughtETHAmount == 0"
            },
            {
                "Location": "fillZrxQuote() function in Swap.sol at L153-L181",
                "Type": "Unused token",
                "Description": "Unused ERC20 tokens are not refunded, and may be left in the contract unintentionally.",
                "Repair": "Return unused ERC20 tokens"
            },
            {
                "Location": "Swap.sol contract, lines 158, 173, and 257",
                "Type": "Potentially dangerous transfer",
                "Description": "The use of transfer() in Swap.sol may have unintended outcomes on the eth being sent to the receiver. Eth may be irretrievable or undelivered if the msg.sender or feeRecipient is a smart contract. Funds can potentially be lost if;1. The smart contract fails to implement the payable fallback function2. The fallback function uses more than 2300 gas units",
                "Repair": "Using a re-entrancy guard and relying on msg.sender.call.value(amount) or using the OpenZeppelin Address.sendValue library"
            }
        ]
    }
]