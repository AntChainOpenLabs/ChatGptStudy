[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MIMOAutomatedRebalnce.sol#rebalance",
                "Type": "Vault rebalancing exploit",
                "Description": "Vault rebalancing can be exploited if two vaults rebalance into the same vault",
                "Repair": "Add nonReentrant modifier to MIMOAutomatedRebalnce.sol#rebalance"
            },
            {
                "Location": "MIMOProxyRegistry#deployFor function",
                "Type": "Proxy contract vulnerability",
                "Description": "If a MIMOProxy owner destroys their proxy by delegatecalling a target that calls selfdestruct, they cannot deploy another from the same address.",
                "Repair": "Check whether the proxy has been destroyed as part of the 'proxy already exists' conditions. If the proxy address has a codesize of zero, it has been destroyed."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./interfaces/IMIMOProxyRegistry.sol\";\nimport \"../core/interfaces/IAddressProvider.sol\";\nimport \"../core/interfaces/IAccessController.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxyRegistry\ncontract MIMOProxyRegistry is IMIMOProxyRegistry {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  IMIMOProxyFactory public override factory;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Internal mapping of owners to current proxies.\n  mapping(address => IMIMOProxy) internal _currentProxies;\n\n  /// CONSTRUCTOR ///\n\n  /// @param factory_ The base contract of the factory\n  constructor(IMIMOProxyFactory factory_) {\n    factory = factory_;\n  }\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function getCurrentProxy(address owner) external view override returns (IMIMOProxy proxy) {\n    proxy = _currentProxies[owner];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function deploy() external override returns (IMIMOProxy proxy) {\n    proxy = deployFor(msg.sender);\n  }\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n    IMIMOProxy currentProxy = _currentProxies[owner];\n\n    // Do not deploy if the proxy already exists and the owner is the same.\n    if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {\n      revert CustomErrors.PROXY_ALREADY_EXISTS(owner);\n    }\n\n    // Deploy the proxy via the factory.\n    proxy = factory.deployFor(owner);\n\n    // Set or override the current proxy for the owner.\n    _currentProxies[owner] = IMIMOProxy(proxy);\n  }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOProxyRegistry.sol",
            "MIMOProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MIMOProxy and MIMOProxyRegistry",
                "Type": "Unexpected ownership behavior",
                "Description": "Registry.sol fails to deliver expected functionality",
                "Repair": "Remove the owner state variable and transferOwner function from MIMOProxy. Remove MIMOProxyRegistry altogether and move its functionality to MIMOProxyFactory. Store ownership data only in MIMOProxyFactory, and all ownership transfers must now be performed by calling MIMOProxyFactory#transferOwnership rather than interacting with MIMOProxy."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOAutoAction.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOAutoAction is IMIMOAutoAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => AutomatedVault) internal _automatedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault automation parameters\n    @dev Can only be called by vault owner\n    @param vaultId Vault id of the vault to be automated\n    @param autoParams AutomatedVault struct containing all automation parameters\n   */\n  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n\n    uint256 toVaultMcr = a.config().collateralMinCollateralRatio(autoParams.toCollateral);\n    uint256 maxVarFee = (autoParams.targetRatio.wadDiv(toVaultMcr + autoParams.mcrBuffer) + WadRayMath.WAD).wadDiv(\n      autoParams.targetRatio\n    );\n\n    if (autoParams.varFee >= maxVarFee) {\n      revert CustomErrors.VARIABLE_FEE_TOO_HIGH(maxVarFee, autoParams.varFee);\n    }\n\n    _automatedVaults[vaultId] = autoParams;\n\n    emit AutomationSet(vaultId, autoParams);\n  }\n\n  /**\n    @return AutomatedVault struct of a specific vault id\n   */\n  function getAutomatedVault(uint256 vaultId) external view override returns (AutomatedVault memory) {\n    return _automatedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @notice Helper function calculating a vault's net value and LTV ratio\n    @param vaultId Vault id of the vault for which to return info\n    @return vaultRatio Vault collateral value / vault debt\n    @return vaultState VaultState struct of the target vault\n   */\n  function _getVaultStats(uint256 vaultId) internal view returns (uint256 vaultRatio, VaultState memory vaultState) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n    vaultRatio = vaultDebt == 0 ? type(uint256).max : collateralValue.wadDiv(vaultDebt);\n\n    vaultState = VaultState({ collateralType: collateralType, collateralValue: collateralValue, vaultDebt: vaultDebt });\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > autoVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOManagedAction.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOManagedAction is IMIMOManagedAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => ManagedVault) internal _managedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n  mapping(address => bool) internal _managers;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault management parameters\n    @dev Can only be called by vault owner and can only appoint whitelisting managers as manger\n    @param vaultId Vault id of the vault to be put under management\n    @param mgtParams ManagedVault struct containing all management parameters\n   */\n  function setManagement(uint256 vaultId, ManagedVault calldata mgtParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n    if (!_managers[mgtParams.manager]) {\n      revert CustomErrors.MANAGER_NOT_LISTED();\n    }\n\n    _managedVaults[vaultId] = mgtParams;\n\n    emit ManagementSet(vaultId, mgtParams);\n  }\n\n  /**\n    @notice Whitelists or removes a manager\n    @dev Can only be called by protocol manager\n    @param manager Manager address\n    @param isManager Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function setManager(address manager, bool isManager) external override {\n    IAccessController controller = a.controller();\n\n    if (!controller.hasRole(controller.MANAGER_ROLE(), msg.sender)) {\n      revert CustomErrors.CALLER_NOT_PROTOCOL_MANAGER();\n    }\n\n    _managers[manager] = isManager;\n\n    emit ManagerSet(manager, isManager);\n  }\n\n  /**\n    @return ManagedVault struct of a specific vault id\n   */\n  function getManagedVault(uint256 vaultId) external view override returns (ManagedVault memory) {\n    return _managedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @return Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function getManager(address manager) external view override returns (bool) {\n    return _managers[manager];\n  }\n\n  /**\n    @notice Helper function calculating LTV ratio\n    @return Vault collateral value / vault debt\n   */\n  function _getVaultRatio(uint256 vaultId) internal view returns (uint256) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n\n    if (vaultDebt == 0) {\n      return (type(uint256).max);\n    }\n\n    uint256 vaultRatio = collateralValue.wadDiv(vaultDebt);\n\n    return (vaultRatio);\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    ManagedVault memory managedVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > managedVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOAutoAction.sol",
            "MIMOManagedAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MIMOAutoAction.sol and MIMOManagedAction.sol",
                "Type": "Automation / management can be set for not yet existing vault",
                "Description": "An attacker can exploit this by setting very high fees before the creation of the vault and then performing actions for the automated vault, which leads to a loss of funds for the user.",
                "Repair": "Check that vaultOwner != address(0) before setting automation parameters for a vault ID that does not exist yet"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOEmptyVault.sol\";\nimport \"./MIMOFlashloan.sol\";\nimport \"./MIMOSwap.sol\";\n\n/**\n  @title A SuperVault V2 action contract for repaying an existing vault's debt and withdrawing all collateral without any additional capital.\n  @notice Should only be accessed through a MIMOProxy delegateCall\n */\ncontract MIMOEmptyVault is MIMOSwap, MIMOFlashloan, IMIMOEmtpyVault {\n  using SafeERC20 for IERC20;\n\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol\n    @param _dexAP The dexAddressProvider for the MIMO protocol\n    @param _lendingPool The AAVE lending pool used for flashloans\n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control\n   */\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry\n  ) MIMOFlashloan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Should be called by MIMOProxy through a delegatecall \n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing vaultId, FlashloanData struct, RebalanceData struct, SwapData struct\n   */\n  function executeAction(bytes calldata _calldata) external override {\n    (uint256 vaultId, FlashLoanData memory flData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (uint256, FlashLoanData, SwapData)\n    );\n    bytes memory params = abi.encode(msg.sender, vaultId, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes an emptyVault operation after taking a flashloan  \n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the target vault asset\n    @param amounts Uint array with one element corresponding to the amount of the target vault asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, target vault id, SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n    IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner));\n\n    if (initiator != address(mimoProxy)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 vaultCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    vaultCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amount + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"emptyVaultOperation(address,uint256,uint256,(uint256,bytes))\",\n        vaultCollateral,\n        vaultId,\n        amount,\n        swapData\n      )\n    );\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform rebalance logic within MIMOProxy context\n    @notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n    @param vaultCollateral Collateral of the vault to empty\n    @param vaultId vault id of the vault to be emptied\n    @param swapAmount Amount of collateral to swap to for par to repay vaultdebt\n    @param swapData SwapData passed from the flashloan call\n   */\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 vaultId,\n    uint256 swapAmount,\n    SwapData calldata swapData\n  ) external {\n    IVaultsCore core = a.core();\n\n    _aggregatorSwap(vaultCollateral, swapAmount, swapData);\n\n    IERC20 stablex = IERC20(a.stablex());\n    stablex.safeIncreaseAllowance(address(core), stablex.balanceOf(address(this)));\n    core.repayAll(vaultId);\n\n    uint256 withdrawAmount = a.vaultsData().vaultCollateralBalance(vaultId);\n\n    core.withdraw(vaultId, withdrawAmount);\n    vaultCollateral.safeTransfer(msg.sender, withdrawAmount);\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOEmptyVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MIMOEmptyVault.sol",
                "Type": "MIMOEmptyVault.sol executeOperation() does not transfer the Vault leftover assets to the owner, it is locked in the MIMOEmptyVault",
                "Description": "The emptyVault contract, after executing the executionOperation(), only pays back the flash loan, and does not transfer the leftover assets to the owner, and locked in the emptyVault contract.",
                "Repair": "Transfer the remaining balance back to mimoProxy or owner"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MIMOProxy.sol",
                "Type": "Malicious targets can manipulate MIMOProxy permissions",
                "Description": "A malicious (or malfunctioning) target contract with the same or overlapping storage layout may manipulate envoy permissions.",
                "Repair": "Remove all storage variables from MIMOProxy, store permissions in a separate MIMOProxyGuard contract"
            },
            {
                "Location": "MIMOProxy.sol",
                "Type": "Denial of Service (DoS)",
                "Description": "A malicious target contract can permanently block access to a MIMOProxy by setting minGasReserve to a very high value and forcing an underflow in the gas stipend calculation.",
                "Repair": "Restore the setMinGasReserve() function removed in PRBProxy v2.0"
            },
            {
                "Location": "MIMOProxy.sol#execute",
                "Type": "Incorrect implementation of access control",
                "Description": "There is a function execute in MIMOProxy smart contract. The function performs a delegate call to the user-specified address with the specified data.",
                "Repair": "Read the first four bytes of the data parameter directly rather than using data.offset to extract the function selector from calldata"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\ncontract BoringBatchable {\n  error BatchError(bytes innerError);\n\n  /// @dev Helper function to extract a useful revert message from a failed call.\n  /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n  function _getRevertMsg(bytes memory _returnData) internal pure {\n    // If the _res length is less than 68, then\n    // the transaction failed with custom error or silently (without a revert message)\n    if (_returnData.length < 68) revert BatchError(_returnData);\n\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n  }\n\n  /// @notice Allows batched call to self (this contract).\n  /// @param calls An array of inputs for each call.\n  /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n  // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n  // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n  // C3: The length of the loop is fully under user control, so can't be exploited\n  // C7: Delegatecall is only used on the same contract, so it's safe\n  function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n      if (!success && revertOnFail) {\n        _getRevertMsg(result);\n      }\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}\n\n\n",
        "CodeNames": [
            "BoringBatchable.sol",
            "MIMOProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BoringBatchable.sol and MIMOProxy.sol contracts",
                "Type": "Persistent msg.value vulnerability",
                "Description": "An attacker can drain proxy wallet funds by calling 'batch()' with an array of equal items that call 'execute()', which sends 1 ETH from proxy funds in every call. If the receiving contract stores these values, the proxy wallet will be drained. The vulnerability can also be exploited if the owner mistakenly grants access to a non-existing function and the target contract has a fallback function. The severity of the vulnerability was decreased to medium as it requires owner privilege and a user mistake.",
                "Repair": "Remove 'payable' from 'batch()' function in BoringBatchable.sol"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IMIMOAutoRebalance.sol\";\nimport \"../interfaces/IMIMORebalance.sol\";\nimport \"./MIMOAutoAction.sol\";\nimport \"../MIMOFlashloan.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\n/**\n  Rebalance value is calculated by the formula below :\n\n        targetRatio * (vaultDebt + fixedFee) - collateralValue\n      ----------------------------------------------------------\n          targetRatio / mcrB - 1 - targetRatio * variableFee \n */\n\n/// @title A `SuperVault V2` action contract for configuring a vault to be autorebalanced.\n/// @notice This allows anyone to rebalance the vault, as long as the rebalance meets the `autoRebalance` configuration.\ncontract MIMOAutoRebalance is MIMOAutoAction, MIMOFlashloan, IMIMOAutoRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol \n    @param _lendingPool The AAVE lending pool used for flashloans \n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control \n    @param _mimoRebalance The MIMORebalance contract address that holds the logic for the rebalance call \n   */\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry,\n    address _mimoRebalance\n  ) MIMOAutoAction(_a, _proxyRegistry) MIMOFlashloan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoRebalance = _mimoRebalance;\n  }\n\n  /**\n    @notice Perform a rebalance on a vault on behalf of vault owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Reverts if operation results in vault value change above allowed variation or in vault ratio lower than min ratio\n    @param vaultId Vault id of the vault to rebalance\n    @param swapData SwapData struct containing aggegator swap parameters\n   */\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData) external override {\n    AutomatedVault memory autoVault = _automatedVaults[vaultId];\n\n    (uint256 vaultARatioBefore, VaultState memory vaultAState) = _getVaultStats(vaultId);\n\n    _preRebalanceChecks(autoVault, vaultId, vaultARatioBefore);\n\n    IVaultsDataProvider vaultsData = a.vaultsData();\n    address vaultOwner = vaultsData.vaultOwner(vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(autoVault.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n    (IMIMORebalance.RebalanceData memory rbData, FlashLoanData memory flData, uint256 autoFee) = _getRebalanceParams(\n      autoVault,\n      vaultAState,\n      IERC20(autoVault.toCollateral),\n      vaultId\n    );\n\n    _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData));\n    _postRebalanceChecks(autoVault, flData.amount, vaultBBalanceBefore, vaultId, vaultOwner, vaultsData);\n\n    _operationTracker[vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(msg.sender, autoFee);\n  }\n\n  /**\n    @notice Routes a call from a flashloan pool to a leverage or rebalance operation\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Getter function returning rebalance amounts for specific vault id\n    @param vaultId Vault id of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault B\n    @return autoFee Automation fee\n   */\n  function getAmounts(uint256 vaultId, address toCollateral)\n    external\n    view\n    override\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    (, VaultState memory vaultState) = _getVaultStats(vaultId);\n    return _getAmounts(_automatedVaults[vaultId], vaultState, toCollateral);\n  }\n\n  /**\n    @notice Helper function calculating the amount to rebalance from vault A and to mint from vault B with rebalnce formula\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct og the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault b\n    @return autoFee Automation fee\n   */\n  function _getAmounts(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    address toCollateral\n  )\n    internal\n    view\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    IAddressProvider _a = a;\n\n    uint256 targetRatio = autoVault.targetRatio + 1e15; // add 0.1% to account for rounding\n    uint256 toVaultMcr = _a.config().collateralMinCollateralRatio(address(toCollateral));\n\n    // The rebalanceValue is the PAR value of the amount of collateral we need to rebalance\n    uint256 rebalanceValue = (targetRatio.wadMul(vaultState.vaultDebt + autoVault.fixedFee) -\n      vaultState.collateralValue).wadDiv(\n        (targetRatio.wadDiv(toVaultMcr + autoVault.mcrBuffer) - targetRatio.wadMul(autoVault.varFee) - WadRayMath.WAD)\n      );\n\n    autoFee = autoVault.fixedFee + rebalanceValue.wadMul(autoVault.varFee);\n    rebalanceAmount = _a.priceFeed().convertTo(vaultState.collateralType, rebalanceValue);\n    mintAmount = rebalanceValue.wadDiv(toVaultMcr + autoVault.mcrBuffer) - autoFee;\n  }\n\n  /**\n    @notice Helper function formatting FlashloanData and RebalanceData parameters\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @param vaultId Vault id of the vault to rebalance\n    @return rbData RebalanceData struct\n    @return flData FlashloanData struct\n    @return autoFee Automation fee\n   */\n  function _getRebalanceParams(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    IERC20 toCollateral,\n    uint256 vaultId\n  )\n    internal\n    view\n    returns (\n      IMIMORebalance.RebalanceData memory rbData,\n      FlashLoanData memory flData,\n      uint256 autoFee\n    )\n  {\n    (uint256 rebalanceAmount, uint256 mintAmount, uint256 _autoFee) = _getAmounts(\n      autoVault,\n      vaultState,\n      address(toCollateral)\n    );\n\n    autoFee = _autoFee;\n    rbData = IMIMORebalance.RebalanceData({ toCollateral: toCollateral, vaultId: vaultId, mintAmount: mintAmount });\n    flData = FlashLoanData({ asset: vaultState.collateralType, proxyAction: address(this), amount: rebalanceAmount });\n  }\n\n  /**\n    @notice Helper function performing pre rebalance operation sanity checks\n    @dev Checks that vault is automated, that maximum daily operation was not reached and that trigger ratio was reached\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultARatio Collateral to debt ratio of the vault to rebalance\n   */\n  function _preRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 vaultId,\n    uint256 vaultARatio\n  ) internal view {\n    if (!autoVault.isAutomated) {\n      revert CustomErrors.VAULT_NOT_AUTOMATED();\n    }\n    if (_operationTracker[vaultId] > block.timestamp - 1 days) {\n      revert CustomErrors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultARatio > autoVault.triggerRatio) {\n      revert CustomErrors.VAULT_TRIGGER_RATIO_NOT_REACHED(vaultARatio, autoVault.triggerRatio);\n    }\n  }\n\n  /**\n    @notice Helper function performing post rebalance operation sanity checks\n    @dev Checks that change in global vault value (vault A + B) is below allowedVaration and vault A ratio equal or above targetRatio\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param rebalanceAmount Rebalanced amount\n    @param vaultBBalanceBefore Collateral balance of the vault to be rebalanced to before the rebalance operation\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultOwner Rebalanced vault owner\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _postRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceAmount,\n    uint256 vaultBBalanceBefore,\n    uint256 vaultId,\n    address vaultOwner,\n    IVaultsDataProvider vaultsData\n  ) internal view {\n    IPriceFeed priceFeed = a.priceFeed();\n    address fromCollateral = vaultsData.vaultCollateralType(vaultId);\n    uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, rebalanceAmount);\n    uint256 vaultBId = vaultsData.vaultId(autoVault.toCollateral, vaultOwner);\n    uint256 vaultBBalanceAfter = vaultsData.vaultCollateralBalance(vaultBId);\n    uint256 swapResultValue = priceFeed.convertFrom(autoVault.toCollateral, vaultBBalanceAfter - vaultBBalanceBefore);\n\n    if (!_isVaultVariationAllowed(autoVault, rebalanceValue, swapResultValue)) {\n      revert CustomErrors.VAULT_VALUE_CHANGE_TOO_HIGH();\n    }\n\n    (uint256 vaultARatio, ) = _getVaultStats(vaultId);\n\n    if (vaultARatio < autoVault.targetRatio) {\n      revert CustomErrors.FINAL_VAULT_RATIO_TOO_LOW(autoVault.targetRatio, vaultARatio);\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOAutoAction.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOAutoAction is IMIMOAutoAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => AutomatedVault) internal _automatedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault automation parameters\n    @dev Can only be called by vault owner\n    @param vaultId Vault id of the vault to be automated\n    @param autoParams AutomatedVault struct containing all automation parameters\n   */\n  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n\n    uint256 toVaultMcr = a.config().collateralMinCollateralRatio(autoParams.toCollateral);\n    uint256 maxVarFee = (autoParams.targetRatio.wadDiv(toVaultMcr + autoParams.mcrBuffer) + WadRayMath.WAD).wadDiv(\n      autoParams.targetRatio\n    );\n\n    if (autoParams.varFee >= maxVarFee) {\n      revert CustomErrors.VARIABLE_FEE_TOO_HIGH(maxVarFee, autoParams.varFee);\n    }\n\n    _automatedVaults[vaultId] = autoParams;\n\n    emit AutomationSet(vaultId, autoParams);\n  }\n\n  /**\n    @return AutomatedVault struct of a specific vault id\n   */\n  function getAutomatedVault(uint256 vaultId) external view override returns (AutomatedVault memory) {\n    return _automatedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @notice Helper function calculating a vault's net value and LTV ratio\n    @param vaultId Vault id of the vault for which to return info\n    @return vaultRatio Vault collateral value / vault debt\n    @return vaultState VaultState struct of the target vault\n   */\n  function _getVaultStats(uint256 vaultId) internal view returns (uint256 vaultRatio, VaultState memory vaultState) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n    vaultRatio = vaultDebt == 0 ? type(uint256).max : collateralValue.wadDiv(vaultDebt);\n\n    vaultState = VaultState({ collateralType: collateralType, collateralValue: collateralValue, vaultDebt: vaultDebt });\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > autoVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOAutoRebalance.sol",
            "MIMOAutoAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MIMOAutoAction.sol, MIMOAutoRebalance.sol",
                "Type": "Front-running",
                "Description": "A vault owner can front-run rebalance() with setAutomation() to lower incentives.",
                "Repair": "Add a time-lock to setAutomation() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IMIMOManagedRebalance.sol\";\nimport \"./MIMOManagedAction.sol\";\nimport \"../MIMOFlashloan.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\n/** \n@title A `SuperVault V2` action contract for configuring a vault to have a manged rebalance. \n@notice This contract only serves to change the access control and enforce the `managedRebalance` configuration; the actual rebalance logic is done through the `MIMORebalance` contract through a `delegateCall` from a `MIMOProxy` clone\n*/\ncontract MIMOManagedRebalance is MIMOManagedAction, MIMOFlashloan, IMIMOManagedRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol\n    @param _lendingPool The AAVE lending pool used for flashloans\n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control\n    @param _mimoRebalance The MIMORebalance contract address that holds the logic for the rebalance call\n   */\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry,\n    address _mimoRebalance\n  ) MIMOManagedAction(_a, _proxyRegistry) MIMOFlashloan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n\n    mimoRebalance = _mimoRebalance;\n  }\n\n  /**\n    @notice Perform a rebalance on a vault by an appointed whitelisted manager on behalf of vault owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Can only be called once a day by the manager selected by the MIMOProxy owner\n    @dev Reverts if operation results in vault value change above allowed variation or in vault ratio lower than min ratio\n    @param flData Flashloan data struct containing flashloan parameters\n    @param rbData RebalanceData struct containing rebalance operation parameters\n    @param swapData SwapData struct containing aggegator swap parameters\n   */\n  function rebalance(\n    FlashLoanData calldata flData,\n    IMIMORebalance.RebalanceData calldata rbData,\n    IMIMOSwap.SwapData calldata swapData\n  ) external override {\n    ManagedVault memory managedVault = _managedVaults[rbData.vaultId];\n    IVaultsDataProvider vaultsData = a.vaultsData();\n\n    _preRebalanceChecks(managedVault, rbData, vaultsData, flData.amount);\n\n    uint256 managerFee = managedVault.fixedFee + flData.amount.wadMul(managedVault.varFee);\n    address vaultOwner = vaultsData.vaultOwner(rbData.vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(rbData.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n    _takeFlashLoan(flData, abi.encode(vaultsData.vaultOwner(rbData.vaultId), managerFee, rbData, swapData));\n\n    _postRebalanceChecks(\n      managedVault,\n      flData.amount,\n      vaultBBalanceBefore,\n      rbData.vaultId,\n      vaultOwner,\n      address(rbData.toCollateral),\n      vaultsData\n    );\n\n    _operationTracker[rbData.vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(managedVault.manager, managerFee);\n  }\n\n  /**\n    @notice Routes a call from a flashloan pool to a leverage or rebalance operation\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Helper function performing pre rebalance operation sanity checks\n    @dev Checks that vault is managed, that rebalance was called by manager, and maximum daily operation was not reached \n    @param managedVault ManagedVault struct of the vault to rebalance\n    @param rbData RebalanceData struct of the vault to rebalance\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _preRebalanceChecks(\n    ManagedVault memory managedVault,\n    IMIMORebalance.RebalanceData calldata rbData,\n    IVaultsDataProvider vaultsData,\n    uint256 rebalanceAmount\n  ) internal view {\n    if (!_managers[msg.sender]) {\n      revert CustomErrors.MANAGER_NOT_LISTED();\n    }\n    if (!managedVault.isManaged) {\n      revert CustomErrors.VAULT_NOT_UNDER_MANAGEMENT();\n    }\n    if (msg.sender != managedVault.manager) {\n      revert CustomErrors.CALLER_NOT_SELECTED_MANAGER();\n    }\n    if (rebalanceAmount == 0) {\n      revert CustomErrors.REBALANCE_AMOUNT_CANNOT_BE_ZERO();\n    }\n    if (_operationTracker[rbData.vaultId] > block.timestamp - 1 days) {\n      revert CustomErrors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultsData.vaultDebt(rbData.vaultId) < rbData.mintAmount) {\n      revert CustomErrors.MINT_AMOUNT_GREATER_THAN_VAULT_DEBT();\n    }\n  }\n\n  /**\n    @notice Helper function performing post rebalance operation sanity checks\n    @dev Checks that change in global vault value (vault A + B) is below allowedVaration and vault A & B ratios are at least targetRatios\n    @param managedVault ManagedVault struct of the vault to rebalance\n    @param rebalanceAmount Rebalanced amount\n    @param vaultBBalanceBefore Collateral balance of the vault to be rebalanced to before the rebalance operation\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultOwner Rebalanced vault owner\n    @param toCollateral Collateral to rebalance to\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _postRebalanceChecks(\n    ManagedVault memory managedVault,\n    uint256 rebalanceAmount,\n    uint256 vaultBBalanceBefore,\n    uint256 vaultId,\n    address vaultOwner,\n    address toCollateral,\n    IVaultsDataProvider vaultsData\n  ) internal view {\n    IPriceFeed priceFeed = a.priceFeed();\n    address fromCollateral = vaultsData.vaultCollateralType(vaultId);\n    uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, rebalanceAmount);\n    uint256 vaultBId = vaultsData.vaultId(toCollateral, vaultOwner);\n    uint256 vaultBBalanceAfter = vaultsData.vaultCollateralBalance(vaultBId);\n    uint256 swapResultValue = priceFeed.convertFrom(toCollateral, vaultBBalanceAfter - vaultBBalanceBefore);\n\n    if (!_isVaultVariationAllowed(managedVault, rebalanceValue, swapResultValue)) {\n      revert CustomErrors.VAULT_VALUE_CHANGE_TOO_HIGH();\n    }\n\n    uint256 vaultARatioAfter = _getVaultRatio(vaultId);\n\n    if (vaultARatioAfter < managedVault.minRatio) {\n      revert CustomErrors.FINAL_VAULT_RATIO_TOO_LOW(managedVault.minRatio, vaultARatioAfter);\n    }\n\n    uint256 vaultBRatioAfter = _getVaultRatio(vaultBId);\n    uint256 minVaultBRatio = a.config().collateralMinCollateralRatio(toCollateral) + managedVault.mcrBuffer;\n\n    if (vaultBRatioAfter < minVaultBRatio) {\n      revert CustomErrors.FINAL_VAULT_RATIO_TOO_LOW(minVaultBRatio, vaultBRatioAfter);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOManagedRebalance.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MIMOManagedRebalance.sol#rebalance",
                "Type": "Inconsistent manager fees",
                "Description": "Inconsistent manager fees could lead to lack of incentivization to rebalance and unexpected liquidation.",
                "Repair": "Calculate varFee against the PAR of the rebalance"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./MIMOProxy.sol\";\n\n/// @title MIMOProxyFactory\n/// @notice Used to make clones of MIMOProxy for each user\ncontract MIMOProxyFactory is IMIMOProxyFactory {\n  using Clones for address;\n  /// PUBLIC STORAGE ///\n\n  address public immutable mimoProxyBase;\n\n  /// @inheritdoc IMIMOProxyFactory\n  uint256 public constant override VERSION = 1;\n\n  /// INTERNAL STORAGE ///\n\n  /// @dev Internal mapping to track all deployed proxies.\n  mapping(address => bool) internal _proxies;\n\n  constructor(address _mimoProxyBase) {\n    mimoProxyBase = _mimoProxyBase;\n  }\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyFactory\n  function isProxy(address proxy) external view override returns (bool result) {\n    result = _proxies[proxy];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyFactory\n  function deploy() external override returns (IMIMOProxy proxy) {\n    proxy = deployFor(msg.sender);\n  }\n\n  /// @inheritdoc IMIMOProxyFactory\n  function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n    proxy = IMIMOProxy(mimoProxyBase.clone());\n    proxy.initialize();\n\n    // Transfer the ownership from this factory contract to the specified owner.\n    proxy.transferOwnership(owner);\n\n    // Mark the proxy as deployed.\n    _proxies[address(proxy)] = true;\n\n    // Log the proxy via en event.\n    emit DeployProxy(msg.sender, owner, address(proxy));\n  }\n}\n\n\n",
        "CodeNames": [
            "MIMOProxyFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MIMOProxyFactory.sol#deployFor()",
                "Type": "Circumvention of access control",
                "Description": "The deployFor() function in MIMOProxyFactory.sol can be called directly instead of being called within MIMOProxyRegistry.sol.",
                "Repair": "Add access control to ensure that the factory deployFor function is called from the proxy registry"
            }
        ]
    }
]