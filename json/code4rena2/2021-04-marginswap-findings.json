[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "[M-05]",
                "Type": "Medium Severity",
                "Description": "Several functions have no entry check or a trivial entry check, which can be manipulated by input values to disturb the internal administration of the contract.",
                "Repair": "Add entry checks to functions that have no entry check or a trivial entry check"
            },
            {
                "Location": "[H-01]",
                "Type": "High Severity",
                "Description": "A re-entrancy bug allows inflating balance by calling MarginRouter.crossSwapExactTokensForTokens with a fake contract disguised as a token pair.",
                "Repair": "Add re-entrancy guards to all external functions of MarginRouter, remove the estimation and only do the actual trade first, then call registerTrade with the actual trade amounts returned"
            },
            {
                "Location": "[H-07]",
                "Type": "High Severity",
                "Description": "The addHolding function does not update the account.holdsToken map, leading to a critical vulnerability where deposits of the same token keep being pushed to the account.holdingTokens array but the sum is correctly updated in account.holdings[token].",
                "Repair": "Correctly set the account.holdsToken map in addHolding function"
            },
            {
                "Location": "[M-09]",
                "Type": "Medium Severity",
                "Description": "Isolated margin contracts declare but do not set the value of liquidationThresholdPercent.",
                "Repair": "Set the initial value for the liquidationThresholdPercent in Isolated margin contracts"
            },
            {
                "Location": "[M-01]",
                "Type": "Medium Severity",
                "Description": "The IsolatedMarginTrading contract does not define a default liquidation threshold which means it is set to 0.",
                "Repair": "Set a default liquidation threshold like in CrossMarginTrading contracts"
            },
            {
                "Location": "[M-04]",
                "Type": "Medium Severity",
                "Description": "UniswapStyleLib.getAmountsOut, PriceAware.setLiquidationPath (and others) don't check that path.length + 1 == tokens.length which should always hold true. Also, it does not check that the tokens actually match the pair.",
                "Repair": "Check that path.length + 1 == tokens.length and that the tokens actually match the pair in UniswapStyleLib.getAmountsOut, PriceAware.setLiquidationPath, and others"
            },
            {
                "Location": "applyInterest function",
                "Type": "Inconsistent usage of applyInterest",
                "Description": "It is unclear if the function applyInterest is supposed to return a new balance with the interest applied or only the accrued interest?",
                "Repair": "Make the usage of applyInterest consistent in all cases when calling this function"
            },
            {
                "Location": "buyBond function",
                "Type": "function buyBond charges msg.sender twice",
                "Description": "function buyBond transfers amount from msg.sender twice",
                "Repair": "Remove one of the transfer calls to avoid charging msg.sender twice"
            },
            {
                "Location": "registerTradeAndBorrow function",
                "Type": "Users are credited more tokens when paying back debt with registerTradeAndBorrow",
                "Description": "The registerTradeAndBorrow is called with the results of a trade (inAmount, outAmount). It first tries to pay back any debt with the outAmount. However, the full outAmount is credited to the user again as a deposit in the adjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount); call.",
                "Repair": "In the adjustAmounts call, it should only credit outAmount extinguishableDebt as a deposit like in registerDeposit"
            },
            {
                "Location": "belowMaintenanceThreshold function",
                "Type": "Wrong liquidation logic",
                "Description": "The inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated.",
                "Repair": "Change the inequality in the last equation to return 100 * holdings <= liquidationThresholdPercent * loan"
            },
            {
                "Location": "crossSwapExactTokensForTokens and crossSwapTokensForExactTokens functions",
                "Type": "No entry checks in crossSwapExactTokensForTokens and crossSwapTokensForExactTokens",
                "Description": "The functions crossSwapTokensForExactTokens and crossSwapExactTokensForTokens of MarginRouter.sol do not check who is calling the function.",
                "Repair": "Limit who can call the functions, whitelist contents of pairs and tokens, and check the size of pairs and tokens is the same"
            },
            {
                "Location": "MarginSwap contract",
                "Type": "Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token",
                "Description": "Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.",
                "Repair": "Use UniswapV2/SushiSwap/UniswapV3's built-in TWAP price oracle instead of MarginSwap's internal price oracle"
            },
            {
                "Location": "withdrawReward function",
                "Type": "Impossible to call withdrawReward fails due to run out of gas",
                "Description": "The withdrawReward fails due to the loop at https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L269.",
                "Repair": "Initialize lastUpdatedDay to the day of deployment"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./RoleAware.sol\";\nimport \"./Fund.sol\";\n\nstruct Claim {\n    uint256 startingRewardRateFP;\n    uint256 amount;\n    uint256 intraDayGain;\n    uint256 intraDayLoss;\n}\n\n/// @title Manage distribution of liquidity stake incentives\n/// Some efforts have been made to reduce gas cost at claim time\n/// and shift gas burden onto those who would want to withdraw\ncontract IncentiveDistribution is RoleAware, Ownable {\n    // fixed point number factor\n    uint256 internal constant FP32 = 2**32;\n    // the amount of contraction per thousand, per day\n    // of the overal daily incentive distribution\n    // https://en.wikipedia.org/wiki/Per_mil\n    uint256 public constant contractionPerMil = 999;\n    address public immutable MFI;\n\n    constructor(\n        address _MFI,\n        uint256 startingDailyDistributionWithoutDecimals,\n        address _roles\n    ) RoleAware(_roles) Ownable() {\n        MFI = _MFI;\n        currentDailyDistribution =\n            startingDailyDistributionWithoutDecimals *\n            (1 ether);\n    }\n\n    // how much is going to be distributed, contracts every day\n    uint256 public currentDailyDistribution;\n\n    uint256 public trancheShareTotal;\n    uint256[] public allTranches;\n\n    struct TrancheMeta {\n        // portion of daily distribution per each tranche\n        uint256 rewardShare;\n\n        uint256 currentDayGains;\n        uint256 currentDayLosses;\n\n        uint256 tomorrowOngoingTotals;\n        uint256 yesterdayOngoingTotals;\n\n        // aggregate all the unclaimed intra-days\n        uint256 intraDayGains;\n        uint256 intraDayLosses;\n        uint256 intraDayRewardGains;\n        uint256 intraDayRewardLosses;\n\n\n        // how much each claim unit would get if they had staked from the dawn of time\n        // expressed as fixed point number\n        // claim amounts are expressed relative to this ongoing aggregate\n        uint256 aggregateDailyRewardRateFP;\n        uint256 yesterdayRewardRateFP;\n\n        mapping(address => Claim) claims;\n    }\n\n    mapping(uint256 => TrancheMeta) public trancheMetadata;\n\n    // last updated day\n    uint256 public lastUpdatedDay;\n\n    mapping(address => uint256) public accruedReward;\n\n    /// Set share of tranche\n    function setTrancheShare(uint256 tranche, uint256 share)\n        external\n        onlyOwner\n    {\n        require(\n            trancheMetadata[tranche].rewardShare > 0,\n            \"Tranche is not initialized, please initialize first\"\n        );\n        _setTrancheShare(tranche, share);\n    }\n\n    function _setTrancheShare(uint256 tranche, uint256 share) internal {\n        TrancheMeta storage tm = trancheMetadata[tranche];\n\n        if (share > tm.rewardShare) {\n            trancheShareTotal += share - tm.rewardShare;\n        } else {\n            trancheShareTotal -= tm.rewardShare - share;\n        }\n        tm.rewardShare = share;\n    }\n\n    /// Initialize tranche\n    function initTranche(uint256 tranche, uint256 share) external onlyOwner {\n        TrancheMeta storage tm = trancheMetadata[tranche];\n        require(tm.rewardShare == 0, \"Tranche already initialized\");\n        _setTrancheShare(tranche, share);\n\n        // simply initialize to 1.0\n        tm.aggregateDailyRewardRateFP = FP32;\n        allTranches.push(tranche);\n    }\n\n    /// Start / increase amount of claim\n    function addToClaimAmount(\n        uint256 tranche,\n        address recipient,\n        uint256 claimAmount\n    ) external {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        if (currentDailyDistribution > 0) {\n            TrancheMeta storage tm = trancheMetadata[tranche];\n            Claim storage claim = tm.claims[recipient];\n\n            uint256 currentDay =\n                claimAmount * (1 days - (block.timestamp % (1 days)));\n\n            tm.currentDayGains += currentDay;\n            claim.intraDayGain += currentDay * currentDailyDistribution;\n\n            tm.tomorrowOngoingTotals += claimAmount * 1 days;\n            updateAccruedReward(tm, recipient, claim);\n\n            claim.amount += claimAmount * (1 days);\n        }\n    }\n\n    /// Decrease amount of claim\n    function subtractFromClaimAmount(\n        uint256 tranche,\n        address recipient,\n        uint256 subtractAmount\n    ) external {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        uint256 currentDay = subtractAmount * (block.timestamp % (1 days));\n\n        TrancheMeta storage tm = trancheMetadata[tranche];\n        Claim storage claim = tm.claims[recipient];\n\n        tm.currentDayLosses += currentDay;\n        claim.intraDayLoss += currentDay * currentDailyDistribution;\n\n        tm.tomorrowOngoingTotals -= subtractAmount * 1 days;\n\n        updateAccruedReward(tm, recipient, claim);\n        claim.amount -= subtractAmount * (1 days);\n    }\n\n    function updateAccruedReward(\n        TrancheMeta storage tm,\n        address recipient,\n        Claim storage claim\n                                 ) internal returns (uint256 rewardDelta){\n        if (claim.startingRewardRateFP > 0) {\n            rewardDelta = calcRewardAmount(tm, claim);\n            accruedReward[recipient] += rewardDelta;\n        }\n        // don't reward for current day (approximately)\n        claim.startingRewardRateFP =\n            tm.yesterdayRewardRateFP +\n            tm.aggregateDailyRewardRateFP;\n    }\n\n    /// @dev additional reward accrued since last update\n    function calcRewardAmount(TrancheMeta storage tm, Claim storage claim)\n        internal\n        view\n        returns (uint256 rewardAmount)\n    {\n        uint256 ours = claim.startingRewardRateFP;\n        uint256 aggregate = tm.aggregateDailyRewardRateFP;\n        if (aggregate > ours) {\n            rewardAmount = (claim.amount * (aggregate - ours)) / FP32;\n        }\n    }\n\n    function applyIntraDay(\n                           TrancheMeta storage tm,\n        Claim storage claim\n                           ) internal view returns (uint256 gainImpact, uint256 lossImpact) {\n        uint256 gain = claim.intraDayGain;\n        uint256 loss = claim.intraDayLoss;\n\n        if (gain + loss > 0) {\n            gainImpact =\n                (gain * tm.intraDayRewardGains) /\n                    (tm.intraDayGains + 1);\n            lossImpact =\n                (loss * tm.intraDayRewardLosses) /\n                    (tm.intraDayLosses + 1);\n        }\n    }\n\n    /// Get a view of reward amount\n    function viewRewardAmount(uint256 tranche, address claimant)\n        external\n        view\n        returns (uint256)\n    {\n        TrancheMeta storage tm = trancheMetadata[tranche];\n        Claim storage claim = tm.claims[claimant];\n\n        uint256 rewardAmount =\n            accruedReward[claimant] + calcRewardAmount(tm, claim);\n        (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(tm, claim);\n\n        return rewardAmount + gainImpact - lossImpact;\n    }\n\n    /// Withdraw current reward amount\n    function withdrawReward(uint256[] calldata tranches)\n        external\n        returns (uint256 withdrawAmount)\n    {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n\n        updateDayTotals();\n\n        withdrawAmount = accruedReward[msg.sender];\n        for (uint256 i; tranches.length > i; i++) {\n            uint256 tranche = tranches[i];\n\n            TrancheMeta storage tm = trancheMetadata[tranche];\n            Claim storage claim = tm.claims[msg.sender];\n\n            withdrawAmount += updateAccruedReward(tm, msg.sender, claim);\n\n            (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(\n                                                                     tm,\n                claim\n            );\n\n            withdrawAmount = withdrawAmount + gainImpact - lossImpact;\n\n            tm.intraDayGains -= claim.intraDayGain;\n            tm.intraDayLosses -= claim.intraDayLoss;\n            tm.intraDayRewardGains -= gainImpact;\n            tm.intraDayRewardLosses -= lossImpact;\n            \n            claim.intraDayGain = 0;\n        }\n\n        accruedReward[msg.sender] = 0;\n\n        Fund(fund()).withdraw(MFI, msg.sender, withdrawAmount);\n    }\n\n    function updateDayTotals() internal {\n        uint256 nowDay = block.timestamp / (1 days);\n        uint256 dayDiff = nowDay - lastUpdatedDay;\n\n        // shrink the daily distribution for every day that has passed\n        for (uint256 i = 0; i < dayDiff; i++) {\n            _updateTrancheTotals();\n\n            currentDailyDistribution =\n                (currentDailyDistribution * contractionPerMil) /\n                1000;\n\n            lastUpdatedDay += 1;\n        }\n    }\n\n    function _updateTrancheTotals() internal {\n        for (uint256 i; allTranches.length > i; i++) {\n            uint256 tranche = allTranches[i];\n            TrancheMeta storage tm = trancheMetadata[tranche];\n\n            uint256 todayTotal =\n                tm.yesterdayOngoingTotals +\n                    tm.currentDayGains -\n                tm.currentDayLosses;\n\n            uint256 todayRewardRateFP =\n                (FP32 * (currentDailyDistribution * tm.rewardShare)) /\n                    trancheShareTotal /\n                    todayTotal;\n\n            tm.yesterdayRewardRateFP = todayRewardRateFP;\n\n            tm.aggregateDailyRewardRateFP += todayRewardRateFP;\n\n            tm.intraDayGains +=\n                tm.currentDayGains *\n                currentDailyDistribution;\n\n            tm.intraDayLosses +=\n                tm.currentDayLosses *\n                currentDailyDistribution;\n\n            tm.intraDayRewardGains +=\n                (tm.currentDayGains * todayRewardRateFP) /\n                FP32;\n\n            tm.intraDayRewardLosses +=\n                (tm.currentDayLosses * todayRewardRateFP) /\n                FP32;\n\n            tm.yesterdayOngoingTotals = tm.tomorrowOngoingTotals;\n            tm.currentDayGains = 0;\n            tm.currentDayLosses = 0;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "IncentiveDistribution.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "IncentiveDistribution.sol",
                "Type": "lastUpdatedDay not initialized",
                "Description": "The variable lastUpdatedDay in IncentiveDistribution.sol is not (properly) initialized.",
                "Repair": "Initialize lastUpdatedDay with something like block.timestamp / (1 days)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"./MarginRouter.sol\";\nimport \"../libraries/UniswapStyleLib.sol\";\n\n/// Stores how many of token you could get for 1k of peg\nstruct TokenPrice {\n    uint256 blockLastUpdated;\n    uint256 tokenPer1k;\n    address[] liquidationPairs;\n    address[] inverseLiquidationPairs;\n    address[] liquidationTokens;\n    address[] inverseLiquidationTokens;\n}\n\n/// @title The protocol features several mechanisms to prevent vulnerability to\n/// price manipulation:\n/// 1) global exposure caps on all tokens which need to be raised gradually\n///    during the process of introducing a new token, making attacks unprofitable\n///    due to lack  of scale\n/// 2) Exponential moving average with cautious price update. Prices for estimating\n///    how much a trader can borrow need not be extremely current and precise, mainly\n///    they must be resilient against extreme manipulation\n/// 3) Liquidators may not call from a contract address, to prevent extreme forms of\n///    of front-running and other price manipulation.\nabstract contract PriceAware is Ownable, RoleAware {\n    address public immutable peg;\n    mapping(address => TokenPrice) public tokenPrices;\n    /// update window in blocks\n    uint16 public priceUpdateWindow = 8;\n    uint256 public UPDATE_RATE_PERMIL = 80;\n    uint256 public UPDATE_MAX_PEG_AMOUNT = 50_000;\n    uint256 public UPDATE_MIN_PEG_AMOUNT = 1_000;\n\n    constructor(address _peg) Ownable() {\n        peg = _peg;\n    }\n\n    /// Set window for price updates\n    function setPriceUpdateWindow(uint16 window) external onlyOwner {\n        priceUpdateWindow = window;\n    }\n\n    /// Set rate for updates\n    function setUpdateRate(uint256 rate) external onlyOwner {\n        UPDATE_RATE_PERMIL = rate;\n    }\n\n    function setUpdateMaxPegAmount(uint256 amount) external onlyOwner {\n        UPDATE_MAX_PEG_AMOUNT = amount;\n    }\n\n    function setUpdateMinPegAmount(uint256 amount) external onlyOwner {\n        UPDATE_MIN_PEG_AMOUNT = amount;\n    }\n\n    /// Get current price of token in peg\n    function getCurrentPriceInPeg(\n        address token,\n        uint256 inAmount,\n        bool forceCurBlock\n    ) public returns (uint256) {\n        TokenPrice storage tokenPrice = tokenPrices[token];\n        if (forceCurBlock) {\n            if (\n                block.number - tokenPrice.blockLastUpdated > priceUpdateWindow\n            ) {\n                // update the currently cached price\n                return getPriceFromAMM(token, inAmount);\n            } else {\n                // just get the current price from AMM\n                return viewCurrentPriceInPeg(token, inAmount);\n            }\n        } else if (tokenPrice.tokenPer1k == 0) {\n            // do the best we can if it's at zero\n            return getPriceFromAMM(token, inAmount);\n        }\n\n        if (block.number - tokenPrice.blockLastUpdated > priceUpdateWindow) {\n            // update the price somewhat\n            getPriceFromAMM(token, inAmount);\n        }\n\n        return (inAmount * 1000 ether) / tokenPrice.tokenPer1k;\n    }\n\n    /// Get view of current price of token in peg\n    function viewCurrentPriceInPeg(address token, uint256 inAmount)\n        public\n        view\n        returns (uint256)\n    {\n        if (token == peg) {\n            return inAmount;\n        } else {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n            uint256[] memory pathAmounts =\n                UniswapStyleLib.getAmountsOut(\n                    inAmount,\n                    tokenPrice.liquidationPairs,\n                    tokenPrice.liquidationTokens\n                );\n            uint256 outAmount = pathAmounts[pathAmounts.length - 1];\n            return outAmount;\n        }\n    }\n\n    /// @dev retrieves the price from the AMM\n    function getPriceFromAMM(address token, uint256 inAmount)\n        internal\n        virtual\n        returns (uint256)\n    {\n        if (token == peg) {\n            return inAmount;\n        } else {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n            uint256[] memory pathAmounts =\n                UniswapStyleLib.getAmountsOut(\n                    inAmount,\n                    tokenPrice.liquidationPairs,\n                    tokenPrice.liquidationTokens\n                );\n            uint256 outAmount = pathAmounts[pathAmounts.length - 1];\n\n            if (\n                outAmount > UPDATE_MIN_PEG_AMOUNT &&\n                outAmount < UPDATE_MAX_PEG_AMOUNT\n            ) {\n                setPriceVal(tokenPrice, inAmount, outAmount);\n            }\n\n            return outAmount;\n        }\n    }\n\n    function setPriceVal(\n        TokenPrice storage tokenPrice,\n        uint256 inAmount,\n        uint256 outAmount\n    ) internal {\n        _setPriceVal(tokenPrice, inAmount, outAmount, UPDATE_RATE_PERMIL);\n        tokenPrice.blockLastUpdated = block.number;\n    }\n\n    function _setPriceVal(\n        TokenPrice storage tokenPrice,\n        uint256 inAmount,\n        uint256 outAmount,\n        uint256 weightPerMil\n    ) internal {\n        uint256 updatePer1k = (1000 ether * inAmount) / (outAmount + 1);\n        tokenPrice.tokenPer1k =\n            (tokenPrice.tokenPer1k *\n                (1000 - weightPerMil) +\n                updatePer1k *\n                weightPerMil) /\n            1000;\n    }\n\n    /// add path from token to current liquidation peg\n    function setLiquidationPath(address[] memory path, address[] memory tokens)\n        external\n    {\n        require(\n            isTokenActivator(msg.sender),\n            \"not authorized to set lending cap\"\n        );\n\n        address token = tokens[0];\n\n        TokenPrice storage tokenPrice = tokenPrices[token];\n        tokenPrice.liquidationPairs = new address[](path.length);\n        tokenPrice.inverseLiquidationPairs = new address[](path.length);\n        tokenPrice.liquidationTokens = new address[](tokens.length);\n        tokenPrice.inverseLiquidationTokens = new address[](tokens.length);\n\n        for (uint256 i = 0; path.length > i; i++) {\n            tokenPrice.liquidationPairs[i] = path[i];\n            tokenPrice.inverseLiquidationPairs[i] = path[path.length - i - 1];\n        }\n\n        for (uint256 i = 0; tokens.length > i; i++) {\n            tokenPrice.liquidationTokens[i] = tokens[i];\n            tokenPrice.inverseLiquidationTokens[i] = tokens[\n                tokens.length - i - 1\n            ];\n        }\n\n        uint256[] memory pathAmounts =\n            UniswapStyleLib.getAmountsIn(1000 ether, path, tokens);\n        uint256 inAmount = pathAmounts[0];\n        _setPriceVal(tokenPrice, inAmount, 1000 ether, 1000);\n    }\n\n    function liquidateToPeg(address token, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        if (token == peg) {\n            return amount;\n        } else {\n            TokenPrice storage tP = tokenPrices[token];\n            uint256[] memory amounts =\n                MarginRouter(router()).authorizedSwapExactT4T(\n                    amount,\n                    0,\n                    tP.liquidationPairs,\n                    tP.liquidationTokens\n                );\n\n            uint256 outAmount = amounts[amounts.length - 1];\n\n            return outAmount;\n        }\n    }\n\n    function liquidateFromPeg(address token, uint256 targetAmount)\n        internal\n        returns (uint256)\n    {\n        if (token == peg) {\n            return targetAmount;\n        } else {\n            TokenPrice storage tP = tokenPrices[token];\n            uint256[] memory amounts =\n                MarginRouter(router()).authorizedSwapT4ExactT(\n                    targetAmount,\n                    type(uint256).max,\n                    tP.inverseLiquidationPairs,\n                    tP.inverseLiquidationTokens\n                );\n\n            return amounts[0];\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PriceAware.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PriceAware contract",
                "Type": "PriceAware uses prices from getAmountsOut",
                "Description": "getPriceFromAMM relies on values returned from getAmountsOut which can be manipulated",
                "Repair": "Use Uniswap v2's TWAP oracle instead of relying on values returned from getAmountsOut"
            }
        ]
    }
]