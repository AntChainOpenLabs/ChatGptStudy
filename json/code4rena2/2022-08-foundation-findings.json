[
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"forge-std/Test.sol\";\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport \"../../contracts/NFTDropMarket.sol\";\nimport \"../../contracts/FETH.sol\";\nimport \"../../contracts/NFTDropCollection.sol\";\nimport \"../../contracts/NFTCollectionFactory.sol\";\nimport \"../../contracts/mocks/MockTreasury.sol\";\nimport \"../../contracts/mocks/RoyaltyRegistry/MockRoyaltyRegistry.sol\";\n\ncontract TestFixedPriceDrop is Test {\n  address admin = address(99);\n  address creator = address(1);\n  address collector = address(2);\n\n  MockTreasury treasury;\n  NFTDropMarket nftDropMarket;\n  FETH feth;\n  MockRoyaltyRegistry royaltyRegistry;\n  NFTCollectionFactory nftCollectionFactory;\n\n  function setUp() public {\n    /** Pre-reqs **/\n    treasury = new MockTreasury();\n\n    /** Deploy Collection Factory **/\n    nftCollectionFactory = new NFTCollectionFactory(address(treasury));\n    nftCollectionFactory.initialize(2);\n    NFTDropCollection nftDropCollectionTemplate = new NFTDropCollection(address(nftCollectionFactory));\n    nftCollectionFactory.adminUpdateNFTDropCollectionImplementation(address(nftDropCollectionTemplate));\n\n    /** Deploy Market **/\n    // Deploy the proxy with a placeholder implementation.\n    TransparentUpgradeableProxy dropMarketProxy = new TransparentUpgradeableProxy(address(treasury), admin, \"\");\n    feth = new FETH(payable(dropMarketProxy), payable(dropMarketProxy), 24 hours);\n    royaltyRegistry = new MockRoyaltyRegistry();\n\n    NFTDropMarket dropMarketImplementation = new NFTDropMarket(\n      payable(treasury),\n      address(feth),\n      address(royaltyRegistry)\n    );\n    vm.prank(admin);\n    dropMarketProxy.upgradeTo(address(dropMarketImplementation));\n    nftDropMarket = NFTDropMarket(payable(dropMarketProxy));\n    nftDropMarket.initialize();\n  }\n\n  function testHappyCase() public {\n    /** Create drop collection **/\n    uint256 nonce = 42;\n    uint32 maxTokenId = 100;\n    vm.prank(creator);\n    nftCollectionFactory.createNFTDropCollection(\n      \"Name\",\n      \"SYM\",\n      \"ipfs://sample\",\n      0x0,\n      maxTokenId,\n      address(nftDropMarket),\n      nonce\n    );\n    NFTDropCollection nftDropCollection = NFTDropCollection(\n      nftCollectionFactory.predictNFTDropCollectionAddress(creator, nonce)\n    );\n\n    /** List for sale **/\n    uint80 price = 0.5 ether;\n    uint16 limitPerAccount = 10;\n    vm.prank(creator);\n    nftDropMarket.createFixedPriceSale(address(nftDropCollection), price, limitPerAccount);\n\n    /** Mint from sale **/\n    uint16 count = 3;\n    vm.deal(collector, 999 ether);\n    vm.prank(collector);\n    nftDropMarket.mintFromFixedPriceSale{ value: price * count }(address(nftDropCollection), count, payable(0));\n  }\n}\n\n\n",
        "CodeNames": [
            "FixedPriceDrop.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FixedPriceDrop.sol",
                "Type": "Bypassing limitPerAccount",
                "Description": "It is possible to bypass the saleConfig.limitPerAccount set by the creator by transferring the NFTs out.",
                "Repair": "Use a mapping to track how many NFTs an address has bought instead of relying on balanceOf"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "royaltyInfo, getRoyalties, or getFeeRecipients functions",
                "Type": "Burning creator fees",
                "Description": "royaltyInfo, getRoyalties, or getFeeRecipients may return address(0) as the recipient address. While the value 0 is correctly handled for the royalties itself, it is not for the address. In such a case, the ETH amount will be sent to address(0), i.e. it is burned and lost.",
                "Repair": "Treat address(0) as if no recipient was returned such that the other priorities / methods take over"
            },
            {
                "Location": "mixins/shared/MarketFees.sol#L130",
                "Type": "Gas Stealing",
                "Description": "Selling a NFT with NFTDropMarketFixedPriceSale.mintFromFixedPriceSale distributes the revenue from the sale to various recipients with the MarketFees._distributeFunds function. It is possible to have multiple NFT creators. Sale revenue will be distributed to each NFT creator address. Revenue distribution is done by calling SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw and providing an appropriate gas limit to prevent consuming too much gas. For the revenue distribution to the seller, protocol and the buy referrer, a gas limit of SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20_000 is used. However, for the creators, a limit of SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000 is used. This higher amount of gas is used if PercentSplitETH is used as a recipient. A maximum of MAX_ROYALTY_RECIPIENTS = 5 NFT creator recipients are allowed.",
                "Repair": "Consider only providing a higher amount of gas (SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT."
            },
            {
                "Location": "contracts/NFTCollection.sol#L262-L274, contracts/NFTDropCollection.sol#L171-L187",
                "Type": "NFT Locking",
                "Description": "When calling the _mint or mintCountTo function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's ERC721Upgradeable contract's _mint function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked.",
                "Repair": "_safeMint function can be used instead of _mint or mintCountTo function to mint NFTs of NFT collection or NFT drop collection. "
            },
            {
                "Location": "getRoyalties function",
                "Type": "Incorrect logic",
                "Description": "If one creator specified a share that is larger than BASIS_POINTS, the first creator gets all of the royalties. This can be exploited by the first creator.",
                "Repair": "Remove the unnecessary check/logic as the whole sum is used to normalize the values"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IOwnable.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../../libraries/ArrayLibrary.sol\";\n\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./OZERC165Checker.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\nimport \"./MarketSharedCore.sol\";\n\nerror NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin to distribute funds when an NFT is sold.\n */\nabstract contract MarketFees is FoundationTreasuryNode, MarketSharedCore, SendValueWithFallbackWithdraw {\n  using AddressUpgradeable for address;\n  using ArrayLibrary for address payable[];\n  using ArrayLibrary for uint256[];\n  using ERC165Checker for address;\n  using OZERC165Checker for address;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private _primaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryCreatorFeeBasisPoints;\n   * mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;\n   */\n  uint256[4] private __gap_was_fees;\n\n  /// @notice The royalties sent to creator recipients on secondary sales.\n  uint256 private constant CREATOR_ROYALTY_DENOMINATOR = BASIS_POINTS / 1000; // 10%\n  /// @notice The fee collected by Foundation for sales facilitated by this market contract.\n  uint256 private constant PROTOCOL_FEE_DENOMINATOR = BASIS_POINTS / 500; // 5%\n  /// @notice The fee collected by the buy referrer for sales facilitated by this market contract.\n  ///         This fee is calculated from the total protocol fee.\n  /// @dev 20% of protocol fee == 1% of total sale.\n  uint256 private constant BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR = 5;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /// @notice The address of this contract's implementation.\n  /// @dev This is used when making stateless external calls to this contract,\n  /// saving gas over hopping through the proxy which is only necessary when accessing state.\n  MarketFees private immutable implementationAddress;\n\n  /// @notice True for the Drop market which only performs primary sales. False if primary & secondary are supported.\n  bool private immutable assumePrimarySale;\n\n  /**\n   * @notice Emitted when a NFT sold with a referrer.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyReferrer The account which received the buy referral incentive.\n   * @param buyReferrerFee The portion of the protocol fee collected by the buy referrer.\n   * @param buyReferrerSellerFee The portion of the owner revenue collected by the buy referrer (not implemented).\n   */\n  event BuyReferralPaid(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address buyReferrer,\n    uint256 buyReferrerFee,\n    uint256 buyReferrerSellerFee\n  );\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry, bool _assumePrimarySale) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n\n    assumePrimarySale = _assumePrimarySale;\n\n    // In the constructor, `this` refers to the implementation address. Everywhere else it'll be the proxy.\n    implementationAddress = this;\n  }\n\n  /**\n   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n   */\n  function _distributeFunds(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    internal\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      uint256 sellerRev\n    )\n  {\n    address payable[] memory creatorRecipients;\n    uint256[] memory creatorShares;\n\n    uint256 buyReferrerFee;\n    (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      buyReferrer\n    );\n\n    // Pay the creator(s)\n    unchecked {\n      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n        _sendValueWithFallbackWithdraw(\n          creatorRecipients[i],\n          creatorShares[i],\n          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS\n        );\n        // Sum the total creator rev from shares\n        // creatorShares is in ETH so creatorRev will not overflow here.\n        creatorRev += creatorShares[i];\n      }\n    }\n\n    // Pay the seller\n    _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the protocol fee\n    _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the buy referrer fee\n    if (buyReferrerFee != 0) {\n      _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n      emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n      unchecked {\n        // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n        totalFees += buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns how funds will be distributed for a sale at the given price point.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param price The sale price to calculate the fees for.\n   * @return totalFees How much will be sent to the Foundation treasury and/or referrals.\n   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.\n   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.\n   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.\n   * If there is only one `creatorRecipient`, this may be an empty array.\n   * Otherwise `creatorShares.length` == `creatorRecipients.length`.\n   * @return sellerRev How much will be sent to the owner/seller of the NFT.\n   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.\n   * @return seller The address of the owner of the NFT.\n   * If `sellerRev` is 0, this may be `address(0)`.\n   */\n  function getFeesAndRecipients(\n    address nftContract,\n    uint256 tokenId,\n    uint256 price\n  )\n    external\n    view\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      address payable seller\n    )\n  {\n    seller = _getSellerOrOwnerOf(nftContract, tokenId);\n    (totalFees, creatorRecipients, creatorShares, sellerRev, ) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      // TODO add referral info\n      payable(0)\n    );\n\n    // Sum the total creator rev from shares\n    for (uint256 i = 0; i < creatorShares.length; ++i) {\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @dev See https://royaltyregistry.xyz/\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() external view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks the token creator.\n   */\n  function internalGetTokenCreator(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable creator)\n  {\n    creator = ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * If ERC2981 royalties (or getRoyalties) are defined by the NFT contract, allow this standard to define immutable\n   * royalties that cannot be later changed via the royalty registry.\n   */\n  function internalGetImmutableRoyalties(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints)\n  {\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 royaltyAmount\n      ) {\n        // Manifold contracts return (address(this), 0) when royalties are not defined\n        // - so ignore results when the amount is 0\n        if (royaltyAmount > 0) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          splitPerRecipientInBasisPoints = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n          return (recipients, splitPerRecipientInBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n          return (_recipients, recipientBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks for royalties defined in the royalty registry or via a non-standard royalty API.\n   */\n  // solhint-disable-next-line code-complexity\n  function internalGetMutableRoyalties(\n    address nftContract,\n    uint256 tokenId,\n    address payable creator\n  ) external view returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints) {\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n\n    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n      address overrideContract\n    ) {\n      if (overrideContract != nftContract) {\n        nftContract = overrideContract;\n\n        // The functions above are repeated here if an override is set.\n\n        // 3rd priority: ERC-2981 override\n        if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n            address receiver,\n            uint256 /* royaltyAmount */\n          ) {\n            recipients = new address payable[](1);\n            recipients[0] = payable(receiver);\n            splitPerRecipientInBasisPoints = new uint256[](1);\n            // The split amount is assumed to be 100% when only 1 recipient is returned\n            return (recipients, splitPerRecipientInBasisPoints);\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n\n        // 4th priority: getRoyalties override\n        if (recipients.length == 0 && nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            address payable[] memory _recipients,\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Ignore out of gas errors and continue using the nftContract address\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length != 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    if (creator != address(0)) {\n      // Only pay the tokenCreator if there wasn't another royalty defined\n      recipients = new address payable[](1);\n      recipients[0] = creator;\n      splitPerRecipientInBasisPoints = new uint256[](1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (owner != address(0)) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        splitPerRecipientInBasisPoints = new uint256[](1);\n        // The split amount is assumed to be 100% when only 1 recipient is returned\n        return (recipients, splitPerRecipientInBasisPoints);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Calculates how funds should be distributed for the given sale details.\n   * @dev When the NFT is being sold by the `tokenCreator`, all the seller revenue will\n   * be split with the royalty recipients defined for that NFT.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getFees(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    private\n    view\n    returns (\n      uint256 totalFees,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      uint256 buyReferrerFee\n    )\n  {\n    // Calculate the protocol fee\n    unchecked {\n      // SafeMath is not required when dividing by a non-zero constant.\n      totalFees = price / PROTOCOL_FEE_DENOMINATOR;\n    }\n\n    address payable creator;\n    try implementationAddress.internalGetTokenCreator(nftContract, tokenId) returns (address payable _creator) {\n      creator = _creator;\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n      address payable[] memory _recipients,\n      uint256[] memory _splitPerRecipientInBasisPoints\n    ) {\n      (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    if (creatorRecipients.length == 0) {\n      // Check mutable royalties only if we didn't find results from the immutable API\n      try implementationAddress.internalGetMutableRoyalties(nftContract, tokenId, creator) returns (\n        address payable[] memory _recipients,\n        uint256[] memory _splitPerRecipientInBasisPoints\n      ) {\n        (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    if (creatorRecipients.length != 0 || assumePrimarySale) {\n      uint256 creatorRev;\n      if (assumePrimarySale) {\n        // All revenue should go to the creator recipients\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n        if (creatorRecipients.length == 0) {\n          // If no creators were found via the royalty APIs, then set that recipient to the seller's address\n          creatorRecipients = new address payable[](1);\n          creatorRecipients[0] = seller;\n          creatorShares = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n        }\n      } else if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {\n        // When sold by the creator, all revenue is split if applicable.\n        // If the seller is unknown, assume it's being sold by the creator.\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        unchecked {\n          // SafeMath is not required when dividing by a non-zero constant.\n          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;\n        }\n        sellerRev = price - totalFees - creatorRev;\n      }\n\n      // Cap the max number of recipients supported\n      creatorRecipients.capLength(MAX_ROYALTY_RECIPIENTS);\n      creatorShares.capLength(MAX_ROYALTY_RECIPIENTS);\n\n      // Sum the total shares defined\n      uint256 totalShares;\n      if (creatorRecipients.length > 1) {\n        unchecked {\n          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n            if (creatorShares[i] > BASIS_POINTS) {\n              // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n              totalShares = 0;\n              break;\n            }\n            totalShares += creatorShares[i];\n          }\n        }\n\n        if (totalShares == 0) {\n          // If no shares were defined or shares were out of bounds, pay only the first recipient\n          creatorRecipients.capLength(1);\n          creatorShares.capLength(1);\n        }\n      }\n\n      // Send payouts to each additional recipient if more than 1 was defined\n      uint256 totalRoyaltiesDistributed;\n      for (uint256 i = 1; i < creatorRecipients.length; ) {\n        uint256 royalty = (creatorRev * creatorShares[i]) / totalShares;\n        totalRoyaltiesDistributed += royalty;\n        creatorShares[i] = royalty;\n        unchecked {\n          ++i;\n        }\n      }\n\n      // Send the remainder to the 1st creator, rounding in their favor\n      creatorShares[0] = creatorRev - totalRoyaltiesDistributed;\n    } else {\n      // No royalty recipients found.\n      unchecked {\n        // totalFees is always < price.\n        sellerRev = price - totalFees;\n      }\n    }\n\n    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {\n      unchecked {\n        buyReferrerFee = totalFees / BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR;\n\n        // buyReferrerFee is always <= totalFees\n        totalFees -= buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n",
        "CodeNames": [
            "MarketFees.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MarketFees.sol",
                "Type": "Wrong return of creatorShares and creatorRecipients",
                "Description": "Wrong return of cretorShares and creatorRecipients can make real royalties party can't gain the revenue of sale.",
                "Repair": "Add check if royaltyAmount is greater than 0 or not in 3rd priority"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\n/**\n * @notice The required interface for collections to support the NFTDropMarket.\n * @dev This interface must be registered as a ERC165 supported interface to support the NFTDropMarket.\n */\ninterface INFTDropCollectionMint {\n  function mintCountTo(uint16 count, address to) external returns (uint256 firstTokenId);\n\n  function numberOfTokensAvailableToMint() external view returns (uint256 count);\n}\n\n\n",
        "CodeNames": [
            "INFTDropCollectionMint.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "INFTDropCollectionMint.mintCountTo()",
                "Type": "Malicious Creator can steal from collectors upon minting with a custom NFT contract",
                "Description": "A malicious creator can set a malicious implementation of INFTDropCollectionMint.mintCountTo() that would result in collectors calling this function losing funds without receiving the expected amount of NFTs.",
                "Repair": "Add an additional check in NFTDropMarketFixedPriceSale.mintCountTo() using ERC721(nftContract).balanceOf(). Specify in INFTDropCollectionMint that mintCountTo must revert if called after all tokens have been minted."
            },
            {
                "Location": "INFTDropCollectionMint.mintCountTo()",
                "Type": "mintFromFixedPriceSale for a custom contract can lead to users losing funds",
                "Description": "It is not clear as to what should be returned upon all tokens being minted. A valid implementation could for instance return 0 if called after the last token has been minted. The drop market expects the call to mintCountTo to revert upon the last token being minted, meaning a user calling it afterwards would lose the ETH they sent.",
                "Repair": "Add an additional check in NFTDropMarketFixedPriceSale.mintCountTo() using ERC721(nftContract).balanceOf(). Specify in INFTDropCollectionMint that mintCountTo must revert if called after all tokens have been minted."
            }
        ]
    }
]