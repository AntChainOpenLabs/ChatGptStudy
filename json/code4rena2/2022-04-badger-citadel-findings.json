[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "mintAndDistribute function",
                "Type": "Guaranteed citadel profit",
                "Description": "User can sandwich mintAndDistribute function if mintable is high enough.",
                "Repair": "Add linear vesting to the way more rewards are distributed to prevent frontrunning"
            },
            {
                "Location": "buy function and setTokenOutPrice function",
                "Type": "KnightingRound tokenOutPrice changes",
                "Description": "User buys tokens with the price he was not aware of.",
                "Repair": "Add additional parameter believedPrice to KnightingRound.buy function and check if believedPrice is equal to tokenOutPrice"
            },
            {
                "Location": "deposit function",
                "Type": "StakedCitadel depositors can be attacked",
                "Description": "Attacker can become the first depositor for a recently created StakedCitadel contract, providing a tiny amount of Citadel tokens.",
                "Repair": "Require a minimum amount for deposit value to reduce the economic viability of the attack"
            },
            {
                "Location": "withdraw function",
                "Type": "StakedCitadel: wrong setupVesting function name",
                "Description": "In the _withdraw function of the StakedCitadel contract, the setupVesting function of vesting is called.",
                "Repair": "Use the correct function name vest instead of setupVesting"
            },
            {
                "Location": "deposit function and getAmountOut function",
                "Type": "Funding.deposit() doesn't work if there is no discount set",
                "Description": "The Funding contract's deposit() function tries to deposit 0 tokens for the user through the StakedCitadel contract.",
                "Repair": "Change the getAmountOut function to calculate citadelAmount_ without the if block"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Staked Citadel Vesting Utility.\n * @notice Time-locks tokens on users' behalf according to an unlock schedule.\n */\ncontract StakedCitadelVester is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n\n    struct VestingParams {\n        uint256 unlockBegin;\n        uint256 unlockEnd;\n        uint256 lockedAmounts;\n        uint256 claimedAmounts;\n    }\n\n    IERC20Upgradeable public vestingToken;\n    address public vault;\n    mapping(address => VestingParams) public vesting;\n\n    uint256 public constant INITIAL_VESTING_DURATION = 86400 * 21; // 21 days of vesting\n    uint256 public vestingDuration;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Vest(\n        address indexed recipient,\n        uint256 _amount,\n        uint256 _unlockBegin,\n        uint256 _unlockEnd\n    );\n    event Claimed(\n        address indexed owner,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event SetVestingDuration(uint256 duration);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    function initialize(\n        address _gac,\n        address _vestingToken,\n        address _vault\n    ) external initializer {\n        require(_vestingToken != address(0), \"Address zero invalid\");\n        require(_vault != address(0), \"Address zero invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        vestingDuration = INITIAL_VESTING_DURATION;\n\n        vestingToken = IERC20Upgradeable(_vestingToken);\n        vault = _vault;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Claims the caller's tokens that have been unlocked, sending them to `recipient`.\n     * @param recipient The account to transfer unlocked tokens to.\n     * @param amount The amount to transfer. If greater than the claimable amount, the maximum is transferred.\n     */\n    function claim(address recipient, uint256 amount) external {\n        uint256 claimable = claimableBalance(msg.sender);\n        if (amount > claimable) {\n            amount = claimable;\n        }\n        if (amount != 0) {\n            vesting[msg.sender].claimedAmounts =\n                vesting[msg.sender].claimedAmounts +\n                amount;\n            vestingToken.safeTransfer(recipient, amount);\n            emit Claimed(msg.sender, recipient, amount);\n        }\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Returns the maximum number of tokens currently claimable by `recipient`.\n     * @param recipient The account to check the claimable balance of.\n     * @return The number of tokens currently claimable.\n     */\n    function claimableBalance(address recipient) public view returns (uint256) {\n        uint256 locked = vesting[recipient].lockedAmounts;\n        uint256 claimed = vesting[recipient].claimedAmounts;\n        if (block.timestamp >= vesting[recipient].unlockEnd) {\n            return locked - claimed;\n        }\n        return\n            ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /\n                (vesting[recipient].unlockEnd -\n                    vesting[recipient].unlockBegin)) - claimed;\n    }\n\n    /// =========================\n    /// ===== Vault actions =====\n    /// =========================\n\n    /**\n     * @dev setup vesting for recipient.\n     * @notice note that a given address can only have one active vest at a time.\n     * @notice adding a new vest before claiming completely from the previous will re-lock the previous amount according to the new vesting timeline.\n     * @param recipient The account for which vesting will be setup.\n     * @param _amount amount that will be vested\n     * @param _unlockBegin The time at which unlocking of tokens will begin.\n     */\n    function vest(\n        address recipient,\n        uint256 _amount,\n        uint256 _unlockBegin\n    ) external {\n        require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");\n        require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");\n\n        vesting[recipient].lockedAmounts =\n            vesting[recipient].lockedAmounts +\n            _amount;\n        vesting[recipient].unlockBegin = _unlockBegin;\n        vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n        emit Vest(\n            recipient,\n            vesting[recipient].lockedAmounts,\n            _unlockBegin,\n            vesting[recipient].unlockEnd\n        );\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice modify vesting duration\n     * @dev does not affect currently active vests, only future vests\n     * @param _duration new vesting duration\n     */\n    function setVestingDuration(uint256 _duration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        vestingDuration = _duration;\n        emit SetVestingDuration(_duration);\n    }\n}\n\n\n",
        "CodeNames": [
            "StakedCitadelVester.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StakedCitadelVester.sol:143,109",
                "Type": "New vest reset unlockBegin of existing vest without removing vested amount",
                "Description": "When vest is called by xCTDL vault, the previous amount will re-lock according to the new vesting timeline. While this is as described in L127, claimableBalance might revert due to underflow if vesting[recipient].claimedAmounts < 0 because the user will need to vest the claimedAmounts again which should not be an expected behavior as it is already vested.",
                "Repair": "Reset claimedAmounts on new vest"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/SettAccessControl.sol\";\n\nimport {IVault} from \"./interfaces/badger/IVault.sol\";\nimport {IVesting} from \"./interfaces/citadel/IVesting.sol\";\nimport {IStrategy} from \"./interfaces/badger/IStrategy.sol\";\nimport {IERC20} from \"./interfaces/erc20/IERC20.sol\";\nimport {IBadgerGuestlist} from \"./interfaces/badger/IBadgerGuestlist.sol\";\n\n/*\n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n\n    V1.3\n    * Add guest list functionality\n    * All deposits can be optionally gated by external guestList approval logic on set guestList contract\n\n    V1.4\n    * Add depositFor() to deposit on the half of other users. That user will then be blockLocked.\n\n    V1.5\n    * Removed Controller\n        - Removed harvest from vault (only on strategy)\n    * Params added to track autocompounded rewards (lifeTimeEarned, lastHarvestedAt, lastHarvestAmount, assetsAtLastHarvest)\n      this would work in sync with autoCompoundRatio to help us track harvests better.\n    * Fees\n        - Strategy would report the autocompounded harvest amount to the vault\n        - Calculation performanceFeeGovernance, performanceFeeStrategist, withdrawalFee, managementFee moved to the vault.\n        - Vault mints shares for performanceFees and managementFee to the respective recipient (treasury, strategist)\n        - withdrawal fees is transferred to the rewards address set\n    * Permission:\n        - Strategist can now set performance, withdrawal and management fees\n        - Governance will determine maxPerformanceFee, maxWithdrawalFee, maxManagementFee that can be set to prevent rug of funds.\n    * Strategy would take the actors from the vault it is connected to\n    * All governance related fees goes to treasury\n*/\n\ncontract StakedCitadel is\n    ERC20Upgradeable,\n    SettAccessControl,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    uint256 constant ONE_ETH = 1e18;\n\n    /// ===== Storage Variables ====\n\n    IERC20Upgradeable public token; // Token used for deposits\n    IBadgerGuestlist public guestList; // guestlist when vault is in experiment/ guarded state\n\n    bool public pausedDeposit; // false by default Allows to only block deposits, use pause for the normal pause state\n\n    address public strategy; // address of the strategy connected to the vault\n    address public guardian; // guardian of vault and strategy\n    address public treasury; // set by governance ... any fees go there\n\n    address public badgerTree; // Address we send tokens too via reportAdditionalTokens\n    address public vesting; // Address of the vesting contract where after withdrawal we send CTDL to vest for 21 days\n\n    /// @dev name and symbol prefixes for lpcomponent token of vault\n    string internal constant _defaultNamePrefix = \"Staked \";\n    string internal constant _symbolSymbolPrefix = \"x\";\n\n    /// Params to track autocompounded rewards\n    uint256 public lifeTimeEarned; // keeps track of total earnings\n    uint256 public lastHarvestedAt; // timestamp of the last harvest\n    uint256 public lastHarvestAmount; // amount harvested during last harvest\n    uint256 public assetsAtLastHarvest; // assets for which the harvest took place.\n\n    mapping(address => uint256) public additionalTokensEarned;\n    mapping(address => uint256) public lastAdditionalTokenAmount;\n\n    /// Fees ///\n    /// @notice all fees will be in bps\n    uint256 public performanceFeeGovernance; // Perf fee sent to `treasury`\n    uint256 public performanceFeeStrategist; // Perf fee sent to `strategist`\n    uint256 public withdrawalFee; // fee issued to `treasury` on withdrawal\n    uint256 public managementFee; // fee issued to `treasury` on report (typically on harvest, but only if strat is autocompounding)\n\n    uint256 public maxPerformanceFee; // maximum allowed performance fees\n    uint256 public maxWithdrawalFee; // maximum allowed withdrawal fees\n    uint256 public maxManagementFee; // maximum allowed management fees\n\n    uint256 public toEarnBps; // NOTE: in BPS, minimum amount of token to deposit into strategy when earn is called\n\n    /// ===== Constants ====\n\n    uint256 public constant MAX_BPS = 10_000;\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    uint256 public constant WITHDRAWAL_FEE_HARD_CAP = 200; // Never higher than 2%\n    uint256 public constant PERFORMANCE_FEE_HARD_CAP = 3_000; // Never higher than 30% // 30% maximum performance fee // We usually do 20, so this is insanely high already\n    uint256 public constant MANAGEMENT_FEE_HARD_CAP = 200; // Never higher than 2%\n\n    /// ===== Events ====\n\n    // Emitted when a token is sent to the badgerTree for emissions\n    event TreeDistribution(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    // Emitted during a report, when there has been an increase in pricePerFullShare (ppfs)\n    event Harvested(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    event SetTreasury(address indexed newTreasury);\n    event SetStrategy(address indexed newStrategy);\n    event SetToEarnBps(uint256 newEarnToBps);\n    event SetMaxWithdrawalFee(uint256 newMaxWithdrawalFee);\n    event SetMaxPerformanceFee(uint256 newMaxPerformanceFee);\n    event SetMaxManagementFee(uint256 newMaxManagementFee);\n    event SetGuardian(address indexed newGuardian);\n    event SetVesting(address indexed newVesting);\n    event SetGuestList(address indexed newGuestList);\n    event SetWithdrawalFee(uint256 newWithdrawalFee);\n    event SetPerformanceFeeStrategist(uint256 newPerformanceFeeStrategist);\n    event SetPerformanceFeeGovernance(uint256 newPerformanceFeeGovernance);\n    event SetManagementFee(uint256 newManagementFee);\n\n    event PauseDeposits(address indexed pausedBy);\n    event UnpauseDeposits(address indexed pausedBy);\n\n    /// @notice Initializes the Sett. Can only be called once, ideally when the contract is deployed.\n    /// @param _token Address of the token that can be deposited into the sett.\n    /// @param _governance Address authorized as governance.\n    /// @param _keeper Address authorized as keeper.\n    /// @param _guardian Address authorized as guardian.\n    /// @param _treasury Address to distribute governance fees/rewards to.\n    /// @param _strategist Address authorized as strategist.\n    /// @param _badgerTree Address of badgerTree used for emissions.\n    /// @param _name Specify a custom sett name. Leave empty for default value.\n    /// @param _symbol Specify a custom sett symbol. Leave empty for default value.\n    /// @param _feeConfig Values for the 4 different types of fees charges by the sett\n    ///         [performanceFeeGovernance, performanceFeeStrategist, withdrawToVault, managementFee]\n    ///         Each fee should be less than the constant hard-caps defined above.\n    function initialize(\n        address _token,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        address _treasury,\n        address _strategist,\n        address _badgerTree,\n        address _vesting,\n        string memory _name,\n        string memory _symbol,\n        uint256[4] memory _feeConfig\n    ) public initializer whenNotPaused {\n        require(_token != address(0)); // dev: _token address should not be zero\n        require(_governance != address(0)); // dev: _governance address should not be zero\n        require(_keeper != address(0)); // dev: _keeper address should not be zero\n        require(_guardian != address(0)); // dev: _guardian address should not be zero\n        require(_treasury != address(0)); // dev: _treasury address should not be zero\n        require(_strategist != address(0)); // dev: _strategist address should not be zero\n        require(_badgerTree != address(0)); // dev: _badgerTree address should not be zero\n        require(_vesting != address(0)); // dev: _vesting address should not be zero\n\n        // Check for fees being reasonable (see below for interpretation)\n        require(\n            _feeConfig[0] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeGovernance too high\"\n        );\n        require(\n            _feeConfig[1] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n        require(\n            _feeConfig[2] <= WITHDRAWAL_FEE_HARD_CAP,\n            \"withdrawalFee too high\"\n        );\n        require(\n            _feeConfig[3] <= MANAGEMENT_FEE_HARD_CAP,\n            \"managementFee too high\"\n        );\n\n        string memory name;\n        string memory symbol;\n\n        // If they are non empty string we'll use the custom names\n        // Else just add the default prefix\n        IERC20 namedToken = IERC20(_token);\n\n        if (keccak256(abi.encodePacked(_name)) != keccak256(\"\")) {\n            name = _name;\n        } else {\n            name = string(\n                abi.encodePacked(_defaultNamePrefix, namedToken.name())\n            );\n        }\n\n        if (keccak256(abi.encodePacked(_symbol)) != keccak256(\"\")) {\n            symbol = _symbol;\n        } else {\n            symbol = string(\n                abi.encodePacked(_symbolSymbolPrefix, namedToken.symbol())\n            );\n        }\n\n        // Initializing the lpcomponent token\n        __ERC20_init(name, symbol);\n        // Initialize the other contracts\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        treasury = _treasury;\n        strategist = _strategist;\n        keeper = _keeper;\n        guardian = _guardian;\n        badgerTree = _badgerTree;\n        vesting = _vesting;\n\n        lastHarvestedAt = block.timestamp; // setting initial value to the time when the vault was deployed\n\n        performanceFeeGovernance = _feeConfig[0];\n        performanceFeeStrategist = _feeConfig[1];\n        withdrawalFee = _feeConfig[2];\n        managementFee = _feeConfig[3];\n        maxPerformanceFee = PERFORMANCE_FEE_HARD_CAP; // 30% max performance fee\n        maxWithdrawalFee = WITHDRAWAL_FEE_HARD_CAP; // 2% maximum withdrawal fee\n        maxManagementFee = MANAGEMENT_FEE_HARD_CAP; // 2% maximum management fee\n\n        toEarnBps = 9_500; // initial value of toEarnBps // 95% is invested to the strategy, 5% for cheap withdrawals\n    }\n\n    /// ===== Modifiers ====\n\n    /// @notice Checks whether a call is from guardian or governance.\n    function _onlyAuthorizedPausers() internal view {\n        require(\n            msg.sender == guardian || msg.sender == governance,\n            \"onlyPausers\"\n        );\n    }\n\n    /// @notice Checks whether a call is from the strategy.\n    function _onlyStrategy() internal view {\n        require(msg.sender == strategy, \"onlyStrategy\");\n    }\n\n    /// ===== View Functions =====\n\n    /// @notice Used to track the deployed version of the contract.\n    /// @return Current version of the contract.\n    function version() external pure returns (string memory) {\n        return \"1.5\";\n    }\n\n    /// @notice Gives the price for a single Sett share.\n    /// @dev Sett starts with a price per share of 1.\n    /// @return Value of a single share.\n    function getPricePerFullShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return ONE_ETH;\n        }\n        return (balance() * ONE_ETH) / totalSupply();\n    }\n\n    /// @notice Gives the total balance of the underlying token within the sett and strategy system.\n    /// @return Balance of token handled by the sett.\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Defines how much of the Setts' underlying is available for strategy to borrow.\n    /// @return Amount of tokens that the sett can provide to the strategy.\n    function available() public view returns (uint256) {\n        return (token.balanceOf(address(this)) * toEarnBps) / MAX_BPS;\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _amount Quantity of tokens to deposit.\n    function deposit(uint256 _amount) external whenNotPaused {\n        _depositWithAuthorization(_amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling account is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _amount Quantity of tokens to deposit.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function deposit(uint256 _amount, bytes32[] memory proof)\n        external\n        whenNotPaused\n    {\n        _depositWithAuthorization(_amount, proof);\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    function depositAll() external whenNotPaused {\n        _depositWithAuthorization(\n            token.balanceOf(msg.sender),\n            new bytes32[](0)\n        );\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling is authorized to make a full deposit.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function depositAll(bytes32[] memory proof) external whenNotPaused {\n        _depositWithAuthorization(token.balanceOf(msg.sender), proof);\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(address _recipient, uint256 _amount)\n        external\n        whenNotPaused\n    {\n        _depositForWithAuthorization(_recipient, _amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Checks the guestlist to verify that `recipient` is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) external whenNotPaused {\n        _depositForWithAuthorization(_recipient, _amount, proof);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    /// @param _shares Quantity of shares to redeem.\n    function withdraw(uint256 _shares) external whenNotPaused {\n        _withdraw(_shares);\n    }\n\n    /// @notice Redeems all shares, issuing an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    function withdrawAll() external whenNotPaused {\n        _withdraw(balanceOf(msg.sender));\n    }\n\n    /// ===== Permissioned Actions: Strategy =====\n\n    /// @notice Used by the strategy to report a harvest to the sett.\n    ///         Issues shares for the strategist and treasury based on the performance fees and harvested amount.\n    ///         Issues shares for the treasury based on the management fee and the time elapsed since last harvest.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This implicitly trusts that the strategy reports the correct amount.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _harvestedAmount Amount of underlying token harvested by the strategy.\n    function reportHarvest(uint256 _harvestedAmount) external nonReentrant {\n        _onlyStrategy();\n\n        uint256 harvestTime = block.timestamp;\n        uint256 assetsAtHarvest = balance() - _harvestedAmount; // Must be less than or equal or revert\n\n        _handleFees(_harvestedAmount, harvestTime);\n\n        // Updated lastHarvestAmount\n        lastHarvestAmount = _harvestedAmount;\n\n        // if we withdrawAll\n        // we will have some yield left\n        // having 0 for assets will inflate APY\n        // Instead, have the last harvest report with the previous assets\n        // And if you end up harvesting again, that report will have both 0s\n        if (assetsAtHarvest != 0) {\n            assetsAtLastHarvest = assetsAtHarvest;\n        } else if (_harvestedAmount == 0) {\n            // If zero\n            assetsAtLastHarvest = 0;\n        }\n\n        lifeTimeEarned = lifeTimeEarned + _harvestedAmount;\n        // Update time either way\n        lastHarvestedAt = harvestTime;\n\n        emit Harvested(\n            address(token),\n            _harvestedAmount,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// @notice Used by the strategy to report harvest of additional tokens to the sett.\n    ///         Charges performance fees on the additional tokens and transfers fees to treasury and strategist.\n    ///         The remaining amount is sent to badgerTree for emissions.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This function is called after the strategy sends the additional tokens to the sett.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _token Address of additional token harvested by the strategy.\n    function reportAdditionalToken(address _token) external nonReentrant {\n        _onlyStrategy();\n        require(address(token) != _token, \"No want\");\n        uint256 tokenBalance = IERC20Upgradeable(_token).balanceOf(\n            address(this)\n        );\n\n        additionalTokensEarned[_token] =\n            additionalTokensEarned[_token] +\n            tokenBalance;\n        lastAdditionalTokenAmount[_token] = tokenBalance;\n\n        // We may have more, but we still report only what the strat sent\n        uint256 governanceRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeGovernance\n        );\n        uint256 strategistRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeStrategist\n        );\n\n        IERC20Upgradeable(_token).safeTransfer(treasury, governanceRewardsFee);\n        IERC20Upgradeable(_token).safeTransfer(\n            strategist,\n            strategistRewardsFee\n        );\n\n        // Send rest to tree\n        uint256 newBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n        IERC20Upgradeable(_token).safeTransfer(badgerTree, newBalance);\n        emit TreeDistribution(\n            _token,\n            newBalance,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n\n    /// @notice Changes the treasury address.\n    ///         Treasury is recipient of management and governance performance fees.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @param _treasury Address of the new treasury.\n    function setTreasury(address _treasury) external whenNotPaused {\n        _onlyGovernance();\n        require(_treasury != address(0), \"Address 0\");\n\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n    /// @notice Changes the strategy address.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @dev This is a rug vector, pay extremely close attention to the next strategy being set.\n    ///      Changing the strategy should happen only via timelock.\n    ///      This function must not be callable when the sett is paused as this would force depositors into a strategy they may not want to use.\n    /// @param _strategy Address of new strategy.\n    function setStrategy(address _strategy) external whenNotPaused {\n        _onlyGovernance();\n        require(_strategy != address(0), \"Address 0\");\n\n        /// NOTE: Migrate funds if settings strategy when already existing one\n        if (strategy != address(0)) {\n            require(\n                IStrategy(strategy).balanceOf() == 0,\n                \"Please withdrawToVault before changing strat\"\n            );\n        }\n        strategy = _strategy;\n        emit SetStrategy(_strategy);\n    }\n\n    // === Setters that can be called by governance even when paused ===\n\n    /// @notice Sets the max withdrawal fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `WITHDRAWAL_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for withdrawal fee.\n    function setMaxWithdrawalFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= WITHDRAWAL_FEE_HARD_CAP, \"withdrawalFee too high\");\n\n        maxWithdrawalFee = _fees;\n        emit SetMaxWithdrawalFee(_fees);\n    }\n\n    /// @notice Sets the max performance fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `PERFORMANCE_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for performance fee.\n    function setMaxPerformanceFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(\n            _fees <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n\n        maxPerformanceFee = _fees;\n        emit SetMaxPerformanceFee(_fees);\n    }\n\n    /// @notice Sets the max management fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `MANAGEMENT_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for management fee.\n    function setMaxManagementFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= MANAGEMENT_FEE_HARD_CAP, \"managementFee too high\");\n\n        maxManagementFee = _fees;\n        emit SetMaxManagementFee(_fees);\n    }\n\n    /// @notice Changes the guardian address.\n    ///         Guardian is an authorized actor that can pause the sett in case of an emergency.\n    ///         This can only be called by governance.\n    /// @param _guardian Address of the new guardian.\n    function setGuardian(address _guardian) external {\n        _onlyGovernance();\n        require(_guardian != address(0), \"Address cannot be 0x0\");\n\n        guardian = _guardian;\n        emit SetGuardian(_guardian);\n    }\n\n    /// @notice Changes the vesting contract address.\n    ///         Vesting contract is used to vest withdrawn tokens linearly over period of 21 days\n    ///         This can only be called by governance.\n    /// @param _vesting Address of the new guardian.\n    function setVesting(address _vesting) external {\n        _onlyGovernance();\n        require(_vesting != address(0), \"Address cannot be 0x0\");\n\n        vesting = _vesting;\n        emit SetVesting(_vesting);\n    }\n\n    /// ===== Permissioned Functions: Trusted Actors =====\n\n    /// @notice Sets the fraction of sett balance (in basis points) that the strategy can borrow.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _newToEarnBps The new maximum cap for management fee.\n    function setToEarnBps(uint256 _newToEarnBps) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_newToEarnBps <= MAX_BPS, \"toEarnBps should be <= MAX_BPS\");\n\n        toEarnBps = _newToEarnBps;\n        emit SetToEarnBps(_newToEarnBps);\n    }\n\n    /// @notice Changes the guestlist address.\n    ///         The guestList is used to gate or limit deposits. If no guestlist is set then anyone can deposit any amount.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _guestList Address of the new guestlist.\n    function setGuestList(address _guestList) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        guestList = IBadgerGuestlist(_guestList);\n        emit SetGuestList(_guestList);\n    }\n\n    /// @notice Sets the withdrawal fee charged by the Sett.\n    ///         The fee is taken at the time of withdrawals in the underlying token which is then used to issue new shares for the treasury.\n    ///         The new withdrawal fee should be less than `maxWithdrawalFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_withdraw` to see how withdrawal fee is charged.\n    /// @param _withdrawalFee The new withdrawal fee.\n    function setWithdrawalFee(uint256 _withdrawalFee) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_withdrawalFee <= maxWithdrawalFee, \"Excessive withdrawal fee\");\n        withdrawalFee = _withdrawalFee;\n        emit SetWithdrawalFee(_withdrawalFee);\n    }\n\n    /// @notice Sets the performance fee taken by the strategist on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the strategist.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeStrategist The new performance fee.\n    function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeStrategist <= maxPerformanceFee,\n            \"Excessive strategist performance fee\"\n        );\n        performanceFeeStrategist = _performanceFeeStrategist;\n        emit SetPerformanceFeeStrategist(_performanceFeeStrategist);\n    }\n\n    /// @notice Sets the performance fee taken by the treasury on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the treasury.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeGovernance The new performance fee.\n    function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeGovernance <= maxPerformanceFee,\n            \"Excessive governance performance fee\"\n        );\n        performanceFeeGovernance = _performanceFeeGovernance;\n        emit SetPerformanceFeeGovernance(_performanceFeeGovernance);\n    }\n\n    /// @notice Sets the management fee taken by the treasury on the AUM in the sett.\n    ///         The fee is calculated at the time of `reportHarvest` and is used to issue new shares for the treasury.\n    ///         The new management fee should be less than `maxManagementFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_handleFees` to see how the management fee is calculated.\n    /// @param _fees The new management fee.\n    function setManagementFee(uint256 _fees) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_fees <= maxManagementFee, \"Excessive management fee\");\n        managementFee = _fees;\n        emit SetManagementFee(_fees);\n    }\n\n    /// === Strategist level operations that can be done even when paused ==\n\n    /// @notice Withdraws all funds from the strategy back to the sett.\n    ///         This can be called by either governance or strategist.\n    /// @dev This calls `_withdrawAll` on the strategy and transfers the balance to the sett.\n    function withdrawToVault() external {\n        _onlyGovernanceOrStrategist();\n        IStrategy(strategy).withdrawToVault();\n    }\n\n    /// @notice Sends balance of any extra token earned by the strategy (from airdrops, donations etc.)\n    ///         to the badgerTree for emissions.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev See `BaseStrategy.emitNonProtectedToken` for details.\n    /// @param _token Address of the token to be emitted.\n    function emitNonProtectedToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n\n        IStrategy(strategy).emitNonProtectedToken(_token);\n    }\n\n    /// @notice Sweeps the balance of an extra token from the vault and strategy and sends it to governance.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev Sweeping doesn't take any fee.\n    /// @param _token Address of the token to be swept.\n    function sweepExtraToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n        require(address(token) != _token, \"No want\");\n\n        IStrategy(strategy).withdrawOther(_token);\n        // Send all `_token` we have\n        // Safe because `withdrawOther` will revert on protected tokens\n        // Done this way works for both a donation to strategy or to vault\n        IERC20Upgradeable(_token).safeTransfer(\n            governance,\n            IERC20Upgradeable(_token).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Deposits the available balance of the underlying token into the strategy.\n    ///         The strategy then uses the amount for yield-generating activities.\n    ///         This can be called by either the keeper or governance.\n    ///         Note that earn cannot be called when deposits are paused.\n    /// @dev Pause is enforced at the Strategy level (this allows to still earn yield when the Vault is paused)\n    function earn() external {\n        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused, we don't earn as well\n        _onlyAuthorizedActors();\n\n        uint256 _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).earn();\n    }\n\n    /// @notice Pauses only deposits.\n    ///         This can be called by either guardian or governance.\n    function pauseDeposits() external {\n        _onlyAuthorizedPausers();\n        pausedDeposit = true;\n        emit PauseDeposits(msg.sender);\n    }\n\n    /// @notice Unpauses deposits.\n    ///         This can only be called by governance.\n    function unpauseDeposits() external {\n        _onlyGovernance();\n        pausedDeposit = false;\n        emit UnpauseDeposits(msg.sender);\n    }\n\n    /// @notice Pauses everything.\n    ///         This can be called by either guardian or governance.\n    function pause() external {\n        _onlyAuthorizedPausers();\n        _pause();\n    }\n\n    /// @notice Unpauses everything\n    ///         This can only be called by governance.\n    function unpause() external {\n        _onlyGovernance();\n        _unpause();\n    }\n\n    /// ===== Internal Implementations =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when `pausedDeposit` is true.\n    /// @dev This is the actual deposit operation.\n    ///      Deposits are based on the realized value of underlying assets between Sett & associated Strategy\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function _depositFor(address _recipient, uint256 _amount)\n        internal\n        nonReentrant\n    {\n        require(_recipient != address(0), \"Address 0\");\n        require(_amount != 0, \"Amount 0\");\n        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused\n\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _mintSharesFor(_recipient, _after - _before, _pool);\n    }\n\n    /// @dev See `_depositWithAuthorization`\n    function _depositWithAuthorization(uint256 _amount, bytes32[] memory proof)\n        internal\n    {\n        _depositForWithAuthorization(msg.sender, _amount, proof);\n    }\n\n    /// @dev Verifies that `_recipient` is authorized to deposit `_amount` based on the guestlist.\n    ///      See `_depositFor` for deposit details.\n    function _depositForWithAuthorization(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) internal {\n        if (address(guestList) != address(0)) {\n            require(\n                guestList.authorized(_recipient, _amount, proof),\n                \"GuestList: Not Authorized\"\n            );\n        }\n        _depositFor(_recipient, _amount);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    /// @dev This is the actual withdraw operation.\n    ///      Withdraws from strategy positions if sett doesn't contain enough tokens to process the withdrawal.\n    ///      Calculates withdrawal fees and issues corresponding shares to treasury.\n    ///      No rebalance implementation for lower fees and faster swaps\n    /// @param _shares Quantity of shares to redeem.\n    function _withdraw(uint256 _shares) internal nonReentrant {\n        require(_shares != 0, \"0 Shares\");\n\n        uint256 r = (balance() * _shares) / totalSupply();\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 b = token.balanceOf(address(this));\n        if (b < r) {\n            uint256 _toWithdraw = r - b;\n            IStrategy(strategy).withdraw(_toWithdraw);\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after - b;\n            if (_diff < _toWithdraw) {\n                r = b + _diff;\n            }\n        }\n\n        uint256 _fee = _calculateFee(r, withdrawalFee);\n        uint256 _amount = r - _fee;\n\n        // Send funds to vesting contract and setup vesting\n        IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);\n        token.safeTransfer(vesting, _amount);\n\n        // After you burned the shares, and you have sent the funds, adding here is equivalent to depositing\n        // Process withdrawal fee\n        if(_fee > 0) {\n            _mintSharesFor(treasury, _fee, balance() - _fee);\n        }\n    }\n\n    /// @dev Helper function to calculate fees.\n    /// @param amount Amount to calculate fee on.\n    /// @param feeBps The fee to be charged in basis points.\n    /// @return Amount of fees to take.\n    function _calculateFee(uint256 amount, uint256 feeBps)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (feeBps == 0) {\n            return 0;\n        }\n        uint256 fee = (amount * feeBps) / MAX_BPS;\n        return fee;\n    }\n\n    /// @dev Helper function to calculate governance and strategist performance fees. Make sure to use it to get paid!\n    /// @param _amount Amount to calculate fee on.\n    /// @return Tuple containing amount of (governance, strategist) fees to take.\n    function _calculatePerformanceFee(uint256 _amount)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        uint256 governancePerformanceFee = _calculateFee(\n            _amount,\n            performanceFeeGovernance\n        );\n\n        uint256 strategistPerformanceFee = _calculateFee(\n            _amount,\n            performanceFeeStrategist\n        );\n\n        return (governancePerformanceFee, strategistPerformanceFee);\n    }\n\n    /// @dev Helper function to issue shares to `recipient` based on an input `_amount` and `_pool` size.\n    /// @param recipient Address to issue shares to.\n    /// @param _amount Amount to issue shares on.\n    /// @param _pool Pool size to use while calculating amount of shares to mint.\n    function _mintSharesFor(\n        address recipient,\n        uint256 _amount,\n        uint256 _pool\n    ) internal {\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply()) / _pool;\n        }\n        _mint(recipient, shares);\n    }\n\n    /// @dev Helper function that issues shares based on performance and management fee when a harvest is reported.\n    /// @param _harvestedAmount The harvested amount to take fee on.\n    /// @param harvestTime Time of harvest (block.timestamp).\n    function _handleFees(uint256 _harvestedAmount, uint256 harvestTime)\n        internal\n    {\n        (\n            uint256 feeGovernance,\n            uint256 feeStrategist\n        ) = _calculatePerformanceFee(_harvestedAmount);\n        uint256 duration = harvestTime - lastHarvestedAt;\n\n        // Management fee is calculated against the assets before harvest, to make it fair to depositors\n        uint256 management_fee = managementFee > 0\n            ? (managementFee * (balance() - _harvestedAmount) * duration) /\n                SECS_PER_YEAR /\n                MAX_BPS\n            : 0;\n        uint256 totalGovernanceFee = feeGovernance + management_fee;\n\n        // Pool size is the size of the pool minus the fees, this way\n        // it's equivalent to sending the tokens as rewards after the harvest\n        // and depositing them again\n        uint256 _pool = balance() - totalGovernanceFee - feeStrategist;\n\n        // uint != is cheaper and equivalent to >\n        if (totalGovernanceFee != 0) {\n            _mintSharesFor(treasury, totalGovernanceFee, _pool);\n        }\n\n        if (feeStrategist != 0 && strategist != address(0)) {\n            /// NOTE: adding feeGovernance backed to _pool as shares would have been issued for it.\n            _mintSharesFor(\n                strategist,\n                feeStrategist,\n                _pool + totalGovernanceFee\n            );\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "StakedCitadel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StakedCitadel.sol:291-295,772-776,881-893",
                "Type": "StakedCitadel doesn't use correct balance for internal accounting",
                "Description": "The StakedCitadel contract's balance() function is supposed to return the balance of the vault + the balance of the strategy. But, it only returns the balance of the vault. The balance is used to determine the number of shares that should be minted when depositing funds into the vault and the number of shares that should be burned when withdrawing funds from it.",
                "Repair": "Add the strategy's balance to the return value of the balance() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/badger/IVault.sol\";\nimport \"./interfaces/erc20/IERC20.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport \"./interfaces/citadel/IMedianOracle.sol\";\n\n/**\n * @notice Sells a token at a predetermined price to whitelisted buyers.\n * TODO: Better revert strings\n */\ncontract Funding is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // Roles used from GAC\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE = keccak256(\"TREASURY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_VAULT_ROLE =\n        keccak256(\"TREASURY_VAULT_ROLE\");\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    uint256 public constant MAX_BPS = 10000;\n\n    IERC20 public citadel; /// token to distribute (in vested xCitadel form)\n    IVault public xCitadel; /// wrapped citadel form that is actually distributed\n    IERC20 public asset; /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n\n    uint256 public citadelPriceInAsset; /// asset per citadel price eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public minCitadelPriceInAsset; /// Lower bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    uint256 public maxCitadelPriceInAsset; /// Upper bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    bool public citadelPriceFlag; /// Flag citadel price for review by guardian if it exceeds min and max bounds;\n\n    uint256 public assetDecimalsNormalizationValue;\n\n    address public citadelPriceInAssetOracle;\n    address public saleRecipient;\n\n    struct FundingParams {\n        uint256 discount;\n        uint256 minDiscount;\n        uint256 maxDiscount;\n        address discountManager;\n        uint256 assetCumulativeFunded; /// persistent sum of asset amount in over lifetime of contract.\n        uint256 assetCap; /// Max asset token that can be taken in by the contract (defines the cap for citadel sold)\n    }\n\n    FundingParams public funding;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    // TODO: we should conform to some interface here\n    event Deposit(\n        address indexed buyer,\n        uint256 assetIn,\n        uint256 citadelOutValue\n    );\n\n    event CitadelPriceInAssetUpdated(uint256 citadelPrice);\n\n    event CitadelPriceBoundsSet(uint256 minPrice, uint256 maxPrice);\n    event CitadelPriceFlag(uint256 price, uint256 minPrice, uint256 maxPrice);\n\n    event SaleRecipientUpdated(address indexed recipient);\n    event AssetCapUpdated(uint256 assetCap);\n\n    event Sweep(address indexed token, uint256 amount);\n    event ClaimToTreasury(address indexed token, uint256 amount);\n\n    modifier onlyCitadelPriceInAssetOracle() {\n        require(\n            msg.sender == citadelPriceInAssetOracle,\n            \"onlyCitadelPriceInAssetOracle\"\n        );\n        _;\n    }\n\n    event DiscountLimitsSet(uint256 minDiscount, uint256 maxDiscount);\n    event DiscountSet(uint256 discount);\n    event DiscountManagerSet(address discountManager);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _gac Global access control\n     * @param _citadel The token this contract will return in a trade\n     * @param _asset The token this contract will receive in a trade\n     * @param _xCitadel Staked citadel, citadel will be granted to funders in this form\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _assetCap The max asset that the contract can take\n     */\n    function initialize(\n        address _gac,\n        address _citadel,\n        address _asset,\n        address _xCitadel,\n        address _saleRecipient,\n        address _citadelPriceInAssetOracle,\n        uint256 _assetCap\n    ) external initializer {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: 0 sale\"\n        );\n        require(\n            _citadelPriceInAssetOracle != address(0),\n            \"Funding: 0 oracle\"\n        );\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadel = IERC20(_citadel);\n        xCitadel = IVault(_xCitadel);\n        asset = IERC20(_asset);\n        saleRecipient = _saleRecipient;\n\n        citadelPriceInAssetOracle = _citadelPriceInAssetOracle;\n\n        funding = FundingParams(0, 0, 0, address(0), 0, _assetCap);\n\n        assetDecimalsNormalizationValue = 10**asset.decimals();\n\n        // No circuit breaker on price by default\n        minCitadelPriceInAsset = 0;\n        maxCitadelPriceInAsset = type(uint256).max;\n\n        // Allow to deposit in vault\n        // Done last for reEntrancy concerns\n        IERC20(_citadel).safeApprove(address(_xCitadel), type(uint256).max);\n    }\n\n    modifier onlyWhenPriceNotFlagged() {\n        require(\n            citadelPriceFlag == false,\n            \"Funding: citadel price from oracle flagged and pending review\"\n        );\n        _;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_assetAmountIn` of `asset` for `citadel`\n     * @param _assetAmountIn Amount of `asset` to give\n     * @param _minCitadelOut ID of DAO to vote for\n     * @return citadelAmount_ Amount of `xCitadel` bought\n     */\n    function deposit(uint256 _assetAmountIn, uint256 _minCitadelOut)\n        external\n        onlyWhenPriceNotFlagged\n        gacPausable\n        nonReentrant\n        returns (uint256 citadelAmount_)\n    {\n        require(_assetAmountIn > 0, \"_assetAmountIn must not be 0\");\n        require(\n            funding.assetCumulativeFunded + _assetAmountIn <= funding.assetCap,\n            \"asset funding cap exceeded\"\n        );\n        funding.assetCumulativeFunded = funding.assetCumulativeFunded + _assetAmountIn;\n        // Take in asset from user\n        citadelAmount_ = getAmountOut(_assetAmountIn);\n        require(citadelAmount_ >= _minCitadelOut, \"minCitadelOut\");\n\n        asset.safeTransferFrom(msg.sender, saleRecipient, _assetAmountIn);\n        \n        // Deposit xCitadel and send to user\n        // TODO: Check gas costs. How does this relate to market buying if you do want to deposit to xCTDL?\n        xCitadel.depositFor(msg.sender, citadelAmount_);\n\n        emit Deposit(\n            msg.sender,\n            _assetAmountIn,\n            citadelAmount_\n        );\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `asset`\n     * @param _assetAmountIn Amount of `asset` to exchange\n     * @return citadelAmount_ Amount of `citadel` received\n     */\n    function getAmountOut(uint256 _assetAmountIn)\n        public\n        view\n        returns (uint256 citadelAmount_)\n    {\n        uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;\n\n        if (funding.discount > 0) {\n            citadelAmount_ =\n                (citadelAmountWithoutDiscount * MAX_BPS) /\n                (MAX_BPS - funding.discount);\n        }\n\n        citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;\n    }\n\n    /**\n     * @notice Get the amount received when exchanging `asset`, in terms of xCitadel at current price per share\n     * @param _assetAmountIn Amount of `asset` to exchange\n     * @return xCitadelAmount_ Amount of `xCitadel` received at current price per share\n     */\n    function getStakedCitadelAmountOut(uint256 _assetAmountIn) public view returns (uint256 xCitadelAmount_) {\n        uint citadelAmount = getAmountOut(_assetAmountIn);\n        xCitadelAmount_ = citadelAmount * 10**citadel.decimals() / xCitadel.getPricePerFullShare();\n    }\n\n    /**\n     * @notice Check how much `asset` can still be taken in, based on cap and cumulative amount funded\n     * @return limitLeft_ Amount of `asset` that can still be exchanged for citadel\n     */\n    function getRemainingFundable() external view returns (uint256 limitLeft_) {\n        uint256 assetCumulativeFunded = funding.assetCumulativeFunded;\n        uint256 assetCap = funding.assetCap;\n        if (assetCumulativeFunded < assetCap) {\n            limitLeft_ = assetCap - assetCumulativeFunded;\n        }\n    }\n\n    /**\n     * @notice Get all funding params\n     * @return funding all funding params\n     */\n    function getFundingParams() external view returns (FundingParams memory) {\n        return funding;\n    }\n\n    /**\n     * @notice Convenience function to get current discount rate\n     * @return discount current discount rate\n     */\n    function getDiscount() external view returns (uint256) {\n        return funding.discount;\n    }\n\n    /// ==============================\n    /// ===== Policy Ops actions =====\n    /// ==============================\n\n    /**\n     * @notice Set discount manually, within the constraints of min and max discount values\n     * @dev managed by policy operations for rapid response to market conditions\n     * @param _discount active discount (in bps)\n     */\n    function setDiscount(uint256 _discount)\n        external\n        gacPausable\n        onlyRoleOrAddress(POLICY_OPERATIONS_ROLE, funding.discountManager)\n    {\n        require(_discount >= funding.minDiscount, \"discount < minDiscount\");\n        require(_discount <= funding.maxDiscount, \"discount > maxDiscount\");\n\n        funding.discount = _discount;\n\n        emit DiscountSet(_discount);\n    }\n\n    function clearCitadelPriceFlag()\n        external\n        gacPausable\n        onlyRole(POLICY_OPERATIONS_ROLE)\n    {\n        citadelPriceFlag = false;\n    }\n\n    /**\n     * @notice Modify the max asset amount that this contract can take. Managed by policy governance.\n     * @dev This is cumulative asset cap, so must take into account the asset amount already funded.\n     * @param _assetCap New max cumulatiive amountIn\n     */\n    function setAssetCap(uint256 _assetCap)\n        external\n        gacPausable\n        onlyRole(POLICY_OPERATIONS_ROLE)\n    {\n        require(\n            _assetCap > funding.assetCumulativeFunded,\n            \"cannot decrease cap below global sum of assets in\"\n        );\n        funding.assetCap = _assetCap;\n        emit AssetCapUpdated(_assetCap);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `asset` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `asset`. For `citadel`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token)\n        external\n        gacPausable\n        nonReentrant\n        onlyRole(TREASURY_OPERATIONS_ROLE)\n    {\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        require(amount > 0, \"nothing to sweep\");\n        require(\n            _token != address(asset),\n            \"cannot sweep funding asset, use claimAssetToTreasury()\"\n        );\n\n        emit Sweep(_token, amount);\n        IERC20(_token).safeTransfer(saleRecipient, amount);\n    }\n\n    /// @notice Claim accumulated asset token to treasury\n    /// @dev We let assets accumulate and batch transfer to treasury (rather than transfer atomically on each deposi)t for user gas savings\n    function claimAssetToTreasury()\n        external\n        gacPausable\n        onlyRole(TREASURY_OPERATIONS_ROLE)\n    {\n        uint256 amount = asset.balanceOf(address(this));\n        require(amount > 0, \"nothing to claim\");\n        asset.safeTransfer(saleRecipient, amount);\n\n        emit ClaimToTreasury(address(asset), amount);\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice Set minimum and maximum discount\n     * @dev managed by contract governance to place constraints around the parameter for policy operations to play within\n     * @param _minDiscount minimum discount (in bps)\n     * @param _maxDiscount maximum discount (in bps)\n     */\n    function setDiscountLimits(uint256 _minDiscount, uint256 _maxDiscount)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(_maxDiscount < MAX_BPS , \"maxDiscount >= MAX_BPS\");\n        funding.minDiscount = _minDiscount;\n        funding.maxDiscount = _maxDiscount;\n\n        emit DiscountLimitsSet(_minDiscount, _maxDiscount);\n    }\n\n    /**\n     * @notice Set a discount manager address\n     * @dev This is intended to be used for an automated discount manager contract to supplement or replace manual calls\n     * @param _discountManager discount manager address\n     */\n    function setDiscountManager(address _discountManager)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        funding.discountManager = _discountManager;\n\n        emit DiscountManagerSet(_discountManager);\n    }\n\n    function setSaleRecipient(address _saleRecipient)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    function setCitadelAssetPriceBounds(uint256 _minPrice, uint256 _maxPrice)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        minCitadelPriceInAsset = _minPrice;\n        maxCitadelPriceInAsset = _maxPrice;\n\n        emit CitadelPriceBoundsSet(_minPrice, _maxPrice);\n    }\n\n    /// ==========================\n    /// ===== Oracle actions =====\n    /// ==========================\n\n    /// @notice Update citadel price in asset terms from oracle source\n    /// @dev Note that the oracle mechanics are abstracted to the oracle address\n    function updateCitadelPriceInAsset()\n        external\n        gacPausable\n        onlyRole(KEEPER_ROLE)\n    {   \n        uint _citadelPriceInAsset;\n        bool _valid;\n\n        (_citadelPriceInAsset, _valid) = IMedianOracle(citadelPriceInAssetOracle).getData();\n\n        require(_citadelPriceInAsset > 0, \"citadel price must not be zero\");\n        require(_valid, \"oracle data must be valid\");\n\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n            citadelPriceInAsset = _citadelPriceInAsset;\n            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);\n        }\n    }\n\n\n    /// @dev OUT OF AUDIT SCOPE: This is a test function that will be removed in final code\n    /// @notice Update citadel price in asset terms from oracle source\n    /// @dev Note that the oracle mechanics are abstracted to the oracle address\n    function updateCitadelPriceInAsset(uint256 _citadelPriceInAsset)\n        external\n        gacPausable\n        onlyCitadelPriceInAssetOracle\n    {\n        require(_citadelPriceInAsset > 0, \"citadel price must not be zero\");\n\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n            citadelPriceInAsset = _citadelPriceInAsset;\n            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.12;\n\nimport {BaseFixture} from \"./BaseFixture.sol\";\nimport {SupplySchedule} from \"../SupplySchedule.sol\";\nimport {GlobalAccessControl} from \"../GlobalAccessControl.sol\";\nimport {Funding} from \"../Funding.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport \"../interfaces/erc20/IERC20.sol\";\n\ncontract FundingTest is BaseFixture {\n    using FixedPointMathLib for uint;\n\n    function setUp() public override {\n        BaseFixture.setUp();\n    }\n    \n    function testDiscountRateBasics() public {\n        /** \n        @fatima: confirm the discount rate is functional\n        - access control for setting discount rate (i.e. the proper accounts can call the function and it works. improper accounts revert when attempting to call)\n        - access control for setting discount rate limits\n        - pausing freezes these functions appropriately\n    */\n\n        // calling from correct account\n        vm.prank(address(governance));\n        fundingCvx.setDiscountLimits(10, 50);\n        vm.prank(address(policyOps));\n        fundingCvx.setDiscount(20);\n        (uint256 discount,uint256 minDiscount,uint256 maxDiscount,,,) = fundingCvx.funding();\n        // check if discount is set\n        assertEq(discount,20);\n\n        // setting discount above maximum limit\n\n        vm.prank(address(policyOps));\n        vm.expectRevert(bytes(\"discount > maxDiscount\"));\n        fundingCvx.setDiscount(60);\n\n        // setting discount below minimum limit\n        vm.prank(address(policyOps));\n        vm.expectRevert(bytes(\"discount < minDiscount\"));\n        fundingCvx.setDiscount(5);\n\n        // calling setDiscount from a different account\n        vm.prank(address(1));\n        vm.expectRevert(bytes(\"GAC: invalid-caller-role-or-address\"));\n        fundingCvx.setDiscount(20);\n\n        // - access control for setting discount rate limits\n\n        // calling with correct role\n        vm.prank(address(governance));\n        fundingCvx.setDiscountLimits(0, 50);\n        (,minDiscount,maxDiscount,,,) = fundingCvx.funding();\n\n        // checking if limits are set\n        assertEq(minDiscount,0);\n        assertEq(maxDiscount, 50);\n\n        // check discount can not be greater than or equal to MAX_BPS\n        vm.prank(address(governance));\n        vm.expectRevert(bytes(\"maxDiscount >= MAX_BPS\"));\n        fundingCvx.setDiscountLimits(0, 10000);\n\n        // calling with wrong address\n        vm.prank(address(1));\n        vm.expectRevert(bytes(\"GAC: invalid-caller-role\"));\n        fundingCvx.setDiscountLimits(0,20);\n\n        // - pausing freezes these functions appropriately\n        vm.prank(guardian);\n        gac.pause();\n        vm.prank(address(governance));\n        vm.expectRevert(bytes(\"global-paused\"));\n        fundingCvx.setDiscountLimits(0, 50);\n        vm.prank(address(policyOps));\n        vm.expectRevert(bytes(\"global-paused\"));\n        fundingCvx.setDiscount(10);\n\n    }\n\n    function testDiscountRateBuys() public{\n        _testDiscountRateBuys(fundingCvx, cvx, 100e18, 5000, 100e18 );\n\n    }\n\n    function testBuyDifferentDecimals() public {\n        // wBTC is an 8 decimal example\n        // TODO: Fix comparator calls in inner function as per that functions comment\n        _testDiscountRateBuys(fundingWbtc, wbtc, 2e8, 2000, 2e8 );\n\n    }\n\n    function testSetAssetCap() public{\n        vm.prank(address(1));\n        vm.expectRevert(\"GAC: invalid-caller-role\");\n        fundingCvx.setAssetCap(10e18);\n\n        // setting asset cap from correct account\n        vm.prank(policyOps);\n        fundingCvx.setAssetCap(1000e18);\n        (,,,,,uint256 assetCap) = fundingCvx.funding();\n        assertEq(assetCap, 1000e18); // check if assetCap is set\n\n        // checking assetCap can not be less than accumulated funds.\n         _testDiscountRateBuys(fundingCvx, cvx, 100e18, 3000, 100e18 );\n        vm.prank(policyOps);\n        vm.expectRevert(\"cannot decrease cap below global sum of assets in\");\n        fundingCvx.setAssetCap(10e18);\n    }\n\n    function testFailClaimAssetToTreasury() public{\n\n        vm.prank(address(1));\n        vm.expectRevert(\"GAC: invalid-caller-role\");\n        fundingCvx.claimAssetToTreasury();\n\n        uint256 amount = cvx.balanceOf(address(fundingCvx));\n        uint256 balanceBefore = cvx.balanceOf(fundingCvx.saleRecipient());\n\n        vm.prank(treasuryOps);\n        fundingCvx.claimAssetToTreasury();\n\n        uint256 balanceAfter = cvx.balanceOf(fundingCvx.saleRecipient());\n\n        // check the difference of saleRecipient's balance is equal to the amount\n        assertEq(amount, balanceAfter-balanceBefore);\n\n    }\n\n    function testSweep() public {\n        \n        vm.stopPrank();\n        vm.prank(address(1));\n        vm.expectRevert(\"GAC: invalid-caller-role\");\n        fundingCvx.sweep(address(cvx));\n\n        vm.prank(treasuryOps);\n        vm.expectRevert(\"nothing to sweep\");\n        fundingCvx.sweep(address(cvx));\n\n    }\n    function testAccessControl() public{\n        // tests to check access controls of various set functions\n        \n        vm.prank(address(1));\n        vm.expectRevert(\"GAC: invalid-caller-role\");\n        fundingCvx.setDiscountManager(address(2));\n\n        // setting discountManager from correct account\n        vm.prank(governance);\n        fundingCvx.setDiscountManager(address(2));\n        (,,,address discountManager,,) = fundingCvx.funding();\n        assertEq(discountManager, address(2)); // check if discountManager is set\n\n        vm.prank(address(1));\n        vm.expectRevert(\"onlyCitadelPriceInAssetOracle\");\n        fundingCvx.updateCitadelPriceInAsset(1000);\n\n        // setting citadelPriceInAsset from correct account\n        vm.prank(eoaOracle);\n        fundingCvx.updateCitadelPriceInAsset(1000);\n        assertEq(fundingCvx.citadelPriceInAsset(), 1000); // check if citadelPriceInAsset is set\n        \n        vm.prank(eoaOracle);\n        vm.expectRevert(\"citadel price must not be zero\");\n        fundingCvx.updateCitadelPriceInAsset(0);\n\n        vm.prank(address(1));\n        vm.expectRevert(\"GAC: invalid-caller-role\");\n        fundingCvx.setSaleRecipient(address(2));\n\n        // setting setSaleRecipient from correct account\n        vm.prank(governance);\n        fundingCvx.setSaleRecipient(address(2));\n        assertEq(fundingCvx.saleRecipient(), address(2)); // check if SaleRecipient is set\n        \n        vm.prank(governance);\n        vm.expectRevert(\"Funding: sale recipient should not be zero\");\n        fundingCvx.setSaleRecipient(address(0));\n    }\n    \n    function testDepositModifiers() public{\n        // pausing should freeze deposit\n        vm.prank(guardian);\n        gac.pause();\n        vm.expectRevert(bytes(\"global-paused\"));\n        fundingCvx.deposit(10e18 , 0);\n        vm.prank(address(techOps));\n        gac.unpause();\n\n        // flagging citadelPriceFlag should freeze deposit\n        vm.prank(governance);\n        fundingCvx.setCitadelAssetPriceBounds(0, 5000);\n        vm.prank(eoaOracle);\n        fundingCvx.updateCitadelPriceInAsset(6000);\n        vm.expectRevert(bytes(\"Funding: citadel price from oracle flagged and pending review\"));\n        fundingCvx.deposit(10e18 , 0);\n\n    }\n\n    function _testDiscountRateBuys(Funding fundingContract, IERC20 token, uint256 _assetAmountIn, uint32 discount, uint256 citadelPrice) public {\n        \n        /**\n            @fatima: this is a good candidate to generalize using fuzzing: test buys with various discount rates, using fuzzing, and confirm the results.\n            sanity check the numerical results (tokens in vs tokens out, based on price and discount rate)\n        */ \n\n        vm.assume(discount<10000 && _assetAmountIn>0 && citadelPrice>0);  // discount < MAX_BPS = 10000 \n\n        vm.prank(address(governance));\n        fundingContract.setDiscountLimits(0, 9999);\n        \n        vm.prank(address(policyOps));\n        fundingContract.setDiscount(discount); // set discount\n\n        vm.prank(eoaOracle);\n        fundingContract.updateCitadelPriceInAsset(citadelPrice); // set citadel price\n\n        uint256 citadelAmountOutExpected = fundingContract.getAmountOut(_assetAmountIn);\n\n        vm.prank(governance);\n        citadel.mint(address(fundingContract), citadelAmountOutExpected ); // fundingContract should have citadel to transfer to user\n\n        address user = address(1) ;\n        vm.startPrank(user);\n        erc20utils.forceMintTo(user, address(token) , _assetAmountIn );\n        token.approve(address(fundingContract), _assetAmountIn);\n        uint256 citadelAmountOut = fundingContract.deposit(_assetAmountIn , 0);\n        vm.stopPrank();\n\n        // check citadelAmoutOut is same as expected\n        assertEq(citadelAmountOut , citadelAmountOutExpected);\n\n    }\n    \n    function _testBuy(Funding fundingContract, uint assetIn, uint citadelPrice) internal {\n        // just make citadel appear rather than going through minting flow here\n        erc20utils.forceMintTo(address(fundingContract), address(citadel), 100000e18);\n        \n        vm.prank(eoaOracle);\n\n        // CVX funding contract gives us an 18 decimal example\n        fundingContract.updateCitadelPriceInAsset(citadelPrice);\n\n        uint expectedAssetOut = assetIn.divWadUp(citadelPrice);\n        \n        emit log_named_uint(\"Citadel Price\", citadelPrice);\n\n        vm.startPrank(whale);\n\n        require(cvx.balanceOf(whale) >= assetIn, \"buyer has insufficent assets for specified buy amount\");\n        require(citadel.balanceOf(address(fundingContract)) >= expectedAssetOut, \"funding has insufficent citadel for specified buy amount\");\n\n        comparator.snapPrev();\n        cvx.approve(address(fundingContract), cvx.balanceOf(whale));\n\n        fundingContract.deposit(assetIn, 0);\n        comparator.snapCurr();\n\n        uint expectedAssetLost = assetIn;\n        uint expectedxCitadelGained = citadelPrice;\n\n        // user trades in asset for citadel in xCitadel form.\n        assertEq(comparator.diff(\"citadel.balanceOf(whale)\"), 0);\n        assertEq(comparator.diff(\"xCitadel.balanceOf(whale)\"), expectedAssetOut);\n        assertEq(comparator.negDiff(\"cvx.balanceOf(whale)\"), assetIn);\n        \n        // funding contract loses citadel and sends asset to saleRecipient. should never hold an xCitadel balance (deposited for each user) (gas costs?)\n\n        // TODO: Improve comparator to easily add new entity for all balance calls.\n        assertEq(comparator.negDiff(\"citadel.balanceOf(fundingCvx)\"), expectedAssetOut);\n        assertEq(comparator.diff(\"cvx.balanceOf(treasuryVault)\"), assetIn);\n        \n        assertEq(xCitadel.balanceOf(address(fundingContract)), 0);\n\n        vm.stopPrank();\n    }\n }\n\n\n",
        "CodeNames": [
            "Funding.sol",
            "Funding.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Funding.sol:427-437",
                "Type": "Stale price used when citadelPriceFlag is cleared",
                "Description": "If an oracle price falls out of the valid min/max range, the citadelPriceFlag is set to true, but the out-of-bounds value is not stored. If the policy operations team calls clearCitadelPriceFlag(), the stale price from before the flag will be used.",
                "Repair": "Always set the citadelPriceInAsset"
            }
        ]
    }
]