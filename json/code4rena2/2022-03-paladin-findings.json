[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./open-zeppelin/ERC20.sol\";\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\nimport \"./open-zeppelin/utils/Math.sol\";\n\n/** @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20(\"Holy Paladin Token\", \"hPAL\"), Ownable {\n    using SafeERC20 for IERC20;\n\n\n    /** @notice Seconds in a Week */\n    uint256 public constant WEEK = 604800;\n    /** @notice Seconds in a Month */\n    uint256 public constant MONTH = 2629800;\n    /** @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    /** @notice Max BPS value (100%) */\n    uint256 public constant MAX_BPS = 10000;\n    /** @notice Seconds in a Year */\n    uint256 public constant ONE_YEAR = 31557600;\n\n    /** @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    /** @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  */\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n\n    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n\n    /** @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    /** @notice Maximum duration of a Lock  */\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n\n    /** @notice Address of the PAL token  */\n    IERC20 public immutable pal;\n\n    /** @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n\n    /** @notice Array of all user Locks, ordered from oldest to newest  */\n    mapping(address => UserLock[]) public userLocks;\n\n    /** @notice Struct trancking the total amount locked  */\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n\n    /** @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    /** @notice List of TotalLocks, ordered from oldest to newest  */\n    TotalLock[] public totalLocks;\n\n    /** @notice User Cooldowns  */\n    mapping(address => uint256) public cooldowns;\n\n    /** @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    /** @notice Checkpoints for users Delegates  */\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n\n    /** @notice mapping tracking the Delegator for each Delegatee  */\n    mapping(address => address) public delegates;\n\n    /** @notice List of Vote checkpoints for each user  */\n    mapping(address => Checkpoint[]) public checkpoints;\n\n    /** @notice List of Delegate checkpoints for each user  */\n    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;\n\n    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */\n    uint256 public kickRatioPerWeek = 1000;\n\n    /** @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n\n    /** @notice Allow emergency withdraws  */\n    bool public emergency = false;\n\n    /** @notice Address of the vault holding the PAL rewards  */\n    address public immutable rewardsVault;\n\n    /** @notice Global reward index  */\n    uint256 public rewardIndex;\n    /** @notice Timstamp of last update for global reward index  */\n    uint256 public lastRewardUpdate;\n\n    /** @notice Amount of rewards distriubted per second at the start  */\n    uint256 public immutable startDropPerSecond;\n    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    /** @notice Current amount of rewards distriubted per second  */\n    uint256 public currentDropPerSecond;\n    /** @notice Timestamp of last update for currentDropPerSecond  */\n    uint256 public lastDropUpdate;\n    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    /** @notice Timestamp: start of the DropPerSecond decrease period  */\n    uint256 public immutable startDropTimestamp;\n\n    /** @notice Last reward index for each user  */\n    mapping(address => uint256) public userRewardIndex;\n    /** @notice Current amount of rewards claimable for the user  */\n    mapping(address => uint256) public claimableRewards;\n    /** @notice Timestamp of last update for user rewards  */\n    mapping(address => uint256) public rewardsLastUpdate;\n\n    /** @notice Base reward multiplier for lock  */\n    uint256 public immutable baseLockBonusRatio;\n    /** @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    /** @notice Maximum reward multiplier for maximum duration  */\n    uint256 public immutable maxLockBonusRatio;\n\n    /** @notice Last updated Bonus Ratio for rewards  */\n    mapping(address => uint256) public userCurrentBonusRatio;\n    /** @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address => uint256) public userBonusRatioDecrease;\n\n    /** @notice Error raised if contract is turned in emergency mode */\n    error EmergencyBlock(); \n\n    // Event\n\n    /** @notice Emitted when an user stake PAL in the contract */\n    event Stake(address indexed user, uint256 amount);\n    /** @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    /** @notice Emitted when an user triggers the cooldown period */\n    event Cooldown(address indexed user);\n    /** @notice Emitted when an user creates or update its Lock */\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    /** @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    /** @notice Emitted when an user is kicked out of the Lock */\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    /** @notice Emitted when an user claim the rewards */\n    event ClaimRewards(address indexed user, uint256 amount);\n    /** @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    /** @notice Emitted when the votes of a delegate is updated */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    /** @notice Emitted when un user withdraw through the emergency method */\n    event EmergencyUnstake(address indexed user, uint256 amount);\n\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n\n        pal = IERC20(palToken);\n\n        transferOwnership(_admin);\n\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n\n        currentDropPerSecond = _startDropPerSecond;\n\n        dropDecreaseDuration = _dropDecreaseDuration;\n\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution & DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n\n    /**\n     * @notice Deposits PAL & mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n\n    /**\n     * @notice Updates the Cooldown for the caller\n     */\n    function cooldown() external {\n        require(balanceOf(msg.sender) > 0, \"hPAL: No balance\");\n\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n\n        emit Cooldown(msg.sender);\n    }\n\n    /**\n     * @notice Burns hPAL & withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     */\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n\n    /**\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n\n    /**\n     * @notice Increase the user current Lock duration (& restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     */\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n\n    /**\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     */\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n\n    /**\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n\n    /**\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     */\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, \"hPAL: cannot kick yourself\");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n\n    /**\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it's done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n\n    /**\n     * @notice Stake more PAL into hPAL & add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it's done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n\n    /**\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     */\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     */\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n\n        require(amount > 0, \"hPAL: incorrect amount\");\n\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n\n    /**\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n\n    /**\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     */\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n\n    // ---------------\n\n    /**\n     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     */\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n\n    /**\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n\n    /**\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     */\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n\n    /**\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     */\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n\n    /**\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n\n    /**\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     */\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n\n    /**\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     */\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber < block.number,\n            \"hPAL: invalid blockNumber\"\n        );\n\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n\n        uint256 nbCheckpoints = totalLocks.length;\n\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock > blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n\n    /**\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n\n    /**\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     */\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n\n    /**\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     */\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // & in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n\n        if(lastRewardUpdate < block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n\n        estimatedClaimableRewards += accruedRewards;\n\n        return estimatedClaimableRewards;\n    }\n\n    /**\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n\n    /**\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     */\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n\n        if(nbLocks == 0) return currentVotes;\n\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n\n        return currentVotes + bonusVotes;\n    }\n\n    /**\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     */\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n\n        return votes + bonusVotes;\n    }\n\n    /**\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber < block.number,\n            \"hPAL: invalid blockNumber\"\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {\n            return address(0);\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    // ----------------\n\n    // Find the user available balance (staked - locked) => the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates => decrease duration is over\n        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n\n            return endDropPerSecond;\n        }\n\n        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n\n        // We calculate the new dropPerSecond value\n        // We don't want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n\n        return newDropPerSecond;\n    }\n\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n\n        // DropPerSeond without any multiplier => the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n\n        return rewardIndex + ratio;\n    }\n\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n\n        // Update (if needed) & get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n\n        return newIndex;\n    }\n\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index & current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n\n        if(userLastIndex != currentRewardsIndex){\n\n            if(balanceOf(user) > 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n\n                uint256 lockingRewards = 0;\n\n                if(userLocks[user].length > 0){\n                    UserLockRewardVars memory vars;\n\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n\n                    // Check that the user's Lock is not empty\n                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n\n                        if(vars.previousBonusRatio > 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n\n                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                vars.bonusRatioDecrease = vars.previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n\n                            // and calculate the locking rewards based on the locked balance & \n                            // a ratio based on the rpevious one and the newly calculated one\n                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);\n                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;\n                        }\n                    }\n\n                }\n                // sum up the accrued rewards, and return it\n                accruedRewards = stakingRewards + lockingRewards;\n            }\n        }\n    }\n\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n\n        // Called for minting & burning, but we don't want to update for address 0x0\n        if(user == address(0)) return;\n\n        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block\n\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        rewardsLastUpdate[user] = block.timestamp;\n        userRewardIndex[user] = newIndex;\n\n    }\n\n    /** @dev Hook called before any transfer */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            require(amount <= _availableBalanceOf(from), \"hPAL: Available balance too low\");\n        }\n\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n\n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // => we don't want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n\n            uint256 previousToBalance = balanceOf(to);\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n        }\n\n        // If from transfer all of its balance, reset the cooldown to 0\n        uint256 previousFromBalance = balanceOf(from);\n        if(previousFromBalance == amount && fromCooldown != 0) {\n            cooldowns[from] = 0;\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender & the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        require(\n            blockNumber < block.number,\n            \"hPAL: invalid blockNumber\"\n        );\n\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock > blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        require( blockNumber < block.number, \"hPAL: invalid blockNumber\");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock > blockNumber) return 0;\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n\n    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {\n        require(blockNumber < block.number, \"hPAL: invalid blockNumber\");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n\n        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n\n    // -----------------\n\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        require(amount > 0, \"hPAL: Null amount\");\n\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n\n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n\n        emit Stake(user, amount);\n\n        return amount;\n    }\n\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        require(amount > 0, \"hPAL: Null amount\");\n        require(receiver != address(0), \"hPAL: Address Zero\");\n\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), \"hPAL: Insufficient cooldown\");\n        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, \"hPAL: unstake period expired\");\n\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;\n\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit Unstake(user, burnAmount);\n\n        return burnAmount;\n    }\n\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown < minValidCooldown) return 0;\n\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;\n\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown < receiverCooldown) return receiverCooldown;\n\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n\n    }\n\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(amount != 0, \"hPAL: Null amount\");\n        uint256 userBalance = balanceOf(user);\n        require(amount <= userBalance, \"hPAL: Amount over balance\");\n        require(duration >= MIN_LOCK_DURATION, \"hPAL: Lock duration under min\");\n        require(duration <= MAX_LOCK_DURATION, \"hPAL: Lock duration over max\");\n\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n\n            // Update total locked supply\n            currentTotalLocked += amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            uint256 currentUserLockIndex = userLocks[user].length - 1;\n            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n            uint256 startTimestamp = block.timestamp;\n\n            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                require(amount >=  currentUserLock.amount,\"hPAL: smaller amount\");\n                require(duration >=  currentUserLock.duration,\"hPAL: smaller duration\");\n\n                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n            }\n\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n            }\n\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(userLocks[user].length > 0, \"hPAL: No Lock\");\n\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp > userCurrentLockEnd, \"hPAL: Not expired\");\n        require(currentUserLock.amount > 0, \"hPAL: No Lock\");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Set the user Lock as an empty Lock\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n\n    function _kick(address user, address kicker) internal {\n        require(user != address(0) && kicker != address(0), \"hPAL: Address Zero\");\n        require(userLocks[user].length > 0, \"hPAL: No Lock\");\n\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp > userCurrentLockEnd, \"hPAL: Not expired\");\n        require(currentUserLock.amount > 0, \"hPAL: No Lock\");\n\n        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, \"hPAL: Not kickable\");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Set an empty Lock for the user\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        // update the the Delegate chekpoint for the delegatee\n        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n\n    /**\n     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     */\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n\n        require(emergency, \"hPAL: Not emergency\");\n\n        require(amount > 0, \"hPAL: Null amount\");\n        require(receiver != address(0), \"hPAL: Address Zero\");\n\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n\n            // To remove the Lock and update the total locked\n            currentTotalLocked -= currentUserLock.amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            userLocks[msg.sender].push(UserLock(\n                safe128(0),\n                safe48(block.timestamp),\n                safe48(0),\n                safe32(block.number)\n            ));\n        }\n\n        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;\n\n        _burn(msg.sender, burnAmount);\n\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit EmergencyUnstake(msg.sender, burnAmount);\n\n        return burnAmount;\n\n    }\n\n    // Utils\n\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n\n    function safe32(uint n) internal pure returns (uint32) {\n        if(n > type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n > type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n > type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n > type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n\n    // Admin methods\n\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n\n    /**\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n\n    /**\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     */\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n\n    /**\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     */\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n}\n\n",
        "CodeNames": [
            "HolyPaladinToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "EmergencyWithdraw function in HolyPaladinToken.sol at line 1338",
                "Type": "Updating the state",
                "Description": "userCurrentBonusRatio and durationRatio aren't updated which will allow users to claim funds with the wrong ratio.",
                "Repair": "Set userCurrentBonusRatio and durationRatio to zero in the EmergencyWithdraw function"
            },
            {
                "Location": "HolyPaladinToken.sol at lines 253, 284, and 268",
                "Type": "System could be wrapped and made useless without contract whitelisting",
                "Description": "Anyone could create a contract or a contract factory 'PAL Locker' with a function to deposit PAL tokens through a contract, lock them, and delegate the voting power to the contract owner. Then, the ownership of this contract could be sold, which would eventually break the overall system of hPAL.",
                "Repair": "Implement a whitelisting/blacklisting system for contracts"
            },
            {
                "Location": "HolyPaladinToken.sol at lines 446-468",
                "Type": "UserLock information can be found during emergency mode",
                "Description": "When the contract is in blocked state (emergency mode), the protocol wants to return an empty UserLock info, on calling the function getUserLock. However, there is another way, by which the users can find the same information.",
                "Repair": "Add additional user access check, so that the function returns correct value when the caller (msg.sender) is admin or owner"
            },
            {
                "Location": "HolyPaladinToken.sol at line 1425",
                "Type": "Emergency mode enable/disable issue",
                "Description": "Enabling emergency mode should be a one-way process that sets contract(s) in emergency mode. It should not be possible to revert that process, otherwise, it puts the owner of the contract(s) in a very privileged position.",
                "Repair": "Remove bool trigger parameter from triggerEmergencyWithdraw function and set emergency to true after successfully executing function"
            },
            {
                "Location": "HolyPaladinToken.sol at transferFrom function",
                "Type": "ERC20 token with a highly unsafe pattern",
                "Description": "The transferFrom() function does not follow the Checks Effect and Interactions safety pattern to safely make external calls to other contracts.",
                "Repair": "Follow the Checks Effects and Interactions safety pattern as the transferFrom function is one of the most important functions in any protocol. Consider importing the Open Zeppelin ERC20.sol contract code directly as it is battle-tested and safe code"
            },
            {
                "Location": "Multiple functions in HolyPaladinToken.sol",
                "Type": "State Manipulation",
                "Description": "Multiple states with the same block number can be manipulated to present an incorrect history.",
                "Repair": "Adopt the same strategy as checkpoint, and modify last entry in array instead of pushing new one if it fromBlock == block.number."
            },
            {
                "Location": "Functions _beforeTokenTransfer() and _updateUserRewards() in HolyPaladinToken.sol",
                "Type": "Bypassing Emergency Restrictions",
                "Description": "Users can bypass emergency restrictions on the updateUserRewardState() function by transferring a small amount of unlocked tokens to their account.",
                "Repair": "Add a check for the boolean emergency value in _beforeTokenTransfer() to not call _updateUserRewards on any account if this value is set. Alternatively, a check could be added into the _updateUserRewards() function to return if emergency is true."
            },
            {
                "Location": "ONE_YEAR variable in HolyPaladinToken.sol",
                "Type": "incorrect variable value",
                "Description": "The ONE_YEAR variable in HolyPaladinToken.sol is set to an incorrect value, which can negatively affect users in functions that use this variable.",
                "Repair": "Change the value of ONE_YEAR variable to the correct number of seconds in a year (31,536,000)"
            },
            {
                "Location": "function cooldown() in HolyPaladinToken.sol",
                "Type": "unprotected function",
                "Description": "The cooldown() function in HolyPaladinToken.sol is not protected when the protocol is in emergency mode, allowing users to set the cooldown and plan for unstaking when the emergency mode is lifted.",
                "Repair": "Add a check for emergency mode to the cooldown() function"
            },
            {
                "Location": "function lock(uint256 amount, uint256 duration) in HolyPaladinToken.sol",
                "Type": "bonus ratio calculation",
                "Description": "If a user increases the lock amount on an expired lock, a new lock will be created with the duration of the previous lock and the provided non-zero amount. Because the userCurrentBonusRatio is not updated, the user will not receive any rewards for their active lock.",
                "Repair": "Prevent users from increasing the amount on an expired lock"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}\n\n\n",
        "CodeNames": [
            "PaladinRewardReserve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PaladinRewardReserve.sol",
                "Type": "Potential Bugs",
                "Description": "PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards.",
                "Repair": "(1) If PAL token is only used and other token will never be used at PaladinRewardReserve.sol, stop having address token argument at setNewSpender, updateSpenderAllowance, removeSpender and transferToken functions. Instead, set token at the constructor or other ways, and limit the ability to flexibly set token from functions.(2) If other tokens potentially will be used at PaladinRewardReserve.sol, update data structure of approvedSpenders mapping and change the logic."
            },
            {
                "Location": "PaladinRewardReserve.sol",
                "Type": "timelock",
                "Description": "The owner of PaladinRewardReserve can approve and transfer any amount of tokens with no limits on any account, which is not good for investors. To give more trust to users, these functions should be put behind a timelock.",
                "Repair": "Put the approve and transfer functions behind a timelock"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function _beforeTokenTransfer(address from, address to, uint256 amount)",
                "Type": "griefing attack",
                "Description": "Users with large cooldowns can grief other users by sending small amounts to them, increasing their cooldowns and preventing them from unstaking.",
                "Repair": "Implement a financial safeguard against griefing attacks by limiting the amount that can be transferred to a waiting account based on the receiver's balance"
            },
            {
                "Location": "function _beforeTokenTransfer(address from, address to, uint256 amount)",
                "Type": "cooldown reset",
                "Description": "If a user transfers all their tokens to themselves, the cooldown is reset to 0, preventing them from unstaking and extending the duration of the lock.",
                "Repair": "Do not reset cooldown to 0 when the user transfers all tokens to themselves"
            },
            {
                "Location": "function _updateDropPerSecond() internal",
                "Type": "Precision Loss",
                "Description": "Due to precision loss in calculating the number of months elapsed, for each _updateDropPerSecond() there can be a short of up to 1 * dropDecreasePerMonth for the decrease of emission rate.",
                "Repair": "Update the calculation of nbMonthEllapsed to include more precision"
            },
            {
                "Location": "function _getNewReceiverCooldown(uint256 senderCooldown, uint256 amount, address receiver, uint256 receiverBalance) internal view",
                "Type": "Assisted Unstaking",
                "Description": "Users at UNSTAKE_PERIOD can assist other users in unstaking tokens.",
                "Repair": "Reduce the Unstake Period to reduce the possibility of such scenario"
            }
        ]
    }
]