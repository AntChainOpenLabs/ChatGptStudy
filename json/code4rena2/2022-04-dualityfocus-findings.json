[
    {
        "Code": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\n// interfaces\nimport { ComptrollerInterface, TickOracleInterface, CErc20Interface } from \"../interfaces/CompoundInterfaces.sol\";\nimport \"../interfaces/IUniV3LpVault.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport { IFlashLoanReceiver } from \"../external/aave/AaveInterfaces.sol\";\nimport \"../external/openzeppelin/token/ERC721/IERC721.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/ISwapRouter.sol\";\n\n// libs\nimport \"../external/uniswap/v3-core/libraries/TransferHelper.sol\";\nimport \"../external/uniswap/v3-periphery/libraries/BytesLib.sol\";\nimport { Uint256Casting } from \"../external/opyn/Uint256Casting.sol\";\nimport { SafeMath } from \"../external/openzeppelin/math/SafeMath.sol\";\nimport \"../libs/LiquidityLibrary.sol\";\n\n/**\n * @title UniV3LpVault\n * @author Duality (h/t to Uniswap's UniswapV3Staker as a starting point)\n */\ncontract UniV3LpVault is IUniV3LpVault {\n    using SafeMath for uint256;\n    using Uint256Casting for uint256;\n    using BytesLib for bytes;\n\n    address public override factory;\n\n    INonfungiblePositionManager public override nonfungiblePositionManager;\n\n    ISwapRouter public override swapRouter;\n\n    ComptrollerInterface public override comptroller;\n\n    IFlashLoanReceiver public override flashLoan;\n\n    mapping(address => bool) public override flashLoanAuthorized;\n\n    /// @dev ownerOf[tokenId] => address owner\n    mapping(uint256 => address) public override ownerOf;\n\n    /// @dev userTokens[userAddress] => tokenIds[]\n    mapping(address => uint256[]) public userTokens;\n\n    /// @notice max number of userTokens for a single userAddress\n    uint256 public override userTokensMax = 4;\n\n    /// @notice whether or not periphery functionality has been paused\n    bool public peripheryGuardianPaused;\n\n    /// @notice whether or not deposits have been paused\n    bool public depositGuardianPaused;\n\n    /// @dev Guard variable for re-entrancy checks\n    bool internal _notEntered;\n\n    constructor(\n        address _factory,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        ISwapRouter _swapRouter,\n        ComptrollerInterface _comptroller\n    ) {\n        factory = _factory;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        swapRouter = _swapRouter;\n        comptroller = _comptroller;\n        _notEntered = true;\n    }\n\n    /*** External Mutator Functions ***/\n\n    /// @dev Upon receiving a Uniswap V3 ERC721, creates the token deposit setting owner to `from`\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override nonReentrant(false) returns (bytes4) {\n        require(!depositGuardianPaused, \"deposit is paused\");\n        require(msg.sender == address(nonfungiblePositionManager), \"IUniV3LpVault::onERC721Received: not a Uni V3 nft\");\n\n        _processNewToken(tokenId, from);\n        emit TokenDeposited(from, tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @notice Withdraw a tokenId from the vault, so long as the caller's debt is still sufficiently collateralized\n     * @param tokenId The tokenId of the NFT to be withdrawn\n     * @param to The address to send tokenId to\n     * @param data any data to provide for the safeTransferFrom call\n     */\n    function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes memory data\n    ) external override nonReentrant(false) avoidsShortfall {\n        require(to != address(this), \"IUniV3LpVault::withdrawToken: cannot withdraw to vault\");\n        require(ownerOf[tokenId] == msg.sender, \"IUniV3LpVault::withdrawToken: only owner can withdraw token\");\n\n        _deleteOldToken(msg.sender, tokenId);\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n        emit TokenWithdrawn(msg.sender, to, tokenId);\n    }\n\n    /**\n     * @notice Seize fees and/or liquidity from a borrower's LP NFT, assuming the seizure is allowed.\n     *          To be called exclusively from the CToken of the debt asset (Best mirroring original compound liquidation path)\n     * @param liquidator The address of the EOA/Contract claiming the liquidation + incentive\n     * @param borrower The address of the account currently in shortfall. Owner of tokenId.\n     * @param tokenId The tokenId to be partially or fully liquidated. Owned by Borrower.\n     * @param seizeFeesToken0 The amount of token0 to seize from tokenId's fees\n     * @param seizeFeesToken1 The amount of token1 to seize from tokenId's fees\n     * @param seizeLiquidity The amount of liquidity to convert to token0/token1 and seize\n     */\n    function seizeAssets(\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external override nonReentrant(true) {\n        require(ownerOf[tokenId] == borrower, \"borrower must own tokenId\");\n\n        // make call to comptroller to ensure seize is allowed\n        uint256 allowed = ComptrollerInterface(comptroller).seizeAllowedUniV3(\n            address(this),\n            msg.sender,\n            liquidator,\n            borrower,\n            tokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n\n        // TODO: do we want some Comptroller like error handling/messaging here?\n        require(allowed == 0, \"seize not allowed according to Comptroller\");\n\n        if (seizeLiquidity > 0) {\n            // liquidate seizeLiquidity from tokenId position\n            _decreaseLiquidity(tokenId, uint128(seizeLiquidity));\n\n            // claim all fees + tokens from liquidity removal\n            nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams(tokenId, liquidator, type(uint128).max, type(uint128).max)\n            );\n        } else {\n            // claim feesAmountToken0 and feesAmountToken1 and send to liquidator\n            nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams(\n                    tokenId,\n                    liquidator,\n                    uint128(seizeFeesToken0),\n                    uint128(seizeFeesToken1)\n                )\n            );\n        }\n    }\n\n    // TODO: do we want a \"decreaseLiquidityAndCollect\" function?\n\n    /**\n     * @notice Passthrough function to NonfungiblePositionManager for an owner of an NFT to decrease its liquidity.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     * @param params INonfungiblePositionManager's decreaseLiquidityParams for the passthrough call\n     */\n    function decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        nonfungiblePositionManager.decreaseLiquidity(params);\n        emit LiquidityDecreased(msg.sender, params.tokenId, params.liquidity);\n    }\n\n    /**\n     * @notice Passthrough function to NonfungiblePositionManager for an owner of an NFT to collect its fees.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     * @param params INonfungiblePositionManager's CollectParams for the passthrough call\n     */\n    function collectFees(INonfungiblePositionManager.CollectParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        (uint256 amount0, uint256 amount1) = nonfungiblePositionManager.collect(params);\n        emit FeesCollected(msg.sender, params.tokenId, amount0, amount1);\n    }\n\n    /**\n     * @notice function for an owner of an NFT to automatically compound fees into liquidity of a range.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     *\n     *          Target balance of fees for swap are pre-computed off-chain along with slippage tolerance.\n     *\n     *          Swap is made by swapping the extra of token0 (according to expectedAmount0) to token1, depositing\n     *          the max liquidity possible (along with min checks), and any remnants left are sent back to the user\n     *\n     * @param params our CompoundFeesParams, described at definition in the interface\n     */\n    function compoundFees(CompoundFeesParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        // collect all fees\n        (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n        address token0;\n        address token1;\n\n        {\n            // avoid stack too deep\n            uint24 fee;\n            (, , token0, token1, fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n            // trade assets to expectedAmounts (assuming correct off-chain computation)\n            (amount0, amount1) = _prepareForDeposit(\n                token0,\n                token1,\n                fee,\n                params.expectedAmount0,\n                params.expectedAmount1,\n                amount0,\n                amount1\n            );\n        }\n\n        // attempt to deposit amount0 and amount1 into our range\n        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(\n            params.tokenId,\n            token0,\n            token1,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min\n        );\n\n        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;\n        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;\n\n        // send back remnants to user\n        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);\n        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);\n        emit FeesCompounded(msg.sender, params.tokenId, amountTaken0, amountTaken1, amountReturned0, amountReturned1);\n    }\n\n    /**\n     * @notice function for an owner of an NFT to move liquidity of one range into a new range.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     *\n     *          Target balance of fees for swap are pre-computed off-chain along with slippage tolerance.\n     *\n     *          Swap is made by swapping the extra of token0 (according to expectedAmount0) to token1, depositing\n     *          the max liquidity possible (along with min checks), and any remnants left are sent back to the user\n     *\n     * @param params our MoveRangeParams, described at definition in the interface\n     * @return newTokenId The tokenId of our new Uni V3 LP position\n     */\n    function moveRange(MoveRangeParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 newTokenId)\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        // remove params.liquidity from token (moves to token's fees)\n        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);\n\n        // collect all fees (includes decreased liquidity)\n        (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n        (, , address token0, address token1, uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(\n            params.tokenId\n        );\n\n        // trade assets to expectedAmounts (assuming correct off-chain computation)\n        (amount0, amount1) = _prepareForDeposit(\n            token0,\n            token1,\n            fee,\n            params.expectedAmount0,\n            params.expectedAmount1,\n            amount0,\n            amount1\n        );\n\n        // prepare mintParams\n        INonfungiblePositionManager.MintParams memory mintParams = INonfungiblePositionManager.MintParams(\n            token0,\n            token1,\n            fee,\n            params.newTickLower,\n            params.newTickUpper,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min,\n            msg.sender, // _mint utilizes this appropriately\n            block.timestamp + 200\n        );\n\n        // burn old token if emptied\n        (, , , , , , , uint128 newLiquidity, , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n        if (newLiquidity == 0) _burn(msg.sender, params.tokenId);\n\n        {\n            uint256 amountTaken0;\n            uint256 amountTaken1;\n\n            // mint new range\n            (newTokenId, amountTaken0, amountTaken1) = _mint(mintParams);\n\n            // send back remnants to user\n            if (amount0 > amountTaken0) TransferHelper.safeTransfer(token0, msg.sender, amount0.sub(amountTaken0));\n            if (amount1 > amountTaken1) TransferHelper.safeTransfer(token1, msg.sender, amount1.sub(amountTaken1));\n        }\n\n        emit RangeMoved(msg.sender, params.tokenId, newTokenId, params.liquidity, newLiquidity == 0);\n    }\n\n    /**\n     * @notice function only to be called by flashloan contract initiated from the NFT owner\n     * @param params our MoveRangeParams, described at definition in the interface\n     */\n    function flashFocusCall(FlashFocusParams calldata params) external override {\n        address owner = ownerOf[params.tokenId];\n        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n        bool tokenOfPool = params.asset == token0 || params.asset == token1;\n\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        require(msg.sender == address(flashLoan), \"Can only be called from our flashLoan contract\");\n        require(flashLoanAuthorized[owner], \"flashLoan action must have been authorized by tokenId owner\");\n        require(\n            tokenOfPool || params.swapPath.length > 0,\n            \"flashLoaned asset must be a pool asset or swapping to token0\"\n        );\n        require(_checkSwapPath(params.swapPath, params.asset, token0), \"swapPath did not pass integrity check\");\n\n        flashLoanAuthorized[owner] = false;\n\n        // transfer flashLoaned assets to vault\n        IERC20Detailed(params.asset).transferFrom(msg.sender, address(this), params.amount);\n\n        uint256 amount0;\n        uint256 amount1;\n\n        {\n            // creating local scope, avoiding stack too deep\n\n            // calculate our starting amounts of each asset\n            uint256 amountIn0 = params.asset == token0 ? params.amount : 0;\n            uint256 amountIn1 = params.asset == token1 ? params.amount : 0;\n\n            // swap everything to token0 if swap path is provided and params.asset is neither of the tokens\n            if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);\n\n            (, , , , uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n            // trade assets to expectedAmounts (assuming correct off-chain computation)\n            (amount0, amount1) = _prepareForDeposit(\n                token0,\n                token1,\n                fee,\n                params.expectedAmount0,\n                params.expectedAmount1,\n                amountIn0,\n                amountIn1\n            );\n        }\n\n        // attempt to deposit amount0 and amount1 into our range\n        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(\n            params.tokenId,\n            token0,\n            token1,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min\n        );\n\n        {\n            // another local scope :)\n            uint256 owedBack = params.amount.add(params.premium);\n\n            // borrow the flashloaned asset in preparation for closing loan\n            uint256 success = CErc20Interface(comptroller.cTokensByUnderlying(params.asset)).borrowBehalf(\n                owner,\n                owedBack\n            );\n            require(success == 0, \"borrow failed\");\n\n            // approve borrowed assets for flashLoan to pull\n            IERC20Detailed(params.asset).approve(msg.sender, owedBack);\n        }\n\n        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;\n        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;\n\n        // send back remnants to user\n        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);\n        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);\n        emit FlashFocus(\n            msg.sender,\n            params.tokenId,\n            params.asset,\n            params.amount,\n            amountTaken0,\n            amountTaken1,\n            amountReturned0,\n            amountReturned1\n        );\n    }\n\n    /**\n     * @notice function for an owner of an NFT to be able enter into a focused position in one click.\n     *          Allows a user, via flashloan, to open debt and re-deposit as liquidity into their NFT range\n     *          up to max leverage in one tx.\n     *          Reentrancy guard must be local, or split up around call to CToken\n     * @param params our FlashFocusParams, described at definition in the interface\n     */\n    function flashFocus(FlashFocusParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        address receiverAddress = address(flashLoan);\n\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        uint256[] memory modes = new uint256[](1);\n\n        assets[0] = params.asset;\n        amounts[0] = params.amount;\n        modes[0] = 0;\n\n        address onBehalfOf = address(this);\n        bytes memory newParams = abi.encode(params);\n        uint16 referralCode = 0;\n\n        flashLoanAuthorized[msg.sender] = true;\n        flashLoan.LENDING_POOL().flashLoan(\n            receiverAddress,\n            assets,\n            amounts,\n            modes,\n            onBehalfOf,\n            newParams,\n            referralCode\n        );\n    }\n\n    /**\n     * @notice function for an owner of an NFT to be able to repay a debt using an NFT in one click.\n     *          Allows a user to repay debt by removing liquidity / fees from an NFT and swapping to\n     *          the debt token in one tx.\n     * @param params our RepayDebtParams, described at definition in the interface\n     * @return amountReturned The amount of the debtToken returned to the function caller\n     */\n    function repayDebt(RepayDebtParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 amountReturned)\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        require(comptroller.markets(params.debtCToken).isListed, \"Debt CToken must be listed by comptroller\");\n        require(\n            params.underlying == CErc20Interface(params.debtCToken).underlying(),\n            \"Underlying must match CToken underlying\"\n        );\n\n        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n        require(_checkSwapPath(params.swapPath0, token0, params.underlying), \"swapPath0 did not pass integrity check\");\n        require(_checkSwapPath(params.swapPath1, token1, params.underlying), \"swapPath1 did not pass integrity check\");\n\n        // remove params.liquidity from token (moves to token's fees)\n        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);\n\n        uint256 amountOutTotal;\n\n        {\n            // collect all fees (includes decreased liquidity)\n            (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n            // calculate the totalAmount of debt asset we have.\n            // check if token0 or token1 are the debt asset. otherwise, swap token0 and token1 to debt asset using swapPaths\n            uint256 amountOutFrom0 = token0 == params.underlying ? amount0 : 0;\n            uint256 amountOutFrom1 = token1 == params.underlying ? amount1 : 0;\n\n            if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);\n            if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);\n\n            // total amount of debtAsset we've collected to use towards repay\n            amountOutTotal = amountOutFrom0.add(amountOutFrom1);\n        }\n\n        require(\n            amountOutTotal > params.repayAmount,\n            \"not enough liquidity burned: Repay debt must repay repayAmount of debt\"\n        );\n\n        // repay the debt for user with new funds\n        IERC20Detailed(params.underlying).approve(address(params.debtCToken), params.repayAmount);\n        uint256 succeeded = CErc20Interface(params.debtCToken).repayBorrowBehalf(msg.sender, params.repayAmount);\n        require(succeeded == 0, \"repay debt did not succeed\");\n        IERC20Detailed(params.underlying).approve(address(params.debtCToken), 0);\n\n        // return remnants to user\n        amountReturned = amountOutTotal > params.repayAmount ? amountOutTotal.sub(params.repayAmount) : 0;\n\n        if (amountReturned > 0) TransferHelper.safeTransfer(params.underlying, msg.sender, amountReturned);\n\n        emit RepayDebt(\n            msg.sender,\n            params.tokenId,\n            params.liquidity,\n            params.debtCToken,\n            params.underlying,\n            params.repayAmount,\n            amountReturned\n        );\n    }\n\n    /*** External View Functions ***/\n\n    /**\n     * @notice gets the length of UserTokens for an account. Allows comptroller to query NFTs for value\n     * @param account The address of the account we want the user tokens length for\n     * @return length The length of the user's userTokens array\n     */\n    function getUserTokensLength(address account) external view override returns (uint256 length) {\n        length = userTokens[account].length;\n    }\n\n    /**\n     * @notice gets the poolAddress for a deposited tokenId\n     * @param tokenId The tokenId to get the poolAddress of\n     * @return poolAddress The address of the pool the token is a deposit of\n     */\n    function getPoolAddress(uint256 tokenId) external view override returns (address poolAddress) {\n        poolAddress = _getPoolAddress(tokenId);\n    }\n\n    /*** Internal Mutator Functions ***/\n\n    /**\n     * @notice Internal function to prepare for a deposit liquidity into a Uni V3 range.\n     *          uses a pool to swap amount0 and amount1 to expectedAmount0 and expectedAmount1.\n     *          uses naive logic, assumes adequate off-chain computation for expectedAmounts\n     *\n     * @param token0 Address of token0\n     * @param token1 Address of token1\n     * @param fee Fee of the pool to swap with\n     * @param expectedAmount0 The amount of token0 that we expect to deposit into a range\n     * @param expectedAmount1 The amount of token1 that we expect to deposit into a range\n     * @param amount0 The amount of token0 that we currently hold and are preparing for deposit (some may be swapped for token1)\n     * @param amount1 The amount of token1 that we currently hold and are preparing for deposit (some may be swapped for token1)\n     * @return newAmount0 Amount of token0 after preparation\n     *         newAmount1 Amount of token1 after preparation\n     */\n    function _prepareForDeposit(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint256 expectedAmount0,\n        uint256 expectedAmount1,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint256 newAmount0, uint256 newAmount1) {\n        if (expectedAmount0 < amount0) {\n            // have extra token0, trade all of the extra to token1\n            uint256 amountOut = _swap(abi.encodePacked(token0, fee, token1), amount0.sub(expectedAmount0));\n            newAmount0 = expectedAmount0;\n            newAmount1 = amount1.add(amountOut);\n        } else if (expectedAmount1 < amount1) {\n            // have extra of token1, trade all of the extra to token0\n            uint256 amountOut = _swap(abi.encodePacked(token1, fee, token0), amount1.sub(expectedAmount1));\n            newAmount0 = amount0.add(amountOut);\n            newAmount1 = expectedAmount1;\n        } else {\n            newAmount0 = amount0;\n            newAmount1 = amount1;\n        }\n    }\n\n    /**\n     * @notice Executes a swap. Performs necessary approval beforehand, and zeros out afterwards for safety\n     * @param swapPath The path to swap along\n     * @param amount The amount of the first token to swap\n     */\n    function _swap(bytes memory swapPath, uint256 amount) internal returns (uint256 amountOut) {\n        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), amount);\n        amountOut = swapRouter.exactInput(\n            ISwapRouter.ExactInputParams(swapPath, address(this), block.timestamp + 200, amount, 0)\n        );\n        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), 0);\n    }\n\n    /**\n     * @notice Increases liquidity of a Uni V3 NFT\n     * @param tokenId The tokenId of the NFT we are depositing liquidity into\n     * @param token0 The address of the first token of the pool\n     * @param token1 The address of the second token of the pool\n     * @param amount0 The amount of token0 that we expect to deposit\n     * @param amount1 The amount of token1 that we expect to deposit\n     * @param amount0Min The min amount of token0 that we are willing to deposit (slippage check)\n     * @param amount1Min The min amount of token1 that we are willing to deposit (slippage check)\n     * @return amountOut0 Amount of token0 deposited into tokenId\n     *         amountOut1 Amount of token1 deposited into tokenId\n     */\n    function _increaseLiquidity(\n        uint256 tokenId,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) internal returns (uint256 amountOut0, uint256 amountOut1) {\n        IERC20Detailed(token0).approve(address(nonfungiblePositionManager), amount0);\n        IERC20Detailed(token1).approve(address(nonfungiblePositionManager), amount1);\n\n        // deposit liquidity into tokenId\n        (, amountOut0, amountOut1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams(\n                tokenId,\n                amount0,\n                amount1,\n                amount0Min,\n                amount1Min,\n                block.timestamp + 200\n            )\n        );\n\n        IERC20Detailed(token0).approve(address(nonfungiblePositionManager), 0);\n        IERC20Detailed(token1).approve(address(nonfungiblePositionManager), 0);\n    }\n\n    /**\n     * @notice Decreases liquidity of a Uni V3 NFT\n     * @param tokenId The tokenId of the NFT we are decreasing liquidity of\n     * @param liquidity The amount of liquidity that we will be decreasing of tokenId\n     */\n    function _decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal {\n        nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams(tokenId, liquidity, 0, 0, block.timestamp + 200)\n        );\n    }\n\n    /**\n     * @notice Collects the maximum amount of fees available from the NFT to this contract\n     * @param tokenId The tokenId of the NFT we are collecting fees from\n     */\n    function _collectMax(uint256 tokenId) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max)\n        );\n    }\n\n    /**\n     * @notice mints a fresh Uni V3 NFT on behalf of a user of this contract.\n     *          Ownership of the mint is replaced with this contract, and the new token is then processed as a new token\n     *          in this contract under the user's ownership\n     * @param params NonfungiblePositionManager's MintParams. Acts as a passthrough except for ownership management\n     */\n    function _mint(INonfungiblePositionManager.MintParams memory params)\n        internal\n        returns (\n            uint256 tokenId,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        IERC20Detailed(params.token0).approve(address(nonfungiblePositionManager), params.amount0Desired);\n        IERC20Detailed(params.token1).approve(address(nonfungiblePositionManager), params.amount1Desired);\n\n        (tokenId, , amount0, amount1) = nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams(\n                params.token0,\n                params.token1,\n                params.fee,\n                params.tickLower,\n                params.tickUpper,\n                params.amount0Desired,\n                params.amount1Desired,\n                params.amount0Min,\n                params.amount1Min,\n                address(this), // replace recipient, and denote owner on deposit entry\n                params.deadline\n            )\n        );\n\n        IERC20Detailed(params.token0).approve(address(nonfungiblePositionManager), 0);\n        IERC20Detailed(params.token1).approve(address(nonfungiblePositionManager), 0);\n\n        // process the token for our internal accounting with the correct recipient\n        _processNewToken(tokenId, params.recipient);\n    }\n\n    /**\n     * @notice burns a Uni V3 NFT on behalf of a user of this contract.\n     *          Manages accounting, deleting user ownership of this token in this contract\n     * @param user Address of the user we are burning the token on behalf of\n     * @param tokenId The Id of the Uni V3 NFT that we are burning\n     */\n    function _burn(address user, uint256 tokenId) internal {\n        _deleteOldToken(user, tokenId);\n        nonfungiblePositionManager.burn(tokenId);\n    }\n\n    /**\n     * @notice processes a new token, checking that the NFT deposit is valid and adding to contract accounting\n     *          on behalf of user\n     * @param tokenId The Id of the Uni V3 NFT being processed\n     * @param account Address of the user we are processing on behalf of\n     */\n    function _processNewToken(uint256 tokenId, address account) internal {\n        require(userTokens[account].length < userTokensMax, \"Cannot process new token: user has too many tokens\");\n        // get poolAddress via helper\n        address poolAddress = _getPoolAddress(tokenId);\n        require(\n            comptroller.isSupportedPool(poolAddress),\n            \"comptroller does not support this pool's liquidity as collateral\"\n        );\n\n        userTokens[account].push(tokenId);\n        ownerOf[tokenId] = account;\n    }\n\n    /**\n     * @notice deletes an old token from internal accounting\n     * @param user Address of the user we are deleting the token on behalf of\n     * @param tokenId The tokenId to be deleted from accounting\n     */\n    function _deleteOldToken(address user, uint256 tokenId) internal {\n        uint256[] memory userTokensArr = userTokens[user];\n        uint256 len = userTokensArr.length;\n        uint256 assetIndex = len;\n\n        for (uint256 i = 0; i < len; i++) {\n            if (userTokensArr[i] == tokenId) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        uint256[] storage storedList = userTokens[user];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        delete ownerOf[tokenId];\n    }\n\n    /*** Internal View Functions ***/\n\n    function _getPoolAddress(uint256 tokenId) internal view returns (address poolAddress) {\n        (, , address token0, address token1, uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(tokenId);\n        poolAddress = LiquidityLibrary._getPoolAddress(factory, token0, token1, fee);\n    }\n\n    /**\n     * @notice Checks that swapPath, if non-empty, starts and ends with the appropriate tokens.\n     *          Doesn't check that the swap path is of proper length, as this will be checked upon use in swapRouter\n     * @param swapPath The swapPath that we are checking\n     * @param tokenStart The expected starting point token of swapPath\n     * @param tokenEnd The expected ending point token of swapPath\n     * @return check The boolean result of whether or not the swapPath has passed our checks\n     */\n    function _checkSwapPath(\n        bytes memory swapPath,\n        address tokenStart,\n        address tokenEnd\n    ) internal pure returns (bool check) {\n        check =\n            swapPath.length == 0 ||\n            (swapPath.toAddress(0) == tokenStart && swapPath.toAddress(swapPath.length - 20) == tokenEnd);\n    }\n\n    /*** Modifiers ***/\n\n    // Need to ensure for all modifying functions that can decrease liquidity in this contract that we don't enter shortfall\n    modifier avoidsShortfall() {\n        _;\n        (, , uint256 shortfall) = comptroller.getAccountLiquidity(msg.sender);\n        require(shortfall == 0, \"insufficient liquidity\");\n    }\n\n    modifier isAuthorizedForToken(uint256 tokenId) {\n        require(ownerOf[tokenId] == msg.sender, \"sender must be owner of deposited tokenId\");\n        _;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice set state of whether or not vault deposits are paused\n     * @param state new value for whether deposits are paused\n     */\n    function _pauseDeposits(bool state) external override returns (bool) {\n        require(\n            msg.sender == comptroller.pauseGuardian() || msg.sender == comptroller.admin(),\n            \"only pause guardian and admin can pause\"\n        );\n        require(msg.sender == comptroller.admin() || state == true, \"only admin can unpause\");\n\n        depositGuardianPaused = state;\n        emit ActionPaused(\"Deposit\", state);\n        return state;\n    }\n\n    /**\n     * @notice set state of whether or not periphery UX functions are paused\n     * @param state new value for whether periphery UX functions are paused\n     */\n    function _pausePeripheryFunctions(bool state) external override returns (bool) {\n        require(\n            msg.sender == comptroller.pauseGuardian() || msg.sender == comptroller.admin(),\n            \"only pause guardian and admin can pause\"\n        );\n        require(msg.sender == comptroller.admin() || state == true, \"only admin can unpause\");\n\n        peripheryGuardianPaused = state;\n        emit ActionPaused(\"Periphery\", state);\n        return state;\n    }\n\n    /**\n     * @notice set new address for flashloan contract as a contract comptroller.admin()\n     * @param _flashLoan the new flashLoan contract's address\n     */\n    function _setFlashLoan(address _flashLoan) external override returns (address) {\n        require(msg.sender == comptroller.admin(), \"only admin can set FlashLoanContract\");\n        address oldFlashLoan = address(flashLoan);\n        flashLoan = IFlashLoanReceiver(_flashLoan);\n        emit NewFlashLoanContract(oldFlashLoan, _flashLoan);\n        return _flashLoan;\n    }\n\n    /**\n     * @notice set new userTokensMax as a contract comptroller.admin()\n     * @param _userTokensMax the new value for userTokensMax\n     */\n    function _setUserTokensMax(uint256 _userTokensMax) external override returns (uint256) {\n        require(msg.sender == comptroller.admin(), \"only admin can set new userTokensMax\");\n        uint256 oldUserTokensMax = userTokensMax;\n        userTokensMax = _userTokensMax;\n        emit NewUserTokensMax(oldUserTokensMax, _userTokensMax);\n        return userTokensMax;\n    }\n\n    /**\n     * @notice Removes tokens accidentally sent to this vault.\n     * @param token address of token to sweep\n     * @param to address to send token to\n     * @param amount amount to token to sweep\n     */\n    function _sweep(\n        address token,\n        address to,\n        uint256 amount\n    ) external override {\n        require(msg.sender == comptroller.admin(), \"only admin can sweep assets\");\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /**\n     * @notice Removes NFTs accidentally sent to this vault.\n     * @param nftContract address of nftContract\n     * @param tokenId tokenId of NFT to sweep\n     * @param to address to send NFT to\n     */\n    function _sweepNFT(\n        address nftContract,\n        address to,\n        uint256 tokenId\n    ) external override {\n        require(msg.sender == comptroller.admin(), \"only admin can sweep nft assets\");\n        require(\n            nftContract != address(nonfungiblePositionManager) || ownerOf[tokenId] == address(0),\n            \"only NFTs not belonging to depositors can be swept\"\n        );\n        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @notice Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant(bool localOnly) {\n        _beforeNonReentrant(localOnly);\n        _;\n        _afterNonReentrant(localOnly);\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` for contract size optimization\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     */\n    function _beforeNonReentrant(bool localOnly) private {\n        require(_notEntered, \"re-entered\");\n        if (!localOnly) comptroller._beforeNonReentrant();\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` for contract size optimization\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     */\n    function _afterNonReentrant(bool localOnly) private {\n        _notEntered = true; // get a gas-refund post-Istanbul\n        if (!localOnly) comptroller._afterNonReentrant();\n    }\n}\n\n\n",
        "CodeNames": [
            "UniV3LpVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniV3LpVault._swap",
                "Type": "Arbitrary contract call",
                "Description": "Allows users to perform arbitrary contract calls during the swap process if swapPath is not validated properly.",
                "Repair": "Validate the entire path against a predefined whitelist while in _checkSwapPath"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "contracts/vault_and_oracles/FlashLoan.sol (line 48, 58), contracts/vault_and_oracles/UniV3LpVault.sol (line 418)",
                "Type": "Improper handling of ERC20 tokens",
                "Description": "The code as currently implemented does not handle tokens such as Tether (USDT) properly when they're a Uniswap pool asset, which would prevent USDT from being used by this project.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20's safeTransfer() instead of approve()"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\nimport \"./CErc20.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./external/IUniV3LpVault.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an admin unsupports a market\n    event MarketUnlisted(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when tick oracle is changed\n    event NewTickOracle(TickOracle oldTickOracle, TickOracle newTickOracle);\n\n    /// @notice Emitted when UniV3LpVault is changed\n    event NewUniV3LpVault(IUniV3LpVault oldVault, IUniV3LpVault newVault);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when supply cap for a cToken is changed\n    event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n     // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n    constructor (address _admin) public {\n        admin = _admin;\n        _notEntered = true;\n        _notEnteredInitialized = true;    \n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) public returns (uint256[] memory) {\n        uint256 len = cTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        // Add to allBorrowers\n        if (!borrowers[borrower]) {\n            allBorrowers.push(borrower);\n            borrowers[borrower] = true;\n            borrowerIndexes[borrower] = allBorrowers.length - 1;\n        }\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing neccessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external returns (uint256) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account\u2019s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.length--;\n\n        // If the user has exited all markets, remove them from the `allBorrowers` array\n        if (storedList.length == 0) {\n            allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n            allBorrowers.length--; // Reduce length by 1\n            borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n            borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n            borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n        }\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // deposits are automatically treated as collateral\n        if (!markets[cToken].accountMembership[minter]) {\n            // only cTokens may call mintAllowed if minter not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add minter to the market\n            Error err = addToMarketInternal(CToken(msg.sender), minter);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[minter]);\n        }\n\n        // Check supply cap\n        uint256 supplyCap = supplyCaps[cToken];\n        // Supply cap of 0 corresponds to unlimited supplying\n        if (supplyCap != 0) {\n            uint256 totalCash = CToken(cToken).getCash();\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            uint256 totalReserves = CToken(cToken).totalReserves();\n\n            // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves)\n            (MathError mathErr, uint256 totalUnderlyingSupply) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            uint256 nextTotalUnderlyingSupply;\n            (mathErr, nextTotalUnderlyingSupply) = addUInt(totalUnderlyingSupply, mintAmount);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            require(nextTotalUnderlyingSupply < supplyCap, \"market supply cap reached\");\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256) {\n        uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            CToken(cToken),\n            redeemTokens,\n            0\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        // Make sure oracle price is available\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        // Check borrow cap\n        uint256 borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            (MathError mathErr, uint256 nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        // Perform a hypothetical liquidity check to guard against shortfall\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            CToken(cToken),\n            0,\n            borrowAmount\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        liquidator;\n\n        // Make sure markets are listed\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Get borrowers's underlying borrow balance\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param collateralTokenId the tokenId of the Uni V3 NFT being used as collateral\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowUniV3Allowed(\n        address cTokenBorrowed,\n        uint256 collateralTokenId,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        collateralTokenId;\n        liquidator;\n\n        if (!markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (uniV3LpVault.ownerOf(collateralTokenId) != borrower) {\n            return uint256(Error.TOKEN_ID_BORROWER_MISMATCH);\n        }\n\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Make sure markets are listed\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Make sure cToken Comptrollers are identical\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * new seize function for Uni V3 vault\n     */\n    function seizeAllowedUniV3(\n        address lpVault,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        tokenId;\n        seizeFeesToken0;\n        seizeFeesToken1;\n        seizeLiquidity;\n\n        // check that the borrow token is listed in comptroller market\n        if (!markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // check that lpVault matches our LPVault\n        if (lpVault != address(uniV3LpVault)) {\n            return uint256(Error.LP_VAULT_MISMATCH);\n        }\n\n        // check that lpVault comptroller matches this comptroller\n        if (uniV3LpVault.comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrowPlusEffects;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(0),\n            0,\n            0\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account)\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(cTokenModify),\n            redeemTokens,\n            borrowAmount\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {\n        uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);\n        for (uint256 i = 0; i < userTokensLength; i++) {\n            uint256 tokenId = uniV3LpVault.userTokens(account, i);\n            (\n                address token0,\n                address token1,\n                uint256 amountToken0Fees,\n                uint256 amountToken1Fees,\n                uint256 amountToken0Liquidity,\n                uint256 amountToken1Liquidity,\n\n            ) = tickOracle.getTokenBreakdownTWAP(tokenId);\n            CToken asset0 = cTokensByUnderlying[token0];\n            CToken asset1 = cTokensByUnderlying[token1];\n\n            {\n                // avoid stack too deep\n                address poolAddress = uniV3LpVault.getPoolAddress(tokenId);\n                uint256 collateralFactorMantissa = poolCollateralFactors[poolAddress];\n\n                vars.collateralFactor = Exp({ mantissa: collateralFactorMantissa });\n            }\n\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset0);\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n            vars.tokensToDenom = mul_(vars.collateralFactor, vars.oraclePrice);\n\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                add_(amountToken0Fees, amountToken0Liquidity),\n                vars.sumCollateral\n            );\n\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset1);\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n            vars.tokensToDenom = mul_(vars.collateralFactor, vars.oraclePrice);\n\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                add_(amountToken1Fees, amountToken1Liquidity),\n                vars.sumCollateral\n            );\n        }\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        // add all Uni V3 LP Collateral value\n        addNFTCollateral(account, vars);\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(\n                account\n            );\n            if (oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({ mantissa: markets[address(asset)].collateralFactorMantissa });\n            vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.tokensToDenom,\n                    redeemTokens,\n                    vars.sumBorrowPlusEffects\n                );\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.oraclePrice,\n                    borrowAmount,\n                    vars.sumBorrowPlusEffects\n                );\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint256(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint256 exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint256 seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa }));\n        denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint256(Error.NO_ERROR), seizeTokens);\n    }\n\n    // to avoid stack-too-deep errors on `liquidateCalculateSeizeTokensUniV3`\n    struct LiquidationSeizeLocalVars {\n        uint256 amountToken0Fees;\n        uint256 amountToken1Fees;\n        uint256 amountToken0Liquidity;\n        uint256 amountToken1Liquidity;\n        uint256 amountLiquidity;\n        Exp borrowValue;\n        Exp feeValue;\n        Exp liquidityValue;\n    }\n\n    /**\n     * @notice Calculate amount of liquidity NFT to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowUniV3Fresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, percent of fees to be seized, amount of colalteralTokenId liquidity to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokensUniV3(\n        address cTokenBorrowed,\n        uint256 collateralTokenId,\n        uint256 actualRepayAmount\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint128,\n            uint128,\n            uint128\n        )\n    {\n        LiquidationSeizeLocalVars memory vars;\n\n        /*\n         * take the value in eth, convert it to borrow value. see what % the repay borrow + incentive.\n         * if % < 100, then return 0 on liquidity.\n         * If above 100%, take % - 100 to get value that should be removed from total liquidity.\n         * Then take that value, divided by the total value of the liquidity, and multiply by the amount of liquidity.\n         * Cap this liquidity amount at the total liquidity amount (since we've already liquidated everything)\n         */\n\n        address token0;\n        address token1;\n        (\n            token0,\n            token1,\n            vars.amountToken0Fees,\n            vars.amountToken1Fees,\n            vars.amountToken0Liquidity,\n            vars.amountToken1Liquidity,\n            vars.amountLiquidity\n        ) = tickOracle.getTokenBreakdownTWAP(collateralTokenId);\n\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint256 oraclePriceMantissa0 = oracle.price(token0);\n        uint256 oraclePriceMantissa1 = oracle.price(token1);\n        if (priceBorrowedMantissa == 0 || oraclePriceMantissa0 == 0 || oraclePriceMantissa1 == 0) {\n            return (uint256(Error.PRICE_ERROR), 0, 0, 0);\n        }\n\n        // TODO: custom liquidation incentive for LP shares\n        vars.borrowValue = mul_(\n            mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa })),\n            actualRepayAmount\n        );\n        vars.feeValue = add_(\n            mul_(Exp({ mantissa: oraclePriceMantissa0 }), vars.amountToken0Fees),\n            mul_(Exp({ mantissa: oraclePriceMantissa1 }), vars.amountToken1Fees)\n        );\n        vars.liquidityValue = add_(\n            mul_(Exp({ mantissa: oraclePriceMantissa0 }), vars.amountToken0Liquidity),\n            mul_(Exp({ mantissa: oraclePriceMantissa1 }), vars.amountToken1Liquidity)\n        );\n\n        require(\n            lessThanOrEqualExp(vars.borrowValue, add_(vars.feeValue, vars.liquidityValue)),\n            \"borrowValue greater than total collateral\"\n        );\n\n        if (lessThanExp(vars.borrowValue, vars.feeValue)) {\n            // only return from fees\n            uint128 seizeAmountToken0Fees = uint128(\n                mul_ScalarTruncate(div_(vars.borrowValue, vars.feeValue), vars.amountToken0Fees)\n            );\n            uint128 seizeAmountToken1Fees = uint128(\n                mul_ScalarTruncate(div_(vars.borrowValue, vars.feeValue), vars.amountToken1Fees)\n            );\n            return (uint256(Error.NO_ERROR), seizeAmountToken0Fees, seizeAmountToken1Fees, 0);\n        } else {\n            // only return from liquidity\n            uint128 seizeAmountLiquidity = uint128(\n                mul_ScalarTruncate(\n                    div_(sub_(vars.borrowValue, vars.feeValue), vars.liquidityValue),\n                    vars.amountLiquidity\n                )\n            );\n            return (\n                uint256(Error.NO_ERROR),\n                uint128(vars.amountToken0Fees),\n                uint128(vars.amountToken1Fees),\n                seizeAmountLiquidity\n            );\n        }\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setTickOracle(TickOracle newTickOracle) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TICK_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        TickOracle oldTickOracle = tickOracle;\n\n        // Set comptroller's oracle to newOracle\n        tickOracle = newTickOracle;\n\n        // Emit NewTickOracle(oldTickOracle, newTickOracle)\n        emit NewTickOracle(oldTickOracle, newTickOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new UniV3LpVault for the comptroller\n     * @dev Admin function to set a new UniV3LpVault\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old vault for the comptroller\n        IUniV3LpVault oldVault = uniV3LpVault;\n\n        // Set comptroller's uniV3LpVault to newVault\n        uniV3LpVault = newVault;\n\n        // Emit NewUniV3LpVault(oldVault, newVault)\n        emit NewUniV3LpVault(oldVault, newVault);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n        }\n\n        // Check limits\n        Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n        Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        // Set pool close factor to new close factor, remember old value\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        // Emit event\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Admin function to set per-market collateralFactor\n     * @param cToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(CToken cToken, uint256 newCollateralFactorMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Check de-scaled min <= newLiquidationIncentive <= max\n        Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\n        Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        // Save current value for use in log\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed\n     * @dev Admin function to set isListed and add support for the market\n     * @param cToken The address of the market (token) to list\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(CToken cToken) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        // Is market already listed?\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        // Sanity check to make sure its really a CToken\n        require(cToken.isCToken(), \"marker method returned false\");\n\n        // Check cToken.comptroller == this\n        require(\n            address(cToken.comptroller()) == address(this),\n            \"Cannot support a market with a different Comptroller.\"\n        );\n\n        // Make sure market is not already listed\n        address underlying = CErc20(address(cToken)).underlying();\n\n        if (address(cTokensByUnderlying[underlying]) != address(0)) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        // List market and emit event\n        markets[address(cToken)] = Market({ isListed: true, collateralFactorMantissa: 0 });\n        allMarkets.push(cToken);\n        cTokensByUnderlying[underlying] = cToken;\n        emit MarketListed(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Removed a market from the markets mapping and sets it as unlisted\n     * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\n     * @param cToken The address of the market (token) to unlist\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _unsupportMarket(CToken cToken) external returns (uint256) {\n        // Check admin rights\n        if (msg.sender != admin) return fail(Error.UNAUTHORIZED, FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK);\n\n        // Check if market is already unlisted\n        if (!markets[address(cToken)].isListed)\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST);\n\n        // Check if market is in use\n        if (cToken.totalSupply() > 0) return fail(Error.NONZERO_TOTAL_SUPPLY, FailureInfo.UNSUPPORT_MARKET_IN_USE);\n\n        // Unlist market\n        delete markets[address(cToken)];\n\n        /* Delete cToken from allMarkets */\n        // load into memory for faster iteration\n        CToken[] memory _allMarkets = allMarkets;\n        uint256 len = _allMarkets.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (_allMarkets[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\n        allMarkets.length--;\n\n        cTokensByUnderlying[CErc20(address(cToken)).underlying()] = CToken(address(0));\n        emit MarketUnlisted(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\n     * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\n     * @param cTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\n     */\n    function _setMarketSupplyCaps(CToken[] calldata cTokens, uint256[] calldata newSupplyCaps) external {\n        require(\n            msg.sender == admin || msg.sender == borrowCapGuardian,\n            \"only admin or borrow cap guardian can set supply caps\"\n        );\n\n        uint256 numMarkets = cTokens.length;\n        uint256 numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n     */\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint256[] calldata newBorrowCaps) external {\n        require(\n            msg.sender == admin || msg.sender == borrowCapGuardian,\n            \"only admin or borrow cap guardian can set borrow caps\"\n        );\n\n        uint256 numMarkets = cTokens.length;\n        uint256 numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n        // Save current value for inclusion in log\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n        borrowCapGuardian = newBorrowCapGuardian;\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint256) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        mintGuardianPaused[address(cToken)] = state;\n        emit ActionPausedMarket(cToken, \"Mint\", state);\n        return state;\n    }\n\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        borrowGuardianPaused[address(cToken)] = state;\n        emit ActionPausedMarket(cToken, \"Borrow\", state);\n        return state;\n    }\n\n    function _setTransferPaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        transferGuardianPaused = state;\n        emit ActionPaused(\"Transfer\", state);\n        return state;\n    }\n\n    function _setSeizePaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        seizeGuardianPaused = state;\n        emit ActionPaused(\"Seize\", state);\n        return state;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n        Comptroller(address(unitroller))._becomeImplementation();\n    }\n\n    function _becomeImplementation() external {\n        require(msg.sender == comptrollerImplementation, \"only implementation may call _becomeImplementation\");\n\n        if (!_notEnteredInitialized) {\n            _notEntered = true;\n            _notEnteredInitialized = true;\n        }\n    }\n\n    /**\n     * @notice sets the state for many pools of whether or not they are supported as collateral\n     *              in actuality, just limits whether or not a pool can be deposited into the vault\n     * @param pools The addresses of Uni V3 Pools\n     * @param states The state of whether or not this pool is to be supported (corresponding by index to pools)\n     */\n    function _setSupportedPools(address[] calldata pools, bool[] calldata states) external {\n        require(msg.sender == admin, \"only admin can set supported pools\");\n        require(pools.length > 0, \"must have at least one pool\");\n        require(pools.length == states.length, \"Number of pools and states must be equal\");\n        for (uint256 i = 0; i < pools.length; i++) {\n            isSupportedPool[pools[i]] = states[i];\n        }\n    }\n\n    /**\n     * @notice sets the collateral factors for many pools\n     * @param pools The addresses of Uni V3 Pools\n     * @param collateralFactorsMantissa The collateral factors for LP positions of the pools\n     */\n    function _setPoolCollateralFactors(address[] calldata pools, uint256[] calldata collateralFactorsMantissa)\n        external\n    {\n        require(msg.sender == admin, \"only admin can set collateral factors for pools\");\n        require(pools.length > 0, \"must have at least one pool\");\n        require(\n            pools.length == collateralFactorsMantissa.length,\n            \"Number of pools and collateralFactors must be equal\"\n        );\n        for (uint256 i = 0; i < pools.length; i++) {\n            poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i];\n        }\n    }\n\n    /*** Helper Functions ***/\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() public view returns (CToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Return all of the borrowers\n     * @dev The automatic getter may be used to access an individual borrower.\n     * @return The list of borrower account addresses\n     */\n    function getAllBorrowers() public view returns (address[] memory) {\n        return allBorrowers;\n    }\n\n    /**\n     * @notice Returns true if the given cToken market has been deprecated\n     * @dev All borrows in a deprecated cToken market can be immediately liquidated\n     * @param cToken The market to check if deprecated\n     */\n    function isDeprecated(CToken cToken) public view returns (bool) {\n        return\n            markets[address(cToken)].collateralFactorMantissa == 0 &&\n            borrowGuardianPaused[address(cToken)] == true &&\n            cToken.reserveFactorMantissa() == 1e18;\n    }\n\n    /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n    /**\n     * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _beforeNonReentrant() external {\n        require(\n            markets[msg.sender].isListed || msg.sender == address(uniV3LpVault),\n            \"Comptroller:_beforeNonReentrant: caller not listed as market or lpVault\"\n        );\n        require(_notEntered, \"re-entered across assets\");\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _afterNonReentrant() external {\n        require(\n            markets[msg.sender].isListed || msg.sender == address(uniV3LpVault),\n            \"Comptroller:_afterNonReentrant: caller not listed as market or lpVault\"\n        );\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n}\n\n\n",
        "CodeNames": [
            "Comptroller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Comptroller._setUniV3LpVault",
                "Type": "In-use uniswapV3 positions become stuck",
                "Description": "Changing Comptroller.uniV3LpVault would mean all actions including collateral calculation, uniswapV3 position withdrawal, uniswapV3 collateral liquidation are no longer performable on existing NFTs, causing NFT tokens to become stuck.",
                "Repair": "Remove the option to change Comptroller.uniV3LpVault altogether"
            },
            {
                "Location": "Comptroller.sol#L1491",
                "Type": "Undercollateralized loans possible",
                "Description": "The _setPoolCollateralFactors function does not check that the collateral factor is < 100%. It's possible that it's set to 200% and then borrows more than the collateral is worth, stealing from the pool.",
                "Repair": "Add a check to ensure collateral factor is not set to 100% or above"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.16;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 reserveFactorMantissa_\n    ) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint256 err = _setComptroller(comptroller_);\n        require(err == uint256(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint256(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // Set reserve factor\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n        require(err == uint256(Error.NO_ERROR), \"setting reserve factor failed\");\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(\n        address spender,\n        address src,\n        address dst,\n        uint256 tokens\n    ) internal returns (uint256) {\n        /* Fail if transfer not allowed */\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint256(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint256 allowanceNew;\n        uint256 srcTokensNew;\n        uint256 dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint256(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external nonReentrant(false) returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external nonReentrant(false) returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        (MathError mErr, uint256 balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 cTokenBalance = accountTokens[account];\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint256(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint256) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint256) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view returns (uint256) {\n        (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint256 principalTimesIndex;\n        uint256 result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        (MathError err, uint256 result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint256) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public returns (uint256) {\n        /* Remember the initial block number */\n        uint256 currentBlockNumber = getBlockNumber();\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumber == currentBlockNumber) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint256 cashPrior = getCashPrior();\n\n        /* Calculate the current borrow interest rate */\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, totalBorrows, totalReserves);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint256 blockDelta) = subUInt(currentBlockNumber, accrualBlockNumber);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        return finishInterestAccrual(currentBlockNumber, cashPrior, borrowRateMantissa, blockDelta);\n    }\n\n    /**\n     * @dev Split off from `accrueInterest` to avoid \"stack too deep\" error\".\n     */\n    function finishInterestAccrual(\n        uint256 currentBlockNumber,\n        uint256 cashPrior,\n        uint256 borrowRateMantissa,\n        uint256 blockDelta\n    ) private returns (uint256) {\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees\n         *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, totalBorrows);\n        uint256 totalBorrowsNew = add_(interestAccumulated, totalBorrows);\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            totalReserves\n        );\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        // Attempt to add interest checkpoint\n        address(interestRateModel).call(abi.encodeWithSignature(\"checkpointInterest(uint256)\", borrowRateMantissa));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint256 mintAmount) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market on behalf of minter and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param minter The account minting the cTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfInternal(address minter, uint256 mintAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, minter, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param payer The address of the account which is supplying the assets\n     * @param minter The address of the account under which supply is tracked\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(\n        address payer,\n        address minter,\n        uint256 mintAmount\n    ) internal returns (uint256, uint256) {\n        /* Fail if mint not allowed */\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(payer, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\n\n        vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemBehalfInternal(address redeemer, uint256 redeemTokens)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == redeemer,\n            \"only the LpVault may redeem other's assets\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemer, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingBehalfInternal(address redeemer, uint256 redeemAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == redeemer,\n            \"only the LpVault may redeem other's assets\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemer, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 redeemTokens;\n        uint256 redeemAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param to The address of the account which is redeeming the tokens\n     * @param redeemer The address of the account under which redemption is tracked\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(\n        address payable to,\n        address redeemer,\n        uint256 redeemTokensIn,\n        uint256 redeemAmountIn\n    ) internal returns (uint256) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n        }\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n                Exp({ mantissa: vars.exchangeRateMantissa }),\n                redeemTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n                redeemAmountIn,\n                Exp({ mantissa: vars.exchangeRateMantissa })\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(to, vars.redeemAmount);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol on behalf of borrower\n     * @param borrower The address of the account under which borrowing is tracked\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowBehalfInternal(address borrower, uint256 borrowAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == borrower,\n            \"only the LpVault may borrow against other's collateral\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(msg.sender, borrower, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    /**\n     * @notice Users borrow assets from the protocol\n     * @param to The address of the account which is borrowing the tokens\n     * @param borrower The address of the account under which borrowing is tracked\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowFresh(\n        address payable to,\n        address borrower,\n        uint256 borrowAmount\n    ) internal returns (uint256) {\n        /* Fail if borrow not allowed */\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        uint256 cashPrior = getCashPrior();\n\n        if (cashPrior < borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(to, borrowAmount);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) internal returns (uint256, uint256) {\n        /* Fail if repayBorrow not allowed */\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return (\n                failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint256(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers Uni V3 LP collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowUniV3Internal(\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n        // liquidateBorrowUniV3Fresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowUniV3Fresh(msg.sender, borrower, repayAmount, collateralTokenId);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal returns (uint256, uint256) {\n        /* Fail if liquidate not allowed */\n        uint256 allowed = comptroller.liquidateBorrowAllowed(\n            address(this),\n            address(cTokenCollateral),\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n\n        /* Verify cTokenCollateral market's block number equals current block number */\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint256(-1)) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n\n        /* Fail if repayBorrow fails */\n        (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint256(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n            address(this),\n            address(cTokenCollateral),\n            actualRepayAmount\n        );\n        require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        uint256 seizeError;\n        if (address(cTokenCollateral) == address(this)) {\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n\n        return (uint256(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowUniV3Fresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) internal returns (uint256, uint256) {\n        /* Fail if liquidate not allowed */\n        uint256 allowed = comptroller.liquidateBorrowUniV3Allowed(\n            address(this),\n            collateralTokenId,\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n        // could reduce duplication of below checks and share w/ liquidateBorrowFresh\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint256(-1)) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n        /* Fail if repayBorrow fails */\n        (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint256(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        (\n            uint256 amountSeizeError,\n            uint256 seizeFeesToken0,\n            uint256 seizeFeesToken1,\n            uint256 seizeLiquidity\n        ) = comptroller.liquidateCalculateSeizeTokensUniV3(address(this), collateralTokenId, actualRepayAmount);\n        require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n        comptroller.uniV3LpVault().seizeAssets(\n            liquidator,\n            borrower,\n            collateralTokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        // require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrowUniV3(\n            liquidator,\n            borrower,\n            actualRepayAmount,\n            collateralTokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n        return (uint256(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external nonReentrant(true) returns (uint256) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    struct SeizeInternalLocalVars {\n        MathError mathErr;\n        uint256 borrowerTokensNew;\n        uint256 liquidatorTokensNew;\n        uint256 liquidatorSeizeTokens;\n        uint256 protocolSeizeTokens;\n        uint256 protocolSeizeAmount;\n        uint256 exchangeRateMantissa;\n        uint256 totalReservesNew;\n        uint256 totalSupplyNew;\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(\n        address seizerToken,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) internal returns (uint256) {\n        /* Fail if seize not allowed */\n        uint256 allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        SeizeInternalLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\n        vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(\n            Exp({ mantissa: vars.exchangeRateMantissa }),\n            vars.protocolSeizeTokens\n        );\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        totalReserves = vars.totalReservesNew;\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[borrower] = vars.borrowerTokensNew;\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() external returns (uint256) {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = address(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Internal function to set a new comptroller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface newComptroller) internal returns (uint256) {\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n     * @dev Admin function to set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\n     * @param addAmount Amount of addition to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReservesInternal(uint256 addAmount) internal nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n        (error, ) = _addReservesFresh(addAmount);\n        return error;\n    }\n\n    /**\n     * @notice Add reserves by transferring from caller\n     * @dev Requires fresh interest accrual\n     * @param addAmount Amount of addition to reserves\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n     */\n    function _addReservesFresh(uint256 addAmount) internal returns (uint256, uint256) {\n        // totalReserves + actualAddAmount\n        uint256 totalReservesNew;\n        uint256 actualAddAmount;\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n        }\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n        totalReservesNew = totalReserves + actualAddAmount;\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n        /* Return (NO_ERROR, actualAddAmount) */\n        return (uint256(Error.NO_ERROR), actualAddAmount);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint256 reduceAmount) external nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n        // totalReserves - reduceAmount\n        uint256 totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(msg.sender, reduceAmount);\n\n        emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market's current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        // Attempt to reset interest checkpoints on old IRM\n        if (address(oldInterestRateModel) != address(0))\n            address(oldInterestRateModel).call(abi.encodeWithSignature(\"resetInterestCheckpoints()\"));\n\n        // Attempt to add first interest checkpoint on new IRM\n        address(newInterestRateModel).call(abi.encodeWithSignature(\"checkpointInterest()\"));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the cToken ERC20 name and symbol\n     * @dev Admin function to update the cToken ERC20 name and symbol\n     * @param _name the new ERC20 token name to use\n     * @param _symbol the new ERC20 token symbol to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setNameAndSymbol(string calldata _name, string calldata _symbol) external {\n        // Check caller is admin\n        require(msg.sender != admin, \"caller not admin\");\n\n        // Set ERC20 name and symbol\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256);\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint256 amount) internal returns (uint256);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint256 amount) internal;\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant(bool localOnly) {\n        _beforeNonReentrant(localOnly);\n        _;\n        _afterNonReentrant(localOnly);\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n     */\n    function _beforeNonReentrant(bool localOnly) private {\n        require(_notEntered, \"re-entered\");\n        if (!localOnly) comptroller._beforeNonReentrant();\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n     */\n    function _afterNonReentrant(bool localOnly) private {\n        _notEntered = true; // get a gas-refund post-Istanbul\n        if (!localOnly) comptroller._afterNonReentrant();\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.call(data);\n\n        if (!success) {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n\n        return returndata;\n    }\n}\n\n\n",
        "CodeNames": [
            "CToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CToken.sol#L1379",
                "Type": "Dysfunctional CToken._acceptAdmin due to lack of function to assign pendingAdmin",
                "Description": "The implementation of CToken in Duality introduced an _acceptAdmin function, which presumably should allow changing the admin. However, there does not exist a pairing proposePendingAdmin function that can propose a new pendingAdmin, thus pendingAdmin will never be set. This renders the _acceptAdmin function useless.",
                "Repair": "Add a proposePendingAdmin function where the current admin can propose successors"
            }
        ]
    }
]