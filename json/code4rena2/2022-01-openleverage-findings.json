[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OpenLevInterface.sol\";\nimport \"./Types.sol\";\nimport \"./Adminable.sol\";\nimport \"./DelegateInterface.sol\";\nimport \"./ControllerInterface.sol\";\nimport \"./IWETH.sol\";\nimport \"./XOLEInterface.sol\";\nimport \"./Types.sol\";\nimport \"./OpenLevV1Lib.sol\";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param _controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, \"NAD\");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i < _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow > 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, \"MAM\");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed > 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), \"PNH\");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, \"ISR\");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, \"ISR\");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, \"ISB\");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), \"IRP\");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), \"PIH\");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty > 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, \"PH\");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance >= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance >= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount > 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount > 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on \"to\" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    /*** Admin Functions ***/\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld <= trade.held, \"CBH\");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), \"HI0\");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), \"UDX\");\n        _;\n    }\n}\n\n",
        "CodeNames": [
            "OpenLevV1.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OpenLevV1.closeTrade with V3 DEX",
                "Type": "Incorrect fee accounting",
                "Description": "The amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.",
                "Repair": "Control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nimport \"./LPoolInterface.sol\";\nimport \"./LPoolDepositor.sol\";\nimport \"../lib/Exponential.sol\";\nimport \"../Adminable.sol\";\nimport \"../lib/CarefulMath.sol\";\nimport \"../lib/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../DelegateInterface.sol\";\nimport \"../ControllerInterface.sol\";\nimport \"../IWETH.sol\";\n\n/// @title OpenLeverage's LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller_ The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), \"underlying_ address cannot be 0\");\n        require(controller_ != address(0), \"controller_ address cannot be 0\");\n        require(msg.sender == admin, \"Only allow to be called by admin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"inited once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial Exchange Rate Mantissa should be greater zero\");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        _notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n    /// @dev Called by both `transfer` and `transferFrom` internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), \"dst address cannot be 0\");\n        /* Do not allow self-transfers */\n        require(src != dst, \"src = dst\");\n        /* Fail if transfer not allowed */\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, 'not allowed');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, 'not enough');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, 'too much');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev This will overwrite the approval amount for `spender`\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the current allowance from `owner` for `spender`\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /// @notice Get the token balance of the `owner`\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by `owner`\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /// @notice Get the underlying balance of the `owner`\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by `owner`\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"calc failed\");\n        return balance;\n    }\n\n    /*** User Interface ***/\n\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, \"not eth pool\");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n    /*** Safe Token ***/\n\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool && convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows > maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /// @notice Get a snapshot of the account's balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        return totalBorrowsNew;\n    }\n\n    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, \"calc borrow index fail\");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');\n\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter > balanceBefore, 'mint 0');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /*\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"calc mint token error\");\n\n        /* Fail if mint not allowed */\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /*\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc supply new failed\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc tokens new ailed\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');\n        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        /* Fail if borrow not allowed */\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        require(getCashPrior() >= borrowAmount, 'cash<borrow');\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(payee, borrowAmount, false);\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n    }\n\n    struct RepayBorrowLocalVars {\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n        uint badDebtsAmount;\n    }\n\n    /// @notice Borrows are repaid by another user (possibly the borrower).\n    /// @param payer the account paying off the borrow\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount the amount of undelrying tokens being returned\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(- 1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);\n\n\n        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n\n        /*\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        */\n        if (vars.accountBorrows < vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount > totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    /*** Admin Functions ***/\n\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, \"0x\");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear < 2000%\n        require(baseRatePerBlock_ < 1e13, 'Base rate too large');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ <= 1e18, 'Kline too large');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa <= 1e18, 'Factor too large');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), 'not same block');\n        _;\n    }\n}\n\n\n\n",
        "CodeNames": [
            "LPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LPool.sol, addReserves",
                "Type": "Missing payable",
                "Description": "The following functions are not payable but uses msg.value therefore the function must be payable.",
                "Repair": "Make the function payable since using msg.value"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OpenLevV1Lib's and LPool's doTransferOut functions",
                "Type": "Unsafe use of transfer()",
                "Description": "OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a payable.transfer() call. This is unsafe as transfer has hard coded gas budget and can fail when the user is a smart contract.",
                "Repair": "Replace transfer() with low-level call.value(amount) with the corresponding result check or using the OpenZeppelin Address.sendValue"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./OpenLevInterface.sol\";\nimport \"./Adminable.sol\";\nimport \"./XOLEInterface.sol\";\nimport \"./IWETH.sol\";\n\npragma experimental ABIEncoderV2;\n\n\nlibrary OpenLevV1Lib {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    struct PricesVar {\n        uint current;\n        uint cAvg;\n        uint hAvg;\n        uint price;\n        uint cAvgPrice;\n    }\n\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData,\n        uint16 marketId,\n        mapping(uint16 => Types.Market) storage markets,\n        OpenLevStorage.CalculateConfig storage config,\n        OpenLevStorage.AddressConfig storage addressConfig,\n        mapping(uint8 => bool) storage _supportDexs,\n        mapping(uint16 => mapping(address => mapping(uint => uint24))) storage taxes\n    ) external {\n        address token0 = pool0.underlying();\n        address token1 = pool1.underlying(); \n        uint8 dex = dexData.toDex();\n        require(isSupportDex(_supportDexs, dex) && msg.sender == address(addressConfig.controller) && marginLimit >= config.defaultMarginLimit && marginLimit < 100000, \"UDX\");\n\n        {\n            uint24[] memory taxRates = dexData.toTransferFeeRates();\n            require(taxRates[0] < 200000 && taxRates[1] < 200000 && taxRates[2] < 200000 && taxRates[3] < 200000 &&taxRates[4] < 200000 && taxRates[5] < 200000, \"WTR\" );\n            taxes[marketId][token0][0]= taxRates[0];\n            taxes[marketId][token1][0]= taxRates[1];\n            taxes[marketId][token0][1]= taxRates[2];\n            taxes[marketId][token1][1]= taxRates[3];\n            taxes[marketId][token0][2]= taxRates[4];\n            taxes[marketId][token1][2]= taxRates[5];\n        }\n\n        // Approve the max number for pools\n        IERC20(token0).safeApprove(address(pool0), uint256(- 1));\n        IERC20(token1).safeApprove(address(pool1), uint256(- 1));\n        //Create Market\n        uint32[] memory dexs = new uint32[](1);\n        dexs[0] = dexData.toDexDetail();\n        markets[marketId] = Types.Market(pool0, pool1, token0, token1, marginLimit, config.defaultFeesRate, config.priceDiffientRatio, address(0), 0, 0, dexs);\n        // Init price oracle\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(token0, token1, dexData);\n        } else if (dex == DexData.DEX_UNIV3) {\n            addressConfig.dexAggregator.updateV3Observation(token0, token1, dexData);\n        }\n    }\n\n    function setCalculateConfigInternal(\n        uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration,\n        OpenLevStorage.CalculateConfig storage calculateConfig\n    ) external {\n        require(defaultFeesRate < 10000 && insuranceRatio < 100 && defaultMarginLimit > 0 && updatePriceDiscount <= 100\n        && feesDiscount <= 100 && penaltyRatio < 10000 && twapDuration > 0, 'PRI');\n        calculateConfig.defaultFeesRate = defaultFeesRate;\n        calculateConfig.insuranceRatio = insuranceRatio;\n        calculateConfig.defaultMarginLimit = defaultMarginLimit;\n        calculateConfig.priceDiffientRatio = priceDiffientRatio;\n        calculateConfig.updatePriceDiscount = updatePriceDiscount;\n        calculateConfig.feesDiscount = feesDiscount;\n        calculateConfig.feesDiscountThreshold = feesDiscountThreshold;\n        calculateConfig.penaltyRatio = penaltyRatio;\n        calculateConfig.maxLiquidationPriceDiffientRatio = maxLiquidationPriceDiffientRatio;\n        calculateConfig.twapDuration = twapDuration;\n    }\n\n    function setAddressConfigInternal(\n        address controller,\n        DexAggregatorInterface dexAggregator,\n        OpenLevStorage.AddressConfig storage addressConfig\n    ) external {\n        require(controller != address(0) && address(dexAggregator) != address(0), 'CD0');\n        addressConfig.controller = controller;\n        addressConfig.dexAggregator = dexAggregator;\n    }\n\n    function setMarketConfigInternal(\n        uint16 feesRate,\n        uint16 marginLimit,\n        uint16 priceDiffientRatio,\n        uint32[] memory dexs,\n        Types.Market storage market\n    ) external {\n        require(feesRate < 10000 && marginLimit > 0 && dexs.length > 0, 'PRI');\n        market.feesRate = feesRate;\n        market.marginLimit = marginLimit;\n        market.dexs = dexs;\n        market.priceDiffientRatio = priceDiffientRatio;\n    }\n\n    function marginRatio(\n        address owner,\n        uint held,\n        address heldToken,\n        address sellToken,\n        LPoolInterface borrowPool,\n        bool isOpen,\n        bytes memory dexData\n    ) external view returns (uint, uint, uint, uint, uint){\n        return marginRatioPrivate(owner, held, heldToken, sellToken, borrowPool, isOpen, dexData);\n    }\n\n    function marginRatioPrivate(\n        address owner,\n        uint held,\n        address heldToken,\n        address sellToken,\n        LPoolInterface borrowPool,\n        bool isOpen,\n        bytes memory dexData\n    ) private view returns (uint, uint, uint, uint, uint){\n        Types.MarginRatioVars memory ratioVars;\n        ratioVars.held = held;\n        ratioVars.dexData = dexData;\n        ratioVars.heldToken = heldToken;\n        ratioVars.sellToken = sellToken;\n        ratioVars.owner = owner;\n        ratioVars.multiplier = 10000;\n\n        (DexAggregatorInterface dexAggregator,,,) = OpenLevStorage(address(this)).addressConfig();\n        (,,,,,,,,,uint16 twapDuration) = OpenLevStorage(address(this)).calculateConfig();\n\n        uint borrowed = isOpen ? borrowPool.borrowBalanceStored(ratioVars.owner) : borrowPool.borrowBalanceCurrent(ratioVars.owner);\n        if (borrowed == 0) {\n            return (ratioVars.multiplier, ratioVars.multiplier, ratioVars.multiplier, ratioVars.multiplier, ratioVars.multiplier);\n        }\n        (ratioVars.price, ratioVars.cAvgPrice, ratioVars.hAvgPrice, ratioVars.decimals, ratioVars.lastUpdateTime) = dexAggregator.getPriceCAvgPriceHAvgPrice(ratioVars.heldToken, ratioVars.sellToken, twapDuration, ratioVars.dexData);\n        //Ignore hAvgPrice\n        if (block.timestamp > ratioVars.lastUpdateTime.add(twapDuration)) {\n            ratioVars.hAvgPrice = ratioVars.cAvgPrice;\n        }\n        //marginRatio=(marketValue-borrowed)/borrowed\n        uint marketValue = ratioVars.held.mul(ratioVars.price).div(10 ** uint(ratioVars.decimals));\n        uint current = marketValue >= borrowed ? marketValue.sub(borrowed).mul(ratioVars.multiplier).div(borrowed) : 0;\n        marketValue = ratioVars.held.mul(ratioVars.cAvgPrice).div(10 ** uint(ratioVars.decimals));\n        uint cAvg = marketValue >= borrowed ? marketValue.sub(borrowed).mul(ratioVars.multiplier).div(borrowed) : 0;\n        marketValue = ratioVars.held.mul(ratioVars.hAvgPrice).div(10 ** uint(ratioVars.decimals));\n        uint hAvg = marketValue >= borrowed ? marketValue.sub(borrowed).mul(ratioVars.multiplier).div(borrowed) : 0;\n        return (current, cAvg, hAvg, ratioVars.price, ratioVars.cAvgPrice);\n    }\n\n    function isPositionHealthy(\n        address owner,\n        bool isOpen,\n        uint amount,\n        Types.MarketVars memory vars,\n        bytes memory dexData\n    ) external view returns (bool){\n        PricesVar memory prices;\n        (prices.current, prices.cAvg, prices.hAvg, prices.price, prices.cAvgPrice) = marginRatioPrivate(owner,\n            amount,\n            isOpen ? address(vars.buyToken) : address(vars.sellToken),\n            isOpen ? address(vars.sellToken) : address(vars.buyToken),\n            isOpen ? vars.sellPool : vars.buyPool,\n            isOpen,\n            dexData\n        );\n\n        (,,,,,,,,uint8 maxLiquidationPriceDiffientRatio,) = OpenLevStorage(address(this)).calculateConfig();\n        if (isOpen) {\n            return prices.current >= vars.marginLimit && prices.cAvg >= vars.marginLimit && prices.hAvg >= vars.marginLimit;\n        } else {\n            // Avoid flash loan\n            if (prices.price < prices.cAvgPrice) {\n                uint differencePriceRatio = prices.cAvgPrice.mul(100).div(prices.price);\n                require(differencePriceRatio - 100 < maxLiquidationPriceDiffientRatio, 'MPT');\n            }\n            return prices.current >= vars.marginLimit || prices.cAvg >= vars.marginLimit || prices.hAvg >= vars.marginLimit;\n        }\n    }\n\n    function updatePriceInternal(address token0, address token1, bytes memory dexData) internal returns (bool){\n        (DexAggregatorInterface dexAggregator,,,) = OpenLevStorage(address(this)).addressConfig();\n        (,,,,,,,,,uint16 twapDuration) = OpenLevStorage(address(this)).calculateConfig();\n        return dexAggregator.updatePriceOracle(token0, token1, twapDuration, dexData);\n    }\n\n    function shouldUpdatePriceInternal(DexAggregatorInterface dexAggregator, uint16 twapDuration, uint16 priceDiffientRatio, address token0, address token1, bytes memory dexData) public view returns (bool){\n        if (!dexData.isUniV2Class()) {\n            return false;\n        }\n        (, uint cAvgPrice, uint hAvgPrice,, uint lastUpdateTime) = dexAggregator.getPriceCAvgPriceHAvgPrice(token0, token1, twapDuration, dexData);\n        if (block.timestamp < lastUpdateTime.add(twapDuration)) {\n            return false;\n        }\n        //Not initialized yet\n        if (cAvgPrice == 0 || hAvgPrice == 0) {\n            return true;\n        }\n        //price difference\n        uint one = 100;\n        uint differencePriceRatio = cAvgPrice.mul(one).div(hAvgPrice);\n        if (differencePriceRatio >= (one.add(priceDiffientRatio)) || differencePriceRatio <= (one.sub(priceDiffientRatio))) {\n            return true;\n        }\n        return false;\n    }\n\n    function updatePrice(uint16 marketId, Types.Market storage market, OpenLevStorage.AddressConfig storage addressConfig,\n        OpenLevStorage.CalculateConfig storage calculateConfig, bytes memory dexData) external {\n        bool shouldUpdate = shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration, market.priceDiffientRatio, market.token1, market.token0, dexData);\n        bool updateResult = updatePriceInternal(market.token0, market.token1, dexData);\n        if (updateResult) {\n            //Discount\n            market.priceUpdater = tx.origin;\n            //Reward OLE\n            if (shouldUpdate) {\n                (ControllerInterface(addressConfig.controller)).updatePriceAllowed(marketId);\n            }\n        }\n    }\n\n    function transferIn(address from, IERC20 token, address weth, uint amount) external returns (uint) {\n        if (address(token) == weth) {\n            IWETH(weth).deposit{value : msg.value}();\n            return msg.value;\n        } else {\n            return token.safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    function doTransferOut(address to, IERC20 token, address weth, uint amount) external {\n        if (address(token) == weth) {\n            IWETH(weth).withdraw(amount);\n            payable(to).transfer(amount);\n        } else {\n            token.safeTransfer(to, amount);\n        }\n    }\n\n    function isInSupportDex(uint32[] memory dexs, uint32 dex) internal pure returns (bool supported){\n        for (uint i = 0; i < dexs.length; i++) {\n            if (dexs[i] == 0) {\n                break;\n            }\n            if (dexs[i] == dex) {\n                supported = true;\n                break;\n            }\n        }\n    }\n\n    function isSupportDex(mapping(uint8 => bool) storage _supportDexs, uint8 dex) internal view returns (bool){\n        return _supportDexs[dex];\n    }\n\n    function amountToShare(uint amount, uint totalShare, uint reserve) internal pure returns (uint share){\n        share = totalShare > 0 && reserve > 0 ? totalShare.mul(amount) / reserve : amount;\n    }\n\n    function shareToAmount(uint share, uint totalShare, uint reserve) internal pure returns (uint amount){\n        if (totalShare > 0 && reserve > 0){\n            amount = reserve.mul(share) / totalShare;\n        }\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData, OpenLevStorage.AddressConfig memory addressConfig, Types.Trade memory trade) external view {\n        //verify if deposit token allowed\n        address depositTokenAddr = depositToken == longToken ? address(vars.buyToken) : address(vars.sellToken);\n\n        //verify minimal deposit > absolute value 0.0001\n        uint decimals = ERC20(depositTokenAddr).decimals();\n        uint minimalDeposit = decimals > 4 ? 10 ** (decimals - 4) : 1;\n        uint actualDeposit = depositTokenAddr == addressConfig.wETH ? msg.value : deposit;\n        require(actualDeposit > minimalDeposit, \"DTS\");\n\n        // New trade\n        if (trade.lastBlockNum == 0) {\n            require(borrow > 0, \"BB0\");\n            return;\n        } else {\n            // For new trade, these checks are not needed\n            require(depositToken == trade.depositToken && trade.lastBlockNum != uint128(block.number) && isInSupportDex(vars.dexs, dexData.toDexDetail()), \"DNS\");\n        }\n    }\n}\n\n",
        "CodeNames": [
            "OpenLevV1Lib.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OpenLevV1Lib.sol",
                "Type": "Anti-flashloan mechanism",
                "Description": "There is a price check to avoid flash loan attacks which significantly moved the price. If current price is 5% lower than the stored twap price, the liquidation will fail.",
                "Repair": "Use the twap price to determine if the position is healthy instead of reverting with maxLiquidationPriceDiffientRatio"
            },
            {
                "Location": "OpenLevV1Lib.sol",
                "Type": "Protocol default due to anti-flashloan mechanism",
                "Description": "The anti-flashloan mechanism may lead to protocol default if the spot price keeps trading 5% lower than the twap, which prevent any liquidation from happening and causing the protocol to be under-collateralized.",
                "Repair": "N/A"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"../../lib/TransferHelper.sol\";\nimport \"../../lib/DexData.sol\";\nimport \"../../lib/Utils.sol\";\n\ncontract UniV2ClassDex {\n    using SafeMath for uint;\n    using Utils for uint;\n    using TransferHelper for IERC20;\n\n    struct V2PriceOracle {\n        uint32 blockTimestampLast;  // Last block timestamp when price updated\n        uint price0; // recorded price for token0\n        uint price1; // recorded price for token1\n        uint price0CumulativeLast; // Cumulative TWAP for token0\n        uint price1CumulativeLast; // Cumulative TWAP for token1\n    }\n\n    struct DexInfo {\n        IUniswapV2Factory factory;\n        uint16 fees;//30->0.3%\n    }\n\n    function uniClassSell(DexInfo memory dexInfo,\n        address buyToken,\n        address sellToken,\n        uint sellAmount,\n        uint minBuyAmount,\n        address payer,\n        address payee\n    ) internal returns (uint buyAmount){\n        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n        IUniswapV2Pair(pair).sync();\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n        uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n        dexInfo.fees = getPairFees(dexInfo, pair);\n        if (buyToken < sellToken) {\n            buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n            IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n        } else {\n            buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n            IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n        }\n\n        require(buyAmount >= minBuyAmount, 'buy amount less than min');\n        uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n        return bought;\n    }\n\n    function uniClassSellMul(DexInfo memory dexInfo, uint sellAmount, uint minBuyAmount, address[] memory tokens)\n    internal returns (uint buyAmount){\n        for (uint i = 1; i < tokens.length; i++) {\n            address sellToken = tokens[i - 1];\n            address buyToken = tokens[i];\n            bool isLast = i == tokens.length - 1;\n            address payer = i == 1 ? msg.sender : address(this);\n            address payee = isLast ? msg.sender : address(this);\n            buyAmount = uniClassSell(dexInfo, buyToken, sellToken, sellAmount, 0, payer, payee);\n            if (!isLast) {\n                sellAmount = buyAmount;\n            }\n        }\n        require(buyAmount >= minBuyAmount, 'buy amount less than min');\n    }\n\n    function uniClassBuy(\n        DexInfo memory dexInfo,\n        address buyToken,\n        address sellToken,\n        uint buyAmount,\n        uint maxSellAmount,\n        uint24 buyTokenFeeRate,\n        uint24 sellTokenFeeRate) internal returns (uint sellAmount){\n        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n        IUniswapV2Pair(pair).sync();\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        uint balanceBefore = IERC20(buyToken).balanceOf(msg.sender);\n        dexInfo.fees = getPairFees(dexInfo, pair);\n        if (buyToken < sellToken) {\n            sellAmount = getAmountIn(buyAmount.toAmountBeforeTax(buyTokenFeeRate), token1Reserves, token0Reserves, dexInfo.fees);\n            sellAmount = sellAmount.toAmountBeforeTax(sellTokenFeeRate);\n            require(sellAmount <= maxSellAmount, 'sell amount not enough');\n            transferOut(IERC20(sellToken), msg.sender, pair, sellAmount);\n            IUniswapV2Pair(pair).swap(buyAmount.toAmountBeforeTax(buyTokenFeeRate), 0, msg.sender, \"\");\n        } else {\n            sellAmount = getAmountIn(buyAmount.toAmountBeforeTax(buyTokenFeeRate), token0Reserves, token1Reserves, dexInfo.fees);\n            sellAmount = sellAmount.toAmountBeforeTax(sellTokenFeeRate);\n            require(sellAmount <= maxSellAmount, 'sell amount not enough');\n            transferOut(IERC20(sellToken), msg.sender, pair, sellAmount);\n            IUniswapV2Pair(pair).swap(0, buyAmount.toAmountBeforeTax(buyTokenFeeRate), msg.sender, \"\");\n        }\n\n        uint balanceAfter = IERC20(buyToken).balanceOf(msg.sender);\n        require(buyAmount <= balanceAfter.sub(balanceBefore), \"wrong amount bought\");\n    }\n\n    function uniClassCalBuyAmount(DexInfo memory dexInfo, address buyToken, address sellToken, uint sellAmount) internal view returns (uint) {\n        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        if (buyToken < sellToken) {\n            return getAmountOut(sellAmount, token1Reserves, token0Reserves, getPairFees(dexInfo, pair));\n        } else {\n            return getAmountOut(sellAmount, token0Reserves, token1Reserves, getPairFees(dexInfo, pair));\n        }\n    }\n\n    function uniClassCalSellAmount(\n        DexInfo memory dexInfo,\n        address buyToken,\n        address sellToken,\n        uint buyAmount,\n        uint24 buyTokenFeeRate,\n        uint24 sellTokenFeeRate) internal view returns (uint sellAmount) {\n        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        sellAmount = buyToken < sellToken ?\n        getAmountIn(buyAmount.toAmountBeforeTax(buyTokenFeeRate), token1Reserves, token0Reserves, getPairFees(dexInfo, pair)) :\n        getAmountIn(buyAmount.toAmountBeforeTax(buyTokenFeeRate), token0Reserves, token1Reserves, getPairFees(dexInfo, pair));\n\n        return sellAmount.toAmountBeforeTax(sellTokenFeeRate);\n    }\n\n    function uniClassGetPrice(IUniswapV2Factory factory, address desToken, address quoteToken, uint8 decimals) internal view returns (uint256){\n        address pair = getUniClassPair(desToken, quoteToken, factory);\n        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n        return desToken == IUniswapV2Pair(pair).token0() ?\n        token1Reserves.mul(10 ** decimals).div(token0Reserves) :\n        token0Reserves.mul(10 ** decimals).div(token1Reserves);\n    }\n\n    function uniClassGetAvgPrice(address desToken, address quoteToken, V2PriceOracle memory priceOracle) internal pure returns (uint256 price, uint256 timestamp){\n        timestamp = priceOracle.blockTimestampLast;\n        price = desToken < quoteToken ? uint(priceOracle.price0) : uint(priceOracle.price1);\n    }\n\n\n    function uniClassGetPriceCAvgPriceHAvgPrice(address pair, V2PriceOracle memory priceOracle, address desToken, address quoteToken, uint8 decimals)\n    internal view returns (uint price, uint cAvgPrice, uint256 hAvgPrice, uint256 timestamp){\n        bool isToken0 = desToken < quoteToken;\n        (uint256 token0Reserves, uint256 token1Reserves, uint32 uniBlockTimeLast) = IUniswapV2Pair(pair).getReserves();\n        price = isToken0 ?\n        token1Reserves.mul(10 ** decimals).div(token0Reserves) :\n        token0Reserves.mul(10 ** decimals).div(token1Reserves);\n\n        hAvgPrice = isToken0 ? uint(priceOracle.price0) : uint(priceOracle.price1);\n        timestamp = priceOracle.blockTimestampLast;\n\n        if (uniBlockTimeLast <= priceOracle.blockTimestampLast) {\n            cAvgPrice = hAvgPrice;\n        } else {\n            uint32 timeElapsed = uniBlockTimeLast - priceOracle.blockTimestampLast;\n            cAvgPrice = uint256(isToken0 ?\n                calTPrice(IUniswapV2Pair(pair).price0CumulativeLast(), priceOracle.price0CumulativeLast, timeElapsed, decimals) :\n                calTPrice(IUniswapV2Pair(pair).price1CumulativeLast(), priceOracle.price1CumulativeLast, timeElapsed, decimals));\n        }\n    }\n\n    function uniClassUpdatePriceOracle(address pair, V2PriceOracle memory priceOracle, uint32 timeWindow, uint8 decimals) internal returns (V2PriceOracle memory, bool updated) {\n        uint32 currentBlockTime = toUint32(block.timestamp);\n        if (currentBlockTime < (priceOracle.blockTimestampLast + timeWindow)) {\n            return (priceOracle, false);\n        }\n        (,,uint32 uniBlockTimeLast) = IUniswapV2Pair(pair).getReserves();\n        if (uniBlockTimeLast != currentBlockTime) {\n            IUniswapV2Pair(pair).sync();\n        }\n        uint32 timeElapsed = currentBlockTime - priceOracle.blockTimestampLast;\n        uint currentPrice0CumulativeLast = IUniswapV2Pair(pair).price0CumulativeLast();\n        uint currentPrice1CumulativeLast = IUniswapV2Pair(pair).price1CumulativeLast();\n        if (priceOracle.blockTimestampLast != 0) {\n            priceOracle.price0 = calTPrice(currentPrice0CumulativeLast, priceOracle.price0CumulativeLast, timeElapsed, decimals);\n            priceOracle.price1 = calTPrice(currentPrice1CumulativeLast, priceOracle.price1CumulativeLast, timeElapsed, decimals);\n        }\n        priceOracle.price0CumulativeLast = currentPrice0CumulativeLast;\n        priceOracle.price1CumulativeLast = currentPrice1CumulativeLast;\n        priceOracle.blockTimestampLast = currentBlockTime;\n        return (priceOracle, true);\n    }\n\n    function calTPrice(uint currentPriceCumulativeLast, uint historyPriceCumulativeLast, uint32 timeElapsed, uint8 decimals)\n    internal pure returns (uint){\n        return ((currentPriceCumulativeLast.sub(historyPriceCumulativeLast).mul(10 ** decimals)) >> 112).div(timeElapsed);\n    }\n\n    function toUint32(uint256 y) internal pure returns (uint32 z) {\n        require((z = uint32(y)) == y);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint16 fees) private pure returns (uint amountOut)\n    {\n        require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(uint(10000).sub(fees));\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint16 fees) private pure returns (uint amountIn) {\n        require(amountOut > 0, 'INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\n        uint denominator = reserveOut.sub(amountOut).mul(uint(10000).sub(fees));\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    function transferOut(IERC20 token, address payer, address to, uint amount) private returns (uint256 amountReceived) {\n        if (payer == address(this)) {\n            amountReceived = token.safeTransfer(to, amount);\n        } else {\n            amountReceived = token.safeTransferFrom(payer, to, amount);\n        }\n    }\n\n    function getUniClassPair(address tokenA, address tokenB, IUniswapV2Factory factory) internal view returns (address pair){\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        if (address(factory) == 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73) {\n            return address(uint(keccak256(abi.encodePacked(\n                    hex'ff',\n                    address(factory),\n                    keccak256(abi.encodePacked(token0, token1)),\n                    hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n                ))));\n        } else {\n            return factory.getPair(tokenA, tokenB);\n        }\n    }\n\n    function getPairFees(DexInfo memory dexInfo, address pair) private view returns (uint16){\n        //mdex\n        if (address(dexInfo.factory) == 0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8) {\n            return toUint16((IMdexFactory)(address(dexInfo.factory)).getPairFees(pair));\n        } else {\n            return dexInfo.fees;\n        }\n    }\n\n    function toUint16(uint256 y) internal pure returns (uint16 z) {\n        require((z = uint16(y)) == y);\n    }\n}\n\ninterface IMdexFactory {\n    function getPairFees(address) external view returns (uint256);\n}\n\n",
        "CodeNames": [
            "UniV2ClassDex.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniV2ClassDex.sol#uniClassSell()",
                "Type": "Trust Issue",
                "Description": "While uniClassBuy() correctly checks the actually received amount by comparing the before and after the balance of the receiver, uniClassSell() trusted the result given by getAmountOut(). This makes uniClassSell() can result in an output amount fewer than minBuyAmount.",
                "Repair": "Change the code to check the actually received amount by comparing the before and after the balance of the receiver"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/// @title Admin to all OpenLeverage contracts\n/// @author OpenLeverage\n/// @dev Fork from compound https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 3 minutes;\n    uint public constant MAXIMUM_DELAY = 3 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n    bool public admin_initialized;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) {\n        require(delay_ >= MINIMUM_DELAY, \"Delay must exceed minimum\");\n        require(delay_ <= MAXIMUM_DELAY, \"Delay must not exceed maximum\");\n\n        admin = admin_;\n        delay = delay_;\n        admin_initialized = false;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Call must come from Timelock\");\n        require(delay_ >= MINIMUM_DELAY, \"Delay must exceed minimum\");\n        require(delay_ <= MAXIMUM_DELAY, \"Delay must not exceed maximum\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Call must from pendingAdmin\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        if (admin_initialized) {\n            require(msg.sender == address(this), \"Call must come from Timelock\");\n        } else {\n            require(msg.sender == admin, \"Call must come from admin\");\n            admin_initialized = true;\n        }\n        pendingAdmin = pendingAdmin_;\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    /// @dev Save transactions before execution. Allowed to cancel before eta\n    /// @param target Address of contract to call.\n    /// @param value Amount of native token send along with the transaction.\n    /// @param signature Function signature of the target contract.\n    /// @param data Argument pass to the target function.\n    /// @param eta time before execution.\n    /// @return ID of the transaction\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Call must come from admin\");\n        require(eta >= getBlockTimestamp().add(delay), \"ETA must satisfy delay\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    /// @dev cancel queued transactions.\n    /// @param target Address of contract to call.\n    /// @param value Amount of native token send along with the transaction.\n    /// @param signature Function signature of the target contract.\n    /// @param data Argument pass to the target function.\n    /// @param eta time before execution.\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Call must come from admin\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        delete queuedTransactions[txHash];\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    /// @dev execute queued transactions.\n    /// @param target Address of contract to call.\n    /// @param value Amount of native token send along with the transaction.\n    /// @param signature Function signature of the target contract.\n    /// @param data Argument pass to the target function.\n    /// @param eta time before execution.\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Call must come from admin\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        if (admin_initialized) {\n            require(queuedTransactions[txHash], \"Tx hasn't been queued\");\n            require(getBlockTimestamp() >= eta, \"Not surpassed timelock\");\n            require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Transaction is stale\");\n            delete queuedTransactions[txHash];\n        }\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value : value}(callData);\n        require(success, \"Transaction execution reverted\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n\n",
        "CodeNames": [
            "Timelock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Timelock contract",
                "Type": "Locking Funds",
                "Description": "Eth sent to Timelock will be locked in current implementation. Consider implementing the provided code to execute the proposal and send funds from the timelock contract.",
                "Repair": "Implement the provided code to execute the proposal and send funds from the timelock contract"
            }
        ]
    }
]