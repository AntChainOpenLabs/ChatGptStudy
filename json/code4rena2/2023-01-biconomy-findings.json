[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // AA implementation\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    \n    //called by entryPoint, only after validateUserOp succeeded.\n    //@review\n    //Method is updated to instruct delegate call and emit regular events\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n        success = execute(dest, value, func, operation, gasLimit);\n        require(success, \"Userop Failed\");\n    }\n\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    // @notice Nonce space is locked to 0 for AA transactions\n    // userOp could have batchId as well\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 deadline) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n        // solhint-disable-next-line avoid-tx-origin\n        require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n        return 0;\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n    */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "SmartAccount.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SmartAccount.sol, execTransaction function",
                "Type": "Theft of funds under relaying the transaction",
                "Description": "An attacker could manipulate the calldata to increase the refund amount while spending less gas than what is calculated by the contract. This would only cost 4 gas per zero byte, but the refund would be calculated as 8 gas per calldata byte. As a result, the refund amount would be higher than the gas amount spent by the relayer. An attacker can frontrun the transaction, changing the transaction calldata by adding the zeroes bytes at the end.",
                "Repair": "Bound the length of the signature and sum the length of each dynamic and static length parameters to calculate the expected number of bytes used by the relayer. Check the length of the msg.data against the expected number of bytes to prevent an attacker from providing non-standard ABI encoding for the PoC calldata. "
            },
            {
                "Location": "checkSignatures function in SmartAccount.sol",
                "Type": "Arbitrary transactions possible due to insufficient signature validation",
                "Description": "A hacker can create arbitrary transaction through the smart wallet by evading signature validation. The vulnerability allows the hacker to steal all funds from the smart wallet and destroy the proxy or lock the wallet from EOAs by updating the implementation contract.",
                "Repair": "The protocol should validate before calling isValidSignature that _signer is owner."
            },
            {
                "Location": "SmartAccount.sol",
                "Type": "Replay attack (EIP712 signed transaction)",
                "Description": "Signed transaction can be replayed.",
                "Repair": "Add batchId to the hash calculation of the transaction in encodeTransactionData function"
            },
            {
                "Location": "SmartAccount.sol",
                "Type": "Inheriting from contracts that contain storage and no gaps",
                "Description": "SmartAccount.sol inherits from contracts that are not stateless and don't contain storage gaps which can be dangerous when upgrading.",
                "Repair": "Add storage gaps to all inherited contracts that contain storage variables"
            },
            {
                "Location": "execute and executeBatch functions in SmartAccount.sol",
                "Type": "Access Control",
                "Description": "The execute and executeBatch functions in SmartAccount.sol have onlyOwner modifier which restricts their access to the owner only, breaking the interaction with EntryPoint. The reference implementation has both these functions without any onlyOwner modifiers.",
                "Repair": "Remove onlyOwner modifier from execute and executeBatch functions"
            },
            {
                "Location": "execTransaction function in SmartAccount.sol",
                "Type": "Nonce Collision",
                "Description": "Transactions can fail due to batchId collision, which can result in unexpected failing of transactions. There are two main ways to execute transactions from the smart wallet, and due to different ways to execute transactions on the wallet, there could be a collision between batchIds being used.",
                "Repair": "Add a requirement that batchId is not 0 in execTransaction"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // AA implementation\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    \n    //called by entryPoint, only after validateUserOp succeeded.\n    //@review\n    //Method is updated to instruct delegate call and emit regular events\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n        success = execute(dest, value, func, operation, gasLimit);\n        require(success, \"Userop Failed\");\n    }\n\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    // @notice Nonce space is locked to 0 for AA transactions\n    // userOp could have batchId as well\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 deadline) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n        // solhint-disable-next-line avoid-tx-origin\n        require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n        return 0;\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n    */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./Proxy.sol\";\nimport \"./BaseSmartAccount.sol\"; \n\ncontract SmartAccountFactory {\n    address immutable public _defaultImpl; \n\n    // EOA + Version tracking\n    string public constant VERSION = \"1.0.2\";\n\n    //states : registry\n    // review need and impact of this update wallet -> account\n    mapping (address => bool) public isAccountExist;\n\n    constructor(address _baseImpl) {\n        require(_baseImpl != address(0), \"base wallet address can not be zero\");\n        _defaultImpl = _baseImpl;\n    }\n\n    // event SmartAccountCreated(address indexed _proxy, address indexed _implementation, address indexed _owner);\n    // EOA + Version tracking\n    event SmartAccountCreated(address indexed _proxy, address indexed _implementation, address indexed _owner, string version, uint256 _index);\n\n    /**\n     * @notice Deploys wallet using create2 and points it to _defaultImpl\n     * @param _owner EOA signatory of the wallet\n     * @param _entryPoint AA 4337 entry point address\n     * @param _handler fallback handler address\n     * @param _index extra salt that allows to deploy more wallets if needed for same EOA (default 0)\n     */\n    function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n        bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n        // EOA + Version tracking\n        emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);\n        BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n        isAccountExist[proxy] = true;\n    }\n\n    /**\n     * @notice Deploys wallet using create and points it to _defaultImpl\n     * @param _owner EOA signatory of the wallet\n     * @param _entryPoint AA 4337 entry point address\n     * @param _handler fallback handler address\n    */ \n    function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){ \n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create(0x0, add(0x20, deploymentData), mload(deploymentData))\n        }\n        BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n        isAccountExist[proxy] = true;\n    }\n\n    /**\n     * @notice Allows to find out wallet address prior to deployment\n     * @param _owner EOA signatory of the wallet\n     * @param _index extra salt that allows to deploy more wallets if needed for same EOA (default 0)\n    */\n    function getAddressForCounterfactualWallet(address _owner, uint _index) external view returns (address _wallet) {\n       bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n       bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n       bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        _wallet = address(uint160(uint(hash)));\n    }\n\n}\n\n",
        "CodeNames": [
            "SmartAccount.sol",
            "SmartAccountFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SmartAccountFactory.deployCounterFactualWallet function and SmartAccount.execFromEntryPoint function",
                "Type": "Control Flow Hijacking",
                "Description": "An attacker can deploy the counterfactual wallet on behalf of the owner and use an arbitrary entrypoint, allowing them to execute any arbitrary call or code using delegatecall and gain total control over the wallet.",
                "Repair": "Include the entrypoint as part of the salt during address generation"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "contracts/smart-contract-wallet/SmartAccount.sol#L166, contracts/smart-contract-wallet/SmartAccount.sol#L192, contracts/smart-contract-wallet/SmartAccount.sol#L229, contracts/smart-contract-wallet/base/Executor.sol#L23",
                "Type": "Destruction of SmartAccount implementation",
                "Description": "If the SmartAccount implementation contract is not initialized, it can be destroyed using a delegatecall to a contract that executes the selfdestruct opcode on any incoming call, resulting in the freezing of all functionality of the wallets that point to such an implementation.",
                "Repair": "Add initialization of the SmartAccount implementation to the deploy script or add a constructor to the SmartAccount contract that prevents the implementation contract from being initialized"
            },
            {
                "Location": "[contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68)",
                "Type": "Non-compliance with EIP-4337",
                "Description": "Some parts of the codebase are not compliant with the EIP-4337 from the EIP-4337 specifications.",
                "Repair": "Refactor the code that is not compliant with the EIP."
            },
            {
                "Location": "[contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L68](https://github.com/code-423n4/2023-01-biconomy/blob/5df2e8f8c0fd3393b9ecdad9ef356955f07fbbdd/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L68) and [contracts/smart-contract-wallet/libs/MultiSend.sol#L26](https://github.com/code-423n4/2023-01-biconomy/blob/5df2e8f8c0fd3393b9ecdad9ef356955f07fbbdd/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol#L26)",
                "Type": "Griefing attacks",
                "Description": "Relayer offchain verify the batch of UserOperations, convinced that they will receive fees, then send the handleOps transaction to the mempool. An attacker front-run the relayers transaction with another handleOps transaction that executes only one UserOperation, the last user operation from the relayers handleOps operations. An attacker will receive the funds for one UserOperation. Original relayers transaction will consume gas for the execution of all except one, user ops, but reverts at the end.",
                "Repair": "Remove redundant require-like checks from internal functions called from the handleOps function and add the non-atomic execution logic to the multiSend function."
            },
            {
                "Location": "[contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L6](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L6), [contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L19](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L19), and [contracts/smart-contract-wallet/SmartAccount.sol#L342](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342)",
                "Type": "Doesn't Follow ERC1271 Standard",
                "Description": "As Per EIP-1271 standard ERC1271_MAGIC_VAULE should be 0x1626ba7e instead of 0x20c13b0b and function name should be isValidSignature(bytes32,bytes) instead of  isValidSignature(bytes,bytes). Due to this, signature verifier contract go fallback function and return unexpected value and never return ERC1271_MAGIC_VALUE and always revert execTransaction function.",
                "Repair": "Follow EIP-1271 standard."
            },
            {
                "Location": "FeeRefund.tokenGasPriceFactor",
                "Type": "Signature Verification Bypass",
                "Description": "The submitter of a transaction can steal funds by not including tokenGasPriceFactor in the signed transaction data and submitting the transaction with a different value for tokenGasPriceFactor.",
                "Repair": "Include tokenGasPriceFactor in the signed transaction data and verify it with the user's signature"
            }
        ]
    },
    {
        "Code": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-tx-origin */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\n\nimport \"../interfaces/IAggregatedAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\n\ncontract EntryPoint is IEntryPoint, StakeManager {\n\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex into into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n            collected = _actualGasCost;\n        } catch {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an \"actualAggregator\" when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\n\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint256 i = 0; i < opslen; i++) {\n            _validatePrepayment(i, ops[i], opInfos[i], address(0));\n        }\n\n        uint256 collected = 0;\n\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\n        }\n\n        _compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            totalOps += opsPerAggregator[i].userOps.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                _validatePrepayment(opIndex, ops[i], opInfos[opIndex], address(aggregator));\n                opIndex++;\n            }\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n\n            (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is SimulationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        uint256 preGas = gasleft();\n\n        UserOpInfo memory outOpInfo;\n\n        (address aggregator, uint256 deadline) = _validatePrepayment(0, userOp, outOpInfo, SIMULATE_FIND_AGGREGATOR);\n        uint256 prefund = outOpInfo.prefund;\n        uint256 preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        StakeInfo memory paymasterInfo = getStakeInfo(outOpInfo.mUserOp.paymaster);\n        StakeInfo memory senderInfo = getStakeInfo(outOpInfo.mUserOp.sender);\n        bytes calldata initCode = userOp.initCode;\n        address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\n        StakeInfo memory factoryInfo = getStakeInfo(factory);\n\n        if (aggregator != address(0)) {\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, getStakeInfo(aggregator));\n            revert SimulationResultWithAggregation(preOpGas, prefund, deadline, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\n        }\n        revert SimulationResult(preOpGas, prefund, deadline, senderInfo, factoryInfo, paymasterInfo);\n\n    }\n\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal view returns (uint256 requiredPrefund) {\n    unchecked {\n        //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n        // our security model might call postOp eventually twice\n        uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n        uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\n\n        // TODO: copy logic of gasPrice?\n        requiredPrefund = requiredGas * getUserOpGasPrice(mUserOp);\n    }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\n            address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\n            if (sender1 == address(0)) revert FailedOp(opIndex, address(0), \"AA13 initCode failed or OOG\");\n            if (sender1 != sender) revert FailedOp(opIndex, address(0), \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0 : 20]));\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n        }\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes calldata initCode) public {\n        revert SenderAddressResult(senderCreator.createSender(initCode));\n    }\n\n    /**\n     * call account.validateUserOp.\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * decrement account's deposit if needed\n     */\n    function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, address aggregator, uint256 requiredPrefund)\n    internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) {\n    unchecked {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        address sender = mUserOp.sender;\n        _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n        if (aggregator == SIMULATE_FIND_AGGREGATOR) {\n            numberMarker();\n\n            if (sender.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert FailedOp(0, address(0), \"AA20 account not deployed\");\n            }\n            if (mUserOp.paymaster != address(0) && mUserOp.paymaster.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert FailedOp(0, address(0), \"AA30 paymaster not deployed\");\n            }\n            try IAggregatedAccount(sender).getAggregator() returns (address userOpAggregator) {\n                aggregator = actualAggregator = userOpAggregator;\n            } catch {\n                aggregator = actualAggregator = address(0);\n            }\n        }\n        uint256 missingAccountFunds = 0;\n        address paymaster = mUserOp.paymaster;\n        if (paymaster == address(0)) {\n            uint256 bal = balanceOf(sender);\n            missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n        }\n        try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, aggregator, missingAccountFunds) returns (uint256 _deadline) {\n            // solhint-disable-next-line not-rely-on-time\n            if (_deadline != 0 && _deadline < block.timestamp) {\n                revert FailedOp(opIndex, address(0), \"AA22 expired\");\n            }\n            deadline = _deadline;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, address(0), revertReason);\n        } catch {\n            revert FailedOp(opIndex, address(0), \"AA23 reverted (or OOG)\");\n        }\n        if (paymaster == address(0)) {\n            DepositInfo storage senderInfo = deposits[sender];\n            uint256 deposit = senderInfo.deposit;\n            if (requiredPrefund > deposit) {\n                revert FailedOp(opIndex, address(0), \"AA21 didn't pay prefund\");\n            }\n            senderInfo.deposit = uint112(deposit - requiredPrefund);\n        }\n        gasUsedByValidateAccountPrepayment = preGas - gasleft();\n    }\n    }\n\n    /**\n     * in case the request has a paymaster:\n     * validate paymaster is staked and has enough deposit.\n     * call paymaster.validatePaymasterUserOp.\n     * revert with proper FailedOp in case paymaster reverts.\n     * decrement paymaster's deposit\n     */\n    function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {\n    unchecked {\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n        require(verificationGasLimit > gasUsedByValidateAccountPrepayment, \"AA41 too little verificationGas\");\n        uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\n\n        address paymaster = mUserOp.paymaster;\n        DepositInfo storage paymasterInfo = deposits[paymaster];\n        uint256 deposit = paymasterInfo.deposit;\n        if (deposit < requiredPreFund) {\n            revert FailedOp(opIndex, paymaster, \"AA31 paymaster deposit too low\");\n        }\n        paymasterInfo.deposit = uint112(deposit - requiredPreFund);\n        try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _deadline){\n            // solhint-disable-next-line not-rely-on-time\n            if (_deadline != 0 && _deadline < block.timestamp) {\n                revert FailedOp(opIndex, paymaster, \"AA32 paymaster expired\");\n            }\n            context = _context;\n            deadline = _deadline;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, paymaster, revertReason);\n        } catch {\n            revert FailedOp(opIndex, paymaster, \"AA33 reverted (or OOG)\");\n        }\n    }\n    }\n\n    /**\n     * validate account and paymaster (if defined).\n     * also make sure total validation doesn't exceed verificationGasLimit\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex the index of this userOp into the \"opInfos\" array\n     * @param userOp the userOp to validate\n     */\n    function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory outOpInfo, address aggregator)\n    private returns (address actualAggregator, uint256 deadline) {\n\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow\n        uint256 maxGasValues = mUserOp.preVerificationGas | mUserOp.verificationGasLimit | mUserOp.callGasLimit |\n        userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 gasUsedByValidateAccountPrepayment;\n        (uint256 requiredPreFund) = _getRequiredPrefund(mUserOp);\n        (gasUsedByValidateAccountPrepayment, actualAggregator, deadline) = _validateAccountPrepayment(opIndex, userOp, outOpInfo, aggregator, requiredPreFund);\n        //a \"marker\" where account opcode validation is done and paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        numberMarker();\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            uint paymasterDeadline;\n            (context, paymasterDeadline) = _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, gasUsedByValidateAccountPrepayment);\n            if (paymasterDeadline != 0 && paymasterDeadline < deadline) {\n                deadline = paymasterDeadline;\n            }\n        } else {\n            context = \"\";\n\n        }\n    unchecked {\n        uint256 gasUsed = preGas - gasleft();\n\n        if (userOp.verificationGasLimit < gasUsed) {\n            revert FailedOp(opIndex, mUserOp.paymaster, \"AA40 over verificationGasLimit\");\n        }\n        outOpInfo.prefund = requiredPreFund;\n        outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n        outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n    }\n    }\n\n    /**\n     * process post-operation.\n     * called just after the callData is executed.\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * the excess amount is refunded to the account (or paymaster - if it is was used in the request)\n     * @param opIndex index in the batch\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\n     * @param opInfo userOp fields and info collected during validation\n     * @param context the context returned in validatePaymasterUserOp\n     * @param actualGas the gas used so far by this user operation\n     */\n    function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOpInfo memory opInfo, bytes memory context, uint256 actualGas) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n    unchecked {\n        address refundAddress;\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n        address paymaster = mUserOp.paymaster;\n        if (paymaster == address(0)) {\n            refundAddress = mUserOp.sender;\n        } else {\n            refundAddress = paymaster;\n            if (context.length > 0) {\n                actualGasCost = actualGas * gasPrice;\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                    IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost);\n                } else {\n                    // solhint-disable-next-line no-empty-blocks\n                    try IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost) {}\n                    catch Error(string memory reason) {\n                        revert FailedOp(opIndex, paymaster, reason);\n                    }\n                    catch {\n                        revert FailedOp(opIndex, paymaster, \"A50 postOp revert\");\n                    }\n                }\n            }\n        }\n        actualGas += preGas - gasleft();\n        actualGasCost = actualGas * gasPrice;\n        if (opInfo.prefund < actualGasCost) {\n            revert FailedOp(opIndex, paymaster, \"A51 prefund below actualGasCost\");\n        }\n        uint256 refund = opInfo.prefund - actualGasCost;\n        internalIncrementDeposit(refundAddress, refund);\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n        emit UserOperationEvent(opInfo.userOpHash, mUserOp.sender, mUserOp.paymaster, mUserOp.nonce, success, actualGasCost, actualGas);\n    } // unchecked\n    }\n\n    /**\n     * the gas price this UserOp agrees to pay.\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\n     */\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\n    unchecked {\n        uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            //legacy mode (for networks that don't support basefee opcode)\n            return maxFeePerGas;\n        }\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n    }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n        assembly {offset := data}\n    }\n\n    function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n        assembly {data := offset}\n    }\n\n    //place the NUMBER opcode in the code.\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\n    // account and paymaster.\n    function numberMarker() internal view {\n        assembly {mstore(0, number())}\n    }\n}\n\n",
        "CodeNames": [
            "EntryPoint.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "EntryPoint.sol",
                "Type": "DoS and loss of user transaction fee",
                "Description": "An attacker (e.g. a malicious bundler) could submit a bundle of high gas usage user operations with insufficient gas value, causing the bundle to fail even when the users calculated the gas limits correctly. This will result in a DoS for the user and the user/paymaster still have to pay for the execution, potentially draining their funds.",
                "Repair": "Update the Account Abstraction implementation to the latest version. This will update the innerHandleOp() to verify that remaining gas is more than sufficient to cover the specified mUserOp.callGasLimit and mUserOp.verificationGasLimit."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable reason-string */\nimport \"../../BasePaymaster.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../PaymasterHelpers.sol\";\n// import \"../samples/Signatures.sol\";\n\n\n/**\n * A sample paymaster that uses external service to decide whether to pay for the UserOp.\n * The paymaster trusts an external signer to sign the transaction.\n * The calling user must pass the UserOp to that external signer first, which performs\n * whatever off-chain verification before signing the UserOp.\n * Note that this signature is NOT a replacement for wallet signature:\n * - the paymaster signs to agree to PAY for GAS.\n * - the wallet signs to prove identity and wallet ownership.\n */\ncontract VerifyingSingletonPaymaster is BasePaymaster {\n\n    using ECDSA for bytes32;\n    // possibly //  using Signatures for UserOperation;\n    using UserOperationLib for UserOperation;\n    using PaymasterHelpers for UserOperation;\n    using PaymasterHelpers for bytes;\n    using PaymasterHelpers for PaymasterData;\n\n    mapping(address => uint256) public paymasterIdBalances;\n\n    address public verifyingSigner;\n\n    constructor(IEntryPoint _entryPoint, address _verifyingSigner) BasePaymaster(_entryPoint) {\n        require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n        require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n        verifyingSigner = _verifyingSigner;\n    }\n\n    function deposit() public virtual override payable {\n        revert(\"Deposit must be for a paymasterId. Use depositFor\");\n    }\n\n    /**\n     * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees\n     */\n    function depositFor(address paymasterId) public payable {\n        require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n        require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n        paymasterIdBalances[paymasterId] += msg.value;\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public override {\n        uint256 currentBalance = paymasterIdBalances[msg.sender];\n        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n        paymasterIdBalances[msg.sender] -= amount;\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    \n    /**\n    this function will let owner change signer\n    */\n    function setSigner( address _newVerifyingSigner) external onlyOwner{\n        require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n        verifyingSigner = _newVerifyingSigner;\n    }\n\n    /**\n     * return the hash we're going to sign off-chain (and validate on-chain)\n     * this method is called by the off-chain service, to sign the request.\n     * it is called on-chain from the validatePaymasterUserOp, to validate the signature.\n     * note that this signature covers all fields of the UserOperation, except the \"paymasterAndData\",\n     * which will carry the signature itself.\n     */\n    function getHash(UserOperation calldata userOp)\n    public pure returns (bytes32) {\n        //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        return keccak256(abi.encode(\n                userOp.getSender(),\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas\n            ));\n    }\n\n    /**\n     * verify our external signer signed this request.\n     * the \"paymasterAndData\" is expected to be the paymaster and a signature over the entire request params\n     */\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    external view override returns (bytes memory context, uint256 deadline) {\n        (requiredPreFund);\n        bytes32 hash = getHash(userOp);\n\n        PaymasterData memory paymasterData = userOp.decodePaymasterData();\n        uint256 sigLength = paymasterData.signatureLength;\n\n        //ECDSA library supports both 64 and 65-byte long signatures.\n        // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n        require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n        require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n        return (userOp.paymasterContext(paymasterData), 0);\n    }\n\n    /**\n   * @dev Executes the paymaster's payment conditions\n   * @param mode tells whether the op succeeded, reverted, or if the op succeeded but cause the postOp to revert\n   * @param context payment conditions signed by the paymaster in `validatePaymasterUserOp`\n   * @param actualGasCost amount to be paid to the entry point in wei\n   */\n  function _postOp(\n    PostOpMode mode,\n    bytes calldata context,\n    uint256 actualGasCost\n  ) internal virtual override {\n    (mode);\n    // (mode,context,actualGasCost); // unused params\n    PaymasterContext memory data = context.decodePaymasterContext();\n    address extractedPaymasterId = data.paymasterId;\n    paymasterIdBalances[extractedPaymasterId] -= actualGasCost;\n  }\n\n}\n\n",
        "CodeNames": [
            "VerifyingSingletonPaymaster.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VerifyingSingletonPaymaster.sol",
                "Type": "Paymaster ETH can be drained with malicious sender",
                "Description": "Paymaster's signature can be replayed to drain their deposits.",
                "Repair": "Add a check for nonce in the validatePaymasterUserOp function"
            },
            {
                "Location": "VerifyingSingletonPaymaster.sol#getHash()",
                "Type": "Cross-Chain Signature Replay Attack",
                "Description": "User operations can be replayed on smart accounts across different chains.",
                "Repair": "Add the chainId in the calculation of the UserOperation hash"
            }
        ]
    }
]