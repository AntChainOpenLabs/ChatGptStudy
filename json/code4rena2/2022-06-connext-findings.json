[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20, Address} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\nimport {ITokenExchange} from \"../interfaces/ITokenExchange.sol\";\nimport {IGasTokenOracle} from \"../interfaces/IGasTokenOracle.sol\";\n\n/**\n * @title SponsorVault\n * @author Connext Labs\n * @notice Contains logic for sponsoring liquidity and relayer fees\n */\ncontract SponsorVault is ISponsorVault, Ownable {\n  // ============ Libraries ============\n  using SafeERC20 for IERC20;\n\n  // ============ Struct ============\n  struct Rate {\n    uint256 num;\n    uint256 den;\n  }\n\n  // ============ Private storage ============\n\n  // ============ Public storage ============\n\n  /**\n   * @notice The address of connext\n   */\n  address public connext;\n\n  /**\n   * @notice The origin domain to this domain native token rates\n   * @dev Used when no oracle is available\n   */\n  mapping(uint32 => Rate) public rates;\n\n  /**\n   * @notice The maximum amount this domain native token to be sponsored for relayer fee\n   */\n  uint256 public relayerFeeCap;\n\n  /**\n   * @notice The origin domain to this domain native token oracle\n   * @dev Used to calculate sponsored relayer fee\n   */\n  IGasTokenOracle public gasTokenOracle;\n\n  /**\n   * @notice The this domain native token to token exchange\n   * @dev Used to exchange this domain native token to the token used to pay liquidity fees\n   */\n  mapping(address => ITokenExchange) public tokenExchanges;\n\n  // ============ Errors ============\n\n  error SponsorVault__setConnext_invalidConnext();\n  error SponsorVault__setRate_invalidOriginDomain();\n  error SponsorVault__setGasTokenOracle_invalidOriginDomain();\n  error SponsorVault__setTokenExchange_invalidAdopted();\n  error SponsorVault__onlyConnext();\n  error SponsorVault__withdraw_invalidAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new connext is set\n   */\n  event ConnextUpdated(address oldConnext, address newConnext, address caller);\n\n  /**\n   * @notice Emitted when a new rate is set\n   */\n  event RateUpdated(uint32 originDomain, Rate oldRate, Rate newRate, address caller);\n\n  /**\n   * @notice Emitted when a new relayerFeeCap is set\n   */\n  event RelayerFeeCapUpdated(uint256 oldRelayerFeeCap, uint256 newRelayerFeeCap, address caller);\n\n  /**\n   * @notice Emitted when a new native token oracle is set\n   */\n  event GasTokenOracleUpdated(address oldOracle, address newOracle, address caller);\n\n  /**\n   * @notice Emitted when a new token exchange is set\n   */\n  event TokenExchangeUpdated(address token, address oldTokenExchange, address newTokenExchange, address caller);\n\n  /**\n   * @notice Emitted when a liquidity fee is reimbursed\n   */\n  event ReimburseLiquidityFees(address token, uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when a relayer fee is reimbursed\n   */\n  event ReimburseRelayerFees(uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when liquidity is added\n   */\n  event Deposit(address token, uint256 amount, address caller);\n\n  /**\n   * @notice Emitted when liquidity is removed\n   */\n  event Withdraw(address token, address receiver, uint256 amount, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Restricts the caller to connext\n   */\n  modifier onlyConnext() {\n    if (msg.sender != connext) revert SponsorVault__onlyConnext();\n    _;\n  }\n\n  // ============ Constructor ============\n\n  constructor(address _connext) Ownable() {\n    _setConnext(_connext);\n  }\n\n  // ============ Owner Functions ============\n\n  /**\n   * @notice Sets the Connext.\n   * @dev Connext and sponsor vault store references to each other\n   * @param _connext The address of the Connext implementation\n   */\n  function setConnext(address _connext) external onlyOwner {\n    _setConnext(_connext);\n  }\n\n  /**\n   * @notice Sets default origin domain native token to this domain native token rate.\n   * @param _originDomain The origin domain\n   * @param _rate The default rate\n   */\n  function setRate(uint32 _originDomain, Rate calldata _rate) external onlyOwner {\n    if (_originDomain == 0) revert SponsorVault__setRate_invalidOriginDomain();\n\n    emit RateUpdated(_originDomain, rates[_originDomain], _rate, msg.sender);\n\n    rates[_originDomain] = _rate;\n  }\n\n  /**\n   * @notice Sets the maximum sponsored relayer fee amount.\n   * @param _relayerFeeCap The new relayerFeeCap\n   */\n  function setRelayerFeeCap(uint256 _relayerFeeCap) external onlyOwner {\n    emit RelayerFeeCapUpdated(relayerFeeCap, _relayerFeeCap, msg.sender);\n    relayerFeeCap = _relayerFeeCap;\n  }\n\n  /**\n   * @notice Sets of an oracle that provides origin domain native token to this domain native token rates.\n   * @param _gasTokenOracle The oracle address\n   */\n  function setGasTokenOracle(address _gasTokenOracle) external onlyOwner {\n    emit GasTokenOracleUpdated(address(gasTokenOracle), _gasTokenOracle, msg.sender);\n    gasTokenOracle = IGasTokenOracle(_gasTokenOracle);\n  }\n\n  /**\n   * @notice Sets the address of an exchange used for swapping this domain native token for a given token.\n   * @param _token The address of the token\n   * @param _tokenExchange The oracle of the exchange\n   */\n  function setTokenExchange(address _token, address payable _tokenExchange) external onlyOwner {\n    if (_token == address(0)) revert SponsorVault__setTokenExchange_invalidAdopted();\n\n    emit TokenExchangeUpdated(_token, address(tokenExchanges[_token]), _tokenExchange, msg.sender);\n    tokenExchanges[_token] = ITokenExchange(_tokenExchange);\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Performs liquidity fee reimbursement.\n   * @dev Uses the token exchange or liquidity deposited in this contract.\n   *      The `_receiver` address is only used for emitting in the event.\n   * @param _token The address of the token\n   * @param _liquidityFee The liquidity fee amount\n   * @param _receiver The address of the receiver\n   * @return Sponsored liquidity fee amount\n   */\n  function reimburseLiquidityFees(\n    address _token,\n    uint256 _liquidityFee,\n    address _receiver\n  ) external override onlyConnext returns (uint256) {\n    uint256 sponsoredFee;\n\n    if (address(tokenExchanges[_token]) != address(0)) {\n      uint256 currentBalance = address(this).balance;\n      ITokenExchange tokenExchange = tokenExchanges[_token];\n\n      uint256 amountIn = tokenExchange.getInGivenExpectedOut(_token, _liquidityFee);\n      amountIn = currentBalance >= amountIn ? amountIn : currentBalance;\n\n      // sponsored fee may end being less than _liquidityFee due to slippage\n      sponsoredFee = tokenExchange.swapExactIn{value: amountIn}(_token, msg.sender);\n    } else {\n      uint256 balance = IERC20(_token).balanceOf(address(this));\n      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee;\n\n      // some ERC20 do not allow to transfer 0 amount\n      if (sponsoredFee > 0) {\n        IERC20(_token).safeTransfer(msg.sender, sponsoredFee);\n      }\n    }\n\n    emit ReimburseLiquidityFees(_token, sponsoredFee, _receiver);\n\n    return sponsoredFee;\n  }\n\n  /**\n   * @notice Performs relayer fee reimbursement sending the corresponding amount of this domain native token to `_to`.\n   * @dev Uses the configured oracle or default rate otherwise.\n   * @param _originDomain The origin domain id\n   * @param _to The fee recipient\n   * @param _originRelayerFee The relayer fee amount in origin domain native token\n   */\n  function reimburseRelayerFees(\n    uint32 _originDomain,\n    address payable _to,\n    uint256 _originRelayerFee\n  ) external override onlyConnext {\n    uint256 sponsoredFee;\n    uint256 num;\n    uint256 den;\n\n    if (address(gasTokenOracle) != address(0)) {\n      (num, den) = gasTokenOracle.getRate(_originDomain);\n\n      sponsoredFee = (_originRelayerFee * num) / den;\n    } else {\n      num = rates[_originDomain].num;\n      den = rates[_originDomain].den;\n    }\n\n    if (den != 0) {\n      sponsoredFee = (_originRelayerFee * num) / den;\n\n      // calculated or max\n      sponsoredFee = sponsoredFee > relayerFeeCap ? relayerFeeCap : sponsoredFee;\n      // calculated or leftover\n      sponsoredFee = sponsoredFee > address(this).balance ? address(this).balance : sponsoredFee;\n\n      Address.sendValue(_to, sponsoredFee);\n    }\n    emit ReimburseRelayerFees(sponsoredFee, _to);\n  }\n\n  /**\n   * @notice Adds liquidity to the sponsor vault, native token or ERC20.\n   * @dev Anyone can add liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _amount The amount of ERC20 to deposit or zero for native token since the amount is sent in msg.value\n   */\n  function deposit(address _token, uint256 _amount) external payable {\n    if (_token != address(0)) {\n      IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    emit Deposit(_token, _token != address(0) ? _amount : msg.value, msg.sender);\n  }\n\n  /**\n   * @notice Removes liquidity from the sponsor vault, native token or ERC20.\n   * @dev Only the owner can remove liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _receiver The receiver of the tokens\n   * @param _amount The amount to remove\n   */\n  function withdraw(\n    address _token,\n    address _receiver,\n    uint256 _amount\n  ) external onlyOwner {\n    if (_token == address(0)) {\n      if (address(this).balance < _amount) revert SponsorVault__withdraw_invalidAmount();\n      Address.sendValue(payable(_receiver), _amount);\n    } else {\n      if (IERC20(_token).balanceOf(address(this)) < _amount) revert SponsorVault__withdraw_invalidAmount();\n      IERC20(_token).safeTransfer(_receiver, _amount);\n    }\n\n    emit Withdraw(_token, _receiver, _amount, msg.sender);\n  }\n\n  // ============ Internal functions ============\n\n  function _setConnext(address _connext) internal {\n    if (_connext == address(0)) revert SponsorVault__setConnext_invalidConnext();\n\n    emit ConnextUpdated(connext, _connext, msg.sender);\n\n    connext = _connext;\n  }\n}\n\n\n",
        "CodeNames": [
            "SponsorVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SponsorVault.sol#L234-L263",
                "Type": "Malicious relayer exploit",
                "Description": "A malicious relayer could create a large number of transactions with the max reimbursed relay fee specified in SponsorVault between chains for which they relay all of them.",
                "Repair": "Set reimburse limits accordingly and add balance checks"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n// import {ExcessivelySafeCall} from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n// TODO: see note in below file re: npm\nimport {ExcessivelySafeCall} from \"../../../nomad-core/libs/ExcessivelySafeCall.sol\";\n\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\n\nimport {LibCrossDomainProperty, TypedMemView} from \"../libraries/LibCrossDomainProperty.sol\";\n\n/**\n * @title Executor\n * @author Connext <support@connext.network>\n * @notice This library contains an `execute` function that is callabale by\n * an associated Connext contract. This is used to execute\n * arbitrary calldata on a receiving chain.\n */\ncontract Executor is IExecutor {\n  // ============ Libraries =============\n\n  using TypedMemView for bytes29;\n  using TypedMemView for bytes;\n\n  // ============ Properties =============\n\n  address private immutable connext;\n  bytes private properties = LibCrossDomainProperty.EMPTY_BYTES;\n  uint256 private amnt;\n\n  /**\n   * @notice The amount of gas needed to execute _handleFailure\n   * @dev Used to calculate the amount of gas to reserve from transaction\n   * to properly handle failure cases\n   */\n  uint256 public FAILURE_GAS = 100_000; // Allowance decrease + transfer\n\n  /**\n   * @notice The maximum number of bytes to store in the return data\n   */\n  uint16 public MAX_COPY = 256;\n\n  // ============ Constructor =============\n\n  constructor(address _connext) {\n    connext = _connext;\n  }\n\n  // ============ Modifiers =============\n\n  /**\n   * @notice Errors if the sender is not Connext\n   */\n  modifier onlyConnext() {\n    require(msg.sender == connext, \"#OC:027\");\n    _;\n  }\n\n  // ============ Public Functions =============\n\n  /**\n   * @notice Returns the connext contract address (only address that can\n   * call the `execute` function)\n   * @return The address of the associated connext contract\n   */\n  function getConnext() external view override returns (address) {\n    return connext;\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access origin domain sender (i.e. msg.sender of `xcall`)\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function originSender() external view override returns (address) {\n    // The following will revert if it is empty\n    bytes29 _parsed = LibCrossDomainProperty.parseDomainAndSenderBytes(properties);\n    return LibCrossDomainProperty.sender(_parsed);\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access origin domain (i.e. domain of `xcall`)\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function origin() external view override returns (uint32) {\n    // The following will revert if it is empty\n    bytes29 _parsed = LibCrossDomainProperty.parseDomainAndSenderBytes(properties);\n    return LibCrossDomainProperty.domain(_parsed);\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access the amount that was delivered from the\n   * bridge. This is also set during reentrancy, but is set during fast *and* slow\n   * liquidity paths\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function amount() external view override returns (uint256) {\n    return amnt;\n  }\n\n  /**\n   * @notice Executes some arbitrary call data on a given address. The\n   * call data executes can be payable, and will have `amount` sent\n   * along with the function (or approved to the contract). If the\n   * call fails, rather than reverting, funds are sent directly to\n   * some provided fallback address\n   * @param _args ExecutorArgs to function.\n   */\n  function execute(ExecutorArgs memory _args) external payable override onlyConnext returns (bool, bytes memory) {\n    // Check if the callTo is a contract\n    bool success;\n    bytes memory returnData;\n\n    bool isNative = _args.assetId == address(0);\n\n    if (!AddressUpgradeable.isContract(_args.to)) {\n      _handleFailure(isNative, false, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n      // Emit event\n      emit Executed(\n        _args.transferId,\n        _args.to,\n        _args.recovery,\n        _args.assetId,\n        _args.amount,\n        _args.properties,\n        _args.callData,\n        returnData,\n        success\n      );\n      return (success, returnData);\n    }\n\n    // If it is not ether, approve the callTo\n    // We approve here rather than transfer since many external contracts\n    // simply require an approval, and it is unclear if they can handle\n    // funds transferred directly to them (i.e. Uniswap)\n\n    if (!isNative) {\n      SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_args.assetId), _args.to, _args.amount);\n    }\n\n    // If it should set the properties, set them.\n    // NOTE: safe to set the properties always because modifier will revert if\n    // it is the wrong type on conversion, and revert occurs with empty type as\n    // well\n    properties = _args.properties;\n\n    // Set the amount as well\n    amnt = _args.amount;\n\n    // Ensure there is enough gas to handle failures\n    uint256 gas = gasleft() - FAILURE_GAS;\n\n    // Try to execute the callData\n    // the low level call will return `false` if its execution reverts\n    (success, returnData) = ExcessivelySafeCall.excessivelySafeCall(\n      _args.to,\n      gas,\n      isNative ? _args.amount : 0,\n      MAX_COPY,\n      _args.callData\n    );\n\n    // Unset properties\n    properties = LibCrossDomainProperty.EMPTY_BYTES;\n\n    // Unset amount\n    amnt = 0;\n\n    // Handle failure cases\n    if (!success) {\n      _handleFailure(isNative, true, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n    }\n\n    // Emit event\n    emit Executed(\n      _args.transferId,\n      _args.to,\n      _args.recovery,\n      _args.assetId,\n      _args.amount,\n      _args.properties,\n      _args.callData,\n      returnData,\n      success\n    );\n    return (success, returnData);\n  }\n\n  function _handleFailure(\n    bool isNative,\n    bool hasIncreased,\n    address _assetId,\n    address payable _to,\n    address payable _recovery,\n    uint256 _amount\n  ) private {\n    if (!isNative) {\n      // Decrease allowance\n      if (hasIncreased) {\n        SafeERC20Upgradeable.safeDecreaseAllowance(IERC20Upgradeable(_assetId), _to, _amount);\n      }\n      // Transfer funds\n      SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_assetId), _recovery, _amount);\n    } else {\n      // Transfer funds\n      AddressUpgradeable.sendValue(_recovery, _amount);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "Executor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Executor.sol#L113-L192, Executor.sol#L194-L213",
                "Type": "Arbitrary call execute failure handler issue",
                "Description": "Current implementation of arbitrary call execute failure handler may break some use case for example NFT bridge.",
                "Repair": "Provide a way for user to cancel the execution, get ERC20 refund into the recovery address and acknowledge contract in the source chain that the bridge is failed to claim back NFT"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n  uint256 private constant _delay = 7 days;\n\n  struct FacetAddressAndPosition {\n    address facetAddress;\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n  }\n\n  struct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n  }\n\n  struct DiamondStorage {\n    // maps function selector to the facet address and\n    // the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    // facet addresses\n    address[] facetAddresses;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address contractOwner;\n    // hash of proposed facets => acceptance time\n    mapping(bytes32 => uint256) acceptanceTimes;\n  }\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function setContractOwner(address _newOwner) internal {\n    DiamondStorage storage ds = diamondStorage();\n    address previousOwner = ds.contractOwner;\n    ds.contractOwner = _newOwner;\n    emit OwnershipTransferred(previousOwner, _newOwner);\n  }\n\n  function contractOwner() internal view returns (address contractOwner_) {\n    contractOwner_ = diamondStorage().contractOwner;\n  }\n\n  function enforceIsContractOwner() internal view {\n    require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n  }\n\n  event DiamondCutProposed(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata, uint256 deadline);\n\n  function proposeDiamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    uint256 acceptance = block.timestamp + _delay;\n    diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = acceptance;\n    emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);\n  }\n\n  event DiamondCutRescinded(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  function rescindDiamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0;\n    emit DiamondCutRescinded(_diamondCut, _init, _calldata);\n  }\n\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  // Internal function version of diamondCut\n  function diamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    require(\n      diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp,\n      \"LibDiamond: delay not elapsed\"\n    );\n    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n      if (action == IDiamondCut.FacetCutAction.Add) {\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else {\n        revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n      }\n    }\n    emit DiamondCut(_diamondCut, _init, _calldata);\n    initializeDiamondCut(_init, _calldata);\n  }\n\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n    // add new facet address if it does not exist\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      selectorPosition++;\n    }\n  }\n\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n    // add new facet address if it does not exist\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n      removeFunction(ds, oldFacetAddress, selector);\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      selectorPosition++;\n    }\n  }\n\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    // if function does not exist then do nothing and return\n    require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      removeFunction(ds, oldFacetAddress, selector);\n    }\n  }\n\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n    enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n    ds.facetAddresses.push(_facetAddress);\n  }\n\n  function addFunction(\n    DiamondStorage storage ds,\n    bytes4 _selector,\n    uint96 _selectorPosition,\n    address _facetAddress\n  ) internal {\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n  }\n\n  function removeFunction(\n    DiamondStorage storage ds,\n    address _facetAddress,\n    bytes4 _selector\n  ) internal {\n    require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n    // an immutable function is a function defined directly in a diamond\n    require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n    // replace selector with last selector, then delete last selector\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n    // if not the same then replace _selector with lastSelector\n    if (selectorPosition != lastSelectorPosition) {\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n    }\n    // delete the last selector\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n    delete ds.selectorToFacetAndPosition[_selector];\n\n    // if no more selectors for facet address then delete the facet address\n    if (lastSelectorPosition == 0) {\n      // replace facet address with last facet address and delete last facet address\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n      if (facetAddressPosition != lastFacetAddressPosition) {\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n      }\n      ds.facetAddresses.pop();\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n    }\n  }\n\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n    if (_init == address(0)) {\n      require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n    } else {\n      require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n      if (_init != address(this)) {\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n      }\n      (bool success, bytes memory error) = _init.delegatecall(_calldata);\n      if (!success) {\n        if (error.length > 0) {\n          // bubble up the error\n          revert(string(error));\n        } else {\n          revert(\"LibDiamondCut: _init function reverted\");\n        }\n      }\n    }\n  }\n\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n    uint256 contractSize;\n    assembly {\n      contractSize := extcodesize(_contract)\n    }\n    require(contractSize > 0, _errorMessage);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n  /// @notice Add/replace/remove any number of functions and optionally execute\n  ///         a function with delegatecall\n  /// @param _diamondCut Contains the facet addresses and function selectors\n  /// @param _init The address of the contract or facet to execute _calldata\n  /// @param _calldata A function call, including function selector and arguments\n  ///                  _calldata is executed with delegatecall on _init\n  function diamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external override {\n    LibDiamond.enforceIsContractOwner();\n    LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n  }\n\n  function proposeDiamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external {\n    LibDiamond.enforceIsContractOwner();\n    LibDiamond.proposeDiamondCut(_diamondCut, _init, _calldata);\n  }\n\n  function rescindDiamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external {\n    LibDiamond.enforceIsContractOwner();\n    LibDiamond.rescindDiamondCut(_diamondCut, _init, _calldata);\n  }\n}\n\n\n",
        "CodeNames": [
            "LibDiamond.sol",
            "DiamondCutFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "DiamondCutFacet.sol#L16-L29, LibDiamond.sol#L94-L118, LibDiamond.sol#L222-L240",
                "Type": "Diamond upgrade falsification",
                "Description": "Diamond is to be upgraded after a certain delay to give time to the community to verify changes made by the developers. If the proposition can be falsified, the contract admins can exploit the contract in any way of their choice.",
                "Repair": "Add _init and _calldata to the proposition hash"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20, Address} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\nimport {ITokenExchange} from \"../interfaces/ITokenExchange.sol\";\nimport {IGasTokenOracle} from \"../interfaces/IGasTokenOracle.sol\";\n\n/**\n * @title SponsorVault\n * @author Connext Labs\n * @notice Contains logic for sponsoring liquidity and relayer fees\n */\ncontract SponsorVault is ISponsorVault, Ownable {\n  // ============ Libraries ============\n  using SafeERC20 for IERC20;\n\n  // ============ Struct ============\n  struct Rate {\n    uint256 num;\n    uint256 den;\n  }\n\n  // ============ Private storage ============\n\n  // ============ Public storage ============\n\n  /**\n   * @notice The address of connext\n   */\n  address public connext;\n\n  /**\n   * @notice The origin domain to this domain native token rates\n   * @dev Used when no oracle is available\n   */\n  mapping(uint32 => Rate) public rates;\n\n  /**\n   * @notice The maximum amount this domain native token to be sponsored for relayer fee\n   */\n  uint256 public relayerFeeCap;\n\n  /**\n   * @notice The origin domain to this domain native token oracle\n   * @dev Used to calculate sponsored relayer fee\n   */\n  IGasTokenOracle public gasTokenOracle;\n\n  /**\n   * @notice The this domain native token to token exchange\n   * @dev Used to exchange this domain native token to the token used to pay liquidity fees\n   */\n  mapping(address => ITokenExchange) public tokenExchanges;\n\n  // ============ Errors ============\n\n  error SponsorVault__setConnext_invalidConnext();\n  error SponsorVault__setRate_invalidOriginDomain();\n  error SponsorVault__setGasTokenOracle_invalidOriginDomain();\n  error SponsorVault__setTokenExchange_invalidAdopted();\n  error SponsorVault__onlyConnext();\n  error SponsorVault__withdraw_invalidAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new connext is set\n   */\n  event ConnextUpdated(address oldConnext, address newConnext, address caller);\n\n  /**\n   * @notice Emitted when a new rate is set\n   */\n  event RateUpdated(uint32 originDomain, Rate oldRate, Rate newRate, address caller);\n\n  /**\n   * @notice Emitted when a new relayerFeeCap is set\n   */\n  event RelayerFeeCapUpdated(uint256 oldRelayerFeeCap, uint256 newRelayerFeeCap, address caller);\n\n  /**\n   * @notice Emitted when a new native token oracle is set\n   */\n  event GasTokenOracleUpdated(address oldOracle, address newOracle, address caller);\n\n  /**\n   * @notice Emitted when a new token exchange is set\n   */\n  event TokenExchangeUpdated(address token, address oldTokenExchange, address newTokenExchange, address caller);\n\n  /**\n   * @notice Emitted when a liquidity fee is reimbursed\n   */\n  event ReimburseLiquidityFees(address token, uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when a relayer fee is reimbursed\n   */\n  event ReimburseRelayerFees(uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when liquidity is added\n   */\n  event Deposit(address token, uint256 amount, address caller);\n\n  /**\n   * @notice Emitted when liquidity is removed\n   */\n  event Withdraw(address token, address receiver, uint256 amount, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Restricts the caller to connext\n   */\n  modifier onlyConnext() {\n    if (msg.sender != connext) revert SponsorVault__onlyConnext();\n    _;\n  }\n\n  // ============ Constructor ============\n\n  constructor(address _connext) Ownable() {\n    _setConnext(_connext);\n  }\n\n  // ============ Owner Functions ============\n\n  /**\n   * @notice Sets the Connext.\n   * @dev Connext and sponsor vault store references to each other\n   * @param _connext The address of the Connext implementation\n   */\n  function setConnext(address _connext) external onlyOwner {\n    _setConnext(_connext);\n  }\n\n  /**\n   * @notice Sets default origin domain native token to this domain native token rate.\n   * @param _originDomain The origin domain\n   * @param _rate The default rate\n   */\n  function setRate(uint32 _originDomain, Rate calldata _rate) external onlyOwner {\n    if (_originDomain == 0) revert SponsorVault__setRate_invalidOriginDomain();\n\n    emit RateUpdated(_originDomain, rates[_originDomain], _rate, msg.sender);\n\n    rates[_originDomain] = _rate;\n  }\n\n  /**\n   * @notice Sets the maximum sponsored relayer fee amount.\n   * @param _relayerFeeCap The new relayerFeeCap\n   */\n  function setRelayerFeeCap(uint256 _relayerFeeCap) external onlyOwner {\n    emit RelayerFeeCapUpdated(relayerFeeCap, _relayerFeeCap, msg.sender);\n    relayerFeeCap = _relayerFeeCap;\n  }\n\n  /**\n   * @notice Sets of an oracle that provides origin domain native token to this domain native token rates.\n   * @param _gasTokenOracle The oracle address\n   */\n  function setGasTokenOracle(address _gasTokenOracle) external onlyOwner {\n    emit GasTokenOracleUpdated(address(gasTokenOracle), _gasTokenOracle, msg.sender);\n    gasTokenOracle = IGasTokenOracle(_gasTokenOracle);\n  }\n\n  /**\n   * @notice Sets the address of an exchange used for swapping this domain native token for a given token.\n   * @param _token The address of the token\n   * @param _tokenExchange The oracle of the exchange\n   */\n  function setTokenExchange(address _token, address payable _tokenExchange) external onlyOwner {\n    if (_token == address(0)) revert SponsorVault__setTokenExchange_invalidAdopted();\n\n    emit TokenExchangeUpdated(_token, address(tokenExchanges[_token]), _tokenExchange, msg.sender);\n    tokenExchanges[_token] = ITokenExchange(_tokenExchange);\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Performs liquidity fee reimbursement.\n   * @dev Uses the token exchange or liquidity deposited in this contract.\n   *      The `_receiver` address is only used for emitting in the event.\n   * @param _token The address of the token\n   * @param _liquidityFee The liquidity fee amount\n   * @param _receiver The address of the receiver\n   * @return Sponsored liquidity fee amount\n   */\n  function reimburseLiquidityFees(\n    address _token,\n    uint256 _liquidityFee,\n    address _receiver\n  ) external override onlyConnext returns (uint256) {\n    uint256 sponsoredFee;\n\n    if (address(tokenExchanges[_token]) != address(0)) {\n      uint256 currentBalance = address(this).balance;\n      ITokenExchange tokenExchange = tokenExchanges[_token];\n\n      uint256 amountIn = tokenExchange.getInGivenExpectedOut(_token, _liquidityFee);\n      amountIn = currentBalance >= amountIn ? amountIn : currentBalance;\n\n      // sponsored fee may end being less than _liquidityFee due to slippage\n      sponsoredFee = tokenExchange.swapExactIn{value: amountIn}(_token, msg.sender);\n    } else {\n      uint256 balance = IERC20(_token).balanceOf(address(this));\n      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee;\n\n      // some ERC20 do not allow to transfer 0 amount\n      if (sponsoredFee > 0) {\n        IERC20(_token).safeTransfer(msg.sender, sponsoredFee);\n      }\n    }\n\n    emit ReimburseLiquidityFees(_token, sponsoredFee, _receiver);\n\n    return sponsoredFee;\n  }\n\n  /**\n   * @notice Performs relayer fee reimbursement sending the corresponding amount of this domain native token to `_to`.\n   * @dev Uses the configured oracle or default rate otherwise.\n   * @param _originDomain The origin domain id\n   * @param _to The fee recipient\n   * @param _originRelayerFee The relayer fee amount in origin domain native token\n   */\n  function reimburseRelayerFees(\n    uint32 _originDomain,\n    address payable _to,\n    uint256 _originRelayerFee\n  ) external override onlyConnext {\n    uint256 sponsoredFee;\n    uint256 num;\n    uint256 den;\n\n    if (address(gasTokenOracle) != address(0)) {\n      (num, den) = gasTokenOracle.getRate(_originDomain);\n\n      sponsoredFee = (_originRelayerFee * num) / den;\n    } else {\n      num = rates[_originDomain].num;\n      den = rates[_originDomain].den;\n    }\n\n    if (den != 0) {\n      sponsoredFee = (_originRelayerFee * num) / den;\n\n      // calculated or max\n      sponsoredFee = sponsoredFee > relayerFeeCap ? relayerFeeCap : sponsoredFee;\n      // calculated or leftover\n      sponsoredFee = sponsoredFee > address(this).balance ? address(this).balance : sponsoredFee;\n\n      Address.sendValue(_to, sponsoredFee);\n    }\n    emit ReimburseRelayerFees(sponsoredFee, _to);\n  }\n\n  /**\n   * @notice Adds liquidity to the sponsor vault, native token or ERC20.\n   * @dev Anyone can add liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _amount The amount of ERC20 to deposit or zero for native token since the amount is sent in msg.value\n   */\n  function deposit(address _token, uint256 _amount) external payable {\n    if (_token != address(0)) {\n      IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    emit Deposit(_token, _token != address(0) ? _amount : msg.value, msg.sender);\n  }\n\n  /**\n   * @notice Removes liquidity from the sponsor vault, native token or ERC20.\n   * @dev Only the owner can remove liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _receiver The receiver of the tokens\n   * @param _amount The amount to remove\n   */\n  function withdraw(\n    address _token,\n    address _receiver,\n    uint256 _amount\n  ) external onlyOwner {\n    if (_token == address(0)) {\n      if (address(this).balance < _amount) revert SponsorVault__withdraw_invalidAmount();\n      Address.sendValue(payable(_receiver), _amount);\n    } else {\n      if (IERC20(_token).balanceOf(address(this)) < _amount) revert SponsorVault__withdraw_invalidAmount();\n      IERC20(_token).safeTransfer(_receiver, _amount);\n    }\n\n    emit Withdraw(_token, _receiver, _amount, msg.sender);\n  }\n\n  // ============ Internal functions ============\n\n  function _setConnext(address _connext) internal {\n    if (_connext == address(0)) revert SponsorVault__setConnext_invalidConnext();\n\n    emit ConnextUpdated(connext, _connext, msg.sender);\n\n    connext = _connext;\n  }\n}\n\n\n",
        "CodeNames": [
            "BridgeFacet.sol",
            "SponsorVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BridgeFacet.sol#L541, SponsorVault.sol#L196",
                "Type": "Router owner could steal all the funds within SponsorVault",
                "Description": "Router owner can intentionally perform many large transfer between their own wallets in two different domain to siphon all the funds from the SponsorVault, and then proceed to withdraw all liquidity from his router.",
                "Repair": "Reconsider the need of having a sponsor in Connext as extreme care have to be taken in its design to ensure that it will not be exploited"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {ITokenRegistry} from \"../interfaces/ITokenRegistry.sol\";\n\ncontract AssetFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error AssetFacet__setWrapper_invalidWrapper();\n  error AssetFacet__setTokenRegistry_invalidTokenRegistry();\n  error AssetFacet__addAssetId_alreadyAdded();\n  error AssetFacet__removeAssetId_notAdded();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when the wrapper variable is updated\n   * @param oldWrapper - The wrapper old value\n   * @param newWrapper - The wrapper new value\n   * @param caller - The account that called the function\n   */\n  event WrapperUpdated(address oldWrapper, address newWrapper, address caller);\n\n  /**\n   * @notice Emitted when the tokenRegistry variable is updated\n   * @param oldTokenRegistry - The tokenRegistry old value\n   * @param newTokenRegistry - The tokenRegistry new value\n   * @param caller - The account that called the function\n   */\n  event TokenRegistryUpdated(address oldTokenRegistry, address newTokenRegistry, address caller);\n\n  /**\n   * @notice Emitted when a new stable-swap AMM is added for the local <> adopted token\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param swapPool - The address of the AMM\n   * @param caller - The account that called the function\n   */\n  event StableSwapAdded(bytes32 canonicalId, uint32 domain, address swapPool, address caller);\n\n  /**\n   * @notice Emitted when a new asset is added\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param adoptedAsset - The address of the adopted (user-expected) asset\n   * @param supportedAsset - The address of the whitelisted asset. If the native asset is to be whitelisted,\n   * the address of the wrapped version will be stored\n   * @param caller - The account that called the function\n   */\n  event AssetAdded(bytes32 canonicalId, uint32 domain, address adoptedAsset, address supportedAsset, address caller);\n\n  /**\n   * @notice Emitted when an asset is removed from whitelists\n   * @param canonicalId - The canonical identifier of the token removed\n   * @param caller - The account that called the function\n   */\n  event AssetRemoved(bytes32 canonicalId, address caller);\n\n  // ============ Getters ============\n\n  function canonicalToAdopted(bytes32 _canonicalId) public view returns (address) {\n    return s.canonicalToAdopted[_canonicalId];\n  }\n\n  function adoptedToCanonical(address _adopted) public view returns (ConnextMessage.TokenId memory) {\n    ConnextMessage.TokenId memory canonical = ConnextMessage.TokenId(\n      s.adoptedToCanonical[_adopted].domain,\n      s.adoptedToCanonical[_adopted].id\n    );\n    return canonical;\n  }\n\n  function approvedAssets(bytes32 _asset) public view returns (bool) {\n    return s.approvedAssets[_asset];\n  }\n\n  function adoptedToLocalPools(bytes32 _adopted) public view returns (IStableSwap) {\n    return s.adoptedToLocalPools[_adopted];\n  }\n\n  function wrapper() public view returns (IWrapped) {\n    return s.wrapper;\n  }\n\n  function tokenRegistry() public view returns (ITokenRegistry) {\n    return s.tokenRegistry;\n  }\n\n  // ============ Admin functions ============\n\n  /**\n   * @notice Updates the native-asset wrapper interface\n   * @param _wrapper The address of the new wrapper\n   */\n  function setWrapper(address _wrapper) external onlyOwner {\n    address old = address(s.wrapper);\n    if (old == _wrapper || !Address.isContract(_wrapper)) revert AssetFacet__setWrapper_invalidWrapper();\n\n    s.wrapper = IWrapped(_wrapper);\n    emit WrapperUpdated(old, _wrapper, msg.sender);\n  }\n\n  /**\n   * @notice Updates the token registry\n   * @param _tokenRegistry The new token registry address\n   */\n  function setTokenRegistry(address _tokenRegistry) external onlyOwner {\n    address old = address(s.tokenRegistry);\n    if (old == _tokenRegistry || !Address.isContract(_tokenRegistry))\n      revert AssetFacet__setTokenRegistry_invalidTokenRegistry();\n\n    s.tokenRegistry = ITokenRegistry(_tokenRegistry);\n    emit TokenRegistryUpdated(old, _tokenRegistry, msg.sender);\n  }\n\n  /**\n   * @notice Used to add supported assets. This is an admin only function\n   * @dev When whitelisting the canonical asset, all representational assets would be\n   * whitelisted as well. In the event you have a different adopted asset (i.e. PoS USDC\n   * on polygon), you should *not* whitelist the adopted asset. The stable swap pool\n   * address used should allow you to swap between the local <> adopted asset\n   * @param _canonical - The canonical asset to add by id and domain. All representations\n   * will be whitelisted as well\n   * @param _adoptedAssetId - The used asset id for this domain (i.e. PoS USDC for\n   * polygon)\n   */\n  function setupAsset(\n    ConnextMessage.TokenId calldata _canonical,\n    address _adoptedAssetId,\n    address _stableSwapPool\n  ) external onlyOwner {\n    // Sanity check: needs approval\n    if (s.approvedAssets[_canonical.id]) revert AssetFacet__addAssetId_alreadyAdded();\n\n    // Update approved assets mapping\n    s.approvedAssets[_canonical.id] = true;\n\n    address supported = _adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId;\n\n    // Update the adopted mapping\n    s.adoptedToCanonical[supported].domain = _canonical.domain;\n    s.adoptedToCanonical[supported].id = _canonical.id;\n\n    // Update the canonical mapping\n    s.canonicalToAdopted[_canonical.id] = supported;\n\n    // Emit event\n    emit AssetAdded(_canonical.id, _canonical.domain, _adoptedAssetId, supported, msg.sender);\n\n    // Add the swap pool\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Adds a stable swap pool for the local <> adopted asset.\n   */\n  function addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwapPool) external onlyOwner {\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Used to remove assets from the whitelist\n   * @param _canonicalId - Token id to remove\n   * @param _adoptedAssetId - Corresponding adopted asset to remove\n   */\n  function removeAssetId(bytes32 _canonicalId, address _adoptedAssetId) external onlyOwner {\n    // Sanity check: already approval\n    if (!s.approvedAssets[_canonicalId]) revert AssetFacet__removeAssetId_notAdded();\n\n    // Delete from approved assets mapping\n    delete s.approvedAssets[_canonicalId];\n\n    // Delete from pools\n    delete s.adoptedToLocalPools[_canonicalId];\n\n    // Delete from adopted mapping\n    delete s.adoptedToCanonical[_adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId];\n\n    // Delete from canonical mapping\n    delete s.canonicalToAdopted[_canonicalId];\n\n    // Emit event\n    emit AssetRemoved(_canonicalId, msg.sender);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Used to add an AMM for adopted <> local assets\n   * @param _canonical - The canonical TokenId to add (domain and id)\n   * @param _stableSwap - The address of the amm to add\n   */\n  function _addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwap) internal {\n    // Update the pool mapping\n    s.adoptedToLocalPools[_canonical.id] = IStableSwap(_stableSwap);\n\n    emit StableSwapAdded(_canonical.id, _canonical.domain, _stableSwap, msg.sender);\n  }\n}\n\n\n",
        "CodeNames": [
            "AssetFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AssetFacet.sol#L100",
                "Type": "Incorrect Adopted mapping on updating wrapper token",
                "Description": "If wrapper is changed then all variables storing this wrapper should also update.",
                "Repair": "Add another property to tell us the canonical ID(s?) that are currently pointing to the wrapper contract as the adopted asset"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20, IERC20, Address} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {ITokenRegistry} from \"../interfaces/ITokenRegistry.sol\";\n\nimport {ConnextMessage} from \"./ConnextMessage.sol\";\nimport {LibConnextStorage, AppStorage} from \"./LibConnextStorage.sol\";\nimport {SwapUtils} from \"./SwapUtils.sol\";\n\nlibrary AssetLogic {\n  // ============ Libraries ============\n  using SwapUtils for SwapUtils.Swap;\n\n  // ============ Errors ============\n\n  error AssetLogic__handleIncomingAsset_notAmount();\n  error AssetLogic__handleIncomingAsset_ethWithErcTransfer();\n  error AssetLogic__transferAssetFromContract_notNative();\n  error AssetLogic__swapToLocalAssetIfNeeded_swapPaused();\n  error AssetLogic__swapFromLocalAssetIfNeeded_swapPaused();\n  error AssetLogic__getTokenIndexFromStableSwapPool_notExist();\n\n  // ============ Internal ============\n\n  /**\n   * @notice Check if the stabelswap pool exists or not\n   * @param canonicalId the canonical token id\n   */\n  function stableSwapPoolExist(bytes32 canonicalId) internal view returns (bool) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n    return s.swapStorages[canonicalId].pooledTokens.length != 0;\n  }\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param canonicalId the canonical token id\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getTokenIndexFromStableSwapPool(bytes32 canonicalId, address tokenAddress) internal view returns (uint8) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n    uint8 index = s.tokenIndexes[canonicalId][tokenAddress];\n    if (address(s.swapStorages[canonicalId].pooledTokens[index]) != tokenAddress)\n      revert AssetLogic__getTokenIndexFromStableSwapPool_notExist();\n    return index;\n  }\n\n  /**\n   * @notice Handles transferring funds from msg.sender to the Connext contract.\n   * @dev If using the native asset, will automatically wrap\n   * @param _assetId - The address to transfer\n   * @param _assetAmount - The specified amount to transfer. May not be the\n   * actual amount transferred (i.e. fee on transfer tokens)\n   * @param _fee - The fee amount in native asset included as part of the transaction that\n   * should not be considered for the transfer amount.\n   * @return The assetId of the transferred asset\n   * @return The amount of the asset that was seen by the contract (may not be the specifiedAmount\n   * if the token is a fee-on-transfer token)\n   */\n  function handleIncomingAsset(\n    address _assetId,\n    uint256 _assetAmount,\n    uint256 _fee\n  ) internal returns (address, uint256) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    uint256 trueAmount = _assetAmount;\n\n    if (_assetId == address(0)) {\n      if (msg.value != _assetAmount + _fee) revert AssetLogic__handleIncomingAsset_notAmount();\n\n      // When transferring native asset to the contract, always make sure that the\n      // asset is properly wrapped\n      wrapNativeAsset(_assetAmount);\n      _assetId = address(s.wrapper);\n    } else {\n      if (msg.value != _fee) revert AssetLogic__handleIncomingAsset_ethWithErcTransfer();\n\n      // Transfer asset to contract\n      trueAmount = transferAssetToContract(_assetId, _assetAmount);\n    }\n\n    return (_assetId, trueAmount);\n  }\n\n  /**\n   * @notice Wrap the native asset\n   * @param _amount - The specified amount to wrap\n   */\n  function wrapNativeAsset(uint256 _amount) internal {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    s.wrapper.deposit{value: _amount}();\n  }\n\n  /**\n   * @notice Transfer asset funds from msg.sender to the Connext contract.\n   * @param _assetId - The address to transfer\n   * @param _amount - The specified amount to transfer\n   * @return The amount of the asset that was seen by the contract\n   */\n  function transferAssetToContract(address _assetId, uint256 _amount) internal returns (uint256) {\n    // Validate correct amounts are transferred\n    uint256 starting = IERC20(_assetId).balanceOf(address(this));\n\n    SafeERC20.safeTransferFrom(IERC20(_assetId), msg.sender, address(this), _amount);\n    // Calculate the *actual* amount that was sent here\n    return IERC20(_assetId).balanceOf(address(this)) - starting;\n  }\n\n  /**\n   * @notice Handles transferring funds from msg.sender to the Connext contract.\n   * @dev If using the native asset, will automatically unwrap\n   * @param _assetId - The address to transfer\n   * @param _to - The account that will receive the withdrawn funds\n   * @param _amount - The amount to withdraw from contract\n   */\n  function transferAssetFromContract(\n    address _assetId,\n    address _to,\n    uint256 _amount\n  ) internal {\n    // If amount is 0 do nothing\n    if (_amount == 0) {\n      return;\n    }\n\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // No native assets should ever be stored on this contract\n    if (_assetId == address(0)) revert AssetLogic__transferAssetFromContract_notNative();\n\n    if (_assetId == address(s.wrapper)) {\n      // If dealing with wrapped assets, make sure they are properly unwrapped\n      // before sending from contract\n      s.wrapper.withdraw(_amount);\n      Address.sendValue(payable(_to), _amount);\n    } else {\n      // Transfer ERC20 asset\n      SafeERC20.safeTransfer(IERC20(_assetId), _to, _amount);\n    }\n  }\n\n  /**\n   * @notice Swaps an adopted asset to the local (representation or canonical) nomad asset\n   * @dev Will not swap if the asset passed in is the local asset\n   * @param _canonical - The canonical token\n   * @param _asset - The address of the adopted asset to swap into the local asset\n   * @param _amount - The amount of the adopted asset to swap\n   * @param _slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n   * @return The amount of local asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function swapToLocalAssetIfNeeded(\n    ConnextMessage.TokenId memory _canonical,\n    address _asset,\n    uint256 _amount,\n    uint256 _slippageTol\n  ) internal returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the local token for this domain (may return canonical or representation).\n    address local = s.tokenRegistry.getLocalAddress(_canonical.domain, _canonical.id);\n\n    // If there's no amount, no need to swap.\n    if (_amount == 0) {\n      return (_amount, local);\n    }\n\n    // Check the case where the adopted asset *is* the local asset. If so, no need to swap.\n    if (local == _asset) {\n      return (_amount, _asset);\n    }\n\n    // Swap the asset to the proper local asset.\n    return _swapAsset(_canonical.id, _asset, local, _amount, _slippageTol);\n  }\n\n  /**\n   * @notice Swaps a local nomad asset for the adopted asset using the stored stable swap\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _asset - The address of the local asset to swap into the adopted asset\n   * @param _amount - The amount of the local asset to swap\n   * @param _slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n   * @return The amount of adopted asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function swapFromLocalAssetIfNeeded(\n    address _asset,\n    uint256 _amount,\n    uint256 _slippageTol\n  ) internal returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (_amount, _asset);\n    }\n\n    // If 0 valued, do nothing\n    if (_amount == 0) {\n      return (_amount, adopted);\n    }\n\n    // Swap the asset to the proper local asset\n    return _swapAsset(id, _asset, adopted, _amount, _slippageTol);\n  }\n\n  /**\n   * @notice Swaps a local nomad asset for the adopted asset using the stored stable swap\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _asset - The address of the local asset to swap into the adopted asset\n   * @param _amount - The exact amount to receive out of the swap\n   * @return The amount of local asset put into  swap\n   * @return The address of asset received post-swap\n   */\n  function swapFromLocalAssetIfNeededForExactOut(\n    address _asset,\n    uint256 _amount,\n    uint256 _maxIn\n  )\n    internal\n    returns (\n      bool,\n      uint256,\n      address\n    )\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (true, _amount, _asset);\n    }\n\n    return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);\n  }\n\n  /**\n   * @notice Swaps assetIn t assetOut using the stored stable swap or internal swap pool\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _canonicalId - The canonical token id\n   * @param _assetIn - The address of the from asset\n   * @param _assetOut - The address of the to asset\n   * @param _amount - The amount of the local asset to swap\n   * @return The amount of assetOut\n   * @return The address of assetOut\n   */\n  function _swapAsset(\n    bytes32 _canonicalId,\n    address _assetIn,\n    address _assetOut,\n    uint256 _amount,\n    uint256 _slippageTol\n  ) internal returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Swap the asset to the proper local asset\n    uint256 minReceived = (_amount * _slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    if (stableSwapPoolExist(_canonicalId)) {\n      // if internal swap pool exists\n      return (\n        s.swapStorages[_canonicalId].swapInternal(\n          getTokenIndexFromStableSwapPool(_canonicalId, _assetOut),\n          getTokenIndexFromStableSwapPool(_canonicalId, _assetIn),\n          _amount,\n          minReceived\n        ),\n        _assetOut\n      );\n    } else {\n      // Otherwise, swap via stable swap pool\n      IStableSwap pool = s.adoptedToLocalPools[_canonicalId];\n      SafeERC20.safeIncreaseAllowance(IERC20(_assetIn), address(pool), _amount);\n\n      return (pool.swapExact(_amount, _assetIn, _assetOut, minReceived), _assetOut);\n    }\n  }\n\n  /**\n   * @notice Swaps assetIn t assetOut using the stored stable swap or internal swap pool\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _canonicalId - The canonical token id\n   * @param _assetIn - The address of the from asset\n   * @param _assetOut - The address of the to asset\n   * @param _amountOut - The amount of the _assetOut to swap\n   * @return The amount of assetIn\n   * @return The address of assetOut\n   */\n  function _swapAssetOut(\n    bytes32 _canonicalId,\n    address _assetIn,\n    address _assetOut,\n    uint256 _amountOut,\n    uint256 _maxIn\n  )\n    internal\n    returns (\n      bool,\n      uint256,\n      address\n    )\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    bool success;\n    uint256 amountIn;\n\n    // Swap the asset to the proper local asset\n    if (stableSwapPoolExist(_canonicalId)) {\n      // get internal swap pool\n      SwapUtils.Swap storage ipool = s.swapStorages[_canonicalId];\n      // if internal swap pool exists\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_canonicalId, _assetIn);\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_canonicalId, _assetOut);\n      // calculate slippage before performing swap\n      // NOTE: this is less efficient then relying on the `swapInternalOut` revert, but makes it easier\n      // to handle slippage failures (this can be called during reconcile, so must not fail)\n      if (_maxIn >= ipool.calculateSwapInv(tokenIndexIn, tokenIndexOut, _amountOut)) {\n        success = true;\n        amountIn = ipool.swapInternalOut(tokenIndexIn, tokenIndexOut, _amountOut, _maxIn);\n      }\n      // slippage is too high to perform swap: success = false, amountIn = 0\n    } else {\n      // Otherwise, swap via stable swap pool\n      IStableSwap pool = s.adoptedToLocalPools[_canonicalId];\n      uint256 _amountIn = pool.calculateSwapOutFromAddress(_assetIn, _assetOut, _amountOut);\n      if (_amountIn <= _maxIn) {\n        // set the success\n        success = true;\n\n        // perform the swap\n        SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn);\n        amountIn = pool.swapExactOut(_amountOut, _assetIn, _assetOut, _maxIn);\n      }\n      // slippage is too high to perform swap: success = false, amountIn = 0\n    }\n\n    return (success, amountIn, _assetOut);\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on a local nomad asset for the adopted asset\n   * using the stored stable swap\n   * @dev Will not use the stored stable swap if the asset passed in is the local asset\n   * @param _asset - The address of the local asset to swap into the local asset\n   * @param _amount - The amount of the local asset to swap\n   * @return The amount of local asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function calculateSwapFromLocalAssetIfNeeded(address _asset, uint256 _amount)\n    internal\n    view\n    returns (uint256, address)\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (_amount, _asset);\n    }\n\n    // Otherwise, calculate swap the asset to the proper local asset\n    if (stableSwapPoolExist(id)) {\n      // if internal swap pool exists\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(id, _asset);\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(id, adopted);\n      return (s.swapStorages[id].calculateSwap(tokenIndexIn, tokenIndexOut, _amount), adopted);\n    } else {\n      IStableSwap pool = s.adoptedToLocalPools[id];\n\n      return (pool.calculateSwapFromAddress(_asset, adopted, _amount), adopted);\n    }\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive of a local nomad asset for the adopted asset\n   * using the stored stable swap\n   * @dev Will not use the stored stable swap if the asset passed in is the local asset\n   * @param _asset - The address of the asset to swap into the local asset\n   * @param _amount - The amount of the asset to swap\n   * @return The amount of local asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function calculateSwapToLocalAssetIfNeeded(address _asset, uint256 _amount) internal view returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (uint32 domain, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n    address local = s.tokenRegistry.getLocalAddress(domain, id);\n\n    // If the asset is the local asset, no swap needed\n    if (_asset == local) {\n      return (_amount, _asset);\n    }\n\n    // Otherwise, calculate swap the asset to the proper local asset\n    if (stableSwapPoolExist(id)) {\n      // if internal swap pool exists\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(id, _asset);\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(id, local);\n      return (s.swapStorages[id].calculateSwap(tokenIndexIn, tokenIndexOut, _amount), local);\n    } else {\n      IStableSwap pool = s.adoptedToLocalPools[id];\n\n      return (pool.calculateSwapFromAddress(_asset, local, _amount), local);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "BridgeFacet.sol",
            "AssetLogic.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BridgeFacet.sol#L984, AssetLogic.sol#L347",
                "Type": "Token Approval Vulnerability",
                "Description": "Certain tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. The vulnerability occurs in the _reconcileProcessPortal and _swapAssetOut functions which are called during repayment to Aave Portal if the fast-transfer was executed using portal liquidity.",
                "Repair": "Set the allowance to zero before increasing the allowance"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n",
        "CodeNames": [
            "BridgeFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BridgeFacet.sol#L411",
                "Type": "Double-Spend Issue",
                "Description": "Malicious Relayer can Replay Execute Calldata on Different Chains Causing Double-Spend Issue",
                "Repair": "Enforce a check in _executeSanityChecks to ensure that transfer data is only executed on the intended destination domain. Sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. Additionally, the execute calldata should also have a field that corresponds to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains."
            },
            {
                "Location": "BridgeFacet.sol#L984",
                "Type": "Unenforced Repayment of AAVE Portal Loan",
                "Description": "Routers are not enforced to repay AAVE Portal loan, which can lead to Connext incurring a large amount of debt from AAVE portal.",
                "Repair": "Implement a multisig or validation system to mitigate the risk of a single trusted actor from turning rogue and performing malicious actions. Alternatively, escrow the amount received from nomad in an Escrow contract and implement a function called settleAAVEPortalLoan within the Escrow contract, which contains the logic to perform the necessary actions to repay AAVE portal loan."
            },
            {
                "Location": "BridgeFacet.sol#L753-L803, BridgeFacet.sol#L526-L616",
                "Type": "Division Rounding Error",
                "Description": "Division rounding error in _handleExecuteLiquidity() and _reconcile() make routerBalances and contract fund balance get out of sync and cause fund loss.",
                "Repair": "Perform better calculations. One possible solution is to make the last router pay the swept balance and then be reconciled this amount once the bridge transfer is complete."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortal_swapFailed();\n  error PortalFacet__repayAavePortalFor_notSupportedAsset();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a router executed a manual repayment to Aave Portal\n   * @param router - The router that execute the repayment\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRouterRepayment(address indexed router, address asset, uint256 amount, uint256 fee);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwner {\n    s.aavePool = _aavePool;\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner {\n    if (_aavePortalFeeNumerator > s.LIQUIDITY_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function\n   * @param _local The local asset (what router stores liquidity in)\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   * @dev Should always be paying in the backing asset for the aave loan\n   * @param _router Router who took out the credit\n   * @param _adopted Address of the adopted asset (asset backing the loan)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function repayAavePortalFor(\n    address _router,\n    address _adopted,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    bytes32 _transferId\n  ) external payable {\n    address adopted = _adopted == address(0) ? address(s.wrapper) : _adopted;\n    // Ensure the asset is whitelisted\n    ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[adopted];\n    if (canonical.id == bytes32(0)) {\n      revert PortalFacet__repayAavePortalFor_notSupportedAsset();\n    }\n\n    // Transfer funds to the contract\n    uint256 total = _backingAmount + _feeAmount;\n    if (total == 0) revert PortalFacet__repayAavePortalFor_zeroAmount();\n\n    (, uint256 amount) = AssetLogic.handleIncomingAsset(_adopted, total, 0);\n\n    // If this was a fee on transfer token, reduce the total\n    if (amount < total) {\n      uint256 missing = total - amount;\n      if (missing < _feeAmount) {\n        // Debit fee amount\n        _feeAmount -= missing;\n      } else {\n        // Debit backing amount\n        missing -= _feeAmount;\n        _feeAmount = 0;\n        _backingAmount -= missing;\n      }\n    }\n\n    // No need to swap because this is the adopted asset. Simply\n    // repay the loan\n    _backLoan(adopted, _backingAmount, _feeAmount, _transferId);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Calls backUnbacked on the aave contracts\n   * @dev Assumes funds in adopted asset are already on contract\n   * @param _asset Address of the adopted asset (asset backing the loan)\n   * @param _backing Amount of principle to repay\n   * @param _fee Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function _backLoan(\n    address _asset,\n    uint256 _backing,\n    uint256 _fee,\n    bytes32 _transferId\n  ) internal {\n    // reduce debt\n    s.portalDebt[_transferId] -= _backing;\n    s.portalFeeDebt[_transferId] -= _fee;\n\n    // increase allowance\n    SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_asset), s.aavePool, _backing + _fee);\n\n    // back loan\n    IAavePool(s.aavePool).backUnbacked(_asset, _backing, _fee);\n\n    // emit event\n    emit AavePortalRouterRepayment(msg.sender, _asset, _backing, _fee);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {Deployer} from \"../../../utils/Deployer.sol\";\nimport {IConnextHandler} from \"../../../../contracts/core/connext/interfaces/IConnextHandler.sol\";\nimport {IStableSwap} from \"../../../../contracts/core/connext/interfaces/IStableSwap.sol\";\nimport {IAavePool} from \"../../../../contracts/core/connext/interfaces/IAavePool.sol\";\nimport {IDiamondCut} from \"../../../../contracts/core/connext/interfaces/IDiamondCut.sol\";\n\nimport {BaseConnextFacet} from \"../../../../contracts/core/connext/facets/BaseConnextFacet.sol\";\nimport {LibDiamond} from \"../../../../contracts/core/connext/libraries/LibDiamond.sol\";\nimport {ConnextMessage} from \"../../../../contracts/core/connext/libraries/ConnextMessage.sol\";\nimport {PortalFacet} from \"../../../../contracts/core/connext/facets/PortalFacet.sol\";\nimport {TestAavePool} from \"../../../../contracts/test/TestAavePool.sol\";\nimport {TestERC20} from \"../../../../contracts/test/TestERC20.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../../utils/Mock.sol\";\nimport \"./FacetHelper.sol\";\n\ncontract PortalFacetTest is PortalFacet, FacetHelper {\n  // ============ Storage ============\n  uint32 domain = _originDomain;\n  address bridgeRouter = address(1);\n  address relayerFeeRouter = address(4);\n  address xAppConnectionManager = address(5);\n  address router = address(1111);\n  address aavePool;\n\n  bytes32 _id = bytes32(abi.encodePacked(address(123)));\n\n  // ============ Test set up ============\n\n  function setUp() public {\n    utils_deployAssetContracts();\n    utils_setFees();\n\n    // we are on the origin domain where local == canonical\n    utils_setupAsset(true, true);\n\n    // set the owner to this contract\n    LibDiamond.setContractOwner(address(this));\n\n    // setup aave pool\n    aavePool = address(new MockPool(false));\n    // set pool\n    s.aavePool = aavePool;\n  }\n\n  // ============ setAavePool ============\n\n  // should work\n  function test_PortalFacet__setAavePool_works() public {\n    s.aavePool = address(0);\n    assertEq(this.aavePool(), address(0));\n\n    this.setAavePool(aavePool);\n\n    assertEq(this.aavePool(), aavePool);\n  }\n\n  // should fail if not owner\n  function test_PortalFacet__setAavePool_failsIfNotOwner() public {\n    vm.prank(address(10));\n    vm.expectRevert(abi.encodeWithSelector(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector));\n    this.setAavePool(aavePool);\n  }\n\n  // ============ setAavePortalFee ============\n\n  // should work\n  function test_PortalFacet__setAavePortalFee_works() public {\n    uint256 fee = 125;\n    assertEq(this.aavePortalFee(), _portalFeeNumerator);\n\n    this.setAavePortalFee(fee);\n\n    assertEq(this.aavePortalFee(), fee);\n  }\n\n  // should fail if not owner\n  function test_PortalFacet__setAavePortalFee_failsIfNotOwner() public {\n    uint256 fee = 5;\n\n    vm.prank(address(10));\n    vm.expectRevert(abi.encodeWithSelector(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector));\n\n    this.setAavePortalFee(fee);\n  }\n\n  // fail if the fee is invalid (greater than denominator)\n  function test_PortalFacet__setAavePortalFee_failsIfInvalidFee() public {\n    uint256 fee = _liquidityFeeDenominator + 1;\n\n    vm.expectRevert(abi.encodeWithSelector(PortalFacet.PortalFacet__setAavePortalFee_invalidFee.selector));\n    this.setAavePortalFee(fee);\n  }\n\n  // ============ repayAavePortal ============\n\n  // should work when local asset is the adopted asset\n  function test_PortalFacet__repayAavePortal_works() public {\n    // set approval context\n    s.routerPermissionInfo.approvedForPortalRouters[router] = true;\n\n    // set debt amount\n    uint256 backing = 1111;\n    uint256 fee = 111;\n\n    // set liquidity\n    uint256 init = 10 ether;\n    s.routerBalances[router][_local] = init;\n    s.portalDebt[_id] = backing;\n    s.portalFeeDebt[_id] = fee;\n    assertTrue(IERC20(_local).balanceOf(address(this)) > init);\n\n    // set mock for backing\n    vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));\n\n    // make call\n    vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, aavePool, backing + fee));\n    vm.expectCall(aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector, _local, backing, fee));\n    vm.expectEmit(true, true, true, true);\n    emit AavePortalRouterRepayment(router, _local, backing, fee);\n    vm.prank(router);\n    this.repayAavePortal(_local, backing, fee, backing, _id);\n\n    // assert balance decrement\n    assertEq(s.routerBalances[router][_local], init - backing - fee);\n  }\n\n  // fails if not enough balance\n  function test_PortalFacet__repayAavePortal_failsIfInsufficientAmount() public {\n    // set approval context\n    s.routerPermissionInfo.approvedForPortalRouters[router] = true;\n\n    // set liquidity\n    assertEq(s.routerBalances[router][_local], 0);\n\n    // set debt amount\n    uint256 backing = 1111;\n    uint256 fee = 111;\n\n    // call coming from router\n    vm.prank(router);\n    vm.expectRevert(abi.encodeWithSelector(PortalFacet.PortalFacet__repayAavePortal_insufficientFunds.selector));\n    this.repayAavePortal(_local, backing, fee, backing, _id);\n  }\n\n  // fails if swap failed\n  function test_PortalFacet__repayAavePortal_failsIfSwapFailed() public {\n    // we are on the destination domain where local != canonical\n    utils_setupAsset(false, false);\n\n    // set approval context\n    s.routerPermissionInfo.approvedForPortalRouters[router] = true;\n\n    // set debt amount\n    uint256 backing = 1111;\n    uint256 fee = 111;\n    uint256 maxIn = 1200;\n\n    // set liquidity\n    s.routerBalances[router][_local] = maxIn + 1;\n\n    // set mock + storage (using external pool)\n    // calculateSwapOutFromAddress returns maxIn + 1 and it causes swap Failed!\n    vm.mockCall(\n      _stableSwap,\n      abi.encodeWithSelector(IStableSwap.calculateSwapOutFromAddress.selector),\n      abi.encode(maxIn + 1)\n    );\n\n    // call coming from router\n    vm.prank(router);\n    vm.expectRevert(abi.encodeWithSelector(PortalFacet.PortalFacet__repayAavePortal_swapFailed.selector));\n    this.repayAavePortal(_local, backing, fee, maxIn, _id);\n  }\n\n  function test_PortalFacet__repayAavePortal_failsIfRepalyTooMuch() public {\n    // we are on the destination domain where local != canonical\n    utils_setupAsset(false, false);\n\n    // set approval context\n    s.routerPermissionInfo.approvedForPortalRouters[router] = true;\n\n    // set debt amount\n    uint256 backing = 1111;\n    uint256 fee = 111;\n    uint256 maxIn = 1200;\n    uint256 totalAmount = backing + fee;\n    uint256 amountIn = maxIn - 1;\n    uint256 init = maxIn + 1;\n\n    s.routerBalances[router][_local] = init;\n    s.portalDebt[_id] = backing - 1;\n    s.portalFeeDebt[_id] = fee - 1;\n\n    // set liquidity\n    s.routerBalances[router][_local] = maxIn + 1;\n\n    // set mock + storage (using external pool)\n    vm.mockCall(\n      _stableSwap,\n      abi.encodeWithSelector(IStableSwap.calculateSwapOutFromAddress.selector),\n      abi.encode(amountIn)\n    );\n    vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExactOut.selector), abi.encode(amountIn));\n\n    // set mock for backing\n    vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));\n\n    vm.expectRevert(stdError.arithmeticError);\n    vm.prank(router);\n    this.repayAavePortal(_local, backing, fee, maxIn, _id);\n\n    // assert balance decrement\n    assertEq(s.routerBalances[router][_local], init);\n  }\n\n  function test_PortalFacet__repayAavePortal_shouldWorkUsingSwap() public {\n    // we are on the destination domain where local != canonical\n    utils_setupAsset(false, false);\n\n    // set approval context\n    s.routerPermissionInfo.approvedForPortalRouters[router] = true;\n\n    // set debt amount\n    uint256 backing = 1111;\n    uint256 fee = 111;\n    uint256 maxIn = 1200;\n    uint256 totalAmount = backing + fee;\n    uint256 amountIn = maxIn - 1;\n    uint256 init = maxIn + 1;\n\n    s.routerBalances[router][_local] = init;\n    s.portalDebt[_id] = backing;\n    s.portalFeeDebt[_id] = fee;\n\n    // set liquidity\n    s.routerBalances[router][_local] = maxIn + 1;\n\n    // set mock + storage (using external pool)\n    vm.mockCall(\n      _stableSwap,\n      abi.encodeWithSelector(IStableSwap.calculateSwapOutFromAddress.selector),\n      abi.encode(amountIn)\n    );\n    vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExactOut.selector), abi.encode(amountIn));\n\n    // set mock for backing\n    vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));\n\n    // make call\n    vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, aavePool, backing + fee));\n    vm.expectCall(aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector, _local, backing, fee));\n    vm.expectEmit(true, true, true, true);\n    emit AavePortalRouterRepayment(router, _local, backing, fee);\n    vm.prank(router);\n    this.repayAavePortal(_local, backing, fee, maxIn, _id);\n\n    // assert balance decrement\n    assertEq(s.routerBalances[router][_local], init - amountIn);\n  }\n\n  // ============ repayAavePortalFor ============\n\n  // fails if not supported asset\n  function test_PortalFacet__repayAavePortalFor_failsIfNotSupportedAsset() public {\n    // set debt amount\n    uint256 backing = 1111;\n    uint256 fee = 111;\n\n    // we are on the destination domain where local != canonical\n    utils_setupAsset(false, false);\n\n    address adopted = address(1);\n    assertTrue(adopted != _adopted);\n\n    vm.expectRevert(abi.encodeWithSelector(PortalFacet.PortalFacet__repayAavePortalFor_notSupportedAsset.selector));\n    this.repayAavePortalFor(router, adopted, backing, fee, _id);\n  }\n\n  // fails if zero amount\n  function test_PortalFacet__repayAavePortalFor_failsIfZeroTotalAmount() public {\n    // set debt amount\n    uint256 backing = 0;\n    uint256 fee = 0;\n\n    // we are on the destination domain where local != canonical\n    utils_setupAsset(false, false);\n\n    vm.expectRevert(abi.encodeWithSelector(PortalFacet.PortalFacet__repayAavePortalFor_zeroAmount.selector));\n    this.repayAavePortalFor(router, _adopted, backing, fee, _id);\n  }\n\n  // should work\n  function test_PortalFacet__repayAavePortalFor_shouldWork() public {\n    // we are on the destination domain where local != canonical\n    utils_setupAsset(false, false);\n\n    // set debt amount\n    uint256 backing = 1111;\n    uint256 fee = 111;\n    uint256 total = backing + fee;\n\n    s.portalDebt[_id] = backing;\n    s.portalFeeDebt[_id] = fee;\n\n    // mint initial balance to sender and approve\n    address sender = address(111);\n    TestERC20(_adopted).mint(sender, total);\n    vm.prank(sender);\n    TestERC20(_adopted).approve(address(this), total);\n\n    // make call\n    vm.expectCall(_adopted, abi.encodeWithSelector(IERC20.approve.selector, aavePool, total));\n    vm.expectCall(aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector, _adopted, backing, fee));\n    vm.expectEmit(true, true, true, true);\n    emit AavePortalRouterRepayment(sender, _adopted, backing, fee);\n    vm.prank(sender);\n    this.repayAavePortalFor(router, _adopted, backing, fee, _id);\n\n    // assert balance decrement\n    assertEq(IERC20(_adopted).balanceOf(sender), 0);\n    assertEq(s.portalDebt[_id], 0);\n    assertEq(s.portalFeeDebt[_id], 0);\n  }\n}\n\n\n",
        "CodeNames": [
            "PortalFacet.sol",
            "PortalFacet.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "repayAavePortal() function in PortalFacet.sol",
                "Type": "Repaying AAVE Loan in local rather than adopted asset",
                "Description": "When repaying the AAVE Portal, the _local asset is used to repay the loan in _backLoan() rather than the adopted asset, which can cause issues in production when repaying loans if the asset/token being repaid to AAVE is not the same as the asset/token that was borrowed.",
                "Repair": "Pass the adopted token to _backLoan() instead of the local token"
            },
            {
                "Location": "PortalFacet.repayAavePortal function",
                "Type": "Arbitrary balance increase",
                "Description": "repayAavePortal() can trigger an underflow of routerBalances.",
                "Repair": "After the call to swapFromLocalAssetIfNeededForExactOut() add the following check: if (_local == adopted) { require(routerBalance >= amountIn); }"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20, Address} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\nimport {ITokenExchange} from \"../interfaces/ITokenExchange.sol\";\nimport {IGasTokenOracle} from \"../interfaces/IGasTokenOracle.sol\";\n\n/**\n * @title SponsorVault\n * @author Connext Labs\n * @notice Contains logic for sponsoring liquidity and relayer fees\n */\ncontract SponsorVault is ISponsorVault, Ownable {\n  // ============ Libraries ============\n  using SafeERC20 for IERC20;\n\n  // ============ Struct ============\n  struct Rate {\n    uint256 num;\n    uint256 den;\n  }\n\n  // ============ Private storage ============\n\n  // ============ Public storage ============\n\n  /**\n   * @notice The address of connext\n   */\n  address public connext;\n\n  /**\n   * @notice The origin domain to this domain native token rates\n   * @dev Used when no oracle is available\n   */\n  mapping(uint32 => Rate) public rates;\n\n  /**\n   * @notice The maximum amount this domain native token to be sponsored for relayer fee\n   */\n  uint256 public relayerFeeCap;\n\n  /**\n   * @notice The origin domain to this domain native token oracle\n   * @dev Used to calculate sponsored relayer fee\n   */\n  IGasTokenOracle public gasTokenOracle;\n\n  /**\n   * @notice The this domain native token to token exchange\n   * @dev Used to exchange this domain native token to the token used to pay liquidity fees\n   */\n  mapping(address => ITokenExchange) public tokenExchanges;\n\n  // ============ Errors ============\n\n  error SponsorVault__setConnext_invalidConnext();\n  error SponsorVault__setRate_invalidOriginDomain();\n  error SponsorVault__setGasTokenOracle_invalidOriginDomain();\n  error SponsorVault__setTokenExchange_invalidAdopted();\n  error SponsorVault__onlyConnext();\n  error SponsorVault__withdraw_invalidAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new connext is set\n   */\n  event ConnextUpdated(address oldConnext, address newConnext, address caller);\n\n  /**\n   * @notice Emitted when a new rate is set\n   */\n  event RateUpdated(uint32 originDomain, Rate oldRate, Rate newRate, address caller);\n\n  /**\n   * @notice Emitted when a new relayerFeeCap is set\n   */\n  event RelayerFeeCapUpdated(uint256 oldRelayerFeeCap, uint256 newRelayerFeeCap, address caller);\n\n  /**\n   * @notice Emitted when a new native token oracle is set\n   */\n  event GasTokenOracleUpdated(address oldOracle, address newOracle, address caller);\n\n  /**\n   * @notice Emitted when a new token exchange is set\n   */\n  event TokenExchangeUpdated(address token, address oldTokenExchange, address newTokenExchange, address caller);\n\n  /**\n   * @notice Emitted when a liquidity fee is reimbursed\n   */\n  event ReimburseLiquidityFees(address token, uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when a relayer fee is reimbursed\n   */\n  event ReimburseRelayerFees(uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when liquidity is added\n   */\n  event Deposit(address token, uint256 amount, address caller);\n\n  /**\n   * @notice Emitted when liquidity is removed\n   */\n  event Withdraw(address token, address receiver, uint256 amount, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Restricts the caller to connext\n   */\n  modifier onlyConnext() {\n    if (msg.sender != connext) revert SponsorVault__onlyConnext();\n    _;\n  }\n\n  // ============ Constructor ============\n\n  constructor(address _connext) Ownable() {\n    _setConnext(_connext);\n  }\n\n  // ============ Owner Functions ============\n\n  /**\n   * @notice Sets the Connext.\n   * @dev Connext and sponsor vault store references to each other\n   * @param _connext The address of the Connext implementation\n   */\n  function setConnext(address _connext) external onlyOwner {\n    _setConnext(_connext);\n  }\n\n  /**\n   * @notice Sets default origin domain native token to this domain native token rate.\n   * @param _originDomain The origin domain\n   * @param _rate The default rate\n   */\n  function setRate(uint32 _originDomain, Rate calldata _rate) external onlyOwner {\n    if (_originDomain == 0) revert SponsorVault__setRate_invalidOriginDomain();\n\n    emit RateUpdated(_originDomain, rates[_originDomain], _rate, msg.sender);\n\n    rates[_originDomain] = _rate;\n  }\n\n  /**\n   * @notice Sets the maximum sponsored relayer fee amount.\n   * @param _relayerFeeCap The new relayerFeeCap\n   */\n  function setRelayerFeeCap(uint256 _relayerFeeCap) external onlyOwner {\n    emit RelayerFeeCapUpdated(relayerFeeCap, _relayerFeeCap, msg.sender);\n    relayerFeeCap = _relayerFeeCap;\n  }\n\n  /**\n   * @notice Sets of an oracle that provides origin domain native token to this domain native token rates.\n   * @param _gasTokenOracle The oracle address\n   */\n  function setGasTokenOracle(address _gasTokenOracle) external onlyOwner {\n    emit GasTokenOracleUpdated(address(gasTokenOracle), _gasTokenOracle, msg.sender);\n    gasTokenOracle = IGasTokenOracle(_gasTokenOracle);\n  }\n\n  /**\n   * @notice Sets the address of an exchange used for swapping this domain native token for a given token.\n   * @param _token The address of the token\n   * @param _tokenExchange The oracle of the exchange\n   */\n  function setTokenExchange(address _token, address payable _tokenExchange) external onlyOwner {\n    if (_token == address(0)) revert SponsorVault__setTokenExchange_invalidAdopted();\n\n    emit TokenExchangeUpdated(_token, address(tokenExchanges[_token]), _tokenExchange, msg.sender);\n    tokenExchanges[_token] = ITokenExchange(_tokenExchange);\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Performs liquidity fee reimbursement.\n   * @dev Uses the token exchange or liquidity deposited in this contract.\n   *      The `_receiver` address is only used for emitting in the event.\n   * @param _token The address of the token\n   * @param _liquidityFee The liquidity fee amount\n   * @param _receiver The address of the receiver\n   * @return Sponsored liquidity fee amount\n   */\n  function reimburseLiquidityFees(\n    address _token,\n    uint256 _liquidityFee,\n    address _receiver\n  ) external override onlyConnext returns (uint256) {\n    uint256 sponsoredFee;\n\n    if (address(tokenExchanges[_token]) != address(0)) {\n      uint256 currentBalance = address(this).balance;\n      ITokenExchange tokenExchange = tokenExchanges[_token];\n\n      uint256 amountIn = tokenExchange.getInGivenExpectedOut(_token, _liquidityFee);\n      amountIn = currentBalance >= amountIn ? amountIn : currentBalance;\n\n      // sponsored fee may end being less than _liquidityFee due to slippage\n      sponsoredFee = tokenExchange.swapExactIn{value: amountIn}(_token, msg.sender);\n    } else {\n      uint256 balance = IERC20(_token).balanceOf(address(this));\n      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee;\n\n      // some ERC20 do not allow to transfer 0 amount\n      if (sponsoredFee > 0) {\n        IERC20(_token).safeTransfer(msg.sender, sponsoredFee);\n      }\n    }\n\n    emit ReimburseLiquidityFees(_token, sponsoredFee, _receiver);\n\n    return sponsoredFee;\n  }\n\n  /**\n   * @notice Performs relayer fee reimbursement sending the corresponding amount of this domain native token to `_to`.\n   * @dev Uses the configured oracle or default rate otherwise.\n   * @param _originDomain The origin domain id\n   * @param _to The fee recipient\n   * @param _originRelayerFee The relayer fee amount in origin domain native token\n   */\n  function reimburseRelayerFees(\n    uint32 _originDomain,\n    address payable _to,\n    uint256 _originRelayerFee\n  ) external override onlyConnext {\n    uint256 sponsoredFee;\n    uint256 num;\n    uint256 den;\n\n    if (address(gasTokenOracle) != address(0)) {\n      (num, den) = gasTokenOracle.getRate(_originDomain);\n\n      sponsoredFee = (_originRelayerFee * num) / den;\n    } else {\n      num = rates[_originDomain].num;\n      den = rates[_originDomain].den;\n    }\n\n    if (den != 0) {\n      sponsoredFee = (_originRelayerFee * num) / den;\n\n      // calculated or max\n      sponsoredFee = sponsoredFee > relayerFeeCap ? relayerFeeCap : sponsoredFee;\n      // calculated or leftover\n      sponsoredFee = sponsoredFee > address(this).balance ? address(this).balance : sponsoredFee;\n\n      Address.sendValue(_to, sponsoredFee);\n    }\n    emit ReimburseRelayerFees(sponsoredFee, _to);\n  }\n\n  /**\n   * @notice Adds liquidity to the sponsor vault, native token or ERC20.\n   * @dev Anyone can add liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _amount The amount of ERC20 to deposit or zero for native token since the amount is sent in msg.value\n   */\n  function deposit(address _token, uint256 _amount) external payable {\n    if (_token != address(0)) {\n      IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    emit Deposit(_token, _token != address(0) ? _amount : msg.value, msg.sender);\n  }\n\n  /**\n   * @notice Removes liquidity from the sponsor vault, native token or ERC20.\n   * @dev Only the owner can remove liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _receiver The receiver of the tokens\n   * @param _amount The amount to remove\n   */\n  function withdraw(\n    address _token,\n    address _receiver,\n    uint256 _amount\n  ) external onlyOwner {\n    if (_token == address(0)) {\n      if (address(this).balance < _amount) revert SponsorVault__withdraw_invalidAmount();\n      Address.sendValue(payable(_receiver), _amount);\n    } else {\n      if (IERC20(_token).balanceOf(address(this)) < _amount) revert SponsorVault__withdraw_invalidAmount();\n      IERC20(_token).safeTransfer(_receiver, _amount);\n    }\n\n    emit Withdraw(_token, _receiver, _amount, msg.sender);\n  }\n\n  // ============ Internal functions ============\n\n  function _setConnext(address _connext) internal {\n    if (_connext == address(0)) revert SponsorVault__setConnext_invalidConnext();\n\n    emit ConnextUpdated(connext, _connext, msg.sender);\n\n    connext = _connext;\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport \"../../../utils/ForgeHelper.sol\";\n\nimport {SponsorVault, ITokenExchange, IGasTokenOracle} from \"../../../../contracts/core/connext/helpers/SponsorVault.sol\";\n\nimport {TestERC20} from \"../../../../contracts/test/TestERC20.sol\";\n\ncontract MockTokenExchange is ITokenExchange {\n  uint256 private sawpResult;\n\n  function setSwapResult(uint256 _sawpResult) external {\n    sawpResult = _sawpResult;\n  }\n\n  function getInGivenExpectedOut(address token, uint256 expectedOut) external returns (uint256) {\n    return expectedOut / 10;\n  }\n\n  function swapExactIn(address token, address recipient) external payable returns (uint256) {\n    return sawpResult;\n  }\n}\n\n// running tests (with logging on failure):\n// yarn workspace @connext/nxtp-contracts test:forge -vvv\n// run a single test:\n// yarn workspace @connext/nxtp-contracts test:forge -m testAddRouterAlreadyApproved -vvv\n\n// other forge commands: yarn workspace @connext/nxtp-contracts forge <CMD>\n// see docs here: https://onbjerg.github.io/foundry-book/index.html\n\ncontract SponsorVaultTest is ForgeHelper {\n  // ============ Libraries ============\n  using stdStorage for StdStorage;\n\n  // ============ Events ============\n\n  event ConnextUpdated(address oldConnext, address newConnext, address caller);\n  event RateUpdated(uint32 originDomain, SponsorVault.Rate oldRate, SponsorVault.Rate newRate, address caller);\n  event RelayerFeeCapUpdated(uint256 oldRelayerFeeCap, uint256 newRelayerFeeCap, address caller);\n  event GasTokenOracleUpdated(address oldOracle, address newOracle, address caller);\n  event TokenExchangeUpdated(address token, address oldTokenExchange, address newTokenExchange, address caller);\n  event Deposit(address token, uint256 amount, address caller);\n  event Withdraw(address token, address receiver, uint256 amount, address caller);\n  event ReimburseLiquidityFees(address token, uint256 amount, address receiver);\n  event ReimburseRelayerFees(uint256 amount, address receiver);\n\n  // ============ Storage ============\n\n  SponsorVault vault;\n\n  address connext = address(this);\n  address gasTokenOracle = address(1);\n  MockTokenExchange tokenExchange;\n  address gasPriceOracle = address(2);\n  uint32 originDomain = 1;\n  TestERC20 localToken;\n  TestERC20 localToken2;\n\n  SponsorVault.Rate rate = SponsorVault.Rate(1, 1);\n\n  receive() external payable {}\n\n  function setUp() public {\n    localToken = new TestERC20();\n    localToken2 = new TestERC20();\n\n    tokenExchange = new MockTokenExchange();\n\n    vault = new SponsorVault(connext);\n\n    localToken.approve(address(vault), type(uint256).max);\n    localToken2.approve(address(vault), type(uint256).max);\n\n    // fund the vault\n    vault.deposit{value: 100 ether}(address(0), 0);\n    vault.deposit(address(localToken), 10 ether);\n  }\n\n  // ============ Utils ============\n  // https://github.com/brockelmore/forge-std\n  // specifically here with overriding mappings: https://github.com/brockelmore/forge-std/blob/99107e3e39f27339d224575756d4548c08639bc0/src/test/StdStorage.t.sol#L189-L192\n\n  // ============ constructor ============\n  function test_SponsorVault__constructor_failsWithConnextZeroAddress() public {\n    vm.expectRevert(abi.encodeWithSelector(SponsorVault.SponsorVault__setConnext_invalidConnext.selector));\n\n    new SponsorVault(address(0));\n  }\n\n  function test_SponsorVault__constructor_works(address _connext) public {\n    vm.assume(_connext != address(0));\n\n    vm.expectEmit(true, true, true, true);\n    emit ConnextUpdated(address(0), _connext, address(this));\n\n    SponsorVault testVault = new SponsorVault(_connext);\n\n    assertEq(testVault.connext(), _connext);\n  }\n\n  // ============ setConnext ============\n\n  function test_SponsorVault__setConnext_failsIfNotOwner() public {\n    vm.prank(address(0));\n    vm.expectRevert(\"Ownable: caller is not the owner\");\n\n    vault.setConnext(address(2));\n  }\n\n  function test_SponsorVault__setConnext_failsWithConnextZeroAddress() public {\n    vm.expectRevert(abi.encodeWithSelector(SponsorVault.SponsorVault__setConnext_invalidConnext.selector));\n\n    vault.setConnext(address(0));\n  }\n\n  function test_SponsorVault__setConnext_works(address _connext) public {\n    vm.assume(_connext != address(0));\n\n    vm.expectEmit(true, true, true, true);\n    emit ConnextUpdated(connext, _connext, address(this));\n\n    vault.setConnext(_connext);\n\n    assertEq(vault.connext(), _connext);\n  }\n\n  // ============ setRate ============\n\n  function test_SponsorVault__setRate_failsIfNotOwner() public {\n    vm.prank(address(0));\n    vm.expectRevert(\"Ownable: caller is not the owner\");\n\n    vault.setRate(1, rate);\n  }\n\n  function test_SponsorVault__setRate_failsWithOriginDomainZero() public {\n    vm.expectRevert(abi.encodeWithSelector(SponsorVault.SponsorVault__setRate_invalidOriginDomain.selector));\n\n    vault.setRate(0, rate);\n  }\n\n  function test_SponsorVault__setRate_works(uint32 _originDomain, SponsorVault.Rate calldata _rate) public {\n    vm.assume(_originDomain != 0);\n\n    (uint256 currNum, uint256 currDen) = vault.rates(_originDomain);\n    SponsorVault.Rate memory currentRate = SponsorVault.Rate(currNum, currDen);\n\n    vm.expectEmit(true, true, true, true);\n    emit RateUpdated(_originDomain, currentRate, _rate, address(this));\n\n    vault.setRate(_originDomain, _rate);\n\n    (uint256 num, uint256 den) = vault.rates(_originDomain);\n\n    assertEq(num, _rate.num);\n    assertEq(den, _rate.den);\n  }\n\n  // ============ setRelayerFeeCap ============\n\n  function test_SponsorVault__setRelayerFeeCap_failsIfNotOwner() public {\n    vm.prank(address(0));\n    vm.expectRevert(\"Ownable: caller is not the owner\");\n\n    vault.setRelayerFeeCap(1);\n  }\n\n  function test_SponsorVault__setRelayerFeeCap_works(uint256 _relayerFeeCap) public {\n    uint256 currRelayerFeeCap = vault.relayerFeeCap();\n\n    vm.expectEmit(true, true, true, true);\n    emit RelayerFeeCapUpdated(currRelayerFeeCap, _relayerFeeCap, address(this));\n\n    vault.setRelayerFeeCap(_relayerFeeCap);\n\n    assertEq(vault.relayerFeeCap(), _relayerFeeCap);\n  }\n\n  // ============ setGasTokenOracle ============\n\n  function test_SponsorVault__setGasTokenOracle_failsIfNotOwner() public {\n    vm.prank(address(0));\n    vm.expectRevert(\"Ownable: caller is not the owner\");\n\n    vault.setGasTokenOracle(address(1));\n  }\n\n  function test_SponsorVault__setGasTokenOracle_works(address _gasTokenOracle) public {\n    address currOracle = address(vault.gasTokenOracle());\n\n    vm.expectEmit(true, true, true, true);\n    emit GasTokenOracleUpdated(currOracle, _gasTokenOracle, address(this));\n\n    vault.setGasTokenOracle(_gasTokenOracle);\n\n    assertEq(address(vault.gasTokenOracle()), _gasTokenOracle);\n  }\n\n  // ============ setTokenExchange ============\n\n  function test_SponsorVault__setTokenExchange_failsIfNotOwner() public {\n    vm.prank(address(0));\n    vm.expectRevert(\"Ownable: caller is not the owner\");\n\n    vault.setTokenExchange(address(2), payable(address(tokenExchange)));\n  }\n\n  function test_SponsorVault__setTokenExchange_failsWithConnextZeroAddress() public {\n    vm.expectRevert(abi.encodeWithSelector(SponsorVault.SponsorVault__setTokenExchange_invalidAdopted.selector));\n\n    vault.setTokenExchange(address(0), payable(address(tokenExchange)));\n  }\n\n  function test_SponsorVault__setTokenExchange_works(address _token, address payable _tokenExchange) public {\n    vm.assume(_token != address(0));\n\n    address currTokenExchange = address(vault.tokenExchanges(_token));\n\n    vm.expectEmit(true, true, true, true);\n    emit TokenExchangeUpdated(_token, currTokenExchange, _tokenExchange, address(this));\n\n    vault.setTokenExchange(_token, _tokenExchange);\n\n    assertEq(address(vault.tokenExchanges(_token)), _tokenExchange);\n  }\n\n  // ============ deposit ============\n  function test_SponsorVault__deposit_works_adding_native_token(uint256 _amount) public {\n    vm.assume(address(this).balance >= _amount);\n\n    uint256 balanceBefore = address(vault).balance;\n\n    vm.expectEmit(true, true, true, true);\n    emit Deposit(address(0), _amount, address(this));\n\n    vault.deposit{value: _amount}(address(0), 0);\n\n    assertEq(address(vault).balance, balanceBefore + _amount);\n  }\n\n  function test_SponsorVault__deposit_works_adding_ERC20_token(uint256 _amount) public {\n    TestERC20 someToken = new TestERC20();\n    vm.assume(someToken.balanceOf(address(this)) >= _amount);\n\n    uint256 balanceBefore = someToken.balanceOf(address(vault));\n\n    someToken.approve(address(vault), 1);\n\n    vm.expectEmit(true, true, true, true);\n    emit Deposit(address(someToken), 1, address(this));\n\n    vault.deposit(address(someToken), 1);\n\n    assertEq(someToken.balanceOf(address(vault)), balanceBefore + 1);\n  }\n\n  // ============ withdraw ============\n\n  function test_SponsorVault__withdraw_failsIfNotOwner() public {\n    vm.prank(address(0));\n    vm.expectRevert(\"Ownable: caller is not the owner\");\n\n    vault.withdraw(address(0), address(this), 1);\n  }\n\n  function test_SponsorVault__withdraw_fails_removing_more_than_owned() public {\n    uint256 balance = address(vault).balance;\n\n    vm.expectRevert(abi.encodeWithSelector(SponsorVault.SponsorVault__withdraw_invalidAmount.selector));\n\n    vault.withdraw(address(0), address(this), balance + 1);\n  }\n\n  function test_SponsorVault__withdraw_works_removing_native_token(uint256 _amount) public {\n    vm.assume(address(vault).balance >= _amount);\n\n    uint256 balanceThisBefore = address(this).balance;\n    uint256 balanceVaultBefore = address(vault).balance;\n\n    vm.expectEmit(true, true, true, true);\n    emit Withdraw(address(0), address(this), _amount, address(this));\n\n    vault.withdraw(address(0), address(this), _amount);\n\n    assertEq(address(this).balance, balanceThisBefore + _amount);\n    assertEq(address(vault).balance, balanceVaultBefore - _amount);\n  }\n\n  function test_SponsorVault__withdraw_works_removing_ERC20_token(uint256 _amount) public {\n    TestERC20 someToken = new TestERC20();\n    someToken.approve(address(vault), someToken.balanceOf(address(this)));\n    vault.deposit(address(someToken), someToken.balanceOf(address(this)));\n\n    uint256 balanceThisBefore = someToken.balanceOf(address(this));\n    uint256 balanceVaultBefore = someToken.balanceOf(address(vault));\n    vm.assume(balanceVaultBefore >= _amount);\n\n    vm.expectEmit(true, true, true, true);\n    emit Withdraw(address(someToken), address(this), _amount, address(this));\n\n    vault.withdraw(address(someToken), address(this), _amount);\n\n    assertEq(someToken.balanceOf(address(vault)), balanceVaultBefore - _amount);\n    assertEq(someToken.balanceOf(address(this)), balanceThisBefore + _amount);\n  }\n\n  // ============ reimburseLiquidityFees ============\n\n  function test_SponsorVault__reimburseLiquidityFees_failsIfNotConnext() public {\n    vm.prank(address(0));\n    vm.expectRevert(abi.encodeWithSelector(SponsorVault.SponsorVault__onlyConnext.selector));\n\n    vault.reimburseLiquidityFees(address(1), 1, address(1));\n  }\n\n  function test_SponsorVault__reimburseLiquidityFees_returns_0_if_no_tokenExchanges_and_no_token_balance() public {\n    assertEq(address(vault.tokenExchanges(address(1))), address(0));\n    assertEq(localToken2.balanceOf(address(vault)), 0);\n\n    uint256 balanceBefore = address(vault).balance;\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseLiquidityFees(address(localToken2), 0, address(1));\n\n    uint256 sponsored = vault.reimburseLiquidityFees(address(localToken2), 1, address(1));\n\n    assertEq(sponsored, 0);\n    assertEq(address(vault).balance, balanceBefore);\n  }\n\n  function test_SponsorVault__reimburseLiquidityFees_returns_should_work_with_tokenExchange_swap_balance_when_no_enough_native_token_to_cover_all_required_in()\n    public\n  {\n    tokenExchange.setSwapResult(1);\n    vault.setTokenExchange(address(localToken), payable(address(tokenExchange)));\n\n    uint256 balanceBefore = address(vault).balance;\n\n    vm.mockCall(\n      address(tokenExchange),\n      abi.encodeWithSelector(ITokenExchange.getInGivenExpectedOut.selector),\n      abi.encode(uint256(balanceBefore + 1))\n    );\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseLiquidityFees(address(localToken), 1, address(1));\n\n    uint256 sponsored = vault.reimburseLiquidityFees(address(localToken), 10, address(1));\n\n    assertEq(sponsored, 1);\n    assertEq(address(vault).balance, 0);\n  }\n\n  function test_SponsorVault__reimburseLiquidityFees_should_work_with_tokenExchange_swap_amount_required_amount_of_native_token()\n    public\n  {\n    uint256 liquidityFee = 500;\n    tokenExchange.setSwapResult(500);\n    uint256 amountIn = tokenExchange.getInGivenExpectedOut(address(localToken), liquidityFee);\n\n    vault.setTokenExchange(address(localToken), payable(address(tokenExchange)));\n\n    uint256 balanceBefore = address(vault).balance;\n\n    vm.expectCall(\n      address(tokenExchange),\n      abi.encodeWithSelector(ITokenExchange.swapExactIn.selector, address(localToken), address(this))\n    );\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseLiquidityFees(address(localToken), liquidityFee, address(1));\n\n    uint256 sponsored = vault.reimburseLiquidityFees(address(localToken), liquidityFee, address(1));\n\n    assertEq(sponsored, liquidityFee);\n    assertEq(address(vault).balance, balanceBefore - amountIn);\n  }\n\n  function test_SponsorVault__reimburseLiquidityFees_should_work_with_tokenExchange_sponsored_less_than_liquidityFee_due_to_slippage()\n    public\n  {\n    uint256 liquidityFee = 500;\n    tokenExchange.setSwapResult(500 - 5);\n    uint256 amountIn = tokenExchange.getInGivenExpectedOut(address(localToken), liquidityFee);\n\n    vault.setTokenExchange(address(localToken), payable(address(tokenExchange)));\n\n    uint256 balanceBefore = address(vault).balance;\n\n    vm.expectCall(\n      address(tokenExchange),\n      abi.encodeWithSelector(ITokenExchange.swapExactIn.selector, address(localToken), address(this))\n    );\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseLiquidityFees(address(localToken), liquidityFee - 5, address(1));\n\n    uint256 sponsored = vault.reimburseLiquidityFees(address(localToken), liquidityFee, address(1));\n\n    assertEq(sponsored, liquidityFee - 5);\n    assertEq(address(vault).balance, balanceBefore - amountIn);\n  }\n\n  function test_SponsorVault__reimburseLiquidityFees_should_work_with_no_tokenExchange_but_token_balance() public {\n    uint256 liquidityFee = 500;\n\n    assertEq(address(vault.tokenExchanges(address(1))), address(0));\n\n    uint256 balanceBefore = address(vault).balance;\n    uint256 balanceLocalBefore = localToken.balanceOf(address(vault));\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseLiquidityFees(address(localToken), liquidityFee, address(1));\n\n    uint256 sponsored = vault.reimburseLiquidityFees(address(localToken), liquidityFee, address(1));\n\n    assertEq(sponsored, liquidityFee);\n    assertEq(address(vault).balance, balanceBefore);\n    assertEq(localToken.balanceOf(address(vault)), balanceLocalBefore - liquidityFee);\n  }\n\n  function test_SponsorVault__reimburseLiquidityFees_should_work_with_no_tokenExchange_but_token_balance_sending_available_amount_if_no_enough()\n    public\n  {\n    uint256 balanceLocalBefore = localToken.balanceOf(address(vault));\n    uint256 liquidityFee = balanceLocalBefore + 10;\n\n    assertEq(address(vault.tokenExchanges(address(1))), address(0));\n\n    uint256 balanceBefore = address(vault).balance;\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseLiquidityFees(address(localToken), balanceLocalBefore, address(1));\n\n    uint256 sponsored = vault.reimburseLiquidityFees(address(localToken), liquidityFee, address(1));\n\n    assertEq(sponsored, balanceLocalBefore);\n    assertEq(address(vault).balance, balanceBefore);\n    assertEq(localToken.balanceOf(address(vault)), 0);\n  }\n\n  // ============ reimburseRelayerFees ============\n\n  function test_SponsorVault__reimburseRelayerFees_failsIfNotConnext() public {\n    vm.prank(address(0));\n    vm.expectRevert(abi.encodeWithSelector(SponsorVault.SponsorVault__onlyConnext.selector));\n\n    vault.reimburseRelayerFees(originDomain, payable(address(this)), 1);\n  }\n\n  function test_SponsorVault__reimburseRelayerFees_should_not_sponsor_fee_when_no_gasTokenOracle_nor_rate() public {\n    assertEq(address(vault.gasTokenOracle()), address(0));\n\n    (uint256 num, uint256 den) = vault.rates(originDomain);\n    assertEq(num, 0);\n    assertEq(den, 0);\n\n    uint256 relayerFeeCap = 1000;\n    uint256 relayerFee = 500;\n    address to = address(10);\n\n    vault.setRelayerFeeCap(relayerFeeCap);\n\n    uint256 balanceBefore = to.balance;\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseRelayerFees(0, to);\n\n    vault.reimburseRelayerFees(originDomain, payable(to), relayerFee);\n\n    assertEq(to.balance, balanceBefore);\n  }\n\n  function test_SponsorVault__reimburseRelayerFees_should_use_rate_when_no_gasTokenOracle_is_set() public {\n    SponsorVault.Rate memory _rate = SponsorVault.Rate({num: 1, den: 2});\n    uint256 relayerFeeCap = 1000;\n    uint256 relayerFee = 500;\n    address to = address(10);\n\n    vault.setRelayerFeeCap(relayerFeeCap);\n    vault.setRate(originDomain, _rate);\n\n    uint256 balanceBefore = to.balance;\n\n    uint256 expectedFee = ((relayerFee * _rate.num) / _rate.den);\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseRelayerFees(expectedFee, to);\n\n    vault.reimburseRelayerFees(originDomain, payable(to), relayerFee);\n\n    assertEq(to.balance, balanceBefore + expectedFee);\n  }\n\n  function test_SponsorVault__reimburseRelayerFees_should_use_rate_when_no_gasTokenOracle_is_set_partially_sponsoring_the_fee_when_no_enough_balance()\n    public\n  {\n    SponsorVault.Rate memory _rate = SponsorVault.Rate({num: 1, den: 1});\n    uint256 initialVaultBalance = address(vault).balance;\n    uint256 relayerFeeCap = initialVaultBalance * 2;\n    uint256 relayerFee = initialVaultBalance + 10;\n    address to = address(10);\n\n    vault.setRelayerFeeCap(relayerFeeCap);\n    vault.setRate(originDomain, _rate);\n\n    uint256 balanceBefore = to.balance;\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseRelayerFees(initialVaultBalance, to);\n\n    vault.reimburseRelayerFees(originDomain, payable(to), relayerFee);\n\n    assertEq(to.balance, balanceBefore + initialVaultBalance);\n  }\n\n  function test_SponsorVault__reimburseRelayerFees_should_return_relayerFeeCap_if_fee_is_to_high() public {\n    SponsorVault.Rate memory _rate = SponsorVault.Rate({num: 1, den: 2});\n    uint256 relayerFeeCap = 1000;\n    uint256 relayerFee = 3000;\n    address to = address(10);\n\n    vault.setRelayerFeeCap(relayerFeeCap);\n    vault.setRate(originDomain, _rate);\n\n    uint256 balanceBefore = to.balance;\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseRelayerFees(relayerFeeCap, to);\n\n    vault.reimburseRelayerFees(originDomain, payable(to), relayerFee);\n\n    assertEq(to.balance, balanceBefore + relayerFeeCap);\n  }\n\n  function test_SponsorVault__reimburseRelayerFees_should_use_gasTokenOracle_rate() public {\n    SponsorVault.Rate memory _rate = SponsorVault.Rate({num: 1, den: 2});\n\n    uint256 relayerFeeCap = 1000;\n    uint256 relayerFee = 500;\n    address to = address(10);\n\n    vault.setRelayerFeeCap(relayerFeeCap);\n    vault.setRate(originDomain, _rate);\n    vault.setGasTokenOracle(gasTokenOracle);\n\n    uint256 balanceBefore = to.balance;\n\n    SponsorVault.Rate memory gasTokenOracleRate = SponsorVault.Rate({num: 1, den: 3});\n\n    vm.mockCall(\n      address(gasTokenOracle),\n      abi.encodeWithSelector(IGasTokenOracle.getRate.selector),\n      abi.encode(gasTokenOracleRate)\n    );\n\n    vm.expectCall(address(gasTokenOracle), abi.encodeWithSelector(IGasTokenOracle.getRate.selector, originDomain));\n\n    uint256 expectedFee = ((relayerFee * gasTokenOracleRate.num) / gasTokenOracleRate.den);\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseRelayerFees(expectedFee, to);\n\n    vault.reimburseRelayerFees(originDomain, payable(to), relayerFee);\n\n    assertEq(to.balance, balanceBefore + expectedFee);\n  }\n\n  function test_SponsorVault__reimburseRelayerFees_should_use_gasTokenOracle_rate_but_return_relayerFeeCap_when_fee_is_to_high()\n    public\n  {\n    SponsorVault.Rate memory _rate = SponsorVault.Rate({num: 1, den: 2});\n\n    uint256 relayerFeeCap = 1000;\n    uint256 relayerFee = 3300;\n    address to = address(10);\n\n    vault.setRelayerFeeCap(relayerFeeCap);\n    vault.setRate(originDomain, _rate);\n    vault.setGasTokenOracle(gasTokenOracle);\n\n    uint256 balanceBefore = to.balance;\n\n    SponsorVault.Rate memory gasTokenOracleRate = SponsorVault.Rate({num: 1, den: 3});\n\n    vm.mockCall(\n      address(gasTokenOracle),\n      abi.encodeWithSelector(IGasTokenOracle.getRate.selector),\n      abi.encode(gasTokenOracleRate)\n    );\n\n    vm.expectCall(address(gasTokenOracle), abi.encodeWithSelector(IGasTokenOracle.getRate.selector, originDomain));\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseRelayerFees(relayerFeeCap, to);\n\n    vault.reimburseRelayerFees(originDomain, payable(to), relayerFee);\n\n    assertEq(to.balance, balanceBefore + relayerFeeCap);\n  }\n\n  function test_SponsorVault__reimburseRelayerFees_should_use_gasTokenOracle_rate_partially_sponsoring_the_fee_when_no_enough_balance()\n    public\n  {\n    SponsorVault.Rate memory _rate = SponsorVault.Rate({num: 1, den: 2});\n\n    address to = address(10);\n    uint256 balanceBefore = to.balance;\n    uint256 initialVaultBalance = address(vault).balance;\n    uint256 relayerFeeCap = initialVaultBalance * 2;\n    uint256 relayerFee = initialVaultBalance + 10;\n\n    vault.setRelayerFeeCap(relayerFeeCap);\n    vault.setRate(originDomain, _rate);\n    vault.setGasTokenOracle(gasTokenOracle);\n\n    SponsorVault.Rate memory gasTokenOracleRate = SponsorVault.Rate({num: 1, den: 1});\n\n    vm.mockCall(\n      address(gasTokenOracle),\n      abi.encodeWithSelector(IGasTokenOracle.getRate.selector),\n      abi.encode(gasTokenOracleRate)\n    );\n\n    vm.expectCall(address(gasTokenOracle), abi.encodeWithSelector(IGasTokenOracle.getRate.selector, originDomain));\n\n    vm.expectEmit(true, true, true, true);\n    emit ReimburseRelayerFees(initialVaultBalance, to);\n\n    vault.reimburseRelayerFees(originDomain, payable(to), relayerFee);\n\n    assertEq(to.balance, balanceBefore + initialVaultBalance);\n  }\n}\n\n\n",
        "CodeNames": [
            "SponsorVault.sol",
            "SponsorVault.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "reimburseLiquidityFees() function in SponsorVault.sol",
                "Type": "Missing slippage limit in token swap",
                "Description": "In reimburseLiquidityFees() of SponserVault contract, swaps tokens without slippage limit so it's possible to perform sandwich attack and create MEV.",
                "Repair": "Specify slippage when calling swap tokens"
            },
            {
                "Location": "SponsorVault contract",
                "Type": "Single point of failure",
                "Description": "A third party sponsor would need to implement a SponsorVault contract that is aligned with the ISponsorVault interface. If there is an error within SponsorVault contract in Optimism causing a revert when s.sponsorVault.reimburseLiquidityFees or s.sponsorVault.reimburseRelayerFees is called, the entire execute transaction will revert. The SponsorVault contract, which belongs to a third-party, is a single point of failure for a domain.",
                "Repair": "Implement a fail-safe design where failure of an external call to SponsorVault will not disrupt the cross-chain communication. Consider implementing a try-catch block."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n  uint256 private constant _delay = 7 days;\n\n  struct FacetAddressAndPosition {\n    address facetAddress;\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n  }\n\n  struct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n  }\n\n  struct DiamondStorage {\n    // maps function selector to the facet address and\n    // the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    // facet addresses\n    address[] facetAddresses;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address contractOwner;\n    // hash of proposed facets => acceptance time\n    mapping(bytes32 => uint256) acceptanceTimes;\n  }\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function setContractOwner(address _newOwner) internal {\n    DiamondStorage storage ds = diamondStorage();\n    address previousOwner = ds.contractOwner;\n    ds.contractOwner = _newOwner;\n    emit OwnershipTransferred(previousOwner, _newOwner);\n  }\n\n  function contractOwner() internal view returns (address contractOwner_) {\n    contractOwner_ = diamondStorage().contractOwner;\n  }\n\n  function enforceIsContractOwner() internal view {\n    require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n  }\n\n  event DiamondCutProposed(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata, uint256 deadline);\n\n  function proposeDiamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    uint256 acceptance = block.timestamp + _delay;\n    diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = acceptance;\n    emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);\n  }\n\n  event DiamondCutRescinded(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  function rescindDiamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0;\n    emit DiamondCutRescinded(_diamondCut, _init, _calldata);\n  }\n\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  // Internal function version of diamondCut\n  function diamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    require(\n      diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp,\n      \"LibDiamond: delay not elapsed\"\n    );\n    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n      if (action == IDiamondCut.FacetCutAction.Add) {\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else {\n        revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n      }\n    }\n    emit DiamondCut(_diamondCut, _init, _calldata);\n    initializeDiamondCut(_init, _calldata);\n  }\n\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n    // add new facet address if it does not exist\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      selectorPosition++;\n    }\n  }\n\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n    // add new facet address if it does not exist\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n      removeFunction(ds, oldFacetAddress, selector);\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      selectorPosition++;\n    }\n  }\n\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    // if function does not exist then do nothing and return\n    require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      removeFunction(ds, oldFacetAddress, selector);\n    }\n  }\n\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n    enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n    ds.facetAddresses.push(_facetAddress);\n  }\n\n  function addFunction(\n    DiamondStorage storage ds,\n    bytes4 _selector,\n    uint96 _selectorPosition,\n    address _facetAddress\n  ) internal {\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n  }\n\n  function removeFunction(\n    DiamondStorage storage ds,\n    address _facetAddress,\n    bytes4 _selector\n  ) internal {\n    require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n    // an immutable function is a function defined directly in a diamond\n    require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n    // replace selector with last selector, then delete last selector\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n    // if not the same then replace _selector with lastSelector\n    if (selectorPosition != lastSelectorPosition) {\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n    }\n    // delete the last selector\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n    delete ds.selectorToFacetAndPosition[_selector];\n\n    // if no more selectors for facet address then delete the facet address\n    if (lastSelectorPosition == 0) {\n      // replace facet address with last facet address and delete last facet address\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n      if (facetAddressPosition != lastFacetAddressPosition) {\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n      }\n      ds.facetAddresses.pop();\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n    }\n  }\n\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n    if (_init == address(0)) {\n      require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n    } else {\n      require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n      if (_init != address(this)) {\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n      }\n      (bool success, bytes memory error) = _init.delegatecall(_calldata);\n      if (!success) {\n        if (error.length > 0) {\n          // bubble up the error\n          revert(string(error));\n        } else {\n          revert(\"LibDiamondCut: _init function reverted\");\n        }\n      }\n    }\n  }\n\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n    uint256 contractSize;\n    assembly {\n      contractSize := extcodesize(_contract)\n    }\n    require(contractSize > 0, _errorMessage);\n  }\n}\n\n\n",
        "CodeNames": [
            "LibDiamond.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "diamondCut() function in LibDiamond.sol",
                "Type": "Missing check in diamondCut()",
                "Description": "In LibDiamond.rescindDiamondCut(), acceptanceTimes[keccak256(abi.encode(_diamondCut))] is set to 0, which can easily pass the check in diamondCut() and bypass the delay time. If proposeDiamondCut() has never been called, the check for delay time is always passed.",
                "Repair": "Add another check in diamondCut() to ensure that acceptanceTimes[keccak256(abi.encode(_diamondCut))] is not 0"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {XAppConnectionManager, TypeCasts} from \"../../../../contracts/nomad-core/contracts/XAppConnectionManager.sol\";\nimport {Home} from \"../../../../contracts/nomad-core/contracts/Home.sol\";\nimport {TypedMemView} from \"../../../../contracts/nomad-core/libs/TypedMemView.sol\";\n\nimport {IAavePool} from \"../../../../contracts/core/connext/interfaces/IAavePool.sol\";\nimport {IStableSwap} from \"../../../../contracts/core/connext/interfaces/IStableSwap.sol\";\nimport {ISponsorVault} from \"../../../../contracts/core/connext/interfaces/ISponsorVault.sol\";\nimport {ITokenRegistry} from \"../../../../contracts/core/connext/interfaces/ITokenRegistry.sol\";\nimport {TokenRegistry} from \"../../../../contracts/core/connext/helpers/TokenRegistry.sol\";\nimport {IBridgeToken} from \"../../../../contracts/core/connext/interfaces/IBridgeToken.sol\";\nimport {IWrapped} from \"../../../../contracts/core/connext/interfaces/IWrapped.sol\";\nimport {IExecutor} from \"../../../../contracts/core/connext/interfaces/IExecutor.sol\";\nimport {Executor} from \"../../../../contracts/core/connext/helpers/Executor.sol\";\nimport {ConnextMessage} from \"../../../../contracts/core/connext/libraries/ConnextMessage.sol\";\nimport {RelayerFeeMessage} from \"../../../../contracts/core/relayer-fee/libraries/RelayerFeeMessage.sol\";\nimport {AssetLogic} from \"../../../../contracts/core/connext/libraries/AssetLogic.sol\";\nimport {LibCrossDomainProperty} from \"../../../../contracts/core/connext/libraries/LibCrossDomainProperty.sol\";\nimport {CallParams, ExecuteArgs, XCallArgs} from \"../../../../contracts/core/connext/libraries/LibConnextStorage.sol\";\nimport {LibDiamond} from \"../../../../contracts/core/connext/libraries/LibDiamond.sol\";\nimport {BridgeFacet} from \"../../../../contracts/core/connext/facets/BridgeFacet.sol\";\nimport {BaseConnextFacet} from \"../../../../contracts/core/connext/facets/BaseConnextFacet.sol\";\nimport {TestERC20} from \"../../../../contracts/test/TestERC20.sol\";\nimport {PromiseRouter} from \"../../../../contracts/core/promise/PromiseRouter.sol\";\n\nimport \"../../../utils/Mock.sol\";\n\nimport \"./FacetHelper.sol\";\n\ncontract BridgeFacetTest is BridgeFacet, FacetHelper {\n  // ============ Libs ============\n  using TypedMemView for bytes29;\n  using TypedMemView for bytes;\n  // ============ Constants ============\n\n  bytes32 constant TEST_MESSAGE = bytes32(\"test message\");\n\n  // ============ Storage ============\n  // diamond storage contract owner\n  address _ds_owner = address(987654321);\n\n  // executor contract\n  address _executor;\n  // mock xapp contract\n  address _xapp;\n  // mock xapp connection manager\n  address _xappConnectionManager;\n  // mock home\n  address _xappHome;\n  // mock promise router\n  address payable _promiseRouter;\n  // mock callback contract\n  address _callback;\n\n  // agents\n  address _agent = address(123456654321);\n\n  // default origin sender\n  address _originSender = address(4);\n\n  // aave pool details\n  address _aavePool;\n\n  // relayer fee\n  uint256 _relayerFee = 0.1 ether;\n\n  // default amount\n  uint256 _amount = 1.1 ether;\n\n  // default nonce on xcall\n  uint256 _nonce = 1;\n\n  // default recovery address\n  address constant _recovery = address(121212);\n\n  // default CallParams\n  CallParams _params =\n    CallParams(\n      address(11), // to\n      bytes(\"\"), // callData\n      _originDomain, // origin domain\n      _destinationDomain, // destination domain\n      _agent, // agent\n      _recovery, // recovery address\n      address(0), // callback\n      0, // callbackFee\n      _relayerFee, // relayer fee\n      false, // forceSlow\n      false, // receiveLocal\n      9900 // slippageTol\n    );\n\n  // ============ Test set up ============\n  function setUp() public {\n    // Deploy any needed contracts.\n    utils_deployContracts();\n\n    utils_setFees();\n\n    // Set up asset context. By default, local is the adopted asset - the one the 'user'\n    // is using - and is representational (meaning canonically it belongs to another chain).\n    utils_setupAsset(true, false);\n\n    // Promise router mock calls.\n    vm.mockCall(_promiseRouter, abi.encodeWithSelector(PromiseRouter.send.selector), abi.encode());\n    vm.mockCall(_promiseRouter, abi.encodeWithSelector(PromiseRouter.initCallbackFee.selector), abi.encode());\n\n    // Other context setup: configuration, storage, etc.\n    s.approvedRelayers[address(this)] = true;\n    s.maxRoutersPerTransfer = 5;\n    s._routerOwnershipRenounced = true;\n\n    vm.prank(address(this));\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.contractOwner = _ds_owner;\n\n    // NOTE: Currently, the only time we check for the domain in params to match the contract's\n    // domain is within the `xcall` method - so it's safe to set the contract domain to be origin.\n    utils_setRemote(true);\n  }\n\n  // ============ Utils ============\n  // Utils used in the following tests (as well as setup).\n\n  // Used in set up for deploying any needed peripheral contracts.\n  function utils_deployContracts() public {\n    utils_deployAssetContracts();\n    // Deploy an executor.\n    _executor = address(new Executor(address(this)));\n    s.executor = IExecutor(_executor);\n    // Deploy a mock xapp consumer.\n    _xapp = address(new MockXApp());\n\n    // Deploy a mock home.\n    _xappHome = address(new MockHome());\n    // Deploy a mock xapp connection manager.\n    _xappConnectionManager = address(new MockXAppConnectionManager(MockHome(_xappHome)));\n    s.xAppConnectionManager = XAppConnectionManager(_xappConnectionManager);\n    // Deploy the promise router.\n    s.promiseRouter = new MockPromiseRouter();\n    _promiseRouter = payable(s.promiseRouter);\n\n    // Deploy a mock callback.\n    _callback = address(new MockCallback());\n\n    // setup aave pool\n    _aavePool = address(new MockPool(false));\n    s.aavePool = _aavePool;\n  }\n\n  // Meant to mimic the corresponding `_getTransferId` method in the BridgeFacet contract.\n  function utils_getTransferIdFromXCallArgs(\n    XCallArgs memory _args,\n    address sender,\n    bytes32 canonicalId,\n    uint32 canonicalDomain\n  ) public view returns (bytes32) {\n    return keccak256(abi.encode(s.nonce, _args.params, sender, canonicalId, canonicalDomain, _args.amount));\n  }\n\n  // Meant to mimic the corresponding `_getTransferId` method in the BridgeFacet contract.\n  function utils_getTransferIdFromExecuteArgs(ExecuteArgs memory _args) public returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(_args.nonce, _args.params, _args.originSender, _canonicalId, _canonicalDomain, _args.amount)\n      );\n  }\n\n  // Makes some mock xcall arguments using params set in storage.\n  function utils_makeXCallArgs() public returns (bytes32, XCallArgs memory) {\n    // get args\n    XCallArgs memory args = XCallArgs(\n      _params,\n      _adopted == address(s.wrapper) ? address(0) : _adopted, // transactingAssetId : could be adopted, local, or wrapped.\n      _amount\n    );\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromXCallArgs(args, _originSender, _canonicalId, _canonicalDomain);\n\n    return (transferId, args);\n  }\n\n  function utils_makeXCallArgs(address transactingAssetId) public returns (bytes32, XCallArgs memory) {\n    // get args\n    XCallArgs memory args = XCallArgs(\n      _params,\n      transactingAssetId, // transactingAssetId : could be adopted, local, or wrapped.\n      _amount\n    );\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromXCallArgs(args, _originSender, _canonicalId, _canonicalDomain);\n\n    return (transferId, args);\n  }\n\n  // Makes some mock router signatures.\n  function utils_makeRouterSignatures(\n    bytes32 _transferId,\n    address[] memory _routers,\n    uint256[] memory _keys\n  ) public returns (bytes[] memory) {\n    uint256 pathLen = _routers.length;\n    bytes[] memory signatures = new bytes[](pathLen);\n    if (pathLen == 0) {\n      return signatures;\n    }\n    bytes32 preImage = keccak256(abi.encode(_transferId, pathLen));\n    bytes32 toSign = ECDSA.toEthSignedMessageHash(preImage);\n    for (uint256 i; i < pathLen; i++) {\n      (uint8 v, bytes32 r, bytes32 _s) = vm.sign(_keys[i], toSign);\n      signatures[i] = abi.encodePacked(r, _s, v);\n    }\n    return signatures;\n  }\n\n  // Makes some mock execute arguments with given router/key pairs.\n  function utils_makeExecuteArgs(address[] memory routers, uint256[] memory keys)\n    public\n    returns (bytes32, ExecuteArgs memory)\n  {\n    // get args\n    bytes[] memory empty = new bytes[](0);\n    ExecuteArgs memory args = ExecuteArgs(_params, _local, routers, empty, _amount, _nonce, _originSender);\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromExecuteArgs(args);\n    // generate router signatures if applicable\n    if (routers.length > 0) {\n      args.routerSignatures = utils_makeRouterSignatures(transferId, routers, keys);\n    }\n    return (transferId, args);\n  }\n\n  // Make execute args, fill in a number of router/key pairs.\n  // Specifically input 0 to make execute arguments with no routers/keys for slow liq simulation.\n  function utils_makeExecuteArgs(uint256 num) public returns (bytes32, ExecuteArgs memory) {\n    if (num == 0) {\n      address[] memory routers;\n      uint256[] memory keys;\n      return utils_makeExecuteArgs(routers, keys);\n    }\n    address[] memory routers = new address[](num);\n    uint256[] memory keys = new uint256[](num);\n    for (uint256 i; i < num; i++) {\n      routers[i] = vm.addr(777 + i);\n      keys[i] = 777 + i;\n    }\n    return utils_makeExecuteArgs(routers, keys);\n  }\n\n  // Intended to mock the fast transfer amount calculation in the target contract.\n  function utils_getFastTransferAmount(uint256 _amount) public returns (uint256) {\n    // This is the method used internally to get the amount of tokens to transfer after liquidity\n    // fees are taken.\n    return (_amount * s.LIQUIDITY_FEE_NUMERATOR) / s.LIQUIDITY_FEE_DENOMINATOR;\n  }\n\n  // Mimics the xcall message formatting. Reduced functionality : won't burn any tokens, for example.\n  function utils_formatMessage(\n    XCallArgs memory _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) public returns (bytes memory) {\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      detailsHash = token.detailsHash();\n    }\n\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  // Wraps reconcile in order to enable externalizing the call.\n  function utils_wrappedReconcile(uint32 origin, bytes memory message) external {\n    _reconcile(origin, message);\n  }\n\n  struct PortalInfo {\n    uint256 fee;\n    uint256 debt;\n    uint256 total;\n    bool aaveReturns;\n  }\n\n  function utils_setPortals(\n    bytes32 _id,\n    uint256 _amount,\n    uint256 _fee\n  ) public returns (PortalInfo memory) {\n    s.portalFeeDebt[_id] = _fee;\n    s.portalDebt[_id] = _amount;\n    return PortalInfo(_fee, _amount, _fee + _amount, true);\n  }\n\n  function utils_setPortals(bytes32 _id, uint256 _amount) public returns (PortalInfo memory) {\n    return utils_setPortals(_id, _amount, (_amount * _portalFeeNumerator) / _liquidityFeeDenominator);\n  }\n\n  // ============== Helpers ==================\n  // Helpers used for executing target methods with given params that assert expected base behavior.\n  function helpers_setupSuccessfulXcallCallAssertions(\n    bytes32 transferId,\n    XCallArgs memory args,\n    uint256 bridgedAmt,\n    bool isNative,\n    bool shouldSwap\n  ) public {\n    // bridged is either local or canonical, depending on domain xcall originates on\n    address bridged = _canonicalDomain == args.params.originDomain ? _canonical : _local;\n    BridgeFacet.XCalledEventArgs memory eventArgs = BridgeFacet.XCalledEventArgs({\n      transactingAssetId: isNative ? address(s.wrapper) : args.transactingAssetId,\n      amount: args.amount,\n      bridgedAmt: bridgedAmt,\n      bridged: bridged\n    });\n    bytes memory message = utils_formatMessage(args, bridged, transferId, bridgedAmt);\n    vm.expectEmit(true, true, true, true);\n    emit XCalled(transferId, args, eventArgs, s.nonce, message, _originSender);\n\n    // assert swap if expected\n    if (shouldSwap && bridgedAmt > 0) {\n      // Transacting asset shouldve been approved for amount in\n      vm.expectCall(\n        eventArgs.transactingAssetId,\n        abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, args.amount)\n      );\n\n      // swapExact on pool should have been called\n      uint256 minReceived = (args.amount * args.params.slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(\n          IStableSwap.swapExact.selector,\n          args.amount,\n          eventArgs.transactingAssetId,\n          _local,\n          minReceived\n        )\n      );\n    }\n\n    if (args.params.callbackFee > 0) {\n      // Assert that CallbackFee would be paid by the user.\n      vm.expectCall(\n        _promiseRouter,\n        args.params.callbackFee,\n        abi.encodeWithSelector(PromiseRouter.initCallbackFee.selector, transferId)\n      );\n    }\n    // Assert dispatch call\n    vm.expectCall(\n      _xappHome,\n      0,\n      abi.encodeWithSelector(Home.dispatch.selector, args.params.destinationDomain, _remote, message)\n    );\n\n    // if the token is a representation token, ensure that burn is called\n    if (bridged != _canonical && bridgedAmt > 0) {\n      vm.expectCall(_local, abi.encodeWithSelector(TestERC20.burn.selector, address(this), bridgedAmt));\n    }\n  }\n\n  // Calls `xcall` with given args and handles standard assertions.\n  function helpers_xcallAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    uint256 dealTokens,\n    uint256 bridgedAmt,\n    bytes4 expectedError,\n    bool shouldSwap\n  ) public {\n    bool isNative = args.transactingAssetId == address(0);\n    bool shouldSucceed = keccak256(abi.encode(expectedError)) == keccak256(abi.encode(bytes4(\"\")));\n    bool isCanonical = _canonicalDomain == args.params.originDomain;\n\n    // Deal the user required eth for transfer.\n    vm.deal(_originSender, 100 ether);\n\n    uint256 initialUserBalance;\n    uint256 initialContractBalance;\n    if (isNative) {\n      initialUserBalance = payable(_originSender).balance;\n      initialContractBalance = payable(address(this)).balance;\n    } else {\n      TestERC20 tokenIn = TestERC20(args.transactingAssetId);\n      TestERC20 localToken = TestERC20(_local);\n\n      // Mint the specified amount of tokens for the user.\n      tokenIn.mint(_originSender, dealTokens);\n\n      initialUserBalance = tokenIn.balanceOf(_originSender);\n      initialContractBalance = localToken.balanceOf(address(this));\n\n      // Approve the target contract to spend the specified amount of tokens.\n      vm.prank(_originSender);\n      tokenIn.approve(address(this), dealTokens);\n    }\n\n    if (shouldSwap) {\n      // Setup the expected swap mock (adopted <> local)\n      vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExact.selector), abi.encode(bridgedAmt, _local));\n    }\n\n    assertEq(s.relayerFees[transferId], 0);\n\n    if (shouldSucceed) {\n      helpers_setupSuccessfulXcallCallAssertions(transferId, args, bridgedAmt, isNative, shouldSwap);\n    } else {\n      vm.expectRevert(expectedError);\n    }\n\n    uint256 fees = args.params.relayerFee + args.params.callbackFee;\n    vm.prank(_originSender);\n    this.xcall{value: isNative ? fees + args.amount : fees}(args);\n\n    if (shouldSucceed) {\n      if (isNative) {\n        // Should have custodied the relayer fee, sent any callback fee to the promise router, and deposited the\n        // amount into the wrapper contract.\n        assertEq(payable(address(this)).balance, initialContractBalance + args.params.relayerFee);\n      } else {\n        // User should have been debited fees... but also tx cost?\n        // assertEq(payable(_originSender).balance, initialUserBalance - fees);\n\n        // Check that the user has been debited the correct amount of tokens.\n        assertEq(TestERC20(args.transactingAssetId).balanceOf(_originSender), initialUserBalance - args.amount);\n\n        // Check that the contract has been credited the correct amount of tokens.\n        // NOTE: Because the tokens are a representational local asset, they are burnt. The contract\n        // should NOT be holding any additional tokens after xcall completes.\n        if (isCanonical) {\n          // This should be a canonical asset transfer\n          assertEq(TestERC20(_canonical).balanceOf(address(this)), initialContractBalance + bridgedAmt);\n        } else {\n          // NOTE: Normally the adopted asset would be swapped into the local asset and then\n          // the local asset would be burned. Because the swap increases the contracts balance\n          // the prod difference in balance is net 0. However, because the swap here is mocked,\n          // when a swap occurrs no balance increase of local happens (i.e. if swap needed, the\n          // balance will decrease by bridgedAmt / what is burned)\n          uint256 expected = args.transactingAssetId == _local\n            ? initialContractBalance\n            : initialContractBalance - bridgedAmt;\n          assertEq(TestERC20(_local).balanceOf(address(this)), expected);\n        }\n      }\n      // Should have updated relayer fees mapping.\n      assertEq(this.relayerFees(transferId), args.params.relayerFee);\n\n      if (args.params.callbackFee > 0) {\n        // TODO: For some reason, balance isn't changing. Perhaps the vm.mockCall prevents this?\n        // CallbackFee should be delivered to the PromiseRouter.\n        // assertEq(_promiseRouter.balance, _params.callbackFee);\n      }\n    } else {\n      // Should have reverted.\n      assertEq(this.relayerFees(transferId), 0);\n    }\n  }\n\n  // Shortcut for the main fn. Generates args within this method.\n  function helpers_xcallAndAssert(\n    bytes4 expectedError,\n    uint256 bridged,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    uint256 dealTokens = (args.transactingAssetId == address(0)) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, expectedError, swaps);\n  }\n\n  function helpers_xcallAndAssert(bytes4 expectedError) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    uint256 dealTokens = (args.transactingAssetId == address(0)) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, 0, expectedError, false);\n  }\n\n  // Shortcut for the above fn, with no expected error.\n  function helpers_xcallAndAssert(uint256 bridged, bool swaps) public {\n    helpers_xcallAndAssert(bytes4(\"\"), bridged, swaps);\n  }\n\n  // Shortcut for the above fn, no expected error, specified transacting asset\n  function helpers_xcallAndAssert(\n    uint256 bridged,\n    address transacting,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs(transacting);\n    uint256 dealTokens = transacting == address(0) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, bytes4(\"\"), swaps);\n  }\n\n  // Shortcut for the main fn.\n  function helpers_xcallAndAssert(\n    uint256 dealTokens,\n    uint256 bridged,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, bytes4(\"\"), swaps);\n  }\n\n  struct ExecuteBalances {\n    uint256 bridge;\n    uint256 to;\n    uint256 executor;\n    uint256 debt;\n    uint256 feeDebt;\n  }\n\n  struct ExecuteTestInputs {\n    uint256 expectedAmt;\n    uint256 routerAmt;\n    address token;\n    bool callsExternal;\n    bool externalCallSucceeds;\n    bool shouldSwap; // Whether the `to` address should receive the tokens.\n    bool isSlow;\n    bool usesPortals;\n    bool useAgent;\n  }\n\n  function utils_getExecuteBalances(\n    bytes32 transferId,\n    IERC20 asset,\n    address _to\n  ) public returns (ExecuteBalances memory) {\n    uint256 debt = s.portalDebt[transferId];\n    uint256 fee = s.portalFeeDebt[transferId];\n    uint256 bridge = IERC20(_local).balanceOf(address(this));\n    uint256 to = address(asset) == address(s.wrapper) ? payable(_to).balance : asset.balanceOf(_to);\n    uint256 executor = address(asset) == address(s.wrapper) ? payable(_executor).balance : asset.balanceOf(_executor);\n    return ExecuteBalances(bridge, to, executor, debt, fee);\n  }\n\n  function helpers_setupExecuteAssertions(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    ExecuteTestInputs memory _inputs\n  ) public {\n    // ----- register expected calls\n\n    // expects portal\n    if (_inputs.usesPortals) {\n      // mint position\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.mintUnbacked.selector, _adopted, _inputs.routerAmt, address(this), 0)\n      );\n\n      // withdraw\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.withdraw.selector, _adopted, _inputs.routerAmt, address(this))\n      );\n    }\n\n    // expected swap\n    if (_inputs.shouldSwap) {\n      // register expected approval\n      vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, _inputs.routerAmt));\n      // register expected swap amount\n      uint256 minReceived = (_inputs.routerAmt * _args.params.slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.swapExact.selector, _inputs.routerAmt, _local, _adopted, minReceived)\n      );\n    }\n\n    // expected sponsor vault\n    if (address(s.sponsorVault) != address(0)) {\n      // if it is a fast transfer, then it should reimburse liquidity fees\n      if (!_inputs.isSlow) {\n        vm.expectCall(\n          address(s.sponsorVault),\n          abi.encodeWithSelector(\n            ISponsorVault.reimburseLiquidityFees.selector,\n            _inputs.token,\n            _args.amount,\n            _args.params.to\n          )\n        );\n      }\n      // always reimburses relayer fees\n      vm.expectCall(\n        address(s.sponsorVault),\n        abi.encodeWithSelector(\n          ISponsorVault.reimburseRelayerFees.selector,\n          _originDomain,\n          _args.params.to,\n          _args.params.relayerFee\n        )\n      );\n    }\n\n    // expected transfer out of contract\n    if (_args.amount > 0) {\n      if (_inputs.token == address(s.wrapper)) {\n        // wrapper withdrawal\n        vm.expectCall(_inputs.token, abi.encodeWithSelector(IWrapped.withdraw.selector, _inputs.expectedAmt));\n      } else {\n        // token transfer\n        vm.expectCall(\n          _inputs.token,\n          abi.encodeWithSelector(\n            IERC20.transfer.selector,\n            _inputs.callsExternal ? _executor : _args.params.to,\n            _inputs.expectedAmt\n          )\n        );\n      }\n    }\n\n    // expected executor call\n    if (_inputs.callsExternal) {\n      {\n        bytes memory properties = _inputs.isSlow\n          ? LibCrossDomainProperty.formatDomainAndSenderBytes(_originDomain, _originSender)\n          : LibCrossDomainProperty.EMPTY_BYTES;\n        vm.expectCall(\n          _executor,\n          abi.encodeWithSelector(\n            IExecutor.execute.selector,\n            IExecutor.ExecutorArgs(\n              transferId,\n              _inputs.expectedAmt,\n              _args.params.to,\n              _args.params.recovery,\n              _inputs.token,\n              properties,\n              _args.params.callData\n            )\n          )\n        );\n      }\n    }\n\n    // expected promise router call\n    if (_args.params.callback != address(0)) {\n      vm.expectCall(\n        _promiseRouter,\n        abi.encodeWithSelector(\n          PromiseRouter.send.selector,\n          _originDomain,\n          transferId,\n          _args.params.callback,\n          _inputs.externalCallSucceeds,\n          bytes(\"\")\n        )\n      );\n    }\n  }\n\n  // Calls `execute` on the target method with the given args and asserts expected behavior.\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    ExecuteTestInputs memory _inputs\n  ) public {\n    // get pre-execute liquidity in local\n    uint256 pathLen = _args.routers.length;\n    uint256[] memory prevLiquidity = new uint256[](pathLen);\n    {\n      for (uint256 i; i < pathLen; i++) {\n        prevLiquidity[i] = s.routerBalances[_args.routers[i]][_local];\n      }\n    }\n\n    // get pre-execute balance here in local\n    IERC20 token = IERC20(_inputs.token);\n    ExecuteBalances memory prevBalances = utils_getExecuteBalances(transferId, token, _args.params.to);\n\n    // execute\n    // expected amount is impacted by (1) fast liquidity fees (2) slippage\n    // router debited amount in local is only impacted by fast liquidity\n    uint256 routerAmt = _inputs.isSlow ? _args.amount : utils_getFastTransferAmount(_args.amount);\n\n    // setup pool mock if needed\n    if (_inputs.shouldSwap) {\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.swapExact.selector),\n        abi.encode(_inputs.expectedAmt, _adopted)\n      );\n    }\n\n    if (_inputs.token == address(s.wrapper)) {\n      vm.mockCall(_inputs.token, abi.encodeWithSelector(IWrapped.withdraw.selector), abi.encode(true));\n    }\n\n    // setup execute mock\n    vm.mockCall(\n      _executor,\n      abi.encodeWithSelector(Executor.execute.selector),\n      abi.encode(_inputs.externalCallSucceeds, bytes(\"\"))\n    );\n\n    // register expected calls\n    helpers_setupExecuteAssertions(transferId, _args, _inputs);\n\n    if (_inputs.usesPortals) {\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalMintUnbacked(transferId, _args.routers[0], _inputs.token, _inputs.expectedAmt);\n    }\n\n    // register expected emit event\n    address sender = _inputs.useAgent ? _args.params.agent : address(this);\n    vm.expectEmit(true, true, false, true);\n    emit Executed(transferId, _args.params.to, _args, _inputs.token, _inputs.expectedAmt, sender);\n    // make call\n    vm.prank(sender);\n    this.execute(_args);\n\n    // check local balance\n    {\n      if (pathLen > 0) {\n        // should decrement router balance unless using aave\n        for (uint256 i; i < pathLen; i++) {\n          assertEq(\n            s.routerBalances[_args.routers[i]][_args.local],\n            _inputs.usesPortals ? prevLiquidity[i] : prevLiquidity[i] - (_inputs.routerAmt / pathLen)\n          );\n        }\n      }\n    }\n\n    {\n      // assertions\n      ExecuteBalances memory finalBalances = utils_getExecuteBalances(transferId, token, _args.params.to);\n\n      // NOTE: the balance of the bridge *should* always decrement in local, however that depends on\n      // the token executing the `swap` / `withdraw` call when a swap is needed (which we have as mocked).\n      // Instead, assert the swap functions on the pool were called correctly\n      if (!_inputs.shouldSwap && _inputs.token != address(s.wrapper)) {\n        // NOTE: when using aave would normally send you funds for the position minted,\n        // but we are not adding any funds from the pool, so always decrement\n        assertEq(finalBalances.bridge, prevBalances.bridge - _inputs.routerAmt);\n      }\n\n      if (_inputs.usesPortals) {\n        uint256 fee = (_inputs.routerAmt * _portalFeeNumerator) / _liquidityFeeDenominator;\n        assertEq(finalBalances.feeDebt, prevBalances.feeDebt + fee);\n        assertEq(finalBalances.debt, prevBalances.debt + _inputs.routerAmt);\n      } else {\n        assertEq(finalBalances.feeDebt, prevBalances.feeDebt);\n        assertEq(finalBalances.debt, prevBalances.debt);\n      }\n\n      if (_inputs.callsExternal) {\n        // should increment balance of executor\n        // should NOT increment balance of to\n        // NOTE: recovery address testing should be done in Executor.t.sol\n        // as such, executor balance should *always* increment\n        assertEq(finalBalances.executor, prevBalances.executor + _inputs.expectedAmt);\n        assertEq(token.balanceOf(_params.to), prevBalances.to);\n      } else {\n        // should have incremented balance of `to`\n        // should NOT increment balance of executor\n        assertEq(finalBalances.to, prevBalances.to + _inputs.expectedAmt);\n        assertEq(finalBalances.executor, prevBalances.executor);\n      }\n    }\n\n    // should mark the transfer as executed\n    assertEq(s.transferRelayer[transferId], sender);\n\n    // should have assigned transfer as routed\n    address[] memory savedRouters = this.routedTransfers(transferId);\n    for (uint256 i; i < savedRouters.length; i++) {\n      assertEq(savedRouters[i], _args.routers[i]);\n    }\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expectedAmt, // amount out of swap\n    bool callsExternal,\n    bool externalCallSucceeds,\n    bool shouldSwap, // Whether the `to` address should receive the tokens.\n    bool usesPortals,\n    bool useAgent\n  ) public {\n    uint256 pathLen = _args.routers.length;\n    bool isSlow = pathLen == 0;\n    // get pre-execute balance here in local\n    uint256 routerAmt = isSlow ? _args.amount : utils_getFastTransferAmount(_args.amount);\n    helpers_executeAndAssert(\n      transferId,\n      _args,\n      ExecuteTestInputs(\n        expectedAmt,\n        routerAmt,\n        shouldSwap ? _adopted : _local, // token\n        callsExternal,\n        externalCallSucceeds,\n        shouldSwap,\n        isSlow,\n        usesPortals,\n        useAgent\n      )\n    );\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expectedAmt, // amount out of swap\n    bool callsExternal,\n    bool externalCallSucceeds,\n    bool shouldSwap // Whether the `to` address should receive the tokens.\n  ) public {\n    helpers_executeAndAssert(\n      transferId,\n      _args,\n      expectedAmt,\n      callsExternal,\n      externalCallSucceeds,\n      shouldSwap,\n      false,\n      false\n    );\n  }\n\n  function buildMessage(bytes32 _id) private returns (bytes memory) {\n    bytes32 detailsHash = keccak256(\"test\");\n\n    bytes29 action = ConnextMessage.formatTransfer(bytes32(uint256(uint160(_params.to))), _amount, detailsHash, _id);\n    bytes29 tokenId = ConnextMessage.formatTokenId(_canonicalDomain, _canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  // ============ execute ============\n  // Shortcut for above method:\n  // - local == adopted\n  // - does not call external\n  // - calling on non-canonical domain\n  function helpers_executeAndAssert(bytes32 transferId, ExecuteArgs memory _args) public {\n    uint256 expected = _args.amount;\n    if (_args.routers.length > 0) {\n      expected = utils_getFastTransferAmount(_args.amount);\n    }\n    helpers_executeAndAssert(transferId, _args, expected, false, false, false, false, false);\n  }\n\n  // Shortcut where:\n  // - local != adopted\n  // - does not call external\n  // - calling on noncanonical domain\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expected,\n    bool shouldSwap\n  ) public {\n    helpers_executeAndAssert(transferId, _args, expected, false, false, shouldSwap, false, false);\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    bool useAgent\n  ) public {\n    uint256 expected = _args.amount;\n    if (_args.routers.length > 0) {\n      expected = utils_getFastTransferAmount(_args.amount);\n    }\n    helpers_executeAndAssert(transferId, _args, expected, false, false, false, false, useAgent);\n  }\n\n  function helpers_setupReconcilePortalAssertions(\n    bytes32 transferId,\n    XCallArgs memory args,\n    PortalInfo memory init,\n    PortalInfo memory repayment,\n    uint256 amountIn,\n    uint256 amountOut\n  ) public {\n    if (repayment.total == 0) {\n      // noting to assert\n      return;\n    }\n    // if local != adopted, need to swap into adopted\n    if (_local != _adopted) {\n      // should call calculate always\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapFromAddress.selector, _local, _adopted, args.amount)\n      );\n\n      // will swap and repay IFF within slippage\n      if (amountIn <= args.amount) {\n        // slippage ok, call approve\n        vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, amountIn));\n        // should call swap\n        vm.expectCall(\n          _stableSwap,\n          abi.encodeWithSelector(IStableSwap.swapExactOut.selector, repayment.total, _local, _adopted, args.amount)\n        );\n      } // otherwise slippage is too high and it should not try to repay the rest of the loan\n    }\n\n    if (amountIn > 0) {\n      // approval of pool for sum\n      vm.expectCall(_adopted, abi.encodeWithSelector(IERC20.approve.selector, _aavePool, repayment.total));\n\n      // approval of payback\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.backUnbacked.selector, _adopted, repayment.debt, repayment.fee)\n      );\n\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalRepayment(transferId, _adopted, repayment.debt, repayment.fee);\n\n      // check if there will be a debt event\n      if (repayment.total < init.total) {\n        // // FIXME: logs are the same in the corresponding event (when insufficient fees)\n        // // but `expectEmit` call is not working\n        // vm.expectEmit(true, false, false, true);\n        // emit AavePortalRepaymentDebt(transferId, _adopted, init.debt - repayment.debt, init.fee - repayment.fee);\n      }\n    } else {\n      // slippage maximums hit, emit full debt in event\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalRepaymentDebt(transferId, _adopted, init.debt, init.fee);\n    }\n  }\n\n  struct SwapInfo {\n    uint256 input;\n    uint256 output; // the equivalent amount of `out` token for given `in`\n  }\n\n  // Helper for calling `reconcile` and asserting expected behavior.\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError,\n    PortalInfo memory repayment,\n    SwapInfo memory swap\n  ) public {\n    PortalInfo memory init = PortalInfo(\n      s.portalFeeDebt[transferId],\n      s.portalDebt[transferId],\n      s.portalDebt[transferId] + s.portalFeeDebt[transferId],\n      true\n    );\n    bool isNative = args.transactingAssetId == address(0);\n    bool shouldSucceed = keccak256(abi.encode(expectedError)) == keccak256(abi.encode(bytes4(\"\")));\n\n    // Derive message from xcall arguments.\n    bytes memory message;\n    {\n      BridgeFacet.XCalledEventArgs memory eventArgs = BridgeFacet.XCalledEventArgs({\n        transactingAssetId: isNative ? address(s.wrapper) : args.transactingAssetId,\n        amount: args.amount,\n        bridgedAmt: args.amount,\n        bridged: _local\n      });\n      message = utils_formatMessage(args, _local, transferId, args.amount);\n    }\n\n    uint256[] memory routerBalances = new uint256[](s.routedTransfers[transferId].length);\n    for (uint256 i = 0; i < s.routedTransfers[transferId].length; i++) {\n      // Warming up the slot in order to make gas estimates more accurate to appropriate conditions.\n      s.routerBalances[s.routedTransfers[transferId][i]][_local] = 1 ether;\n      routerBalances[i] = 1 ether;\n    }\n\n    // Get pre-reconcile balances.\n    uint256 prevBalance;\n    if (isNative) {\n      prevBalance = payable(address(this)).balance;\n    } else {\n      prevBalance = IERC20(_local).balanceOf(address(this));\n    }\n\n    // Mock calls for swap if needed\n    if (_local != _adopted && init.total > 0) {\n      // mock calculate equivalent of bridged amount in adopted\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapFromAddress.selector),\n        abi.encode(swap.output)\n      );\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapOutFromAddress.selector),\n        abi.encode(swap.input)\n      );\n      // mock swap\n      vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExactOut.selector), abi.encode(swap.input));\n    }\n\n    if (!repayment.aaveReturns) {\n      // Force failure on call\n      _aavePool = address(new MockPool(true));\n      s.aavePool = _aavePool;\n    }\n\n    if (shouldSucceed) {\n      // check that the mint is called properly\n      if (_local != _canonical) {\n        vm.expectCall(_local, abi.encodeWithSelector(TestERC20.mint.selector, address(this), args.amount));\n      }\n\n      helpers_setupReconcilePortalAssertions(transferId, args, init, repayment, swap.input, swap.output);\n\n      vm.expectEmit(true, true, true, true);\n      emit Reconciled(transferId, _originDomain, s.routedTransfers[transferId], _local, args.amount, address(this));\n    } else {\n      vm.expectRevert(expectedError);\n    }\n\n    this.utils_wrappedReconcile(_originDomain, message);\n\n    if (shouldSucceed) {\n      assertEq(this.reconciledTransfers(transferId), true);\n      address[] memory routers = this.routedTransfers(transferId);\n      if (routers.length > 0) {\n        uint256 routerAmt;\n        if (init.total > 0 && repayment.aaveReturns) {\n          routerAmt = swap.input > args.amount ? args.amount : args.amount - swap.input;\n        } else {\n          routerAmt = args.amount / s.routedTransfers[transferId].length;\n        }\n        // Fast liquidity route. Should have reimbursed routers.\n        for (uint256 i = 0; i < routers.length; i++) {\n          assertEq(s.routerBalances[routers[i]][_local], routerBalances[i] + routerAmt);\n        }\n      }\n\n      if (init.total > 0) {\n        // assert repayment\n        assertEq(s.portalDebt[transferId], init.debt - repayment.debt);\n        assertEq(s.portalFeeDebt[transferId], init.fee - repayment.fee);\n      }\n    }\n  }\n\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError,\n    PortalInfo memory repayment\n  ) public {\n    helpers_reconcileAndAssert(transferId, args, expectedError, repayment, SwapInfo(repayment.total, args.amount));\n  }\n\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError\n  ) public {\n    helpers_reconcileAndAssert(transferId, args, expectedError, PortalInfo(0, 0, 0, true));\n  }\n\n  function helpers_reconcileAndAssert(bytes4 expectedError) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    helpers_reconcileAndAssert(transferId, args, expectedError);\n  }\n\n  // Shortcut for above method.\n  function helpers_reconcileAndAssert() public {\n    helpers_reconcileAndAssert(bytes4(\"\"));\n  }\n\n  // ============ Getters ==============\n\n  function test_BridgeFacet_domain_works() public {\n    s.domain = 0;\n    assertEq(this.domain(), 0);\n    s.domain = _destinationDomain;\n    assertEq(this.domain(), _destinationDomain);\n  }\n\n  function test_BridgeFacet_executor_works() public {\n    s.executor = IExecutor(address(0));\n    assertEq(address(this.executor()), address(0));\n    s.executor = IExecutor(_local);\n    assertEq(address(this.executor()), _local);\n  }\n\n  function test_BridgeFacet_nonce_works() public {\n    s.nonce = 0;\n    assertEq(this.nonce(), 0);\n    s.nonce = _destinationDomain;\n    assertEq(this.nonce(), _destinationDomain);\n  }\n\n  function test_BridgeFacet_sponsorVault_works() public {\n    s.sponsorVault = ISponsorVault(address(0));\n    assertEq(address(this.sponsorVault()), address(0));\n    s.sponsorVault = ISponsorVault(_local);\n    assertEq(address(this.sponsorVault()), _local);\n  }\n\n  function test_BridgeFacet_promiseRouter_works() public {\n    s.promiseRouter = PromiseRouter(payable(address(0)));\n    assertEq(address(this.promiseRouter()), address(0));\n    s.promiseRouter = PromiseRouter(payable(_local));\n    assertEq(address(this.promiseRouter()), _local);\n  }\n\n  // The rest (relayerFees, routedTransfers, reconciledTransfers) are checked on\n  // assertions for xcall / reconcile / execute\n\n  // ============ Admin methods ==============\n  // setPromiseRouter\n  // FIXME: move to BaseConnextFacet.t.sol\n  function test_BridgeFacet__setPromiseRouter_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setPromiseRouter_invalidPromiseRouter.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_failIfNotContract() public {\n    // constants\n    address old = address(123);\n    address updated = address(456);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setPromiseRouter_invalidPromiseRouter.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test success\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit PromiseRouterUpdated(old, updated, LibDiamond.contractOwner());\n    this.setPromiseRouter(payable(updated));\n    assertEq(address(this.promiseRouter()), updated);\n  }\n\n  // setExecutor\n  function test_BridgeFacet__setExecutor_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setExecutor_invalidExecutor.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_failIfNotContract() public {\n    // constants\n    address old = address(123);\n    address updated = address(456);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setExecutor_invalidExecutor.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit ExecutorUpdated(old, updated, LibDiamond.contractOwner());\n    this.setExecutor(payable(updated));\n    assertEq(address(this.executor()), updated);\n  }\n\n  // setSponsorVault\n  function test_BridgeFacet__setSponsorVault_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setSponsorVault(payable(updated));\n  }\n\n  function test_BridgeFacet__setSponsorVault_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setSponsorVault_invalidSponsorVault.selector);\n    this.setSponsorVault(payable(updated));\n  }\n\n  function test_BridgeFacet__setSponsorVault_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit SponsorVaultUpdated(old, updated, LibDiamond.contractOwner());\n    this.setSponsorVault(payable(updated));\n    assertEq(address(this.sponsorVault()), updated);\n  }\n\n  // ============ Public methods ==============\n\n  // ============ xcall ============\n\n  // ============ xcall fail cases\n  // fails if paused\n  // FIXME: move to BaseConnextFacet.t.sol\n  function test_BridgeFacet__xcall_failIfPaused() public {\n    // require(false, \"not tested\");\n  }\n\n  // fails if origin domain is incorrect\n  function test_BridgeFacet__xcall_failIfDomainIncorrect() public {\n    _params.originDomain = 999999;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_wrongDomain.selector);\n  }\n\n  // TODO: fails if destination domain does not have an xapp router registered\n  // FIXME: this should be tested at the integration level (i.e. when we deploy\n  // the contracts via Deployer.sol), or on a facet that asserts this\n\n  // fails if recipient `to` not a valid address (i.e. != address(0))\n  function test_BridgeFacet__xcall_failIfNoRecipient() public {\n    _params.to = address(0);\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_emptyTo.selector);\n  }\n\n  // fails if callback fee > 0 but callback address is not defined\n  function test_BridgeFacet__xcall_failIfCallbackFeeButNoContract() public {\n    _params.callback = address(0);\n    _params.callbackFee = 0.001 ether;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_nonZeroCallbackFeeForCallback.selector);\n  }\n\n  // fails if callback is defined but not a contract\n  function test_BridgeFacet__xcall_failIfCallbackNotAContract() public {\n    _params.callback = address(42);\n    _params.callbackFee = 0.001 ether;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_callbackNotAContract.selector);\n  }\n\n  // fails if asset is not supported (i.e. s.adoptedToCanonical[transactingAssetId].id == bytes32(0) and using non-local)\n  function test_BridgeFacet__xcall_failIfAssetNotSupported() public {\n    // setup asset with local != adopted, not on canonical domain\n    utils_setupAsset(false, false);\n\n    s.adoptedToCanonical[_adopted] = ConnextMessage.TokenId(0, bytes32(0));\n\n    // ensure token registry returns true for local origin\n    vm.mockCall(\n      address(s.tokenRegistry),\n      abi.encodeWithSelector(ITokenRegistry.isLocalOrigin.selector, _adopted),\n      abi.encode(true)\n    );\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_notSupportedAsset.selector);\n  }\n\n  // fails if native asset wrapper is not supported (i.e. s.adoptedToCanonical[transactingAssetId].id == bytes32(0))\n  function test_BridgeFacet__xcall_failIfNativeAssetWrapperNotSupported() public {\n    utils_setupNative(true, true);\n    s.adoptedToCanonical[address(s.wrapper)] = ConnextMessage.TokenId(0, bytes32(0));\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_notSupportedAsset.selector);\n  }\n\n  // fails if native token transfer and amount of native tokens sent is < amount + relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failNativeAssetCallbackFeeInsufficient() public {\n    vm.deal(_originSender, 100 ether);\n    utils_setupNative(true, true);\n    _params.callback = _callback;\n    _params.callbackFee = 0.01 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_notAmount.selector);\n    vm.prank(_originSender);\n    // Sending only the amount + relayer fee; callbackFee is not covered!\n    this.xcall{value: args.params.relayerFee + args.amount}(args);\n  }\n\n  // fails if erc20 transfer and eth sent < relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failEthWithErc20TransferInsufficient() public {\n    utils_setupAsset(true, false);\n    vm.deal(_originSender, 100 ether);\n    _relayerFee = 0.1 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_ethWithErcTransfer.selector);\n    vm.prank(_originSender);\n    // Sending insufficent eth to cover relayer fee.\n    this.xcall{value: 0.08 ether}(args);\n  }\n\n  // fails if erc20 transfer and eth sent > relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failEthWithErc20TransferUnnecessary() public {\n    vm.deal(_originSender, 100 ether);\n    _relayerFee = 0.1 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_ethWithErcTransfer.selector);\n    vm.prank(_originSender);\n    // Sending too much eth.\n    this.xcall{value: 1 ether}(args);\n  }\n\n  // fails if user has insufficient tokens\n  function test_BridgeFacet__xcall_failInsufficientErc20Tokens() public {\n    _amount = 10.1 ether;\n    TestERC20 localToken = TestERC20(_local);\n    localToken.mint(_originSender, 10 ether);\n    vm.prank(_originSender);\n    localToken.approve(address(this), 10.1 ether);\n\n    vm.deal(_originSender, 100 ether);\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(\"ERC20: transfer amount exceeds balance\");\n    vm.prank(_originSender);\n    this.xcall{value: args.params.relayerFee}(args);\n  }\n\n  // fails if user has not set enough allowance\n  function test_BridgeFacet__xcall_failInsufficientErc20Approval() public {\n    _amount = 10.1 ether;\n    TestERC20 localToken = TestERC20(_local);\n    localToken.mint(_originSender, 10.1 ether);\n    vm.prank(_originSender);\n    localToken.approve(address(this), 10 ether);\n\n    vm.deal(_originSender, 100 ether);\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(\"ERC20: transfer amount exceeds allowance\");\n    vm.prank(_originSender);\n    this.xcall{value: args.params.relayerFee}(args);\n  }\n\n  // ============ xcall success cases\n  // asset cases:\n  // - works on remote domain\n  //   - transferring native (local == adopted)\n  //   - transferring native (local != adopted)\n  //   - transferring asset (local == adopted)\n  //   - transferring asset (local != adopted)\n\n  // - works on cannonical domain\n  //   - transferring native (local == adopted)\n  //   - transferring asset (local == adopted)\n  // canonincal token transfer on canonical domain\n  function test_BridgeFacet__xcall_canonicalTokenTransferWorks() public {\n    utils_setupAsset(true, true);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // local token transfer on non-canonical domain (local != adopted)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWithAdopted() public {\n    uint256 bridged = (_amount * 9995) / _liquidityFeeDenominator;\n    utils_setupAsset(false, false);\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // local token transfer on non-canonical domain, local != adopted, send in local\n  // (i.e. i should be able to xcall with madEth on optimism)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWhenNotAdopted() public {\n    // local is not adopted, not on canonical domain, sending in local\n    utils_setupAsset(false, false);\n    s.adoptedToCanonical[_local] = ConnextMessage.TokenId(0, bytes32(0));\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    vm.mockCall(\n      _tokenRegistry,\n      abi.encodeWithSelector(ITokenRegistry.isLocalOrigin.selector, _local),\n      abi.encode(false)\n    );\n    args.transactingAssetId = _local;\n    helpers_xcallAndAssert(transferId, args, args.amount, args.amount, bytes4(\"\"), false);\n  }\n\n  // local token transfer on non-canonical domain (local == adopted)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWithoutAdopted() public {\n    utils_setupAsset(true, false);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // native asset transfer on canonical domain\n  function test_BridgeFacet__xcall_nativeTransferWorksOnCanonical() public {\n    utils_setupNative(true, true);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // native asset transfer on non-canonical domain with local == adopted\n  // i.e. get ETH on arbitrum from cronos\n  // adopted = address(madETH cronos)\n  // local = address(madETH on cronos)\n  // canonical = address(mainnet wrapper)\n  function test_BridgeFacet__xcall_nativeTransferWorksOnRemote() public {\n    utils_setupNative(true, false);\n    helpers_xcallAndAssert(_amount, _local, false);\n  }\n\n  // native asset transfer on non-canonical domain with local != adopted\n  // i.e. native arbitrum eth transfer to matic weth\n  // adopted = address(arbitrum wrapper)\n  // canonical = address(eth wrapper)\n  // local = address(madETH on arbitrum)\n  function test_BridgeFacet__xcall_nativeTransferWorksOnRemoteWithAdopted() public {\n    utils_setupNative(false, false);\n    helpers_xcallAndAssert(_amount, address(0), true);\n  }\n\n  // adopted asset transfer\n  function test_BridgeFacet__xcall_adoptedTransferWorks() public {\n    utils_setupAsset(false, false);\n    uint256 bridged = (_amount * 9995) / _liquidityFeeDenominator;\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // FIXME: should work with fee on transfer tokens\n  function test_BridgeFacet__xcall_feeOnTransferWorks() public {\n    // require(false, \"not tested\");\n  }\n\n  // should work with positive slippage\n  function test_BridgeFacet__xcall_worksWithPositiveSlippage() public {\n    utils_setupAsset(false, false);\n    uint256 bridged = (_amount * 10005) / _liquidityFeeDenominator;\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // should work with 0 value\n  function test_BridgeFacet__xcall_worksWithoutValue() public {\n    _amount = 0;\n    helpers_xcallAndAssert(0, true);\n  }\n\n  // should send promise router callback fee\n  function test_BridgeFacet__xcall_shouldHandleCallbackFee() public {\n    _params.callback = _callback;\n    _params.callbackFee = 0.02 ether;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // works if relayer fee is set to 0\n  function test_BridgeFacet__xcall_zeroRelayerFeeWorks() public {\n    _relayerFee = 0;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // works with callback fee set to 0\n  function test_BridgeFacet__xcall_zeroCallbackFeesWorks() public {\n    _params.callbackFee = 0;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // FIXME: move to BaseConnextFacet.t.sol\n  // works if swap isnt required and swaps are paused\n  function test_BridgeFacet__xcall_worksIfNoSwapAndSwapPaused() public {\n    // require(false, \"not tested\");\n  }\n\n  // =========== handle / reconcile ==========\n  // NOTE: modifier tests happen in BaseConnext.t.sol. Below are the reconcile (internal fn)\n  // unit tests\n\n  // ============ reconcile fail cases\n\n  // should not process invalid messages\n  function test_BridgeFacet__reconcile_invalidMessage() public {\n    bytes memory _message = bytes(\"\");\n    vm.expectRevert(bytes(\"Validity assertion failed\"));\n    _reconcile(_originDomain, _message);\n  }\n\n  // fails if action is not transfer\n  function test_BridgeFacet__reconcile_invalidTransfer() public {\n    bytes29 tokenId = ConnextMessage.formatTokenId(_canonicalDomain, _canonicalId);\n    bytes29 action = abi\n      .encodePacked(ConnextMessage.Types.Message, bytes32(\"recip\"), uint256(100), bytes32(\"details\"), bytes32(\"id\"))\n      .ref(0)\n      .castTo(uint40(ConnextMessage.Types.Message));\n    bytes29[] memory _views = new bytes29[](2);\n    _views[0] = tokenId;\n    _views[1] = action;\n    bytes memory _message = TypedMemView.join(_views);\n    vm.expectRevert(BridgeFacet.BridgeFacet__reconcile_invalidAction.selector);\n    _reconcile(_originDomain, _message);\n  }\n\n  // fails if already reconciled (s.reconciledTransfers[transferId] = true)\n  function test_BridgeFacet__reconcile_failIfAlreadyReconciled() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.reconciledTransfers[transferId] = true;\n    helpers_reconcileAndAssert(transferId, args, BridgeFacet.BridgeFacet__reconcile_alreadyReconciled.selector);\n  }\n\n  // fails if portal record, but used in slow mode\n  function test_BridgeFacet__reconcile_failsIfPortalAndNoRouter() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    delete s.routedTransfers[transferId];\n\n    // set portal fee debt\n    s.portalDebt[transferId] = 15;\n    s.portalFeeDebt[transferId] = 10;\n\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      BridgeFacet.BridgeFacet__reconcile_noPortalRouter.selector,\n      PortalInfo(10, 15, 25, true)\n    );\n  }\n\n  // ============ reconcile success cases\n  // works with local representational tokens (remote origin, so they will be minted)\n  function test_BridgeFacet__reconcile_worksWithLocal() public {\n    utils_setupAsset(true, false);\n    helpers_reconcileAndAssert();\n  }\n\n  function test_BridgeFacet__reconcile_worksWithCanonical() public {\n    utils_setupAsset(true, true);\n    helpers_reconcileAndAssert();\n  }\n\n  // funds contract when pre-execute (slow liquidity route)\n  function test_BridgeFacet__reconcile_worksPreExecute() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    delete s.routedTransfers[transferId];\n\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // funds router when post-execute (fast liquidity route)\n  function test_BridgeFacet__reconcile_fastLiquiditySingleRouterWorks() public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.routedTransfers[transferId] = [address(42)];\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // funds routers when post-execute multipath (fast liquidity route)\n  function test_BridgeFacet__reconcile_fastLiquidityMultipathWorks() public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.routedTransfers[transferId] = [address(42), address(43), address(44), address(45)];\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // should work with portals without swap\n  function test_BridgeFacet__reconcile_canUsePortalsWithoutSwap() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // should work with portals with swap\n  function test_BridgeFacet__reconcile_canUsePortalsWithSwap() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals, SwapInfo(args.amount - 10000, args.amount));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalSwapFailures() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // assume ratio of 10:1 (i.e. you put in 10x, the amount out from args.amount is 1/10 val)\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      bytes4(\"\"),\n      PortalInfo(0, 0, 0, true),\n      SwapInfo(args.amount * 10, args.amount * 10)\n    );\n  }\n\n  // should credit router leftovers from portal repayment from positive slippage of amm\n  // or previous\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaSwap() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      bytes4(\"\"),\n      portals,\n      SwapInfo(args.amount - 0.01 ether, args.amount + 0.2 ether)\n    );\n  }\n\n  // at some point some of the fee is repaid, remainder goes to router liq\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaFeeRepayment() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    uint256 fullFee = (args.amount * _portalFeeNumerator) / _liquidityFeeDenominator;\n    uint256 paid = fullFee / 2;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled, fullFee - paid);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // at some point some of the principle is repaid, remainder goes to router liq\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaPrincipleRepayment() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    uint256 fee = (args.amount * _portalFeeNumerator) / _liquidityFeeDenominator;\n    uint256 paid = portaled / 2;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled - paid, fee);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // should prioritize debt as: as much principle as possible then as much fee as possible\n  function test_BridgeFacet__reconcile_handlesPortalDeficitPartialPrinciple() public {\n    // in this case, the swap only gives enough out to handle *some* of the amount portaled.\n    // specifically, it can only handle amount < principle\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // set the total debt\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // decrement portal repayment\n    uint256 debtRepaid = (init.debt * 9997) / 10000; // 3bps debt remaining\n    PortalInfo memory repayment = PortalInfo(0, debtRepaid, debtRepaid, true);\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), repayment, SwapInfo(init.total, debtRepaid));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalDeficitPartialFee() public {\n    // in this case, the swap only gives enough out to handle *some* of the amount portaled.\n    // specifically, it can only handle principle < amount < total\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // set the total debt\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    uint256 debtRepaid = (init.total * 9997) / 10000; // 3bps debt remaining\n    PortalInfo memory repayment = PortalInfo(debtRepaid - init.debt, init.debt, debtRepaid, true);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), repayment, SwapInfo(init.total, debtRepaid));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalFailureToRepayFromAave() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // assume no repayment (aave will not be mocked)\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), PortalInfo(0, 0, 0, false));\n  }\n\n  // ============ execute ============\n  // ============ execute fail cases\n\n  // FIXME: move to `BaseConnextFacet.t.sol`\n  // should fail if paused\n  function test_BridgeFacet__execute_failIfPaused() public {\n    // set context\n    s._paused = true;\n\n    // get args\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // expect failure\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__whenNotPaused_paused.selector);\n    this.execute(args);\n  }\n\n  // should fail if msg.sender is not an approved relayer && msg.sender != params.agent\n  function test_BridgeFacet__execute_failIfSenderNotApproved() public {\n    // set context\n    s.approvedRelayers[address(this)] = false;\n\n    // get args\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // expect failure\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_unapprovedSender.selector);\n    this.execute(args);\n  }\n\n  // multipath: should fail if pathLength > maxRouters\n  function test_BridgeFacet__execute_failIfPathLengthGreaterThanMaxRouters() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(s.maxRoutersPerTransfer + 1);\n\n    for (uint256 i; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] += 10 ether;\n    }\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_maxRoutersExceeded.selector);\n    this.execute(args);\n  }\n\n  // should fail if it is a slow transfer (forceSlow = true) and not reconciled\n  function test_BridgeFacet__execute_failIfForceSlowAndNotReconciled() public {\n    _params.forceSlow = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if it is a slow transfer (forceSlow = true) and we try to execute with routers\n  function test_BridgeFacet__execute_failIfForceSlowAndRoutersSet() public {\n    _params.forceSlow = true;\n\n    // Routers providing liquidity implies this is a fast-liquidity transfer. If we're forcing slow,\n    // this should fail.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(2);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if no routers were passed in and not reconciled\n  function test_BridgeFacet__execute_failIfNoRoutersAndNotReconciled() public {\n    // Setting no routers in the execute call means that the transfer must already be reconciled.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router is not approved and ownership is not renounced\n  function test_BridgeFacet__execute_failIfRouterNotApproved() public {\n    s._routerOwnershipRenounced = false;\n\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = false;\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notSupportedRouter.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router signature is invalid\n  function test_BridgeFacet__execute_failIfSignatureInvalid() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // Make invalid args based on (slightly) altered params.\n    _params.originDomain = 1001;\n    (, ExecuteArgs memory invalidArgs) = utils_makeExecuteArgs(4);\n    // The signature of the last router in the group will be invalid.\n    args.routerSignatures[0] = invalidArgs.routerSignatures[0];\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_invalidRouterSignature.selector);\n    this.execute(args);\n  }\n\n  // multipath: should fail if any 1 router's signature is invalid\n  function test_BridgeFacet__execute_failIfAnySignatureInvalid() public {\n    // Using multipath; this should fail if any 1 router signature is invalid.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(4);\n\n    for (uint256 i; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] += 10 ether;\n    }\n\n    // Make invalid args based on (slightly) altered params.\n    _params.originDomain = 1001;\n    (, ExecuteArgs memory invalidArgs) = utils_makeExecuteArgs(4);\n    // The signature of the last router in the group will be invalid.\n    args.routerSignatures[3] = invalidArgs.routerSignatures[3];\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_invalidRouterSignature.selector);\n    this.execute(args);\n  }\n\n  // should fail if it was already executed (s.transferRelayer[transferId] != address(0))\n  function test_BridgeFacet__execute_failIfAlreadyExecuted() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.transferRelayer[transferId] = address(this);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_alreadyExecuted.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router does not have sufficient tokens\n  function test_BridgeFacet__execute_failIfRouterHasInsufficientFunds() public {\n    _amount = 5 ether;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(2);\n\n    s.routerBalances[args.routers[0]][args.local] = 1.5 ether;\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(args);\n  }\n\n  // multipath: should fail if any 1 router has insufficient tokens\n  function test_BridgeFacet__execute_failIfAnyRouterHasInsufficientFunds() public {\n    _amount = 5 ether;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(s.maxRoutersPerTransfer);\n\n    uint256 routerAmountSent = _amount / args.routers.length; // The amount each individual router will send.\n\n    // Set the first router's balance to be (slightly) less than the amount that they'd need to send.\n    s.routerBalances[args.routers[0]][args.local] = routerAmountSent - 0.1 ether;\n    for (uint256 i = 1; i < args.routers.length; i++) {\n      // The other routers have plenty of funds.\n      s.routerBalances[args.routers[i]][args.local] = 50 ether;\n    }\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(args);\n  }\n\n  // should fail if sponsored vault did not fund contract with returned amount\n  function test_BridgeFacet__execute_failIfSponsorVaultLied() public {\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n    for (uint256 i = 0; i < args.routers.length; i++) {\n      // The other routers have plenty of funds.\n      s.routerBalances[args.routers[i]][args.local] = 50 ether;\n    }\n\n    // set mock sponsor vault\n    address vault = address(123456654321);\n    s.sponsorVault = ISponsorVault(vault);\n    // set change\n    vm.mockCall(vault, abi.encodeWithSelector(ISponsorVault.reimburseLiquidityFees.selector), abi.encode(10 ether));\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount.selector);\n    this.execute(args);\n  }\n\n  function test_BridgeFacet__execute_failsIfRouterNotApprovedForPortal() public {\n    _amount = 5 ether;\n\n    (bytes32 _id, ExecuteArgs memory _args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[_args.routers[0]][_args.local] = 4.5 ether;\n\n    // set aave enabled\n    s.aavePool = _aavePool;\n\n    vm.expectRevert(abi.encodeWithSelector(BridgeFacet.BridgeFacet__execute_notApprovedForPortals.selector));\n    this.execute(_args);\n  }\n\n  // ============ execute success cases\n  // should use slow liquidity if specified (forceSlow = true)\n  function test_BridgeFacet__execute_forceSlowWorks() public {\n    // set test params\n    _params.forceSlow = true;\n\n    // get args\n    (bytes32 transferId, ExecuteArgs memory _args) = utils_makeExecuteArgs(0);\n\n    // set reconciled context\n    s.reconciledTransfers[transferId] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, _args);\n  }\n\n  // should use the local asset if specified (receiveLocal = true)\n  function test_BridgeFacet__execute_receiveLocalWorks() public {\n    _params.receiveLocal = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), false);\n  }\n\n  // should work with approved router if router ownership is not renounced\n  function test_BridgeFacet__execute_worksWithLocalAsAdopted() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // works when local != adopted\n  function test_BridgeFacet__execute_worksWithAdopted() public {\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), true);\n  }\n\n  // works when local != adopted, should work with +ve slippage\n  function test_BridgeFacet__execute_worksWithPositiveSlippage() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) + 1 ether, true);\n  }\n\n  // works when local != adopted, should work with -ve slippage\n  function test_BridgeFacet__execute_worksWithNegativeSlippage() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) - 0.01 ether, true);\n  }\n\n  // works when on canonical domain\n  function test_BridgeFacet__execute_worksOnCanonical() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, true);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work when adopted asset is native asset and on canonical\n  // (adopted == wrapper)\n  function test_BridgeFacet__execute_worksWithNativeOnCanonical() public {\n    // set asset context (local == adopted)\n    utils_setupNative(true, true);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work when adopted asset is native asset and on remote\n  // (adopted == wrapper)\n  function test_BridgeFacet__execute_worksWithNativeOnRemote() public {\n    // set asset context (local != adopted)\n    utils_setupNative(false, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), true);\n  }\n\n  // should work with unapproved router if router ownership is renounced\n  function test_BridgeFacet__execute_worksWithUnapprovedIfNoWhitelist() public {\n    s._routerOwnershipRenounced = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = false;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with 0 value\n  function test_BridgeFacet__execute_worksWith0Value() public {\n    _amount = 0;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work if no sponsor vault set\n  function test_BridgeFacet__execute_worksWithoutVault() public {\n    s.sponsorVault = ISponsorVault(address(0));\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should sponsor if fast liquidity is used and sponsor vault set\n  function test_BridgeFacet__execute_worksWithSponsorLiquidity() public {\n    // setup vault\n    uint256 vaultAmount = 10000;\n    MockSponsorVault vault = new MockSponsorVault(vaultAmount);\n    s.sponsorVault = vault;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) + vaultAmount, false);\n  }\n\n  // should sponsor relayer fee in slow liquidity\n  function test_BridgeFacet__execute_sponsorsRelayersSlow() public {\n    // set test vault\n    uint256 vaultAmount = 10000;\n    MockSponsorVault vault = new MockSponsorVault(vaultAmount);\n    s.sponsorVault = vault;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // get args\n    (bytes32 transferId, ExecuteArgs memory _args) = utils_makeExecuteArgs(0);\n\n    // set reconciled context\n    s.reconciledTransfers[transferId] = true;\n\n    helpers_executeAndAssert(transferId, _args);\n  }\n\n  // should work without calldata\n  function test_BridgeFacet__execute_noCalldataWorks() public {\n    _params.callData = bytes(\"\");\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // With no calldata set, this method call should just send funds directly to the user.\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with successful calldata and using fast liquidity\n  function test_BridgeFacet__execute_successfulCalldata() public {\n    // Set the args.to to the mock xapp address, and args.callData to the `fulfill` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // should work with failing calldata : contract call failed\n  function test_BridgeFacet__execute_failingCalldata() public {\n    // Set the args.to to the mock xapp address, and args.callData to the `fail` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fail.selector);\n    _params.to = _xapp;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      false,\n      false,\n      false,\n      false\n    );\n  }\n\n  function test_BridgeFacet__execute_failsIfNoLiquidityAndAaveNotEnabled() public {\n    // get args\n    (bytes32 _id, ExecuteArgs memory _args) = utils_makeExecuteArgs(1);\n\n    // set liquidity context\n    for (uint256 i; i < _args.routers.length; i++) {\n      s.routerBalances[_args.routers[i]][_args.local] = 0 ether;\n    }\n\n    // set aave not enabled\n    s.aavePool = address(0);\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(_args);\n  }\n\n  // should work with a callback\n  function test_BridgeFacet__execute_worksWithCallback() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    _params.callback = address(123456654321);\n    // Set the args.to to the mock xapp address, and args.callData to the `fulfill` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // FIXME: move to Executor.t.sol\n  // should work with failing calldata : recipient `to` is not a contract (should call _handleFailure)\n  function test_BridgeFacet__execute_handleRecipientNotAContract() public {\n    // Setting the calldata to be for fulfill... but obviously, that method should never be called.\n    // Because `to` is not a valid contract address.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n    _params.to = address(42);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // should work if already reconciled (happening in slow liquidity mode, uses\n  // authenticated data)\n  function test_BridgeFacet__execute_handleAlreadyReconciled() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // Set the args.to to the mock xapp address, and args.callData to the\n    // `fulfillWithProperties` fn. This will check to make sure `originDomain` and\n    // `originSender` properties are correctly set.\n    _params.callData = abi.encodeWithSelector(\n      MockXApp.fulfillWithProperties.selector,\n      _local,\n      TEST_MESSAGE,\n      _originDomain,\n      _originSender\n    );\n    _params.to = _xapp;\n\n    // We specify that 0 routers are in the path for this execution.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    // Transfer has already been reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    helpers_executeAndAssert(transferId, args, args.amount, true, true, false, false, false);\n  }\n\n  // multipath: should subtract equally from each router's liquidity\n  function test_BridgeFacet__execute_multipath() public {\n    _amount = 1 ether;\n\n    // Should work if the pathLength == max routers.\n    uint256 pathLength = s.maxRoutersPerTransfer;\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(pathLength);\n\n    // Add initial liquiidty\n    for (uint256 i = 1; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] = 10 ether;\n    }\n    // Sanity check: assuming the multipath is > 1, no router should need to have more than half of the\n    // transfer amount.\n    s.routerBalances[args.routers[0]][args.local] = 0.5 ether;\n\n    uint256 amount = utils_getFastTransferAmount(args.amount);\n    uint256 routerAmountSent = amount / pathLength; // The amount each individual router will send.\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with approved router if router ownership is not renounced\n  function test_BridgeFacet__execute_worksWithAgentAsSender() public {\n    address agent = address(12345654321);\n    _params.agent = agent;\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    s.approvedRelayers[address(this)] = false;\n    helpers_executeAndAssert(transferId, args, true);\n  }\n\n  // can use liquidity from portals\n  function test_BridgeFacet__execute_worksWithAave() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // set liquidity\n    s.routerBalances[args.routers[0]][args.local] = 0;\n\n    // set approval\n    s.routerPermissionInfo.approvedForPortalRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      false,\n      true,\n      false,\n      true,\n      false\n    );\n  }\n\n  // ============ bumpTransfer ============\n  // ============ bumpTransfer fail cases\n\n  // should work with unapproved router if router-whitelist ownership renouncedcanonicalId\n}\n\n\n",
        "CodeNames": [
            "BridgeFacet.sol",
            "BridgeFacet.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BridgeFacet._executeSanityChecks function",
                "Type": "Liquidity drain",
                "Description": "A malicious relayer could rearrange the _args.routers[] array to cause a certain router to drain more liquidity than it should be and overwrite the sequencer decision. This is possible because the routerHash used to generate the router signature only consists of two items (transferId and pathLength).",
                "Repair": "Generate the routerHash with the following items should help to prevent this attack: transferId, pathLength, _args.routers[] array. If the attacker attempts to re-arrange the _args.routers[] array, the routerHash generate on the bridge will be different. Thus, it will fail the router signature verification within _executeSanityChecks function and it will revert."
            },
            {
                "Location": "BridgeFacet.execute function",
                "Type": "Loss of funds",
                "Description": "Relayer will not receive any fee if execute reverts.",
                "Repair": "Update the implementation of the BridgeFacet.execute so that it will fail gracefully and not revert when the swap fails or other functions fails. Relayers should be entitled to relayer fee regardless of the outcome of the BridgeFacet.execute call for their effort."
            },
            {
                "Location": "BridgeFacet.execute function",
                "Type": "Malicious relayer could favor their routers",
                "Description": "A malicious relayer could always swap the router(s) within the execute calldata with the router(s) owned by malicious relayer, and submit it to the chain for execution. This could cause the original router chosen by the sequencer to lose the opportunity to earn the liquidity fee, disrupting the balance and fairness of the protocol.",
                "Repair": "Two possible methods: 1) Verify the execute calldata received from the relayer is valid and has not been altered by signing the execute calldata with the sequencer's private key and attaching the signature to the execute calldata. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. 2) Embed the selected router(s) within the slow nomad message and use both transfer ID + selected router as the array index within the BridgeFacet.execute function."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport \"../../../../contracts/core/connext/libraries/AssetLogic.sol\";\nimport \"../../../../contracts/core/connext/libraries/SwapUtils.sol\";\nimport {IWrapped} from \"../../../../contracts/core/connext/interfaces/IWrapped.sol\";\nimport {BaseConnextFacet} from \"../../../../contracts/core/connext/facets/BaseConnextFacet.sol\";\nimport {ConnextMessage} from \"../../../../contracts/core/connext/libraries/ConnextMessage.sol\";\nimport {LibConnextStorage, AppStorage} from \"../../../../contracts/core/connext/libraries/LibConnextStorage.sol\";\nimport {ITokenRegistry} from \"../../../../contracts/core/connext/interfaces/ITokenRegistry.sol\";\n\nimport \"../facets/FacetHelper.sol\";\n\n\n\n// Helper to call library with native value functions\ncontract LibCaller {\n  constructor(address _wrapper) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n    s.wrapper = IWrapped(_wrapper);\n  }\n\n  function handleIncomingAsset(\n    address _assetId,\n    uint256 _assetAmount,\n    uint256 _fee\n  ) public payable {\n    AssetLogic.handleIncomingAsset(_assetId, _assetAmount, _fee);\n  }\n\n  function deposit(IWrapped wrapper) public payable {\n    wrapper.deposit{ value: msg.value }();\n  }\n\n  function transferAssetToContract(address _assetId, uint256 _amount) public {\n    AssetLogic.transferAssetToContract(_assetId, _amount);\n  }\n}\n\ncontract AssetLogicTest is BaseConnextFacet, FacetHelper {\n  // ============ Storage ============\n  LibCaller caller;\n\n  // ============ Setup ============\n  function setUp() public {\n    // set defaults\n    utils_setFees();\n    utils_deployAssetContracts();\n    // set up assets (including remote swap)\n    utils_setupAsset(false, false);\n    // // set stable swap\n    // utils_setMockStableSwap();\n    caller = new LibCaller(_wrapper);\n  }\n\n  // ============ utils ============\n\n  function utils_setMockStableSwap() internal {\n    IERC20[] memory _pooledTokens = new IERC20[](2);\n    _pooledTokens[0] = IERC20(_adopted);\n    _pooledTokens[1] = IERC20(address(22));\n    uint256[] memory _tokenPrecisionMultipliers = new uint256[](2);\n    _tokenPrecisionMultipliers[0] = 1;\n    _tokenPrecisionMultipliers[1] = 1;\n    uint256[] memory  _balances = new uint256[](2);\n    _balances[0] = 100;\n    _balances[1] = 100;\n    SwapUtils.Swap memory swap = SwapUtils.Swap({\n        initialA : 0,\n        futureA : 0,\n        initialATime: 0,\n        futureATime: 0,\n        // fee calculations\n        swapFee : 0,\n        adminFee : 0,\n        lpToken: LPToken(address(100)),\n        // contract references for all tokens being pooled\n        pooledTokens: _pooledTokens,\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n        tokenPrecisionMultipliers: _tokenPrecisionMultipliers,\n        // the pool balance of each token, in the token's precision\n        // the contract's actual token balance might differ\n        balances: _balances,\n        adminFees:  new uint256[](2)\n    });\n\n    s.swapStorages[_canonicalId] = swap;\n    s.tokenIndexes[_canonicalId][_adopted] = 0;\n    \n  }\n\n  // transfers specified asset to contract\n  function utils_handleIncomingAssetAndAssert(address assetId, uint256 amount, uint256 fee) public {\n    bool isNative = assetId == address(0);\n\n    // get initial balances\n    uint256 initDestAssetBalance = IERC20(isNative ? _wrapper : assetId).balanceOf(address(caller));\n    uint256 initDestFeeBalance = address(caller).balance;\n\n    uint256 initSrcAssetBalance = isNative ? address(this).balance : IERC20(assetId).balanceOf(address(this));\n    uint256 initSrcFeeBalance = address(this).balance;\n\n    // approve\n    if (!isNative) {\n      IERC20(assetId).approve(address(caller), amount);\n    }\n\n    caller.handleIncomingAsset{ value: isNative ? amount + fee : fee }(assetId, amount, fee);\n\n    // caller balance always goes up in token (wrapper if native)\n    assertEq(IERC20(isNative ? _wrapper : assetId).balanceOf(address(caller)), initDestAssetBalance + amount);\n    // fees on caller\n    assertEq(address(caller).balance, initDestFeeBalance + fee);\n    if (isNative) {\n      // balance deducted from source in native for both\n      assertEq(address(this).balance, initSrcAssetBalance - fee - amount);\n    } else {\n      assertEq(IERC20(assetId).balanceOf(address(this)), initSrcAssetBalance - amount);\n      assertEq(address(this).balance, initSrcFeeBalance - fee);\n    }\n  }\n\n  // transfers specified asset from contract\n  function utils_transferFromContractAndAssert(address assetId, address to, uint256 amount) public {\n    bool isNative = assetId == _wrapper;\n    // fund caller\n    if (isNative) {\n      IWrapped(_wrapper).deposit{ value: 10 ether}();\n    } else {\n      TestERC20(assetId).mint(address(this), 10 ether);\n    }\n\n    // set expects\n    if (amount > 0) {\n      if (isNative) {\n        // Should withdraw\n        vm.expectCall(_wrapper, abi.encodeWithSelector(IWrapped.withdraw.selector, amount));\n      } else {\n        // Should transfer funds to user\n        vm.expectCall(assetId, abi.encodeWithSelector(IERC20.transfer.selector, to, amount));\n      }\n    } // otherwise, no calls should be made\n\n    // get initial balances\n    uint256 initContract = IERC20(assetId).balanceOf(address(this));\n    uint256 initTarget = isNative ? to.balance : IERC20(assetId).balanceOf(to);\n\n    // call\n    AssetLogic.transferAssetFromContract(assetId, to, amount);\n\n    // assert balance changes on contract + target\n    uint256 finalTarget = isNative ? to.balance : IERC20(assetId).balanceOf(to);\n    assertEq(IERC20(assetId).balanceOf(address(this)), initContract - amount);\n    assertEq(finalTarget, initTarget + amount);\n  }\n\n  // Sets up env to swap from local -> adopted using external pools only\n  function utils_swapFromLocalAndAssertViaExternal(address asset, uint256 amount, uint256 swapOut) internal {\n    // set mock\n    vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExact.selector), abi.encode(swapOut));\n\n    bool willSwap = asset == _local && amount > 0;\n    if (willSwap) {\n      // expect pool approval\n      vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, amount));\n      // expect swap\n      vm.expectCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExact.selector, amount, _local, _adopted));\n    }\n\n    (uint256 received, address out) = AssetLogic.swapFromLocalAssetIfNeeded(asset, amount, _liquidityFeeDenominator);\n    // assert return amount\n    assertEq(received, willSwap ? swapOut : amount);\n    // assert return asset\n    assertEq(out, _adopted);\n  }\n\n  // Sets up env to swap from local -> adopted using external pools only\n  function utils_swapToLocalAndAssertViaExternal(address asset, uint256 amount, uint256 swapOut) internal {\n    // set mock\n    vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExact.selector), abi.encode(swapOut));\n\n    bool willSwap = asset == _adopted && amount > 0;\n    if (willSwap) {\n      // expect pool approval\n      vm.expectCall(_adopted, abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, amount));\n      // expect swap\n      vm.expectCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExact.selector, amount, _adopted, _local));\n    }\n\n    (uint256 received, address out) = AssetLogic.swapToLocalAssetIfNeeded(ConnextMessage.TokenId(_canonicalDomain, _canonicalId), asset, amount, _liquidityFeeDenominator);\n    // assert return amount\n    assertEq(received, willSwap ? swapOut : amount);\n    // assert return asset\n    assertEq(out, _local);\n  }\n\n  // ============ stableSwapPoolExist ============\n  function test_AssetLogic_stableSwapPoolExist_works() public {\n    utils_setMockStableSwap();\n    assertEq(AssetLogic.stableSwapPoolExist(_canonicalId), true);\n    assertEq(AssetLogic.stableSwapPoolExist(bytes32(abi.encodePacked(address(5)))), false);\n  }\n\n  // ============ getTokenIndexFromStableSwapPool ============\n  function test_AssetLogic_getTokenIndexFromStableSwapPool_failsIfNotFound() public {\n    utils_setMockStableSwap();\n    address arbitrary = address(555555555555);\n    vm.expectRevert(AssetLogic.AssetLogic__getTokenIndexFromStableSwapPool_notExist.selector);\n    AssetLogic.getTokenIndexFromStableSwapPool(_canonicalId, arbitrary);\n  }\n\n  function test_AssetLogic_getTokenIndexFromStableSwapPool_works() public {\n    utils_setMockStableSwap();\n    assertEq(AssetLogic.getTokenIndexFromStableSwapPool(_canonicalId, _adopted), 0);\n  }\n\n  // ============ handleIncomingAsset ============\n  function test_AssetLogic_handleIncomingAsset_failsIfValueBadWhenNative() public {\n    address assetId = address(0);\n    uint256 amount = 10;\n    uint256 fee = 1;\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_notAmount.selector);\n    caller.handleIncomingAsset(assetId, amount, fee);\n  }\n\n  function test_AssetLogic_handleIncomingAsset_failsIfValueBad() public {\n    address assetId = address(1);\n    uint256 amount = 10;\n    uint256 fee = 1;\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_ethWithErcTransfer.selector);\n    caller.handleIncomingAsset(assetId, amount, fee);\n  }\n\n  function test_AssetLogic_handleIncomingAsset_worksWithToken() public {\n    address assetId = _local;\n    uint256 amount = 10;\n    uint256 fee = 1;\n    utils_handleIncomingAssetAndAssert(assetId, amount, fee);\n  }\n\n  function test_AssetLogic_handleIncomingAsset_worksWithNative() public {\n    address assetId = address(0);\n    uint256 amount = 10;\n    uint256 fee = 0;\n    utils_handleIncomingAssetAndAssert(assetId, amount, fee);\n  }\n\n  function test_AssetLogic_handleIncomingAsset_worksWithNativeAndFee() public {\n    address assetId = address(0);\n    uint256 amount = 10;\n    uint256 fee = 3;\n    utils_handleIncomingAssetAndAssert(assetId, amount, fee);\n  }\n\n  // FIXME: special token\n  function test_AssetLogic_handleIncomingAsset_worksWithFeeOnTransfer() public {}\n\n  // ============ wrapNativeAsset ============\n  function test_AssetLogic_wrapNativeAsset_works() public {\n    uint256 initEth = address(this).balance;\n    uint256 initWeth = IERC20(_wrapper).balanceOf(address(this));\n    AssetLogic.wrapNativeAsset(100);\n    assertEq(address(this).balance, initEth - 100);\n    assertEq(IERC20(_wrapper).balanceOf(address(this)), initWeth + 100);\n  }\n\n  // ============ transferAssetToContract ============\n  function test_AssetLogic_transferAssetToContract_works() public {\n    uint256 initSrc = IERC20(_local).balanceOf(address(this));\n    uint256 initDest = IERC20(_local).balanceOf(address(caller));\n    IERC20(_local).approve(address(caller), 100);\n    caller.transferAssetToContract(_local, 100);\n    assertEq(IERC20(_local).balanceOf(address(this)), initSrc - 100);\n    assertEq(IERC20(_local).balanceOf(address(caller)), initDest + 100);\n  }\n\n  // FIXME: special token\n  function test_AssetLogic_transferAssetToContract_worksWithFeeOnTransfer() public {}\n\n  // ============ transferAssetFromContract ============\n  function test_AssetLogic_transferAssetFromContract_failsIfNoAsset() public {\n    // set constants\n    address assetId = address(0);\n    address to = address(12345);\n    uint256 amount = 12345678;\n    vm.expectRevert(AssetLogic.AssetLogic__transferAssetFromContract_notNative.selector);\n    AssetLogic.transferAssetFromContract(assetId, to, amount);\n  }\n\n  function test_AssetLogic_transferAssetFromContract_works() public {\n    // set constants\n    address assetId = _local;\n    address to = address(12345);\n    uint256 amount = 12345678;\n    utils_transferFromContractAndAssert(assetId, to, amount);\n  }\n\n  function test_AssetLogic_transferAssetFromContract_worksIfZero() public {\n    // set constants\n    address assetId = _local;\n    address to = address(12345);\n    uint256 amount = 0;\n    utils_transferFromContractAndAssert(assetId, to, amount);\n  }\n\n  function test_AssetLogic_transferAssetFromContract_worksForNative() public {\n    // setup asset\n    utils_setupNative(false, false);\n    // set constants\n    address assetId = _wrapper; // native asset will be wrapper\n    address to = address(12345);\n    uint256 amount = 12345678;\n    utils_transferFromContractAndAssert(assetId, to, amount);\n  }\n\n  // ============ swapToLocalAssetIfNeeded ============\n\n  // doesnt swap\n  function test_AssetLogic_swapToLocalAssetIfNeeded_worksIfZero() public {\n    utils_swapToLocalAndAssertViaExternal(_adopted, 0, 10000);\n  }\n\n  // does not swap if already local\n  function test_AssetLogic_swapToLocalAssetIfNeeded_worksWithLocal() public {\n    utils_swapToLocalAndAssertViaExternal(_local, 1 ether, 0.9 ether);\n  }\n\n  // works\n  function test_AssetLogic_swapToLocalAssetIfNeeded_worksWithAdopted() public {\n    utils_swapToLocalAndAssertViaExternal(_adopted, 1 ether, 0.9 ether);\n  }\n\n  // ============ swapFromLocalAssetIfNeeded ============\n\n  // doesnt swap\n  function test_AssetLogic_swapFromLocalAssetIfNeeded_worksIfZero() public {\n    utils_swapFromLocalAndAssertViaExternal(_local, 0, 0.1 ether);\n  }\n\n  // does not swap if already adopted\n  function test_AssetLogic_swapFromLocalAssetIfNeeded_worksWithAdopted() public {\n    utils_swapFromLocalAndAssertViaExternal(_adopted, 1 ether, 0.9 ether);\n  }\n\n  // should work (swap local for adopted)\n  function test_AssetLogic_swapFromLocalAssetIfNeeded_worksWithLocal() public {\n    utils_swapFromLocalAndAssertViaExternal(_local, 1 ether, 0.9 ether);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {XAppConnectionManager, TypeCasts} from \"../../../../contracts/nomad-core/contracts/XAppConnectionManager.sol\";\nimport {Home} from \"../../../../contracts/nomad-core/contracts/Home.sol\";\nimport {TypedMemView} from \"../../../../contracts/nomad-core/libs/TypedMemView.sol\";\n\nimport {IAavePool} from \"../../../../contracts/core/connext/interfaces/IAavePool.sol\";\nimport {IStableSwap} from \"../../../../contracts/core/connext/interfaces/IStableSwap.sol\";\nimport {ISponsorVault} from \"../../../../contracts/core/connext/interfaces/ISponsorVault.sol\";\nimport {ITokenRegistry} from \"../../../../contracts/core/connext/interfaces/ITokenRegistry.sol\";\nimport {TokenRegistry} from \"../../../../contracts/core/connext/helpers/TokenRegistry.sol\";\nimport {IBridgeToken} from \"../../../../contracts/core/connext/interfaces/IBridgeToken.sol\";\nimport {IWrapped} from \"../../../../contracts/core/connext/interfaces/IWrapped.sol\";\nimport {IExecutor} from \"../../../../contracts/core/connext/interfaces/IExecutor.sol\";\nimport {Executor} from \"../../../../contracts/core/connext/helpers/Executor.sol\";\nimport {ConnextMessage} from \"../../../../contracts/core/connext/libraries/ConnextMessage.sol\";\nimport {RelayerFeeMessage} from \"../../../../contracts/core/relayer-fee/libraries/RelayerFeeMessage.sol\";\nimport {AssetLogic} from \"../../../../contracts/core/connext/libraries/AssetLogic.sol\";\nimport {LibCrossDomainProperty} from \"../../../../contracts/core/connext/libraries/LibCrossDomainProperty.sol\";\nimport {CallParams, ExecuteArgs, XCallArgs} from \"../../../../contracts/core/connext/libraries/LibConnextStorage.sol\";\nimport {LibDiamond} from \"../../../../contracts/core/connext/libraries/LibDiamond.sol\";\nimport {BridgeFacet} from \"../../../../contracts/core/connext/facets/BridgeFacet.sol\";\nimport {BaseConnextFacet} from \"../../../../contracts/core/connext/facets/BaseConnextFacet.sol\";\nimport {TestERC20} from \"../../../../contracts/test/TestERC20.sol\";\nimport {PromiseRouter} from \"../../../../contracts/core/promise/PromiseRouter.sol\";\n\nimport \"../../../utils/Mock.sol\";\n\nimport \"./FacetHelper.sol\";\n\ncontract BridgeFacetTest is BridgeFacet, FacetHelper {\n  // ============ Libs ============\n  using TypedMemView for bytes29;\n  using TypedMemView for bytes;\n  // ============ Constants ============\n\n  bytes32 constant TEST_MESSAGE = bytes32(\"test message\");\n\n  // ============ Storage ============\n  // diamond storage contract owner\n  address _ds_owner = address(987654321);\n\n  // executor contract\n  address _executor;\n  // mock xapp contract\n  address _xapp;\n  // mock xapp connection manager\n  address _xappConnectionManager;\n  // mock home\n  address _xappHome;\n  // mock promise router\n  address payable _promiseRouter;\n  // mock callback contract\n  address _callback;\n\n  // agents\n  address _agent = address(123456654321);\n\n  // default origin sender\n  address _originSender = address(4);\n\n  // aave pool details\n  address _aavePool;\n\n  // relayer fee\n  uint256 _relayerFee = 0.1 ether;\n\n  // default amount\n  uint256 _amount = 1.1 ether;\n\n  // default nonce on xcall\n  uint256 _nonce = 1;\n\n  // default recovery address\n  address constant _recovery = address(121212);\n\n  // default CallParams\n  CallParams _params =\n    CallParams(\n      address(11), // to\n      bytes(\"\"), // callData\n      _originDomain, // origin domain\n      _destinationDomain, // destination domain\n      _agent, // agent\n      _recovery, // recovery address\n      address(0), // callback\n      0, // callbackFee\n      _relayerFee, // relayer fee\n      false, // forceSlow\n      false, // receiveLocal\n      9900 // slippageTol\n    );\n\n  // ============ Test set up ============\n  function setUp() public {\n    // Deploy any needed contracts.\n    utils_deployContracts();\n\n    utils_setFees();\n\n    // Set up asset context. By default, local is the adopted asset - the one the 'user'\n    // is using - and is representational (meaning canonically it belongs to another chain).\n    utils_setupAsset(true, false);\n\n    // Promise router mock calls.\n    vm.mockCall(_promiseRouter, abi.encodeWithSelector(PromiseRouter.send.selector), abi.encode());\n    vm.mockCall(_promiseRouter, abi.encodeWithSelector(PromiseRouter.initCallbackFee.selector), abi.encode());\n\n    // Other context setup: configuration, storage, etc.\n    s.approvedRelayers[address(this)] = true;\n    s.maxRoutersPerTransfer = 5;\n    s._routerOwnershipRenounced = true;\n\n    vm.prank(address(this));\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.contractOwner = _ds_owner;\n\n    // NOTE: Currently, the only time we check for the domain in params to match the contract's\n    // domain is within the `xcall` method - so it's safe to set the contract domain to be origin.\n    utils_setRemote(true);\n  }\n\n  // ============ Utils ============\n  // Utils used in the following tests (as well as setup).\n\n  // Used in set up for deploying any needed peripheral contracts.\n  function utils_deployContracts() public {\n    utils_deployAssetContracts();\n    // Deploy an executor.\n    _executor = address(new Executor(address(this)));\n    s.executor = IExecutor(_executor);\n    // Deploy a mock xapp consumer.\n    _xapp = address(new MockXApp());\n\n    // Deploy a mock home.\n    _xappHome = address(new MockHome());\n    // Deploy a mock xapp connection manager.\n    _xappConnectionManager = address(new MockXAppConnectionManager(MockHome(_xappHome)));\n    s.xAppConnectionManager = XAppConnectionManager(_xappConnectionManager);\n    // Deploy the promise router.\n    s.promiseRouter = new MockPromiseRouter();\n    _promiseRouter = payable(s.promiseRouter);\n\n    // Deploy a mock callback.\n    _callback = address(new MockCallback());\n\n    // setup aave pool\n    _aavePool = address(new MockPool(false));\n    s.aavePool = _aavePool;\n  }\n\n  // Meant to mimic the corresponding `_getTransferId` method in the BridgeFacet contract.\n  function utils_getTransferIdFromXCallArgs(\n    XCallArgs memory _args,\n    address sender,\n    bytes32 canonicalId,\n    uint32 canonicalDomain\n  ) public view returns (bytes32) {\n    return keccak256(abi.encode(s.nonce, _args.params, sender, canonicalId, canonicalDomain, _args.amount));\n  }\n\n  // Meant to mimic the corresponding `_getTransferId` method in the BridgeFacet contract.\n  function utils_getTransferIdFromExecuteArgs(ExecuteArgs memory _args) public returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(_args.nonce, _args.params, _args.originSender, _canonicalId, _canonicalDomain, _args.amount)\n      );\n  }\n\n  // Makes some mock xcall arguments using params set in storage.\n  function utils_makeXCallArgs() public returns (bytes32, XCallArgs memory) {\n    // get args\n    XCallArgs memory args = XCallArgs(\n      _params,\n      _adopted == address(s.wrapper) ? address(0) : _adopted, // transactingAssetId : could be adopted, local, or wrapped.\n      _amount\n    );\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromXCallArgs(args, _originSender, _canonicalId, _canonicalDomain);\n\n    return (transferId, args);\n  }\n\n  function utils_makeXCallArgs(address transactingAssetId) public returns (bytes32, XCallArgs memory) {\n    // get args\n    XCallArgs memory args = XCallArgs(\n      _params,\n      transactingAssetId, // transactingAssetId : could be adopted, local, or wrapped.\n      _amount\n    );\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromXCallArgs(args, _originSender, _canonicalId, _canonicalDomain);\n\n    return (transferId, args);\n  }\n\n  // Makes some mock router signatures.\n  function utils_makeRouterSignatures(\n    bytes32 _transferId,\n    address[] memory _routers,\n    uint256[] memory _keys\n  ) public returns (bytes[] memory) {\n    uint256 pathLen = _routers.length;\n    bytes[] memory signatures = new bytes[](pathLen);\n    if (pathLen == 0) {\n      return signatures;\n    }\n    bytes32 preImage = keccak256(abi.encode(_transferId, pathLen));\n    bytes32 toSign = ECDSA.toEthSignedMessageHash(preImage);\n    for (uint256 i; i < pathLen; i++) {\n      (uint8 v, bytes32 r, bytes32 _s) = vm.sign(_keys[i], toSign);\n      signatures[i] = abi.encodePacked(r, _s, v);\n    }\n    return signatures;\n  }\n\n  // Makes some mock execute arguments with given router/key pairs.\n  function utils_makeExecuteArgs(address[] memory routers, uint256[] memory keys)\n    public\n    returns (bytes32, ExecuteArgs memory)\n  {\n    // get args\n    bytes[] memory empty = new bytes[](0);\n    ExecuteArgs memory args = ExecuteArgs(_params, _local, routers, empty, _amount, _nonce, _originSender);\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromExecuteArgs(args);\n    // generate router signatures if applicable\n    if (routers.length > 0) {\n      args.routerSignatures = utils_makeRouterSignatures(transferId, routers, keys);\n    }\n    return (transferId, args);\n  }\n\n  // Make execute args, fill in a number of router/key pairs.\n  // Specifically input 0 to make execute arguments with no routers/keys for slow liq simulation.\n  function utils_makeExecuteArgs(uint256 num) public returns (bytes32, ExecuteArgs memory) {\n    if (num == 0) {\n      address[] memory routers;\n      uint256[] memory keys;\n      return utils_makeExecuteArgs(routers, keys);\n    }\n    address[] memory routers = new address[](num);\n    uint256[] memory keys = new uint256[](num);\n    for (uint256 i; i < num; i++) {\n      routers[i] = vm.addr(777 + i);\n      keys[i] = 777 + i;\n    }\n    return utils_makeExecuteArgs(routers, keys);\n  }\n\n  // Intended to mock the fast transfer amount calculation in the target contract.\n  function utils_getFastTransferAmount(uint256 _amount) public returns (uint256) {\n    // This is the method used internally to get the amount of tokens to transfer after liquidity\n    // fees are taken.\n    return (_amount * s.LIQUIDITY_FEE_NUMERATOR) / s.LIQUIDITY_FEE_DENOMINATOR;\n  }\n\n  // Mimics the xcall message formatting. Reduced functionality : won't burn any tokens, for example.\n  function utils_formatMessage(\n    XCallArgs memory _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) public returns (bytes memory) {\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      detailsHash = token.detailsHash();\n    }\n\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  // Wraps reconcile in order to enable externalizing the call.\n  function utils_wrappedReconcile(uint32 origin, bytes memory message) external {\n    _reconcile(origin, message);\n  }\n\n  struct PortalInfo {\n    uint256 fee;\n    uint256 debt;\n    uint256 total;\n    bool aaveReturns;\n  }\n\n  function utils_setPortals(\n    bytes32 _id,\n    uint256 _amount,\n    uint256 _fee\n  ) public returns (PortalInfo memory) {\n    s.portalFeeDebt[_id] = _fee;\n    s.portalDebt[_id] = _amount;\n    return PortalInfo(_fee, _amount, _fee + _amount, true);\n  }\n\n  function utils_setPortals(bytes32 _id, uint256 _amount) public returns (PortalInfo memory) {\n    return utils_setPortals(_id, _amount, (_amount * _portalFeeNumerator) / _liquidityFeeDenominator);\n  }\n\n  // ============== Helpers ==================\n  // Helpers used for executing target methods with given params that assert expected base behavior.\n  function helpers_setupSuccessfulXcallCallAssertions(\n    bytes32 transferId,\n    XCallArgs memory args,\n    uint256 bridgedAmt,\n    bool isNative,\n    bool shouldSwap\n  ) public {\n    // bridged is either local or canonical, depending on domain xcall originates on\n    address bridged = _canonicalDomain == args.params.originDomain ? _canonical : _local;\n    BridgeFacet.XCalledEventArgs memory eventArgs = BridgeFacet.XCalledEventArgs({\n      transactingAssetId: isNative ? address(s.wrapper) : args.transactingAssetId,\n      amount: args.amount,\n      bridgedAmt: bridgedAmt,\n      bridged: bridged\n    });\n    bytes memory message = utils_formatMessage(args, bridged, transferId, bridgedAmt);\n    vm.expectEmit(true, true, true, true);\n    emit XCalled(transferId, args, eventArgs, s.nonce, message, _originSender);\n\n    // assert swap if expected\n    if (shouldSwap && bridgedAmt > 0) {\n      // Transacting asset shouldve been approved for amount in\n      vm.expectCall(\n        eventArgs.transactingAssetId,\n        abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, args.amount)\n      );\n\n      // swapExact on pool should have been called\n      uint256 minReceived = (args.amount * args.params.slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(\n          IStableSwap.swapExact.selector,\n          args.amount,\n          eventArgs.transactingAssetId,\n          _local,\n          minReceived\n        )\n      );\n    }\n\n    if (args.params.callbackFee > 0) {\n      // Assert that CallbackFee would be paid by the user.\n      vm.expectCall(\n        _promiseRouter,\n        args.params.callbackFee,\n        abi.encodeWithSelector(PromiseRouter.initCallbackFee.selector, transferId)\n      );\n    }\n    // Assert dispatch call\n    vm.expectCall(\n      _xappHome,\n      0,\n      abi.encodeWithSelector(Home.dispatch.selector, args.params.destinationDomain, _remote, message)\n    );\n\n    // if the token is a representation token, ensure that burn is called\n    if (bridged != _canonical && bridgedAmt > 0) {\n      vm.expectCall(_local, abi.encodeWithSelector(TestERC20.burn.selector, address(this), bridgedAmt));\n    }\n  }\n\n  // Calls `xcall` with given args and handles standard assertions.\n  function helpers_xcallAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    uint256 dealTokens,\n    uint256 bridgedAmt,\n    bytes4 expectedError,\n    bool shouldSwap\n  ) public {\n    bool isNative = args.transactingAssetId == address(0);\n    bool shouldSucceed = keccak256(abi.encode(expectedError)) == keccak256(abi.encode(bytes4(\"\")));\n    bool isCanonical = _canonicalDomain == args.params.originDomain;\n\n    // Deal the user required eth for transfer.\n    vm.deal(_originSender, 100 ether);\n\n    uint256 initialUserBalance;\n    uint256 initialContractBalance;\n    if (isNative) {\n      initialUserBalance = payable(_originSender).balance;\n      initialContractBalance = payable(address(this)).balance;\n    } else {\n      TestERC20 tokenIn = TestERC20(args.transactingAssetId);\n      TestERC20 localToken = TestERC20(_local);\n\n      // Mint the specified amount of tokens for the user.\n      tokenIn.mint(_originSender, dealTokens);\n\n      initialUserBalance = tokenIn.balanceOf(_originSender);\n      initialContractBalance = localToken.balanceOf(address(this));\n\n      // Approve the target contract to spend the specified amount of tokens.\n      vm.prank(_originSender);\n      tokenIn.approve(address(this), dealTokens);\n    }\n\n    if (shouldSwap) {\n      // Setup the expected swap mock (adopted <> local)\n      vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExact.selector), abi.encode(bridgedAmt, _local));\n    }\n\n    assertEq(s.relayerFees[transferId], 0);\n\n    if (shouldSucceed) {\n      helpers_setupSuccessfulXcallCallAssertions(transferId, args, bridgedAmt, isNative, shouldSwap);\n    } else {\n      vm.expectRevert(expectedError);\n    }\n\n    uint256 fees = args.params.relayerFee + args.params.callbackFee;\n    vm.prank(_originSender);\n    this.xcall{value: isNative ? fees + args.amount : fees}(args);\n\n    if (shouldSucceed) {\n      if (isNative) {\n        // Should have custodied the relayer fee, sent any callback fee to the promise router, and deposited the\n        // amount into the wrapper contract.\n        assertEq(payable(address(this)).balance, initialContractBalance + args.params.relayerFee);\n      } else {\n        // User should have been debited fees... but also tx cost?\n        // assertEq(payable(_originSender).balance, initialUserBalance - fees);\n\n        // Check that the user has been debited the correct amount of tokens.\n        assertEq(TestERC20(args.transactingAssetId).balanceOf(_originSender), initialUserBalance - args.amount);\n\n        // Check that the contract has been credited the correct amount of tokens.\n        // NOTE: Because the tokens are a representational local asset, they are burnt. The contract\n        // should NOT be holding any additional tokens after xcall completes.\n        if (isCanonical) {\n          // This should be a canonical asset transfer\n          assertEq(TestERC20(_canonical).balanceOf(address(this)), initialContractBalance + bridgedAmt);\n        } else {\n          // NOTE: Normally the adopted asset would be swapped into the local asset and then\n          // the local asset would be burned. Because the swap increases the contracts balance\n          // the prod difference in balance is net 0. However, because the swap here is mocked,\n          // when a swap occurrs no balance increase of local happens (i.e. if swap needed, the\n          // balance will decrease by bridgedAmt / what is burned)\n          uint256 expected = args.transactingAssetId == _local\n            ? initialContractBalance\n            : initialContractBalance - bridgedAmt;\n          assertEq(TestERC20(_local).balanceOf(address(this)), expected);\n        }\n      }\n      // Should have updated relayer fees mapping.\n      assertEq(this.relayerFees(transferId), args.params.relayerFee);\n\n      if (args.params.callbackFee > 0) {\n        // TODO: For some reason, balance isn't changing. Perhaps the vm.mockCall prevents this?\n        // CallbackFee should be delivered to the PromiseRouter.\n        // assertEq(_promiseRouter.balance, _params.callbackFee);\n      }\n    } else {\n      // Should have reverted.\n      assertEq(this.relayerFees(transferId), 0);\n    }\n  }\n\n  // Shortcut for the main fn. Generates args within this method.\n  function helpers_xcallAndAssert(\n    bytes4 expectedError,\n    uint256 bridged,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    uint256 dealTokens = (args.transactingAssetId == address(0)) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, expectedError, swaps);\n  }\n\n  function helpers_xcallAndAssert(bytes4 expectedError) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    uint256 dealTokens = (args.transactingAssetId == address(0)) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, 0, expectedError, false);\n  }\n\n  // Shortcut for the above fn, with no expected error.\n  function helpers_xcallAndAssert(uint256 bridged, bool swaps) public {\n    helpers_xcallAndAssert(bytes4(\"\"), bridged, swaps);\n  }\n\n  // Shortcut for the above fn, no expected error, specified transacting asset\n  function helpers_xcallAndAssert(\n    uint256 bridged,\n    address transacting,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs(transacting);\n    uint256 dealTokens = transacting == address(0) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, bytes4(\"\"), swaps);\n  }\n\n  // Shortcut for the main fn.\n  function helpers_xcallAndAssert(\n    uint256 dealTokens,\n    uint256 bridged,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, bytes4(\"\"), swaps);\n  }\n\n  struct ExecuteBalances {\n    uint256 bridge;\n    uint256 to;\n    uint256 executor;\n    uint256 debt;\n    uint256 feeDebt;\n  }\n\n  struct ExecuteTestInputs {\n    uint256 expectedAmt;\n    uint256 routerAmt;\n    address token;\n    bool callsExternal;\n    bool externalCallSucceeds;\n    bool shouldSwap; // Whether the `to` address should receive the tokens.\n    bool isSlow;\n    bool usesPortals;\n    bool useAgent;\n  }\n\n  function utils_getExecuteBalances(\n    bytes32 transferId,\n    IERC20 asset,\n    address _to\n  ) public returns (ExecuteBalances memory) {\n    uint256 debt = s.portalDebt[transferId];\n    uint256 fee = s.portalFeeDebt[transferId];\n    uint256 bridge = IERC20(_local).balanceOf(address(this));\n    uint256 to = address(asset) == address(s.wrapper) ? payable(_to).balance : asset.balanceOf(_to);\n    uint256 executor = address(asset) == address(s.wrapper) ? payable(_executor).balance : asset.balanceOf(_executor);\n    return ExecuteBalances(bridge, to, executor, debt, fee);\n  }\n\n  function helpers_setupExecuteAssertions(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    ExecuteTestInputs memory _inputs\n  ) public {\n    // ----- register expected calls\n\n    // expects portal\n    if (_inputs.usesPortals) {\n      // mint position\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.mintUnbacked.selector, _adopted, _inputs.routerAmt, address(this), 0)\n      );\n\n      // withdraw\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.withdraw.selector, _adopted, _inputs.routerAmt, address(this))\n      );\n    }\n\n    // expected swap\n    if (_inputs.shouldSwap) {\n      // register expected approval\n      vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, _inputs.routerAmt));\n      // register expected swap amount\n      uint256 minReceived = (_inputs.routerAmt * _args.params.slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.swapExact.selector, _inputs.routerAmt, _local, _adopted, minReceived)\n      );\n    }\n\n    // expected sponsor vault\n    if (address(s.sponsorVault) != address(0)) {\n      // if it is a fast transfer, then it should reimburse liquidity fees\n      if (!_inputs.isSlow) {\n        vm.expectCall(\n          address(s.sponsorVault),\n          abi.encodeWithSelector(\n            ISponsorVault.reimburseLiquidityFees.selector,\n            _inputs.token,\n            _args.amount,\n            _args.params.to\n          )\n        );\n      }\n      // always reimburses relayer fees\n      vm.expectCall(\n        address(s.sponsorVault),\n        abi.encodeWithSelector(\n          ISponsorVault.reimburseRelayerFees.selector,\n          _originDomain,\n          _args.params.to,\n          _args.params.relayerFee\n        )\n      );\n    }\n\n    // expected transfer out of contract\n    if (_args.amount > 0) {\n      if (_inputs.token == address(s.wrapper)) {\n        // wrapper withdrawal\n        vm.expectCall(_inputs.token, abi.encodeWithSelector(IWrapped.withdraw.selector, _inputs.expectedAmt));\n      } else {\n        // token transfer\n        vm.expectCall(\n          _inputs.token,\n          abi.encodeWithSelector(\n            IERC20.transfer.selector,\n            _inputs.callsExternal ? _executor : _args.params.to,\n            _inputs.expectedAmt\n          )\n        );\n      }\n    }\n\n    // expected executor call\n    if (_inputs.callsExternal) {\n      {\n        bytes memory properties = _inputs.isSlow\n          ? LibCrossDomainProperty.formatDomainAndSenderBytes(_originDomain, _originSender)\n          : LibCrossDomainProperty.EMPTY_BYTES;\n        vm.expectCall(\n          _executor,\n          abi.encodeWithSelector(\n            IExecutor.execute.selector,\n            IExecutor.ExecutorArgs(\n              transferId,\n              _inputs.expectedAmt,\n              _args.params.to,\n              _args.params.recovery,\n              _inputs.token,\n              properties,\n              _args.params.callData\n            )\n          )\n        );\n      }\n    }\n\n    // expected promise router call\n    if (_args.params.callback != address(0)) {\n      vm.expectCall(\n        _promiseRouter,\n        abi.encodeWithSelector(\n          PromiseRouter.send.selector,\n          _originDomain,\n          transferId,\n          _args.params.callback,\n          _inputs.externalCallSucceeds,\n          bytes(\"\")\n        )\n      );\n    }\n  }\n\n  // Calls `execute` on the target method with the given args and asserts expected behavior.\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    ExecuteTestInputs memory _inputs\n  ) public {\n    // get pre-execute liquidity in local\n    uint256 pathLen = _args.routers.length;\n    uint256[] memory prevLiquidity = new uint256[](pathLen);\n    {\n      for (uint256 i; i < pathLen; i++) {\n        prevLiquidity[i] = s.routerBalances[_args.routers[i]][_local];\n      }\n    }\n\n    // get pre-execute balance here in local\n    IERC20 token = IERC20(_inputs.token);\n    ExecuteBalances memory prevBalances = utils_getExecuteBalances(transferId, token, _args.params.to);\n\n    // execute\n    // expected amount is impacted by (1) fast liquidity fees (2) slippage\n    // router debited amount in local is only impacted by fast liquidity\n    uint256 routerAmt = _inputs.isSlow ? _args.amount : utils_getFastTransferAmount(_args.amount);\n\n    // setup pool mock if needed\n    if (_inputs.shouldSwap) {\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.swapExact.selector),\n        abi.encode(_inputs.expectedAmt, _adopted)\n      );\n    }\n\n    if (_inputs.token == address(s.wrapper)) {\n      vm.mockCall(_inputs.token, abi.encodeWithSelector(IWrapped.withdraw.selector), abi.encode(true));\n    }\n\n    // setup execute mock\n    vm.mockCall(\n      _executor,\n      abi.encodeWithSelector(Executor.execute.selector),\n      abi.encode(_inputs.externalCallSucceeds, bytes(\"\"))\n    );\n\n    // register expected calls\n    helpers_setupExecuteAssertions(transferId, _args, _inputs);\n\n    if (_inputs.usesPortals) {\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalMintUnbacked(transferId, _args.routers[0], _inputs.token, _inputs.expectedAmt);\n    }\n\n    // register expected emit event\n    address sender = _inputs.useAgent ? _args.params.agent : address(this);\n    vm.expectEmit(true, true, false, true);\n    emit Executed(transferId, _args.params.to, _args, _inputs.token, _inputs.expectedAmt, sender);\n    // make call\n    vm.prank(sender);\n    this.execute(_args);\n\n    // check local balance\n    {\n      if (pathLen > 0) {\n        // should decrement router balance unless using aave\n        for (uint256 i; i < pathLen; i++) {\n          assertEq(\n            s.routerBalances[_args.routers[i]][_args.local],\n            _inputs.usesPortals ? prevLiquidity[i] : prevLiquidity[i] - (_inputs.routerAmt / pathLen)\n          );\n        }\n      }\n    }\n\n    {\n      // assertions\n      ExecuteBalances memory finalBalances = utils_getExecuteBalances(transferId, token, _args.params.to);\n\n      // NOTE: the balance of the bridge *should* always decrement in local, however that depends on\n      // the token executing the `swap` / `withdraw` call when a swap is needed (which we have as mocked).\n      // Instead, assert the swap functions on the pool were called correctly\n      if (!_inputs.shouldSwap && _inputs.token != address(s.wrapper)) {\n        // NOTE: when using aave would normally send you funds for the position minted,\n        // but we are not adding any funds from the pool, so always decrement\n        assertEq(finalBalances.bridge, prevBalances.bridge - _inputs.routerAmt);\n      }\n\n      if (_inputs.usesPortals) {\n        uint256 fee = (_inputs.routerAmt * _portalFeeNumerator) / _liquidityFeeDenominator;\n        assertEq(finalBalances.feeDebt, prevBalances.feeDebt + fee);\n        assertEq(finalBalances.debt, prevBalances.debt + _inputs.routerAmt);\n      } else {\n        assertEq(finalBalances.feeDebt, prevBalances.feeDebt);\n        assertEq(finalBalances.debt, prevBalances.debt);\n      }\n\n      if (_inputs.callsExternal) {\n        // should increment balance of executor\n        // should NOT increment balance of to\n        // NOTE: recovery address testing should be done in Executor.t.sol\n        // as such, executor balance should *always* increment\n        assertEq(finalBalances.executor, prevBalances.executor + _inputs.expectedAmt);\n        assertEq(token.balanceOf(_params.to), prevBalances.to);\n      } else {\n        // should have incremented balance of `to`\n        // should NOT increment balance of executor\n        assertEq(finalBalances.to, prevBalances.to + _inputs.expectedAmt);\n        assertEq(finalBalances.executor, prevBalances.executor);\n      }\n    }\n\n    // should mark the transfer as executed\n    assertEq(s.transferRelayer[transferId], sender);\n\n    // should have assigned transfer as routed\n    address[] memory savedRouters = this.routedTransfers(transferId);\n    for (uint256 i; i < savedRouters.length; i++) {\n      assertEq(savedRouters[i], _args.routers[i]);\n    }\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expectedAmt, // amount out of swap\n    bool callsExternal,\n    bool externalCallSucceeds,\n    bool shouldSwap, // Whether the `to` address should receive the tokens.\n    bool usesPortals,\n    bool useAgent\n  ) public {\n    uint256 pathLen = _args.routers.length;\n    bool isSlow = pathLen == 0;\n    // get pre-execute balance here in local\n    uint256 routerAmt = isSlow ? _args.amount : utils_getFastTransferAmount(_args.amount);\n    helpers_executeAndAssert(\n      transferId,\n      _args,\n      ExecuteTestInputs(\n        expectedAmt,\n        routerAmt,\n        shouldSwap ? _adopted : _local, // token\n        callsExternal,\n        externalCallSucceeds,\n        shouldSwap,\n        isSlow,\n        usesPortals,\n        useAgent\n      )\n    );\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expectedAmt, // amount out of swap\n    bool callsExternal,\n    bool externalCallSucceeds,\n    bool shouldSwap // Whether the `to` address should receive the tokens.\n  ) public {\n    helpers_executeAndAssert(\n      transferId,\n      _args,\n      expectedAmt,\n      callsExternal,\n      externalCallSucceeds,\n      shouldSwap,\n      false,\n      false\n    );\n  }\n\n  function buildMessage(bytes32 _id) private returns (bytes memory) {\n    bytes32 detailsHash = keccak256(\"test\");\n\n    bytes29 action = ConnextMessage.formatTransfer(bytes32(uint256(uint160(_params.to))), _amount, detailsHash, _id);\n    bytes29 tokenId = ConnextMessage.formatTokenId(_canonicalDomain, _canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  // ============ execute ============\n  // Shortcut for above method:\n  // - local == adopted\n  // - does not call external\n  // - calling on non-canonical domain\n  function helpers_executeAndAssert(bytes32 transferId, ExecuteArgs memory _args) public {\n    uint256 expected = _args.amount;\n    if (_args.routers.length > 0) {\n      expected = utils_getFastTransferAmount(_args.amount);\n    }\n    helpers_executeAndAssert(transferId, _args, expected, false, false, false, false, false);\n  }\n\n  // Shortcut where:\n  // - local != adopted\n  // - does not call external\n  // - calling on noncanonical domain\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expected,\n    bool shouldSwap\n  ) public {\n    helpers_executeAndAssert(transferId, _args, expected, false, false, shouldSwap, false, false);\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    bool useAgent\n  ) public {\n    uint256 expected = _args.amount;\n    if (_args.routers.length > 0) {\n      expected = utils_getFastTransferAmount(_args.amount);\n    }\n    helpers_executeAndAssert(transferId, _args, expected, false, false, false, false, useAgent);\n  }\n\n  function helpers_setupReconcilePortalAssertions(\n    bytes32 transferId,\n    XCallArgs memory args,\n    PortalInfo memory init,\n    PortalInfo memory repayment,\n    uint256 amountIn,\n    uint256 amountOut\n  ) public {\n    if (repayment.total == 0) {\n      // noting to assert\n      return;\n    }\n    // if local != adopted, need to swap into adopted\n    if (_local != _adopted) {\n      // should call calculate always\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapFromAddress.selector, _local, _adopted, args.amount)\n      );\n\n      // will swap and repay IFF within slippage\n      if (amountIn <= args.amount) {\n        // slippage ok, call approve\n        vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, amountIn));\n        // should call swap\n        vm.expectCall(\n          _stableSwap,\n          abi.encodeWithSelector(IStableSwap.swapExactOut.selector, repayment.total, _local, _adopted, args.amount)\n        );\n      } // otherwise slippage is too high and it should not try to repay the rest of the loan\n    }\n\n    if (amountIn > 0) {\n      // approval of pool for sum\n      vm.expectCall(_adopted, abi.encodeWithSelector(IERC20.approve.selector, _aavePool, repayment.total));\n\n      // approval of payback\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.backUnbacked.selector, _adopted, repayment.debt, repayment.fee)\n      );\n\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalRepayment(transferId, _adopted, repayment.debt, repayment.fee);\n\n      // check if there will be a debt event\n      if (repayment.total < init.total) {\n        // // FIXME: logs are the same in the corresponding event (when insufficient fees)\n        // // but `expectEmit` call is not working\n        // vm.expectEmit(true, false, false, true);\n        // emit AavePortalRepaymentDebt(transferId, _adopted, init.debt - repayment.debt, init.fee - repayment.fee);\n      }\n    } else {\n      // slippage maximums hit, emit full debt in event\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalRepaymentDebt(transferId, _adopted, init.debt, init.fee);\n    }\n  }\n\n  struct SwapInfo {\n    uint256 input;\n    uint256 output; // the equivalent amount of `out` token for given `in`\n  }\n\n  // Helper for calling `reconcile` and asserting expected behavior.\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError,\n    PortalInfo memory repayment,\n    SwapInfo memory swap\n  ) public {\n    PortalInfo memory init = PortalInfo(\n      s.portalFeeDebt[transferId],\n      s.portalDebt[transferId],\n      s.portalDebt[transferId] + s.portalFeeDebt[transferId],\n      true\n    );\n    bool isNative = args.transactingAssetId == address(0);\n    bool shouldSucceed = keccak256(abi.encode(expectedError)) == keccak256(abi.encode(bytes4(\"\")));\n\n    // Derive message from xcall arguments.\n    bytes memory message;\n    {\n      BridgeFacet.XCalledEventArgs memory eventArgs = BridgeFacet.XCalledEventArgs({\n        transactingAssetId: isNative ? address(s.wrapper) : args.transactingAssetId,\n        amount: args.amount,\n        bridgedAmt: args.amount,\n        bridged: _local\n      });\n      message = utils_formatMessage(args, _local, transferId, args.amount);\n    }\n\n    uint256[] memory routerBalances = new uint256[](s.routedTransfers[transferId].length);\n    for (uint256 i = 0; i < s.routedTransfers[transferId].length; i++) {\n      // Warming up the slot in order to make gas estimates more accurate to appropriate conditions.\n      s.routerBalances[s.routedTransfers[transferId][i]][_local] = 1 ether;\n      routerBalances[i] = 1 ether;\n    }\n\n    // Get pre-reconcile balances.\n    uint256 prevBalance;\n    if (isNative) {\n      prevBalance = payable(address(this)).balance;\n    } else {\n      prevBalance = IERC20(_local).balanceOf(address(this));\n    }\n\n    // Mock calls for swap if needed\n    if (_local != _adopted && init.total > 0) {\n      // mock calculate equivalent of bridged amount in adopted\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapFromAddress.selector),\n        abi.encode(swap.output)\n      );\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapOutFromAddress.selector),\n        abi.encode(swap.input)\n      );\n      // mock swap\n      vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExactOut.selector), abi.encode(swap.input));\n    }\n\n    if (!repayment.aaveReturns) {\n      // Force failure on call\n      _aavePool = address(new MockPool(true));\n      s.aavePool = _aavePool;\n    }\n\n    if (shouldSucceed) {\n      // check that the mint is called properly\n      if (_local != _canonical) {\n        vm.expectCall(_local, abi.encodeWithSelector(TestERC20.mint.selector, address(this), args.amount));\n      }\n\n      helpers_setupReconcilePortalAssertions(transferId, args, init, repayment, swap.input, swap.output);\n\n      vm.expectEmit(true, true, true, true);\n      emit Reconciled(transferId, _originDomain, s.routedTransfers[transferId], _local, args.amount, address(this));\n    } else {\n      vm.expectRevert(expectedError);\n    }\n\n    this.utils_wrappedReconcile(_originDomain, message);\n\n    if (shouldSucceed) {\n      assertEq(this.reconciledTransfers(transferId), true);\n      address[] memory routers = this.routedTransfers(transferId);\n      if (routers.length > 0) {\n        uint256 routerAmt;\n        if (init.total > 0 && repayment.aaveReturns) {\n          routerAmt = swap.input > args.amount ? args.amount : args.amount - swap.input;\n        } else {\n          routerAmt = args.amount / s.routedTransfers[transferId].length;\n        }\n        // Fast liquidity route. Should have reimbursed routers.\n        for (uint256 i = 0; i < routers.length; i++) {\n          assertEq(s.routerBalances[routers[i]][_local], routerBalances[i] + routerAmt);\n        }\n      }\n\n      if (init.total > 0) {\n        // assert repayment\n        assertEq(s.portalDebt[transferId], init.debt - repayment.debt);\n        assertEq(s.portalFeeDebt[transferId], init.fee - repayment.fee);\n      }\n    }\n  }\n\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError,\n    PortalInfo memory repayment\n  ) public {\n    helpers_reconcileAndAssert(transferId, args, expectedError, repayment, SwapInfo(repayment.total, args.amount));\n  }\n\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError\n  ) public {\n    helpers_reconcileAndAssert(transferId, args, expectedError, PortalInfo(0, 0, 0, true));\n  }\n\n  function helpers_reconcileAndAssert(bytes4 expectedError) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    helpers_reconcileAndAssert(transferId, args, expectedError);\n  }\n\n  // Shortcut for above method.\n  function helpers_reconcileAndAssert() public {\n    helpers_reconcileAndAssert(bytes4(\"\"));\n  }\n\n  // ============ Getters ==============\n\n  function test_BridgeFacet_domain_works() public {\n    s.domain = 0;\n    assertEq(this.domain(), 0);\n    s.domain = _destinationDomain;\n    assertEq(this.domain(), _destinationDomain);\n  }\n\n  function test_BridgeFacet_executor_works() public {\n    s.executor = IExecutor(address(0));\n    assertEq(address(this.executor()), address(0));\n    s.executor = IExecutor(_local);\n    assertEq(address(this.executor()), _local);\n  }\n\n  function test_BridgeFacet_nonce_works() public {\n    s.nonce = 0;\n    assertEq(this.nonce(), 0);\n    s.nonce = _destinationDomain;\n    assertEq(this.nonce(), _destinationDomain);\n  }\n\n  function test_BridgeFacet_sponsorVault_works() public {\n    s.sponsorVault = ISponsorVault(address(0));\n    assertEq(address(this.sponsorVault()), address(0));\n    s.sponsorVault = ISponsorVault(_local);\n    assertEq(address(this.sponsorVault()), _local);\n  }\n\n  function test_BridgeFacet_promiseRouter_works() public {\n    s.promiseRouter = PromiseRouter(payable(address(0)));\n    assertEq(address(this.promiseRouter()), address(0));\n    s.promiseRouter = PromiseRouter(payable(_local));\n    assertEq(address(this.promiseRouter()), _local);\n  }\n\n  // The rest (relayerFees, routedTransfers, reconciledTransfers) are checked on\n  // assertions for xcall / reconcile / execute\n\n  // ============ Admin methods ==============\n  // setPromiseRouter\n  // FIXME: move to BaseConnextFacet.t.sol\n  function test_BridgeFacet__setPromiseRouter_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setPromiseRouter_invalidPromiseRouter.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_failIfNotContract() public {\n    // constants\n    address old = address(123);\n    address updated = address(456);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setPromiseRouter_invalidPromiseRouter.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test success\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit PromiseRouterUpdated(old, updated, LibDiamond.contractOwner());\n    this.setPromiseRouter(payable(updated));\n    assertEq(address(this.promiseRouter()), updated);\n  }\n\n  // setExecutor\n  function test_BridgeFacet__setExecutor_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setExecutor_invalidExecutor.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_failIfNotContract() public {\n    // constants\n    address old = address(123);\n    address updated = address(456);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setExecutor_invalidExecutor.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit ExecutorUpdated(old, updated, LibDiamond.contractOwner());\n    this.setExecutor(payable(updated));\n    assertEq(address(this.executor()), updated);\n  }\n\n  // setSponsorVault\n  function test_BridgeFacet__setSponsorVault_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setSponsorVault(payable(updated));\n  }\n\n  function test_BridgeFacet__setSponsorVault_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setSponsorVault_invalidSponsorVault.selector);\n    this.setSponsorVault(payable(updated));\n  }\n\n  function test_BridgeFacet__setSponsorVault_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit SponsorVaultUpdated(old, updated, LibDiamond.contractOwner());\n    this.setSponsorVault(payable(updated));\n    assertEq(address(this.sponsorVault()), updated);\n  }\n\n  // ============ Public methods ==============\n\n  // ============ xcall ============\n\n  // ============ xcall fail cases\n  // fails if paused\n  // FIXME: move to BaseConnextFacet.t.sol\n  function test_BridgeFacet__xcall_failIfPaused() public {\n    // require(false, \"not tested\");\n  }\n\n  // fails if origin domain is incorrect\n  function test_BridgeFacet__xcall_failIfDomainIncorrect() public {\n    _params.originDomain = 999999;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_wrongDomain.selector);\n  }\n\n  // TODO: fails if destination domain does not have an xapp router registered\n  // FIXME: this should be tested at the integration level (i.e. when we deploy\n  // the contracts via Deployer.sol), or on a facet that asserts this\n\n  // fails if recipient `to` not a valid address (i.e. != address(0))\n  function test_BridgeFacet__xcall_failIfNoRecipient() public {\n    _params.to = address(0);\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_emptyTo.selector);\n  }\n\n  // fails if callback fee > 0 but callback address is not defined\n  function test_BridgeFacet__xcall_failIfCallbackFeeButNoContract() public {\n    _params.callback = address(0);\n    _params.callbackFee = 0.001 ether;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_nonZeroCallbackFeeForCallback.selector);\n  }\n\n  // fails if callback is defined but not a contract\n  function test_BridgeFacet__xcall_failIfCallbackNotAContract() public {\n    _params.callback = address(42);\n    _params.callbackFee = 0.001 ether;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_callbackNotAContract.selector);\n  }\n\n  // fails if asset is not supported (i.e. s.adoptedToCanonical[transactingAssetId].id == bytes32(0) and using non-local)\n  function test_BridgeFacet__xcall_failIfAssetNotSupported() public {\n    // setup asset with local != adopted, not on canonical domain\n    utils_setupAsset(false, false);\n\n    s.adoptedToCanonical[_adopted] = ConnextMessage.TokenId(0, bytes32(0));\n\n    // ensure token registry returns true for local origin\n    vm.mockCall(\n      address(s.tokenRegistry),\n      abi.encodeWithSelector(ITokenRegistry.isLocalOrigin.selector, _adopted),\n      abi.encode(true)\n    );\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_notSupportedAsset.selector);\n  }\n\n  // fails if native asset wrapper is not supported (i.e. s.adoptedToCanonical[transactingAssetId].id == bytes32(0))\n  function test_BridgeFacet__xcall_failIfNativeAssetWrapperNotSupported() public {\n    utils_setupNative(true, true);\n    s.adoptedToCanonical[address(s.wrapper)] = ConnextMessage.TokenId(0, bytes32(0));\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_notSupportedAsset.selector);\n  }\n\n  // fails if native token transfer and amount of native tokens sent is < amount + relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failNativeAssetCallbackFeeInsufficient() public {\n    vm.deal(_originSender, 100 ether);\n    utils_setupNative(true, true);\n    _params.callback = _callback;\n    _params.callbackFee = 0.01 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_notAmount.selector);\n    vm.prank(_originSender);\n    // Sending only the amount + relayer fee; callbackFee is not covered!\n    this.xcall{value: args.params.relayerFee + args.amount}(args);\n  }\n\n  // fails if erc20 transfer and eth sent < relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failEthWithErc20TransferInsufficient() public {\n    utils_setupAsset(true, false);\n    vm.deal(_originSender, 100 ether);\n    _relayerFee = 0.1 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_ethWithErcTransfer.selector);\n    vm.prank(_originSender);\n    // Sending insufficent eth to cover relayer fee.\n    this.xcall{value: 0.08 ether}(args);\n  }\n\n  // fails if erc20 transfer and eth sent > relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failEthWithErc20TransferUnnecessary() public {\n    vm.deal(_originSender, 100 ether);\n    _relayerFee = 0.1 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_ethWithErcTransfer.selector);\n    vm.prank(_originSender);\n    // Sending too much eth.\n    this.xcall{value: 1 ether}(args);\n  }\n\n  // fails if user has insufficient tokens\n  function test_BridgeFacet__xcall_failInsufficientErc20Tokens() public {\n    _amount = 10.1 ether;\n    TestERC20 localToken = TestERC20(_local);\n    localToken.mint(_originSender, 10 ether);\n    vm.prank(_originSender);\n    localToken.approve(address(this), 10.1 ether);\n\n    vm.deal(_originSender, 100 ether);\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(\"ERC20: transfer amount exceeds balance\");\n    vm.prank(_originSender);\n    this.xcall{value: args.params.relayerFee}(args);\n  }\n\n  // fails if user has not set enough allowance\n  function test_BridgeFacet__xcall_failInsufficientErc20Approval() public {\n    _amount = 10.1 ether;\n    TestERC20 localToken = TestERC20(_local);\n    localToken.mint(_originSender, 10.1 ether);\n    vm.prank(_originSender);\n    localToken.approve(address(this), 10 ether);\n\n    vm.deal(_originSender, 100 ether);\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(\"ERC20: transfer amount exceeds allowance\");\n    vm.prank(_originSender);\n    this.xcall{value: args.params.relayerFee}(args);\n  }\n\n  // ============ xcall success cases\n  // asset cases:\n  // - works on remote domain\n  //   - transferring native (local == adopted)\n  //   - transferring native (local != adopted)\n  //   - transferring asset (local == adopted)\n  //   - transferring asset (local != adopted)\n\n  // - works on cannonical domain\n  //   - transferring native (local == adopted)\n  //   - transferring asset (local == adopted)\n  // canonincal token transfer on canonical domain\n  function test_BridgeFacet__xcall_canonicalTokenTransferWorks() public {\n    utils_setupAsset(true, true);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // local token transfer on non-canonical domain (local != adopted)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWithAdopted() public {\n    uint256 bridged = (_amount * 9995) / _liquidityFeeDenominator;\n    utils_setupAsset(false, false);\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // local token transfer on non-canonical domain, local != adopted, send in local\n  // (i.e. i should be able to xcall with madEth on optimism)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWhenNotAdopted() public {\n    // local is not adopted, not on canonical domain, sending in local\n    utils_setupAsset(false, false);\n    s.adoptedToCanonical[_local] = ConnextMessage.TokenId(0, bytes32(0));\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    vm.mockCall(\n      _tokenRegistry,\n      abi.encodeWithSelector(ITokenRegistry.isLocalOrigin.selector, _local),\n      abi.encode(false)\n    );\n    args.transactingAssetId = _local;\n    helpers_xcallAndAssert(transferId, args, args.amount, args.amount, bytes4(\"\"), false);\n  }\n\n  // local token transfer on non-canonical domain (local == adopted)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWithoutAdopted() public {\n    utils_setupAsset(true, false);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // native asset transfer on canonical domain\n  function test_BridgeFacet__xcall_nativeTransferWorksOnCanonical() public {\n    utils_setupNative(true, true);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // native asset transfer on non-canonical domain with local == adopted\n  // i.e. get ETH on arbitrum from cronos\n  // adopted = address(madETH cronos)\n  // local = address(madETH on cronos)\n  // canonical = address(mainnet wrapper)\n  function test_BridgeFacet__xcall_nativeTransferWorksOnRemote() public {\n    utils_setupNative(true, false);\n    helpers_xcallAndAssert(_amount, _local, false);\n  }\n\n  // native asset transfer on non-canonical domain with local != adopted\n  // i.e. native arbitrum eth transfer to matic weth\n  // adopted = address(arbitrum wrapper)\n  // canonical = address(eth wrapper)\n  // local = address(madETH on arbitrum)\n  function test_BridgeFacet__xcall_nativeTransferWorksOnRemoteWithAdopted() public {\n    utils_setupNative(false, false);\n    helpers_xcallAndAssert(_amount, address(0), true);\n  }\n\n  // adopted asset transfer\n  function test_BridgeFacet__xcall_adoptedTransferWorks() public {\n    utils_setupAsset(false, false);\n    uint256 bridged = (_amount * 9995) / _liquidityFeeDenominator;\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // FIXME: should work with fee on transfer tokens\n  function test_BridgeFacet__xcall_feeOnTransferWorks() public {\n    // require(false, \"not tested\");\n  }\n\n  // should work with positive slippage\n  function test_BridgeFacet__xcall_worksWithPositiveSlippage() public {\n    utils_setupAsset(false, false);\n    uint256 bridged = (_amount * 10005) / _liquidityFeeDenominator;\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // should work with 0 value\n  function test_BridgeFacet__xcall_worksWithoutValue() public {\n    _amount = 0;\n    helpers_xcallAndAssert(0, true);\n  }\n\n  // should send promise router callback fee\n  function test_BridgeFacet__xcall_shouldHandleCallbackFee() public {\n    _params.callback = _callback;\n    _params.callbackFee = 0.02 ether;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // works if relayer fee is set to 0\n  function test_BridgeFacet__xcall_zeroRelayerFeeWorks() public {\n    _relayerFee = 0;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // works with callback fee set to 0\n  function test_BridgeFacet__xcall_zeroCallbackFeesWorks() public {\n    _params.callbackFee = 0;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // FIXME: move to BaseConnextFacet.t.sol\n  // works if swap isnt required and swaps are paused\n  function test_BridgeFacet__xcall_worksIfNoSwapAndSwapPaused() public {\n    // require(false, \"not tested\");\n  }\n\n  // =========== handle / reconcile ==========\n  // NOTE: modifier tests happen in BaseConnext.t.sol. Below are the reconcile (internal fn)\n  // unit tests\n\n  // ============ reconcile fail cases\n\n  // should not process invalid messages\n  function test_BridgeFacet__reconcile_invalidMessage() public {\n    bytes memory _message = bytes(\"\");\n    vm.expectRevert(bytes(\"Validity assertion failed\"));\n    _reconcile(_originDomain, _message);\n  }\n\n  // fails if action is not transfer\n  function test_BridgeFacet__reconcile_invalidTransfer() public {\n    bytes29 tokenId = ConnextMessage.formatTokenId(_canonicalDomain, _canonicalId);\n    bytes29 action = abi\n      .encodePacked(ConnextMessage.Types.Message, bytes32(\"recip\"), uint256(100), bytes32(\"details\"), bytes32(\"id\"))\n      .ref(0)\n      .castTo(uint40(ConnextMessage.Types.Message));\n    bytes29[] memory _views = new bytes29[](2);\n    _views[0] = tokenId;\n    _views[1] = action;\n    bytes memory _message = TypedMemView.join(_views);\n    vm.expectRevert(BridgeFacet.BridgeFacet__reconcile_invalidAction.selector);\n    _reconcile(_originDomain, _message);\n  }\n\n  // fails if already reconciled (s.reconciledTransfers[transferId] = true)\n  function test_BridgeFacet__reconcile_failIfAlreadyReconciled() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.reconciledTransfers[transferId] = true;\n    helpers_reconcileAndAssert(transferId, args, BridgeFacet.BridgeFacet__reconcile_alreadyReconciled.selector);\n  }\n\n  // fails if portal record, but used in slow mode\n  function test_BridgeFacet__reconcile_failsIfPortalAndNoRouter() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    delete s.routedTransfers[transferId];\n\n    // set portal fee debt\n    s.portalDebt[transferId] = 15;\n    s.portalFeeDebt[transferId] = 10;\n\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      BridgeFacet.BridgeFacet__reconcile_noPortalRouter.selector,\n      PortalInfo(10, 15, 25, true)\n    );\n  }\n\n  // ============ reconcile success cases\n  // works with local representational tokens (remote origin, so they will be minted)\n  function test_BridgeFacet__reconcile_worksWithLocal() public {\n    utils_setupAsset(true, false);\n    helpers_reconcileAndAssert();\n  }\n\n  function test_BridgeFacet__reconcile_worksWithCanonical() public {\n    utils_setupAsset(true, true);\n    helpers_reconcileAndAssert();\n  }\n\n  // funds contract when pre-execute (slow liquidity route)\n  function test_BridgeFacet__reconcile_worksPreExecute() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    delete s.routedTransfers[transferId];\n\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // funds router when post-execute (fast liquidity route)\n  function test_BridgeFacet__reconcile_fastLiquiditySingleRouterWorks() public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.routedTransfers[transferId] = [address(42)];\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // funds routers when post-execute multipath (fast liquidity route)\n  function test_BridgeFacet__reconcile_fastLiquidityMultipathWorks() public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.routedTransfers[transferId] = [address(42), address(43), address(44), address(45)];\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // should work with portals without swap\n  function test_BridgeFacet__reconcile_canUsePortalsWithoutSwap() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // should work with portals with swap\n  function test_BridgeFacet__reconcile_canUsePortalsWithSwap() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals, SwapInfo(args.amount - 10000, args.amount));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalSwapFailures() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // assume ratio of 10:1 (i.e. you put in 10x, the amount out from args.amount is 1/10 val)\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      bytes4(\"\"),\n      PortalInfo(0, 0, 0, true),\n      SwapInfo(args.amount * 10, args.amount * 10)\n    );\n  }\n\n  // should credit router leftovers from portal repayment from positive slippage of amm\n  // or previous\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaSwap() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      bytes4(\"\"),\n      portals,\n      SwapInfo(args.amount - 0.01 ether, args.amount + 0.2 ether)\n    );\n  }\n\n  // at some point some of the fee is repaid, remainder goes to router liq\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaFeeRepayment() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    uint256 fullFee = (args.amount * _portalFeeNumerator) / _liquidityFeeDenominator;\n    uint256 paid = fullFee / 2;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled, fullFee - paid);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // at some point some of the principle is repaid, remainder goes to router liq\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaPrincipleRepayment() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    uint256 fee = (args.amount * _portalFeeNumerator) / _liquidityFeeDenominator;\n    uint256 paid = portaled / 2;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled - paid, fee);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // should prioritize debt as: as much principle as possible then as much fee as possible\n  function test_BridgeFacet__reconcile_handlesPortalDeficitPartialPrinciple() public {\n    // in this case, the swap only gives enough out to handle *some* of the amount portaled.\n    // specifically, it can only handle amount < principle\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // set the total debt\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // decrement portal repayment\n    uint256 debtRepaid = (init.debt * 9997) / 10000; // 3bps debt remaining\n    PortalInfo memory repayment = PortalInfo(0, debtRepaid, debtRepaid, true);\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), repayment, SwapInfo(init.total, debtRepaid));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalDeficitPartialFee() public {\n    // in this case, the swap only gives enough out to handle *some* of the amount portaled.\n    // specifically, it can only handle principle < amount < total\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // set the total debt\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    uint256 debtRepaid = (init.total * 9997) / 10000; // 3bps debt remaining\n    PortalInfo memory repayment = PortalInfo(debtRepaid - init.debt, init.debt, debtRepaid, true);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), repayment, SwapInfo(init.total, debtRepaid));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalFailureToRepayFromAave() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // assume no repayment (aave will not be mocked)\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), PortalInfo(0, 0, 0, false));\n  }\n\n  // ============ execute ============\n  // ============ execute fail cases\n\n  // FIXME: move to `BaseConnextFacet.t.sol`\n  // should fail if paused\n  function test_BridgeFacet__execute_failIfPaused() public {\n    // set context\n    s._paused = true;\n\n    // get args\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // expect failure\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__whenNotPaused_paused.selector);\n    this.execute(args);\n  }\n\n  // should fail if msg.sender is not an approved relayer && msg.sender != params.agent\n  function test_BridgeFacet__execute_failIfSenderNotApproved() public {\n    // set context\n    s.approvedRelayers[address(this)] = false;\n\n    // get args\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // expect failure\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_unapprovedSender.selector);\n    this.execute(args);\n  }\n\n  // multipath: should fail if pathLength > maxRouters\n  function test_BridgeFacet__execute_failIfPathLengthGreaterThanMaxRouters() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(s.maxRoutersPerTransfer + 1);\n\n    for (uint256 i; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] += 10 ether;\n    }\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_maxRoutersExceeded.selector);\n    this.execute(args);\n  }\n\n  // should fail if it is a slow transfer (forceSlow = true) and not reconciled\n  function test_BridgeFacet__execute_failIfForceSlowAndNotReconciled() public {\n    _params.forceSlow = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if it is a slow transfer (forceSlow = true) and we try to execute with routers\n  function test_BridgeFacet__execute_failIfForceSlowAndRoutersSet() public {\n    _params.forceSlow = true;\n\n    // Routers providing liquidity implies this is a fast-liquidity transfer. If we're forcing slow,\n    // this should fail.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(2);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if no routers were passed in and not reconciled\n  function test_BridgeFacet__execute_failIfNoRoutersAndNotReconciled() public {\n    // Setting no routers in the execute call means that the transfer must already be reconciled.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router is not approved and ownership is not renounced\n  function test_BridgeFacet__execute_failIfRouterNotApproved() public {\n    s._routerOwnershipRenounced = false;\n\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = false;\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notSupportedRouter.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router signature is invalid\n  function test_BridgeFacet__execute_failIfSignatureInvalid() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // Make invalid args based on (slightly) altered params.\n    _params.originDomain = 1001;\n    (, ExecuteArgs memory invalidArgs) = utils_makeExecuteArgs(4);\n    // The signature of the last router in the group will be invalid.\n    args.routerSignatures[0] = invalidArgs.routerSignatures[0];\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_invalidRouterSignature.selector);\n    this.execute(args);\n  }\n\n  // multipath: should fail if any 1 router's signature is invalid\n  function test_BridgeFacet__execute_failIfAnySignatureInvalid() public {\n    // Using multipath; this should fail if any 1 router signature is invalid.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(4);\n\n    for (uint256 i; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] += 10 ether;\n    }\n\n    // Make invalid args based on (slightly) altered params.\n    _params.originDomain = 1001;\n    (, ExecuteArgs memory invalidArgs) = utils_makeExecuteArgs(4);\n    // The signature of the last router in the group will be invalid.\n    args.routerSignatures[3] = invalidArgs.routerSignatures[3];\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_invalidRouterSignature.selector);\n    this.execute(args);\n  }\n\n  // should fail if it was already executed (s.transferRelayer[transferId] != address(0))\n  function test_BridgeFacet__execute_failIfAlreadyExecuted() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.transferRelayer[transferId] = address(this);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_alreadyExecuted.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router does not have sufficient tokens\n  function test_BridgeFacet__execute_failIfRouterHasInsufficientFunds() public {\n    _amount = 5 ether;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(2);\n\n    s.routerBalances[args.routers[0]][args.local] = 1.5 ether;\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(args);\n  }\n\n  // multipath: should fail if any 1 router has insufficient tokens\n  function test_BridgeFacet__execute_failIfAnyRouterHasInsufficientFunds() public {\n    _amount = 5 ether;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(s.maxRoutersPerTransfer);\n\n    uint256 routerAmountSent = _amount / args.routers.length; // The amount each individual router will send.\n\n    // Set the first router's balance to be (slightly) less than the amount that they'd need to send.\n    s.routerBalances[args.routers[0]][args.local] = routerAmountSent - 0.1 ether;\n    for (uint256 i = 1; i < args.routers.length; i++) {\n      // The other routers have plenty of funds.\n      s.routerBalances[args.routers[i]][args.local] = 50 ether;\n    }\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(args);\n  }\n\n  // should fail if sponsored vault did not fund contract with returned amount\n  function test_BridgeFacet__execute_failIfSponsorVaultLied() public {\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n    for (uint256 i = 0; i < args.routers.length; i++) {\n      // The other routers have plenty of funds.\n      s.routerBalances[args.routers[i]][args.local] = 50 ether;\n    }\n\n    // set mock sponsor vault\n    address vault = address(123456654321);\n    s.sponsorVault = ISponsorVault(vault);\n    // set change\n    vm.mockCall(vault, abi.encodeWithSelector(ISponsorVault.reimburseLiquidityFees.selector), abi.encode(10 ether));\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount.selector);\n    this.execute(args);\n  }\n\n  function test_BridgeFacet__execute_failsIfRouterNotApprovedForPortal() public {\n    _amount = 5 ether;\n\n    (bytes32 _id, ExecuteArgs memory _args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[_args.routers[0]][_args.local] = 4.5 ether;\n\n    // set aave enabled\n    s.aavePool = _aavePool;\n\n    vm.expectRevert(abi.encodeWithSelector(BridgeFacet.BridgeFacet__execute_notApprovedForPortals.selector));\n    this.execute(_args);\n  }\n\n  // ============ execute success cases\n  // should use slow liquidity if specified (forceSlow = true)\n  function test_BridgeFacet__execute_forceSlowWorks() public {\n    // set test params\n    _params.forceSlow = true;\n\n    // get args\n    (bytes32 transferId, ExecuteArgs memory _args) = utils_makeExecuteArgs(0);\n\n    // set reconciled context\n    s.reconciledTransfers[transferId] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, _args);\n  }\n\n  // should use the local asset if specified (receiveLocal = true)\n  function test_BridgeFacet__execute_receiveLocalWorks() public {\n    _params.receiveLocal = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), false);\n  }\n\n  // should work with approved router if router ownership is not renounced\n  function test_BridgeFacet__execute_worksWithLocalAsAdopted() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // works when local != adopted\n  function test_BridgeFacet__execute_worksWithAdopted() public {\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), true);\n  }\n\n  // works when local != adopted, should work with +ve slippage\n  function test_BridgeFacet__execute_worksWithPositiveSlippage() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) + 1 ether, true);\n  }\n\n  // works when local != adopted, should work with -ve slippage\n  function test_BridgeFacet__execute_worksWithNegativeSlippage() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) - 0.01 ether, true);\n  }\n\n  // works when on canonical domain\n  function test_BridgeFacet__execute_worksOnCanonical() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, true);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work when adopted asset is native asset and on canonical\n  // (adopted == wrapper)\n  function test_BridgeFacet__execute_worksWithNativeOnCanonical() public {\n    // set asset context (local == adopted)\n    utils_setupNative(true, true);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work when adopted asset is native asset and on remote\n  // (adopted == wrapper)\n  function test_BridgeFacet__execute_worksWithNativeOnRemote() public {\n    // set asset context (local != adopted)\n    utils_setupNative(false, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), true);\n  }\n\n  // should work with unapproved router if router ownership is renounced\n  function test_BridgeFacet__execute_worksWithUnapprovedIfNoWhitelist() public {\n    s._routerOwnershipRenounced = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = false;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with 0 value\n  function test_BridgeFacet__execute_worksWith0Value() public {\n    _amount = 0;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work if no sponsor vault set\n  function test_BridgeFacet__execute_worksWithoutVault() public {\n    s.sponsorVault = ISponsorVault(address(0));\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should sponsor if fast liquidity is used and sponsor vault set\n  function test_BridgeFacet__execute_worksWithSponsorLiquidity() public {\n    // setup vault\n    uint256 vaultAmount = 10000;\n    MockSponsorVault vault = new MockSponsorVault(vaultAmount);\n    s.sponsorVault = vault;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) + vaultAmount, false);\n  }\n\n  // should sponsor relayer fee in slow liquidity\n  function test_BridgeFacet__execute_sponsorsRelayersSlow() public {\n    // set test vault\n    uint256 vaultAmount = 10000;\n    MockSponsorVault vault = new MockSponsorVault(vaultAmount);\n    s.sponsorVault = vault;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // get args\n    (bytes32 transferId, ExecuteArgs memory _args) = utils_makeExecuteArgs(0);\n\n    // set reconciled context\n    s.reconciledTransfers[transferId] = true;\n\n    helpers_executeAndAssert(transferId, _args);\n  }\n\n  // should work without calldata\n  function test_BridgeFacet__execute_noCalldataWorks() public {\n    _params.callData = bytes(\"\");\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // With no calldata set, this method call should just send funds directly to the user.\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with successful calldata and using fast liquidity\n  function test_BridgeFacet__execute_successfulCalldata() public {\n    // Set the args.to to the mock xapp address, and args.callData to the `fulfill` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // should work with failing calldata : contract call failed\n  function test_BridgeFacet__execute_failingCalldata() public {\n    // Set the args.to to the mock xapp address, and args.callData to the `fail` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fail.selector);\n    _params.to = _xapp;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      false,\n      false,\n      false,\n      false\n    );\n  }\n\n  function test_BridgeFacet__execute_failsIfNoLiquidityAndAaveNotEnabled() public {\n    // get args\n    (bytes32 _id, ExecuteArgs memory _args) = utils_makeExecuteArgs(1);\n\n    // set liquidity context\n    for (uint256 i; i < _args.routers.length; i++) {\n      s.routerBalances[_args.routers[i]][_args.local] = 0 ether;\n    }\n\n    // set aave not enabled\n    s.aavePool = address(0);\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(_args);\n  }\n\n  // should work with a callback\n  function test_BridgeFacet__execute_worksWithCallback() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    _params.callback = address(123456654321);\n    // Set the args.to to the mock xapp address, and args.callData to the `fulfill` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // FIXME: move to Executor.t.sol\n  // should work with failing calldata : recipient `to` is not a contract (should call _handleFailure)\n  function test_BridgeFacet__execute_handleRecipientNotAContract() public {\n    // Setting the calldata to be for fulfill... but obviously, that method should never be called.\n    // Because `to` is not a valid contract address.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n    _params.to = address(42);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // should work if already reconciled (happening in slow liquidity mode, uses\n  // authenticated data)\n  function test_BridgeFacet__execute_handleAlreadyReconciled() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // Set the args.to to the mock xapp address, and args.callData to the\n    // `fulfillWithProperties` fn. This will check to make sure `originDomain` and\n    // `originSender` properties are correctly set.\n    _params.callData = abi.encodeWithSelector(\n      MockXApp.fulfillWithProperties.selector,\n      _local,\n      TEST_MESSAGE,\n      _originDomain,\n      _originSender\n    );\n    _params.to = _xapp;\n\n    // We specify that 0 routers are in the path for this execution.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    // Transfer has already been reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    helpers_executeAndAssert(transferId, args, args.amount, true, true, false, false, false);\n  }\n\n  // multipath: should subtract equally from each router's liquidity\n  function test_BridgeFacet__execute_multipath() public {\n    _amount = 1 ether;\n\n    // Should work if the pathLength == max routers.\n    uint256 pathLength = s.maxRoutersPerTransfer;\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(pathLength);\n\n    // Add initial liquiidty\n    for (uint256 i = 1; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] = 10 ether;\n    }\n    // Sanity check: assuming the multipath is > 1, no router should need to have more than half of the\n    // transfer amount.\n    s.routerBalances[args.routers[0]][args.local] = 0.5 ether;\n\n    uint256 amount = utils_getFastTransferAmount(args.amount);\n    uint256 routerAmountSent = amount / pathLength; // The amount each individual router will send.\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with approved router if router ownership is not renounced\n  function test_BridgeFacet__execute_worksWithAgentAsSender() public {\n    address agent = address(12345654321);\n    _params.agent = agent;\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    s.approvedRelayers[address(this)] = false;\n    helpers_executeAndAssert(transferId, args, true);\n  }\n\n  // can use liquidity from portals\n  function test_BridgeFacet__execute_worksWithAave() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // set liquidity\n    s.routerBalances[args.routers[0]][args.local] = 0;\n\n    // set approval\n    s.routerPermissionInfo.approvedForPortalRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      false,\n      true,\n      false,\n      true,\n      false\n    );\n  }\n\n  // ============ bumpTransfer ============\n  // ============ bumpTransfer fail cases\n\n  // should work with unapproved router if router-whitelist ownership renouncedcanonicalId\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LPToken} from \"../helpers/LPToken.sol\";\nimport {AmplificationUtils} from \"./AmplificationUtils.sol\";\nimport {MathUtils} from \"./MathUtils.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using MathUtils for uint256;\n\n  /*** EVENTS ***/\n\n  event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\n  event AddLiquidity(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(uint256 newAdminFee);\n  event NewSwapFee(uint256 newSwapFee);\n\n  struct Swap {\n    // variables around the ramp management of A,\n    // the amplification coefficient * n * (n - 1)\n    // see https://www.curve.fi/stableswap-paper.pdf for details\n    uint256 initialA;\n    uint256 futureA;\n    uint256 initialATime;\n    uint256 futureATime;\n    // fee calculation\n    uint256 swapFee;\n    uint256 adminFee;\n    LPToken lpToken;\n    // contract references for all tokens being pooled\n    IERC20[] pooledTokens;\n    // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n    // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n    // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n    uint256[] tokenPrecisionMultipliers;\n    // the pool balance of each token, in the token's precision\n    // the contract's actual token balance might differ\n    uint256[] balances;\n    // the admin fee balance of each token, in the token's precision\n    uint256[] adminFees;\n  }\n\n  // Struct storing variables used in calculations in the\n  // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n  struct CalculateWithdrawOneTokenDYInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 newY;\n    uint256 feePerToken;\n    uint256 preciseA;\n  }\n\n  // Struct storing variables used in calculations in the\n  // {add,remove}Liquidity functions to avoid stack too deep errors\n  struct ManageLiquidityInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 d2;\n    uint256 preciseA;\n    LPToken lpToken;\n    uint256 totalSupply;\n    uint256[] balances;\n    uint256[] multipliers;\n  }\n\n  // the precision all pools tokens will be converted to\n  uint8 internal constant POOL_PRECISION_DECIMALS = 18;\n\n  // the denominator used to calculate admin and LP fees. For example, an\n  // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n  uint256 internal constant FEE_DENOMINATOR = 10**10;\n\n  // Max swap fee is 1% or 100bps of each swap\n  uint256 internal constant MAX_SWAP_FEE = 10**8;\n\n  // Max adminFee is 100% of the swapFee\n  // adminFee does not add additional fee on top of swapFee\n  // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n  // users but only on the earnings of LPs\n  uint256 internal constant MAX_ADMIN_FEE = 10**10;\n\n  // Constant value used as max loop limit\n  uint256 internal constant MAX_LOOP_LIMIT = 256;\n\n  /*** VIEW & PURE FUNCTIONS ***/\n\n  function _getAPrecise(Swap storage self) private view returns (uint256) {\n    return AmplificationUtils._getAPrecise(self);\n  }\n\n  /**\n   * @notice Calculate the dy, the amount of selected token that user receives and\n   * the fee of withdrawing in one token\n   * @param tokenAmount the amount to withdraw in the pool's precision\n   * @param tokenIndex which token will be withdrawn\n   * @param self Swap struct to read from\n   * @return the amount of token user will receive\n   */\n  function calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) internal view returns (uint256) {\n    (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n      self,\n      tokenAmount,\n      tokenIndex,\n      self.lpToken.totalSupply()\n    );\n    return availableTokenAmount;\n  }\n\n  function _calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 totalSupply\n  ) private view returns (uint256, uint256) {\n    uint256 dy;\n    uint256 newY;\n    uint256 currentY;\n\n    (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\n\n    // dy_0 (without fees)\n    // dy, dy_0 - dy\n\n    uint256 dySwapFee = currentY.sub(newY).div(self.tokenPrecisionMultipliers[tokenIndex]).sub(dy);\n\n    return (dy, dySwapFee);\n  }\n\n  /**\n   * @notice Calculate the dy of withdrawing in one token\n   * @param self Swap struct to read from\n   * @param tokenIndex which token will be withdrawn\n   * @param tokenAmount the amount to withdraw in the pools precision\n   * @return the d and the new y after withdrawing one token\n   */\n  function calculateWithdrawOneTokenDY(\n    Swap storage self,\n    uint8 tokenIndex,\n    uint256 tokenAmount,\n    uint256 totalSupply\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    // Get the current D, then solve the stableswap invariant\n    // y_i for D - tokenAmount\n    uint256[] memory xp = _xp(self);\n\n    require(tokenIndex < xp.length, \"Token index out of range\");\n\n    CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n    v.preciseA = _getAPrecise(self);\n    v.d0 = getD(xp, v.preciseA);\n    v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\n\n    require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n    v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n    uint256[] memory xpReduced = new uint256[](xp.length);\n\n    v.feePerToken = _feePerToken(self.swapFee, xp.length);\n    for (uint256 i = 0; i < xp.length; i++) {\n      uint256 xpi = xp[i];\n      // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n      // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n      // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n      xpReduced[i] = xpi.sub(\n        ((i == tokenIndex) ? xpi.mul(v.d1).div(v.d0).sub(v.newY) : xpi.sub(xpi.mul(v.d1).div(v.d0)))\n          .mul(v.feePerToken)\n          .div(FEE_DENOMINATOR)\n      );\n    }\n\n    uint256 dy = xpReduced[tokenIndex].sub(getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\n    dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n\n    return (dy, v.newY, xp[tokenIndex]);\n  }\n\n  /**\n   * @notice Calculate the price of a token in the pool with given\n   * precision-adjusted balances and a particular D.\n   *\n   * @dev This is accomplished via solving the invariant iteratively.\n   * See the StableSwap paper and Curve.fi implementation for further details.\n   *\n   * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n   * x_1**2 + b*x_1 = c\n   * x_1 = (x_1**2 + c) / (2*x_1 + b)\n   *\n   * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n   * @param tokenIndex Index of token we are calculating for.\n   * @param xp a precision-adjusted set of pool balances. Array should be\n   * the same cardinality as the pool.\n   * @param d the stableswap invariant\n   * @return the price of the token, in the same precision as in xp\n   */\n  function getYD(\n    uint256 a,\n    uint8 tokenIndex,\n    uint256[] memory xp,\n    uint256 d\n  ) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndex < numTokens, \"Token not found\");\n\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = a.mul(numTokens);\n\n    for (uint256 i = 0; i < numTokens; i++) {\n      if (i != tokenIndex) {\n        s = s.add(xp[i]);\n        c = c.mul(d).div(xp[i].mul(numTokens));\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // c = c * D * D * D * ... overflow!\n      }\n    }\n    c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\n\n    uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\n    uint256 yPrev;\n    uint256 y = d;\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      yPrev = y;\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n      if (y.within1(yPrev)) {\n        return y;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n   * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n   * as the pool.\n   * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n   * See the StableSwap paper for details\n   * @return the invariant, at the precision of the pool\n   */\n  function getD(uint256[] memory xp, uint256 a) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    uint256 s;\n    for (uint256 i = 0; i < numTokens; i++) {\n      s = s.add(xp[i]);\n    }\n    if (s == 0) {\n      return 0;\n    }\n\n    uint256 prevD;\n    uint256 d = s;\n    uint256 nA = a.mul(numTokens);\n\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      uint256 dP = d;\n      for (uint256 j = 0; j < numTokens; j++) {\n        dP = dP.mul(d).div(xp[j].mul(numTokens));\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // dP = dP * D * D * D * ... overflow!\n      }\n      prevD = d;\n      d = nA.mul(s).div(AmplificationUtils.A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\n        nA.sub(AmplificationUtils.A_PRECISION).mul(d).div(AmplificationUtils.A_PRECISION).add(numTokens.add(1).mul(dP))\n      );\n      if (d.within1(prevD)) {\n        return d;\n      }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    revert(\"D does not converge\");\n  }\n\n  /**\n   * @notice Given a set of balances and precision multipliers, return the\n   * precision-adjusted balances.\n   *\n   * @param balances an array of token balances, in their native precisions.\n   * These should generally correspond with pooled tokens.\n   *\n   * @param precisionMultipliers an array of multipliers, corresponding to\n   * the amounts in the balances array. When multiplied together they\n   * should yield amounts at the pool's precision.\n   *\n   * @return an array of amounts \"scaled\" to the pool's precision\n   */\n  function _xp(uint256[] memory balances, uint256[] memory precisionMultipliers)\n    internal\n    pure\n    returns (uint256[] memory)\n  {\n    uint256 numTokens = balances.length;\n    require(numTokens == precisionMultipliers.length, \"Balances must match multipliers\");\n    uint256[] memory xp = new uint256[](numTokens);\n    for (uint256 i = 0; i < numTokens; i++) {\n      xp[i] = balances[i].mul(precisionMultipliers[i]);\n    }\n    return xp;\n  }\n\n  /**\n   * @notice Return the precision-adjusted balances of all tokens in the pool\n   * @param self Swap struct to read from\n   * @return the pool balances \"scaled\" to the pool's precision, allowing\n   * them to be more easily compared.\n   */\n  function _xp(Swap storage self) internal view returns (uint256[] memory) {\n    return _xp(self.balances, self.tokenPrecisionMultipliers);\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param self Swap struct to read from\n   * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n   */\n  function getVirtualPrice(Swap storage self) internal view returns (uint256) {\n    uint256 d = getD(_xp(self), _getAPrecise(self));\n    LPToken lpToken = self.lpToken;\n    uint256 supply = lpToken.totalSupply();\n    if (supply > 0) {\n      return d.mul(10**uint256(POOL_PRECISION_DECIMALS)).div(supply);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Calculate the new balances of the tokens given the indexes of the token\n   * that is swapped from (FROM) and the token that is swapped to (TO).\n   * This function is used as a helper function to calculate how much TO token\n   * the user should receive on swap.\n   *\n   * @param preciseA precise form of amplification coefficient\n   * @param tokenIndexFrom index of FROM token\n   * @param tokenIndexTo index of TO token\n   * @param x the new total amount of FROM token\n   * @param xp balances of the tokens in the pool\n   * @return the amount of TO token that should remain in the pool\n   */\n  function getY(\n    uint256 preciseA,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 x,\n    uint256[] memory xp\n  ) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndexFrom != tokenIndexTo, \"Can't compare token to itself\");\n    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"Tokens must be in pool\");\n\n    uint256 d = getD(xp, preciseA);\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = numTokens.mul(preciseA);\n\n    uint256 _x;\n    for (uint256 i = 0; i < numTokens; i++) {\n      if (i == tokenIndexFrom) {\n        _x = x;\n      } else if (i != tokenIndexTo) {\n        _x = xp[i];\n      } else {\n        continue;\n      }\n      s = s.add(_x);\n      c = c.mul(d).div(_x.mul(numTokens));\n      // If we were to protect the division loss we would have to keep the denominator separate\n      // and divide at the end. However this leads to overflow with large numTokens or/and D.\n      // c = c * D * D * D * ... overflow!\n    }\n    c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\n    uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\n    uint256 yPrev;\n    uint256 y = d;\n\n    // iterative approximation\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      yPrev = y;\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n      if (y.within1(yPrev)) {\n        return y;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   */\n  function calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) internal view returns (uint256 dy) {\n    (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy.\n   * @return dx the number of tokens the user have to transfer + fee\n   */\n  function calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy\n  ) internal view returns (uint256 dx) {\n    (dx, ) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, self.balances);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   * @return dyFee the associated fee\n   */\n  function _calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256[] memory balances\n  ) internal view returns (uint256 dy, uint256 dyFee) {\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\n    uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\n    uint256 y = getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n    dy = xp[tokenIndexTo].sub(y).sub(1);\n    dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n    dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dx the number of tokens the user have to deposit\n   * @return dxFee the associated fee\n   */\n  function _calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256[] memory balances\n  ) internal view returns (uint256 dx, uint256 dxFee) {\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\n\n    uint256 a = _getAPrecise(self);\n    uint256 d0 = getD(xp, a);\n\n    xp[tokenIndexTo] = xp[tokenIndexTo].sub(dy.mul(multipliers[tokenIndexTo]));\n    uint256 x = getYD(a, tokenIndexFrom, xp, d0);\n    dx = x.sub(xp[tokenIndexFrom]).add(1);\n    dxFee = dx.mul(self.swapFee).div(FEE_DENOMINATOR);\n    dx = dx.add(dxFee).div(multipliers[tokenIndexFrom]);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of\n   * LP tokens\n   *\n   * @param amount the amount of LP tokens that would to be burned on\n   * withdrawal\n   * @return array of amounts of tokens user will receive\n   */\n  function calculateRemoveLiquidity(Swap storage self, uint256 amount) internal view returns (uint256[] memory) {\n    return _calculateRemoveLiquidity(self.balances, amount, self.lpToken.totalSupply());\n  }\n\n  function _calculateRemoveLiquidity(\n    uint256[] memory balances,\n    uint256 amount,\n    uint256 totalSupply\n  ) internal pure returns (uint256[] memory) {\n    require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n    uint256[] memory amounts = new uint256[](balances.length);\n\n    for (uint256 i = 0; i < balances.length; i++) {\n      amounts[i] = balances[i].mul(amount).div(totalSupply);\n    }\n    return amounts;\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param self Swap struct to read from\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return if deposit was true, total amount of lp token that will be minted and if\n   * deposit was false, total amount of lp token that will be burned\n   */\n  function calculateTokenAmount(\n    Swap storage self,\n    uint256[] calldata amounts,\n    bool deposit\n  ) internal view returns (uint256) {\n    uint256 a = _getAPrecise(self);\n    uint256[] memory balances = self.balances;\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n\n    uint256 d0 = getD(_xp(balances, multipliers), a);\n    for (uint256 i = 0; i < balances.length; i++) {\n      if (deposit) {\n        balances[i] = balances[i].add(amounts[i]);\n      } else {\n        balances[i] = balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\n      }\n    }\n    uint256 d1 = getD(_xp(balances, multipliers), a);\n    uint256 totalSupply = self.lpToken.totalSupply();\n\n    if (deposit) {\n      return d1.sub(d0).mul(totalSupply).div(d0);\n    } else {\n      return d0.sub(d1).mul(totalSupply).div(d0);\n    }\n  }\n\n  /**\n   * @notice return accumulated amount of admin fees of the token with given index\n   * @param self Swap struct to read from\n   * @param index Index of the pooled token\n   * @return admin balance in the token's precision\n   */\n  function getAdminBalance(Swap storage self, uint256 index) internal view returns (uint256) {\n    require(index < self.pooledTokens.length, \"Token index out of range\");\n    return self.adminFees[index];\n  }\n\n  /**\n   * @notice internal helper function to calculate fee per token multiplier used in\n   * swap fee calculations\n   * @param swapFee swap fee for the tokens\n   * @param numTokens number of tokens pooled\n   */\n  function _feePerToken(uint256 swapFee, uint256 numTokens) internal pure returns (uint256) {\n    return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) internal returns (uint256) {\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n      // Transfer tokens first to see if a fee was charged on transfer\n      uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n      tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n      // Use the actual transferred amount for AMM math\n      dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);\n    }\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n    uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexTo]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\n    if (dyAdminFee > 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo].add(dyAdminFee);\n    }\n\n    self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dy the amount of tokens the user wants to buy\n   * @param maxDx the max amount the user would like to send.\n   * @return amount of token user have to transfer on swap\n   */\n  function swapOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) internal returns (uint256) {\n    require(dy <= self.balances[tokenIndexTo], \"Cannot get more than pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"Swap needs more than max tokens\");\n\n    uint256 dxAdminFee = dxFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexFrom]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx).sub(dxAdminFee);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy);\n    if (dxAdminFee > 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom].add(dxAdminFee);\n    }\n\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n      // Transfer tokens first to see if a fee was charged on transfer\n      uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n      tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n      // Use the actual transferred amount for AMM math\n      require(dx == tokenFrom.balanceOf(address(this)).sub(beforeBalance), \"not support fee token\");\n    }\n\n    self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice swap two tokens in the pool internally\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swapInternal(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) internal returns (uint256) {\n    IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n    require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n    uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexTo]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\n\n    if (dyAdminFee > 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo].add(dyAdminFee);\n    }\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice Should get exact amount out of AMM for asset put in\n   */\n  function swapInternalOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) internal returns (uint256) {\n    require(dy <= self.balances[tokenIndexTo], \"Cannot get more than pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"Swap didn't result in min tokens\");\n\n    uint256 dxAdminFee = dxFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexFrom]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx).sub(dxAdminFee);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy);\n\n    if (dxAdminFee > 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom].add(dxAdminFee);\n    }\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice Add liquidity to the pool\n   * @param self Swap struct to read from and write to\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n   * @return amount of LP token user received\n   */\n  function addLiquidity(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 minToMint\n  ) internal returns (uint256) {\n    IERC20[] memory pooledTokens = self.pooledTokens;\n    require(amounts.length == pooledTokens.length, \"Amounts must match pooled tokens\");\n\n    // current state\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n\n    if (v.totalSupply != 0) {\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n    }\n\n    uint256[] memory newBalances = new uint256[](pooledTokens.length);\n\n    for (uint256 i = 0; i < pooledTokens.length; i++) {\n      require(v.totalSupply != 0 || amounts[i] > 0, \"Must supply all tokens in pool\");\n\n      // Transfer tokens first to see if a fee was charged on transfer\n      if (amounts[i] != 0) {\n        uint256 beforeBalance = pooledTokens[i].balanceOf(address(this));\n        pooledTokens[i].safeTransferFrom(msg.sender, address(this), amounts[i]);\n\n        // Update the amounts[] with actual transfer amount\n        amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(beforeBalance);\n      }\n\n      newBalances[i] = v.balances[i].add(amounts[i]);\n    }\n\n    // invariant after change\n    v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    require(v.d1 > v.d0, \"D should increase\");\n\n    // updated to reflect fees and calculate the user's LP tokens\n    v.d2 = v.d1;\n    uint256[] memory fees = new uint256[](pooledTokens.length);\n\n    if (v.totalSupply != 0) {\n      uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n      for (uint256 i = 0; i < pooledTokens.length; i++) {\n        uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n        fees[i] = feePerToken.mul(idealBalance.difference(newBalances[i])).div(FEE_DENOMINATOR);\n        uint256 adminFee = fees[i].mul(self.adminFee).div(FEE_DENOMINATOR);\n        self.balances[i] = newBalances[i].sub(adminFee);\n        self.adminFees[i] = self.adminFees[i].add(adminFee);\n        newBalances[i] = newBalances[i].sub(fees[i]);\n      }\n      v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    } else {\n      // the initial depositor doesn't pay fees\n      self.balances = newBalances;\n    }\n\n    uint256 toMint;\n    if (v.totalSupply == 0) {\n      toMint = v.d1;\n    } else {\n      toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\n    }\n\n    require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n    // mint the user's LP tokens\n    v.lpToken.mint(msg.sender, toMint);\n\n    emit AddLiquidity(msg.sender, amounts, fees, v.d1, v.totalSupply.add(toMint));\n\n    return toMint;\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param self Swap struct to read from and write to\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   * acceptable for this burn. Useful as a front-running mitigation\n   * @return amounts of tokens the user received\n   */\n  function removeLiquidity(\n    Swap storage self,\n    uint256 amount,\n    uint256[] calldata minAmounts\n  ) internal returns (uint256[] memory) {\n    LPToken lpToken = self.lpToken;\n    IERC20[] memory pooledTokens = self.pooledTokens;\n    require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    require(minAmounts.length == pooledTokens.length, \"minAmounts must match poolTokens\");\n\n    uint256[] memory balances = self.balances;\n    uint256 totalSupply = lpToken.totalSupply();\n\n    uint256[] memory amounts = _calculateRemoveLiquidity(balances, amount, totalSupply);\n\n    for (uint256 i = 0; i < amounts.length; i++) {\n      require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n      self.balances[i] = balances[i].sub(amounts[i]);\n      pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n    }\n\n    lpToken.burnFrom(msg.sender, amount);\n\n    emit RemoveLiquidity(msg.sender, amounts, totalSupply.sub(amount));\n\n    return amounts;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token.\n   * @param self Swap struct to read from and write to\n   * @param tokenAmount the amount of the lp tokens to burn\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @return amount chosen token that user received\n   */\n  function removeLiquidityOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount\n  ) internal returns (uint256) {\n    LPToken lpToken = self.lpToken;\n    IERC20[] memory pooledTokens = self.pooledTokens;\n\n    require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    require(tokenIndex < pooledTokens.length, \"Token not found\");\n\n    uint256 totalSupply = lpToken.totalSupply();\n\n    (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(self, tokenAmount, tokenIndex, totalSupply);\n\n    require(dy >= minAmount, \"dy < minAmount\");\n\n    uint256 adminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);\n    self.balances[tokenIndex] = self.balances[tokenIndex].sub(dy.add(adminFee));\n    if (adminFee > 0) {\n      self.adminFees[tokenIndex] = self.adminFees[tokenIndex].add(adminFee);\n    }\n    lpToken.burnFrom(msg.sender, tokenAmount);\n    pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n\n    emit RemoveLiquidityOne(msg.sender, tokenAmount, totalSupply, tokenIndex, dy);\n\n    return dy;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances.\n   *\n   * @param self Swap struct to read from and write to\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @return actual amount of LP tokens burned in the withdrawal\n   */\n  function removeLiquidityImbalance(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 maxBurnAmount\n  ) internal returns (uint256) {\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n\n    IERC20[] memory pooledTokens = self.pooledTokens;\n\n    require(amounts.length == pooledTokens.length, \"Amounts should match pool tokens\");\n\n    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \">LP.balanceOf\");\n\n    uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n    uint256[] memory fees = new uint256[](pooledTokens.length);\n    {\n      uint256[] memory balances1 = new uint256[](pooledTokens.length);\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n      for (uint256 i = 0; i < pooledTokens.length; i++) {\n        balances1[i] = v.balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\n      }\n      v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n      for (uint256 i = 0; i < pooledTokens.length; i++) {\n        uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n        uint256 difference = idealBalance.difference(balances1[i]);\n        fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n        uint256 adminFee = fees[i].mul(self.adminFee).div(FEE_DENOMINATOR);\n        self.balances[i] = balances1[i].sub(adminFee);\n        self.adminFees[i] = self.adminFees[i].add(adminFee);\n        balances1[i] = balances1[i].sub(fees[i]);\n      }\n\n      v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n    }\n    uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n    require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n    tokenAmount = tokenAmount.add(1);\n\n    require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n    v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n    for (uint256 i = 0; i < pooledTokens.length; i++) {\n      pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n    }\n\n    emit RemoveLiquidityImbalance(msg.sender, amounts, fees, v.d1, v.totalSupply.sub(tokenAmount));\n\n    return tokenAmount;\n  }\n\n  /**\n   * @notice withdraw all admin fees to a given address\n   * @param self Swap struct to withdraw fees from\n   * @param to Address to send the fees to\n   */\n  function withdrawAdminFees(Swap storage self, address to) internal {\n    IERC20[] memory pooledTokens = self.pooledTokens;\n    for (uint256 i = 0; i < pooledTokens.length; i++) {\n      IERC20 token = pooledTokens[i];\n      uint256 balance = self.adminFees[i];\n      if (balance != 0) {\n        token.safeTransfer(to, balance);\n      }\n    }\n  }\n\n  /**\n   * @notice Sets the admin fee\n   * @dev adminFee cannot be higher than 100% of the swap fee\n   * @param self Swap struct to update\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setAdminFee(Swap storage self, uint256 newAdminFee) internal {\n    require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\n    self.adminFee = newAdminFee;\n\n    emit NewAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice update the swap fee\n   * @dev fee cannot be higher than 1% of each swap\n   * @param self Swap struct to update\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(Swap storage self, uint256 newSwapFee) internal {\n    require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\n    self.swapFee = newSwapFee;\n\n    emit NewSwapFee(newSwapFee);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20, IERC20, Address} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {ITokenRegistry} from \"../interfaces/ITokenRegistry.sol\";\n\nimport {ConnextMessage} from \"./ConnextMessage.sol\";\nimport {LibConnextStorage, AppStorage} from \"./LibConnextStorage.sol\";\nimport {SwapUtils} from \"./SwapUtils.sol\";\n\nlibrary AssetLogic {\n  // ============ Libraries ============\n  using SwapUtils for SwapUtils.Swap;\n\n  // ============ Errors ============\n\n  error AssetLogic__handleIncomingAsset_notAmount();\n  error AssetLogic__handleIncomingAsset_ethWithErcTransfer();\n  error AssetLogic__transferAssetFromContract_notNative();\n  error AssetLogic__swapToLocalAssetIfNeeded_swapPaused();\n  error AssetLogic__swapFromLocalAssetIfNeeded_swapPaused();\n  error AssetLogic__getTokenIndexFromStableSwapPool_notExist();\n\n  // ============ Internal ============\n\n  /**\n   * @notice Check if the stabelswap pool exists or not\n   * @param canonicalId the canonical token id\n   */\n  function stableSwapPoolExist(bytes32 canonicalId) internal view returns (bool) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n    return s.swapStorages[canonicalId].pooledTokens.length != 0;\n  }\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param canonicalId the canonical token id\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getTokenIndexFromStableSwapPool(bytes32 canonicalId, address tokenAddress) internal view returns (uint8) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n    uint8 index = s.tokenIndexes[canonicalId][tokenAddress];\n    if (address(s.swapStorages[canonicalId].pooledTokens[index]) != tokenAddress)\n      revert AssetLogic__getTokenIndexFromStableSwapPool_notExist();\n    return index;\n  }\n\n  /**\n   * @notice Handles transferring funds from msg.sender to the Connext contract.\n   * @dev If using the native asset, will automatically wrap\n   * @param _assetId - The address to transfer\n   * @param _assetAmount - The specified amount to transfer. May not be the\n   * actual amount transferred (i.e. fee on transfer tokens)\n   * @param _fee - The fee amount in native asset included as part of the transaction that\n   * should not be considered for the transfer amount.\n   * @return The assetId of the transferred asset\n   * @return The amount of the asset that was seen by the contract (may not be the specifiedAmount\n   * if the token is a fee-on-transfer token)\n   */\n  function handleIncomingAsset(\n    address _assetId,\n    uint256 _assetAmount,\n    uint256 _fee\n  ) internal returns (address, uint256) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    uint256 trueAmount = _assetAmount;\n\n    if (_assetId == address(0)) {\n      if (msg.value != _assetAmount + _fee) revert AssetLogic__handleIncomingAsset_notAmount();\n\n      // When transferring native asset to the contract, always make sure that the\n      // asset is properly wrapped\n      wrapNativeAsset(_assetAmount);\n      _assetId = address(s.wrapper);\n    } else {\n      if (msg.value != _fee) revert AssetLogic__handleIncomingAsset_ethWithErcTransfer();\n\n      // Transfer asset to contract\n      trueAmount = transferAssetToContract(_assetId, _assetAmount);\n    }\n\n    return (_assetId, trueAmount);\n  }\n\n  /**\n   * @notice Wrap the native asset\n   * @param _amount - The specified amount to wrap\n   */\n  function wrapNativeAsset(uint256 _amount) internal {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    s.wrapper.deposit{value: _amount}();\n  }\n\n  /**\n   * @notice Transfer asset funds from msg.sender to the Connext contract.\n   * @param _assetId - The address to transfer\n   * @param _amount - The specified amount to transfer\n   * @return The amount of the asset that was seen by the contract\n   */\n  function transferAssetToContract(address _assetId, uint256 _amount) internal returns (uint256) {\n    // Validate correct amounts are transferred\n    uint256 starting = IERC20(_assetId).balanceOf(address(this));\n\n    SafeERC20.safeTransferFrom(IERC20(_assetId), msg.sender, address(this), _amount);\n    // Calculate the *actual* amount that was sent here\n    return IERC20(_assetId).balanceOf(address(this)) - starting;\n  }\n\n  /**\n   * @notice Handles transferring funds from msg.sender to the Connext contract.\n   * @dev If using the native asset, will automatically unwrap\n   * @param _assetId - The address to transfer\n   * @param _to - The account that will receive the withdrawn funds\n   * @param _amount - The amount to withdraw from contract\n   */\n  function transferAssetFromContract(\n    address _assetId,\n    address _to,\n    uint256 _amount\n  ) internal {\n    // If amount is 0 do nothing\n    if (_amount == 0) {\n      return;\n    }\n\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // No native assets should ever be stored on this contract\n    if (_assetId == address(0)) revert AssetLogic__transferAssetFromContract_notNative();\n\n    if (_assetId == address(s.wrapper)) {\n      // If dealing with wrapped assets, make sure they are properly unwrapped\n      // before sending from contract\n      s.wrapper.withdraw(_amount);\n      Address.sendValue(payable(_to), _amount);\n    } else {\n      // Transfer ERC20 asset\n      SafeERC20.safeTransfer(IERC20(_assetId), _to, _amount);\n    }\n  }\n\n  /**\n   * @notice Swaps an adopted asset to the local (representation or canonical) nomad asset\n   * @dev Will not swap if the asset passed in is the local asset\n   * @param _canonical - The canonical token\n   * @param _asset - The address of the adopted asset to swap into the local asset\n   * @param _amount - The amount of the adopted asset to swap\n   * @param _slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n   * @return The amount of local asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function swapToLocalAssetIfNeeded(\n    ConnextMessage.TokenId memory _canonical,\n    address _asset,\n    uint256 _amount,\n    uint256 _slippageTol\n  ) internal returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the local token for this domain (may return canonical or representation).\n    address local = s.tokenRegistry.getLocalAddress(_canonical.domain, _canonical.id);\n\n    // If there's no amount, no need to swap.\n    if (_amount == 0) {\n      return (_amount, local);\n    }\n\n    // Check the case where the adopted asset *is* the local asset. If so, no need to swap.\n    if (local == _asset) {\n      return (_amount, _asset);\n    }\n\n    // Swap the asset to the proper local asset.\n    return _swapAsset(_canonical.id, _asset, local, _amount, _slippageTol);\n  }\n\n  /**\n   * @notice Swaps a local nomad asset for the adopted asset using the stored stable swap\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _asset - The address of the local asset to swap into the adopted asset\n   * @param _amount - The amount of the local asset to swap\n   * @param _slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n   * @return The amount of adopted asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function swapFromLocalAssetIfNeeded(\n    address _asset,\n    uint256 _amount,\n    uint256 _slippageTol\n  ) internal returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (_amount, _asset);\n    }\n\n    // If 0 valued, do nothing\n    if (_amount == 0) {\n      return (_amount, adopted);\n    }\n\n    // Swap the asset to the proper local asset\n    return _swapAsset(id, _asset, adopted, _amount, _slippageTol);\n  }\n\n  /**\n   * @notice Swaps a local nomad asset for the adopted asset using the stored stable swap\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _asset - The address of the local asset to swap into the adopted asset\n   * @param _amount - The exact amount to receive out of the swap\n   * @return The amount of local asset put into  swap\n   * @return The address of asset received post-swap\n   */\n  function swapFromLocalAssetIfNeededForExactOut(\n    address _asset,\n    uint256 _amount,\n    uint256 _maxIn\n  )\n    internal\n    returns (\n      bool,\n      uint256,\n      address\n    )\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (true, _amount, _asset);\n    }\n\n    return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);\n  }\n\n  /**\n   * @notice Swaps assetIn t assetOut using the stored stable swap or internal swap pool\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _canonicalId - The canonical token id\n   * @param _assetIn - The address of the from asset\n   * @param _assetOut - The address of the to asset\n   * @param _amount - The amount of the local asset to swap\n   * @return The amount of assetOut\n   * @return The address of assetOut\n   */\n  function _swapAsset(\n    bytes32 _canonicalId,\n    address _assetIn,\n    address _assetOut,\n    uint256 _amount,\n    uint256 _slippageTol\n  ) internal returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Swap the asset to the proper local asset\n    uint256 minReceived = (_amount * _slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    if (stableSwapPoolExist(_canonicalId)) {\n      // if internal swap pool exists\n      return (\n        s.swapStorages[_canonicalId].swapInternal(\n          getTokenIndexFromStableSwapPool(_canonicalId, _assetOut),\n          getTokenIndexFromStableSwapPool(_canonicalId, _assetIn),\n          _amount,\n          minReceived\n        ),\n        _assetOut\n      );\n    } else {\n      // Otherwise, swap via stable swap pool\n      IStableSwap pool = s.adoptedToLocalPools[_canonicalId];\n      SafeERC20.safeIncreaseAllowance(IERC20(_assetIn), address(pool), _amount);\n\n      return (pool.swapExact(_amount, _assetIn, _assetOut, minReceived), _assetOut);\n    }\n  }\n\n  /**\n   * @notice Swaps assetIn t assetOut using the stored stable swap or internal swap pool\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _canonicalId - The canonical token id\n   * @param _assetIn - The address of the from asset\n   * @param _assetOut - The address of the to asset\n   * @param _amountOut - The amount of the _assetOut to swap\n   * @return The amount of assetIn\n   * @return The address of assetOut\n   */\n  function _swapAssetOut(\n    bytes32 _canonicalId,\n    address _assetIn,\n    address _assetOut,\n    uint256 _amountOut,\n    uint256 _maxIn\n  )\n    internal\n    returns (\n      bool,\n      uint256,\n      address\n    )\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    bool success;\n    uint256 amountIn;\n\n    // Swap the asset to the proper local asset\n    if (stableSwapPoolExist(_canonicalId)) {\n      // get internal swap pool\n      SwapUtils.Swap storage ipool = s.swapStorages[_canonicalId];\n      // if internal swap pool exists\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_canonicalId, _assetIn);\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_canonicalId, _assetOut);\n      // calculate slippage before performing swap\n      // NOTE: this is less efficient then relying on the `swapInternalOut` revert, but makes it easier\n      // to handle slippage failures (this can be called during reconcile, so must not fail)\n      if (_maxIn >= ipool.calculateSwapInv(tokenIndexIn, tokenIndexOut, _amountOut)) {\n        success = true;\n        amountIn = ipool.swapInternalOut(tokenIndexIn, tokenIndexOut, _amountOut, _maxIn);\n      }\n      // slippage is too high to perform swap: success = false, amountIn = 0\n    } else {\n      // Otherwise, swap via stable swap pool\n      IStableSwap pool = s.adoptedToLocalPools[_canonicalId];\n      uint256 _amountIn = pool.calculateSwapOutFromAddress(_assetIn, _assetOut, _amountOut);\n      if (_amountIn <= _maxIn) {\n        // set the success\n        success = true;\n\n        // perform the swap\n        SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn);\n        amountIn = pool.swapExactOut(_amountOut, _assetIn, _assetOut, _maxIn);\n      }\n      // slippage is too high to perform swap: success = false, amountIn = 0\n    }\n\n    return (success, amountIn, _assetOut);\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on a local nomad asset for the adopted asset\n   * using the stored stable swap\n   * @dev Will not use the stored stable swap if the asset passed in is the local asset\n   * @param _asset - The address of the local asset to swap into the local asset\n   * @param _amount - The amount of the local asset to swap\n   * @return The amount of local asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function calculateSwapFromLocalAssetIfNeeded(address _asset, uint256 _amount)\n    internal\n    view\n    returns (uint256, address)\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (_amount, _asset);\n    }\n\n    // Otherwise, calculate swap the asset to the proper local asset\n    if (stableSwapPoolExist(id)) {\n      // if internal swap pool exists\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(id, _asset);\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(id, adopted);\n      return (s.swapStorages[id].calculateSwap(tokenIndexIn, tokenIndexOut, _amount), adopted);\n    } else {\n      IStableSwap pool = s.adoptedToLocalPools[id];\n\n      return (pool.calculateSwapFromAddress(_asset, adopted, _amount), adopted);\n    }\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive of a local nomad asset for the adopted asset\n   * using the stored stable swap\n   * @dev Will not use the stored stable swap if the asset passed in is the local asset\n   * @param _asset - The address of the asset to swap into the local asset\n   * @param _amount - The amount of the asset to swap\n   * @return The amount of local asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function calculateSwapToLocalAssetIfNeeded(address _asset, uint256 _amount) internal view returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (uint32 domain, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n    address local = s.tokenRegistry.getLocalAddress(domain, id);\n\n    // If the asset is the local asset, no swap needed\n    if (_asset == local) {\n      return (_amount, _asset);\n    }\n\n    // Otherwise, calculate swap the asset to the proper local asset\n    if (stableSwapPoolExist(id)) {\n      // if internal swap pool exists\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(id, _asset);\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(id, local);\n      return (s.swapStorages[id].calculateSwap(tokenIndexIn, tokenIndexOut, _amount), local);\n    } else {\n      IStableSwap pool = s.adoptedToLocalPools[id];\n\n      return (pool.calculateSwapFromAddress(_asset, local, _amount), local);\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n",
        "CodeNames": [
            "AssetLogic.t.sol",
            "BridgeFacet.t.sol",
            "SwapUtils.sol",
            "AssetLogic.sol",
            "BridgeFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "swapAsset() function in BridgeFacet.sol, AssetLogic.sol, and SwapUtils.sol",
                "Type": "Incorrect argument ordering",
                "Description": "The swapAsset() function facilitates two swaps, either using the internal or external pool. But if an internal pool exists, a swap will be unsuccessful because the call to s.swapStorages[_canonicalId].swapInternal() takes two incorrect arguments due to an incorrect ordering.",
                "Repair": "Correct the argument ordering in the swapAsset() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport \"../../../utils/ForgeHelper.sol\";\n\nimport \"../../../../contracts/test/TestERC20.sol\";\nimport \"../../../../lib/forge-std/src/console.sol\";\n\nimport \"../../../../contracts/core/connext/interfaces/IExecutor.sol\";\nimport \"../../../../contracts/core/connext/helpers/Executor.sol\";\n\n// running tests (with logging on failure):\n// yarn workspace @connext/nxtp-contracts test:forge -vvv\n// run a single test:\n// yarn workspace @connext/nxtp-contracts test:forge -m testAddRouterAlreadyApproved -vvv\n\n// other forge commands: yarn workspace @connext/nxtp-contracts forge <CMD>\n// see docs here: https://onbjerg.github.io/foundry-book/index.html\n\n// Helper to query properties via reentrancy\ncontract PropertyQuery is ForgeHelper {\n  address public originSender;\n  uint32 public origin;\n  uint256 public amt;\n\n  function setOriginSender() public returns (address) {\n    originSender = IExecutor(msg.sender).originSender();\n    return originSender;\n  }\n\n  function setOrigin() public returns (uint32) {\n    origin = IExecutor(msg.sender).origin();\n    return origin;\n  }\n\n  function setAmount() public payable returns (uint256) {\n    amt = IExecutor(msg.sender).amount();\n    return amt;\n  }\n\n  receive() external payable {}\n}\n\ncontract ExecutorTest is ForgeHelper {\n  // ============ Libraries ============\n\n  using stdStorage for StdStorage;\n  using TypedMemView for bytes29;\n  using TypedMemView for bytes;\n\n  // ============ Storage ============\n\n  Executor executor;\n  PropertyQuery query;\n  TestERC20 asset;\n\n  address connext = address(this);\n  address originSender = address(2);\n  address recovery = address(3);\n  uint32 origin = uint32(1000);\n  bytes32 transferId = keccak256(abi.encode(1));\n\n  // ============ Test set up ============\n\n  function setUp() public {\n    executor = new Executor(connext);\n    query = new PropertyQuery();\n    asset = new TestERC20();\n\n    // fund executor\n    asset.mint(address(executor), 10 ether);\n  }\n\n  // ============ Utils ============\n\n  // ============ getConnext ============\n\n  // Should work\n  function test_Executor__getConnext_works() public {\n    address c = executor.getConnext();\n    assertEq(c, connext);\n  }\n\n  // ============ originSender ============\n\n  // Should fail if properties are not set\n  function test_Executor__originSender_revertOnEmpty() public {\n    // Get the calldata\n    bytes memory data = abi.encodeWithSelector(PropertyQuery.setOriginSender.selector, \"\");\n    // send tx\n    (bool success, ) = executor.execute(\n      IExecutor.ExecutorArgs(\n        transferId,\n        0,\n        payable(address(query)),\n        payable(recovery),\n        NATIVE_ASSET,\n        LibCrossDomainProperty.EMPTY_BYTES,\n        data\n      )\n    );\n    assertTrue(!success);\n  }\n\n  // Should work\n  function test_Executor__originSender_works() public {\n    // Get the calldata\n    bytes memory data = abi.encodeWithSelector(PropertyQuery.setOriginSender.selector, \"\");\n    bytes memory property = LibCrossDomainProperty.formatDomainAndSenderBytes(origin, originSender);\n\n    // send tx\n    (bool success, ) = executor.execute(\n      IExecutor.ExecutorArgs(transferId, 0, payable(address(query)), payable(recovery), NATIVE_ASSET, property, data)\n    );\n    assertTrue(success);\n    assertEq(query.originSender(), originSender);\n  }\n\n  // ============ origin ============\n\n  // Should fail if properties are not set\n  function test_Executor__origin_revertOnEmpty() public {\n    // Get the calldata\n    bytes memory data = abi.encodeWithSelector(PropertyQuery.setOrigin.selector, \"\");\n    // send tx\n    (bool success, ) = executor.execute(\n      IExecutor.ExecutorArgs(\n        transferId,\n        0,\n        payable(address(query)),\n        payable(recovery),\n        NATIVE_ASSET,\n        LibCrossDomainProperty.EMPTY_BYTES,\n        data\n      )\n    );\n    assertTrue(!success);\n  }\n\n  // Should work\n  function test_Executor__origin_works() public {\n    // Get the calldata\n    bytes memory data = abi.encodeWithSelector(PropertyQuery.setOrigin.selector, \"\");\n    bytes memory property = LibCrossDomainProperty.formatDomainAndSenderBytes(origin, originSender);\n\n    // send tx\n    (bool success, ) = executor.execute(\n      IExecutor.ExecutorArgs(transferId, 0, payable(address(query)), payable(recovery), NATIVE_ASSET, property, data)\n    );\n    assertTrue(success);\n    assertEq(query.origin(), origin);\n  }\n\n  // ============ amount ============\n\n  // Should work\n  function test_Executor__amount_works() public {\n    // Get the calldata\n    bytes memory data = abi.encodeWithSelector(PropertyQuery.setAmount.selector, \"\");\n    bytes memory property = LibCrossDomainProperty.EMPTY_BYTES;\n\n    // send tx\n    uint256 amount = 1200;\n    (bool success, ) = executor.execute(\n      IExecutor.ExecutorArgs(\n        transferId,\n        amount,\n        payable(address(query)),\n        payable(recovery),\n        address(asset),\n        property,\n        data\n      )\n    );\n    assertTrue(success);\n    assertEq(query.amt(), amount);\n    assertEq(executor.amount(), 0);\n  }\n\n  // ============ execute ============\n\n  // Fails if not called by connext\n\n  // Should gracefully handle failure of no code at to\n  function test_Executor__execute_handlesNoCodeFailure() public {\n    // Get the calldata\n    bytes memory data = abi.encodeWithSelector(PropertyQuery.setAmount.selector, \"\");\n    bytes memory property = LibCrossDomainProperty.EMPTY_BYTES;\n\n    // Get starting recovery balance\n    uint256 initRecovery = asset.balanceOf(recovery);\n\n    // send tx\n    uint256 amount = 1200;\n    (bool success, ) = executor.execute(\n      IExecutor.ExecutorArgs(\n        transferId,\n        amount,\n        payable(address(12344321)),\n        payable(recovery),\n        address(asset),\n        property,\n        data\n      )\n    );\n    assertTrue(!success);\n\n    // should have transferred funds to recovery address\n    assertEq(asset.balanceOf(recovery), initRecovery + amount);\n  }\n\n  // Should work with native asset\n\n  // Should work with tokens\n\n  // Should decrease allowance if external call fails & using tokens\n\n  // Should not set properties if it is the default value from LibCrossDomainProperty\n\n  // Should set properties if they are provided\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {XAppConnectionManager, TypeCasts} from \"../../../../contracts/nomad-core/contracts/XAppConnectionManager.sol\";\nimport {Home} from \"../../../../contracts/nomad-core/contracts/Home.sol\";\nimport {TypedMemView} from \"../../../../contracts/nomad-core/libs/TypedMemView.sol\";\n\nimport {IAavePool} from \"../../../../contracts/core/connext/interfaces/IAavePool.sol\";\nimport {IStableSwap} from \"../../../../contracts/core/connext/interfaces/IStableSwap.sol\";\nimport {ISponsorVault} from \"../../../../contracts/core/connext/interfaces/ISponsorVault.sol\";\nimport {ITokenRegistry} from \"../../../../contracts/core/connext/interfaces/ITokenRegistry.sol\";\nimport {TokenRegistry} from \"../../../../contracts/core/connext/helpers/TokenRegistry.sol\";\nimport {IBridgeToken} from \"../../../../contracts/core/connext/interfaces/IBridgeToken.sol\";\nimport {IWrapped} from \"../../../../contracts/core/connext/interfaces/IWrapped.sol\";\nimport {IExecutor} from \"../../../../contracts/core/connext/interfaces/IExecutor.sol\";\nimport {Executor} from \"../../../../contracts/core/connext/helpers/Executor.sol\";\nimport {ConnextMessage} from \"../../../../contracts/core/connext/libraries/ConnextMessage.sol\";\nimport {RelayerFeeMessage} from \"../../../../contracts/core/relayer-fee/libraries/RelayerFeeMessage.sol\";\nimport {AssetLogic} from \"../../../../contracts/core/connext/libraries/AssetLogic.sol\";\nimport {LibCrossDomainProperty} from \"../../../../contracts/core/connext/libraries/LibCrossDomainProperty.sol\";\nimport {CallParams, ExecuteArgs, XCallArgs} from \"../../../../contracts/core/connext/libraries/LibConnextStorage.sol\";\nimport {LibDiamond} from \"../../../../contracts/core/connext/libraries/LibDiamond.sol\";\nimport {BridgeFacet} from \"../../../../contracts/core/connext/facets/BridgeFacet.sol\";\nimport {BaseConnextFacet} from \"../../../../contracts/core/connext/facets/BaseConnextFacet.sol\";\nimport {TestERC20} from \"../../../../contracts/test/TestERC20.sol\";\nimport {PromiseRouter} from \"../../../../contracts/core/promise/PromiseRouter.sol\";\n\nimport \"../../../utils/Mock.sol\";\n\nimport \"./FacetHelper.sol\";\n\ncontract BridgeFacetTest is BridgeFacet, FacetHelper {\n  // ============ Libs ============\n  using TypedMemView for bytes29;\n  using TypedMemView for bytes;\n  // ============ Constants ============\n\n  bytes32 constant TEST_MESSAGE = bytes32(\"test message\");\n\n  // ============ Storage ============\n  // diamond storage contract owner\n  address _ds_owner = address(987654321);\n\n  // executor contract\n  address _executor;\n  // mock xapp contract\n  address _xapp;\n  // mock xapp connection manager\n  address _xappConnectionManager;\n  // mock home\n  address _xappHome;\n  // mock promise router\n  address payable _promiseRouter;\n  // mock callback contract\n  address _callback;\n\n  // agents\n  address _agent = address(123456654321);\n\n  // default origin sender\n  address _originSender = address(4);\n\n  // aave pool details\n  address _aavePool;\n\n  // relayer fee\n  uint256 _relayerFee = 0.1 ether;\n\n  // default amount\n  uint256 _amount = 1.1 ether;\n\n  // default nonce on xcall\n  uint256 _nonce = 1;\n\n  // default recovery address\n  address constant _recovery = address(121212);\n\n  // default CallParams\n  CallParams _params =\n    CallParams(\n      address(11), // to\n      bytes(\"\"), // callData\n      _originDomain, // origin domain\n      _destinationDomain, // destination domain\n      _agent, // agent\n      _recovery, // recovery address\n      address(0), // callback\n      0, // callbackFee\n      _relayerFee, // relayer fee\n      false, // forceSlow\n      false, // receiveLocal\n      9900 // slippageTol\n    );\n\n  // ============ Test set up ============\n  function setUp() public {\n    // Deploy any needed contracts.\n    utils_deployContracts();\n\n    utils_setFees();\n\n    // Set up asset context. By default, local is the adopted asset - the one the 'user'\n    // is using - and is representational (meaning canonically it belongs to another chain).\n    utils_setupAsset(true, false);\n\n    // Promise router mock calls.\n    vm.mockCall(_promiseRouter, abi.encodeWithSelector(PromiseRouter.send.selector), abi.encode());\n    vm.mockCall(_promiseRouter, abi.encodeWithSelector(PromiseRouter.initCallbackFee.selector), abi.encode());\n\n    // Other context setup: configuration, storage, etc.\n    s.approvedRelayers[address(this)] = true;\n    s.maxRoutersPerTransfer = 5;\n    s._routerOwnershipRenounced = true;\n\n    vm.prank(address(this));\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.contractOwner = _ds_owner;\n\n    // NOTE: Currently, the only time we check for the domain in params to match the contract's\n    // domain is within the `xcall` method - so it's safe to set the contract domain to be origin.\n    utils_setRemote(true);\n  }\n\n  // ============ Utils ============\n  // Utils used in the following tests (as well as setup).\n\n  // Used in set up for deploying any needed peripheral contracts.\n  function utils_deployContracts() public {\n    utils_deployAssetContracts();\n    // Deploy an executor.\n    _executor = address(new Executor(address(this)));\n    s.executor = IExecutor(_executor);\n    // Deploy a mock xapp consumer.\n    _xapp = address(new MockXApp());\n\n    // Deploy a mock home.\n    _xappHome = address(new MockHome());\n    // Deploy a mock xapp connection manager.\n    _xappConnectionManager = address(new MockXAppConnectionManager(MockHome(_xappHome)));\n    s.xAppConnectionManager = XAppConnectionManager(_xappConnectionManager);\n    // Deploy the promise router.\n    s.promiseRouter = new MockPromiseRouter();\n    _promiseRouter = payable(s.promiseRouter);\n\n    // Deploy a mock callback.\n    _callback = address(new MockCallback());\n\n    // setup aave pool\n    _aavePool = address(new MockPool(false));\n    s.aavePool = _aavePool;\n  }\n\n  // Meant to mimic the corresponding `_getTransferId` method in the BridgeFacet contract.\n  function utils_getTransferIdFromXCallArgs(\n    XCallArgs memory _args,\n    address sender,\n    bytes32 canonicalId,\n    uint32 canonicalDomain\n  ) public view returns (bytes32) {\n    return keccak256(abi.encode(s.nonce, _args.params, sender, canonicalId, canonicalDomain, _args.amount));\n  }\n\n  // Meant to mimic the corresponding `_getTransferId` method in the BridgeFacet contract.\n  function utils_getTransferIdFromExecuteArgs(ExecuteArgs memory _args) public returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(_args.nonce, _args.params, _args.originSender, _canonicalId, _canonicalDomain, _args.amount)\n      );\n  }\n\n  // Makes some mock xcall arguments using params set in storage.\n  function utils_makeXCallArgs() public returns (bytes32, XCallArgs memory) {\n    // get args\n    XCallArgs memory args = XCallArgs(\n      _params,\n      _adopted == address(s.wrapper) ? address(0) : _adopted, // transactingAssetId : could be adopted, local, or wrapped.\n      _amount\n    );\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromXCallArgs(args, _originSender, _canonicalId, _canonicalDomain);\n\n    return (transferId, args);\n  }\n\n  function utils_makeXCallArgs(address transactingAssetId) public returns (bytes32, XCallArgs memory) {\n    // get args\n    XCallArgs memory args = XCallArgs(\n      _params,\n      transactingAssetId, // transactingAssetId : could be adopted, local, or wrapped.\n      _amount\n    );\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromXCallArgs(args, _originSender, _canonicalId, _canonicalDomain);\n\n    return (transferId, args);\n  }\n\n  // Makes some mock router signatures.\n  function utils_makeRouterSignatures(\n    bytes32 _transferId,\n    address[] memory _routers,\n    uint256[] memory _keys\n  ) public returns (bytes[] memory) {\n    uint256 pathLen = _routers.length;\n    bytes[] memory signatures = new bytes[](pathLen);\n    if (pathLen == 0) {\n      return signatures;\n    }\n    bytes32 preImage = keccak256(abi.encode(_transferId, pathLen));\n    bytes32 toSign = ECDSA.toEthSignedMessageHash(preImage);\n    for (uint256 i; i < pathLen; i++) {\n      (uint8 v, bytes32 r, bytes32 _s) = vm.sign(_keys[i], toSign);\n      signatures[i] = abi.encodePacked(r, _s, v);\n    }\n    return signatures;\n  }\n\n  // Makes some mock execute arguments with given router/key pairs.\n  function utils_makeExecuteArgs(address[] memory routers, uint256[] memory keys)\n    public\n    returns (bytes32, ExecuteArgs memory)\n  {\n    // get args\n    bytes[] memory empty = new bytes[](0);\n    ExecuteArgs memory args = ExecuteArgs(_params, _local, routers, empty, _amount, _nonce, _originSender);\n    // generate transfer id\n    bytes32 transferId = utils_getTransferIdFromExecuteArgs(args);\n    // generate router signatures if applicable\n    if (routers.length > 0) {\n      args.routerSignatures = utils_makeRouterSignatures(transferId, routers, keys);\n    }\n    return (transferId, args);\n  }\n\n  // Make execute args, fill in a number of router/key pairs.\n  // Specifically input 0 to make execute arguments with no routers/keys for slow liq simulation.\n  function utils_makeExecuteArgs(uint256 num) public returns (bytes32, ExecuteArgs memory) {\n    if (num == 0) {\n      address[] memory routers;\n      uint256[] memory keys;\n      return utils_makeExecuteArgs(routers, keys);\n    }\n    address[] memory routers = new address[](num);\n    uint256[] memory keys = new uint256[](num);\n    for (uint256 i; i < num; i++) {\n      routers[i] = vm.addr(777 + i);\n      keys[i] = 777 + i;\n    }\n    return utils_makeExecuteArgs(routers, keys);\n  }\n\n  // Intended to mock the fast transfer amount calculation in the target contract.\n  function utils_getFastTransferAmount(uint256 _amount) public returns (uint256) {\n    // This is the method used internally to get the amount of tokens to transfer after liquidity\n    // fees are taken.\n    return (_amount * s.LIQUIDITY_FEE_NUMERATOR) / s.LIQUIDITY_FEE_DENOMINATOR;\n  }\n\n  // Mimics the xcall message formatting. Reduced functionality : won't burn any tokens, for example.\n  function utils_formatMessage(\n    XCallArgs memory _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) public returns (bytes memory) {\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      detailsHash = token.detailsHash();\n    }\n\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  // Wraps reconcile in order to enable externalizing the call.\n  function utils_wrappedReconcile(uint32 origin, bytes memory message) external {\n    _reconcile(origin, message);\n  }\n\n  struct PortalInfo {\n    uint256 fee;\n    uint256 debt;\n    uint256 total;\n    bool aaveReturns;\n  }\n\n  function utils_setPortals(\n    bytes32 _id,\n    uint256 _amount,\n    uint256 _fee\n  ) public returns (PortalInfo memory) {\n    s.portalFeeDebt[_id] = _fee;\n    s.portalDebt[_id] = _amount;\n    return PortalInfo(_fee, _amount, _fee + _amount, true);\n  }\n\n  function utils_setPortals(bytes32 _id, uint256 _amount) public returns (PortalInfo memory) {\n    return utils_setPortals(_id, _amount, (_amount * _portalFeeNumerator) / _liquidityFeeDenominator);\n  }\n\n  // ============== Helpers ==================\n  // Helpers used for executing target methods with given params that assert expected base behavior.\n  function helpers_setupSuccessfulXcallCallAssertions(\n    bytes32 transferId,\n    XCallArgs memory args,\n    uint256 bridgedAmt,\n    bool isNative,\n    bool shouldSwap\n  ) public {\n    // bridged is either local or canonical, depending on domain xcall originates on\n    address bridged = _canonicalDomain == args.params.originDomain ? _canonical : _local;\n    BridgeFacet.XCalledEventArgs memory eventArgs = BridgeFacet.XCalledEventArgs({\n      transactingAssetId: isNative ? address(s.wrapper) : args.transactingAssetId,\n      amount: args.amount,\n      bridgedAmt: bridgedAmt,\n      bridged: bridged\n    });\n    bytes memory message = utils_formatMessage(args, bridged, transferId, bridgedAmt);\n    vm.expectEmit(true, true, true, true);\n    emit XCalled(transferId, args, eventArgs, s.nonce, message, _originSender);\n\n    // assert swap if expected\n    if (shouldSwap && bridgedAmt > 0) {\n      // Transacting asset shouldve been approved for amount in\n      vm.expectCall(\n        eventArgs.transactingAssetId,\n        abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, args.amount)\n      );\n\n      // swapExact on pool should have been called\n      uint256 minReceived = (args.amount * args.params.slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(\n          IStableSwap.swapExact.selector,\n          args.amount,\n          eventArgs.transactingAssetId,\n          _local,\n          minReceived\n        )\n      );\n    }\n\n    if (args.params.callbackFee > 0) {\n      // Assert that CallbackFee would be paid by the user.\n      vm.expectCall(\n        _promiseRouter,\n        args.params.callbackFee,\n        abi.encodeWithSelector(PromiseRouter.initCallbackFee.selector, transferId)\n      );\n    }\n    // Assert dispatch call\n    vm.expectCall(\n      _xappHome,\n      0,\n      abi.encodeWithSelector(Home.dispatch.selector, args.params.destinationDomain, _remote, message)\n    );\n\n    // if the token is a representation token, ensure that burn is called\n    if (bridged != _canonical && bridgedAmt > 0) {\n      vm.expectCall(_local, abi.encodeWithSelector(TestERC20.burn.selector, address(this), bridgedAmt));\n    }\n  }\n\n  // Calls `xcall` with given args and handles standard assertions.\n  function helpers_xcallAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    uint256 dealTokens,\n    uint256 bridgedAmt,\n    bytes4 expectedError,\n    bool shouldSwap\n  ) public {\n    bool isNative = args.transactingAssetId == address(0);\n    bool shouldSucceed = keccak256(abi.encode(expectedError)) == keccak256(abi.encode(bytes4(\"\")));\n    bool isCanonical = _canonicalDomain == args.params.originDomain;\n\n    // Deal the user required eth for transfer.\n    vm.deal(_originSender, 100 ether);\n\n    uint256 initialUserBalance;\n    uint256 initialContractBalance;\n    if (isNative) {\n      initialUserBalance = payable(_originSender).balance;\n      initialContractBalance = payable(address(this)).balance;\n    } else {\n      TestERC20 tokenIn = TestERC20(args.transactingAssetId);\n      TestERC20 localToken = TestERC20(_local);\n\n      // Mint the specified amount of tokens for the user.\n      tokenIn.mint(_originSender, dealTokens);\n\n      initialUserBalance = tokenIn.balanceOf(_originSender);\n      initialContractBalance = localToken.balanceOf(address(this));\n\n      // Approve the target contract to spend the specified amount of tokens.\n      vm.prank(_originSender);\n      tokenIn.approve(address(this), dealTokens);\n    }\n\n    if (shouldSwap) {\n      // Setup the expected swap mock (adopted <> local)\n      vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExact.selector), abi.encode(bridgedAmt, _local));\n    }\n\n    assertEq(s.relayerFees[transferId], 0);\n\n    if (shouldSucceed) {\n      helpers_setupSuccessfulXcallCallAssertions(transferId, args, bridgedAmt, isNative, shouldSwap);\n    } else {\n      vm.expectRevert(expectedError);\n    }\n\n    uint256 fees = args.params.relayerFee + args.params.callbackFee;\n    vm.prank(_originSender);\n    this.xcall{value: isNative ? fees + args.amount : fees}(args);\n\n    if (shouldSucceed) {\n      if (isNative) {\n        // Should have custodied the relayer fee, sent any callback fee to the promise router, and deposited the\n        // amount into the wrapper contract.\n        assertEq(payable(address(this)).balance, initialContractBalance + args.params.relayerFee);\n      } else {\n        // User should have been debited fees... but also tx cost?\n        // assertEq(payable(_originSender).balance, initialUserBalance - fees);\n\n        // Check that the user has been debited the correct amount of tokens.\n        assertEq(TestERC20(args.transactingAssetId).balanceOf(_originSender), initialUserBalance - args.amount);\n\n        // Check that the contract has been credited the correct amount of tokens.\n        // NOTE: Because the tokens are a representational local asset, they are burnt. The contract\n        // should NOT be holding any additional tokens after xcall completes.\n        if (isCanonical) {\n          // This should be a canonical asset transfer\n          assertEq(TestERC20(_canonical).balanceOf(address(this)), initialContractBalance + bridgedAmt);\n        } else {\n          // NOTE: Normally the adopted asset would be swapped into the local asset and then\n          // the local asset would be burned. Because the swap increases the contracts balance\n          // the prod difference in balance is net 0. However, because the swap here is mocked,\n          // when a swap occurrs no balance increase of local happens (i.e. if swap needed, the\n          // balance will decrease by bridgedAmt / what is burned)\n          uint256 expected = args.transactingAssetId == _local\n            ? initialContractBalance\n            : initialContractBalance - bridgedAmt;\n          assertEq(TestERC20(_local).balanceOf(address(this)), expected);\n        }\n      }\n      // Should have updated relayer fees mapping.\n      assertEq(this.relayerFees(transferId), args.params.relayerFee);\n\n      if (args.params.callbackFee > 0) {\n        // TODO: For some reason, balance isn't changing. Perhaps the vm.mockCall prevents this?\n        // CallbackFee should be delivered to the PromiseRouter.\n        // assertEq(_promiseRouter.balance, _params.callbackFee);\n      }\n    } else {\n      // Should have reverted.\n      assertEq(this.relayerFees(transferId), 0);\n    }\n  }\n\n  // Shortcut for the main fn. Generates args within this method.\n  function helpers_xcallAndAssert(\n    bytes4 expectedError,\n    uint256 bridged,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    uint256 dealTokens = (args.transactingAssetId == address(0)) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, expectedError, swaps);\n  }\n\n  function helpers_xcallAndAssert(bytes4 expectedError) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    uint256 dealTokens = (args.transactingAssetId == address(0)) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, 0, expectedError, false);\n  }\n\n  // Shortcut for the above fn, with no expected error.\n  function helpers_xcallAndAssert(uint256 bridged, bool swaps) public {\n    helpers_xcallAndAssert(bytes4(\"\"), bridged, swaps);\n  }\n\n  // Shortcut for the above fn, no expected error, specified transacting asset\n  function helpers_xcallAndAssert(\n    uint256 bridged,\n    address transacting,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs(transacting);\n    uint256 dealTokens = transacting == address(0) ? 0 : args.amount;\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, bytes4(\"\"), swaps);\n  }\n\n  // Shortcut for the main fn.\n  function helpers_xcallAndAssert(\n    uint256 dealTokens,\n    uint256 bridged,\n    bool swaps\n  ) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    helpers_xcallAndAssert(transferId, args, dealTokens, bridged, bytes4(\"\"), swaps);\n  }\n\n  struct ExecuteBalances {\n    uint256 bridge;\n    uint256 to;\n    uint256 executor;\n    uint256 debt;\n    uint256 feeDebt;\n  }\n\n  struct ExecuteTestInputs {\n    uint256 expectedAmt;\n    uint256 routerAmt;\n    address token;\n    bool callsExternal;\n    bool externalCallSucceeds;\n    bool shouldSwap; // Whether the `to` address should receive the tokens.\n    bool isSlow;\n    bool usesPortals;\n    bool useAgent;\n  }\n\n  function utils_getExecuteBalances(\n    bytes32 transferId,\n    IERC20 asset,\n    address _to\n  ) public returns (ExecuteBalances memory) {\n    uint256 debt = s.portalDebt[transferId];\n    uint256 fee = s.portalFeeDebt[transferId];\n    uint256 bridge = IERC20(_local).balanceOf(address(this));\n    uint256 to = address(asset) == address(s.wrapper) ? payable(_to).balance : asset.balanceOf(_to);\n    uint256 executor = address(asset) == address(s.wrapper) ? payable(_executor).balance : asset.balanceOf(_executor);\n    return ExecuteBalances(bridge, to, executor, debt, fee);\n  }\n\n  function helpers_setupExecuteAssertions(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    ExecuteTestInputs memory _inputs\n  ) public {\n    // ----- register expected calls\n\n    // expects portal\n    if (_inputs.usesPortals) {\n      // mint position\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.mintUnbacked.selector, _adopted, _inputs.routerAmt, address(this), 0)\n      );\n\n      // withdraw\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.withdraw.selector, _adopted, _inputs.routerAmt, address(this))\n      );\n    }\n\n    // expected swap\n    if (_inputs.shouldSwap) {\n      // register expected approval\n      vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, _inputs.routerAmt));\n      // register expected swap amount\n      uint256 minReceived = (_inputs.routerAmt * _args.params.slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.swapExact.selector, _inputs.routerAmt, _local, _adopted, minReceived)\n      );\n    }\n\n    // expected sponsor vault\n    if (address(s.sponsorVault) != address(0)) {\n      // if it is a fast transfer, then it should reimburse liquidity fees\n      if (!_inputs.isSlow) {\n        vm.expectCall(\n          address(s.sponsorVault),\n          abi.encodeWithSelector(\n            ISponsorVault.reimburseLiquidityFees.selector,\n            _inputs.token,\n            _args.amount,\n            _args.params.to\n          )\n        );\n      }\n      // always reimburses relayer fees\n      vm.expectCall(\n        address(s.sponsorVault),\n        abi.encodeWithSelector(\n          ISponsorVault.reimburseRelayerFees.selector,\n          _originDomain,\n          _args.params.to,\n          _args.params.relayerFee\n        )\n      );\n    }\n\n    // expected transfer out of contract\n    if (_args.amount > 0) {\n      if (_inputs.token == address(s.wrapper)) {\n        // wrapper withdrawal\n        vm.expectCall(_inputs.token, abi.encodeWithSelector(IWrapped.withdraw.selector, _inputs.expectedAmt));\n      } else {\n        // token transfer\n        vm.expectCall(\n          _inputs.token,\n          abi.encodeWithSelector(\n            IERC20.transfer.selector,\n            _inputs.callsExternal ? _executor : _args.params.to,\n            _inputs.expectedAmt\n          )\n        );\n      }\n    }\n\n    // expected executor call\n    if (_inputs.callsExternal) {\n      {\n        bytes memory properties = _inputs.isSlow\n          ? LibCrossDomainProperty.formatDomainAndSenderBytes(_originDomain, _originSender)\n          : LibCrossDomainProperty.EMPTY_BYTES;\n        vm.expectCall(\n          _executor,\n          abi.encodeWithSelector(\n            IExecutor.execute.selector,\n            IExecutor.ExecutorArgs(\n              transferId,\n              _inputs.expectedAmt,\n              _args.params.to,\n              _args.params.recovery,\n              _inputs.token,\n              properties,\n              _args.params.callData\n            )\n          )\n        );\n      }\n    }\n\n    // expected promise router call\n    if (_args.params.callback != address(0)) {\n      vm.expectCall(\n        _promiseRouter,\n        abi.encodeWithSelector(\n          PromiseRouter.send.selector,\n          _originDomain,\n          transferId,\n          _args.params.callback,\n          _inputs.externalCallSucceeds,\n          bytes(\"\")\n        )\n      );\n    }\n  }\n\n  // Calls `execute` on the target method with the given args and asserts expected behavior.\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    ExecuteTestInputs memory _inputs\n  ) public {\n    // get pre-execute liquidity in local\n    uint256 pathLen = _args.routers.length;\n    uint256[] memory prevLiquidity = new uint256[](pathLen);\n    {\n      for (uint256 i; i < pathLen; i++) {\n        prevLiquidity[i] = s.routerBalances[_args.routers[i]][_local];\n      }\n    }\n\n    // get pre-execute balance here in local\n    IERC20 token = IERC20(_inputs.token);\n    ExecuteBalances memory prevBalances = utils_getExecuteBalances(transferId, token, _args.params.to);\n\n    // execute\n    // expected amount is impacted by (1) fast liquidity fees (2) slippage\n    // router debited amount in local is only impacted by fast liquidity\n    uint256 routerAmt = _inputs.isSlow ? _args.amount : utils_getFastTransferAmount(_args.amount);\n\n    // setup pool mock if needed\n    if (_inputs.shouldSwap) {\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.swapExact.selector),\n        abi.encode(_inputs.expectedAmt, _adopted)\n      );\n    }\n\n    if (_inputs.token == address(s.wrapper)) {\n      vm.mockCall(_inputs.token, abi.encodeWithSelector(IWrapped.withdraw.selector), abi.encode(true));\n    }\n\n    // setup execute mock\n    vm.mockCall(\n      _executor,\n      abi.encodeWithSelector(Executor.execute.selector),\n      abi.encode(_inputs.externalCallSucceeds, bytes(\"\"))\n    );\n\n    // register expected calls\n    helpers_setupExecuteAssertions(transferId, _args, _inputs);\n\n    if (_inputs.usesPortals) {\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalMintUnbacked(transferId, _args.routers[0], _inputs.token, _inputs.expectedAmt);\n    }\n\n    // register expected emit event\n    address sender = _inputs.useAgent ? _args.params.agent : address(this);\n    vm.expectEmit(true, true, false, true);\n    emit Executed(transferId, _args.params.to, _args, _inputs.token, _inputs.expectedAmt, sender);\n    // make call\n    vm.prank(sender);\n    this.execute(_args);\n\n    // check local balance\n    {\n      if (pathLen > 0) {\n        // should decrement router balance unless using aave\n        for (uint256 i; i < pathLen; i++) {\n          assertEq(\n            s.routerBalances[_args.routers[i]][_args.local],\n            _inputs.usesPortals ? prevLiquidity[i] : prevLiquidity[i] - (_inputs.routerAmt / pathLen)\n          );\n        }\n      }\n    }\n\n    {\n      // assertions\n      ExecuteBalances memory finalBalances = utils_getExecuteBalances(transferId, token, _args.params.to);\n\n      // NOTE: the balance of the bridge *should* always decrement in local, however that depends on\n      // the token executing the `swap` / `withdraw` call when a swap is needed (which we have as mocked).\n      // Instead, assert the swap functions on the pool were called correctly\n      if (!_inputs.shouldSwap && _inputs.token != address(s.wrapper)) {\n        // NOTE: when using aave would normally send you funds for the position minted,\n        // but we are not adding any funds from the pool, so always decrement\n        assertEq(finalBalances.bridge, prevBalances.bridge - _inputs.routerAmt);\n      }\n\n      if (_inputs.usesPortals) {\n        uint256 fee = (_inputs.routerAmt * _portalFeeNumerator) / _liquidityFeeDenominator;\n        assertEq(finalBalances.feeDebt, prevBalances.feeDebt + fee);\n        assertEq(finalBalances.debt, prevBalances.debt + _inputs.routerAmt);\n      } else {\n        assertEq(finalBalances.feeDebt, prevBalances.feeDebt);\n        assertEq(finalBalances.debt, prevBalances.debt);\n      }\n\n      if (_inputs.callsExternal) {\n        // should increment balance of executor\n        // should NOT increment balance of to\n        // NOTE: recovery address testing should be done in Executor.t.sol\n        // as such, executor balance should *always* increment\n        assertEq(finalBalances.executor, prevBalances.executor + _inputs.expectedAmt);\n        assertEq(token.balanceOf(_params.to), prevBalances.to);\n      } else {\n        // should have incremented balance of `to`\n        // should NOT increment balance of executor\n        assertEq(finalBalances.to, prevBalances.to + _inputs.expectedAmt);\n        assertEq(finalBalances.executor, prevBalances.executor);\n      }\n    }\n\n    // should mark the transfer as executed\n    assertEq(s.transferRelayer[transferId], sender);\n\n    // should have assigned transfer as routed\n    address[] memory savedRouters = this.routedTransfers(transferId);\n    for (uint256 i; i < savedRouters.length; i++) {\n      assertEq(savedRouters[i], _args.routers[i]);\n    }\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expectedAmt, // amount out of swap\n    bool callsExternal,\n    bool externalCallSucceeds,\n    bool shouldSwap, // Whether the `to` address should receive the tokens.\n    bool usesPortals,\n    bool useAgent\n  ) public {\n    uint256 pathLen = _args.routers.length;\n    bool isSlow = pathLen == 0;\n    // get pre-execute balance here in local\n    uint256 routerAmt = isSlow ? _args.amount : utils_getFastTransferAmount(_args.amount);\n    helpers_executeAndAssert(\n      transferId,\n      _args,\n      ExecuteTestInputs(\n        expectedAmt,\n        routerAmt,\n        shouldSwap ? _adopted : _local, // token\n        callsExternal,\n        externalCallSucceeds,\n        shouldSwap,\n        isSlow,\n        usesPortals,\n        useAgent\n      )\n    );\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expectedAmt, // amount out of swap\n    bool callsExternal,\n    bool externalCallSucceeds,\n    bool shouldSwap // Whether the `to` address should receive the tokens.\n  ) public {\n    helpers_executeAndAssert(\n      transferId,\n      _args,\n      expectedAmt,\n      callsExternal,\n      externalCallSucceeds,\n      shouldSwap,\n      false,\n      false\n    );\n  }\n\n  function buildMessage(bytes32 _id) private returns (bytes memory) {\n    bytes32 detailsHash = keccak256(\"test\");\n\n    bytes29 action = ConnextMessage.formatTransfer(bytes32(uint256(uint160(_params.to))), _amount, detailsHash, _id);\n    bytes29 tokenId = ConnextMessage.formatTokenId(_canonicalDomain, _canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  // ============ execute ============\n  // Shortcut for above method:\n  // - local == adopted\n  // - does not call external\n  // - calling on non-canonical domain\n  function helpers_executeAndAssert(bytes32 transferId, ExecuteArgs memory _args) public {\n    uint256 expected = _args.amount;\n    if (_args.routers.length > 0) {\n      expected = utils_getFastTransferAmount(_args.amount);\n    }\n    helpers_executeAndAssert(transferId, _args, expected, false, false, false, false, false);\n  }\n\n  // Shortcut where:\n  // - local != adopted\n  // - does not call external\n  // - calling on noncanonical domain\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    uint256 expected,\n    bool shouldSwap\n  ) public {\n    helpers_executeAndAssert(transferId, _args, expected, false, false, shouldSwap, false, false);\n  }\n\n  function helpers_executeAndAssert(\n    bytes32 transferId,\n    ExecuteArgs memory _args,\n    bool useAgent\n  ) public {\n    uint256 expected = _args.amount;\n    if (_args.routers.length > 0) {\n      expected = utils_getFastTransferAmount(_args.amount);\n    }\n    helpers_executeAndAssert(transferId, _args, expected, false, false, false, false, useAgent);\n  }\n\n  function helpers_setupReconcilePortalAssertions(\n    bytes32 transferId,\n    XCallArgs memory args,\n    PortalInfo memory init,\n    PortalInfo memory repayment,\n    uint256 amountIn,\n    uint256 amountOut\n  ) public {\n    if (repayment.total == 0) {\n      // noting to assert\n      return;\n    }\n    // if local != adopted, need to swap into adopted\n    if (_local != _adopted) {\n      // should call calculate always\n      vm.expectCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapFromAddress.selector, _local, _adopted, args.amount)\n      );\n\n      // will swap and repay IFF within slippage\n      if (amountIn <= args.amount) {\n        // slippage ok, call approve\n        vm.expectCall(_local, abi.encodeWithSelector(IERC20.approve.selector, _stableSwap, amountIn));\n        // should call swap\n        vm.expectCall(\n          _stableSwap,\n          abi.encodeWithSelector(IStableSwap.swapExactOut.selector, repayment.total, _local, _adopted, args.amount)\n        );\n      } // otherwise slippage is too high and it should not try to repay the rest of the loan\n    }\n\n    if (amountIn > 0) {\n      // approval of pool for sum\n      vm.expectCall(_adopted, abi.encodeWithSelector(IERC20.approve.selector, _aavePool, repayment.total));\n\n      // approval of payback\n      vm.expectCall(\n        _aavePool,\n        abi.encodeWithSelector(IAavePool.backUnbacked.selector, _adopted, repayment.debt, repayment.fee)\n      );\n\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalRepayment(transferId, _adopted, repayment.debt, repayment.fee);\n\n      // check if there will be a debt event\n      if (repayment.total < init.total) {\n        // // FIXME: logs are the same in the corresponding event (when insufficient fees)\n        // // but `expectEmit` call is not working\n        // vm.expectEmit(true, false, false, true);\n        // emit AavePortalRepaymentDebt(transferId, _adopted, init.debt - repayment.debt, init.fee - repayment.fee);\n      }\n    } else {\n      // slippage maximums hit, emit full debt in event\n      vm.expectEmit(true, true, true, true);\n      emit AavePortalRepaymentDebt(transferId, _adopted, init.debt, init.fee);\n    }\n  }\n\n  struct SwapInfo {\n    uint256 input;\n    uint256 output; // the equivalent amount of `out` token for given `in`\n  }\n\n  // Helper for calling `reconcile` and asserting expected behavior.\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError,\n    PortalInfo memory repayment,\n    SwapInfo memory swap\n  ) public {\n    PortalInfo memory init = PortalInfo(\n      s.portalFeeDebt[transferId],\n      s.portalDebt[transferId],\n      s.portalDebt[transferId] + s.portalFeeDebt[transferId],\n      true\n    );\n    bool isNative = args.transactingAssetId == address(0);\n    bool shouldSucceed = keccak256(abi.encode(expectedError)) == keccak256(abi.encode(bytes4(\"\")));\n\n    // Derive message from xcall arguments.\n    bytes memory message;\n    {\n      BridgeFacet.XCalledEventArgs memory eventArgs = BridgeFacet.XCalledEventArgs({\n        transactingAssetId: isNative ? address(s.wrapper) : args.transactingAssetId,\n        amount: args.amount,\n        bridgedAmt: args.amount,\n        bridged: _local\n      });\n      message = utils_formatMessage(args, _local, transferId, args.amount);\n    }\n\n    uint256[] memory routerBalances = new uint256[](s.routedTransfers[transferId].length);\n    for (uint256 i = 0; i < s.routedTransfers[transferId].length; i++) {\n      // Warming up the slot in order to make gas estimates more accurate to appropriate conditions.\n      s.routerBalances[s.routedTransfers[transferId][i]][_local] = 1 ether;\n      routerBalances[i] = 1 ether;\n    }\n\n    // Get pre-reconcile balances.\n    uint256 prevBalance;\n    if (isNative) {\n      prevBalance = payable(address(this)).balance;\n    } else {\n      prevBalance = IERC20(_local).balanceOf(address(this));\n    }\n\n    // Mock calls for swap if needed\n    if (_local != _adopted && init.total > 0) {\n      // mock calculate equivalent of bridged amount in adopted\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapFromAddress.selector),\n        abi.encode(swap.output)\n      );\n      vm.mockCall(\n        _stableSwap,\n        abi.encodeWithSelector(IStableSwap.calculateSwapOutFromAddress.selector),\n        abi.encode(swap.input)\n      );\n      // mock swap\n      vm.mockCall(_stableSwap, abi.encodeWithSelector(IStableSwap.swapExactOut.selector), abi.encode(swap.input));\n    }\n\n    if (!repayment.aaveReturns) {\n      // Force failure on call\n      _aavePool = address(new MockPool(true));\n      s.aavePool = _aavePool;\n    }\n\n    if (shouldSucceed) {\n      // check that the mint is called properly\n      if (_local != _canonical) {\n        vm.expectCall(_local, abi.encodeWithSelector(TestERC20.mint.selector, address(this), args.amount));\n      }\n\n      helpers_setupReconcilePortalAssertions(transferId, args, init, repayment, swap.input, swap.output);\n\n      vm.expectEmit(true, true, true, true);\n      emit Reconciled(transferId, _originDomain, s.routedTransfers[transferId], _local, args.amount, address(this));\n    } else {\n      vm.expectRevert(expectedError);\n    }\n\n    this.utils_wrappedReconcile(_originDomain, message);\n\n    if (shouldSucceed) {\n      assertEq(this.reconciledTransfers(transferId), true);\n      address[] memory routers = this.routedTransfers(transferId);\n      if (routers.length > 0) {\n        uint256 routerAmt;\n        if (init.total > 0 && repayment.aaveReturns) {\n          routerAmt = swap.input > args.amount ? args.amount : args.amount - swap.input;\n        } else {\n          routerAmt = args.amount / s.routedTransfers[transferId].length;\n        }\n        // Fast liquidity route. Should have reimbursed routers.\n        for (uint256 i = 0; i < routers.length; i++) {\n          assertEq(s.routerBalances[routers[i]][_local], routerBalances[i] + routerAmt);\n        }\n      }\n\n      if (init.total > 0) {\n        // assert repayment\n        assertEq(s.portalDebt[transferId], init.debt - repayment.debt);\n        assertEq(s.portalFeeDebt[transferId], init.fee - repayment.fee);\n      }\n    }\n  }\n\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError,\n    PortalInfo memory repayment\n  ) public {\n    helpers_reconcileAndAssert(transferId, args, expectedError, repayment, SwapInfo(repayment.total, args.amount));\n  }\n\n  function helpers_reconcileAndAssert(\n    bytes32 transferId,\n    XCallArgs memory args,\n    bytes4 expectedError\n  ) public {\n    helpers_reconcileAndAssert(transferId, args, expectedError, PortalInfo(0, 0, 0, true));\n  }\n\n  function helpers_reconcileAndAssert(bytes4 expectedError) public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    helpers_reconcileAndAssert(transferId, args, expectedError);\n  }\n\n  // Shortcut for above method.\n  function helpers_reconcileAndAssert() public {\n    helpers_reconcileAndAssert(bytes4(\"\"));\n  }\n\n  // ============ Getters ==============\n\n  function test_BridgeFacet_domain_works() public {\n    s.domain = 0;\n    assertEq(this.domain(), 0);\n    s.domain = _destinationDomain;\n    assertEq(this.domain(), _destinationDomain);\n  }\n\n  function test_BridgeFacet_executor_works() public {\n    s.executor = IExecutor(address(0));\n    assertEq(address(this.executor()), address(0));\n    s.executor = IExecutor(_local);\n    assertEq(address(this.executor()), _local);\n  }\n\n  function test_BridgeFacet_nonce_works() public {\n    s.nonce = 0;\n    assertEq(this.nonce(), 0);\n    s.nonce = _destinationDomain;\n    assertEq(this.nonce(), _destinationDomain);\n  }\n\n  function test_BridgeFacet_sponsorVault_works() public {\n    s.sponsorVault = ISponsorVault(address(0));\n    assertEq(address(this.sponsorVault()), address(0));\n    s.sponsorVault = ISponsorVault(_local);\n    assertEq(address(this.sponsorVault()), _local);\n  }\n\n  function test_BridgeFacet_promiseRouter_works() public {\n    s.promiseRouter = PromiseRouter(payable(address(0)));\n    assertEq(address(this.promiseRouter()), address(0));\n    s.promiseRouter = PromiseRouter(payable(_local));\n    assertEq(address(this.promiseRouter()), _local);\n  }\n\n  // The rest (relayerFees, routedTransfers, reconciledTransfers) are checked on\n  // assertions for xcall / reconcile / execute\n\n  // ============ Admin methods ==============\n  // setPromiseRouter\n  // FIXME: move to BaseConnextFacet.t.sol\n  function test_BridgeFacet__setPromiseRouter_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setPromiseRouter_invalidPromiseRouter.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_failIfNotContract() public {\n    // constants\n    address old = address(123);\n    address updated = address(456);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setPromiseRouter_invalidPromiseRouter.selector);\n    this.setPromiseRouter(payable(updated));\n  }\n\n  function test_BridgeFacet__setPromiseRouter_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.promiseRouter = PromiseRouter(payable(old));\n\n    // test success\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit PromiseRouterUpdated(old, updated, LibDiamond.contractOwner());\n    this.setPromiseRouter(payable(updated));\n    assertEq(address(this.promiseRouter()), updated);\n  }\n\n  // setExecutor\n  function test_BridgeFacet__setExecutor_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setExecutor_invalidExecutor.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_failIfNotContract() public {\n    // constants\n    address old = address(123);\n    address updated = address(456);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setExecutor_invalidExecutor.selector);\n    this.setExecutor(payable(updated));\n  }\n\n  function test_BridgeFacet__setExecutor_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.executor = IExecutor(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit ExecutorUpdated(old, updated, LibDiamond.contractOwner());\n    this.setExecutor(payable(updated));\n    assertEq(address(this.executor()), updated);\n  }\n\n  // setSponsorVault\n  function test_BridgeFacet__setSponsorVault_failIfNotOwner() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(_originSender);\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    this.setSponsorVault(payable(updated));\n  }\n\n  function test_BridgeFacet__setSponsorVault_failIfNoChange() public {\n    // constants\n    address old = address(123);\n    address updated = old;\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectRevert(BridgeFacet.BridgeFacet__setSponsorVault_invalidSponsorVault.selector);\n    this.setSponsorVault(payable(updated));\n  }\n\n  function test_BridgeFacet__setSponsorVault_works() public {\n    // constants\n    address old = address(123);\n    address updated = address(_local);\n\n    // set storage\n    s.sponsorVault = ISponsorVault(payable(old));\n\n    // test revert\n    vm.prank(LibDiamond.contractOwner());\n    vm.expectEmit(true, true, true, true);\n    emit SponsorVaultUpdated(old, updated, LibDiamond.contractOwner());\n    this.setSponsorVault(payable(updated));\n    assertEq(address(this.sponsorVault()), updated);\n  }\n\n  // ============ Public methods ==============\n\n  // ============ xcall ============\n\n  // ============ xcall fail cases\n  // fails if paused\n  // FIXME: move to BaseConnextFacet.t.sol\n  function test_BridgeFacet__xcall_failIfPaused() public {\n    // require(false, \"not tested\");\n  }\n\n  // fails if origin domain is incorrect\n  function test_BridgeFacet__xcall_failIfDomainIncorrect() public {\n    _params.originDomain = 999999;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_wrongDomain.selector);\n  }\n\n  // TODO: fails if destination domain does not have an xapp router registered\n  // FIXME: this should be tested at the integration level (i.e. when we deploy\n  // the contracts via Deployer.sol), or on a facet that asserts this\n\n  // fails if recipient `to` not a valid address (i.e. != address(0))\n  function test_BridgeFacet__xcall_failIfNoRecipient() public {\n    _params.to = address(0);\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_emptyTo.selector);\n  }\n\n  // fails if callback fee > 0 but callback address is not defined\n  function test_BridgeFacet__xcall_failIfCallbackFeeButNoContract() public {\n    _params.callback = address(0);\n    _params.callbackFee = 0.001 ether;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_nonZeroCallbackFeeForCallback.selector);\n  }\n\n  // fails if callback is defined but not a contract\n  function test_BridgeFacet__xcall_failIfCallbackNotAContract() public {\n    _params.callback = address(42);\n    _params.callbackFee = 0.001 ether;\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_callbackNotAContract.selector);\n  }\n\n  // fails if asset is not supported (i.e. s.adoptedToCanonical[transactingAssetId].id == bytes32(0) and using non-local)\n  function test_BridgeFacet__xcall_failIfAssetNotSupported() public {\n    // setup asset with local != adopted, not on canonical domain\n    utils_setupAsset(false, false);\n\n    s.adoptedToCanonical[_adopted] = ConnextMessage.TokenId(0, bytes32(0));\n\n    // ensure token registry returns true for local origin\n    vm.mockCall(\n      address(s.tokenRegistry),\n      abi.encodeWithSelector(ITokenRegistry.isLocalOrigin.selector, _adopted),\n      abi.encode(true)\n    );\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_notSupportedAsset.selector);\n  }\n\n  // fails if native asset wrapper is not supported (i.e. s.adoptedToCanonical[transactingAssetId].id == bytes32(0))\n  function test_BridgeFacet__xcall_failIfNativeAssetWrapperNotSupported() public {\n    utils_setupNative(true, true);\n    s.adoptedToCanonical[address(s.wrapper)] = ConnextMessage.TokenId(0, bytes32(0));\n    helpers_xcallAndAssert(BridgeFacet.BridgeFacet__xcall_notSupportedAsset.selector);\n  }\n\n  // fails if native token transfer and amount of native tokens sent is < amount + relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failNativeAssetCallbackFeeInsufficient() public {\n    vm.deal(_originSender, 100 ether);\n    utils_setupNative(true, true);\n    _params.callback = _callback;\n    _params.callbackFee = 0.01 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_notAmount.selector);\n    vm.prank(_originSender);\n    // Sending only the amount + relayer fee; callbackFee is not covered!\n    this.xcall{value: args.params.relayerFee + args.amount}(args);\n  }\n\n  // fails if erc20 transfer and eth sent < relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failEthWithErc20TransferInsufficient() public {\n    utils_setupAsset(true, false);\n    vm.deal(_originSender, 100 ether);\n    _relayerFee = 0.1 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_ethWithErcTransfer.selector);\n    vm.prank(_originSender);\n    // Sending insufficent eth to cover relayer fee.\n    this.xcall{value: 0.08 ether}(args);\n  }\n\n  // fails if erc20 transfer and eth sent > relayerFee + callbackFee\n  function test_BridgeFacet__xcall_failEthWithErc20TransferUnnecessary() public {\n    vm.deal(_originSender, 100 ether);\n    _relayerFee = 0.1 ether;\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(AssetLogic.AssetLogic__handleIncomingAsset_ethWithErcTransfer.selector);\n    vm.prank(_originSender);\n    // Sending too much eth.\n    this.xcall{value: 1 ether}(args);\n  }\n\n  // fails if user has insufficient tokens\n  function test_BridgeFacet__xcall_failInsufficientErc20Tokens() public {\n    _amount = 10.1 ether;\n    TestERC20 localToken = TestERC20(_local);\n    localToken.mint(_originSender, 10 ether);\n    vm.prank(_originSender);\n    localToken.approve(address(this), 10.1 ether);\n\n    vm.deal(_originSender, 100 ether);\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(\"ERC20: transfer amount exceeds balance\");\n    vm.prank(_originSender);\n    this.xcall{value: args.params.relayerFee}(args);\n  }\n\n  // fails if user has not set enough allowance\n  function test_BridgeFacet__xcall_failInsufficientErc20Approval() public {\n    _amount = 10.1 ether;\n    TestERC20 localToken = TestERC20(_local);\n    localToken.mint(_originSender, 10.1 ether);\n    vm.prank(_originSender);\n    localToken.approve(address(this), 10 ether);\n\n    vm.deal(_originSender, 100 ether);\n\n    (, XCallArgs memory args) = utils_makeXCallArgs();\n\n    vm.expectRevert(\"ERC20: transfer amount exceeds allowance\");\n    vm.prank(_originSender);\n    this.xcall{value: args.params.relayerFee}(args);\n  }\n\n  // ============ xcall success cases\n  // asset cases:\n  // - works on remote domain\n  //   - transferring native (local == adopted)\n  //   - transferring native (local != adopted)\n  //   - transferring asset (local == adopted)\n  //   - transferring asset (local != adopted)\n\n  // - works on cannonical domain\n  //   - transferring native (local == adopted)\n  //   - transferring asset (local == adopted)\n  // canonincal token transfer on canonical domain\n  function test_BridgeFacet__xcall_canonicalTokenTransferWorks() public {\n    utils_setupAsset(true, true);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // local token transfer on non-canonical domain (local != adopted)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWithAdopted() public {\n    uint256 bridged = (_amount * 9995) / _liquidityFeeDenominator;\n    utils_setupAsset(false, false);\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // local token transfer on non-canonical domain, local != adopted, send in local\n  // (i.e. i should be able to xcall with madEth on optimism)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWhenNotAdopted() public {\n    // local is not adopted, not on canonical domain, sending in local\n    utils_setupAsset(false, false);\n    s.adoptedToCanonical[_local] = ConnextMessage.TokenId(0, bytes32(0));\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    vm.mockCall(\n      _tokenRegistry,\n      abi.encodeWithSelector(ITokenRegistry.isLocalOrigin.selector, _local),\n      abi.encode(false)\n    );\n    args.transactingAssetId = _local;\n    helpers_xcallAndAssert(transferId, args, args.amount, args.amount, bytes4(\"\"), false);\n  }\n\n  // local token transfer on non-canonical domain (local == adopted)\n  function test_BridgeFacet__xcall_localTokenTransferWorksWithoutAdopted() public {\n    utils_setupAsset(true, false);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // native asset transfer on canonical domain\n  function test_BridgeFacet__xcall_nativeTransferWorksOnCanonical() public {\n    utils_setupNative(true, true);\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // native asset transfer on non-canonical domain with local == adopted\n  // i.e. get ETH on arbitrum from cronos\n  // adopted = address(madETH cronos)\n  // local = address(madETH on cronos)\n  // canonical = address(mainnet wrapper)\n  function test_BridgeFacet__xcall_nativeTransferWorksOnRemote() public {\n    utils_setupNative(true, false);\n    helpers_xcallAndAssert(_amount, _local, false);\n  }\n\n  // native asset transfer on non-canonical domain with local != adopted\n  // i.e. native arbitrum eth transfer to matic weth\n  // adopted = address(arbitrum wrapper)\n  // canonical = address(eth wrapper)\n  // local = address(madETH on arbitrum)\n  function test_BridgeFacet__xcall_nativeTransferWorksOnRemoteWithAdopted() public {\n    utils_setupNative(false, false);\n    helpers_xcallAndAssert(_amount, address(0), true);\n  }\n\n  // adopted asset transfer\n  function test_BridgeFacet__xcall_adoptedTransferWorks() public {\n    utils_setupAsset(false, false);\n    uint256 bridged = (_amount * 9995) / _liquidityFeeDenominator;\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // FIXME: should work with fee on transfer tokens\n  function test_BridgeFacet__xcall_feeOnTransferWorks() public {\n    // require(false, \"not tested\");\n  }\n\n  // should work with positive slippage\n  function test_BridgeFacet__xcall_worksWithPositiveSlippage() public {\n    utils_setupAsset(false, false);\n    uint256 bridged = (_amount * 10005) / _liquidityFeeDenominator;\n    helpers_xcallAndAssert(bridged, true);\n  }\n\n  // should work with 0 value\n  function test_BridgeFacet__xcall_worksWithoutValue() public {\n    _amount = 0;\n    helpers_xcallAndAssert(0, true);\n  }\n\n  // should send promise router callback fee\n  function test_BridgeFacet__xcall_shouldHandleCallbackFee() public {\n    _params.callback = _callback;\n    _params.callbackFee = 0.02 ether;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // works if relayer fee is set to 0\n  function test_BridgeFacet__xcall_zeroRelayerFeeWorks() public {\n    _relayerFee = 0;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // works with callback fee set to 0\n  function test_BridgeFacet__xcall_zeroCallbackFeesWorks() public {\n    _params.callbackFee = 0;\n    helpers_xcallAndAssert(_amount, false);\n  }\n\n  // FIXME: move to BaseConnextFacet.t.sol\n  // works if swap isnt required and swaps are paused\n  function test_BridgeFacet__xcall_worksIfNoSwapAndSwapPaused() public {\n    // require(false, \"not tested\");\n  }\n\n  // =========== handle / reconcile ==========\n  // NOTE: modifier tests happen in BaseConnext.t.sol. Below are the reconcile (internal fn)\n  // unit tests\n\n  // ============ reconcile fail cases\n\n  // should not process invalid messages\n  function test_BridgeFacet__reconcile_invalidMessage() public {\n    bytes memory _message = bytes(\"\");\n    vm.expectRevert(bytes(\"Validity assertion failed\"));\n    _reconcile(_originDomain, _message);\n  }\n\n  // fails if action is not transfer\n  function test_BridgeFacet__reconcile_invalidTransfer() public {\n    bytes29 tokenId = ConnextMessage.formatTokenId(_canonicalDomain, _canonicalId);\n    bytes29 action = abi\n      .encodePacked(ConnextMessage.Types.Message, bytes32(\"recip\"), uint256(100), bytes32(\"details\"), bytes32(\"id\"))\n      .ref(0)\n      .castTo(uint40(ConnextMessage.Types.Message));\n    bytes29[] memory _views = new bytes29[](2);\n    _views[0] = tokenId;\n    _views[1] = action;\n    bytes memory _message = TypedMemView.join(_views);\n    vm.expectRevert(BridgeFacet.BridgeFacet__reconcile_invalidAction.selector);\n    _reconcile(_originDomain, _message);\n  }\n\n  // fails if already reconciled (s.reconciledTransfers[transferId] = true)\n  function test_BridgeFacet__reconcile_failIfAlreadyReconciled() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.reconciledTransfers[transferId] = true;\n    helpers_reconcileAndAssert(transferId, args, BridgeFacet.BridgeFacet__reconcile_alreadyReconciled.selector);\n  }\n\n  // fails if portal record, but used in slow mode\n  function test_BridgeFacet__reconcile_failsIfPortalAndNoRouter() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    delete s.routedTransfers[transferId];\n\n    // set portal fee debt\n    s.portalDebt[transferId] = 15;\n    s.portalFeeDebt[transferId] = 10;\n\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      BridgeFacet.BridgeFacet__reconcile_noPortalRouter.selector,\n      PortalInfo(10, 15, 25, true)\n    );\n  }\n\n  // ============ reconcile success cases\n  // works with local representational tokens (remote origin, so they will be minted)\n  function test_BridgeFacet__reconcile_worksWithLocal() public {\n    utils_setupAsset(true, false);\n    helpers_reconcileAndAssert();\n  }\n\n  function test_BridgeFacet__reconcile_worksWithCanonical() public {\n    utils_setupAsset(true, true);\n    helpers_reconcileAndAssert();\n  }\n\n  // funds contract when pre-execute (slow liquidity route)\n  function test_BridgeFacet__reconcile_worksPreExecute() public {\n    utils_setupAsset(true, false);\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    delete s.routedTransfers[transferId];\n\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // funds router when post-execute (fast liquidity route)\n  function test_BridgeFacet__reconcile_fastLiquiditySingleRouterWorks() public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.routedTransfers[transferId] = [address(42)];\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // funds routers when post-execute multipath (fast liquidity route)\n  function test_BridgeFacet__reconcile_fastLiquidityMultipathWorks() public {\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n    s.routedTransfers[transferId] = [address(42), address(43), address(44), address(45)];\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"));\n  }\n\n  // should work with portals without swap\n  function test_BridgeFacet__reconcile_canUsePortalsWithoutSwap() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // should work with portals with swap\n  function test_BridgeFacet__reconcile_canUsePortalsWithSwap() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals, SwapInfo(args.amount - 10000, args.amount));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalSwapFailures() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // assume ratio of 10:1 (i.e. you put in 10x, the amount out from args.amount is 1/10 val)\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      bytes4(\"\"),\n      PortalInfo(0, 0, 0, true),\n      SwapInfo(args.amount * 10, args.amount * 10)\n    );\n  }\n\n  // should credit router leftovers from portal repayment from positive slippage of amm\n  // or previous\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaSwap() public {\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(\n      transferId,\n      args,\n      bytes4(\"\"),\n      portals,\n      SwapInfo(args.amount - 0.01 ether, args.amount + 0.2 ether)\n    );\n  }\n\n  // at some point some of the fee is repaid, remainder goes to router liq\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaFeeRepayment() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    uint256 fullFee = (args.amount * _portalFeeNumerator) / _liquidityFeeDenominator;\n    uint256 paid = fullFee / 2;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled, fullFee - paid);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // at some point some of the principle is repaid, remainder goes to router liq\n  function test_BridgeFacet__reconcile_handlesPortalDebtSurplusViaPrincipleRepayment() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    uint256 fee = (args.amount * _portalFeeNumerator) / _liquidityFeeDenominator;\n    uint256 paid = portaled / 2;\n    PortalInfo memory portals = utils_setPortals(transferId, portaled - paid, fee);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), portals);\n  }\n\n  // should prioritize debt as: as much principle as possible then as much fee as possible\n  function test_BridgeFacet__reconcile_handlesPortalDeficitPartialPrinciple() public {\n    // in this case, the swap only gives enough out to handle *some* of the amount portaled.\n    // specifically, it can only handle amount < principle\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // set the total debt\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // decrement portal repayment\n    uint256 debtRepaid = (init.debt * 9997) / 10000; // 3bps debt remaining\n    PortalInfo memory repayment = PortalInfo(0, debtRepaid, debtRepaid, true);\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), repayment, SwapInfo(init.total, debtRepaid));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalDeficitPartialFee() public {\n    // in this case, the swap only gives enough out to handle *some* of the amount portaled.\n    // specifically, it can only handle principle < amount < total\n    utils_setupAsset(false, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // set the total debt\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    uint256 debtRepaid = (init.total * 9997) / 10000; // 3bps debt remaining\n    PortalInfo memory repayment = PortalInfo(debtRepaid - init.debt, init.debt, debtRepaid, true);\n\n    // assume full repayment\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), repayment, SwapInfo(init.total, debtRepaid));\n  }\n\n  function test_BridgeFacet__reconcile_handlesPortalFailureToRepayFromAave() public {\n    utils_setupAsset(true, false);\n    // get args\n    (bytes32 transferId, XCallArgs memory args) = utils_makeXCallArgs();\n\n    // set router\n    address router = address(456545654);\n    s.routedTransfers[transferId] = [router];\n\n    // get the total debt (no repayment)\n    uint256 portaled = (args.amount * _liquidityFeeNumerator) / _liquidityFeeDenominator;\n    PortalInfo memory init = utils_setPortals(transferId, portaled);\n\n    // assume no repayment (aave will not be mocked)\n    helpers_reconcileAndAssert(transferId, args, bytes4(\"\"), PortalInfo(0, 0, 0, false));\n  }\n\n  // ============ execute ============\n  // ============ execute fail cases\n\n  // FIXME: move to `BaseConnextFacet.t.sol`\n  // should fail if paused\n  function test_BridgeFacet__execute_failIfPaused() public {\n    // set context\n    s._paused = true;\n\n    // get args\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // expect failure\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__whenNotPaused_paused.selector);\n    this.execute(args);\n  }\n\n  // should fail if msg.sender is not an approved relayer && msg.sender != params.agent\n  function test_BridgeFacet__execute_failIfSenderNotApproved() public {\n    // set context\n    s.approvedRelayers[address(this)] = false;\n\n    // get args\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // expect failure\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_unapprovedSender.selector);\n    this.execute(args);\n  }\n\n  // multipath: should fail if pathLength > maxRouters\n  function test_BridgeFacet__execute_failIfPathLengthGreaterThanMaxRouters() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(s.maxRoutersPerTransfer + 1);\n\n    for (uint256 i; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] += 10 ether;\n    }\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_maxRoutersExceeded.selector);\n    this.execute(args);\n  }\n\n  // should fail if it is a slow transfer (forceSlow = true) and not reconciled\n  function test_BridgeFacet__execute_failIfForceSlowAndNotReconciled() public {\n    _params.forceSlow = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if it is a slow transfer (forceSlow = true) and we try to execute with routers\n  function test_BridgeFacet__execute_failIfForceSlowAndRoutersSet() public {\n    _params.forceSlow = true;\n\n    // Routers providing liquidity implies this is a fast-liquidity transfer. If we're forcing slow,\n    // this should fail.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(2);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if no routers were passed in and not reconciled\n  function test_BridgeFacet__execute_failIfNoRoutersAndNotReconciled() public {\n    // Setting no routers in the execute call means that the transfer must already be reconciled.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notReconciled.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router is not approved and ownership is not renounced\n  function test_BridgeFacet__execute_failIfRouterNotApproved() public {\n    s._routerOwnershipRenounced = false;\n\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = false;\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_notSupportedRouter.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router signature is invalid\n  function test_BridgeFacet__execute_failIfSignatureInvalid() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // Make invalid args based on (slightly) altered params.\n    _params.originDomain = 1001;\n    (, ExecuteArgs memory invalidArgs) = utils_makeExecuteArgs(4);\n    // The signature of the last router in the group will be invalid.\n    args.routerSignatures[0] = invalidArgs.routerSignatures[0];\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_invalidRouterSignature.selector);\n    this.execute(args);\n  }\n\n  // multipath: should fail if any 1 router's signature is invalid\n  function test_BridgeFacet__execute_failIfAnySignatureInvalid() public {\n    // Using multipath; this should fail if any 1 router signature is invalid.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(4);\n\n    for (uint256 i; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] += 10 ether;\n    }\n\n    // Make invalid args based on (slightly) altered params.\n    _params.originDomain = 1001;\n    (, ExecuteArgs memory invalidArgs) = utils_makeExecuteArgs(4);\n    // The signature of the last router in the group will be invalid.\n    args.routerSignatures[3] = invalidArgs.routerSignatures[3];\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_invalidRouterSignature.selector);\n    this.execute(args);\n  }\n\n  // should fail if it was already executed (s.transferRelayer[transferId] != address(0))\n  function test_BridgeFacet__execute_failIfAlreadyExecuted() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.transferRelayer[transferId] = address(this);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__execute_alreadyExecuted.selector);\n    this.execute(args);\n  }\n\n  // should fail if the router does not have sufficient tokens\n  function test_BridgeFacet__execute_failIfRouterHasInsufficientFunds() public {\n    _amount = 5 ether;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(2);\n\n    s.routerBalances[args.routers[0]][args.local] = 1.5 ether;\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(args);\n  }\n\n  // multipath: should fail if any 1 router has insufficient tokens\n  function test_BridgeFacet__execute_failIfAnyRouterHasInsufficientFunds() public {\n    _amount = 5 ether;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(s.maxRoutersPerTransfer);\n\n    uint256 routerAmountSent = _amount / args.routers.length; // The amount each individual router will send.\n\n    // Set the first router's balance to be (slightly) less than the amount that they'd need to send.\n    s.routerBalances[args.routers[0]][args.local] = routerAmountSent - 0.1 ether;\n    for (uint256 i = 1; i < args.routers.length; i++) {\n      // The other routers have plenty of funds.\n      s.routerBalances[args.routers[i]][args.local] = 50 ether;\n    }\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(args);\n  }\n\n  // should fail if sponsored vault did not fund contract with returned amount\n  function test_BridgeFacet__execute_failIfSponsorVaultLied() public {\n    (, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n    for (uint256 i = 0; i < args.routers.length; i++) {\n      // The other routers have plenty of funds.\n      s.routerBalances[args.routers[i]][args.local] = 50 ether;\n    }\n\n    // set mock sponsor vault\n    address vault = address(123456654321);\n    s.sponsorVault = ISponsorVault(vault);\n    // set change\n    vm.mockCall(vault, abi.encodeWithSelector(ISponsorVault.reimburseLiquidityFees.selector), abi.encode(10 ether));\n\n    vm.expectRevert(BridgeFacet.BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount.selector);\n    this.execute(args);\n  }\n\n  function test_BridgeFacet__execute_failsIfRouterNotApprovedForPortal() public {\n    _amount = 5 ether;\n\n    (bytes32 _id, ExecuteArgs memory _args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[_args.routers[0]][_args.local] = 4.5 ether;\n\n    // set aave enabled\n    s.aavePool = _aavePool;\n\n    vm.expectRevert(abi.encodeWithSelector(BridgeFacet.BridgeFacet__execute_notApprovedForPortals.selector));\n    this.execute(_args);\n  }\n\n  // ============ execute success cases\n  // should use slow liquidity if specified (forceSlow = true)\n  function test_BridgeFacet__execute_forceSlowWorks() public {\n    // set test params\n    _params.forceSlow = true;\n\n    // get args\n    (bytes32 transferId, ExecuteArgs memory _args) = utils_makeExecuteArgs(0);\n\n    // set reconciled context\n    s.reconciledTransfers[transferId] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, _args);\n  }\n\n  // should use the local asset if specified (receiveLocal = true)\n  function test_BridgeFacet__execute_receiveLocalWorks() public {\n    _params.receiveLocal = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), false);\n  }\n\n  // should work with approved router if router ownership is not renounced\n  function test_BridgeFacet__execute_worksWithLocalAsAdopted() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // works when local != adopted\n  function test_BridgeFacet__execute_worksWithAdopted() public {\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), true);\n  }\n\n  // works when local != adopted, should work with +ve slippage\n  function test_BridgeFacet__execute_worksWithPositiveSlippage() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) + 1 ether, true);\n  }\n\n  // works when local != adopted, should work with -ve slippage\n  function test_BridgeFacet__execute_worksWithNegativeSlippage() public {\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local != adopted)\n    utils_setupAsset(false, false);\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) - 0.01 ether, true);\n  }\n\n  // works when on canonical domain\n  function test_BridgeFacet__execute_worksOnCanonical() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, true);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work when adopted asset is native asset and on canonical\n  // (adopted == wrapper)\n  function test_BridgeFacet__execute_worksWithNativeOnCanonical() public {\n    // set asset context (local == adopted)\n    utils_setupNative(true, true);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work when adopted asset is native asset and on remote\n  // (adopted == wrapper)\n  function test_BridgeFacet__execute_worksWithNativeOnRemote() public {\n    // set asset context (local != adopted)\n    utils_setupNative(false, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount), true);\n  }\n\n  // should work with unapproved router if router ownership is renounced\n  function test_BridgeFacet__execute_worksWithUnapprovedIfNoWhitelist() public {\n    s._routerOwnershipRenounced = true;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = false;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with 0 value\n  function test_BridgeFacet__execute_worksWith0Value() public {\n    _amount = 0;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work if no sponsor vault set\n  function test_BridgeFacet__execute_worksWithoutVault() public {\n    s.sponsorVault = ISponsorVault(address(0));\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should sponsor if fast liquidity is used and sponsor vault set\n  function test_BridgeFacet__execute_worksWithSponsorLiquidity() public {\n    // setup vault\n    uint256 vaultAmount = 10000;\n    MockSponsorVault vault = new MockSponsorVault(vaultAmount);\n    s.sponsorVault = vault;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(transferId, args, utils_getFastTransferAmount(args.amount) + vaultAmount, false);\n  }\n\n  // should sponsor relayer fee in slow liquidity\n  function test_BridgeFacet__execute_sponsorsRelayersSlow() public {\n    // set test vault\n    uint256 vaultAmount = 10000;\n    MockSponsorVault vault = new MockSponsorVault(vaultAmount);\n    s.sponsorVault = vault;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // get args\n    (bytes32 transferId, ExecuteArgs memory _args) = utils_makeExecuteArgs(0);\n\n    // set reconciled context\n    s.reconciledTransfers[transferId] = true;\n\n    helpers_executeAndAssert(transferId, _args);\n  }\n\n  // should work without calldata\n  function test_BridgeFacet__execute_noCalldataWorks() public {\n    _params.callData = bytes(\"\");\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // With no calldata set, this method call should just send funds directly to the user.\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with successful calldata and using fast liquidity\n  function test_BridgeFacet__execute_successfulCalldata() public {\n    // Set the args.to to the mock xapp address, and args.callData to the `fulfill` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // should work with failing calldata : contract call failed\n  function test_BridgeFacet__execute_failingCalldata() public {\n    // Set the args.to to the mock xapp address, and args.callData to the `fail` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fail.selector);\n    _params.to = _xapp;\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      false,\n      false,\n      false,\n      false\n    );\n  }\n\n  function test_BridgeFacet__execute_failsIfNoLiquidityAndAaveNotEnabled() public {\n    // get args\n    (bytes32 _id, ExecuteArgs memory _args) = utils_makeExecuteArgs(1);\n\n    // set liquidity context\n    for (uint256 i; i < _args.routers.length; i++) {\n      s.routerBalances[_args.routers[i]][_args.local] = 0 ether;\n    }\n\n    // set aave not enabled\n    s.aavePool = address(0);\n\n    vm.expectRevert(stdError.arithmeticError);\n    this.execute(_args);\n  }\n\n  // should work with a callback\n  function test_BridgeFacet__execute_worksWithCallback() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    _params.callback = address(123456654321);\n    // Set the args.to to the mock xapp address, and args.callData to the `fulfill` fn.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // FIXME: move to Executor.t.sol\n  // should work with failing calldata : recipient `to` is not a contract (should call _handleFailure)\n  function test_BridgeFacet__execute_handleRecipientNotAContract() public {\n    // Setting the calldata to be for fulfill... but obviously, that method should never be called.\n    // Because `to` is not a valid contract address.\n    _params.callData = abi.encodeWithSelector(MockXApp.fulfill.selector, _local, TEST_MESSAGE);\n    _params.to = address(42);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      true,\n      true,\n      false,\n      false,\n      false\n    );\n  }\n\n  // should work if already reconciled (happening in slow liquidity mode, uses\n  // authenticated data)\n  function test_BridgeFacet__execute_handleAlreadyReconciled() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    // Set the args.to to the mock xapp address, and args.callData to the\n    // `fulfillWithProperties` fn. This will check to make sure `originDomain` and\n    // `originSender` properties are correctly set.\n    _params.callData = abi.encodeWithSelector(\n      MockXApp.fulfillWithProperties.selector,\n      _local,\n      TEST_MESSAGE,\n      _originDomain,\n      _originSender\n    );\n    _params.to = _xapp;\n\n    // We specify that 0 routers are in the path for this execution.\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(0);\n\n    // Transfer has already been reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    helpers_executeAndAssert(transferId, args, args.amount, true, true, false, false, false);\n  }\n\n  // multipath: should subtract equally from each router's liquidity\n  function test_BridgeFacet__execute_multipath() public {\n    _amount = 1 ether;\n\n    // Should work if the pathLength == max routers.\n    uint256 pathLength = s.maxRoutersPerTransfer;\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(pathLength);\n\n    // Add initial liquiidty\n    for (uint256 i = 1; i < args.routers.length; i++) {\n      s.routerBalances[args.routers[i]][args.local] = 10 ether;\n    }\n    // Sanity check: assuming the multipath is > 1, no router should need to have more than half of the\n    // transfer amount.\n    s.routerBalances[args.routers[0]][args.local] = 0.5 ether;\n\n    uint256 amount = utils_getFastTransferAmount(args.amount);\n    uint256 routerAmountSent = amount / pathLength; // The amount each individual router will send.\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    helpers_executeAndAssert(transferId, args);\n  }\n\n  // should work with approved router if router ownership is not renounced\n  function test_BridgeFacet__execute_worksWithAgentAsSender() public {\n    address agent = address(12345654321);\n    _params.agent = agent;\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    s.routerBalances[args.routers[0]][args.local] += 10 ether;\n    s.routerPermissionInfo.approvedRouters[args.routers[0]] = true;\n\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    s.approvedRelayers[address(this)] = false;\n    helpers_executeAndAssert(transferId, args, true);\n  }\n\n  // can use liquidity from portals\n  function test_BridgeFacet__execute_worksWithAave() public {\n    // set asset context (local == adopted)\n    utils_setupAsset(true, false);\n\n    (bytes32 transferId, ExecuteArgs memory args) = utils_makeExecuteArgs(1);\n\n    // set liquidity\n    s.routerBalances[args.routers[0]][args.local] = 0;\n\n    // set approval\n    s.routerPermissionInfo.approvedForPortalRouters[args.routers[0]] = true;\n\n    helpers_executeAndAssert(\n      transferId,\n      args,\n      utils_getFastTransferAmount(args.amount),\n      false,\n      true,\n      false,\n      true,\n      false\n    );\n  }\n\n  // ============ bumpTransfer ============\n  // ============ bumpTransfer fail cases\n\n  // should work with unapproved router if router-whitelist ownership renouncedcanonicalId\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n// import {ExcessivelySafeCall} from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n// TODO: see note in below file re: npm\nimport {ExcessivelySafeCall} from \"../../../nomad-core/libs/ExcessivelySafeCall.sol\";\n\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\n\nimport {LibCrossDomainProperty, TypedMemView} from \"../libraries/LibCrossDomainProperty.sol\";\n\n/**\n * @title Executor\n * @author Connext <support@connext.network>\n * @notice This library contains an `execute` function that is callabale by\n * an associated Connext contract. This is used to execute\n * arbitrary calldata on a receiving chain.\n */\ncontract Executor is IExecutor {\n  // ============ Libraries =============\n\n  using TypedMemView for bytes29;\n  using TypedMemView for bytes;\n\n  // ============ Properties =============\n\n  address private immutable connext;\n  bytes private properties = LibCrossDomainProperty.EMPTY_BYTES;\n  uint256 private amnt;\n\n  /**\n   * @notice The amount of gas needed to execute _handleFailure\n   * @dev Used to calculate the amount of gas to reserve from transaction\n   * to properly handle failure cases\n   */\n  uint256 public FAILURE_GAS = 100_000; // Allowance decrease + transfer\n\n  /**\n   * @notice The maximum number of bytes to store in the return data\n   */\n  uint16 public MAX_COPY = 256;\n\n  // ============ Constructor =============\n\n  constructor(address _connext) {\n    connext = _connext;\n  }\n\n  // ============ Modifiers =============\n\n  /**\n   * @notice Errors if the sender is not Connext\n   */\n  modifier onlyConnext() {\n    require(msg.sender == connext, \"#OC:027\");\n    _;\n  }\n\n  // ============ Public Functions =============\n\n  /**\n   * @notice Returns the connext contract address (only address that can\n   * call the `execute` function)\n   * @return The address of the associated connext contract\n   */\n  function getConnext() external view override returns (address) {\n    return connext;\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access origin domain sender (i.e. msg.sender of `xcall`)\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function originSender() external view override returns (address) {\n    // The following will revert if it is empty\n    bytes29 _parsed = LibCrossDomainProperty.parseDomainAndSenderBytes(properties);\n    return LibCrossDomainProperty.sender(_parsed);\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access origin domain (i.e. domain of `xcall`)\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function origin() external view override returns (uint32) {\n    // The following will revert if it is empty\n    bytes29 _parsed = LibCrossDomainProperty.parseDomainAndSenderBytes(properties);\n    return LibCrossDomainProperty.domain(_parsed);\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access the amount that was delivered from the\n   * bridge. This is also set during reentrancy, but is set during fast *and* slow\n   * liquidity paths\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function amount() external view override returns (uint256) {\n    return amnt;\n  }\n\n  /**\n   * @notice Executes some arbitrary call data on a given address. The\n   * call data executes can be payable, and will have `amount` sent\n   * along with the function (or approved to the contract). If the\n   * call fails, rather than reverting, funds are sent directly to\n   * some provided fallback address\n   * @param _args ExecutorArgs to function.\n   */\n  function execute(ExecutorArgs memory _args) external payable override onlyConnext returns (bool, bytes memory) {\n    // Check if the callTo is a contract\n    bool success;\n    bytes memory returnData;\n\n    bool isNative = _args.assetId == address(0);\n\n    if (!AddressUpgradeable.isContract(_args.to)) {\n      _handleFailure(isNative, false, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n      // Emit event\n      emit Executed(\n        _args.transferId,\n        _args.to,\n        _args.recovery,\n        _args.assetId,\n        _args.amount,\n        _args.properties,\n        _args.callData,\n        returnData,\n        success\n      );\n      return (success, returnData);\n    }\n\n    // If it is not ether, approve the callTo\n    // We approve here rather than transfer since many external contracts\n    // simply require an approval, and it is unclear if they can handle\n    // funds transferred directly to them (i.e. Uniswap)\n\n    if (!isNative) {\n      SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_args.assetId), _args.to, _args.amount);\n    }\n\n    // If it should set the properties, set them.\n    // NOTE: safe to set the properties always because modifier will revert if\n    // it is the wrong type on conversion, and revert occurs with empty type as\n    // well\n    properties = _args.properties;\n\n    // Set the amount as well\n    amnt = _args.amount;\n\n    // Ensure there is enough gas to handle failures\n    uint256 gas = gasleft() - FAILURE_GAS;\n\n    // Try to execute the callData\n    // the low level call will return `false` if its execution reverts\n    (success, returnData) = ExcessivelySafeCall.excessivelySafeCall(\n      _args.to,\n      gas,\n      isNative ? _args.amount : 0,\n      MAX_COPY,\n      _args.callData\n    );\n\n    // Unset properties\n    properties = LibCrossDomainProperty.EMPTY_BYTES;\n\n    // Unset amount\n    amnt = 0;\n\n    // Handle failure cases\n    if (!success) {\n      _handleFailure(isNative, true, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n    }\n\n    // Emit event\n    emit Executed(\n      _args.transferId,\n      _args.to,\n      _args.recovery,\n      _args.assetId,\n      _args.amount,\n      _args.properties,\n      _args.callData,\n      returnData,\n      success\n    );\n    return (success, returnData);\n  }\n\n  function _handleFailure(\n    bool isNative,\n    bool hasIncreased,\n    address _assetId,\n    address payable _to,\n    address payable _recovery,\n    uint256 _amount\n  ) private {\n    if (!isNative) {\n      // Decrease allowance\n      if (hasIncreased) {\n        SafeERC20Upgradeable.safeDecreaseAllowance(IERC20Upgradeable(_assetId), _to, _amount);\n      }\n      // Transfer funds\n      SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_assetId), _recovery, _amount);\n    } else {\n      // Transfer funds\n      AddressUpgradeable.sendValue(_recovery, _amount);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "BridgeFacet.sol",
            "Executor.t.sol",
            "BridgeFacet.t.sol",
            "Executor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_handleExecuteTransaction function in BridgeFacet.sol and Executor.sol",
                "Type": "Fee-on-transfer token vulnerability",
                "Description": "The _handleExecuteTransaction function may not work correctly on fee-on-transfer tokens. Moreover, if it fails, funds may be locked forever. As duplicated fees are applied to fee-on-transfer tokens when executing an arbitrary call message passing request, the Executor contract increases the allowance on that token for that target contract in full amount without any fee, which may open a vulnerability to steal dust fund in the contract. Failure occurs when trying to send the full amount without any fee, which is not possible because the fee is already applied one time.",
                "Repair": "Approve only one step to avoid an extra token transfer"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {AppStorage} from \"../libraries/LibConnextStorage.sol\";\n\n/**\n * @notice\n * This contract is designed to manage router access, meaning it maintains the\n * router recipients, owners, and the router whitelist itself.\n *\n * As a router, there are three important permissions:\n * `router` - this is the address that will sign bids sent to the sequencer\n * `routerRecipient` - this is the address that receives funds when liquidity is withdrawn\n * `routerOwner` - this is the address permitted to update recipients and propose new owners\n *\n * In cases where the owner is not set, the caller should be the `router` itself. In cases where the\n * `routerRecipient` is not set, the funds can be removed to anywhere.\n *\n * When setting a new `routerOwner`, the current owner (or router) must create a proposal, which\n * can be accepted by the proposed owner after the delay period. If the proposed owner is the empty\n * address, then it must be accepted by the current owner.\n */\ncontract RoutersFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error RoutersFacet__acceptProposedRouterOwner_notElapsed();\n  error RoutersFacet__setRouterRecipient_notNewRecipient();\n  error RoutersFacet__onlyRouterOwner_notRouterOwner();\n  error RoutersFacet__onlyProposedRouterOwner_notRouterOwner();\n  error RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner();\n  error RoutersFacet__removeRouter_routerEmpty();\n  error RoutersFacet__removeRouter_notAdded();\n  error RoutersFacet__setupRouter_routerEmpty();\n  error RoutersFacet__setupRouter_alreadyAdded();\n  error RoutersFacet__proposeRouterOwner_notNewOwner();\n  error RoutersFacet__proposeRouterOwner_badRouter();\n  error RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\n  error RoutersFacet__addLiquidityForRouter_routerEmpty();\n  error RoutersFacet__addLiquidityForRouter_amountIsZero();\n  error RoutersFacet__addLiquidityForRouter_badRouter();\n  error RoutersFacet__addLiquidityForRouter_badAsset();\n  error RoutersFacet__removeRouterLiquidity_recipientEmpty();\n  error RoutersFacet__removeRouterLiquidity_amountIsZero();\n  error RoutersFacet__removeRouterLiquidity_insufficientFunds();\n  error RoutersFacet__removeRouterLiquidityFor_notOwner();\n  error RoutersFacet__setLiquidityFeeNumerator_tooSmall();\n  error RoutersFacet__setLiquidityFeeNumerator_tooLarge();\n  error RoutersFacet__approveRouterForPortal_notRouter();\n  error RoutersFacet__approveRouterForPortal_alreadyApproved();\n  error RoutersFacet__unapproveRouterForPortal_notApproved();\n\n  // ============ Properties ============\n\n  // ============ Constants ============\n  uint256 private constant _delay = 7 days;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new router is added\n   * @param router - The address of the added router\n   * @param caller - The account that called the function\n   */\n  event RouterAdded(address indexed router, address caller);\n\n  /**\n   * @notice Emitted when an existing router is removed\n   * @param router - The address of the removed router\n   * @param caller - The account that called the function\n   */\n  event RouterRemoved(address indexed router, address caller);\n\n  /**\n   * @notice Emitted when the recipient of router is updated\n   * @param router - The address of the added router\n   * @param prevRecipient  - The address of the previous recipient of the router\n   * @param newRecipient  - The address of the new recipient of the router\n   */\n  event RouterRecipientSet(address indexed router, address indexed prevRecipient, address indexed newRecipient);\n\n  /**\n   * @notice Emitted when the owner of router is proposed\n   * @param router - The address of the added router\n   * @param prevProposed  - The address of the previous proposed\n   * @param newProposed  - The address of the new proposed\n   */\n  event RouterOwnerProposed(address indexed router, address indexed prevProposed, address indexed newProposed);\n\n  /**\n   * @notice Emitted when the owner of router is accepted\n   * @param router - The address of the added router\n   * @param prevOwner  - The address of the previous owner of the router\n   * @param newOwner  - The address of the new owner of the router\n   */\n  event RouterOwnerAccepted(address indexed router, address indexed prevOwner, address indexed newOwner);\n\n  /**\n   * @notice Emitted when the maxRoutersPerTransfer variable is updated\n   * @param maxRoutersPerTransfer - The maxRoutersPerTransfer new value\n   * @param caller - The account that called the function\n   */\n  event MaxRoutersPerTransferUpdated(uint256 maxRoutersPerTransfer, address caller);\n\n  /**\n   * @notice Emitted when the LIQUIDITY_FEE_NUMERATOR variable is updated\n   * @param liquidityFeeNumerator - The LIQUIDITY_FEE_NUMERATOR new value\n   * @param caller - The account that called the function\n   */\n  event LiquidityFeeNumeratorUpdated(uint256 liquidityFeeNumerator, address caller);\n\n  /**\n   * @notice Emitted when a router is approved for Portal\n   * @param router - The address of the approved router\n   * @param caller - The account that called the function\n   */\n  event RouterApprovedForPortal(address router, address caller);\n\n  /**\n   * @notice Emitted when a router is disapproved for Portal\n   * @param router - The address of the disapproved router\n   * @param caller - The account that called the function\n   */\n  event RouterUnapprovedForPortal(address router, address caller);\n\n  /**\n   * @notice Emitted when a router adds liquidity to the contract\n   * @param router - The address of the router the funds were credited to\n   * @param local - The address of the token added (all liquidity held in local asset)\n   * @param amount - The amount of liquidity added\n   * @param caller - The account that called the function\n   */\n  event RouterLiquidityAdded(\n    address indexed router,\n    address local,\n    bytes32 canonicalId,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when a router withdraws liquidity from the contract\n   * @param router - The router you are removing liquidity from\n   * @param to - The address the funds were withdrawn to\n   * @param local - The address of the token withdrawn\n   * @param amount - The amount of liquidity withdrawn\n   * @param caller - The account that called the function\n   */\n  event RouterLiquidityRemoved(address indexed router, address to, address local, uint256 amount, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Asserts caller is the router owner (if set) or the router itself\n   */\n  modifier onlyRouterOwner(address _router) {\n    address owner = s.routerPermissionInfo.routerOwners[_router];\n    if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\n      revert RoutersFacet__onlyRouterOwner_notRouterOwner();\n    _;\n  }\n\n  /**\n   * @notice Asserts caller is the proposed router. If proposed router is address(0), then asserts\n   * the owner is calling the function (if set), or the router itself is calling the function\n   */\n  modifier onlyProposedRouterOwner(address _router) {\n    address proposed = s.routerPermissionInfo.proposedRouterOwners[_router];\n    if (proposed == address(0)) {\n      address owner = s.routerPermissionInfo.routerOwners[_router];\n      if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\n        revert RoutersFacet__onlyProposedRouterOwner_notRouterOwner();\n    } else {\n      if (msg.sender != proposed) revert RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner();\n    }\n    _;\n  }\n\n  // ============ Getters ==============\n\n  function LIQUIDITY_FEE_NUMERATOR() public view returns (uint256) {\n    return s.LIQUIDITY_FEE_NUMERATOR;\n  }\n\n  function LIQUIDITY_FEE_DENOMINATOR() public view returns (uint256) {\n    return s.LIQUIDITY_FEE_DENOMINATOR;\n  }\n\n  /**\n   * @notice Returns the approved router for the given router address\n   * @param _router The relevant router address\n   */\n  function getRouterApproval(address _router) public view returns (bool) {\n    return s.routerPermissionInfo.approvedRouters[_router];\n  }\n\n  /**\n   * @notice Returns the recipient for the specified router\n   * @dev The recipient (if set) receives all funds when router liquidity is removed\n   * @param _router The relevant router address\n   */\n  function getRouterRecipient(address _router) public view returns (address) {\n    return s.routerPermissionInfo.routerRecipients[_router];\n  }\n\n  /**\n   * @notice Returns the router owner if it is set, or the router itself if not\n   * @dev Uses logic function here to handle the case where router owner is not set.\n   * Other getters within this interface use explicitly the stored value\n   * @param _router The relevant router address\n   */\n  function getRouterOwner(address _router) public view returns (address) {\n    address _owner = s.routerPermissionInfo.routerOwners[_router];\n    return _owner == address(0) ? _router : _owner;\n  }\n\n  /**\n   * @notice Returns the currently proposed router owner\n   * @dev All routers must wait for the delay timeout before accepting a new owner\n   * @param _router The relevant router address\n   */\n  function getProposedRouterOwner(address _router) public view returns (address) {\n    return s.routerPermissionInfo.proposedRouterOwners[_router];\n  }\n\n  /**\n   * @notice Returns the currently proposed router owner timestamp\n   * @dev All routers must wait for the delay timeout before accepting a new owner\n   * @param _router The relevant router address\n   */\n  function getProposedRouterOwnerTimestamp(address _router) public view returns (uint256) {\n    return s.routerPermissionInfo.proposedRouterTimestamp[_router];\n  }\n\n  function maxRoutersPerTransfer() public view returns (uint256) {\n    return s.maxRoutersPerTransfer;\n  }\n\n  function routerBalances(address _router, address _asset) public view returns (uint256) {\n    return s.routerBalances[_router][_asset];\n  }\n\n  /**\n   * @notice Returns whether the router is approved for portals or not\n   * @param _router The relevant router address\n   */\n  function getRouterApprovalForPortal(address _router) public view returns (bool) {\n    return s.routerPermissionInfo.approvedForPortalRouters[_router];\n  }\n\n  // ============ Admin methods ==============\n\n  /**\n   * @notice Used to set router initial properties\n   * @param router Router address to setup\n   * @param owner Initial Owner of router\n   * @param recipient Initial Recipient of router\n   */\n  function setupRouter(\n    address router,\n    address owner,\n    address recipient\n  ) external onlyOwner {\n    // Sanity check: not empty\n    if (router == address(0)) revert RoutersFacet__setupRouter_routerEmpty();\n\n    // Sanity check: needs approval\n    if (s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__setupRouter_alreadyAdded();\n\n    // Approve router\n    s.routerPermissionInfo.approvedRouters[router] = true;\n\n    // Emit event\n    emit RouterAdded(router, msg.sender);\n\n    // Update routerOwner (zero address possible)\n    if (owner != address(0)) {\n      s.routerPermissionInfo.routerOwners[router] = owner;\n      emit RouterOwnerAccepted(router, address(0), owner);\n    }\n\n    // Update router recipient\n    if (recipient != address(0)) {\n      s.routerPermissionInfo.routerRecipients[router] = recipient;\n      emit RouterRecipientSet(router, address(0), recipient);\n    }\n  }\n\n  /**\n   * @notice Used to remove routers that can transact crosschain\n   * @param router Router address to remove\n   */\n  function removeRouter(address router) external onlyOwner {\n    // Sanity check: not empty\n    if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();\n\n    // Sanity check: needs removal\n    if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();\n\n    // Update mapping\n    s.routerPermissionInfo.approvedRouters[router] = false;\n\n    // Emit event\n    emit RouterRemoved(router, msg.sender);\n\n    // Remove router owner\n    address _owner = s.routerPermissionInfo.routerOwners[router];\n    if (_owner != address(0)) {\n      emit RouterOwnerAccepted(router, _owner, address(0));\n      // delete routerOwners[router];\n      s.routerPermissionInfo.routerOwners[router] = address(0);\n    }\n\n    // Remove router recipient\n    address _recipient = s.routerPermissionInfo.routerRecipients[router];\n    if (_recipient != address(0)) {\n      emit RouterRecipientSet(router, _recipient, address(0));\n      // delete routerRecipients[router];\n      s.routerPermissionInfo.routerRecipients[router] = address(0);\n    }\n\n    // Clear any proposed ownership changes\n    s.routerPermissionInfo.proposedRouterOwners[router] = address(0);\n    s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;\n  }\n\n  /**\n   * @notice Used to set the max amount of routers a payment can be routed through\n   * @param _newMaxRouters The new max amount of routers\n   */\n  function setMaxRoutersPerTransfer(uint256 _newMaxRouters) external onlyOwner {\n    if (_newMaxRouters == 0 || _newMaxRouters == s.maxRoutersPerTransfer)\n      revert RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\n\n    emit MaxRoutersPerTransferUpdated(_newMaxRouters, msg.sender);\n\n    s.maxRoutersPerTransfer = _newMaxRouters;\n  }\n\n  /**\n   * @notice Sets the LIQUIDITY_FEE_NUMERATOR\n   * @dev Admin can set LIQUIDITY_FEE_NUMERATOR variable, Liquidity fee should be less than 5%\n   * @param _numerator new LIQUIDITY_FEE_NUMERATOR\n   */\n  function setLiquidityFeeNumerator(uint256 _numerator) external onlyOwner {\n    // Slightly misleading: the liquidity fee numerator is not the amount charged,\n    // but the amount received after fees are deducted (e.g. 9995/10000 would be .005%).\n    uint256 denominator = s.LIQUIDITY_FEE_DENOMINATOR;\n    if (_numerator < (denominator * 95) / 100) revert RoutersFacet__setLiquidityFeeNumerator_tooSmall();\n\n    if (_numerator > denominator) revert RoutersFacet__setLiquidityFeeNumerator_tooLarge();\n    s.LIQUIDITY_FEE_NUMERATOR = _numerator;\n\n    emit LiquidityFeeNumeratorUpdated(_numerator, msg.sender);\n  }\n\n  /**\n   * @notice Allow router to use Portals\n   * @param _router - The router address to approve\n   */\n  function approveRouterForPortal(address _router) external onlyOwner {\n    if (!s.routerPermissionInfo.approvedRouters[_router]) revert RoutersFacet__approveRouterForPortal_notRouter();\n    if (s.routerPermissionInfo.approvedForPortalRouters[_router])\n      revert RoutersFacet__approveRouterForPortal_alreadyApproved();\n\n    s.routerPermissionInfo.approvedForPortalRouters[_router] = true;\n\n    emit RouterApprovedForPortal(_router, msg.sender);\n  }\n\n  /**\n   * @notice Remove router access to use Portals\n   * @param _router - The router address to remove approval\n   */\n  function unapproveRouterForPortal(address _router) external onlyOwner {\n    if (!s.routerPermissionInfo.approvedForPortalRouters[_router])\n      revert RoutersFacet__unapproveRouterForPortal_notApproved();\n\n    s.routerPermissionInfo.approvedForPortalRouters[_router] = false;\n\n    emit RouterUnapprovedForPortal(_router, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Sets the designated recipient for a router\n   * @dev Router should only be able to set this once otherwise if router key compromised,\n   * no problem is solved since attacker could just update recipient\n   * @param router Router address to set recipient\n   * @param recipient Recipient Address to set to router\n   */\n  function setRouterRecipient(address router, address recipient) external onlyRouterOwner(router) {\n    // Check recipient is changing\n    address _prevRecipient = s.routerPermissionInfo.routerRecipients[router];\n    if (_prevRecipient == recipient) revert RoutersFacet__setRouterRecipient_notNewRecipient();\n\n    // Set new recipient\n    s.routerPermissionInfo.routerRecipients[router] = recipient;\n\n    // Emit event\n    emit RouterRecipientSet(router, _prevRecipient, recipient);\n  }\n\n  /**\n   * @notice Current owner or router may propose a new router owner\n   * @param router Router address to set recipient\n   * @param proposed Proposed owner Address to set to router\n   */\n  function proposeRouterOwner(address router, address proposed) external onlyRouterOwner(router) {\n    // Check that proposed is different than current owner\n    if (getRouterOwner(router) == proposed) revert RoutersFacet__proposeRouterOwner_notNewOwner();\n\n    // Check that proposed is different than current proposed\n    address _currentProposed = s.routerPermissionInfo.proposedRouterOwners[router];\n    if (_currentProposed == proposed) revert RoutersFacet__proposeRouterOwner_badRouter();\n\n    // Set proposed owner + timestamp\n    s.routerPermissionInfo.proposedRouterOwners[router] = proposed;\n    s.routerPermissionInfo.proposedRouterTimestamp[router] = block.timestamp;\n\n    // Emit event\n    emit RouterOwnerProposed(router, _currentProposed, proposed);\n  }\n\n  /**\n   * @notice New router owner must accept role, or previous if proposed is 0x0\n   * @param router Router address to set recipient\n   */\n  function acceptProposedRouterOwner(address router) external onlyProposedRouterOwner(router) {\n    address owner = getRouterOwner(router);\n\n    // Check timestamp has passed\n    if (block.timestamp - s.routerPermissionInfo.proposedRouterTimestamp[router] <= _delay)\n      revert RoutersFacet__acceptProposedRouterOwner_notElapsed();\n\n    // Get current owner + proposed\n    address _proposed = s.routerPermissionInfo.proposedRouterOwners[router];\n\n    // Update the current owner\n    s.routerPermissionInfo.routerOwners[router] = _proposed;\n\n    // Reset proposal + timestamp\n    if (_proposed != address(0)) {\n      s.routerPermissionInfo.proposedRouterOwners[router] = address(0);\n    }\n    s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;\n\n    // Emit event\n    emit RouterOwnerAccepted(router, owner, _proposed);\n  }\n\n  /**\n   * @notice This is used by anyone to increase a router's available liquidity for a given asset.\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the asset you're adding liquidity for. If adding liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _router The router you are adding liquidity on behalf of\n   */\n  function addRouterLiquidityFor(\n    uint256 _amount,\n    address _local,\n    address _router\n  ) external payable nonReentrant whenNotPaused {\n    _addLiquidityForRouter(_amount, _local, _router);\n  }\n\n  /**\n   * @notice This is used by any router to increase their available liquidity for a given asset.\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the asset you're adding liquidity for. If adding liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   */\n  function addRouterLiquidity(uint256 _amount, address _local) external payable nonReentrant whenNotPaused {\n    _addLiquidityForRouter(_amount, _local, msg.sender);\n  }\n\n  /**\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _to The address that will receive the liquidity being removed\n   * @param _router The address of the router\n   */\n  function removeRouterLiquidityFor(\n    uint256 _amount,\n    address _local,\n    address payable _to,\n    address _router\n  ) external nonReentrant whenNotPaused {\n    // Caller must be the router owner\n    if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();\n\n    // Remove liquidity\n    _removeLiquidityForRouter(_amount, _local, _to, _router);\n  }\n\n  /**\n   * @notice This is used by any router to decrease their available liquidity for a given asset.\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _to The address that will receive the liquidity being removed if no router recipient exists.\n   */\n  function removeRouterLiquidity(\n    uint256 _amount,\n    address _local,\n    address payable _to\n  ) external nonReentrant whenNotPaused {\n    _removeLiquidityForRouter(_amount, _local, _to, msg.sender);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Contains the logic to verify + increment a given routers liquidity\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the nomad representation of the asset\n   * @param _router - The router you are adding liquidity on behalf of\n   */\n  function _addLiquidityForRouter(\n    uint256 _amount,\n    address _local,\n    address _router\n  ) internal {\n    // Sanity check: router is sensible\n    if (_router == address(0)) revert RoutersFacet__addLiquidityForRouter_routerEmpty();\n\n    // Sanity check: nonzero amounts\n    if (_amount == 0) revert RoutersFacet__addLiquidityForRouter_amountIsZero();\n\n    // Get the canonical asset id from the representation\n    (, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_local == address(0) ? address(s.wrapper) : _local);\n\n    // Router is approved\n    if (!_isRouterOwnershipRenounced() && !getRouterApproval(_router))\n      revert RoutersFacet__addLiquidityForRouter_badRouter();\n\n    // Asset is approved\n    if (!_isAssetOwnershipRenounced() && !s.approvedAssets[canonicalId])\n      revert RoutersFacet__addLiquidityForRouter_badAsset();\n\n    // Transfer funds to contract\n    (address asset, uint256 received) = AssetLogic.handleIncomingAsset(_local, _amount, 0);\n\n    // Update the router balances. Happens after pulling funds to account for\n    // the fee on transfer tokens\n    s.routerBalances[_router][asset] += received;\n\n    // Emit event\n    emit RouterLiquidityAdded(_router, asset, canonicalId, received, msg.sender);\n  }\n\n  /**\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _to The address that will receive the liquidity being removed\n   * @param _router The address of the router\n   */\n  function _removeLiquidityForRouter(\n    uint256 _amount,\n    address _local,\n    address payable _to,\n    address _router\n  ) internal {\n    // transfer to specicfied recipient IF recipient not set\n    address recipient = getRouterRecipient(_router);\n    recipient = recipient == address(0) ? _to : recipient;\n\n    // Sanity check: to is sensible\n    if (recipient == address(0)) revert RoutersFacet__removeRouterLiquidity_recipientEmpty();\n\n    // Sanity check: nonzero amounts\n    if (_amount == 0) revert RoutersFacet__removeRouterLiquidity_amountIsZero();\n\n    // Get the local key\n    address key = _local == address(0) ? address(s.wrapper) : _local;\n\n    // Get existing router balance\n    uint256 routerBalance = s.routerBalances[_router][key];\n\n    // Sanity check: amount can be deducted for the router\n    if (routerBalance < _amount) revert RoutersFacet__removeRouterLiquidity_insufficientFunds();\n\n    // Update router balances\n    unchecked {\n      s.routerBalances[_router][key] = routerBalance - _amount;\n    }\n\n    // Transfer from contract to specified to\n    AssetLogic.transferAssetFromContract(key, recipient, _amount);\n\n    // Emit event\n    emit RouterLiquidityRemoved(_router, recipient, _local, _amount, msg.sender);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {LibDiamond} from \"../../../../contracts/core/connext/libraries/LibDiamond.sol\";\nimport {IStableSwap} from \"../../../../contracts/core/connext/interfaces/IStableSwap.sol\";\nimport {ITokenRegistry} from \"../../../../contracts/core/connext/interfaces/ITokenRegistry.sol\";\nimport {IWrapped} from \"../../../../contracts/core/connext/interfaces/IWrapped.sol\";\nimport {ConnextMessage} from \"../../../../contracts/core/connext/libraries/ConnextMessage.sol\";\nimport {RoutersFacet, BaseConnextFacet} from \"../../../../contracts/core/connext/facets/RoutersFacet.sol\";\nimport {TestERC20} from \"../../../../contracts/test/TestERC20.sol\";\n\nimport {MockWrapper, MockTokenRegistry} from \"../../../utils/Mock.sol\";\n\nimport \"./FacetHelper.sol\";\n\ncontract RoutersFacetTest is RoutersFacet, FacetHelper {\n  // ============ storage ============\n  // owner\n  address _owner = address(12345);\n\n  // sample data\n  uint32 _domain = _originDomain;\n\n  address _routerAgent0 = address(222000111); // 0x000000000000000000000000000000000d3b73ef\n  address _routerRecipient0 = address(222000222); // 0x000000000000000000000000000000000d3b745e\n  address _routerOwner0 = address(222000333); // 0x000000000000000000000000000000000d3b74cd\n\n  address _routerAgent1 = address(222001111);\n  address _routerRecipient1 = address(222001222);\n  address _routerOwner1 = address(222001333);\n\n  address _routerAgent2 = address(222002111);\n  address _routerRecipient2 = address(222002222);\n  address _routerOwner2 = address(222002333);\n\n  address _asset0 = address(333000111);\n  address _asset1 = address(333001111);\n\n  // ============ Test set up ============\n  function setUp() public {\n    setOwner(_owner);\n  }\n\n  // ============ Utils ==============\n  // Set diamond storage owner\n  function setOwner(address owner) internal {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.contractOwner = owner;\n  }\n\n  // ============ Test methods ============\n\n  // TODO: test modifiers? onlyRouterOwner, onlyProposedRouterOwner, etc.\n\n  // ============ Getters ==============\n\n  function test_RoutersFacet__LIQUIDITY_FEE_NUMERATOR_success() public {\n    s.LIQUIDITY_FEE_NUMERATOR = 54321;\n    assertEq(this.LIQUIDITY_FEE_NUMERATOR(), 54321);\n  }\n\n  function test_RoutersFacet__LIQUIDITY_FEE_NUMERATOR_notFound() public {\n    assertEq(this.LIQUIDITY_FEE_NUMERATOR(), 0);\n  }\n\n  function test_RoutersFacet__LIQUIDITY_FEE_DENOMINATOR_success() public {\n    s.LIQUIDITY_FEE_DENOMINATOR = 12345;\n    assertEq(this.LIQUIDITY_FEE_DENOMINATOR(), 12345);\n  }\n\n  function test_RoutersFacet__LIQUIDITY_FEE_DENOMINATOR_notFound() public {\n    assertEq(this.LIQUIDITY_FEE_DENOMINATOR(), 0);\n  }\n\n  function test_RoutersFacet__getRouterApproval_success() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    assertEq(this.getRouterApproval(_routerAgent0), true);\n  }\n\n  function test_RoutersFacet__getRouterApproval_notFound() public {\n    assertEq(this.getRouterApproval(_routerAgent0), false);\n  }\n\n  function test_RoutersFacet__getRouterRecipient_success() public {\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n    assertEq(this.getRouterRecipient(_routerAgent0), _routerRecipient0);\n  }\n\n  function test_RoutersFacet__getRouterRecipient_notFound() public {\n    assertEq(this.getRouterRecipient(_routerAgent0), address(0));\n  }\n\n  function test_RoutersFacet__getRouterOwner_success() public {\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    assertEq(this.getRouterOwner(_routerAgent0), _routerOwner0);\n  }\n\n  function test_RoutersFacet__getRouterOwner_notFound() public {\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], address(0));\n    // NOTE: If router owner was not set, this method should return the router address itself.\n    address routerOwner = this.getRouterOwner(_routerAgent0);\n    assertEq(routerOwner, _routerAgent0);\n  }\n\n  function test_RoutersFacet__getProposedRouterOwner_success() public {\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = _routerOwner0;\n    assertEq(this.getProposedRouterOwner(_routerAgent0), _routerOwner0);\n  }\n\n  function test_RoutersFacet__getProposedRouterOwner_notFound() public {\n    assertEq(this.getProposedRouterOwner(_routerAgent0), address(0));\n  }\n\n  function test_RoutersFacet__getProposedRouterOwnerTimestamp() public {\n    s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0] = 12345;\n    assertEq(this.getProposedRouterOwnerTimestamp(_routerAgent0), 12345);\n  }\n\n  function test_RoutersFacet__maxRoutersPerTransfer_success() public {\n    s.maxRoutersPerTransfer = 12345;\n    assertEq(this.maxRoutersPerTransfer(), 12345);\n  }\n\n  function test_RoutersFacet__maxRoutersPerTransfer_notFound() public {\n    assertEq(this.maxRoutersPerTransfer(), 0);\n  }\n\n  function test_RoutersFacet__routerBalances_success() public {\n    s.routerBalances[_routerAgent0][_asset0] = 12345;\n    s.routerBalances[_routerAgent0][_asset1] = 5678;\n    assertEq(this.routerBalances(_routerAgent0, _asset0), 12345);\n    assertEq(this.routerBalances(_routerAgent0, _asset1), 5678);\n  }\n\n  function test_RoutersFacet__routerBalances_notFound() public {\n    assertEq(this.routerBalances(_routerAgent0, _asset0), 0);\n  }\n\n  // ============ Admin methods ==============\n\n  // setupRouter\n  function test_RoutersFacet__setupRouter_success() public {\n    assertEq(s.routerPermissionInfo.approvedRouters[_routerAgent0], false);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterAdded(_routerAgent0, _owner);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterOwnerAccepted(_routerAgent0, address(0), _routerOwner0);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterRecipientSet(_routerAgent0, address(0), _routerRecipient0);\n\n    vm.prank(_owner);\n    this.setupRouter(_routerAgent0, _routerOwner0, _routerRecipient0);\n\n    assertEq(s.routerPermissionInfo.approvedRouters[_routerAgent0], true);\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], _routerOwner0);\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], _routerRecipient0);\n\n    // Should never touch these values:\n    assertEq(s.routerPermissionInfo.proposedRouterOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0], 0);\n  }\n\n  function test_RoutersFacet__setupRouter_failsIfNotOwner() public {\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    vm.prank(address(123456123));\n    this.setupRouter(address(0), _routerOwner0, _routerRecipient0);\n  }\n\n  function test_RoutersFacet__setupRouter_failsIfRouterAddressIsZero() public {\n    vm.expectRevert(RoutersFacet.RoutersFacet__setupRouter_routerEmpty.selector);\n    vm.prank(_owner);\n    this.setupRouter(address(0), _routerOwner0, _routerRecipient0);\n  }\n\n  function test_RoutersFacet__setupRouter_failsIfRouterAlreadyApproved() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    vm.expectRevert(RoutersFacet.RoutersFacet__setupRouter_alreadyAdded.selector);\n    vm.prank(_owner);\n    this.setupRouter(_routerAgent0, _routerOwner0, _routerRecipient0);\n  }\n\n  function test_RoutersFacet__setupRouter_shouldHandleNoOwner() public {\n    vm.expectEmit(true, true, false, true);\n    emit RouterAdded(_routerAgent0, _owner);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterRecipientSet(_routerAgent0, address(0), _routerRecipient0);\n\n    vm.prank(_owner);\n    this.setupRouter(_routerAgent0, address(0), _routerRecipient0);\n\n    assertEq(s.routerPermissionInfo.approvedRouters[_routerAgent0], true);\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], _routerRecipient0);\n  }\n\n  function test_RoutersFacet__setupRouter_shouldHandleNoRecipient() public {\n    vm.expectEmit(true, true, false, true);\n    emit RouterAdded(_routerAgent0, _owner);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterOwnerAccepted(_routerAgent0, address(0), _routerOwner0);\n\n    vm.prank(_owner);\n    this.setupRouter(_routerAgent0, _routerOwner0, address(0));\n\n    assertEq(s.routerPermissionInfo.approvedRouters[_routerAgent0], true);\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], _routerOwner0);\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], address(0));\n  }\n\n  // removeRouter\n  function test_RoutersFacet__removeRouter_success() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n    // Should also remove these values, if they were previously set.\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = _routerOwner1;\n    s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0] = 12345;\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterRemoved(_routerAgent0, _owner);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterOwnerAccepted(_routerAgent0, _routerOwner0, address(0));\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterRecipientSet(_routerAgent0, _routerRecipient0, address(0));\n\n    vm.prank(_owner);\n    this.removeRouter(_routerAgent0);\n\n    assertEq(s.routerPermissionInfo.approvedRouters[_routerAgent0], false);\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.proposedRouterOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0], 0);\n  }\n\n  function test_RoutersFacet__removeRouter_failsIfNotOwner() public {\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    vm.prank(address(123456123));\n    this.removeRouter(address(0));\n  }\n\n  function test_RoutersFacet__removeRouter_failsIfRouterAddressIsZero() public {\n    vm.expectRevert(RoutersFacet.RoutersFacet__removeRouter_routerEmpty.selector);\n    vm.prank(_owner);\n    this.removeRouter(address(0));\n  }\n\n  function test_RoutersFacet__removeRouter_failsIfRouterNotApproved() public {\n    vm.expectRevert(RoutersFacet.RoutersFacet__removeRouter_notAdded.selector);\n    vm.prank(_owner);\n    this.removeRouter(_routerAgent0);\n  }\n\n  function test_RoutersFacet__removeRouter_handlesNoOwner() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = address(0);\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = _routerOwner1;\n    s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0] = 12345;\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterRemoved(_routerAgent0, _owner);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterRecipientSet(_routerAgent0, _routerRecipient0, address(0));\n\n    vm.prank(_owner);\n    this.removeRouter(_routerAgent0);\n\n    assertEq(s.routerPermissionInfo.approvedRouters[_routerAgent0], false);\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.proposedRouterOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0], 0);\n  }\n\n  function test_RoutersFacet__removeRouter_handlesNoRecipient() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = address(0);\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = _routerOwner1;\n    s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0] = 12345;\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterRemoved(_routerAgent0, _owner);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterOwnerAccepted(_routerAgent0, _routerOwner0, address(0));\n\n    vm.prank(_owner);\n    this.removeRouter(_routerAgent0);\n\n    assertEq(s.routerPermissionInfo.approvedRouters[_routerAgent0], false);\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.proposedRouterOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0], 0);\n  }\n\n  // setMaxRoutersPerTransfer\n  function test_RoutersFacet__setMaxRoutersPerTransfer_success() public {\n    // Change from zero.\n    vm.expectEmit(true, true, false, true);\n    emit MaxRoutersPerTransferUpdated(123, _owner);\n\n    s.maxRoutersPerTransfer = 0;\n    vm.prank(_owner);\n    this.setMaxRoutersPerTransfer(123);\n    assertEq(s.maxRoutersPerTransfer, 123);\n\n    // Increasable.\n    vm.expectEmit(true, true, false, true);\n    emit MaxRoutersPerTransferUpdated(9999999, _owner);\n\n    s.maxRoutersPerTransfer = 777;\n    vm.prank(_owner);\n    this.setMaxRoutersPerTransfer(9999999);\n    assertEq(s.maxRoutersPerTransfer, 9999999);\n\n    // Decreasable.\n    vm.expectEmit(true, true, false, true);\n    emit MaxRoutersPerTransferUpdated(1, _owner);\n\n    s.maxRoutersPerTransfer = 777;\n    vm.prank(_owner);\n    this.setMaxRoutersPerTransfer(1);\n    assertEq(s.maxRoutersPerTransfer, 1);\n  }\n\n  function test_RoutersFacet__setMaxRoutersPerTransfer_failsIfNotOwner() public {\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    vm.prank(address(123456654321));\n    this.setMaxRoutersPerTransfer(10);\n  }\n\n  function test_RoutersFacet__setMaxRoutersPerTransfer_failsIfZero() public {\n    s.maxRoutersPerTransfer = 10;\n    vm.expectRevert(RoutersFacet.RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer.selector);\n    vm.prank(_owner);\n    this.setMaxRoutersPerTransfer(0);\n    assertEq(s.maxRoutersPerTransfer, 10);\n  }\n\n  function test_RoutersFacet__setMaxRoutersPerTransfer_failsIfRedundant() public {\n    s.maxRoutersPerTransfer = 10;\n    vm.expectRevert(RoutersFacet.RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer.selector);\n    vm.prank(_owner);\n    this.setMaxRoutersPerTransfer(10);\n\n    assertEq(s.maxRoutersPerTransfer, 10);\n  }\n\n  // setLiquidityFeeNumerator\n  function test_RoutersFacet__setLiquidityFeeNumerator_success() public {\n    s.LIQUIDITY_FEE_DENOMINATOR = 10000;\n    s.LIQUIDITY_FEE_NUMERATOR = 9995; // Fee is currently 5 basis points.\n\n    vm.expectEmit(true, true, false, true);\n    emit LiquidityFeeNumeratorUpdated(9970, _owner);\n\n    vm.prank(_owner);\n    this.setLiquidityFeeNumerator(9970); // Set fee to 30 basis points.\n    assertEq(s.LIQUIDITY_FEE_NUMERATOR, 9970);\n  }\n\n  function test_RoutersFacet__setLiquidityFeeNumerator_failsIfNotOwner() public {\n    vm.expectRevert(BaseConnextFacet.BaseConnextFacet__onlyOwner_notOwner.selector);\n    vm.prank(address(123456654321));\n    this.setLiquidityFeeNumerator(9995);\n  }\n\n  function test_RoutersFacet__setLiquidityFeeNumerator_failsIfTooSmall() public {\n    s.LIQUIDITY_FEE_DENOMINATOR = 10000;\n    s.LIQUIDITY_FEE_NUMERATOR = 9995; // Fee is currently 5 basis points.\n\n    vm.expectRevert(RoutersFacet.RoutersFacet__setLiquidityFeeNumerator_tooSmall.selector);\n    vm.prank(_owner);\n    // Set fee to 600 basis points, which is over the 5% limit.\n    this.setLiquidityFeeNumerator(9400);\n    assertEq(s.LIQUIDITY_FEE_NUMERATOR, 9995);\n  }\n\n  function test_RoutersFacet__setLiquidityFeeNumerator_failsIfTooLarge() public {\n    s.LIQUIDITY_FEE_DENOMINATOR = 10000;\n    s.LIQUIDITY_FEE_NUMERATOR = 9995; // Fee is currently 5 basis points.\n\n    vm.expectRevert(RoutersFacet.RoutersFacet__setLiquidityFeeNumerator_tooLarge.selector);\n    vm.prank(_owner);\n    // Set fee to -100 basis points, literally making the routers give users free money.\n    this.setLiquidityFeeNumerator(10100);\n    assertEq(s.LIQUIDITY_FEE_NUMERATOR, 9995);\n  }\n\n  // ============ Public methods ==============\n  // setRouterRecipient\n  function test_RoutersFacet__setRouterRecipient_success() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterRecipientSet(_routerAgent0, _routerRecipient0, _routerRecipient1);\n\n    // Call must come from router owner.\n    vm.prank(_routerOwner0);\n    this.setRouterRecipient(_routerAgent0, _routerRecipient1);\n\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], _routerRecipient1);\n\n    // Shouldn't change any of these values:\n    assertEq(s.routerPermissionInfo.approvedRouters[_routerAgent0], true);\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], _routerOwner0);\n    assertEq(s.routerPermissionInfo.proposedRouterOwners[_routerAgent0], address(0));\n    assertEq(s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0], 0);\n  }\n\n  // Should work if owner == address(0) && msg.sender == router\n  function test_RoutersFacet__setRouterRecipient_successIfOwnerEmpty() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = address(0);\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.prank(_routerAgent0);\n    this.setRouterRecipient(_routerAgent0, _routerRecipient1);\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], _routerRecipient1);\n  }\n\n  // Should work if msg.sender == owner\n  function test_RoutersFacet__setRouterRecipient_successIfOwnerSet() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.prank(_routerOwner0);\n    this.setRouterRecipient(_routerAgent0, _routerRecipient1);\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], _routerRecipient1);\n  }\n\n  // Fail if setting a duplicate recipient\n  function test_RoutersFacet__setRouterRecipient_failsIfRedundantRecipient() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.expectRevert(RoutersFacet.RoutersFacet__setRouterRecipient_notNewRecipient.selector);\n    vm.prank(_routerOwner0);\n    this.setRouterRecipient(_routerAgent0, _routerRecipient0);\n\n    assertEq(s.routerPermissionInfo.routerRecipients[_routerAgent0], _routerRecipient0);\n  }\n\n  // Fail if owner == address(0) && msg.sender != router\n  function test_RoutersFacet__setRouterRecipient_failsIfEmptyOwnerSenderNotRouter() public {\n    vm.prank(address(2));\n    vm.expectRevert(abi.encodeWithSelector(RoutersFacet.RoutersFacet__onlyRouterOwner_notRouterOwner.selector));\n    this.setRouterRecipient(_routerAgent0, address(0));\n  }\n\n  // Fail if owner != address(0) && msg.sender != owner\n  function test_RoutersFacet__setRouterRecipient_failsIfNotOwner() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.prank(_routerOwner1);\n    vm.expectRevert(abi.encodeWithSelector(RoutersFacet.RoutersFacet__onlyRouterOwner_notRouterOwner.selector));\n    this.setRouterRecipient(_routerAgent0, address(0));\n  }\n\n  // proposeRouterOwner\n\n  // Fails if owner != address(0), msg.sender != owner\n  function test_RoutersFacet__proposeRouterOwner_failIfNotOwnerWithOwnerSet() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.expectRevert(RoutersFacet.RoutersFacet__onlyRouterOwner_notRouterOwner.selector);\n    vm.prank(address(123456654321));\n    this.proposeRouterOwner(_routerAgent0, _routerOwner1);\n  }\n\n  // Fails if owner == address(0), msg.sender != router\n  function test_RoutersFacet__proposeRouterOwner_failIfNotOwnerWithoutSet() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = address(0);\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.expectRevert(RoutersFacet.RoutersFacet__onlyRouterOwner_notRouterOwner.selector);\n    vm.prank(address(123456654321));\n    this.proposeRouterOwner(_routerAgent0, _routerOwner1);\n  }\n\n  // Fail if propose current owner\n  function test_RoutersFacet__proposeRouterOwner_failsIfAlreadyOwner() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.prank(_routerOwner0);\n    vm.expectRevert(abi.encodeWithSelector(RoutersFacet.RoutersFacet__proposeRouterOwner_notNewOwner.selector));\n    this.proposeRouterOwner(_routerAgent0, _routerOwner0);\n  }\n\n  // Fail if proposed owner is same as the previous proposed\n  function test_RoutersFacet__proposeRouterOwner_failsIfAlreadyProposed() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = _routerOwner1;\n\n    vm.prank(_routerOwner0);\n    vm.expectRevert(abi.encodeWithSelector(RoutersFacet.RoutersFacet__proposeRouterOwner_badRouter.selector));\n    this.proposeRouterOwner(_routerAgent0, _routerOwner1);\n  }\n\n  // Should work\n  function test_RoutersFacet__proposeRouterOwner_success() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.prank(_routerOwner0);\n    this.proposeRouterOwner(_routerAgent0, _routerOwner1);\n    assertEq(this.getProposedRouterOwner(_routerAgent0), _routerOwner1);\n  }\n\n  // acceptProposedRouterOwner\n  // Should work if proposed == address(0)  && (_owner == address(0) && msg.sender == router) || _owner != msg.sender\n  function test_RoutersFacet__acceptProposedRouterOwner_successWhenProposedAndOwnerNotSet() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = address(0);\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = address(0);\n\n    vm.expectEmit(true, true, false, true);\n    emit RouterOwnerAccepted(_routerAgent0, _routerAgent0, address(0));\n\n    // If the proposed owner is not set and no current owner is set, the router itself must be the caller.\n    vm.prank(_routerAgent0);\n    this.acceptProposedRouterOwner(_routerAgent0);\n    // No change...\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], address(0));\n  }\n\n  // Should work if proposed == address(0)  &&  msg.sender == owner\n  function test_RoutersFacet__acceptProposedRouterOwner_successWhenProposedNotSet() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = address(0);\n\n    vm.prank(_routerOwner0);\n    this.acceptProposedRouterOwner(_routerAgent0);\n    // The owner should be address(0) now.\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], address(0));\n  }\n\n  // Should work if proposed != address(0)  &&  msg.sender == _proposed\n  function test_RoutersFacet__acceptProposedRouterOwner_successWhenProposedIsSet() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = _routerOwner1;\n    s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0] = block.timestamp;\n\n    vm.prank(_routerOwner1);\n    vm.warp(block.timestamp + 8 days);\n\n    this.acceptProposedRouterOwner(_routerAgent0);\n    assertEq(s.routerPermissionInfo.routerOwners[_routerAgent0], _routerOwner1);\n    // Should have cleared the proposed owner.\n    assertEq(s.routerPermissionInfo.proposedRouterOwners[_routerAgent0], address(0));\n    // Should have cleared the proposed owner timestamp.\n    assertEq(s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0], 0);\n  }\n\n  // Fail if proposed == address(0) && (_owner != address(0) && msg.sender != router) || _owner != msg.sender\n  function test_RoutersFacet__acceptProposedRouterOwner_failsIfNotOwnerWhenOwnerEmpty() public {\n    address _router = address(1);\n\n    vm.expectRevert(abi.encodeWithSelector(RoutersFacet.RoutersFacet__onlyProposedRouterOwner_notRouterOwner.selector));\n    vm.prank(address(2));\n    this.acceptProposedRouterOwner(_router);\n  }\n\n  // Fail if proposed == address(0) && (_owner != address(0) && msg.sender != router) || _owner != msg.sender\n  function test_RoutersFacet__acceptProposedRouterOwner_failsIfNotOwnerWhenOwnerSet() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n\n    vm.prank(address(2));\n    vm.expectRevert(abi.encodeWithSelector(RoutersFacet.RoutersFacet__onlyProposedRouterOwner_notRouterOwner.selector));\n    this.acceptProposedRouterOwner(_routerAgent0);\n  }\n\n  // Fail if proposed != address(0) && msg.sender != _proposed\n  function test_RoutersFacet__acceptProposedRouterOwner_failsIfNotProposedWhenProposedSet() public {\n    s.routerPermissionInfo.approvedRouters[_routerAgent0] = true;\n    s.routerPermissionInfo.routerOwners[_routerAgent0] = _routerOwner0;\n    s.routerPermissionInfo.routerRecipients[_routerAgent0] = _routerRecipient0;\n    s.routerPermissionInfo.proposedRouterOwners[_routerAgent0] = _routerOwner1;\n    s.routerPermissionInfo.proposedRouterTimestamp[_routerAgent0] = block.timestamp;\n\n    vm.prank(_routerOwner2);\n    vm.expectRevert(\n      abi.encodeWithSelector(RoutersFacet.RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner.selector)\n    );\n    this.acceptProposedRouterOwner(_routerAgent0);\n  }\n\n  // function test_RoutersFacet__addRouterLiquidityFor\n  // function test_RoutersFacet__addRouterLiquidity\n  // function test_RoutersFacet__removeRouterLiquidity\n\n  // ============ Internal functions ============\n\n  // function test_RoutersFacet___addLiquidityForRouter\n}\n\n\n",
        "CodeNames": [
            "RoutersFacet.sol",
            "RoutersFacet.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RoutersFacet.removeRouter and RoutersFacet.removeRouterLiquidityFor functions",
                "Type": "Router owner could be rugged by admin",
                "Description": "Router owner who provides liquidity could be rugged by Connext admin. When this happens, the router owner funds will be struck within the RoutersFacet contract, and there is no way for the router owner to retrieve their liquidity.",
                "Repair": "Update contract implementation to allow router owners to withdraw their liquidity even after their router has been removed by Connext Admin"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.14;\n\nimport {Home} from \"../../nomad-core/contracts/Home.sol\";\nimport {TypedMemView} from \"../../nomad-core/libs/TypedMemView.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IConnextHandler} from \"../connext/interfaces/IConnextHandler.sol\";\nimport {IBridgeToken} from \"../connext/interfaces/IBridgeToken.sol\";\n\nimport {Router} from \"../shared/Router.sol\";\nimport {XAppConnectionClient} from \"../shared/XAppConnectionClient.sol\";\nimport {Version} from \"../shared/Version.sol\";\n\nimport {ICallback} from \"./interfaces/ICallback.sol\";\nimport {PromiseMessage} from \"./libraries/PromiseMessage.sol\";\n\n/**\n * @title PromiseRouter\n */\ncontract PromiseRouter is Version, Router, ReentrancyGuardUpgradeable {\n  // ============ Libraries ============\n\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using PromiseMessage for bytes29;\n\n  // ========== Custom Errors ===========\n\n  error PromiseRouter__onlyConnext_notConnext();\n  error PromiseRouter__send_returndataEmpty();\n  error PromiseRouter__send_callbackEmpty();\n  error PromiseRouter__process_invalidTransferId();\n  error PromiseRouter__process_invalidMessage();\n  error PromiseRouter__process_notApprovedRelayer();\n  error PromiseRouter__process_insufficientCallbackFee();\n  error PromiseRouter__process_notContractCallback();\n  error PromiseRouter__bumpCallbackFee_valueIsZero();\n  error PromiseRouter__bumpCallbackFee_messageUnavailable();\n  error PromiseRouter__initCallbackFee_valueIsZero();\n\n  // ============ Public Storage ============\n\n  IConnextHandler public connext;\n\n  /**\n   * @notice Mapping of transferId to promise callback messages\n   * @dev While handling the message, it will parse transferId from incomming message and store the message in the mapping\n   */\n  mapping(bytes32 => bytes32) public messageHashes;\n\n  /**\n   * @notice Mapping of transferId to callback fee\n   * @dev This will track all the callback fees for each transferId.\n   * Can add while xcall or bumping callback fee\n   */\n  mapping(bytes32 => uint256) public callbackFees;\n\n  // ============ Upgrade Gap ============\n\n  // gap for upgrade safety\n  uint256[49] private __GAP;\n\n  // ======== Events =========\n\n  /**\n   * @notice Emitted when a promise callback has been sent from this domain\n   * @param domain The domain where to execute the callback\n   * @param remote Remote PromiseRouter address\n   * @param transferId The transferId\n   * @param callbackAddress The address of the callback\n   * @param success The return success from the execution on the destination domain\n   * @param data The returnData from the execution on the destination domain\n   * @param message The message sent to the destination domain\n   */\n  event Send(\n    uint32 domain,\n    bytes32 remote,\n    bytes32 transferId,\n    address callbackAddress,\n    bool success,\n    bytes data,\n    bytes message\n  );\n\n  /**\n   * @notice Emitted when a promise callback message has arrived to this domain\n   * @param originAndNonce Domain where the transfer originated and the unique identifier\n   * for the message from origin to destination, combined in a single field ((origin << 32) & nonce)\n   * @param origin Domain where the transfer originated\n   * @param transferId The transferId\n   * @param callbackAddress The address of the callback\n   * @param success The return success from the execution on the destination domain\n   * @param data The returnData from the execution on the destination domain\n   * @param message The message sent to the destination domain\n   */\n  event Receive(\n    uint64 indexed originAndNonce,\n    uint32 indexed origin,\n    bytes32 transferId,\n    address callbackAddress,\n    bool success,\n    bytes data,\n    bytes message\n  );\n\n  /**\n   * @notice Emitted when transaction fee for callback added\n   * @param transferId The transferId\n   * @param addedFee The fee amount that added newly\n   * @param totalFee The total fee amount, can be bumped by multiple times\n   * @param caller The transaction caller\n   */\n  event CallbackFeeAdded(bytes32 indexed transferId, uint256 addedFee, uint256 totalFee, address caller);\n\n  /**\n   * @notice Emitted when callback function executed\n   * @param transferId The transferId\n   * @param relayer The address of the relayer which executed the callback\n   */\n  event CallbackExecuted(bytes32 indexed transferId, address relayer);\n\n  /**\n   * @notice Emitted when a new Connext address is set\n   * @param connext The new connext address\n   */\n  event SetConnext(address indexed connext);\n\n  // ======== Receive =======\n  receive() external payable {}\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Restricts the caller to the local bridge router\n   */\n  modifier onlyConnext() {\n    if (msg.sender != address(connext)) revert PromiseRouter__onlyConnext_notConnext();\n    _;\n  }\n\n  // ======== Initializer ========\n\n  function initialize(address _xAppConnectionManager) public initializer {\n    __XAppConnectionClient_initialize(_xAppConnectionManager);\n  }\n\n  /**\n   * @notice Sets the Connext.\n   * @dev Connext and relayer fee router store references to each other\n   * @param _connext The address of the Connext implementation\n   */\n  function setConnext(address _connext) external onlyOwner {\n    connext = IConnextHandler(_connext);\n    emit SetConnext(_connext);\n  }\n\n  // ======== External: Send PromiseCallback =========\n\n  /**\n   * @notice Sends a request to execute callback in the originated domain\n   * @param _domain The domain where to execute callback\n   * @param _transferId The transferId\n   * @param _callbackAddress A callback address to be called when promise callback is received\n   * @param _returnSuccess The returnSuccess from the execution\n   * @param _returnData The returnData from the execution\n   */\n  function send(\n    uint32 _domain,\n    bytes32 _transferId,\n    address _callbackAddress,\n    bool _returnSuccess,\n    bytes calldata _returnData\n  ) external onlyConnext {\n    if (_returnData.length == 0) revert PromiseRouter__send_returndataEmpty();\n    if (_callbackAddress == address(0)) revert PromiseRouter__send_callbackEmpty();\n\n    // get remote PromiseRouter address; revert if not found\n    bytes32 remote = _mustHaveRemote(_domain);\n\n    bytes memory message = PromiseMessage.formatPromiseCallback(\n      _transferId,\n      _callbackAddress,\n      _returnSuccess,\n      _returnData\n    );\n\n    xAppConnectionManager.home().dispatch(_domain, remote, message);\n\n    // emit Send event\n    emit Send(_domain, remote, _transferId, _callbackAddress, _returnSuccess, _returnData, message);\n  }\n\n  // ======== External: Handle =========\n\n  /**\n   * @notice Handles an incoming message\n   * @param _origin The origin domain\n   * @param _nonce The unique identifier for the message from origin to destination\n   * @param _sender The sender address\n   * @param _message The message\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external override onlyReplica onlyRemoteRouter(_origin, _sender) {\n    // parse transferId, callbackAddress, callData from message\n    bytes29 _msg = _message.ref(0).mustBePromiseCallback();\n\n    bytes32 transferId = _msg.transferId();\n    address callbackAddress = _msg.callbackAddress();\n    bool success = _msg.returnSuccess();\n    bytes memory data = _msg.returnData();\n\n    // store Promise message\n    messageHashes[transferId] = _msg.keccak();\n\n    // emit Receive event\n    emit Receive(_originAndNonce(_origin, _nonce), _origin, transferId, callbackAddress, success, data, _message);\n  }\n\n  /**\n   * @notice Process stored callback function\n   * @param transferId The transferId to process\n   */\n  function process(bytes32 transferId, bytes calldata _message) public nonReentrant {\n    // parse out the return data and callback address from message\n    bytes32 messageHash = messageHashes[transferId];\n    if (messageHash == bytes32(0)) revert PromiseRouter__process_invalidTransferId();\n\n    bytes29 _msg = _message.ref(0).mustBePromiseCallback();\n    if (messageHash != _msg.keccak()) revert PromiseRouter__process_invalidMessage();\n\n    // enforce relayer is whitelisted by calling local connext contract\n    if (!connext.approvedRelayers(msg.sender)) revert PromiseRouter__process_notApprovedRelayer();\n\n    address callbackAddress = _msg.callbackAddress();\n\n    if (!AddressUpgradeable.isContract(callbackAddress)) revert PromiseRouter__process_notContractCallback();\n\n    uint256 callbackFee = callbackFees[transferId];\n\n    // remove message\n    delete messageHashes[transferId];\n\n    // remove callback fees\n    callbackFees[transferId] = 0;\n\n    // execute callback\n    ICallback(callbackAddress).callback(transferId, _msg.returnSuccess(), _msg.returnData());\n\n    emit CallbackExecuted(transferId, msg.sender);\n\n    // Should transfer the stored relayer fee to the msg.sender\n    if (callbackFee > 0) {\n      AddressUpgradeable.sendValue(payable(msg.sender), callbackFee);\n    }\n  }\n\n  /**\n   * @notice This function will be called on the origin domain to init the callback fee while xcall\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function initCallbackFee(bytes32 _transferId) external payable onlyConnext {\n    if (msg.value == 0) revert PromiseRouter__initCallbackFee_valueIsZero();\n\n    callbackFees[_transferId] += msg.value;\n\n    emit CallbackFeeAdded(_transferId, msg.value, callbackFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice This function will be called on the origin domain to increase the callback fee\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpCallbackFee(bytes32 _transferId) external payable {\n    if (msg.value == 0) revert PromiseRouter__bumpCallbackFee_valueIsZero();\n\n    // use the presence of the message to evaluate if the fee should be bumped.\n    // this is to check that the user is not bumping a transferId that does not exist, or they\n    // are not bumping the fees of a transfer that has already been processed.\n    // the other options are to (a) track process status in a separate mapping (3 mappings updated)\n    // on process) or (b) use the callbackFees mapping and require the callback fees are nonzero\n    // on xcall (preventing 0-fee callbacks)\n    if (messageHashes[_transferId] == bytes32(0)) revert PromiseRouter__bumpCallbackFee_messageUnavailable();\n\n    callbackFees[_transferId] += msg.value;\n\n    emit CallbackFeeAdded(_transferId, msg.value, callbackFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @dev explicit override for compiler inheritance\n   * @return domain of chain on which the contract is deployed\n   */\n  function _localDomain() internal view override(XAppConnectionClient) returns (uint32) {\n    return XAppConnectionClient._localDomain();\n  }\n\n  /**\n   * @notice Internal utility function that combines\n   * `_origin` and `_nonce`.\n   * @dev Both origin and nonce should be less than 2^32 - 1\n   * @param _origin Domain of chain where the transfer originated\n   * @param _nonce The unique identifier for the message from origin to destination\n   * @return Returns (`_origin` << 32) & `_nonce`\n   */\n  function _originAndNonce(uint32 _origin, uint32 _nonce) internal pure returns (uint64) {\n    return (uint64(_origin) << 32) | _nonce;\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {XAppConnectionManager} from \"../../../contracts/nomad-core/contracts/XAppConnectionManager.sol\";\nimport {Home} from \"../../../contracts/nomad-core/contracts/Home.sol\";\n\nimport \"../../utils/ForgeHelper.sol\";\n\nimport {TypedMemView, PromiseMessage, PromiseRouter, AddressUpgradeable} from \"../../../contracts/core/promise/PromiseRouter.sol\";\nimport {ProposedOwnable} from \"../../../contracts/core/shared/ProposedOwnable.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {Deployer} from \"../../utils/Deployer.sol\";\nimport {IConnextHandler} from \"../../../contracts/core/connext/interfaces/IConnextHandler.sol\";\nimport {ICallback} from \"../../../contracts/core/promise/interfaces/ICallback.sol\";\nimport {BaseConnextFacet} from \"../../../contracts/core/connext/facets/BaseConnextFacet.sol\";\n\nimport {MockHome, MockCallback, MockPromiseRouter, TestSetterFacet, MockXAppConnectionManager} from \"../../utils/Mock.sol\";\n\ncontract PromiseRouterTest is ForgeHelper, PromiseRouter {\n  // ============ Libraries ============\n\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using PromiseMessage for bytes29;\n\n  // ============ Storage ============\n\n  address _xAppConnectionManager = address(1);\n  address _connext = address(2);\n  address _xAppHome = address(3);\n  address _callback;\n\n  uint32 _domain = 1000;\n  bytes32 _remote = bytes32(abi.encode(address(4)));\n\n  bytes32 _transferId = bytes32(\"id\");\n\n  PromiseRouter public promiseRouter;\n\n  // ============ Test set up ============\n\n  function setUp() public {\n    PromiseRouter promiseRouterImpl = new PromiseRouter();\n\n    // Deploy a mock home.\n    _xAppHome = address(new MockHome());\n    // Deploy a mock xapp connection manager.\n    _xAppConnectionManager = address(new MockXAppConnectionManager(MockHome(_xAppHome)));\n\n    ERC1967Proxy proxy = new ERC1967Proxy(\n      address(promiseRouterImpl),\n      abi.encodeWithSelector(PromiseRouter.initialize.selector, _xAppConnectionManager)\n    );\n\n    promiseRouter = PromiseRouter(payable(address(proxy)));\n    promiseRouter.setConnext(_connext);\n\n    // enroll router\n    vm.prank(promiseRouter.owner());\n    promiseRouter.enrollRemoteRouter(_domain, _remote);\n\n    // deploy callback\n    _callback = address(new MockCallback());\n  }\n\n  // ============ Utils ============\n  function utils_formatPromiseCallback(bool _returnSuccess, bytes memory _returnData) internal returns (bytes memory) {\n    return\n      abi.encodePacked(\n        uint8(PromiseMessage.Types.PromiseCallback),\n        _transferId,\n        _callback,\n        uint8(_returnSuccess ? 1 : 0),\n        _returnData.length,\n        _returnData\n      );\n  }\n\n  // ============ initialize ============\n  function test_PromiseRouter__initializeParameters_shouldWork() public {\n    assertEq(address(promiseRouter.xAppConnectionManager()), _xAppConnectionManager);\n  }\n\n  // ============ setConnext ============\n  // fixme: move to ProposedOwnable.t.sol\n  function test_PromiseRouter__setConnext_failsIfNotOwner() public {\n    address updated = address(1234);\n\n    vm.expectRevert(ProposedOwnable.ProposedOwnable__onlyOwner_notOwner.selector);\n    vm.prank(updated);\n    promiseRouter.setConnext(updated);\n  }\n\n  // Should work\n  function test_PromiseRouter__setConnext_shouldWork() public {\n    address updated = address(1234);\n    vm.expectEmit(true, true, true, true);\n    emit SetConnext(updated);\n\n    vm.prank(promiseRouter.owner());\n    promiseRouter.setConnext(updated);\n    assertEq(address(promiseRouter.connext()), updated);\n  }\n\n  // ============ send ============\n  // Fail if not called by connext\n  function test_PromiseRouter__send_failsIfNotConnext(bool returnSuccess, bytes calldata returnData) public {\n    vm.assume(returnData.length > 0);\n    vm.prank(address(0));\n    vm.expectRevert(abi.encodeWithSelector(PromiseRouter.PromiseRouter__onlyConnext_notConnext.selector));\n\n    promiseRouter.send(_domain, _transferId, _callback, returnSuccess, returnData);\n  }\n\n  // Fail if return data is empty\n  function test_PromiseRouter__send_failsIfEmptyReturnData(bool returnSuccess, bytes calldata returnData) public {\n    vm.assume(returnData.length == 0);\n    vm.prank(_connext);\n    vm.expectRevert(abi.encodeWithSelector(PromiseRouter.PromiseRouter__send_returndataEmpty.selector));\n\n    promiseRouter.send(_domain, _transferId, _callback, returnSuccess, returnData);\n  }\n\n  // Fail if callback address is not contract\n  function test_PromiseRouter__send_failsIfEmptyCallback(bool returnSuccess, bytes calldata returnData) public {\n    vm.assume(returnData.length > 0);\n    vm.prank(_connext);\n    vm.expectRevert(abi.encodeWithSelector(PromiseRouter.PromiseRouter__send_callbackEmpty.selector));\n\n    promiseRouter.send(_domain, _transferId, address(0), returnSuccess, returnData);\n  }\n\n  // fails if no remote\n  function test_PromiseRouter__send_failsIfNoRemote(bool returnSuccess, bytes calldata returnData) public {\n    vm.assume(returnData.length > 0);\n\n    // enroll router\n    vm.prank(promiseRouter.owner());\n    promiseRouter.enrollRemoteRouter(_domain, bytes32(0));\n\n    vm.prank(_connext);\n    vm.expectRevert(bytes(\"!remote\"));\n\n    promiseRouter.send(_domain, _transferId, _callback, returnSuccess, returnData);\n  }\n\n  // Should work\n  function test_PromiseRouter__send_shouldWork(bool returnSuccess, bytes calldata returnData) public {\n    vm.prank(_connext);\n    vm.assume(returnData.length > 0);\n\n    bytes memory message = PromiseMessage.formatPromiseCallback(_transferId, _callback, returnSuccess, returnData);\n\n    vm.expectCall(_xAppHome, abi.encodeWithSelector(MockHome.dispatch.selector, _domain, _remote, message));\n    vm.expectEmit(true, true, true, true);\n    emit Send(_domain, _remote, _transferId, _callback, returnSuccess, returnData, message);\n\n    promiseRouter.send(_domain, _transferId, _callback, returnSuccess, returnData);\n  }\n\n  // ============ handle ============\n  // NOTE: modifiers are in the nomad contracts, tested separately\n\n  // should fail if the message is not a promise callback\n  function test_PromiseRouter__handle_failsIfMalformedMessage(bytes calldata returnData, uint32 nonce) public {\n    vm.assume(returnData.length > 0);\n\n    uint64 originAndNonce = _originAndNonce(_domain, nonce);\n\n    // register as replica\n    vm.mockCall(\n      _xAppConnectionManager,\n      abi.encodeWithSelector(XAppConnectionManager.isReplica.selector, address(this)),\n      abi.encode(true)\n    );\n\n    bytes memory _message = bytes(\"msg\");\n    vm.expectRevert(bytes(\"Validity assertion failed\"));\n    promiseRouter.handle(_domain, nonce, _remote, _message);\n  }\n\n  // Should work\n  // bytes calldata returnData, uint32 _nonce\n  function test_PromiseRouter__handle_shouldWork(\n    bytes calldata returnData,\n    uint32 nonce,\n    bool success\n  ) public {\n    vm.assume(returnData.length > 0);\n\n    uint64 originAndNonce = _originAndNonce(_domain, nonce);\n\n    bytes memory message = utils_formatPromiseCallback(success, returnData);\n    bytes29 _msg = message.ref(0).mustBePromiseCallback();\n\n    // register as replica\n    vm.mockCall(\n      _xAppConnectionManager,\n      abi.encodeWithSelector(XAppConnectionManager.isReplica.selector, address(this)),\n      abi.encode(true)\n    );\n\n    vm.expectEmit(true, true, true, true);\n    emit Receive(originAndNonce, _domain, _transferId, _callback, success, returnData, message);\n\n    promiseRouter.handle(_domain, nonce, _remote, message);\n    assertEq(promiseRouter.messageHashes(_transferId), _msg.keccak());\n  }\n\n  // ============ process ============\n  // fails if no message present for transfer\n  function test_PromiseRouter__process_failsIfNoMessage(bytes calldata returnData, uint32 nonce) public {\n    vm.assume(returnData.length != 0);\n    bool success = true;\n    bytes memory message = utils_formatPromiseCallback(success, returnData);\n    // mock relayer approval\n    vm.mockCall(_connext, abi.encodeWithSelector(IConnextHandler.approvedRelayers.selector), abi.encode(true));\n\n    vm.expectRevert(PromiseRouter.PromiseRouter__process_invalidTransferId.selector);\n    promiseRouter.process(_transferId, message);\n  }\n\n  // fails if invalid message provided\n  function test_PromiseRouter__process_failsIfInvalidMessage(bytes calldata returnData, uint32 nonce) public {\n    vm.assume(returnData.length != 0);\n    bool success = true;\n    bytes memory message = utils_formatPromiseCallback(success, returnData);\n    bytes29 _msg = message.ref(0).mustBePromiseCallback();\n\n    // mock is replica result for handle\n    vm.mockCall(\n      _xAppConnectionManager,\n      abi.encodeWithSelector(XAppConnectionManager.isReplica.selector),\n      abi.encode(true)\n    );\n\n    promiseRouter.handle(_domain, nonce, _remote, message);\n    assertEq(promiseRouter.messageHashes(_transferId), _msg.keccak());\n\n    // mock relayer approval\n    vm.mockCall(_connext, abi.encodeWithSelector(IConnextHandler.approvedRelayers.selector), abi.encode(true));\n\n    vm.expectRevert(bytes(\"Validity assertion failed\"));\n    promiseRouter.process(_transferId, bytes(\"\"));\n  }\n\n  // Fail if relayer is not approved on connext contract\n  function test_PromiseRouter__process_failsIfNotApprovedRelayer(bytes calldata returnData, uint32 nonce) public {\n    vm.assume(returnData.length != 0);\n    bool success = true;\n    bytes memory message = utils_formatPromiseCallback(success, returnData);\n    bytes29 _msg = message.ref(0).mustBePromiseCallback();\n\n    // mock is replica result for handle\n    vm.mockCall(\n      _xAppConnectionManager,\n      abi.encodeWithSelector(XAppConnectionManager.isReplica.selector),\n      abi.encode(true)\n    );\n\n    promiseRouter.handle(_domain, nonce, _remote, message);\n    assertEq(promiseRouter.messageHashes(_transferId), _msg.keccak());\n\n    // mock relayer approval\n    vm.mockCall(_connext, abi.encodeWithSelector(IConnextHandler.approvedRelayers.selector), abi.encode(false));\n\n    vm.expectRevert(PromiseRouter.PromiseRouter__process_notApprovedRelayer.selector);\n    vm.prank(address(123123123));\n    promiseRouter.process(_transferId, message);\n  }\n\n  // fails if callback is not a contract\n  function test_PromiseRouter__process_failsIfNotContract(bytes calldata returnData, uint32 nonce) public {\n    vm.assume(returnData.length != 0);\n    _callback = address(12344321);\n    bool success = true;\n    bytes memory message = utils_formatPromiseCallback(success, returnData);\n    bytes29 _msg = message.ref(0).mustBePromiseCallback();\n\n    // mock is replica result for handle\n    vm.mockCall(\n      _xAppConnectionManager,\n      abi.encodeWithSelector(XAppConnectionManager.isReplica.selector),\n      abi.encode(true)\n    );\n\n    promiseRouter.handle(_domain, nonce, _remote, message);\n    assertEq(promiseRouter.messageHashes(_transferId), _msg.keccak());\n\n    // mock relayer approval\n    vm.mockCall(_connext, abi.encodeWithSelector(IConnextHandler.approvedRelayers.selector), abi.encode(true));\n\n    vm.expectRevert(PromiseRouter.PromiseRouter__process_notContractCallback.selector);\n    promiseRouter.process(_transferId, message);\n  }\n\n  // Should work if callback fee is zero\n  function test_PromiseRouter__process_shouldWorkIfZeroCallbackFee(bytes calldata returnData, uint32 nonce) public {\n    vm.assume(returnData.length != 0);\n    bool success = true;\n    bytes memory message = utils_formatPromiseCallback(success, returnData);\n    bytes29 _msg = message.ref(0).mustBePromiseCallback();\n\n    uint256 callbackFee = 0;\n\n    uint256 relayerBeforeBalance = address(this).balance;\n    uint256 beforeBalance = address(promiseRouter).balance;\n\n    // mock is replica result for handle\n    vm.mockCall(\n      _xAppConnectionManager,\n      abi.encodeWithSelector(XAppConnectionManager.isReplica.selector),\n      abi.encode(true)\n    );\n\n    promiseRouter.handle(_domain, nonce, _remote, message);\n    assertEq(promiseRouter.messageHashes(_transferId), _msg.keccak());\n\n    // mock relayer approval\n    vm.mockCall(_connext, abi.encodeWithSelector(IConnextHandler.approvedRelayers.selector), abi.encode(true));\n\n    // check if callback executed\n    vm.expectCall(_callback, abi.encodeWithSelector(ICallback.callback.selector, _transferId, success, returnData));\n\n    vm.expectEmit(true, true, true, true);\n    emit CallbackExecuted(_transferId, address(this));\n\n    promiseRouter.process(_transferId, message);\n\n    // check if promiseMessage cleared after callback\n    assertEq(promiseRouter.messageHashes(_transferId), bytes32(0));\n\n    // check if callbackFee cleared after callback\n    assertTrue(promiseRouter.callbackFees(_transferId) == 0);\n\n    // check if callback fee is transferred to relayer\n    assertEq(address(this).balance, relayerBeforeBalance + callbackFee);\n    assertEq(address(promiseRouter).balance, beforeBalance - callbackFee);\n  }\n\n  // Should work if callback fee is nonzero\n  function test_PromiseRouter__process_shouldWork(bytes calldata returnData, uint32 nonce) public {\n    vm.assume(returnData.length != 0);\n    bool success = true;\n    bytes memory message = utils_formatPromiseCallback(success, returnData);\n    bytes29 _msg = message.ref(0).mustBePromiseCallback();\n\n    uint256 callbackFee = 0.01 ether;\n    vm.deal(address(promiseRouter), 10 ether);\n\n    address relayer = address(123456654321);\n    uint256 relayerBeforeBalance = relayer.balance;\n\n    // mock is replica result for handle\n    vm.mockCall(\n      _xAppConnectionManager,\n      abi.encodeWithSelector(XAppConnectionManager.isReplica.selector),\n      abi.encode(true)\n    );\n\n    promiseRouter.handle(_domain, nonce, _remote, message);\n    assertEq(promiseRouter.messageHashes(_transferId), _msg.keccak());\n\n    // bump fee\n    promiseRouter.bumpCallbackFee{value: callbackFee}(_transferId);\n    uint256 beforeBalance = address(promiseRouter).balance;\n\n    // mock relayer approval\n    vm.mockCall(_connext, abi.encodeWithSelector(IConnextHandler.approvedRelayers.selector), abi.encode(true));\n\n    // check if callback executed\n    vm.expectCall(_callback, abi.encodeWithSelector(ICallback.callback.selector, _transferId, success, returnData));\n\n    vm.expectEmit(true, true, true, true);\n    emit CallbackExecuted(_transferId, relayer);\n\n    vm.prank(relayer);\n    promiseRouter.process(_transferId, message);\n\n    // check if promiseMessage cleared after callback\n    assertEq(promiseRouter.messageHashes(_transferId), bytes32(0));\n\n    // check if callbackFee cleared after callback\n    assertTrue(promiseRouter.callbackFees(_transferId) == 0);\n\n    // check if callback fee is transferred to relayer\n    assertEq(relayer.balance, relayerBeforeBalance + callbackFee);\n    assertEq(address(promiseRouter).balance, beforeBalance - callbackFee);\n  }\n\n  // ============ initCallbackFee ============\n  // Fail if not called by connext\n  function test_PromiseRouter__initCallbackFee_failsIfNotConnext() public {\n    vm.expectRevert(PromiseRouter.PromiseRouter__onlyConnext_notConnext.selector);\n    vm.prank(address(123321456654));\n    promiseRouter.initCallbackFee(_transferId);\n  }\n\n  // Fail if value is zero\n  function test_PromiseRouter__initCallbackFee_failsIfZeroValue() public {\n    vm.expectRevert(PromiseRouter.PromiseRouter__initCallbackFee_valueIsZero.selector);\n    vm.prank(_connext);\n    promiseRouter.initCallbackFee(_transferId);\n  }\n\n  // Works\n  function test_PromiseRouter__initCallbackFee_works() public {\n    uint256 fee = 0.01 ether;\n    uint256 init = address(promiseRouter).balance;\n    vm.deal(address(promiseRouter.connext()), 10 ether);\n\n    vm.expectEmit(true, true, true, true);\n    emit CallbackFeeAdded(_transferId, fee, fee, _connext);\n\n    vm.prank(address(promiseRouter.connext()));\n    promiseRouter.initCallbackFee{value: fee}(_transferId);\n    assertEq(promiseRouter.callbackFees(_transferId), fee);\n    assertEq(address(promiseRouter).balance, init + fee);\n  }\n\n  // ============ bumpCallbackFee ============\n  // Fail if value is zero\n  function test_PromiseRouter__bumpCallbackFee_failsIfZeroValue(bytes calldata returnData, uint32 nonce) public {\n    vm.expectRevert(PromiseRouter.PromiseRouter__bumpCallbackFee_valueIsZero.selector);\n    promiseRouter.bumpCallbackFee(_transferId);\n  }\n\n  // Should fail if message isnt handled\n  function test_PromiseRouter__bumpCallbackFee_shouldFailIfMessageNotHandled(bytes calldata returnData, uint32 nonce)\n    public\n  {\n    vm.expectRevert(PromiseRouter.PromiseRouter__bumpCallbackFee_messageUnavailable.selector);\n    promiseRouter.bumpCallbackFee{value: 0.01 ether}(_transferId);\n  }\n\n  // Should work\n  function test_PromiseRouter__bumpCallbackFee_shouldWork(bytes calldata returnData, uint32 nonce) public {\n    vm.assume(returnData.length != 0);\n    bool success = true;\n    bytes memory message = utils_formatPromiseCallback(success, returnData);\n    bytes29 _msg = message.ref(0).mustBePromiseCallback();\n\n    uint256 callbackFee = 0;\n\n    uint256 relayerBeforeBalance = address(this).balance;\n    uint256 beforeBalance = address(promiseRouter).balance;\n\n    // mock is replica result for handle\n    vm.mockCall(\n      _xAppConnectionManager,\n      abi.encodeWithSelector(XAppConnectionManager.isReplica.selector),\n      abi.encode(true)\n    );\n\n    promiseRouter.handle(_domain, nonce, _remote, message);\n    assertEq(promiseRouter.messageHashes(_transferId), _msg.keccak());\n\n    uint256 initial = promiseRouter.callbackFees(_transferId);\n    uint256 amount = 0.5 ether;\n\n    vm.expectEmit(true, true, true, true);\n    emit CallbackFeeAdded(_transferId, amount, amount + initial, address(this));\n    promiseRouter.bumpCallbackFee{value: amount}(_transferId);\n\n    assertEq(promiseRouter.callbackFees(_transferId), initial + amount);\n  }\n}\n\n\n",
        "CodeNames": [
            "PromiseRouter.sol",
            "PromiseRouter.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PromiseRouter.process function",
                "Type": "Attacker can perform griefing for process() in PromiseRouter by reverting calls to callback() in callbackAddress",
                "Description": "Attacker can setup callbackAddress that reverts on callback() and cause process() caller griefing.",
                "Repair": "Use a try/catch statement for the ICallback(callbackAddress).callback(transferId, _msg.returnSuccess(), _msg.returnData()) call"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {AmplificationUtils, SwapUtils} from \"../libraries/AmplificationUtils.sol\";\nimport {LPToken} from \"../helpers/LPToken.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\n\ncontract StableSwapFacet is BaseConnextFacet {\n  using SwapUtils for SwapUtils.Swap;\n  using AmplificationUtils for SwapUtils.Swap;\n\n  // ========== Custom Errors ===========\n  error StableSwapFacet__deadlineCheck_deadlineNotMet();\n  error StableSwapFacet__initializeSwap_alreadyInitialized();\n  error StableSwapFacet__initializeSwap_invalidPooledTokens();\n  error StableSwapFacet__initializeSwap_decimalsMismatch();\n  error StableSwapFacet__initializeSwap_duplicateTokens();\n  error StableSwapFacet__initializeSwap_zeroTokenAddress();\n  error StableSwapFacet__initializeSwap_tokenDecimalsExceedMax();\n  error StableSwapFacet__initializeSwap_aExceedMax();\n  error StableSwapFacet__initializeSwap_feeExceedMax();\n  error StableSwapFacet__initializeSwap_adminFeeExceedMax();\n  error StableSwapFacet__initializeSwap_failedInitLpTokenClone();\n  error StableSwapFacet__getSwapToken_outOfRange();\n  error StableSwapFacet__getSwapTokenIndex_notExist();\n  error StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n\n  // ============ Properties ============\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Modifier to check deadline against current timestamp\n   * @param deadline latest timestamp to accept this transaction\n   */\n  modifier deadlineCheck(uint256 deadline) {\n    if (block.timestamp > deadline) revert StableSwapFacet__deadlineCheck_deadlineNotMet();\n    _;\n  }\n\n  // ============ View Functions ============\n  /**\n   * @notice Return Stable swap storage\n   * @param canonicalId the canonical token id\n   * @return SwapUtils.Swap\n   */\n  function getSwapStorage(bytes32 canonicalId) external view returns (SwapUtils.Swap memory) {\n    return s.swapStorages[canonicalId];\n  }\n\n  /**\n   * @notice Return LP token for canonical Id\n   * @param canonicalId the canonical token id\n   * @return LPToken\n   */\n  function getSwapLPToken(bytes32 canonicalId) external view returns (address) {\n    return address(s.swapStorages[canonicalId].lpToken);\n  }\n\n  /**\n   * @notice Return A, the amplification coefficient * n * (n - 1)\n   * @dev See the StableSwap paper for details\n   * @param canonicalId the canonical token id\n   * @return A parameter\n   */\n  function getSwapA(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getA();\n  }\n\n  /**\n   * @notice Return A in its raw precision form\n   * @dev See the StableSwap paper for details\n   * @param canonicalId the canonical token id\n   * @return A parameter in its raw precision form\n   */\n  function getSwapAPrecise(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getAPrecise();\n  }\n\n  /**\n   * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n   * @param canonicalId the canonical token id\n   * @param index the index of the token\n   * @return address of the token at given index\n   */\n  function getSwapToken(bytes32 canonicalId, uint8 index) public view returns (IERC20) {\n    if (index >= s.swapStorages[canonicalId].pooledTokens.length) revert StableSwapFacet__getSwapToken_outOfRange();\n    return s.swapStorages[canonicalId].pooledTokens[index];\n  }\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param canonicalId the canonical token id\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getSwapTokenIndex(bytes32 canonicalId, address tokenAddress) public view returns (uint8) {\n    uint8 index = s.tokenIndexes[canonicalId][tokenAddress];\n    if (address(getSwapToken(canonicalId, index)) != tokenAddress) revert StableSwapFacet__getSwapTokenIndex_notExist();\n    return index;\n  }\n\n  /**\n   * @notice Return current balance of the pooled token at given index\n   * @param canonicalId the canonical token id\n   * @param index the index of the token\n   * @return current balance of the pooled token at given index with token's native precision\n   */\n  function getSwapTokenBalance(bytes32 canonicalId, uint8 index) external view returns (uint256) {\n    if (index >= s.swapStorages[canonicalId].balances.length)\n      revert StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n    return s.swapStorages[canonicalId].balances[index];\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param canonicalId the canonical token id\n   * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n   */\n  function getSwapVirtualPrice(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getVirtualPrice();\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param canonicalId the canonical token id\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell. If the token charges\n   * a fee on transfers, use the amount that gets transferred after the fee.\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256) {\n    return s.swapStorages[canonicalId].calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param canonicalId the canonical token id\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return token amount the user will receive\n   */\n  function calculateSwapTokenAmount(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    bool deposit\n  ) external view returns (uint256) {\n    return s.swapStorages[canonicalId].calculateTokenAmount(amounts, deposit);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of LP tokens\n   * @param canonicalId the canonical token id\n   * @param amount the amount of LP tokens that would be burned on withdrawal\n   * @return array of token balances that the user will receive\n   */\n  function calculateRemoveSwapLiquidity(bytes32 canonicalId, uint256 amount) external view returns (uint256[] memory) {\n    return s.swapStorages[canonicalId].calculateRemoveLiquidity(amount);\n  }\n\n  /**\n   * @notice Calculate the amount of underlying token available to withdraw\n   * when withdrawing via only single token\n   * @param canonicalId the canonical token id\n   * @param tokenAmount the amount of LP token to burn\n   * @param tokenIndex index of which token will be withdrawn\n   * @return availableTokenAmount calculated amount of underlying token\n   * available to withdraw\n   */\n  function calculateRemoveSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount) {\n    return s.swapStorages[canonicalId].calculateWithdrawOneToken(tokenAmount, tokenIndex);\n  }\n\n  /**\n   * @notice This function reads the accumulated amount of admin fees of the token with given index\n   * @param canonicalId the canonical token id\n   * @param index Index of the pooled token\n   * @return admin's token balance in the token's precision\n   */\n  function getSwapAdminBalance(bytes32 canonicalId, uint256 index) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getAdminBalance(index);\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param tokenIndexFrom the token the user wants to swap from\n   * @param tokenIndexTo the token the user wants to swap to\n   * @param dx the amount of tokens the user wants to swap from\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @param deadline latest timestamp to accept this transaction\n   */\n  function swap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountIn the amount of tokens the user wants to swap from\n   */\n  function swapExact(\n    bytes32 canonicalId,\n    uint256 amountIn,\n    address assetIn,\n    address assetOut,\n    uint256 minAmountOut,\n    uint256 deadline\n  ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return\n      s.swapStorages[canonicalId].swap(\n        getSwapTokenIndex(canonicalId, assetIn),\n        getSwapTokenIndex(canonicalId, assetOut),\n        amountIn,\n        minAmountOut\n      );\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountOut the amount of tokens the user wants to swap to\n   */\n  function swapExactOut(\n    bytes32 canonicalId,\n    uint256 amountOut,\n    address assetIn,\n    address assetOut,\n    uint256 maxAmountIn,\n    uint256 deadline\n  ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) {\n    return\n      s.swapStorages[canonicalId].swapOut(\n        getSwapTokenIndex(canonicalId, assetIn),\n        getSwapTokenIndex(canonicalId, assetOut),\n        amountOut,\n        maxAmountIn\n      );\n  }\n\n  /**\n   * @notice Add liquidity to the pool with the given amounts of tokens\n   * @param canonicalId the canonical token id\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP token user minted and received\n   */\n  function addSwapLiquidity(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) returns (uint256) {\n    return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param canonicalId the canonical token id\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   *        acceptable for this burn. Useful as a front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amounts of tokens user received\n   */\n  function removeSwapLiquidity(\n    bytes32 canonicalId,\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256[] memory) {\n    return s.swapStorages[canonicalId].removeLiquidity(amount, minAmounts);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param canonicalId the canonical token id\n   * @param tokenAmount the amount of the token you want to receive\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of chosen token user received\n   */\n  function removeSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param canonicalId the canonical token id\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP tokens burned\n   */\n  function removeSwapLiquidityImbalance(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].removeLiquidityImbalance(amounts, maxBurnAmount);\n  }\n\n  /*** ADMIN FUNCTIONS ***/\n  /**\n   * @notice Initializes this Swap contract with the given parameters.\n   * This will also clone a LPToken contract that represents users'\n   * LP positions. The owner of LPToken will be this contract - which means\n   * only this contract is allowed to mint/burn tokens.\n   *\n   * @param _canonicalId the canonical token id\n   * @param _pooledTokens an array of ERC20s this pool will accept\n   * @param decimals the decimals to use for each pooled token,\n   * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n   * @param lpTokenName the long-form name of the token to be deployed\n   * @param lpTokenSymbol the short symbol for the token to be deployed\n   * @param _a the amplification coefficient * n * (n - 1). See the\n   * StableSwap paper for details\n   * @param _fee default swap fee to be initialized with\n   * @param _adminFee default adminFee to be initialized with\n   * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n   */\n  function initializeSwap(\n    bytes32 _canonicalId,\n    IERC20[] memory _pooledTokens,\n    uint8[] memory decimals,\n    string memory lpTokenName,\n    string memory lpTokenSymbol,\n    uint256 _a,\n    uint256 _fee,\n    uint256 _adminFee,\n    address lpTokenTargetAddress\n  ) external onlyOwner {\n    if (s.swapStorages[_canonicalId].pooledTokens.length != 0)\n      revert StableSwapFacet__initializeSwap_alreadyInitialized();\n\n    // Check _pooledTokens and precisions parameter\n    if (_pooledTokens.length <= 1 || _pooledTokens.length > 32)\n      revert StableSwapFacet__initializeSwap_invalidPooledTokens();\n\n    if (_pooledTokens.length != decimals.length) revert StableSwapFacet__initializeSwap_decimalsMismatch();\n\n    uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n    for (uint8 i = 0; i < _pooledTokens.length; i++) {\n      if (i > 0) {\n        // Check if index is already used. Check if 0th element is a duplicate.\n        if (s.tokenIndexes[_canonicalId][address(_pooledTokens[i])] != 0 || _pooledTokens[0] == _pooledTokens[i])\n          revert StableSwapFacet__initializeSwap_duplicateTokens();\n      }\n      if (address(_pooledTokens[i]) == address(0)) revert StableSwapFacet__initializeSwap_zeroTokenAddress();\n\n      if (decimals[i] > SwapUtils.POOL_PRECISION_DECIMALS)\n        revert StableSwapFacet__initializeSwap_tokenDecimalsExceedMax();\n\n      precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]);\n      s.tokenIndexes[_canonicalId][address(_pooledTokens[i])] = i;\n    }\n\n    // Check _a, _fee, _adminFee, _withdrawFee parameters\n    if (_a >= AmplificationUtils.MAX_A) revert StableSwapFacet__initializeSwap_aExceedMax();\n    if (_fee >= SwapUtils.MAX_SWAP_FEE) revert StableSwapFacet__initializeSwap_feeExceedMax();\n    if (_adminFee >= SwapUtils.MAX_ADMIN_FEE) revert StableSwapFacet__initializeSwap_adminFeeExceedMax();\n\n    // Initialize a LPToken contract\n    LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n    if (!lpToken.initialize(lpTokenName, lpTokenSymbol))\n      revert StableSwapFacet__initializeSwap_failedInitLpTokenClone();\n\n    // Initialize swapStorage struct\n    s.swapStorages[_canonicalId] = SwapUtils.Swap({\n      initialA: _a * AmplificationUtils.A_PRECISION,\n      futureA: _a * AmplificationUtils.A_PRECISION,\n      swapFee: _fee,\n      adminFee: _adminFee,\n      lpToken: lpToken,\n      pooledTokens: _pooledTokens,\n      tokenPrecisionMultipliers: precisionMultipliers,\n      balances: new uint256[](_pooledTokens.length),\n      adminFees: new uint256[](_pooledTokens.length),\n      initialATime: 0,\n      futureATime: 0\n    });\n  }\n\n  /**\n   * @notice Withdraw all admin fees to the contract owner\n   * @param canonicalId the canonical token id\n   */\n  function withdrawSwapAdminFees(bytes32 canonicalId) external onlyOwner {\n    s.swapStorages[canonicalId].withdrawAdminFees(msg.sender);\n  }\n\n  /**\n   * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n   * @param canonicalId the canonical token id\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setSwapAdminFee(bytes32 canonicalId, uint256 newAdminFee) external onlyOwner {\n    s.swapStorages[canonicalId].setAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice Update the swap fee to be applied on swaps\n   * @param canonicalId the canonical token id\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(bytes32 canonicalId, uint256 newSwapFee) external onlyOwner {\n    s.swapStorages[canonicalId].setSwapFee(newSwapFee);\n  }\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA and futureTime\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param canonicalId the canonical token id\n   * @param futureA the new A to ramp towards\n   * @param futureTime timestamp when the new A should be reached\n   */\n  function rampA(\n    bytes32 canonicalId,\n    uint256 futureA,\n    uint256 futureTime\n  ) external onlyOwner {\n    s.swapStorages[canonicalId].rampA(futureA, futureTime);\n  }\n\n  /**\n   * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n   * @param canonicalId the canonical token id\n   */\n  function stopRampA(bytes32 canonicalId) external onlyOwner {\n    s.swapStorages[canonicalId].stopRampA();\n  }\n}\n\n\n",
        "CodeNames": [
            "StableSwapFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StableSwapFacet.sol#L279-L286",
                "Type": "Missing modifier",
                "Description": "Two swapping functions contain the 'whenNotPaused' modifier while 'swapExactOut()' and 'addSwapLiquidity()' do not. All functions to swap and add liquidity should contain the same modifiers to stop transactions while paused.",
                "Repair": "Add the 'whenNotPaused' modifier to all functions that perform swaps or liquidity additions."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LPToken} from \"../helpers/LPToken.sol\";\nimport {AmplificationUtils} from \"./AmplificationUtils.sol\";\nimport {MathUtils} from \"./MathUtils.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using MathUtils for uint256;\n\n  /*** EVENTS ***/\n\n  event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\n  event AddLiquidity(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(uint256 newAdminFee);\n  event NewSwapFee(uint256 newSwapFee);\n\n  struct Swap {\n    // variables around the ramp management of A,\n    // the amplification coefficient * n * (n - 1)\n    // see https://www.curve.fi/stableswap-paper.pdf for details\n    uint256 initialA;\n    uint256 futureA;\n    uint256 initialATime;\n    uint256 futureATime;\n    // fee calculation\n    uint256 swapFee;\n    uint256 adminFee;\n    LPToken lpToken;\n    // contract references for all tokens being pooled\n    IERC20[] pooledTokens;\n    // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n    // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n    // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n    uint256[] tokenPrecisionMultipliers;\n    // the pool balance of each token, in the token's precision\n    // the contract's actual token balance might differ\n    uint256[] balances;\n    // the admin fee balance of each token, in the token's precision\n    uint256[] adminFees;\n  }\n\n  // Struct storing variables used in calculations in the\n  // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n  struct CalculateWithdrawOneTokenDYInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 newY;\n    uint256 feePerToken;\n    uint256 preciseA;\n  }\n\n  // Struct storing variables used in calculations in the\n  // {add,remove}Liquidity functions to avoid stack too deep errors\n  struct ManageLiquidityInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 d2;\n    uint256 preciseA;\n    LPToken lpToken;\n    uint256 totalSupply;\n    uint256[] balances;\n    uint256[] multipliers;\n  }\n\n  // the precision all pools tokens will be converted to\n  uint8 internal constant POOL_PRECISION_DECIMALS = 18;\n\n  // the denominator used to calculate admin and LP fees. For example, an\n  // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n  uint256 internal constant FEE_DENOMINATOR = 10**10;\n\n  // Max swap fee is 1% or 100bps of each swap\n  uint256 internal constant MAX_SWAP_FEE = 10**8;\n\n  // Max adminFee is 100% of the swapFee\n  // adminFee does not add additional fee on top of swapFee\n  // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n  // users but only on the earnings of LPs\n  uint256 internal constant MAX_ADMIN_FEE = 10**10;\n\n  // Constant value used as max loop limit\n  uint256 internal constant MAX_LOOP_LIMIT = 256;\n\n  /*** VIEW & PURE FUNCTIONS ***/\n\n  function _getAPrecise(Swap storage self) private view returns (uint256) {\n    return AmplificationUtils._getAPrecise(self);\n  }\n\n  /**\n   * @notice Calculate the dy, the amount of selected token that user receives and\n   * the fee of withdrawing in one token\n   * @param tokenAmount the amount to withdraw in the pool's precision\n   * @param tokenIndex which token will be withdrawn\n   * @param self Swap struct to read from\n   * @return the amount of token user will receive\n   */\n  function calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) internal view returns (uint256) {\n    (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n      self,\n      tokenAmount,\n      tokenIndex,\n      self.lpToken.totalSupply()\n    );\n    return availableTokenAmount;\n  }\n\n  function _calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 totalSupply\n  ) private view returns (uint256, uint256) {\n    uint256 dy;\n    uint256 newY;\n    uint256 currentY;\n\n    (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\n\n    // dy_0 (without fees)\n    // dy, dy_0 - dy\n\n    uint256 dySwapFee = currentY.sub(newY).div(self.tokenPrecisionMultipliers[tokenIndex]).sub(dy);\n\n    return (dy, dySwapFee);\n  }\n\n  /**\n   * @notice Calculate the dy of withdrawing in one token\n   * @param self Swap struct to read from\n   * @param tokenIndex which token will be withdrawn\n   * @param tokenAmount the amount to withdraw in the pools precision\n   * @return the d and the new y after withdrawing one token\n   */\n  function calculateWithdrawOneTokenDY(\n    Swap storage self,\n    uint8 tokenIndex,\n    uint256 tokenAmount,\n    uint256 totalSupply\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    // Get the current D, then solve the stableswap invariant\n    // y_i for D - tokenAmount\n    uint256[] memory xp = _xp(self);\n\n    require(tokenIndex < xp.length, \"Token index out of range\");\n\n    CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n    v.preciseA = _getAPrecise(self);\n    v.d0 = getD(xp, v.preciseA);\n    v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\n\n    require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n    v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n    uint256[] memory xpReduced = new uint256[](xp.length);\n\n    v.feePerToken = _feePerToken(self.swapFee, xp.length);\n    for (uint256 i = 0; i < xp.length; i++) {\n      uint256 xpi = xp[i];\n      // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n      // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n      // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n      xpReduced[i] = xpi.sub(\n        ((i == tokenIndex) ? xpi.mul(v.d1).div(v.d0).sub(v.newY) : xpi.sub(xpi.mul(v.d1).div(v.d0)))\n          .mul(v.feePerToken)\n          .div(FEE_DENOMINATOR)\n      );\n    }\n\n    uint256 dy = xpReduced[tokenIndex].sub(getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\n    dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n\n    return (dy, v.newY, xp[tokenIndex]);\n  }\n\n  /**\n   * @notice Calculate the price of a token in the pool with given\n   * precision-adjusted balances and a particular D.\n   *\n   * @dev This is accomplished via solving the invariant iteratively.\n   * See the StableSwap paper and Curve.fi implementation for further details.\n   *\n   * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n   * x_1**2 + b*x_1 = c\n   * x_1 = (x_1**2 + c) / (2*x_1 + b)\n   *\n   * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n   * @param tokenIndex Index of token we are calculating for.\n   * @param xp a precision-adjusted set of pool balances. Array should be\n   * the same cardinality as the pool.\n   * @param d the stableswap invariant\n   * @return the price of the token, in the same precision as in xp\n   */\n  function getYD(\n    uint256 a,\n    uint8 tokenIndex,\n    uint256[] memory xp,\n    uint256 d\n  ) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndex < numTokens, \"Token not found\");\n\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = a.mul(numTokens);\n\n    for (uint256 i = 0; i < numTokens; i++) {\n      if (i != tokenIndex) {\n        s = s.add(xp[i]);\n        c = c.mul(d).div(xp[i].mul(numTokens));\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // c = c * D * D * D * ... overflow!\n      }\n    }\n    c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\n\n    uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\n    uint256 yPrev;\n    uint256 y = d;\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      yPrev = y;\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n      if (y.within1(yPrev)) {\n        return y;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n   * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n   * as the pool.\n   * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n   * See the StableSwap paper for details\n   * @return the invariant, at the precision of the pool\n   */\n  function getD(uint256[] memory xp, uint256 a) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    uint256 s;\n    for (uint256 i = 0; i < numTokens; i++) {\n      s = s.add(xp[i]);\n    }\n    if (s == 0) {\n      return 0;\n    }\n\n    uint256 prevD;\n    uint256 d = s;\n    uint256 nA = a.mul(numTokens);\n\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      uint256 dP = d;\n      for (uint256 j = 0; j < numTokens; j++) {\n        dP = dP.mul(d).div(xp[j].mul(numTokens));\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // dP = dP * D * D * D * ... overflow!\n      }\n      prevD = d;\n      d = nA.mul(s).div(AmplificationUtils.A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\n        nA.sub(AmplificationUtils.A_PRECISION).mul(d).div(AmplificationUtils.A_PRECISION).add(numTokens.add(1).mul(dP))\n      );\n      if (d.within1(prevD)) {\n        return d;\n      }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    revert(\"D does not converge\");\n  }\n\n  /**\n   * @notice Given a set of balances and precision multipliers, return the\n   * precision-adjusted balances.\n   *\n   * @param balances an array of token balances, in their native precisions.\n   * These should generally correspond with pooled tokens.\n   *\n   * @param precisionMultipliers an array of multipliers, corresponding to\n   * the amounts in the balances array. When multiplied together they\n   * should yield amounts at the pool's precision.\n   *\n   * @return an array of amounts \"scaled\" to the pool's precision\n   */\n  function _xp(uint256[] memory balances, uint256[] memory precisionMultipliers)\n    internal\n    pure\n    returns (uint256[] memory)\n  {\n    uint256 numTokens = balances.length;\n    require(numTokens == precisionMultipliers.length, \"Balances must match multipliers\");\n    uint256[] memory xp = new uint256[](numTokens);\n    for (uint256 i = 0; i < numTokens; i++) {\n      xp[i] = balances[i].mul(precisionMultipliers[i]);\n    }\n    return xp;\n  }\n\n  /**\n   * @notice Return the precision-adjusted balances of all tokens in the pool\n   * @param self Swap struct to read from\n   * @return the pool balances \"scaled\" to the pool's precision, allowing\n   * them to be more easily compared.\n   */\n  function _xp(Swap storage self) internal view returns (uint256[] memory) {\n    return _xp(self.balances, self.tokenPrecisionMultipliers);\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param self Swap struct to read from\n   * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n   */\n  function getVirtualPrice(Swap storage self) internal view returns (uint256) {\n    uint256 d = getD(_xp(self), _getAPrecise(self));\n    LPToken lpToken = self.lpToken;\n    uint256 supply = lpToken.totalSupply();\n    if (supply > 0) {\n      return d.mul(10**uint256(POOL_PRECISION_DECIMALS)).div(supply);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Calculate the new balances of the tokens given the indexes of the token\n   * that is swapped from (FROM) and the token that is swapped to (TO).\n   * This function is used as a helper function to calculate how much TO token\n   * the user should receive on swap.\n   *\n   * @param preciseA precise form of amplification coefficient\n   * @param tokenIndexFrom index of FROM token\n   * @param tokenIndexTo index of TO token\n   * @param x the new total amount of FROM token\n   * @param xp balances of the tokens in the pool\n   * @return the amount of TO token that should remain in the pool\n   */\n  function getY(\n    uint256 preciseA,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 x,\n    uint256[] memory xp\n  ) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndexFrom != tokenIndexTo, \"Can't compare token to itself\");\n    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"Tokens must be in pool\");\n\n    uint256 d = getD(xp, preciseA);\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = numTokens.mul(preciseA);\n\n    uint256 _x;\n    for (uint256 i = 0; i < numTokens; i++) {\n      if (i == tokenIndexFrom) {\n        _x = x;\n      } else if (i != tokenIndexTo) {\n        _x = xp[i];\n      } else {\n        continue;\n      }\n      s = s.add(_x);\n      c = c.mul(d).div(_x.mul(numTokens));\n      // If we were to protect the division loss we would have to keep the denominator separate\n      // and divide at the end. However this leads to overflow with large numTokens or/and D.\n      // c = c * D * D * D * ... overflow!\n    }\n    c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\n    uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\n    uint256 yPrev;\n    uint256 y = d;\n\n    // iterative approximation\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n      yPrev = y;\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n      if (y.within1(yPrev)) {\n        return y;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   */\n  function calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) internal view returns (uint256 dy) {\n    (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy.\n   * @return dx the number of tokens the user have to transfer + fee\n   */\n  function calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy\n  ) internal view returns (uint256 dx) {\n    (dx, ) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, self.balances);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   * @return dyFee the associated fee\n   */\n  function _calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256[] memory balances\n  ) internal view returns (uint256 dy, uint256 dyFee) {\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\n    uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\n    uint256 y = getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n    dy = xp[tokenIndexTo].sub(y).sub(1);\n    dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n    dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dx the number of tokens the user have to deposit\n   * @return dxFee the associated fee\n   */\n  function _calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256[] memory balances\n  ) internal view returns (uint256 dx, uint256 dxFee) {\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\n\n    uint256 a = _getAPrecise(self);\n    uint256 d0 = getD(xp, a);\n\n    xp[tokenIndexTo] = xp[tokenIndexTo].sub(dy.mul(multipliers[tokenIndexTo]));\n    uint256 x = getYD(a, tokenIndexFrom, xp, d0);\n    dx = x.sub(xp[tokenIndexFrom]).add(1);\n    dxFee = dx.mul(self.swapFee).div(FEE_DENOMINATOR);\n    dx = dx.add(dxFee).div(multipliers[tokenIndexFrom]);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of\n   * LP tokens\n   *\n   * @param amount the amount of LP tokens that would to be burned on\n   * withdrawal\n   * @return array of amounts of tokens user will receive\n   */\n  function calculateRemoveLiquidity(Swap storage self, uint256 amount) internal view returns (uint256[] memory) {\n    return _calculateRemoveLiquidity(self.balances, amount, self.lpToken.totalSupply());\n  }\n\n  function _calculateRemoveLiquidity(\n    uint256[] memory balances,\n    uint256 amount,\n    uint256 totalSupply\n  ) internal pure returns (uint256[] memory) {\n    require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n    uint256[] memory amounts = new uint256[](balances.length);\n\n    for (uint256 i = 0; i < balances.length; i++) {\n      amounts[i] = balances[i].mul(amount).div(totalSupply);\n    }\n    return amounts;\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param self Swap struct to read from\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return if deposit was true, total amount of lp token that will be minted and if\n   * deposit was false, total amount of lp token that will be burned\n   */\n  function calculateTokenAmount(\n    Swap storage self,\n    uint256[] calldata amounts,\n    bool deposit\n  ) internal view returns (uint256) {\n    uint256 a = _getAPrecise(self);\n    uint256[] memory balances = self.balances;\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n\n    uint256 d0 = getD(_xp(balances, multipliers), a);\n    for (uint256 i = 0; i < balances.length; i++) {\n      if (deposit) {\n        balances[i] = balances[i].add(amounts[i]);\n      } else {\n        balances[i] = balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\n      }\n    }\n    uint256 d1 = getD(_xp(balances, multipliers), a);\n    uint256 totalSupply = self.lpToken.totalSupply();\n\n    if (deposit) {\n      return d1.sub(d0).mul(totalSupply).div(d0);\n    } else {\n      return d0.sub(d1).mul(totalSupply).div(d0);\n    }\n  }\n\n  /**\n   * @notice return accumulated amount of admin fees of the token with given index\n   * @param self Swap struct to read from\n   * @param index Index of the pooled token\n   * @return admin balance in the token's precision\n   */\n  function getAdminBalance(Swap storage self, uint256 index) internal view returns (uint256) {\n    require(index < self.pooledTokens.length, \"Token index out of range\");\n    return self.adminFees[index];\n  }\n\n  /**\n   * @notice internal helper function to calculate fee per token multiplier used in\n   * swap fee calculations\n   * @param swapFee swap fee for the tokens\n   * @param numTokens number of tokens pooled\n   */\n  function _feePerToken(uint256 swapFee, uint256 numTokens) internal pure returns (uint256) {\n    return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) internal returns (uint256) {\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n      // Transfer tokens first to see if a fee was charged on transfer\n      uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n      tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n      // Use the actual transferred amount for AMM math\n      dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);\n    }\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n    uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexTo]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\n    if (dyAdminFee > 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo].add(dyAdminFee);\n    }\n\n    self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dy the amount of tokens the user wants to buy\n   * @param maxDx the max amount the user would like to send.\n   * @return amount of token user have to transfer on swap\n   */\n  function swapOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) internal returns (uint256) {\n    require(dy <= self.balances[tokenIndexTo], \"Cannot get more than pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"Swap needs more than max tokens\");\n\n    uint256 dxAdminFee = dxFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexFrom]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx).sub(dxAdminFee);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy);\n    if (dxAdminFee > 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom].add(dxAdminFee);\n    }\n\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n      // Transfer tokens first to see if a fee was charged on transfer\n      uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n      tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n      // Use the actual transferred amount for AMM math\n      require(dx == tokenFrom.balanceOf(address(this)).sub(beforeBalance), \"not support fee token\");\n    }\n\n    self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice swap two tokens in the pool internally\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swapInternal(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) internal returns (uint256) {\n    IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n    require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n    uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexTo]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\n\n    if (dyAdminFee > 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo].add(dyAdminFee);\n    }\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice Should get exact amount out of AMM for asset put in\n   */\n  function swapInternalOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) internal returns (uint256) {\n    require(dy <= self.balances[tokenIndexTo], \"Cannot get more than pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"Swap didn't result in min tokens\");\n\n    uint256 dxAdminFee = dxFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n      self.tokenPrecisionMultipliers[tokenIndexFrom]\n    );\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx).sub(dxAdminFee);\n    self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy);\n\n    if (dxAdminFee > 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom].add(dxAdminFee);\n    }\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice Add liquidity to the pool\n   * @param self Swap struct to read from and write to\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n   * @return amount of LP token user received\n   */\n  function addLiquidity(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 minToMint\n  ) internal returns (uint256) {\n    IERC20[] memory pooledTokens = self.pooledTokens;\n    require(amounts.length == pooledTokens.length, \"Amounts must match pooled tokens\");\n\n    // current state\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n\n    if (v.totalSupply != 0) {\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n    }\n\n    uint256[] memory newBalances = new uint256[](pooledTokens.length);\n\n    for (uint256 i = 0; i < pooledTokens.length; i++) {\n      require(v.totalSupply != 0 || amounts[i] > 0, \"Must supply all tokens in pool\");\n\n      // Transfer tokens first to see if a fee was charged on transfer\n      if (amounts[i] != 0) {\n        uint256 beforeBalance = pooledTokens[i].balanceOf(address(this));\n        pooledTokens[i].safeTransferFrom(msg.sender, address(this), amounts[i]);\n\n        // Update the amounts[] with actual transfer amount\n        amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(beforeBalance);\n      }\n\n      newBalances[i] = v.balances[i].add(amounts[i]);\n    }\n\n    // invariant after change\n    v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    require(v.d1 > v.d0, \"D should increase\");\n\n    // updated to reflect fees and calculate the user's LP tokens\n    v.d2 = v.d1;\n    uint256[] memory fees = new uint256[](pooledTokens.length);\n\n    if (v.totalSupply != 0) {\n      uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n      for (uint256 i = 0; i < pooledTokens.length; i++) {\n        uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n        fees[i] = feePerToken.mul(idealBalance.difference(newBalances[i])).div(FEE_DENOMINATOR);\n        uint256 adminFee = fees[i].mul(self.adminFee).div(FEE_DENOMINATOR);\n        self.balances[i] = newBalances[i].sub(adminFee);\n        self.adminFees[i] = self.adminFees[i].add(adminFee);\n        newBalances[i] = newBalances[i].sub(fees[i]);\n      }\n      v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    } else {\n      // the initial depositor doesn't pay fees\n      self.balances = newBalances;\n    }\n\n    uint256 toMint;\n    if (v.totalSupply == 0) {\n      toMint = v.d1;\n    } else {\n      toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\n    }\n\n    require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n    // mint the user's LP tokens\n    v.lpToken.mint(msg.sender, toMint);\n\n    emit AddLiquidity(msg.sender, amounts, fees, v.d1, v.totalSupply.add(toMint));\n\n    return toMint;\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param self Swap struct to read from and write to\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   * acceptable for this burn. Useful as a front-running mitigation\n   * @return amounts of tokens the user received\n   */\n  function removeLiquidity(\n    Swap storage self,\n    uint256 amount,\n    uint256[] calldata minAmounts\n  ) internal returns (uint256[] memory) {\n    LPToken lpToken = self.lpToken;\n    IERC20[] memory pooledTokens = self.pooledTokens;\n    require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    require(minAmounts.length == pooledTokens.length, \"minAmounts must match poolTokens\");\n\n    uint256[] memory balances = self.balances;\n    uint256 totalSupply = lpToken.totalSupply();\n\n    uint256[] memory amounts = _calculateRemoveLiquidity(balances, amount, totalSupply);\n\n    for (uint256 i = 0; i < amounts.length; i++) {\n      require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n      self.balances[i] = balances[i].sub(amounts[i]);\n      pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n    }\n\n    lpToken.burnFrom(msg.sender, amount);\n\n    emit RemoveLiquidity(msg.sender, amounts, totalSupply.sub(amount));\n\n    return amounts;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token.\n   * @param self Swap struct to read from and write to\n   * @param tokenAmount the amount of the lp tokens to burn\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @return amount chosen token that user received\n   */\n  function removeLiquidityOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount\n  ) internal returns (uint256) {\n    LPToken lpToken = self.lpToken;\n    IERC20[] memory pooledTokens = self.pooledTokens;\n\n    require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    require(tokenIndex < pooledTokens.length, \"Token not found\");\n\n    uint256 totalSupply = lpToken.totalSupply();\n\n    (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(self, tokenAmount, tokenIndex, totalSupply);\n\n    require(dy >= minAmount, \"dy < minAmount\");\n\n    uint256 adminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);\n    self.balances[tokenIndex] = self.balances[tokenIndex].sub(dy.add(adminFee));\n    if (adminFee > 0) {\n      self.adminFees[tokenIndex] = self.adminFees[tokenIndex].add(adminFee);\n    }\n    lpToken.burnFrom(msg.sender, tokenAmount);\n    pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n\n    emit RemoveLiquidityOne(msg.sender, tokenAmount, totalSupply, tokenIndex, dy);\n\n    return dy;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances.\n   *\n   * @param self Swap struct to read from and write to\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @return actual amount of LP tokens burned in the withdrawal\n   */\n  function removeLiquidityImbalance(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 maxBurnAmount\n  ) internal returns (uint256) {\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n\n    IERC20[] memory pooledTokens = self.pooledTokens;\n\n    require(amounts.length == pooledTokens.length, \"Amounts should match pool tokens\");\n\n    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \">LP.balanceOf\");\n\n    uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n    uint256[] memory fees = new uint256[](pooledTokens.length);\n    {\n      uint256[] memory balances1 = new uint256[](pooledTokens.length);\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n      for (uint256 i = 0; i < pooledTokens.length; i++) {\n        balances1[i] = v.balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\n      }\n      v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n      for (uint256 i = 0; i < pooledTokens.length; i++) {\n        uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n        uint256 difference = idealBalance.difference(balances1[i]);\n        fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n        uint256 adminFee = fees[i].mul(self.adminFee).div(FEE_DENOMINATOR);\n        self.balances[i] = balances1[i].sub(adminFee);\n        self.adminFees[i] = self.adminFees[i].add(adminFee);\n        balances1[i] = balances1[i].sub(fees[i]);\n      }\n\n      v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n    }\n    uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n    require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n    tokenAmount = tokenAmount.add(1);\n\n    require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n    v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n    for (uint256 i = 0; i < pooledTokens.length; i++) {\n      pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n    }\n\n    emit RemoveLiquidityImbalance(msg.sender, amounts, fees, v.d1, v.totalSupply.sub(tokenAmount));\n\n    return tokenAmount;\n  }\n\n  /**\n   * @notice withdraw all admin fees to a given address\n   * @param self Swap struct to withdraw fees from\n   * @param to Address to send the fees to\n   */\n  function withdrawAdminFees(Swap storage self, address to) internal {\n    IERC20[] memory pooledTokens = self.pooledTokens;\n    for (uint256 i = 0; i < pooledTokens.length; i++) {\n      IERC20 token = pooledTokens[i];\n      uint256 balance = self.adminFees[i];\n      if (balance != 0) {\n        token.safeTransfer(to, balance);\n      }\n    }\n  }\n\n  /**\n   * @notice Sets the admin fee\n   * @dev adminFee cannot be higher than 100% of the swap fee\n   * @param self Swap struct to update\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setAdminFee(Swap storage self, uint256 newAdminFee) internal {\n    require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\n    self.adminFee = newAdminFee;\n\n    emit NewAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice update the swap fee\n   * @dev fee cannot be higher than 1% of each swap\n   * @param self Swap struct to update\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(Swap storage self, uint256 newSwapFee) internal {\n    require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\n    self.swapFee = newSwapFee;\n\n    emit NewSwapFee(newSwapFee);\n  }\n}\n\n\n",
        "CodeNames": [
            "SwapUtils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SwapUtils.sol#L1053-L1062",
                "Type": "Incorrect implementation",
                "Description": "'self.adminFees[i]' should be reset to 0 every time it's withdrawn. Otherwise, the 'adminFees' can be withdrawn multiple times. The admin may just be unaware of this issue and casualty 'withdrawAdminFees()' from time to time, and rug all the users slowly.",
                "Repair": "Reset 'self.adminFees[i]' to 0 every time it's withdrawn."
            }
        ]
    }
]