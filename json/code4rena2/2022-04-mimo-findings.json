[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SuperVault's leverageSwap and emptyVaultOperation functions",
                "Type": "Stuck Functions",
                "Description": "leverageSwap and emptyVaultOperation can be run repeatedly for the same tokens. If these tokens happen to be an ERC20 that do not allow for approval of positive amount when allowance already positive, both functions can become stuck.",
                "Repair": "Consider adding zero amount approval before actual amount approval, i.e. force zero allowance before current approval."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\n\nimport \"./interfaces/IAddressProvider.sol\";\nimport \"./interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IVaultsCore.sol\";\nimport \"./interfaces/IGenericMiner.sol\";\nimport \"./interfaces/IDexAddressProvider.sol\";\n\n/// @title A parallel protocol vault with added functionality\n/// @notice You can use this for collateral rebalancing\n/// @dev This contract should be cloned and initialized with a SuperVaultFactory contract\ncontract SuperVault is AccessControl, Initializable {\n  enum Operation {\n    LEVERAGE,\n    REBALANCE,\n    EMPTY\n  }\n\n  struct AggregatorRequest {\n    uint256 parToSell;\n    bytes dexTxData;\n    uint dexIndex;\n  }\n\n  IAddressProvider public a;\n  IGovernanceAddressProvider public ga;\n  IPool public lendingPool;\n  IDexAddressProvider internal _dexAP;\n\n  modifier onlyOwner() {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"SV001\");\n    _;\n  }\n\n  ///@notice Initializes the Supervault contract\n  ///@dev This replaces the constructor function as in the factory design pattern\n  ///@param _a The address of the protocol's AddressProvider\n  ///@param _ga The address of the protocol's GovernanceAddressProvider\n  ///@param _lendingPool The address of the lendingPool from where flashLoans are taken\n  ///@param _owner The owner of this SuperVault contract\n  function initialize(\n    IAddressProvider _a,\n    IGovernanceAddressProvider _ga,\n    IPool _lendingPool,\n    address _owner,\n    IDexAddressProvider dexAP\n  ) external initializer {\n    require(address(_a) != address(0));\n    require(address(_ga) != address(0));\n    require(address(_lendingPool) != address(0));\n    require(address(dexAP) != address(0));\n\n    a = _a;\n    ga = _ga;\n    lendingPool = _lendingPool;\n    _dexAP = dexAP;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n  }\n\n  ///@notice Routes a call from a flashloan pool to a leverage or rebalance operation\n  ///@dev This Integrates with AAVE V2 flashLoans\n  ///@dev This function is called by the lendingPool during execution of the leverage function\n  ///@param assets An address array with one element corresponding to the address of the leveraged or rebalanced asset\n  ///@param amounts A uint array with one element corresponding to the amount of the leveraged or rebalanced asset\n  ///@param premiums A uint array with one element corresponding to the flashLoan fees\n  ///@param params Bytes sent by the leverage or rebalance function that contains information on the aggregator swap\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address,\n    bytes calldata params\n  ) external returns (bool) {\n    require(msg.sender == address(lendingPool), \"SV002\");\n    (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));\n    IERC20 asset = IERC20(assets[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n    if (operation == Operation.LEVERAGE) {\n      leverageOperation(asset, flashloanRepayAmount, operationParams);\n    }\n    if (operation == Operation.REBALANCE) {\n      rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n    }\n    if (operation == Operation.EMPTY) {\n      emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n    }\n\n    asset.approve(address(lendingPool), flashloanRepayAmount);\n    return true;\n  }\n\n  ///@notice Used by executeOperation to call an aggregator to swap and deposit the swapped asset into a vault\n  function leverageOperation(\n    IERC20 token,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    leverageSwap(params, token);\n\n    require(token.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n    a.core().deposit(address(token), token.balanceOf(address(this)) - flashloanRepayAmount);\n  }\n\n  ///@notice Leverage an asset using a flashloan to balance collateral\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param asset The address of the asset to leverage\n  ///@param depositAmount The initial starting amount, e.g. 1 ETH\n  ///@param borrowAmount The amount to be borrowed, e.g. 2 ETH, bringing the total to 3 ETH\n  ///@param parToSell The amount of PAR we'll borrow so we can repay the leverage\n  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap\n  ///@param dexIndex DexAddressProvider index of the aggregator to be used for selling PAR, either OneInch or Paraswap\n  function leverage(\n    address asset,\n    uint256 depositAmount, //\n    uint256 borrowAmount, //\n    uint256 parToSell, //\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    IERC20(asset).transferFrom(msg.sender, address(this), depositAmount);\n    bytes memory leverageParams = abi.encode(parToSell, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.LEVERAGE, leverageParams);\n    takeFlashLoan(asset, borrowAmount, params);\n    checkAndSendMIMO();\n  }\n\n  ///@notice Used by executeOperation to flashloan an asset, call an aggregator to swap for toAsset, and then rebalance the vault\n  function rebalanceOperation(\n    IERC20 fromCollateral,\n    uint256 amount,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    (uint256 vaultId, address toCollateral, uint256 parAmount, bytes memory dexTxData, uint dexIndex) = abi\n      .decode(params, (uint256, address, uint256, bytes, uint ));\n    aggregatorSwap(dexIndex, fromCollateral, amount, dexTxData);\n\n    uint256 depositAmount = IERC20(toCollateral).balanceOf(address(this));\n\n    IERC20(toCollateral).approve(address(a.core()), depositAmount);\n\n    a.core().depositAndBorrow(toCollateral, depositAmount, parAmount);\n    a.core().repay(vaultId, parAmount);\n\n    a.core().withdraw(vaultId, flashloanRepayAmount);\n\n    require(fromCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n  }\n\n  ///@notice Uses a flashloan to exchange one collateral type for another, e.g. to hold less volatile collateral\n  ///@notice Both collateral vaults must have been created by this contract using the depositToVault or depositAndBorrowFromVault functions\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param vaultId The Id of the vault to reduce the collateral of\n  ///@param toCollateral Address of the collateral to rebalance to\n  ///@param fromCollateral Address of the starting collateral that will be reduced\n  ///@param fromCollateralAmount Amount of starting collateral to deleverage\n  ///@param parAmount Amount of par that will be deposited to exchange for\n  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap\n  ///@param dexIndex DexAddressProvider index representing the aggregator to be used for selling PAR, either OneInch or Paraswap\n  function rebalance(\n    uint256 vaultId, // vaultId to deleverage\n    address toCollateral,\n    address fromCollateral, // save some gas by just passing in collateral type instead of querying VaultsDataProvider for it\n    uint256 fromCollateralAmount, // amount of collateral to reduce in main vault and borrow from Aave first\n    uint256 parAmount, // amount of PAR to repay and deleverage\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    bytes memory rebalanceParams = abi.encode(vaultId, toCollateral, parAmount, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.REBALANCE, rebalanceParams);\n\n    takeFlashLoan(fromCollateral, fromCollateralAmount, params);\n    checkAndSendMIMO();\n  }\n\n  ///@notice Used by executeOperation to repay all debt for a vault, withdraw collateral from the vault, and send the collateral back to the user\n  ///@notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 amount,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    // Use par to repay debt\n    (uint256 vaultId, bytes memory dexTxData, uint dexIndex) = abi.decode(params, (uint256, bytes, uint));\n\n    aggregatorSwap(dexIndex, vaultCollateral, amount, dexTxData); // swap assets for par to repay back loan\n\n    IERC20 par = IERC20(a.stablex());\n    par.approve(address(a.core()), par.balanceOf(address(this)));\n\n    // Repay the par debt\n    a.core().repayAll(vaultId);\n    uint256 vaultBalance = a.vaultsData().vaultCollateralBalance(vaultId);\n    // Withdraw all collateral\n    a.core().withdraw(vaultId, vaultBalance);\n\n    require(vaultCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n  }\n\n  ///@notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n  ///@notice This vault must have been created by this contract\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param vaultId The Id of the vault to empty\n  ///@param collateralType Address of the collateral of the vault\n  ///@param repayAmount Amount of par that needs to be repaid before all collateral can be withdrawn\n  ///@param dexTxData Bytes that contain the low-level call to swap the vault asset for par to repay the vault loan\n  ///@param dexIndex Index to use for swapping the vault collateral for par\n  function emptyVault(\n    uint256 vaultId,\n    address collateralType,\n    uint256 repayAmount, // Amount, in collateral type, needed to borrow to repay current vault debt\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    // Flashloan collateral and swap for par to repay any outstanding vault debt\n    bytes memory emptyVaultParams = abi.encode(vaultId, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.EMPTY, emptyVaultParams);\n    takeFlashLoan(collateralType, repayAmount, params);\n\n    checkAndSendMIMO();\n\n    // Send remaining par, mimo, and collateral back to the owner\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));\n    checkAndSendMIMO();\n\n    IERC20 collateral = IERC20(collateralType);\n    collateral.transfer(msg.sender, collateral.balanceOf(address(this)));\n  }\n\n  ///@notice Withdraw collateral from a vault\n  ///@notice Vault must have been created through leverage, depositToVault, or depositAndBorrowFromVault from this contract\n  ///@param vaultId The ID of the vault to withdraw from\n  ///@param amount The amount of collateral to withdraw\n  function withdrawFromVault(uint256 vaultId, uint256 amount) external onlyOwner {\n    a.core().withdraw(vaultId, amount);\n    IERC20 asset = IERC20(a.vaultsData().vaultCollateralType(vaultId));\n    require(asset.transfer(msg.sender, amount));\n  }\n\n  ///@notice Borrow PAR from a vault\n  ///@param vaultId The ID of the vault to borrow from\n  ///@param amount The amount of PAR to borrow\n  function borrowFromVault(uint256 vaultId, uint256 amount) external onlyOwner {\n    a.core().borrow(vaultId, amount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));\n    checkAndSendMIMO();\n  }\n\n  ///@notice Withdraw all of one type of collateral from this contract\n  ///@notice Can only be used on vaults which have been created by this contract\n  ///@param asset The address of the collateral type\n  function withdrawAsset(address asset) external onlyOwner {\n    IERC20 token = IERC20(asset);\n    require(token.transfer(msg.sender, token.balanceOf(address(this))));\n  }\n\n  ///@notice Deposit collateral into a vault\n  ///@notice Requires approval of asset for amount before calling\n  ///@param asset Address of the collateral type\n  ///@param amount Amount to deposit\n  function depositToVault(address asset, uint256 amount) external {\n    IERC20 token = IERC20(asset);\n    token.approve(address(a.core()), amount);\n    token.transferFrom(msg.sender, address(this), amount);\n    a.core().deposit(asset, amount);\n  }\n\n  ///@notice Deposit collateral into a vault and borrow PAR\n  ///@notice Requires approval of asset for amount before calling\n  ///@param asset Address of the collateral type\n  ///@param depositAmount Amount to deposit\n  ///@param borrowAmount Amount of PAR to borrow after depositing\n  function depositAndBorrowFromVault(\n    address asset,\n    uint256 depositAmount,\n    uint256 borrowAmount\n  ) external onlyOwner {\n    IERC20 token = IERC20(asset);\n    token.approve(address(a.core()), depositAmount);\n    token.transferFrom(msg.sender, address(this), depositAmount);\n    a.core().depositAndBorrow(asset, depositAmount, borrowAmount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par\n    checkAndSendMIMO();\n  }\n\n  ///@notice Release MIMO from a MIMO miner to the owner\n  ///@param minerAddress The address of the MIMO miner\n  function releaseMIMO(address minerAddress) external payable onlyOwner {\n    IGenericMiner miner = IGenericMiner(minerAddress);\n    miner.releaseMIMO(address(this));\n    checkAndSendMIMO();\n  }\n\n  ///@notice Wrap ETH and deposit WETH as collateral into a vault\n  function depositETHToVault() external payable {\n    a.core().depositETH{ value: msg.value }();\n  }\n\n  ///@notice Wrap ETH and deposit WETH as collateral into a vault, then borrow PAR from vault\n  ///@param borrowAmount The amount of PAR to borrow after depositing ETH\n  function depositETHAndBorrowFromVault(uint256 borrowAmount) external payable onlyOwner {\n    a.core().depositETHAndBorrow{ value: msg.value }(borrowAmount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par\n    checkAndSendMIMO();\n  }\n\n  ///@notice Helper function to call an aggregator to swap PAR for a leveraged asset\n  ///@dev This helper function is used to limit the number of local variables in the leverageOperation function\n  ///@param params The params passed from the leverageOperation function for the aggregator call\n  ///@param token The leveraged asset to swap PAR for\n  function leverageSwap(bytes memory params, IERC20 token) internal {\n    (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(\n      params,\n      (uint256, bytes, uint )\n    );\n    token.approve(address(a.core()), 2**256 - 1);\n    a.core().depositAndBorrow(address(token), token.balanceOf(address(this)), parToSell);\n    IERC20 par = IERC20(a.stablex());\n    aggregatorSwap(dexIndex, par, parToSell, dexTxData);\n  }\n\n  ///@notice Helper function to approve and swap an asset using an aggregator\n  ///@param dexIndex The DexAddressProvider index of aggregator to use to swap\n  ///@param token The starting token to swap for another asset\n  ///@param amount The amount of starting token to swap for\n  ///@param dexTxData The low-level data to call the aggregator with\n  function aggregatorSwap(\n    uint256 dexIndex,\n    IERC20 token,\n    uint256 amount,\n    bytes memory dexTxData\n  ) internal {\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    require(proxy != address(0) && router != address(0), \"SV201\"); \n    token.approve(proxy, amount);\n    router.call(dexTxData);\n  }\n\n  ///@notice Helper function to format arguments to take a flashloan\n  ///@dev The flashloan call will call the executeOperation function on this contract\n  ///@param asset The address of the asset to loan\n  ///@param amount The amount to borrow\n  ///@param params The params that will be sent to executeOperation after the asset is borrowed\n  function takeFlashLoan(\n    address asset,\n    uint256 amount,\n    bytes memory params\n  ) internal {\n    uint8 referralCode;\n    address[] memory assets = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    uint256[] memory modes = new uint256[](1);\n    (assets[0], amounts[0]) = (asset, amount);\n    lendingPool.flashLoan(address(this), assets, amounts, modes, address(this), params, referralCode);\n  }\n\n  ///@notice Helper function to transfer all MIMO owned by this contract to the Owner\n  function checkAndSendMIMO() internal {\n    if (ga.mimo().balanceOf(address(this)) > 0) {\n      require(ga.mimo().transfer(msg.sender, ga.mimo().balanceOf(address(this))));\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "SuperVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "executeOperation() function in SuperVault contract",
                "Type": "Flash Loan Attack",
                "Description": "Fund loss or theft by attacker with creating a flash loan and setting SuperVault as receiver so executeOperation() will be get called by lendingPool but with attackers specified params.",
                "Repair": "Add a state variable to store the fact that SuperVault imitated flash-loan. When contract tries to start flash-loan, it sets the isFlash to True and executeOperation() only accepts calls if isFlash is True. After the flash loan code will set isFlash to False."
            },
            {
                "Location": "SuperVault.executeOperation function",
                "Type": "Non-standard ERC20 Tokens are Not Supported",
                "Description": "The call to asset.approve() in line{97} doesn't match the expected function signature of approve() on the target contract like in the case of USDT.",
                "Repair": "Consider using safeApprove of OZ"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./GenericMinerV2.sol\";\nimport \"./interfaces/ISupplyMinerV2.sol\";\nimport \"../../governance/interfaces/IGovernanceAddressProvider.sol\";\n\ncontract SupplyMinerV2 is ISupplyMinerV2, GenericMinerV2 {\n  IERC20 private immutable _collateral;\n\n  constructor(\n    IGovernanceAddressProvider _addresses,\n    BoostConfig memory _boostConfig,\n    IERC20 collateral\n  ) public GenericMinerV2(_addresses, _boostConfig) {\n    require(address(collateral) != address(0), \"LM000\");\n    _collateral = collateral;\n  }\n\n  modifier onlyNotifier() {\n    require(msg.sender == address(_a.debtNotifier()), \"LM020\");\n    _;\n  }\n\n  /**\n    Updates user stake based on current user baseDebt\n    @dev this method is for upgradability purposes from an older SupplyMiner to a newer one so the user doesn't have to repay/borrow to set their stake in this SupplyMiner\n    @param user address of the user\n  */\n  function syncStake(address user) external override {\n    uint256 vaultId = _a.parallel().vaultsData().vaultId(address(_collateral), user);\n    IVaultsDataProvider.Vault memory v = _a.parallel().vaultsData().vaults(vaultId);\n    _updateStake(user, v.baseDebt);\n  }\n\n  /**\n    Gets called by the `DebtNotifier` and will update the stake of the user\n    to match his current outstanding debt by using his baseDebt\n    @param user address of the user\n    @param newBaseDebt the new baseDebt and therefore stake for the user\n  */\n  function baseDebtChanged(address user, uint256 newBaseDebt) public override onlyNotifier {\n    _updateStake(user, newBaseDebt);\n  }\n\n  function collateral() public view override returns (IERC20) {\n    return _collateral;\n  }\n}\n\n\n",
        "CodeNames": [
            "SupplyMinerV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "updateBoost function in SupplyMinerV2 contract",
                "Type": "Unfair Rewards",
                "Description": "Users can use updateBoost function to claim unfairly large rewards from liquidity mining contracts for themselves at cost of other users.",
                "Repair": "Remove updateBoost function or redesign boost updates in such a way that distribution of rewards no longer depends on when and how often boost multiplier is updated."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IGenericMinerV2.sol\";\nimport \"../../dex/interfaces/IDexAddressProvider.sol\";\nimport \"../../interfaces/IVaultsDataProvider.sol\";\nimport \"../../libraries/ABDKMath64x64.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract PARMinerV2 is IGenericMinerV2 {\n  using ABDKMath64x64 for int128;\n  using ABDKMath64x64 for uint256;\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  IERC20 internal _par;\n  IGovernanceAddressProvider internal _a;\n  IDexAddressProvider internal immutable _dexAP;\n\n  BoostConfig internal _boostConfig;\n\n  mapping(address => UserInfo) internal _users;\n\n  uint256 internal _totalStake;\n  uint256 internal _totalStakeWithBoost;\n  uint256 internal _liquidateCallerReward;\n\n  uint256 internal _mimoBalanceTracker;\n  uint256 internal _accMimoAmountPerShare;\n\n  uint256 internal _parBalanceTracker;\n  uint256 internal _accParAmountPerShare;\n\n  modifier onlyManager {\n    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), \"LM010\");\n    _;\n  }\n\n  constructor(\n    IGovernanceAddressProvider govAP,\n    IDexAddressProvider dexAP,\n    BoostConfig memory boostConfig\n  ) public {\n    require(address(govAP) != address(0), \"LM000\");\n    require(address(dexAP) != address(0), \"LM000\");\n    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, \"LM004\");\n    _a = govAP;\n    _dexAP = dexAP;\n    _liquidateCallerReward = 200 ether;\n\n    _par = IERC20(govAP.parallel().stablex());\n    _par.approve(address(_a.parallel().core()), uint256(-1));\n\n    _boostConfig = boostConfig;\n\n    emit BoostConfigSet(boostConfig);\n  }\n\n  /**\n    Sets new boost config\n    @dev can only be called by protocol manager\n    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}\n   */\n  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {\n    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, \"LM004\");\n    _boostConfig = newBoostConfig;\n\n    emit BoostConfigSet(_boostConfig);\n  }\n\n  /**\n    Sets liquidation call reward amount\n    @dev can only be called by protocol manager\n    @param amount the amount to reward liquidate method callers with\n   */\n  function setLiquidateCallerReward(uint256 amount) external onlyManager {\n    _liquidateCallerReward = amount;\n  }\n\n  /**\n    Deposit an ERC20 pool token for staking\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20\n    @param amount the amount of tokens to be deposited. Unit is in WEI\n  **/\n  function deposit(uint256 amount) public {\n    _par.safeTransferFrom(msg.sender, address(this), amount);\n    _increaseStake(msg.sender, amount);\n  }\n\n  /**\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI\n  **/\n  function withdraw(uint256 amount) public {\n    _par.safeTransfer(msg.sender, amount);\n    _decreaseStake(msg.sender, amount);\n  }\n\n  /**\n    Liquidate a vault with a specific amount, and sell collaterall back to PAR\n    @param vaultId the ID of the vault to be liquidated\n    @param amount the amount of debt+liquidationFee to repay\n    @param dexIndex the index of dex in dex address provider mapping\n    @param dexTxData the tx data used to sell collateral back to PAR\n  **/\n  function liquidate(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 dexIndex,\n    bytes calldata dexTxData\n  ) public {\n    uint256 parBalanceBefore = _par.balanceOf(address(this));\n\n    IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);\n    IERC20 collateralToken = IERC20(vault.collateralType);\n    _a.parallel().core().liquidatePartial(vaultId, amount);\n\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));\n    router.call(dexTxData);\n    _par.safeTransfer(msg.sender, _liquidateCallerReward);\n    require(_par.balanceOf(address(this)) > parBalanceBefore, \"LM104\");\n    _refreshPAR(_totalStake);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function releaseRewards(address _user) public override {\n    UserInfo memory _userInfo = _users[_user];\n    _releaseRewards(_user, _userInfo, _totalStake, false);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n  }\n\n  /**\n    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake\n    @param _user the address of the user for which the PAR tokens will be restaked\n  */\n  function restakePAR(address _user) public {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    _refreshPAR(_totalStake);\n    uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    _increaseStake(_user, pendingPAR);\n  }\n\n  /**\n    Reapplies the boost of the user, useful a whale's vMIMO has decreased but their boost is still the original value\n  */\n  function updateBoost(address _user) public {\n    UserInfo memory userInfo = _users[_user];\n    _updateBoost(_user, userInfo);\n  }\n\n  /**\n    Returns the number of tokens a user has staked\n    @param _user the address of the user\n    @return number of staked tokens\n  */\n  function stake(address _user) public view override returns (uint256) {\n    return _users[_user].stake;\n  }\n\n  /**\n    Returns the number of tokens a user has staked with the boost\n    @param _user the address of the user\n    @return number of staked tokens with boost\n  */\n  function stakeWithBoost(address _user) public view override returns (uint256) {\n    return _users[_user].stakeWithBoost;\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @param _user the address of the user\n    @return number of MIMO tokens that the user can claim\n  */\n  function pendingMIMO(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @param _user the address of the user\n    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function pendingPAR(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);\n    uint256 reward = currentBalance.sub(_parBalanceTracker);\n    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n\n    return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n  }\n\n  function par() public view override returns (IERC20) {\n    return _par;\n  }\n\n  function a() public view override returns (IGovernanceAddressProvider) {\n    return _a;\n  }\n\n  function boostConfig() public view override returns (BoostConfig memory) {\n    return _boostConfig;\n  }\n\n  function totalStake() public view override returns (uint256) {\n    return _totalStake;\n  }\n\n  function totalStakeWithBoost() public view override returns (uint256) {\n    return _totalStakeWithBoost;\n  }\n\n  function liquidateCallerReward() public view returns (uint256) {\n    return _liquidateCallerReward;\n  }\n\n  /**\n    Returns the userInfo stored of a user\n    @param _user the address of the user\n    @return `struct UserInfo {\n      uint256 stake;\n      uint256 stakeWithBoost;\n      uint256 accAmountPerShare;\n      uint256 accParAmountPerShare;\n    }`\n  **/\n  function userInfo(address _user) public view override returns (UserInfo memory) {\n    return _users[_user];\n  }\n\n  /**\n    Refreshes the global state and subsequently increases a user's stake\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be increased\n  */\n  function _increaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n\n    UserInfo memory _userInfo = _users[_user];\n\n    uint256 newTotalStake = _totalStake.add(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, true);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.add(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    if (pendingPAR > 0) {\n      _userInfo.stake = _userInfo.stake.add(pendingPAR);\n      _totalStake = _totalStake.add(pendingPAR);\n    }\n\n    _updateBoost(_user, _userInfo);\n\n    emit StakeIncreased(_user, _value.add(pendingPAR));\n  }\n\n  /**\n    Refreshes the global state and subsequently decreases the stake a user has\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be reduced\n  */\n  function _decreaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n    UserInfo memory _userInfo = _users[_user];\n    require(_userInfo.stake >= _value, \"LM102\");\n\n    uint256 newTotalStake = _totalStake.sub(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, false);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.sub(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n\n    emit StakeDecreased(_user, _value);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function _releaseRewards(\n    address _user,\n    UserInfo memory _userInfo,\n    uint256 _newTotalStake,\n    bool _restakePAR\n  ) internal {\n    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n    _refresh();\n    _refreshPAR(_newTotalStake);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    if (_userInfo.stakeWithBoost > 0) {\n      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    }\n\n    if (pendingPAR > 0 && !_restakePAR) {\n      require(_par.transfer(_user, pendingPAR), \"LM100\");\n    }\n    if (pendingMIMO > 0) {\n      require(_a.mimo().transfer(_user, pendingMIMO), \"LM100\");\n    }\n  }\n\n  /**\n    Updates the internal state variables based on user's veMIMO hodlings\n    @param _user the address of the user\n   */\n  function _updateBoost(address _user, UserInfo memory _userInfo) internal {\n    // if user had a boost already, first remove it from the totalStakeWithBoost\n    if (_userInfo.stakeWithBoost > 0) {\n      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);\n    }\n    uint256 multiplier = _getBoostMultiplier(_user);\n    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);\n    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);\n    _users[_user] = _userInfo;\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received MIMO tokens\n  */\n  function _refresh() internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));\n    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);\n    _mimoBalanceTracker = currentMimoBalance;\n    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received PAR tokens\n    @dev need to pass updated stake as arg because reward token and stake token are the same\n    @param newTotalStake updated total stake in PAR tokens\n  */\n  function _refreshPAR(uint256 newTotalStake) internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);\n    uint256 parReward = currentParBalance.sub(_parBalanceTracker);\n\n    _parBalanceTracker = currentParBalance;\n    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @return number of MIMO tokens that the user can claim\n  */\n  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    uint256 currentBalance = _a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_mimoBalanceTracker);\n    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @return number of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function _pendingPAR(\n    uint256 accParAmountPerShare,\n    uint256 _userStakeWithBoost,\n    uint256 _userAccParAmountPerShare\n  ) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));\n  }\n\n  /**\n    Returns the boost multiplier the user is eligible for\n    @param _user the address of the user\n    @return the boost multuplie based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))\n   */\n  function _getBoostMultiplier(address _user) internal view returns (uint256) {\n    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);\n\n    if (veMIMO == 0) return 1e18;\n\n    // Convert boostConfig variables to signed 64.64-bit fixed point numbers\n    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);\n    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);\n    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);\n    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);\n    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);\n\n    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000\n    int128 e2 = e1.sub(e); // x/25000 - 6\n    int128 e3 = e2.neg(); // -(x/25000 - 6)\n    int128 e4 = e3.exp(); // e^-(x/25000 - 6)\n    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)\n    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))\n    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64\n    uint256 multiplier = uint256(e7); // convert to uint256\n\n    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, \"LM103\");\n\n    return multiplier;\n  }\n}\n\n\n",
        "CodeNames": [
            "PARMinerV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PARMinerV2.liquidate() function",
                "Type": "User can call liquidate() and steal all collateral due to arbitrary router call",
                "Description": "The attacker is able to steal all collateral from every unhealthy position that they liquidate.",
                "Repair": "Add a check that the _totalStake variable has not increased during the liquidation call"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../chainlink/AggregatorV3Interface.sol\";\nimport \"../interfaces/IGUniPool.sol\";\nimport \"../libraries/MathPow.sol\";\n\ncontract GUniLPOracle is AggregatorV3Interface {\n  using SafeMath for uint256;\n\n  string public override description;\n  uint256 public override version = 3;\n  uint8 public override decimals;\n\n  IGUniPool public immutable pool;\n  AggregatorV3Interface public immutable oracleA;\n  AggregatorV3Interface public immutable oracleB;\n\n  uint256 private immutable _tokenDecimalsUnitA;\n  uint256 private immutable _tokenDecimalsOffsetA;\n  uint256 private immutable _tokenDecimalsUnitB;\n  uint256 private immutable _tokenDecimalsOffsetB;\n\n  constructor(\n    uint8 _decimals,\n    string memory _description,\n    IGUniPool _pool,\n    AggregatorV3Interface _oracleA,\n    AggregatorV3Interface _oracleB\n  ) public {\n    require(address(_pool) != address(0), \"C000\");\n    require(address(_oracleA) != address(0), \"C000\");\n    require(address(_oracleB) != address(0), \"C000\");\n\n    decimals = _decimals;\n    description = _description;\n    pool = _pool;\n    oracleA = _oracleA;\n    oracleB = _oracleB;\n\n    uint256 decimalsA = ERC20(_pool.token0()).decimals();\n    _tokenDecimalsUnitA = 10**decimalsA;\n    _tokenDecimalsOffsetA = 10**(18 - decimalsA);\n\n    uint256 decimalsB = ERC20(_pool.token1()).decimals();\n    _tokenDecimalsUnitB = 10**decimalsB;\n    _tokenDecimalsOffsetB = 10**(18 - decimalsB);\n  }\n\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    // Skip the implementation since it is not used by price feed\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();\n    (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();\n    uint256 priceA = uint256(answerA);\n    uint256 priceB = uint256(answerB);\n    uint160 sqrtPriceX96 = uint160(\n      MathPow.sqrt((priceA.mul(_tokenDecimalsUnitB).mul(1 << 96)) / (priceB.mul(_tokenDecimalsUnitA))) << 48\n    );\n\n    (uint256 rA, uint256 rB) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);\n    require(rA > 0 || rB > 0, \"C100\");\n    uint256 totalSupply = pool.totalSupply();\n    require(totalSupply >= 1e9, \"C101\");\n\n    answer = int256(\n      priceA.mul(rA.mul(_tokenDecimalsOffsetA)).add(priceB.mul(rB.mul(_tokenDecimalsOffsetB))).div(totalSupply)\n    );\n    updatedAt = assetUpdatedAtA;\n\n    // use ealier time for updateAt\n    if (assetUpdatedAtA > assetUpdatedAtB) {\n      updatedAt = assetUpdatedAtB;\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "GUniLPOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GUniLPOracle.sol",
                "Type": "Decimal token underflow could produce loss of funds",
                "Description": "There is a decimal subtraction that could underflow if any token in the pool has more than 18 decimals.",
                "Repair": "Ensure that tokens have less than 18 decimals"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity 0.6.12;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have.\n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have.\n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt(int256 x) internal pure returns (int128) {\n    require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n    return int128(x << 64);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt(int128 x) internal pure returns (int64) {\n    return int64(x >> 64);\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt(uint256 x) internal pure returns (int128) {\n    require(x <= 0x7FFFFFFFFFFFFFFF);\n    return int128(x << 64);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt(int128 x) internal pure returns (uint64) {\n    require(x >= 0);\n    return uint64(x >> 64);\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128(int256 x) internal pure returns (int128) {\n    int256 result = x >> 64;\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128(int128 x) internal pure returns (int256) {\n    return int256(x) << 64;\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add(int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) + y;\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub(int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) - y;\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul(int128 x, int128 y) internal pure returns (int128) {\n    int256 result = (int256(x) * y) >> 64;\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli(int128 x, int256 y) internal pure returns (int256) {\n    if (x == MIN_64x64) {\n      require(\n        y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000\n      );\n      return -y << 63;\n    } else {\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x;\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint256 absoluteResult = mulu(x, uint256(y));\n      if (negativeResult) {\n        require(absoluteResult <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n        return -int256(absoluteResult); // We rely on overflow behavior here\n      } else {\n        require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int256(absoluteResult);\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu(int128 x, uint256 y) internal pure returns (uint256) {\n    if (y == 0) return 0;\n\n    require(x >= 0);\n\n    uint256 lo = (uint256(x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n    uint256 hi = uint256(x) * (y >> 128);\n\n    require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    hi <<= 64;\n\n    require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n    return hi + lo;\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div(int128 x, int128 y) internal pure returns (int128) {\n    require(y != 0);\n    int256 result = (int256(x) << 64) / y;\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi(int256 x, int256 y) internal pure returns (int128) {\n    require(y != 0);\n\n    bool negativeResult = false;\n    if (x < 0) {\n      x = -x; // We rely on overflow behavior here\n      negativeResult = true;\n    }\n    if (y < 0) {\n      y = -y; // We rely on overflow behavior here\n      negativeResult = !negativeResult;\n    }\n    uint128 absoluteResult = divuu(uint256(x), uint256(y));\n    if (negativeResult) {\n      require(absoluteResult <= 0x80000000000000000000000000000000);\n      return -int128(absoluteResult); // We rely on overflow behavior here\n    } else {\n      require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return int128(absoluteResult); // We rely on overflow behavior here\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu(uint256 x, uint256 y) internal pure returns (int128) {\n    require(y != 0);\n    uint128 result = divuu(x, y);\n    require(result <= uint128(MAX_64x64));\n    return int128(result);\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg(int128 x) internal pure returns (int128) {\n    require(x != MIN_64x64);\n    return -x;\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs(int128 x) internal pure returns (int128) {\n    require(x != MIN_64x64);\n    return x < 0 ? -x : x;\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv(int128 x) internal pure returns (int128) {\n    require(x != 0);\n    int256 result = int256(0x100000000000000000000000000000000) / x;\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg(int128 x, int128 y) internal pure returns (int128) {\n    return int128((int256(x) + int256(y)) >> 1);\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg(int128 x, int128 y) internal pure returns (int128) {\n    int256 m = int256(x) * int256(y);\n    require(m >= 0);\n    require(m < 0x4000000000000000000000000000000000000000000000000000000000000000);\n    return int128(sqrtu(uint256(m)));\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow(int128 x, uint256 y) internal pure returns (int128) {\n    bool negative = x < 0 && y & 1 == 1;\n\n    uint256 absX = uint128(x < 0 ? -x : x);\n    uint256 absResult;\n    absResult = 0x100000000000000000000000000000000;\n\n    if (absX <= 0x10000000000000000) {\n      absX <<= 63;\n      while (y != 0) {\n        if (y & 0x1 != 0) {\n          absResult = (absResult * absX) >> 127;\n        }\n        absX = (absX * absX) >> 127;\n\n        if (y & 0x2 != 0) {\n          absResult = (absResult * absX) >> 127;\n        }\n        absX = (absX * absX) >> 127;\n\n        if (y & 0x4 != 0) {\n          absResult = (absResult * absX) >> 127;\n        }\n        absX = (absX * absX) >> 127;\n\n        if (y & 0x8 != 0) {\n          absResult = (absResult * absX) >> 127;\n        }\n        absX = (absX * absX) >> 127;\n\n        y >>= 4;\n      }\n\n      absResult >>= 64;\n    } else {\n      uint256 absXShift = 63;\n      if (absX < 0x1000000000000000000000000) {\n        absX <<= 32;\n        absXShift -= 32;\n      }\n      if (absX < 0x10000000000000000000000000000) {\n        absX <<= 16;\n        absXShift -= 16;\n      }\n      if (absX < 0x1000000000000000000000000000000) {\n        absX <<= 8;\n        absXShift -= 8;\n      }\n      if (absX < 0x10000000000000000000000000000000) {\n        absX <<= 4;\n        absXShift -= 4;\n      }\n      if (absX < 0x40000000000000000000000000000000) {\n        absX <<= 2;\n        absXShift -= 2;\n      }\n      if (absX < 0x80000000000000000000000000000000) {\n        absX <<= 1;\n        absXShift -= 1;\n      }\n\n      uint256 resultShift = 0;\n      while (y != 0) {\n        require(absXShift < 64);\n\n        if (y & 0x1 != 0) {\n          absResult = (absResult * absX) >> 127;\n          resultShift += absXShift;\n          if (absResult > 0x100000000000000000000000000000000) {\n            absResult >>= 1;\n            resultShift += 1;\n          }\n        }\n        absX = (absX * absX) >> 127;\n        absXShift <<= 1;\n        if (absX >= 0x100000000000000000000000000000000) {\n          absX >>= 1;\n          absXShift += 1;\n        }\n\n        y >>= 1;\n      }\n\n      require(resultShift < 64);\n      absResult >>= 64 - resultShift;\n    }\n    int256 result = negative ? -int256(absResult) : int256(absResult);\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt(int128 x) internal pure returns (int128) {\n    require(x >= 0);\n    return int128(sqrtu(uint256(x) << 64));\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2(int128 x) internal pure returns (int128) {\n    require(x > 0);\n\n    int256 msb = 0;\n    int256 xc = x;\n    if (xc >= 0x10000000000000000) {\n      xc >>= 64;\n      msb += 64;\n    }\n    if (xc >= 0x100000000) {\n      xc >>= 32;\n      msb += 32;\n    }\n    if (xc >= 0x10000) {\n      xc >>= 16;\n      msb += 16;\n    }\n    if (xc >= 0x100) {\n      xc >>= 8;\n      msb += 8;\n    }\n    if (xc >= 0x10) {\n      xc >>= 4;\n      msb += 4;\n    }\n    if (xc >= 0x4) {\n      xc >>= 2;\n      msb += 2;\n    }\n    if (xc >= 0x2) msb += 1; // No need to shift xc anymore\n\n    int256 result = (msb - 64) << 64;\n    uint256 ux = uint256(x) << uint256(127 - msb);\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n      ux *= ux;\n      uint256 b = ux >> 255;\n      ux >>= 127 + b;\n      result += bit * int256(b);\n    }\n\n    return int128(result);\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln(int128 x) internal pure returns (int128) {\n    require(x > 0);\n\n    return int128((uint256(log_2(x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128);\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2(int128 x) internal pure returns (int128) {\n    require(x < 0x400000000000000000); // Overflow\n\n    if (x < -0x400000000000000000) return 0; // Underflow\n\n    uint256 result = 0x80000000000000000000000000000000;\n\n    if (x & 0x8000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\n    if (x & 0x4000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\n    if (x & 0x2000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\n    if (x & 0x1000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\n    if (x & 0x800000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\n    if (x & 0x400000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\n    if (x & 0x200000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\n    if (x & 0x100000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\n    if (x & 0x80000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\n    if (x & 0x40000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\n    if (x & 0x20000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\n    if (x & 0x10000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\n    if (x & 0x8000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\n    if (x & 0x4000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\n    if (x & 0x2000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\n    if (x & 0x1000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\n    if (x & 0x800000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\n    if (x & 0x400000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\n    if (x & 0x200000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\n    if (x & 0x100000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\n    if (x & 0x80000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\n    if (x & 0x40000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\n    if (x & 0x20000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\n    if (x & 0x10000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\n    if (x & 0x8000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\n    if (x & 0x4000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\n    if (x & 0x2000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\n    if (x & 0x1000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\n    if (x & 0x800000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\n    if (x & 0x400000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\n    if (x & 0x200000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\n    if (x & 0x100000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\n    if (x & 0x80000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\n    if (x & 0x40000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\n    if (x & 0x20000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\n    if (x & 0x10000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\n    if (x & 0x8000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\n    if (x & 0x4000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\n    if (x & 0x2000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\n    if (x & 0x1000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\n    if (x & 0x800000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\n    if (x & 0x400000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\n    if (x & 0x200000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\n    if (x & 0x100000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\n    if (x & 0x80000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\n    if (x & 0x40000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\n    if (x & 0x20000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\n    if (x & 0x10000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\n    if (x & 0x8000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\n    if (x & 0x4000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\n    if (x & 0x2000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\n    if (x & 0x1000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\n    if (x & 0x800 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\n    if (x & 0x400 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\n    if (x & 0x200 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\n    if (x & 0x100 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\n    if (x & 0x80 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\n    if (x & 0x40 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\n    if (x & 0x20 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\n    if (x & 0x10 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\n    if (x & 0x8 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\n    if (x & 0x4 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\n    if (x & 0x2 > 0) result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\n    if (x & 0x1 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\n\n    result >>= uint256(63 - (x >> 64));\n    require(result <= uint256(MAX_64x64));\n\n    return int128(result);\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp(int128 x) internal pure returns (int128) {\n    require(x < 0x400000000000000000); // Overflow\n\n    if (x < -0x400000000000000000) return 0; // Underflow\n\n    return exp_2(int128((int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128));\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu(uint256 x, uint256 y) private pure returns (uint128) {\n    require(y != 0);\n\n    uint256 result;\n\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) result = (x << 64) / y;\n    else {\n      uint256 msb = 192;\n      uint256 xc = x >> 192;\n      if (xc >= 0x100000000) {\n        xc >>= 32;\n        msb += 32;\n      }\n      if (xc >= 0x10000) {\n        xc >>= 16;\n        msb += 16;\n      }\n      if (xc >= 0x100) {\n        xc >>= 8;\n        msb += 8;\n      }\n      if (xc >= 0x10) {\n        xc >>= 4;\n        msb += 4;\n      }\n      if (xc >= 0x4) {\n        xc >>= 2;\n        msb += 2;\n      }\n      if (xc >= 0x2) msb += 1; // No need to shift xc anymore\n\n      result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\n      require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n      uint256 hi = result * (y >> 128);\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n      uint256 xh = x >> 192;\n      uint256 xl = x << 64;\n\n      if (xl < lo) xh -= 1;\n      xl -= lo; // We rely on overflow behavior here\n      lo = hi << 128;\n      if (xl < lo) xh -= 1;\n      xl -= lo; // We rely on overflow behavior here\n\n      assert(xh == hi >> 128);\n\n      result += xl / y;\n    }\n\n    require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    return uint128(result);\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu(uint256 x) private pure returns (uint128) {\n    if (x == 0) return 0;\n    else {\n      uint256 xx = x;\n      uint256 r = 1;\n      if (xx >= 0x100000000000000000000000000000000) {\n        xx >>= 128;\n        r <<= 64;\n      }\n      if (xx >= 0x10000000000000000) {\n        xx >>= 64;\n        r <<= 32;\n      }\n      if (xx >= 0x100000000) {\n        xx >>= 32;\n        r <<= 16;\n      }\n      if (xx >= 0x10000) {\n        xx >>= 16;\n        r <<= 8;\n      }\n      if (xx >= 0x100) {\n        xx >>= 8;\n        r <<= 4;\n      }\n      if (xx >= 0x10) {\n        xx >>= 4;\n        r <<= 2;\n      }\n      if (xx >= 0x8) {\n        r <<= 1;\n      }\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1; // Seven iterations should be enough\n      uint256 r1 = x / r;\n      return uint128(r < r1 ? r : r1);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "ABDKMath64x64.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ABDKMath64x64.sol",
                "Type": "ABDKMath64 performs multiplication on results of division",
                "Description": "Solidity could truncate the results, performing multiplication before division will prevent rounding/truncation in solidity math.",
                "Repair": "Consider ordering multiplication first"
            }
        ]
    }
]