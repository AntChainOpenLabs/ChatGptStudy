[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "@timeswap-labs/timeswap-v1-core package",
                "Type": "NPM Dependency confusion",
                "Description": "An unclaimed npm package and scope can allow an attacker to upload malicious code under that unclaimed package and achieve remote code execution on developers/users' machine who depends on the timeswap repository to build it on local env.",
                "Repair": "Claim the Scope name called \"timeswap-labs\" on NPM Registry"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from './interfaces/IPair.sol';\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {TimeswapMath} from './libraries/TimeswapMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Array} from './libraries/Array.sol';\nimport {Callback} from './libraries/Callback.sol';\nimport {BlockNumber} from './libraries/BlockNumber.sol';\n\n/// @title Timeswap Pair\n/// @author Timeswap Labs\n/// @notice It is recommended to use Timeswap Convenience to interact with this contract.\n/// @notice All error messages are coded and can be found in the documentation.\ncontract TimeswapPair is IPair {\n    using SafeERC20 for IERC20;\n    using Array for Due[];\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IPair\n    IFactory public immutable override factory;\n    /// @inheritdoc IPair\n    IERC20 public immutable override asset;\n    /// @inheritdoc IPair\n    IERC20 public immutable override collateral;\n    /// @inheritdoc IPair\n    uint16 public immutable override fee;\n    /// @inheritdoc IPair\n    uint16 public immutable override protocolFee;\n\n    /// @inheritdoc IPair\n    uint256 public override protocolFeeStored;\n\n    /// @dev Stores the individual states of each Pool.\n    mapping(uint256 => Pool) private pools;\n\n    /// @dev Stores the access state for reentrancy guard.\n    uint256 private locked = 1;\n\n    /* ===== VIEW =====*/\n\n    /// @inheritdoc IPair\n    function feeStored(uint256 maturity)\n        external\n        view\n        override\n        returns (uint256) \n    {\n        return pools[maturity].state.feeStored;\n    }\n\n    /// @inheritdoc IPair\n    function constantProduct(uint256 maturity)\n        external\n        view\n        override\n        returns (uint112, uint112, uint112)\n    {\n        State storage state = pools[maturity].state;\n        return (state.x, state.y, state.z);\n    }\n\n    /// @inheritdoc IPair\n    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {\n        return pools[maturity].state.reserves;\n    }\n\n    /// @inheritdoc IPair\n    function totalLiquidity(uint256 maturity) external view override returns (uint256) {\n        return pools[maturity].state.totalLiquidity;\n    }\n\n    /// @inheritdoc IPair\n    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].liquidities[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalClaims(uint256 maturity) external view override returns (Claims memory) {\n        return pools[maturity].state.totalClaims;\n    }\n\n    /// @inheritdoc IPair\n    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {\n        return pools[maturity].claims[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {\n        return pools[maturity].state.totalDebtCreated;\n    }\n\n    /// @inheritdoc IPair\n    function totalDuesOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].dues[owner].length;\n    }\n\n    /// @inheritdoc IPair\n    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {\n        return pools[maturity].dues[owner][id];\n    }\n\n    /* ===== INIT ===== */\n\n    /// @dev Initializes the Pair contract.\n    /// @dev Called by the Timeswap factory contract.\n    /// @param _asset The address of the ERC20 being lent and borrowed.\n    /// @param _collateral The address of the ERC20 as the collateral.\n    /// @param _fee The chosen fee rate.\n    /// @param _protocolFee The chosen protocol fee rate.\n    constructor(\n        IERC20 _asset,\n        IERC20 _collateral,\n        uint16 _fee,\n        uint16 _protocolFee\n    ) {\n        factory = IFactory(msg.sender);\n        asset = _asset;\n        collateral = _collateral;\n        fee = _fee;\n        protocolFee = _protocolFee;\n    }\n\n    /* ===== MODIFIER ===== */\n\n    /// @dev The modifier for reentrancy guard.\n    modifier lock() {\n        require(locked == 1, 'E211');\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc IPair\n    function mint(MintParam calldata param)\n        external\n        override\n        lock\n        returns (\n            uint256 assetIn,\n            uint256 liquidityOut,\n            uint256 id,\n            Due memory dueOut\n        )\n    {   \n        require(block.timestamp < param.maturity, 'E202');\n        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); }\n        require(param.liquidityTo != address(0), 'E201');\n        require(param.dueTo != address(0), 'E201');\n        require(param.liquidityTo != address(this), 'E204');\n        require(param.dueTo != address(this), 'E204');\n        require(param.xIncrease != 0, 'E205');\n        require(param.yIncrease != 0, 'E205');\n        require(param.zIncrease != 0, 'E205');\n        \n        Pool storage pool = pools[param.maturity];\n\n        uint256 feeStoredIncrease;\n        (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(\n            param.maturity,\n            pool.state,\n            param.xIncrease,\n            param.yIncrease,\n            param.zIncrease\n        );\n\n        require(liquidityOut != 0, 'E212');\n        pool.state.totalLiquidity += liquidityOut;\n        pool.liquidities[param.liquidityTo] += liquidityOut;\n\n        pool.state.feeStored += feeStoredIncrease;\n\n\n        id = pool.dues[param.dueTo].insert(dueOut);\n\n        pool.state.reserves.asset += param.xIncrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x += param.xIncrease;\n        pool.state.y += param.yIncrease;\n        pool.state.z += param.zIncrease;\n\n        assetIn = param.xIncrease;\n        assetIn += feeStoredIncrease;\n        Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Mint(\n            param.maturity, \n            msg.sender, \n            param.liquidityTo, \n            param.dueTo, \n            assetIn, \n            liquidityOut, \n            id, \n            dueOut,\n            feeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function burn(BurnParam calldata param) \n        external \n        override \n        lock \n        returns (\n            uint256 assetOut, \n            uint128 collateralOut\n        ) \n    {\n        require(block.timestamp >= param.maturity, 'E203');\n        require(param.assetTo != address(0), 'E201');\n        require(param.collateralTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.collateralTo != address(this), 'E204');\n        require(param.liquidityIn != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity > 0, 'E206');\n\n        uint128 _assetOut;\n        uint256 feeOut;\n        (_assetOut, collateralOut, feeOut) = TimeswapMath.burn(\n            pool.state,\n            param.liquidityIn\n        );\n\n        pool.state.totalLiquidity -= param.liquidityIn;\n\n        pool.liquidities[msg.sender] -= param.liquidityIn;\n\n        assetOut = _assetOut;\n        assetOut += feeOut;\n\n        if (assetOut != 0) {\n            pool.state.reserves.asset -= _assetOut;\n            pool.state.feeStored -= feeOut;\n            asset.safeTransfer(param.assetTo, assetOut);\n        }\n        if (collateralOut != 0) {\n            pool.state.reserves.collateral -= collateralOut;\n            collateral.safeTransfer(param.collateralTo, collateralOut);\n        }\n\n        emit Burn(\n            param.maturity,\n            msg.sender, \n            param.assetTo, \n            param.collateralTo, \n            param.liquidityIn, \n            assetOut, \n            collateralOut,\n            feeOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function lend(LendParam calldata param) \n        external \n        override \n        lock \n        returns (\n            uint256 assetIn,\n            Claims memory claimsOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.bondTo != address(0), 'E201');\n        require(param.insuranceTo != address(0), 'E201');\n        require(param.bondTo != address(this), 'E204');\n        require(param.insuranceTo != address(this), 'E204');\n        require(param.xIncrease != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity != 0, 'E206');\n\n        uint256 feeStoredIncrease;\n        uint256 protocolFeeStoredIncrease;\n        (claimsOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.lend(\n            param.maturity,\n            pool.state,\n            param.xIncrease,\n            param.yDecrease,\n            param.zDecrease,\n            fee,\n            protocolFee\n        );\n\n        pool.state.feeStored += feeStoredIncrease;\n        protocolFeeStored += protocolFeeStoredIncrease;\n\n        pool.state.totalClaims.bondPrincipal += claimsOut.bondPrincipal;\n        pool.state.totalClaims.bondInterest += claimsOut.bondInterest;\n        pool.state.totalClaims.insurancePrincipal += claimsOut.insurancePrincipal;\n        pool.state.totalClaims.insuranceInterest += claimsOut.insuranceInterest;\n\n        pool.claims[param.bondTo].bondPrincipal += claimsOut.bondPrincipal;\n        pool.claims[param.bondTo].bondInterest += claimsOut.bondInterest;\n        pool.claims[param.insuranceTo].insurancePrincipal += claimsOut.insurancePrincipal;\n        pool.claims[param.insuranceTo].insuranceInterest += claimsOut.insuranceInterest;\n\n        pool.state.reserves.asset += param.xIncrease;\n\n        pool.state.x += param.xIncrease;\n        pool.state.y -= param.yDecrease;\n        pool.state.z -= param.zDecrease;\n\n        assetIn = param.xIncrease;\n        assetIn += feeStoredIncrease;\n        assetIn += protocolFeeStoredIncrease;\n\n        Callback.lend(asset, assetIn, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Lend(\n            param.maturity,\n            msg.sender, \n            param.bondTo, \n            param.insuranceTo, \n            assetIn, \n            claimsOut,\n            feeStoredIncrease,\n            protocolFeeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function withdraw(WithdrawParam calldata param)\n        external \n        override \n        lock \n        returns (\n            Tokens memory tokensOut\n        ) \n    {\n        require(block.timestamp >= param.maturity, 'E203');\n        require(param.assetTo != address(0), 'E201');\n        require(param.collateralTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.collateralTo != address(this), 'E204');\n        require(\n            param.claimsIn.bondPrincipal != 0 || \n            param.claimsIn.bondInterest != 0 ||\n            param.claimsIn.insurancePrincipal != 0 ||\n            param.claimsIn.insuranceInterest != 0, \n            'E205'\n        );\n\n        Pool storage pool = pools[param.maturity];\n\n        tokensOut = TimeswapMath.withdraw(pool.state, param.claimsIn);\n\n        pool.state.totalClaims.bondPrincipal -= param.claimsIn.bondPrincipal;\n        pool.state.totalClaims.bondInterest -= param.claimsIn.bondInterest;\n        pool.state.totalClaims.insurancePrincipal -= param.claimsIn.insurancePrincipal;\n        pool.state.totalClaims.insuranceInterest -= param.claimsIn.insuranceInterest;\n\n        Claims storage sender = pool.claims[msg.sender];\n\n        sender.bondPrincipal -= param.claimsIn.bondPrincipal;\n        sender.bondInterest -= param.claimsIn.bondInterest;\n        sender.insurancePrincipal -= param.claimsIn.insurancePrincipal;\n        sender.insuranceInterest -= param.claimsIn.insuranceInterest;\n\n        if (tokensOut.asset != 0) {\n            pool.state.reserves.asset -= tokensOut.asset;\n            asset.safeTransfer(param.assetTo, tokensOut.asset);\n        }\n        if (tokensOut.collateral != 0) {\n            pool.state.reserves.collateral -= tokensOut.collateral;\n            collateral.safeTransfer(param.collateralTo, tokensOut.collateral);\n        }\n\n        emit Withdraw(\n            param.maturity,\n            msg.sender, \n            param.assetTo, \n            param.collateralTo, \n            param.claimsIn, \n            tokensOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function borrow(BorrowParam calldata param)\n        external \n        override \n        lock \n        returns (\n            uint256 assetOut,\n            uint256 id, \n            Due memory dueOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.assetTo != address(0), 'E201');\n        require(param.dueTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.dueTo != address(this), 'E204');\n        require(param.xDecrease != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity != 0, 'E206');\n\n        uint256 feeStoredIncrease;\n        uint256 protocolFeeStoredIncrease;\n        (dueOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.borrow(\n            param.maturity,\n            pool.state,\n            param.xDecrease,\n            param.yIncrease,\n            param.zIncrease,\n            fee,\n            protocolFee\n        );\n\n        pool.state.feeStored += feeStoredIncrease;\n        protocolFeeStored += protocolFeeStoredIncrease;\n\n        id = pool.dues[param.dueTo].insert(dueOut);\n\n        pool.state.reserves.asset -= param.xDecrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x -= param.xDecrease;\n        pool.state.y += param.yIncrease;\n        pool.state.z += param.zIncrease;\n\n        assetOut = param.xDecrease;\n        assetOut -= feeStoredIncrease;\n        assetOut -= protocolFeeStoredIncrease;\n\n        asset.safeTransfer(param.assetTo, assetOut);\n\n        Callback.borrow(collateral, dueOut.collateral, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Borrow(\n            param.maturity, \n            msg.sender, \n            param.assetTo, \n            param.dueTo, \n            assetOut, \n            id, \n            dueOut,\n            feeStoredIncrease,\n            protocolFeeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function pay(PayParam calldata param)\n        external \n        override \n        lock \n        returns (\n            uint128 assetIn, \n            uint128 collateralOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.owner != address(0), 'E201');\n        require(param.to != address(0), 'E201');\n        require(param.to != address(this), 'E204');\n        require(param.ids.length == param.assetsIn.length, 'E205');\n        require(param.ids.length == param.collateralsOut.length, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n\n        Due[] storage dues = pool.dues[param.owner];\n        require(dues.length >= param.ids.length, 'E205');\n\n        for (uint256 i; i < param.ids.length;) {\n            Due storage due = dues[param.ids[i]];\n            require(due.startBlock != BlockNumber.get(), 'E207');\n            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');\n            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');\n            due.debt -= param.assetsIn[i];\n            due.collateral -= param.collateralsOut[i];\n            assetIn += param.assetsIn[i];\n            collateralOut += param.collateralsOut[i];\n            unchecked { ++i; }\n        }\n\n        pool.state.reserves.asset += assetIn;\n        pool.state.reserves.collateral -= collateralOut;\n\n        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);\n\n        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);\n\n        emit Pay(\n            param.maturity, \n            msg.sender, \n            param.to, \n            param.owner, \n            param.ids, \n            param.assetsIn, \n            param.collateralsOut, \n            assetIn, \n            collateralOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function collectProtocolFee(address to) external override lock returns (uint256 protocolFeeOut) {\n        require(msg.sender == factory.owner(), 'E216');\n\n        protocolFeeOut = protocolFeeStored;\n        protocolFeeStored = 0;\n\n        asset.safeTransfer(to, protocolFeeOut);\n\n        emit CollectProtocolFee(msg.sender, to, protocolFeeOut);\n    }\n}\n\n\n",
        "CodeNames": [
            "TimeswapPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "pay() function in TimeswapPair.sol",
                "Type": "Denial of Service (DoS)",
                "Description": "An attacker can keep doing it every time the user is going to pay and since 1 token is basically 0$, the attacker doesn't lose real money.",
                "Repair": "Move the DOS protection to TimeswapPair.pay()"
            },
            {
                "Location": "pay() function in TimeswapPair.sol",
                "Type": "Incorrect timing of check",
                "Description": "An attacker can steal USDC by calling pay() with 0 USDC as assetsIn and 1 BTC as collateralsOut.",
                "Repair": "Check assetIn and collateralOut properly during the first iteration of the for loop"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IConvenience} from '../interfaces/IConvenience.sol';\nimport {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';\nimport {IWETH} from '../interfaces/IWETH.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IBorrow} from '../interfaces/IBorrow.sol';\nimport {BorrowMath} from './BorrowMath.sol';\nimport {Deploy} from './Deploy.sol';\nimport {MsgValue} from './MsgValue.sol';\nimport {ETH} from './ETH.sol';\n\nlibrary Borrow {\n    using BorrowMath for IPair;\n    using Deploy for IConvenience.Native;\n\n    function borrowGivenDebt(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IBorrow.BorrowGivenDebt calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (assetOut, id, dueOut) = _borrowGivenDebt(\n            natives,\n            IBorrow._BorrowGivenDebt(\n                convenience,\n                factory,\n                params.asset,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                params.assetTo,\n                params.dueTo,\n                params.assetOut,\n                params.debtIn,\n                params.maxCollateral,\n                params.deadline\n            )\n        );\n    }\n\n    function borrowGivenDebtETHAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IBorrow.BorrowGivenDebtETHAsset calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (assetOut, id, dueOut) = _borrowGivenDebt(\n            natives,\n            IBorrow._BorrowGivenDebt(\n                convenience,\n                factory,\n                weth,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                address(this),\n                params.dueTo,\n                params.assetOut,\n                params.debtIn,\n                params.maxCollateral,\n                params.deadline\n            )\n        );\n\n        weth.withdraw(params.assetOut);\n        ETH.transfer(params.assetTo, params.assetOut);\n    }\n\n    function borrowGivenDebtETHCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IBorrow.BorrowGivenDebtETHCollateral calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 maxCollateral = MsgValue.getUint112();\n\n        (assetOut, id, dueOut) = _borrowGivenDebt(\n            natives,\n            IBorrow._BorrowGivenDebt(\n                convenience,\n                factory,\n                params.asset,\n                weth,\n                params.maturity,\n                address(this),\n                params.assetTo,\n                params.dueTo,\n                params.assetOut,\n                params.debtIn,\n                maxCollateral,\n                params.deadline\n            )\n        );\n\n        if (maxCollateral > dueOut.collateral) {\n            uint256 excess;\n            unchecked {\n                excess -= dueOut.collateral;\n            }\n            ETH.transfer(payable(msg.sender), excess);\n        }\n    }\n\n    function borrowGivenCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IBorrow.BorrowGivenCollateral calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (assetOut, id, dueOut) = _borrowGivenCollateral(\n            natives,\n            IBorrow._BorrowGivenCollateral(\n                convenience,\n                factory,\n                params.asset,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                params.assetTo,\n                params.dueTo,\n                params.assetOut,\n                params.collateralIn,\n                params.maxDebt,\n                params.deadline\n            )\n        );\n    }\n\n    function borrowGivenCollateralETHAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IBorrow.BorrowGivenCollateralETHAsset calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (assetOut, id, dueOut) = _borrowGivenCollateral(\n            natives,\n            IBorrow._BorrowGivenCollateral(\n                convenience,\n                factory,\n                weth,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                address(this),\n                params.dueTo,\n                params.assetOut,\n                params.collateralIn,\n                params.maxDebt,\n                params.deadline\n            )\n        );\n\n        weth.withdraw(assetOut);\n        ETH.transfer(payable(params.assetTo), assetOut);\n    }\n\n    function borrowGivenCollateralETHCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IBorrow.BorrowGivenCollateralETHCollateral calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 collateralIn = MsgValue.getUint112();\n\n        (assetOut, id, dueOut) = _borrowGivenCollateral(\n            natives,\n            IBorrow._BorrowGivenCollateral(\n                convenience,\n                factory,\n                params.asset,\n                weth,\n                params.maturity,\n                address(this),\n                params.assetTo,\n                params.dueTo,\n                params.assetOut,\n                collateralIn,\n                params.maxDebt,\n                params.deadline\n            )\n        );\n\n        if (collateralIn > dueOut.collateral) {\n            uint256 excess = collateralIn;\n            unchecked {\n                excess -= dueOut.collateral;\n            }\n            ETH.transfer(payable(msg.sender), excess);\n        }\n    }\n\n    function borrowGivenPercent(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IBorrow.BorrowGivenPercent calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (assetOut, id, dueOut) = _borrowGivenPercent(\n            natives,\n            IBorrow._BorrowGivenPercent(\n                convenience,\n                factory,\n                params.asset,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                params.assetTo,\n                params.dueTo,\n                params.assetOut,\n                params.percent,\n                params.maxDebt,\n                params.maxCollateral,\n                params.deadline\n            )\n        );\n    }\n\n    function borrowGivenPercentETHAsset(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IBorrow.BorrowGivenPercentETHAsset calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        (assetOut, id, dueOut) = _borrowGivenPercent(\n            natives,\n            IBorrow._BorrowGivenPercent(\n                convenience,\n                factory,\n                weth,\n                params.collateral,\n                params.maturity,\n                msg.sender,\n                address(this),\n                params.dueTo,\n                params.assetOut,\n                params.percent,\n                params.maxDebt,\n                params.maxCollateral,\n                params.deadline\n            )\n        );\n\n        weth.withdraw(assetOut);\n        ETH.transfer(params.assetTo, assetOut);\n    }\n\n    function borrowGivenPercentETHCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IConvenience convenience,\n        IFactory factory,\n        IWETH weth,\n        IBorrow.BorrowGivenPercentETHCollateral calldata params\n    )\n        external\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        uint112 maxCollateral = MsgValue.getUint112();\n\n        (assetOut, id, dueOut) = _borrowGivenPercent(\n            natives,\n            IBorrow._BorrowGivenPercent(\n                convenience,\n                factory,\n                params.asset,\n                weth,\n                params.maturity,\n                address(this),\n                params.assetTo,\n                params.dueTo,\n                params.assetOut,\n                params.percent,\n                params.maxDebt,\n                maxCollateral,\n                params.deadline\n            )\n        );\n\n        if (maxCollateral > dueOut.collateral) {\n            uint256 excess = maxCollateral;\n            unchecked {\n                excess -= dueOut.collateral;\n            }\n            ETH.transfer(payable(msg.sender), excess);\n        }\n    }\n\n    function _borrowGivenDebt(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IBorrow._BorrowGivenDebt memory params\n    )\n        private\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        require(params.debtIn > params.assetOut, 'E518');\n\n        IPair pair = params.factory.getPair(params.asset, params.collateral);\n        require(address(pair) != address(0), 'E501');\n\n        (uint112 xDecrease, uint112 yIncrease, uint112 zIncrease) = pair.givenDebt(\n            params.maturity,\n            params.assetOut,\n            params.debtIn\n        );\n\n        (assetOut, id, dueOut) = _borrow(\n            natives,\n            IBorrow._Borrow(\n                params.convenience,\n                pair,\n                params.asset,\n                params.collateral,\n                params.maturity,\n                params.from,\n                params.assetTo,\n                params.dueTo,\n                xDecrease,\n                yIncrease,\n                zIncrease,\n                params.deadline\n            )\n        );\n\n        require(dueOut.collateral <= params.maxCollateral, 'E513');\n    }\n\n    function _borrowGivenCollateral(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IBorrow._BorrowGivenCollateral memory params\n    )\n        private\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        IPair pair = params.factory.getPair(params.asset, params.collateral);\n        require(address(pair) != address(0), 'E501');\n\n        (uint112 xDecrease, uint112 yIncrease, uint112 zIncrease) = pair.givenCollateral(\n            params.maturity,\n            params.assetOut,\n            params.collateralIn\n        );\n\n        (assetOut, id, dueOut) = _borrow(\n            natives,\n            IBorrow._Borrow(\n                params.convenience,\n                pair,\n                params.asset,\n                params.collateral,\n                params.maturity,\n                params.from,\n                params.assetTo,\n                params.dueTo,\n                xDecrease,\n                yIncrease,\n                zIncrease,\n                params.deadline\n            )\n        );\n\n        require(dueOut.debt <= params.maxDebt, 'E512');\n    }\n\n    function _borrowGivenPercent(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IBorrow._BorrowGivenPercent memory params\n    )\n        private\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        require(params.percent <= 0x100000000, 'E505');\n\n        IPair pair = params.factory.getPair(params.asset, params.collateral);\n        require(address(pair) != address(0), 'E501');\n\n        (uint112 xDecrease, uint112 yIncrease, uint112 zIncrease) = pair.givenPercent(\n            params.maturity,\n            params.assetOut,\n            params.percent\n        );\n\n        (assetOut, id, dueOut) = _borrow(\n            natives,\n            IBorrow._Borrow(\n                params.convenience,\n                pair,\n                params.asset,\n                params.collateral,\n                params.maturity,\n                params.from,\n                params.assetTo,\n                params.dueTo,\n                xDecrease,\n                yIncrease,\n                zIncrease,\n                params.deadline\n            )\n        );\n\n\n        require(dueOut.debt <= params.maxDebt, 'E512');\n        require(dueOut.collateral <= params.maxCollateral, 'E513');\n    }\n\n    function _borrow(\n        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,\n        IBorrow._Borrow memory params\n    )\n        private\n        returns (\n            uint256 assetOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {\n        require(params.deadline >= block.timestamp, 'E504');\n        require(params.maturity > block.timestamp, 'E508');\n\n        IConvenience.Native storage native = natives[params.asset][params.collateral][params.maturity];\n        if (address(native.liquidity) == address(0))\n            native.deploy(params.convenience, params.pair, params.asset, params.collateral, params.maturity);\n\n        (assetOut, id, dueOut) = params.pair.borrow(\n            IPair.BorrowParam(\n                params.maturity,\n                params.assetTo,\n                address(this),\n                params.xDecrease,\n                params.yIncrease,\n                params.zIncrease,\n                bytes(abi.encode(params.asset, params.collateral, params.from))\n            )\n        );\n\n        native.collateralizedDebt.mint(params.dueTo, id);\n    }\n}\n\n\n",
        "CodeNames": [
            "Borrow.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "borrowGivenDebtETHCollateral function in Borrow.sol",
                "Type": "Underflown variable",
                "Description": "The borrowGivenDebtETHCollateral function does not properly call ETH.transfer due to underflow, which can cause unexpected behaviors for users.",
                "Repair": "Initialize the excess variable with maxCollateral"
            }
        ]
    }
]