[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IExecutionDelegate} from \"./interfaces/IExecutionDelegate.sol\";\n\n/**\n * @title ExecutionDelegate\n * @dev Proxy contract to manage user token approvals\n */\ncontract ExecutionDelegate is IExecutionDelegate, Ownable {\n\n    mapping(address => bool) public contracts;\n    mapping(address => bool) public revokedApproval;\n\n    modifier approvedContract() {\n        require(contracts[msg.sender], \"Contract is not approved to make transfers\");\n        _;\n    }\n\n    event ApproveContract(address indexed _contract);\n    event DenyContract(address indexed _contract);\n\n    event RevokeApproval(address indexed user);\n    event GrantApproval(address indexed user);\n\n    /**\n     * @dev Approve contract to call transfer functions\n     * @param _contract address of contract to approve\n     */\n    function approveContract(address _contract) onlyOwner external {\n        contracts[_contract] = true;\n        emit ApproveContract(_contract);\n    }\n\n    /**\n     * @dev Revoke approval of contract to call transfer functions\n     * @param _contract address of contract to revoke approval\n     */\n    function denyContract(address _contract) onlyOwner external {\n        contracts[_contract] = false;\n        emit DenyContract(_contract);\n    }\n\n    /**\n     * @dev Block contract from making transfers on-behalf of a specific user\n     */\n    function revokeApproval() external {\n        revokedApproval[msg.sender] = true;\n        emit RevokeApproval(msg.sender);\n    }\n\n    /**\n     * @dev Allow contract to make transfers on-behalf of a specific user\n     */\n    function grantApproval() external {\n        revokedApproval[msg.sender] = false;\n        emit GrantApproval(msg.sender);\n    }\n\n    /**\n     * @dev Transfer ERC721 token using `transferFrom`\n     * @param collection address of the collection\n     * @param from address of the sender\n     * @param to address of the recipient\n     * @param tokenId tokenId\n     */\n    function transferERC721Unsafe(address collection, address from, address to, uint256 tokenId)\n        approvedContract\n        external\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        IERC721(collection).transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Transfer ERC721 token using `safeTransferFrom`\n     * @param collection address of the collection\n     * @param from address of the sender\n     * @param to address of the recipient\n     * @param tokenId tokenId\n     */\n    function transferERC721(address collection, address from, address to, uint256 tokenId)\n        approvedContract\n        external\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        IERC721(collection).safeTransferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Transfer ERC1155 token using `safeTransferFrom`\n     * @param collection address of the collection\n     * @param from address of the sender\n     * @param to address of the recipient\n     * @param tokenId tokenId\n     * @param amount amount\n     */\n    function transferERC1155(address collection, address from, address to, uint256 tokenId, uint256 amount)\n        approvedContract\n        external\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        IERC1155(collection).safeTransferFrom(from, to, tokenId, amount, \"\");\n    }\n\n    /**\n     * @dev Transfer ERC20 token\n     * @param token address of the token\n     * @param from address of the sender\n     * @param to address of the recipient\n     * @param amount amount\n     */\n    function transferERC20(address token, address from, address to, uint256 amount)\n        approvedContract\n        external\n        returns (bool)\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        return IERC20(token).transferFrom(from, to, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ExecutionDelegate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ExecutionDelegate.sol#L119",
                "Type": "Contract Owner Possesses Too Many Privileges",
                "Description": "The owner can set approvedContract  to any address at any time with approveContract(address _contract), and revokeApproval() can be frontrun. As a result, all user funds approved to the ExecutionDelegate contract can be lost via rugpull.",
                "Repair": "Reconsider the protocol's design. BlurExchange.sol should be approved by users instead. The exchange should require that the buyer has received their NFT and the seller has received their ETH/WETH or revert."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Order, AssetType} from \"../lib/OrderStructs.sol\";\nimport {IMatchingPolicy} from \"../interfaces/IMatchingPolicy.sol\";\n\n/**\n * @title StandardPolicyERC1155\n * @dev Policy for matching orders at a fixed price for a specific ERC1155 tokenId\n */\ncontract StandardPolicyERC1155 is IMatchingPolicy {\n    function canMatchMakerAsk(Order calldata makerAsk, Order calldata takerBid)\n        external\n        pure\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            AssetType\n        )\n    {\n        return (\n            (makerAsk.side != takerBid.side) &&\n            (makerAsk.paymentToken == takerBid.paymentToken) &&\n            (makerAsk.collection == takerBid.collection) &&\n            (makerAsk.tokenId == takerBid.tokenId) &&\n            (makerAsk.matchingPolicy == takerBid.matchingPolicy) &&\n            (makerAsk.price == takerBid.price),\n            makerAsk.price,\n            makerAsk.tokenId,\n            1,\n            AssetType.ERC1155\n        );\n    }\n\n    function canMatchMakerBid(Order calldata makerBid, Order calldata takerAsk)\n        external\n        pure\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            AssetType\n        )\n    {\n        return (\n            (makerBid.side != takerAsk.side) &&\n            (makerBid.paymentToken == takerAsk.paymentToken) &&\n            (makerBid.collection == takerAsk.collection) &&\n            (makerBid.tokenId == takerAsk.tokenId) &&\n            (makerBid.matchingPolicy == takerAsk.matchingPolicy) &&\n            (makerBid.price == takerAsk.price),\n            makerBid.price,\n            makerBid.tokenId,\n            1,\n            AssetType.ERC1155\n        );\n    }\n}\n\n\n\n",
        "CodeNames": [
            "StandardPolicyERC1155.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StandardPolicyERC1155.sol#L12-L36",
                "Type": "StandardPolicyERC1155 returns amount == 1 instead of amount == order.amount",
                "Description": "The canMatchMakerAsk and canMatchMakerBid functions in StandardPolicyERC1155.sol will only return 1 as the amount instead of the order.amount value. This value is then used in the _executeTokenTransfer call during the execution flow and leads to only 1 ERC1155 token being sent.",
                "Repair": "Policies used for ERC1155 tokens should return and consider the amount of tokens set for the order."
            }
        ]
    }
]