[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from \"./AuraMath.sol\";\nimport \"./Interfaces.sol\";\n\ninterface IRewardStaking {\n    function stakeFor(address, uint256) external;\n}\n\n/**\n * @title   AuraLocker\n * @author  ConvexFinance\n * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available\n *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes\n *          to depositors.\n * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.\n */\ncontract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {\n    using AuraMath for uint256;\n    using AuraMath224 for uint224;\n    using AuraMath112 for uint112;\n    using AuraMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    /* ==========     STRUCTS     ========== */\n\n    struct RewardData {\n        /// Timestamp for current period finish\n        uint32 periodFinish;\n        /// Last time any user took action\n        uint32 lastUpdateTime;\n        /// RewardRate for the rest of the period\n        uint96 rewardRate;\n        /// Ever increasing rewardPerToken rate, based on % of total supply\n        uint96 rewardPerTokenStored;\n    }\n    struct UserData {\n        uint128 rewardPerTokenPaid;\n        uint128 rewards;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n    struct DelegateeCheckpoint {\n        uint224 votes;\n        uint32 epochStart;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Rewards\n    address[] public rewardTokens;\n    uint256 public queuedCvxCrvRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    //     Core reward data\n    mapping(address => RewardData) public rewardData;\n    //     Reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n    //     User -> reward token -> amount\n    mapping(address => mapping(address => UserData)) public userData;\n    //     Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n    //     Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // Balances\n    //     Supplies and historic supply\n    uint256 public lockedSupply;\n    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply\n    Epoch[] public epochs;\n    //     Mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    // Voting\n    //     Stored delegations\n    mapping(address => address) private _delegates;\n    //     Checkpointed votes\n    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;\n    //     Delegatee balances (user -> unlock timestamp -> amount)\n    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;\n\n    // Config\n    //     Tokens\n    IERC20 public immutable stakingToken;\n    address public immutable cvxCrv;\n    //     Denom for calcs\n    uint256 public constant denominator = 10000;\n    //     Staking cvxCrv\n    address public immutable cvxcrvStaking;\n    //     Incentives\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 3;\n    //     Shutdown\n    bool public isShutdown = false;\n\n    // Basic token data\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== EVENTS ========== */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateCheckpointed(address indexed delegate);\n\n    event Recovered(address _token, uint256 _amount);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardAdded(address indexed _token, uint256 _reward);\n\n    event KickIncentiveSet(uint256 rate, uint256 delay);\n    event Shutdown();\n\n    /***************************************\n                    CONSTRUCTOR\n    ****************************************/\n\n    /**\n     * @param _nameArg          Token name, simples\n     * @param _symbolArg        Token symbol\n     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)\n     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)\n     */\n    constructor(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _stakingToken,\n        address _cvxCrv,\n        address _cvxCrvStaking\n    ) Ownable() {\n        _name = _nameArg;\n        _symbol = _symbolArg;\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n        cvxCrv = _cvxCrv;\n        cvxcrvStaking = _cvxCrvStaking;\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));\n    }\n\n    /***************************************\n                    MODIFIER\n    ****************************************/\n\n    modifier updateReward(address _account) {\n        {\n            Balances storage userBalance = balances[_account];\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i = 0; i < rewardTokensLength; i++) {\n                address token = rewardTokens[i];\n                uint256 newRewardPerToken = _rewardPerToken(token);\n                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();\n                if (_account != address(0)) {\n                    userData[_account][token] = UserData({\n                        rewardPerTokenPaid: newRewardPerToken.to128(),\n                        rewards: _earned(_account, token, userBalance.locked).to128()\n                    });\n                }\n            }\n        }\n        _;\n    }\n\n    /***************************************\n                    ADMIN\n    ****************************************/\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(address _rewardsToken, address _distributor) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0, \"Reward already exists\");\n        require(_rewardsToken != address(stakingToken), \"Cannot add StakingToken as reward\");\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0, \"Reward does not exist\");\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n\n        emit KickIncentiveSet(_rate, _delay);\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    // Set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount);\n    }\n\n    //lock tokens\n    function _lock(address _account, uint256 _amount) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(_amount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n        }\n\n        address delegatee = delegates(_account);\n        if (delegatee != address(0)) {\n            delegateeUnlocks[delegatee][unlockTime] += lockAmount;\n            _checkpointDelegate(delegatee, lockAmount, 0);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(lockAmount);\n\n        emit Staked(_account, lockAmount, lockAmount);\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i < rewardTokensLength; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = userData[_account][_rewardsToken].rewards;\n            if (reward > 0) {\n                userData[_account][_rewardsToken].rewards = 0;\n                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n        //check to add\n        if (epochs[epochindex - 1].date < currentEpoch) {\n            //fill any epoch gaps until the next epoch date.\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);\n                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));\n            }\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));\n    }\n\n    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown\n    function emergencyWithdraw() external nonReentrant {\n        require(isShutdown, \"Must be shutdown\");\n\n        LockedBalance[] memory locks = userLocks[msg.sender];\n        Balances storage userBalance = balances[msg.sender];\n\n        uint256 amt = userBalance.locked;\n        require(amt > 0, \"Nothing locked\");\n\n        userBalance.locked = 0;\n        userBalance.nextUnlockIndex = locks.length.to32();\n        lockedSupply -= amt;\n\n        emit Withdrawn(msg.sender, amt, false);\n\n        stakingToken.safeTransfer(msg.sender, amt);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        uint256 expiryTime = _checkDelay == 0 && _relock\n            ? block.timestamp.add(rewardsDuration)\n            : block.timestamp.sub(_checkDelay);\n        require(length > 0, \"no locks\");\n        // e.g. now = 16\n        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)\n        // e.g. 17 <= (16 + 1)\n        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);\n                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > expiryTime) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);\n                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        lockedSupply = lockedSupply.sub(locked);\n\n        //checkpoint the delegatee\n        _checkpointDelegate(delegates(_account), 0, 0);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            stakingToken.safeTransfer(_rewardAddress, reward);\n            emit KickReward(_rewardAddress, _account, reward);\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_account, locked);\n        } else {\n            stakingToken.safeTransfer(_account, locked);\n        }\n    }\n\n    /***************************************\n            DELEGATION & VOTE BALANCE\n    ****************************************/\n\n    /**\n     * @dev Delegate votes from the sender to `newDelegatee`.\n     */\n    function delegate(address newDelegatee) external virtual nonReentrant {\n        // Step 1: Get lock data\n        LockedBalance[] storage locks = userLocks[msg.sender];\n        uint256 len = locks.length;\n        require(len > 0, \"Nothing to delegate\");\n        require(newDelegatee != address(0), \"Must delegate to someone\");\n\n        // Step 2: Update delegatee storage\n        address oldDelegatee = delegates(msg.sender);\n        require(newDelegatee != oldDelegatee, \"Must choose new delegatee\");\n        _delegates[msg.sender] = newDelegatee;\n\n        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);\n\n        // Step 3: Move balances around\n        //         Delegate for the upcoming epoch\n        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n        uint256 i = len - 1;\n        uint256 futureUnlocksSum = 0;\n        LockedBalance memory currentLock = locks[i];\n        // Step 3.1: Add future unlocks and sum balances\n        while (currentLock.unlockTime > upcomingEpoch) {\n            futureUnlocksSum += currentLock.amount;\n\n            if (oldDelegatee != address(0)) {\n                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;\n            }\n            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;\n\n            if (i > 0) {\n                i--;\n                currentLock = locks[i];\n            } else {\n                break;\n            }\n        }\n\n        // Step 3.2: Checkpoint old delegatee\n        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);\n\n        // Step 3.3: Checkpoint new delegatee\n        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);\n    }\n\n    function _checkpointDelegate(\n        address _account,\n        uint256 _upcomingAddition,\n        uint256 _upcomingDeduction\n    ) internal {\n        // This would only skip on first checkpointing\n        if (_account != address(0)) {\n            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];\n            if (ckpts.length > 0) {\n                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];\n                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks\n                if (prevCkpt.epochStart == upcomingEpoch) {\n                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({\n                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    });\n                }\n                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired\n                // e.g. week 1 + 17 <= 18\n                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                } else {\n                    uint256 nextEpoch = upcomingEpoch;\n                    uint256 unlocksSinceLatestCkpt = 0;\n                    // Should be maximum 18 iterations\n                    while (nextEpoch > prevCkpt.epochStart) {\n                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];\n                        nextEpoch -= rewardsDuration;\n                    }\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)\n                                .to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                }\n            } else {\n                ckpts.push(\n                    DelegateeCheckpoint({\n                        votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    })\n                );\n            }\n            emit DelegateCheckpointed(_account);\n        }\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) external view returns (uint256) {\n        return getPastVotes(account, block.timestamp);\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {\n        return _checkpointedVotes[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) external view virtual returns (uint32) {\n        return _checkpointedVotes[account].length.to32();\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     */\n    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {\n        require(timestamp <= block.timestamp, \"ERC20Votes: block not yet mined\");\n        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);\n        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);\n        votes = ckpt.votes;\n        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {\n            return 0;\n        }\n        while (epoch > ckpt.epochStart) {\n            votes -= delegateeUnlocks[account][epoch];\n            epoch -= rewardsDuration;\n        }\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     */\n    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {\n        require(timestamp < block.timestamp, \"ERC20Votes: block not yet mined\");\n        return totalSupplyAtEpoch(findEpochId(timestamp));\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     *      Copied from oz/ERC20Votes.sol\n     */\n    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)\n        private\n        view\n        returns (DelegateeCheckpoint memory)\n    {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = AuraMath.average(low, high);\n            if (ckpts[mid].epochStart > epochStart) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];\n    }\n\n    /***************************************\n                VIEWS - BALANCES\n    ****************************************/\n\n    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        return balanceAtEpochOf(findEpochId(block.timestamp), _user);\n    }\n\n    // Balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {\n        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));\n        require(epochStart < block.timestamp, \"Epoch is in the future\");\n\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        uint256 locksLength = locks.length;\n        for (uint256 i = locksLength; i > 0; i--) {\n            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            //also not include the current epoch\n            if (lockEpoch < epochStart) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i - 1].amount);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    // Information on a user's locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    // Supply of all properly locked balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        return totalSupplyAtEpoch(findEpochId(block.timestamp));\n    }\n\n    // Supply of all properly locked balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {\n        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));\n        require(epochStart < block.timestamp, \"Epoch is in the future\");\n\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 lastIndex = epochs.length - 1;\n\n        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;\n\n        for (uint256 i = epochIndex + 1; i > 0; i--) {\n            Epoch memory e = epochs[i - 1];\n            if (e.date == epochStart) {\n                continue;\n            } else if (e.date <= cutoffEpoch) {\n                break;\n            } else {\n                supply += e.supply;\n            }\n        }\n    }\n\n    // Get an epoch index based on timestamp\n    function findEpochId(uint256 _time) public view returns (uint256 epoch) {\n        return _time.sub(epochs[0].date).div(rewardsDuration);\n    }\n\n    /***************************************\n                VIEWS - GENERAL\n    ****************************************/\n\n    // Number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /***************************************\n                VIEWS - REWARDS\n    ****************************************/\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        uint256 userRewardsLength = userRewards.length;\n        for (uint256 i = 0; i < userRewardsLength; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(_account, token, userBalance.locked);\n        }\n        return userRewards;\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {\n        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        UserData memory data = userData[_user][_rewardsToken];\n        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {\n        return AuraMath.min(block.timestamp, _finishTime);\n    }\n\n    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {\n        if (lockedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(lockedSupply)\n            );\n    }\n\n    /***************************************\n                REWARD FUNDING\n    ****************************************/\n\n    function queueNewRewards(uint256 _rewards) external nonReentrant {\n        require(rewardDistributors[cvxCrv][msg.sender], \"!authorized\");\n        require(_rewards > 0, \"No reward\");\n\n        RewardData storage rdata = rewardData[cvxCrv];\n\n        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);\n\n        _rewards = _rewards.add(queuedCvxCrvRewards);\n        if (block.timestamp >= rdata.periodFinish) {\n            _notifyReward(cvxCrv, _rewards);\n            queuedCvxCrvRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rdata.rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            _notifyReward(cvxCrv, _rewards);\n            queuedCvxCrvRewards = 0;\n        } else {\n            queuedCvxCrvRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {\n        require(_rewardsToken != cvxCrv, \"Use queueNewRewards\");\n        require(rewardDistributors[_rewardsToken][msg.sender], \"Must be rewardsDistributor\");\n        require(_reward > 0, \"No reward\");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);\n    }\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {\n        RewardData storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to96();\n        } else {\n            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to32();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();\n\n        emit RewardAdded(_rewardsToken, _reward);\n    }\n}\n\n\n",
        "CodeNames": [
            "AuraLocker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AuraLocker.sol#L258-L295",
                "Type": "Increase voting power by tokenizing the address that locks the token",
                "Description": "A bad actor could lock the token through a smart contract, tokenize it, and accumulate voting power that could dictate the future of the protocol.",
                "Repair": "Implement a whitelist or blacklist to restrict the type of address that can lock the token"
            },
            {
                "Location": "AuraLocker.sol#L176-L177, AuraLocker.sol#L802-L814, AuraLocker.sol#L864",
                "Type": "Integer overflow",
                "Description": "There is a potential overflow in the rewards calculations which would lead to updateReward() always reverting. The impact of this overflow is that all reward tokens will be permanently locked in the contract.",
                "Repair": "Increase the size of the rewardPerTokenStored to either uint256 or update both rewardRate and rewardPerTokenStored to be uint224"
            },
            {
                "Location": "AuraLocker.sol#L594-L609, AuraLocker.sol#L611-L618",
                "Type": "Governance Susceptibility",
                "Description": "The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances.",
                "Repair": "Track the delegated balances only in the total voting supply to properly track the voting power of each individual."
            },
            {
                "Location": "AuraLocker.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "Rewards distribution can be delayed/never distributed",
                "Repair": "Add a check to queueNewRewards to disallow funding once endTime has been reached"
            },
            {
                "Location": "AuraLocker.sol#L396:#L405",
                "Type": "Inaccurate reward calculation",
                "Description": "AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance.",
                "Repair": "Change the last line in the code above to: reward = uint256(locked).mul(rRate).div(denominator);"
            },
            {
                "Location": "AuraLocker._lock() function",
                "Type": "Lack of voting power allocation",
                "Description": "Users who lock their AURA tokens in the AuraLocker do not receive voting power unless they delegate to themselves, which is not mentioned in the documentation. This can lead to missed opportunities to vote on critical protocol decisions or flow of incentives.",
                "Repair": "Update the AuraLocker._lock() function to automatically delegate to the account to trigger the checkpointing if there is no delegatee"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { AuraMath } from \"./AuraMath.sol\";\nimport { IAuraLocker, ICrvDepositorWrapper } from \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IBasicRewards {\n    function getReward(address _account, bool _claimExtras) external;\n\n    function getReward(address _account) external;\n\n    function getReward(address _account, address _token) external;\n\n    function stakeFor(address, uint256) external;\n}\n\n/**\n * @title   ClaimZap\n * @author  ConvexFinance -> AuraFinance\n * @notice  Claim zap to bundle various reward claims\n * @dev     Claims from all pools, and stakes cvxCrv and CVX if wanted.\n *          v2:\n *           - change exchange to use curve pool\n *           - add getReward(address,token) type\n *           - add option to lock cvx\n *           - add option use all funds in wallet\n */\ncontract AuraClaimZap {\n    using SafeERC20 for IERC20;\n    using AuraMath for uint256;\n\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable cvxCrv;\n    address public immutable crvDepositWrapper;\n    address public immutable cvxCrvRewards;\n    address public immutable locker;\n    address public immutable owner;\n\n    enum Options {\n        ClaimCvxCrv, //1\n        ClaimLockedCvx, //2\n        ClaimLockedCvxStake, //4\n        LockCrvDeposit, //8\n        UseAllWalletFunds, //16\n        LockCvx //32\n    }\n\n    /**\n     * @param _crv                CRV token (0xD533a949740bb3306d119CC777fa900bA034cd52);\n     * @param _cvx                CVX token (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n     * @param _cvxCrv             cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n     * @param _crvDepositWrapper  crvDepositWrapper (0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae);\n     * @param _cvxCrvRewards      cvxCrvRewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n     * @param _locker             vlCVX (0xD18140b4B819b895A3dba5442F959fA44994AF50);\n     */\n    constructor(\n        address _crv,\n        address _cvx,\n        address _cvxCrv,\n        address _crvDepositWrapper,\n        address _cvxCrvRewards,\n        address _locker\n    ) {\n        crv = _crv;\n        cvx = _cvx;\n        cvxCrv = _cvxCrv;\n        crvDepositWrapper = _crvDepositWrapper;\n        cvxCrvRewards = _cvxCrvRewards;\n        locker = _locker;\n        owner = msg.sender;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ClaimZap V2.0\";\n    }\n\n    /**\n     * @notice Approve spending of:\n     *          crv     -> crvDepositor\n     *          cvxCrv  -> cvxCrvRewards\n     *          cvx     -> Locker\n     */\n    function setApprovals() external {\n        require(msg.sender == owner, \"!auth\");\n\n        IERC20(crv).safeApprove(crvDepositWrapper, 0);\n        IERC20(crv).safeApprove(crvDepositWrapper, type(uint256).max);\n\n        IERC20(cvxCrv).safeApprove(cvxCrvRewards, 0);\n        IERC20(cvxCrv).safeApprove(cvxCrvRewards, type(uint256).max);\n\n        IERC20(cvx).safeApprove(locker, 0);\n        IERC20(cvx).safeApprove(locker, type(uint256).max);\n    }\n\n    /**\n     * @notice Use bitmask to check if option flag is set\n     */\n    function _checkOption(uint256 _mask, uint256 _flag) internal pure returns (bool) {\n        return (_mask & (1 << _flag)) != 0;\n    }\n\n    /**\n     * @notice Claim all the rewards\n     * @param rewardContracts       Array of addresses for LP token rewards\n     * @param extraRewardContracts  Array of addresses for extra rewards\n     * @param tokenRewardContracts  Array of addresses for token rewards e.g vlCvxExtraRewardDistribution\n     * @param tokenRewardTokens     Array of token reward addresses to use with tokenRewardContracts\n     * @param depositCrvMaxAmount   The max amount of CRV to deposit if converting to crvCvx\n     * @param minAmountOut          The min amount out for crv:cvxCrv swaps if swapping. Set this to zero if you\n     *                              want to use CrvDepositor instead of balancer swap\n     * @param depositCvxMaxAmount   The max amount of CVX to deposit if locking CVX\n     * @param options               Claim options\n     */\n    function claimRewards(\n        address[] calldata rewardContracts,\n        address[] calldata extraRewardContracts,\n        address[] calldata tokenRewardContracts,\n        address[] calldata tokenRewardTokens,\n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 options\n    ) external {\n        require(tokenRewardContracts.length == tokenRewardTokens.length, \"!parity\");\n\n        uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);\n        uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);\n\n        //claim from main curve LP pools\n        for (uint256 i = 0; i < rewardContracts.length; i++) {\n            IBasicRewards(rewardContracts[i]).getReward(msg.sender, true);\n        }\n        //claim from extra rewards\n        for (uint256 i = 0; i < extraRewardContracts.length; i++) {\n            IBasicRewards(extraRewardContracts[i]).getReward(msg.sender);\n        }\n        //claim from multi reward token contract\n        for (uint256 i = 0; i < tokenRewardContracts.length; i++) {\n            IBasicRewards(tokenRewardContracts[i]).getReward(msg.sender, tokenRewardTokens[i]);\n        }\n\n        // claim others/deposit/lock/stake\n        _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);\n    }\n\n    /**\n     * @notice  Claim additional rewards from:\n     *          - cvxCrvRewards\n     *          - cvxLocker\n     * @param depositCrvMaxAmount see claimRewards\n     * @param minAmountOut        see claimRewards\n     * @param depositCvxMaxAmount see claimRewards\n     * @param removeCrvBalance    crvBalance to ignore and not redeposit (starting Crv balance)\n     * @param removeCvxBalance    cvxBalance to ignore and not redeposit (starting Cvx balance)\n     * @param options             see claimRewards\n     */\n    // prettier-ignore\n    function _claimExtras( // solhint-disable-line \n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 removeCrvBalance,\n        uint256 removeCvxBalance,\n        uint256 options\n    ) internal {\n        //claim from cvxCrv rewards\n        if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {\n            IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);\n        }\n\n        //claim from locker\n        if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {\n            IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));\n        }\n\n        //reset remove balances if we want to also stake/lock funds already in our wallet\n        if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {\n            removeCrvBalance = 0;\n            removeCvxBalance = 0;\n        }\n\n        //lock upto given amount of crv and stake\n        if (depositCrvMaxAmount > 0) {\n            uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);\n            crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);\n\n            if (crvBalance > 0) {\n                //pull crv\n                IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);\n                //deposit\n                ICrvDepositorWrapper(crvDepositWrapper).deposit(\n                    crvBalance,\n                    minAmountOut,\n                    _checkOption(options, uint256(Options.LockCrvDeposit)),\n                    address(0)\n                );\n\n                uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));\n                //stake for msg.sender\n                IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);\n            }\n        }\n\n        //stake up to given amount of cvx\n        if (depositCvxMaxAmount > 0) {\n            uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\n            cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\n            if (cvxBalance > 0) {\n                //pull cvx\n                IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\n                if (_checkOption(options, uint256(Options.LockCvx))) {\n                    IAuraLocker(locker).lock(msg.sender, cvxBalance);\n                }\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "AuraClaimZap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AuraClaimZap.sol#L224-L226",
                "Type": "User will lose funds",
                "Description": "If the user calls claimRewards with Options.LockCvx as false, their cvx funds can get stuck in the contract.",
                "Repair": "Check if the user has enabled lock for cvx before transferring cvx from the user to the contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport { BaseRewardPool, IDeposit } from \"./BaseRewardPool.sol\";\nimport { IERC4626, IERC20Metadata } from \"./interfaces/IERC4626.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.6/utils/ReentrancyGuard.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   BaseRewardPool4626\n * @notice  Simply wraps the BaseRewardPool with the new IERC4626 Vault standard functions.\n * @dev     See https://github.com/fei-protocol/ERC4626/blob/main/src/interfaces/IERC4626.sol#L58\n *          This is not so much a vault as a Reward Pool, therefore asset:share ratio is always 1:1.\n *          To create most utility for this RewardPool, the \"asset\" has been made to be the crvLP token,\n *          as opposed to the cvxLP token. Therefore, users can easily deposit crvLP, and it will first\n *          go to the Booster and mint the cvxLP before performing the normal staking function.\n */\ncontract BaseRewardPool4626 is BaseRewardPool, ReentrancyGuard, IERC4626 {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The address of the underlying ERC20 token used for\n     * the Vault for accounting, depositing, and withdrawing.\n     */\n    address public override asset;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    /**\n     * @dev See BaseRewardPool.sol\n     */\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_,\n        address lptoken_\n    ) public BaseRewardPool(pid_, stakingToken_, rewardToken_, operator_, rewardManager_) {\n        asset = lptoken_;\n        IERC20(asset).safeApprove(operator_, type(uint256).max);\n    }\n\n    /**\n     * @notice Total amount of the underlying asset that is \"managed\" by Vault.\n     */\n    function totalAssets() external view virtual override returns(uint256){\n        return totalSupply();\n    }\n\n    /**\n     * @notice Mints `shares` Vault shares to `receiver`.\n     * @dev Because `asset` is not actually what is collected here, first wrap to required token in the booster.\n     */\n    function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {\n        // Transfer \"asset\" (crvLP) from sender\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        // Convert crvLP to cvxLP through normal booster deposit process, but don't stake\n        uint256 balBefore = stakingToken.balanceOf(address(this));\n        IDeposit(operator).deposit(pid, assets, false);\n        uint256 balAfter = stakingToken.balanceOf(address(this));\n\n        require(balAfter - balBefore >= assets, \"!deposit\");\n\n        // Perform stake manually, now that the funds have been received\n        _processStake(assets, receiver);\n\n        emit Deposit(msg.sender, receiver, assets, assets);\n        emit Staked(receiver, assets);\n        return assets;\n    }\n\n    /**\n     * @notice Mints exactly `shares` Vault shares to `receiver`\n     * by depositing `assets` of underlying tokens.\n     */\n    function mint(uint256 shares, address receiver) external virtual override returns (uint256) {\n        return deposit(shares, receiver);\n    }\n\n    /**\n     * @notice Redeems `shares` from `owner` and sends `assets`\n     * of underlying tokens to `receiver`.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant returns (uint256) {\n        if (msg.sender != owner) {\n            _approve(owner, msg.sender, _allowances[owner][msg.sender].sub(assets, \"ERC4626: withdrawal amount exceeds allowance\"));\n        }\n        \n        _withdrawAndUnwrapTo(assets, owner, receiver);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, assets);\n        return assets;\n    }\n\n    /**\n     * @notice Redeems `shares` from `owner` and sends `assets`\n     * of underlying tokens to `receiver`.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external virtual override returns (uint256) {\n        return withdraw(shares, receiver, owner);\n    }\n\n    /**\n     * @notice The amount of shares that the vault would\n     * exchange for the amount of assets provided, in an\n     * ideal scenario where all the conditions are met.\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice The amount of assets that the vault would\n     * exchange for the amount of shares provided, in an\n     * ideal scenario where all the conditions are met.\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Total number of underlying assets that can\n     * be deposited by `owner` into the Vault, where `owner`\n     * corresponds to the input parameter `receiver` of a\n     * `deposit` call.\n     */\n    function maxDeposit(address /* owner */) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     */    \n    function previewDeposit(uint256 assets) external view virtual override returns(uint256){\n        return convertToShares(assets);\n    }\n\n    /**\n     * @notice Total number of underlying shares that can be minted\n     * for `owner`, where `owner` corresponds to the input\n     * parameter `receiver` of a `mint` call.\n     */\n    function maxMint(address owner) external view virtual override returns (uint256) {\n        return maxDeposit(owner);\n    }\n\n    /**    \n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their mint at the current block, given\n     * current on-chain conditions.\n     */\n    function previewMint(uint256 shares) external view virtual override returns(uint256){\n        return convertToAssets(shares);\n    }\n\n    /**\n     * @notice Total number of underlying assets that can be\n     * withdrawn from the Vault by `owner`, where `owner`\n     * corresponds to the input parameter of a `withdraw` call.\n     */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /**    \n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns(uint256 shares){\n        return convertToShares(assets);\n    }\n\n    /**\n     * @notice Total number of underlying shares that can be\n     * redeemed from the Vault by `owner`, where `owner` corresponds\n     * to the input parameter of a `redeem` call.\n     */\n    function maxRedeem(address owner) external view virtual override returns (uint256) {\n        return maxWithdraw(owner);\n    }\n    /**    \n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     */\n    function previewRedeem(uint256 shares) external view virtual override returns(uint256){\n        return previewWithdraw(shares);\n    }\n\n\n    /* ========== IERC20 ========== */\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view override returns (string memory) {\n        return string(\n            abi.encodePacked(IERC20Metadata(address(stakingToken)).name(), \" Vault\")\n        );\n    }\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view override returns (string memory) {\n        return string(\n            abi.encodePacked(IERC20Metadata(address(stakingToken)).symbol(), \"-vault\")\n        );\n    }\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() public view override(BaseRewardPool, IERC20) returns (uint256) {\n        return BaseRewardPool.totalSupply();\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) public view override(BaseRewardPool, IERC20) returns (uint256) {\n        return BaseRewardPool.balanceOf(account);\n    }\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address /* recipient */, uint256 /* amount */) external override returns (bool) {\n        revert(\"ERC4626: Not supported\");\n    }\n\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC4626: approve from the zero address\");\n        require(spender != address(0), \"ERC4626: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     */\n    function transferFrom(address /* sender */, address /* recipient */, uint256 /* amount */) external override returns (bool) {\n        revert(\"ERC4626: Not supported\");\n    }\n}\n\n",
        "CodeNames": [
            "BaseRewardPool4626.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BaseRewardPool4626.sol",
                "Type": "BaseRewardPool4626 is not IERC4626 compliant",
                "Description": "BaseRewardPool4626 is not compliant with the eip-4626 standard, making it irrelevant for projects to integrate with it.",
                "Repair": "Review the necessary functions and emits required on eip-4626 and add them to BaseRewardPool4626"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { IVault, IPriceOracle, ICrvDepositorWrapper, IAsset } from \"./Interfaces.sol\";\nimport { IVault } from \"./Interfaces.sol\";\n\ninterface ICrvDepositor {\n    function depositFor(\n        address to,\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) external;\n}\n\n/**\n * @title   BalInvestor\n * @notice  Deposits $BAL into a BAL/WETH BPT. Hooks into TWAP to determine minOut.\n * @dev     Abstract contract for depositing BAL -> balBPT -> auraBAL via crvDepositor\n */\nabstract contract BalInvestor {\n    using SafeERC20 for IERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    address public immutable BAL;\n    address public immutable WETH;\n    address public immutable BALANCER_POOL_TOKEN;\n    bytes32 public immutable BAL_ETH_POOL_ID;\n\n    constructor(\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) {\n        (\n            address poolAddress, /* */\n\n        ) = _balancerVault.getPool(_balETHPoolId);\n        require(poolAddress != address(0), \"!poolAddress\");\n\n        BALANCER_VAULT = _balancerVault;\n        BAL = _bal;\n        WETH = _weth;\n        BALANCER_POOL_TOKEN = poolAddress;\n        BAL_ETH_POOL_ID = _balETHPoolId;\n    }\n\n    function _setApprovals() internal {\n        IERC20(WETH).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        IERC20(BAL).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _getBptPrice() internal view returns (uint256) {\n        IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);\n\n        queries[0].variable = IPriceOracle.Variable.BPT_PRICE;\n        queries[0].secs = 3600; // last hour\n        queries[0].ago = 0; // now\n\n        // Gets the balancer time weighted average price denominated in BAL\n        return IPriceOracle(BALANCER_POOL_TOKEN).getTimeWeightedAverage(queries)[0];\n    }\n\n    function _getMinOut(uint256 amount, uint256 minOutBps) internal view returns (uint256) {\n        // Gets the balancer time weighted average price denominated in BAL\n        // e.g.  if 1 BAL == 0.4 BPT, bptOraclePrice == 2.5\n        uint256 bptOraclePrice = _getBptPrice();\n        // e.g. minOut = (((100e18 * 1e18) / 2.5e18) * 9980) / 10000;\n        // e.g. minout = 39.92e18\n        uint256 minOut = (((amount * 1e18) / bptOraclePrice) * minOutBps) / 10000;\n        return minOut;\n    }\n\n    function _investBalToPool(uint256 amount, uint256 minOut) internal {\n        IERC20(BAL).safeTransferFrom(msg.sender, address(this), amount);\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(BAL);\n        assets[1] = IAsset(WETH);\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = amount;\n        maxAmountsIn[1] = 0;\n\n        BALANCER_VAULT.joinPool(\n            BAL_ETH_POOL_ID,\n            address(this),\n            address(this),\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, minOut),\n                false // Don't use internal balances\n            )\n        );\n    }\n}\n\n/**\n * @title   CrvDepositorWrapper\n * @notice  Converts BAL -> balBPT and then wraps to auraBAL via the crvDepositor\n */\ncontract CrvDepositorWrapper is ICrvDepositorWrapper, BalInvestor {\n    address public immutable crvDeposit;\n\n    constructor(\n        address _crvDeposit,\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) BalInvestor(_balancerVault, _bal, _weth, _balETHPoolId) {\n        crvDeposit = _crvDeposit;\n    }\n\n    function setApprovals() external {\n        _setApprovals();\n        require(IERC20(BALANCER_POOL_TOKEN).approve(crvDeposit, type(uint256).max), \"!approval\");\n    }\n\n    /**\n     * @dev Gets minimum output based on BPT oracle price\n     * @param _amount Units of BAL to deposit\n     * @param _outputBps Multiplier where 100% == 10000, 99.5% == 9950 and 98% == 9800\n     * @return minOut Units of BPT to expect as output\n     */\n    function getMinOut(uint256 _amount, uint256 _outputBps) external view returns (uint256) {\n        return _getMinOut(_amount, _outputBps);\n    }\n\n    function deposit(\n        uint256 _amount,\n        uint256 _minOut,\n        bool _lock,\n        address _stakeAddress\n    ) external {\n        _investBalToPool(_amount, _minOut);\n        uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));\n        ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);\n    }\n}\n\n\n",
        "CodeNames": [
            "CrvDepositorWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CrvDepositorWrapper.sol#L56-L65",
                "Type": "CrvDepositorWrapper.sol relies on oracle that isn't frequently updated",
                "Description": "The oracle used by CrvDepositorWrapper is infrequently updated, which can result in an inaccurate oracle and high levels of slippage.",
                "Repair": "Consider using chainlink oracles for both BAL and ETH to get a real-time estimate of the LP value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Context.sol\";\nimport \"@openzeppelin/contracts-0.6/access/Ownable.sol\";\nimport \"./interfaces/IRewarder.sol\";\n\n/**\n * @title   ConvexMasterChef\n * @author  ConvexFinance\n * @notice  Masterchef can distribute rewards to n pools over x time\n * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,\n *          and thus it can over complicate the distribution of these rewards.\n *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed\n *          pro-rata based on the allocation points in each pool vs the total alloc.\n */\ncontract ConvexMasterChef is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of CVXs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.\n        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.\n        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.\n        IRewarder rewarder;\n    }\n\n    //cvx\n    IERC20 public immutable cvx;\n    // CVX tokens created per block.\n    uint256 public immutable rewardPerBlock;\n    // Bonus muliplier for early cvx makers.\n    uint256 public constant BONUS_MULTIPLIER = 2;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The block number when CVX mining starts.\n    uint256 public immutable startBlock;\n    uint256 public immutable endBlock;\n\n    // Events\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        IERC20 _cvx,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _endBlock\n    ) public {\n        cvx = _cvx;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    function add(\n        uint256 _allocPoint,\n        IERC20 _lpToken,\n        IRewarder _rewarder,\n        bool _withUpdate\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock = block.number > startBlock\n            ? block.number\n            : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accCvxPerShare: 0,\n                rewarder: _rewarder\n            })\n        );\n    }\n\n    // Update the given pool's CVX allocation point. Can only be called by the owner.\n    function set(\n        uint256 _pid,\n        uint256 _allocPoint,\n        IRewarder _rewarder,\n        bool _withUpdate,\n        bool _updateRewarder\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n            _allocPoint\n        );\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if(_updateRewarder){\n            poolInfo[_pid].rewarder = _rewarder;\n        }\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint256 _from, uint256 _to)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 clampedTo = _to > endBlock ? endBlock : _to;\n        uint256 clampedFrom = _from > endBlock ? endBlock : _from;\n        return clampedTo.sub(clampedFrom);\n    }\n\n    // View function to see pending CVXs on frontend.\n    function pendingCvx(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accCvxPerShare = pool.accCvxPerShare;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 multiplier = getMultiplier(\n                pool.lastRewardBlock,\n                block.number\n            );\n            uint256 cvxReward = multiplier\n                .mul(rewardPerBlock)\n                .mul(pool.allocPoint)\n                .div(totalAllocPoint);\n            accCvxPerShare = accCvxPerShare.add(\n                cvxReward.mul(1e12).div(lpSupply)\n            );\n        }\n        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);\n    }\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 cvxReward = multiplier\n            .mul(rewardPerBlock)\n            .mul(pool.allocPoint)\n            .div(totalAllocPoint);\n        //cvx.mint(address(this), cvxReward);\n        pool.accCvxPerShare = pool.accCvxPerShare.add(\n            cvxReward.mul(1e12).div(lpSupply)\n        );\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit LP tokens to MasterChef for CVX allocation.\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user\n                .amount\n                .mul(pool.accCvxPerShare)\n                .div(1e12)\n                .sub(user.rewardDebt);\n            safeRewardTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);\n        }\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(\n            user.rewardDebt\n        );\n        safeRewardTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);\n        }\n\n        emit RewardPaid(msg.sender, _pid, pending);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    function claim(uint256 _pid, address _account) external{\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_account];\n\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(\n            user.rewardDebt\n        );\n        safeRewardTransfer(_account, pending);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, _account, _account, pending, user.amount);\n        }\n\n        emit RewardPaid(_account, _pid, pending);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);\n        }\n    }\n\n    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.\n    function safeRewardTransfer(address _to, uint256 _amount) internal {\n        uint256 cvxBal = cvx.balanceOf(address(this));\n        if (_amount > cvxBal) {\n            cvx.safeTransfer(_to, cvxBal);\n        } else {\n            cvx.safeTransfer(_to, _amount);\n        }\n    }\n\n}\n\n",
        "CodeNames": [
            "ConvexMasterChef.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ConvexMasterChef.sol#L299-L306",
                "Type": "safeRewardTransfer can cause loss of funds",
                "Description": "The safeRewardTransfer function in ConvexMasterChef can cause depositors to be sent less tokens than needed or none at all, resulting in a loss of funds.",
                "Repair": "Use usual safeTransfer instead of safeRewardTransfer"
            },
            {
                "Location": "ConvexMasterChef.sol#L209-L221, ConvexMasterChef.sol#L239-L250",
                "Type": "Reentrancy",
                "Description": "Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future, the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.",
                "Repair": "Consider adding a direct reentrancy control, e.g. nonReentrant modifier. Also, consider finishing all internal state updates prior to external calls."
            },
            {
                "Location": "ConvexMasterChef.sol#L96",
                "Type": "Incorrect reward distribution",
                "Description": "Duplicate LP token could lead to incorrect reward distribution.",
                "Repair": "Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken add function should fail."
            },
            {
                "Location": "ConvexMasterChef contract, updatePool() function",
                "Type": "Incorrect reward calculation",
                "Description": "When the _lpToken is the same token as cvx, reward calculation for that pool in the updatePool() function can be incorrect.",
                "Repair": "Add a check that _lpToken is not cvx in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token."
            },
            {
                "Location": "ConvexMasterChef.sol",
                "Type": "Incorrect implementation",
                "Description": "The use of add() and set() functions in ConvexMasterChef.sol without calling massUpdatePools() to update all pools can lead to incorrect reward calculation due to the modification of the totalAllocPoint variable without updating the pending reward first.",
                "Repair": "Remove the _withUpdate variable in the add() and set() functions and always call the massUpdatePools() function before updating totalAllocPoint variable"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward token\u03c0\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}\n\n\n",
        "CodeNames": [
            "ExtraRewardsDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ExtraRewardsDistributor.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "User can forfeit other user rewards",
                "Repair": "Disallow users to call getReward function for other users"
            },
            {
                "Location": "ExtraRewardsDistributor.sol#L74",
                "Type": "Griefing attack",
                "Description": "Users can grief reward distributions by spending dust.",
                "Repair": "Allow the backdating of rewards, which will cost more gas."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IVault } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title   BalLiquidityProvider\n * @notice  Provides initial liquidity to a Balancer pool on behalf of a given DAO\n */\ncontract BalLiquidityProvider {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable startToken;\n    IERC20 public immutable pairToken;\n    uint256 public minPairAmount;\n\n    address private immutable provider;\n    address public immutable dao;\n\n    IVault public immutable bVault;\n\n    event LiquidityProvided(uint256[] input, uint256 output);\n    event MinPairAmountChanged(uint256 oldMinPairAmount, uint256 newMinPairAmount);\n\n    constructor(\n        address _startToken,\n        address _pairToken,\n        uint256 _minPairAmount,\n        address _dao,\n        address _bVault\n    ) {\n        startToken = IERC20(_startToken);\n        pairToken = IERC20(_pairToken);\n        minPairAmount = _minPairAmount;\n        provider = msg.sender;\n        dao = _dao;\n        bVault = IVault(_bVault);\n    }\n\n    /**\n     * @dev Provides liquidity on behalf of the dao, in a non-custodial manner.\n     *      Has protections in place to ensure that no erroneous liquidity data gets added.\n     */\n    function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {\n        require(msg.sender == provider, \"!auth\");\n        require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, \"!valid\");\n        require(pairToken.balanceOf(address(this)) > minPairAmount, \"!minLiq\");\n\n        for (uint256 i = 0; i < 2; i++) {\n            address asset = address(_request.assets[i]);\n            require(asset == address(startToken) || asset == address(pairToken), \"!asset\");\n\n            IERC20 tkn = IERC20(asset);\n            uint256 bal = tkn.balanceOf(address(this));\n            require(bal > 0 && bal == _request.maxAmountsIn[i], \"!bal\");\n\n            tkn.safeApprove(address(bVault), 0);\n            tkn.safeApprove(address(bVault), bal);\n        }\n\n        (address pool, ) = bVault.getPool(_poolId);\n        uint256 supplyBefore = IERC20(pool).totalSupply();\n        require(supplyBefore == 0, \"!init\");\n\n        bVault.joinPool(_poolId, address(this), dao, _request);\n\n        uint256 balAfter = IERC20(pool).balanceOf(dao);\n        require(balAfter > 0, \"!mint\");\n\n        emit LiquidityProvided(_request.maxAmountsIn, balAfter);\n    }\n\n    /**\n     * @dev Allows the DAO to change the minimum amount of the pair token that must be added as liquidity\n     */\n    function changeMinPairAmount(uint256 _newAmount) external {\n        require(msg.sender == dao, \"!auth\");\n        emit MinPairAmountChanged(minPairAmount, _newAmount);\n        minPairAmount = _newAmount;\n    }\n\n    /**\n     * @dev Rescues a given token from the contract.\n     * Only provider or DAO can call this function.\n     */\n    function rescueToken(address _erc20) external {\n        require(msg.sender == provider || msg.sender == dao, \"!auth\");\n        IERC20 tkn = IERC20(_erc20);\n        tkn.safeTransfer(dao, tkn.balanceOf(address(this)));\n    }\n}\n\n\n",
        "CodeNames": [
            "BalLiquidityProvider.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BalLiquidityProvider.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "DDOS in BalLiquidityProvider",
                "Repair": "Remove or change the requirement for balances to be equal to input variables"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport { AuraMath } from \"./AuraMath.sol\";\n\n/**\n * @title   AuraVestedEscrow\n * @author  adapted from ConvexFinance (convex-platform/contracts/contracts/VestedEscrow)\n * @notice  Vests tokens over a given timeframe to an array of recipients. Allows locking of\n *          these tokens directly to staking contract.\n * @dev     Adaptations:\n *           - One time initialisation\n *           - Consolidation of fundAdmin/admin\n *           - Lock in AuraLocker by default\n *           - Start and end time\n */\ncontract AuraVestedEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n\n    address public admin;\n    IAuraLocker public auraLocker;\n\n    uint256 public immutable startTime;\n    uint256 public immutable endTime;\n    uint256 public immutable totalTime;\n\n    bool public initialised = false;\n\n    mapping(address => uint256) public totalLocked;\n    mapping(address => uint256) public totalClaimed;\n\n    event Funded(address indexed recipient, uint256 reward);\n    event Cancelled(address indexed recipient);\n    event Claim(address indexed user, uint256 amount, bool locked);\n\n    /**\n     * @param rewardToken_    Reward token (AURA)\n     * @param admin_          Admin to cancel rewards\n     * @param auraLocker_     Contract where rewardToken can be staked\n     * @param starttime_      Timestamp when claim starts\n     * @param endtime_        When vesting ends\n     */\n    constructor(\n        address rewardToken_,\n        address admin_,\n        address auraLocker_,\n        uint256 starttime_,\n        uint256 endtime_\n    ) {\n        require(starttime_ >= block.timestamp, \"start must be future\");\n        require(endtime_ > starttime_, \"end must be greater\");\n\n        rewardToken = IERC20(rewardToken_);\n        admin = admin_;\n        auraLocker = IAuraLocker(auraLocker_);\n\n        startTime = starttime_;\n        endTime = endtime_;\n        totalTime = endTime - startTime;\n        require(totalTime >= 16 weeks, \"!short\");\n    }\n\n    /***************************************\n                    SETUP\n    ****************************************/\n\n    /**\n     * @notice Change contract admin\n     * @param _admin New admin address\n     */\n    function setAdmin(address _admin) external {\n        require(msg.sender == admin, \"!auth\");\n        admin = _admin;\n    }\n\n    /**\n     * @notice Change locker contract address\n     * @param _auraLocker Aura Locker address\n     */\n    function setLocker(address _auraLocker) external {\n        require(msg.sender == admin, \"!auth\");\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /**\n     * @notice Fund recipients with rewardTokens\n     * @param _recipient  Array of recipients to vest rewardTokens for\n     * @param _amount     Arrary of amount of rewardTokens to vest\n     */\n    function fund(address[] calldata _recipient, uint256[] calldata _amount) external nonReentrant {\n        require(!initialised, \"initialised already\");\n\n        uint256 totalAmount = 0;\n        for (uint256 i = 0; i < _recipient.length; i++) {\n            uint256 amount = _amount[i];\n\n            totalLocked[_recipient[i]] += amount;\n            totalAmount += amount;\n\n            emit Funded(_recipient[i], amount);\n        }\n        rewardToken.safeTransferFrom(msg.sender, address(this), totalAmount);\n        initialised = true;\n    }\n\n    /**\n     * @notice Cancel recipients vesting rewardTokens\n     * @param _recipient Recipient address\n     */\n    function cancel(address _recipient) external nonReentrant {\n        require(msg.sender == admin, \"!auth\");\n        require(totalLocked[_recipient] > 0, \"!funding\");\n\n        _claim(_recipient, false);\n\n        uint256 delta = remaining(_recipient);\n        rewardToken.safeTransfer(admin, delta);\n\n        totalLocked[_recipient] = 0;\n\n        emit Cancelled(_recipient);\n    }\n\n    /***************************************\n                    VIEWS\n    ****************************************/\n\n    /**\n     * @notice Available amount to claim\n     * @param _recipient Recipient to lookup\n     */\n    function available(address _recipient) public view returns (uint256) {\n        uint256 vested = _totalVestedOf(_recipient, block.timestamp);\n        return vested - totalClaimed[_recipient];\n    }\n\n    /**\n     * @notice Total remaining vested amount\n     * @param _recipient Recipient to lookup\n     */\n    function remaining(address _recipient) public view returns (uint256) {\n        uint256 vested = _totalVestedOf(_recipient, block.timestamp);\n        return totalLocked[_recipient] - vested;\n    }\n\n    /**\n     * @notice Get total amount vested for this timestamp\n     * @param _recipient  Recipient to lookup\n     * @param _time       Timestamp to check vesting amount for\n     */\n    function _totalVestedOf(address _recipient, uint256 _time) internal view returns (uint256 total) {\n        if (_time < startTime) {\n            return 0;\n        }\n        uint256 locked = totalLocked[_recipient];\n        uint256 elapsed = _time - startTime;\n        total = AuraMath.min((locked * elapsed) / totalTime, locked);\n    }\n\n    /***************************************\n                    CLAIM\n    ****************************************/\n\n    function claim(bool _lock) external nonReentrant {\n        _claim(msg.sender, _lock);\n    }\n\n    /**\n     * @dev Claim reward token (Aura) and lock it.\n     * @param _recipient  Address to receive rewards.\n     * @param _lock       Lock rewards immediately.\n     */\n    function _claim(address _recipient, bool _lock) internal {\n        uint256 claimable = available(_recipient);\n\n        totalClaimed[_recipient] += claimable;\n\n        if (_lock) {\n            require(address(auraLocker) != address(0), \"!auraLocker\");\n            rewardToken.safeApprove(address(auraLocker), claimable);\n            auraLocker.lock(_recipient, claimable);\n        } else {\n            rewardToken.safeTransfer(_recipient, claimable);\n        }\n\n        emit Claim(_recipient, claimable, _lock);\n    }\n}\n\n\n",
        "CodeNames": [
            "AuraVestedEscrow.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AuraVestedEscrow.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "Reward can be vested even after endTime",
                "Repair": "Add a check to disallow funding once endTime has been reached"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from \"./AuraMath.sol\";\nimport \"./Interfaces.sol\";\n\ninterface IRewardStaking {\n    function stakeFor(address, uint256) external;\n}\n\n/**\n * @title   AuraLocker\n * @author  ConvexFinance\n * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available\n *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes\n *          to depositors.\n * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.\n */\ncontract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {\n    using AuraMath for uint256;\n    using AuraMath224 for uint224;\n    using AuraMath112 for uint112;\n    using AuraMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    /* ==========     STRUCTS     ========== */\n\n    struct RewardData {\n        /// Timestamp for current period finish\n        uint32 periodFinish;\n        /// Last time any user took action\n        uint32 lastUpdateTime;\n        /// RewardRate for the rest of the period\n        uint96 rewardRate;\n        /// Ever increasing rewardPerToken rate, based on % of total supply\n        uint96 rewardPerTokenStored;\n    }\n    struct UserData {\n        uint128 rewardPerTokenPaid;\n        uint128 rewards;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n    struct DelegateeCheckpoint {\n        uint224 votes;\n        uint32 epochStart;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Rewards\n    address[] public rewardTokens;\n    uint256 public queuedCvxCrvRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    //     Core reward data\n    mapping(address => RewardData) public rewardData;\n    //     Reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n    //     User -> reward token -> amount\n    mapping(address => mapping(address => UserData)) public userData;\n    //     Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n    //     Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // Balances\n    //     Supplies and historic supply\n    uint256 public lockedSupply;\n    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply\n    Epoch[] public epochs;\n    //     Mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    // Voting\n    //     Stored delegations\n    mapping(address => address) private _delegates;\n    //     Checkpointed votes\n    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;\n    //     Delegatee balances (user -> unlock timestamp -> amount)\n    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;\n\n    // Config\n    //     Tokens\n    IERC20 public immutable stakingToken;\n    address public immutable cvxCrv;\n    //     Denom for calcs\n    uint256 public constant denominator = 10000;\n    //     Staking cvxCrv\n    address public immutable cvxcrvStaking;\n    //     Incentives\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 3;\n    //     Shutdown\n    bool public isShutdown = false;\n\n    // Basic token data\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== EVENTS ========== */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateCheckpointed(address indexed delegate);\n\n    event Recovered(address _token, uint256 _amount);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardAdded(address indexed _token, uint256 _reward);\n\n    event KickIncentiveSet(uint256 rate, uint256 delay);\n    event Shutdown();\n\n    /***************************************\n                    CONSTRUCTOR\n    ****************************************/\n\n    /**\n     * @param _nameArg          Token name, simples\n     * @param _symbolArg        Token symbol\n     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)\n     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)\n     */\n    constructor(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _stakingToken,\n        address _cvxCrv,\n        address _cvxCrvStaking\n    ) Ownable() {\n        _name = _nameArg;\n        _symbol = _symbolArg;\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n        cvxCrv = _cvxCrv;\n        cvxcrvStaking = _cvxCrvStaking;\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));\n    }\n\n    /***************************************\n                    MODIFIER\n    ****************************************/\n\n    modifier updateReward(address _account) {\n        {\n            Balances storage userBalance = balances[_account];\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i = 0; i < rewardTokensLength; i++) {\n                address token = rewardTokens[i];\n                uint256 newRewardPerToken = _rewardPerToken(token);\n                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();\n                if (_account != address(0)) {\n                    userData[_account][token] = UserData({\n                        rewardPerTokenPaid: newRewardPerToken.to128(),\n                        rewards: _earned(_account, token, userBalance.locked).to128()\n                    });\n                }\n            }\n        }\n        _;\n    }\n\n    /***************************************\n                    ADMIN\n    ****************************************/\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(address _rewardsToken, address _distributor) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0, \"Reward already exists\");\n        require(_rewardsToken != address(stakingToken), \"Cannot add StakingToken as reward\");\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0, \"Reward does not exist\");\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n\n        emit KickIncentiveSet(_rate, _delay);\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    // Set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount);\n    }\n\n    //lock tokens\n    function _lock(address _account, uint256 _amount) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(_amount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n        }\n\n        address delegatee = delegates(_account);\n        if (delegatee != address(0)) {\n            delegateeUnlocks[delegatee][unlockTime] += lockAmount;\n            _checkpointDelegate(delegatee, lockAmount, 0);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(lockAmount);\n\n        emit Staked(_account, lockAmount, lockAmount);\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i < rewardTokensLength; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = userData[_account][_rewardsToken].rewards;\n            if (reward > 0) {\n                userData[_account][_rewardsToken].rewards = 0;\n                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n        //check to add\n        if (epochs[epochindex - 1].date < currentEpoch) {\n            //fill any epoch gaps until the next epoch date.\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);\n                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));\n            }\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));\n    }\n\n    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown\n    function emergencyWithdraw() external nonReentrant {\n        require(isShutdown, \"Must be shutdown\");\n\n        LockedBalance[] memory locks = userLocks[msg.sender];\n        Balances storage userBalance = balances[msg.sender];\n\n        uint256 amt = userBalance.locked;\n        require(amt > 0, \"Nothing locked\");\n\n        userBalance.locked = 0;\n        userBalance.nextUnlockIndex = locks.length.to32();\n        lockedSupply -= amt;\n\n        emit Withdrawn(msg.sender, amt, false);\n\n        stakingToken.safeTransfer(msg.sender, amt);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        uint256 expiryTime = _checkDelay == 0 && _relock\n            ? block.timestamp.add(rewardsDuration)\n            : block.timestamp.sub(_checkDelay);\n        require(length > 0, \"no locks\");\n        // e.g. now = 16\n        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)\n        // e.g. 17 <= (16 + 1)\n        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);\n                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > expiryTime) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);\n                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        lockedSupply = lockedSupply.sub(locked);\n\n        //checkpoint the delegatee\n        _checkpointDelegate(delegates(_account), 0, 0);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            stakingToken.safeTransfer(_rewardAddress, reward);\n            emit KickReward(_rewardAddress, _account, reward);\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_account, locked);\n        } else {\n            stakingToken.safeTransfer(_account, locked);\n        }\n    }\n\n    /***************************************\n            DELEGATION & VOTE BALANCE\n    ****************************************/\n\n    /**\n     * @dev Delegate votes from the sender to `newDelegatee`.\n     */\n    function delegate(address newDelegatee) external virtual nonReentrant {\n        // Step 1: Get lock data\n        LockedBalance[] storage locks = userLocks[msg.sender];\n        uint256 len = locks.length;\n        require(len > 0, \"Nothing to delegate\");\n        require(newDelegatee != address(0), \"Must delegate to someone\");\n\n        // Step 2: Update delegatee storage\n        address oldDelegatee = delegates(msg.sender);\n        require(newDelegatee != oldDelegatee, \"Must choose new delegatee\");\n        _delegates[msg.sender] = newDelegatee;\n\n        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);\n\n        // Step 3: Move balances around\n        //         Delegate for the upcoming epoch\n        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n        uint256 i = len - 1;\n        uint256 futureUnlocksSum = 0;\n        LockedBalance memory currentLock = locks[i];\n        // Step 3.1: Add future unlocks and sum balances\n        while (currentLock.unlockTime > upcomingEpoch) {\n            futureUnlocksSum += currentLock.amount;\n\n            if (oldDelegatee != address(0)) {\n                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;\n            }\n            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;\n\n            if (i > 0) {\n                i--;\n                currentLock = locks[i];\n            } else {\n                break;\n            }\n        }\n\n        // Step 3.2: Checkpoint old delegatee\n        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);\n\n        // Step 3.3: Checkpoint new delegatee\n        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);\n    }\n\n    function _checkpointDelegate(\n        address _account,\n        uint256 _upcomingAddition,\n        uint256 _upcomingDeduction\n    ) internal {\n        // This would only skip on first checkpointing\n        if (_account != address(0)) {\n            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];\n            if (ckpts.length > 0) {\n                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];\n                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks\n                if (prevCkpt.epochStart == upcomingEpoch) {\n                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({\n                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    });\n                }\n                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired\n                // e.g. week 1 + 17 <= 18\n                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                } else {\n                    uint256 nextEpoch = upcomingEpoch;\n                    uint256 unlocksSinceLatestCkpt = 0;\n                    // Should be maximum 18 iterations\n                    while (nextEpoch > prevCkpt.epochStart) {\n                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];\n                        nextEpoch -= rewardsDuration;\n                    }\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)\n                                .to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                }\n            } else {\n                ckpts.push(\n                    DelegateeCheckpoint({\n                        votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    })\n                );\n            }\n            emit DelegateCheckpointed(_account);\n        }\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) external view returns (uint256) {\n        return getPastVotes(account, block.timestamp);\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {\n        return _checkpointedVotes[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) external view virtual returns (uint32) {\n        return _checkpointedVotes[account].length.to32();\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     */\n    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {\n        require(timestamp <= block.timestamp, \"ERC20Votes: block not yet mined\");\n        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);\n        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);\n        votes = ckpt.votes;\n        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {\n            return 0;\n        }\n        while (epoch > ckpt.epochStart) {\n            votes -= delegateeUnlocks[account][epoch];\n            epoch -= rewardsDuration;\n        }\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     */\n    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {\n        require(timestamp < block.timestamp, \"ERC20Votes: block not yet mined\");\n        return totalSupplyAtEpoch(findEpochId(timestamp));\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     *      Copied from oz/ERC20Votes.sol\n     */\n    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)\n        private\n        view\n        returns (DelegateeCheckpoint memory)\n    {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = AuraMath.average(low, high);\n            if (ckpts[mid].epochStart > epochStart) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];\n    }\n\n    /***************************************\n                VIEWS - BALANCES\n    ****************************************/\n\n    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        return balanceAtEpochOf(findEpochId(block.timestamp), _user);\n    }\n\n    // Balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {\n        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));\n        require(epochStart < block.timestamp, \"Epoch is in the future\");\n\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        uint256 locksLength = locks.length;\n        for (uint256 i = locksLength; i > 0; i--) {\n            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            //also not include the current epoch\n            if (lockEpoch < epochStart) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i - 1].amount);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    // Information on a user's locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    // Supply of all properly locked balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        return totalSupplyAtEpoch(findEpochId(block.timestamp));\n    }\n\n    // Supply of all properly locked balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {\n        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));\n        require(epochStart < block.timestamp, \"Epoch is in the future\");\n\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 lastIndex = epochs.length - 1;\n\n        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;\n\n        for (uint256 i = epochIndex + 1; i > 0; i--) {\n            Epoch memory e = epochs[i - 1];\n            if (e.date == epochStart) {\n                continue;\n            } else if (e.date <= cutoffEpoch) {\n                break;\n            } else {\n                supply += e.supply;\n            }\n        }\n    }\n\n    // Get an epoch index based on timestamp\n    function findEpochId(uint256 _time) public view returns (uint256 epoch) {\n        return _time.sub(epochs[0].date).div(rewardsDuration);\n    }\n\n    /***************************************\n                VIEWS - GENERAL\n    ****************************************/\n\n    // Number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /***************************************\n                VIEWS - REWARDS\n    ****************************************/\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        uint256 userRewardsLength = userRewards.length;\n        for (uint256 i = 0; i < userRewardsLength; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(_account, token, userBalance.locked);\n        }\n        return userRewards;\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {\n        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        UserData memory data = userData[_user][_rewardsToken];\n        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {\n        return AuraMath.min(block.timestamp, _finishTime);\n    }\n\n    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {\n        if (lockedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(lockedSupply)\n            );\n    }\n\n    /***************************************\n                REWARD FUNDING\n    ****************************************/\n\n    function queueNewRewards(uint256 _rewards) external nonReentrant {\n        require(rewardDistributors[cvxCrv][msg.sender], \"!authorized\");\n        require(_rewards > 0, \"No reward\");\n\n        RewardData storage rdata = rewardData[cvxCrv];\n\n        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);\n\n        _rewards = _rewards.add(queuedCvxCrvRewards);\n        if (block.timestamp >= rdata.periodFinish) {\n            _notifyReward(cvxCrv, _rewards);\n            queuedCvxCrvRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rdata.rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            _notifyReward(cvxCrv, _rewards);\n            queuedCvxCrvRewards = 0;\n        } else {\n            queuedCvxCrvRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {\n        require(_rewardsToken != cvxCrv, \"Use queueNewRewards\");\n        require(rewardDistributors[_rewardsToken][msg.sender], \"Must be rewardsDistributor\");\n        require(_reward > 0, \"No reward\");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);\n    }\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {\n        RewardData storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to96();\n        } else {\n            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to32();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();\n\n        emit RewardAdded(_rewardsToken, _reward);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward token\u03c0\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}\n\n\n",
        "CodeNames": [
            "AuraLocker.sol",
            "ExtraRewardsDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ExtraRewardsDistributor.sol#L233-L240, AuraLocker.sol#L334-L337",
                "Type": "Reward locking",
                "Description": "Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed.",
                "Repair": "Allow users to supply endEpochIndex to the claim reward functions and only calculate reward from startIndex to min(auraLocker.epochCount() - 1, endEpochIndex). Add support for partial reward claiming."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "massUpdatePools() function",
                "Type": "DoS with block gas limit",
                "Description": "massUpdatePools() is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo.",
                "Repair": "Limit the max number of loop iterations to prevent hitting block gas limit."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { AuraMath } from \"./AuraMath.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuraLocker } from \"./Interfaces.sol\";\n\n/**\n * @title   AuraBalRewardPool\n * @author  Synthetix -> ConvexFinance -> adapted\n * @notice  This AuraBalRewardPool is deployed to support auraBAL deposits during the first 2\n *          weeks of system operation. After which, the BaseRewardPool hooked into the Booster (lockRewards)\n *          will be used for auraBAL farming.\n * @dev     Modifications from convex-platform/contracts/contracts/BaseRewardPool.sol:\n *            - Delayed start (tokens transferred then delay is enforced before notification)\n *            - One time duration of 14 days\n *            - Remove child reward contracts\n *            - Penalty on claim at 20%\n */\ncontract AuraBalRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 14 days;\n\n    address public immutable rewardManager;\n\n    IAuraLocker public immutable auraLocker;\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n    uint256 public immutable startTime;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @dev Simple constructoor\n     * @param _stakingToken  Pool LP token\n     * @param _rewardToken   $AURA\n     * @param _rewardManager Depositor\n     * @param _auraLocker    $AURA lock contract\n     * @param _penaltyForwarder Address to which penalties are sent\n     */\n    constructor(\n        address _stakingToken,\n        address _rewardToken,\n        address _rewardManager,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay\n    ) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardManager = _rewardManager;\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        rewardToken.safeApprove(_auraLocker, type(uint256).max);\n\n        require(_startDelay < 2 weeks, \"!delay\");\n        startTime = block.timestamp + _startDelay;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return AuraMath.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(\n        uint256 amount,\n        bool claim,\n        bool lock\n    ) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(lock);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Gives a staker their rewards\n     * @param _lock Lock the rewards? If false, takes a 20% haircut\n     */\n    function getReward(bool _lock) public updateReward(msg.sender) returns (bool) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            if (_lock) {\n                auraLocker.lock(msg.sender, reward);\n            } else {\n                uint256 penalty = (reward * 2) / 10;\n                pendingPenalty += penalty;\n                rewardToken.safeTransfer(msg.sender, reward - penalty);\n            }\n            emit RewardPaid(msg.sender, reward, _lock);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Forwards to the penalty forwarder for distro to Aura Lockers\n     */\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        rewardToken.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n\n    /**\n     * @dev Called once to initialise the rewards based on balance of stakeToken\n     */\n    function initialiseRewards() external returns (bool) {\n        require(msg.sender == rewardManager || block.timestamp > startTime, \"!authorized\");\n        require(rewardRate == 0, \"!one time\");\n\n        uint256 rewardsAvailable = rewardToken.balanceOf(address(this));\n        require(rewardsAvailable > 0, \"!balance\");\n\n        rewardRate = rewardsAvailable.div(duration);\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n\n        emit RewardAdded(rewardsAvailable);\n\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "AuraBalRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AuraBalRewardPool.getReward() function",
                "Type": "Penalty charged due to admin actions",
                "Description": "Users are charged a penalty when claiming rewards from the AuraBalRewardPool if they do not pass it into the AuraLocker, but if the AuraLocker has been shut down, the penalty path is the only option, which is unfair to users.",
                "Repair": "Do not charge the penalty if the AuraLocker has been shut down"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   CrvDepositor\n * @author  ConvexFinance\n * @notice  This is the entry point for CRV > cvxCRV wrapping. It accepts CRV, sends to 'staler'\n *          for depositing into Curves VotingEscrow, and then mints cvxCRV at 1:1 via the 'minter' (cCrv) minus\n *          the lockIncentive (initially 1%) which is used to basically compensate users who call the `lock` function on Curves\n *          system (larger depositors would likely want to lock).\n */\ncontract CrvDepositor{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crvBpt;\n    address public immutable escrow;\n    uint256 private constant MAXTIME = 1 * 364 * 86400;\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public lockIncentive = 10; //incentive to users who spend gas to lock crvBpt\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public feeManager;\n    address public daoOperator;\n    address public immutable staker;\n    address public immutable minter;\n    uint256 public incentiveCrv = 0;\n    uint256 public unlockTime;\n\n    bool public cooldown;\n\n    /**\n     * @param _staker   CVX VoterProxy (0x989AEb4d175e16225E39E87d0D97A3360524AD80)\n     * @param _minter   cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _crvBpt   crvBPT for veCRV deposits\n     * @param _escrow   CRV VotingEscrow (0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2)\n     */\n    constructor(\n        address _staker,\n        address _minter,\n        address _crvBpt,\n        address _escrow,\n        address _daoOperator\n    ) public {\n        staker = _staker;\n        minter = _minter;\n        crvBpt = _crvBpt;\n        escrow = _escrow;\n        feeManager = msg.sender;\n        daoOperator = _daoOperator;\n    }\n\n    function setFeeManager(address _feeManager) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeManager;\n    }\n\n    function setDaoOperator(address _daoOperator) external {\n        require(msg.sender == daoOperator, \"!auth\");\n        daoOperator = _daoOperator;\n    }\n\n    function setFees(uint256 _lockIncentive) external{\n        require(msg.sender==feeManager, \"!auth\");\n\n        if(_lockIncentive >= 0 && _lockIncentive <= 30){\n            lockIncentive = _lockIncentive;\n       }\n    }\n\n    function setCooldown(bool _cooldown) external {\n      require(msg.sender == daoOperator, \"!auth\");\n      cooldown = _cooldown;\n    }\n\n    /**\n     * @notice Called once to deposit the balance of CRV in this contract to the VotingEscrow\n     */\n    function initialLock() external{\n        require(!cooldown, \"cooldown\");\n        require(msg.sender==feeManager, \"!auth\");\n\n        uint256 vecrv = IERC20(escrow).balanceOf(staker);\n        if(vecrv == 0){\n            uint256 unlockAt = block.timestamp + MAXTIME;\n            uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n            //release old lock if exists\n            IStaker(staker).release();\n            //create new lock\n            uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\n            IStaker(staker).createLock(crvBalanceStaker, unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n    }\n\n    //lock curve\n    function _lockCurve() internal {\n        if(cooldown) {\n          return;\n        }\n\n        uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));\n        if(crvBalance > 0){\n            IERC20(crvBpt).safeTransfer(staker, crvBalance);\n        }\n        \n        //increase ammount\n        uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\n        if(crvBalanceStaker == 0){\n            return;\n        }\n        \n        //increase amount\n        IStaker(staker).increaseAmount(crvBalanceStaker);\n        \n\n        uint256 unlockAt = block.timestamp + MAXTIME;\n        uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n        //increase time too if over 2 week buffer\n        if(unlockInWeeks.sub(unlockTime) > 2){\n            IStaker(staker).increaseTime(unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n    }\n\n    /**\n     * @notice Locks the balance of CRV, and gives out an incentive to the caller\n     */\n    function lockCurve() external {\n        require(!cooldown, \"cooldown\");\n        _lockCurve();\n\n        //mint incentives\n        if(incentiveCrv > 0){\n            ITokenMinter(minter).mint(msg.sender,incentiveCrv);\n            incentiveCrv = 0;\n        }\n    }\n\n    /**\n     * @notice Deposit crvBpt for cvxCrv on behalf of another user\n     * @dev    See depositFor(address, uint256, bool, address) \n     */\n    function deposit(uint256 _amount, bool _lock, address _stakeAddress) public {\n        depositFor(msg.sender, _amount, _lock, _stakeAddress);\n    }\n\n    /**\n     * @notice Deposit crvBpt for cvxCrv\n     * @dev    Can locking immediately or defer locking to someone else by paying a fee.\n     *         while users can choose to lock or defer, this is mostly in place so that\n     *         the cvx reward contract isnt costly to claim rewards.\n     * @param _amount        Units of CRV to deposit\n     * @param _lock          Lock now? or pay ~1% to the locker\n     * @param _stakeAddress  Stake in cvxCrv staking?\n     */\n    function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {\n        require(_amount > 0,\"!>0\");\n        \n        if(_lock){\n            //lock immediately, transfer directly to staker to skip an erc20 transfer\n            IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);\n            _lockCurve();\n            if(incentiveCrv > 0){\n                //add the incentive tokens here so they can be staked together\n                _amount = _amount.add(incentiveCrv);\n                incentiveCrv = 0;\n            }\n        }else{\n            //move tokens here\n            IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);\n            //defer lock cost to another user\n            uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);\n            _amount = _amount.sub(callIncentive);\n\n            //add to a pool for lock caller\n            incentiveCrv = incentiveCrv.add(callIncentive);\n        }\n\n        bool depositOnly = _stakeAddress == address(0);\n        if(depositOnly){\n            //mint for to\n            ITokenMinter(minter).mint(to,_amount);\n        }else{\n            //mint here \n            ITokenMinter(minter).mint(address(this),_amount);\n            //stake for to\n            IERC20(minter).safeApprove(_stakeAddress,0);\n            IERC20(minter).safeApprove(_stakeAddress,_amount);\n            IRewards(_stakeAddress).stakeFor(to,_amount);\n        }\n    }\n\n    function deposit(uint256 _amount, bool _lock) external {\n        deposit(_amount,_lock,address(0));\n    }\n\n    function depositAll(bool _lock, address _stakeAddress) external{\n        uint256 crvBal = IERC20(crvBpt).balanceOf(msg.sender);\n        deposit(crvBal,_lock,_stakeAddress);\n    }\n}\n\n\n",
        "CodeNames": [
            "CrvDepositor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CrvDepositor.sol",
                "Type": "Incorrect implementation",
                "Description": "The implementation of the 2-week buffer for lock in CrvDepositor.sol is incorrect as unlockInWeeks is being used as a number in weeks instead of seconds, leading to a 2-second buffer instead of a 2-week buffer.",
                "Repair": "Change the implementation of the 2-week buffer for lock by changing the name of unlockTime to unlockTimeInWeeks and modifying the code in L94-102 and L127-L134"
            }
        ]
    }
]