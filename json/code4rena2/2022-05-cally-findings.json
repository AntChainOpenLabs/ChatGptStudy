[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "createVault() function",
                "Type": "Incompatible Token Vulnerability",
                "Description": "ERC20 tokens that charge a transaction fee for every transfer could be exploited if used in the createVault() function, resulting in loss of user funds and value from the Cally contract.",
                "Repair": "Disallowing fee tokens from being used in the vault by adding a require() statement to check that the amount increase of the token balance in the Cally contract is equal to the amount being sent by the caller of the createVault() function."
            },
            {
                "Location": "createVault() function",
                "Type": "Vault Creation Vulnerability",
                "Description": "It is possible to create a vault with Cally's own address as token, resulting in an unusable vault and locked ETH deposited by users in the Cally contract.",
                "Repair": "Add a check at the start of createVault() to disallow using Cally's own address as token."
            },
            {
                "Location": "createVault() function",
                "Type": "Mismatched Token Type",
                "Description": "When calling createVault(), tokenType could be different from token\u2019s type. If a user accidentally used the wrong tokenType, it could lead to two different results.",
                "Repair": "Confirm whether tokenType and token\u2019s type are the same in createVault()"
            },
            {
                "Location": "createVault() function",
                "Type": "Infinite Vault Creation",
                "Description": "A griefer is able to create as many vaults as they want by simply calling createVault() with tokenIdOrAmount = 0.",
                "Repair": "Add the simple check require(tokenIdOrAmount > 0, 'Amount must be greater than 0')"
            },
            {
                "Location": "createVault(), exercise(), and withdraw() functions",
                "Type": "Locked Rewards",
                "Description": "If rebasing tokens are used as the vault token, rewards accrue to the vault and cannot be withdrawn by either the option seller or the owner, and remain locked forever.",
                "Repair": "Track total amounts currently deposited and allow vault creators to withdraw excess on a pro-rata basis"
            },
            {
                "Location": "buyOption() function",
                "Type": "Accidental Overpayment",
                "Description": "It is possible for a user purchasing an option to accidentally overpay the premium during buyOption(). Any excess funds paid for in excess of the premium will be transferred to the vault creator.",
                "Repair": "Modify the check such that the msg.value is exactly equal to the premium"
            },
            {
                "Location": "setFee() function",
                "Type": "Fee Rate Manipulation",
                "Description": "The owner can force options to be non-exercisable, collecting premium without risking the loss of their NFT/tokens.",
                "Repair": "Add reasonable fee rate bounds checks in the setFee() function"
            },
            {
                "Location": "exercise() function",
                "Type": "Fee Stealing",
                "Description": "The owner can steal the exercise cost which should have gone to the option seller.",
                "Repair": "Fix the fee rate per vault during vault creation"
            },
            {
                "Location": "currentExpiration calculation",
                "Type": "Expiration Calculation Overflow",
                "Description": "Expiration calculation overflows if call option duration \u2265 195 days.",
                "Repair": "Cast the multiplication into uint32"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557     \u2588\u2588\u2557  \u2588\u2588\u2557   \u2588\u2588\u2557\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551  \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\n    \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2554\u255d \n    \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551    \u255a\u2588\u2588\u2554\u255d  \n    \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551   \n     \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d   \n                                      \n\n    \n    NFT & ERC20 covered call vaults.\n    this is intended to be a public good.\n    pog pog pog.\n    \n\n*/\n\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\n\nimport \"./CallyNft.sol\";\n\n/// @title Cally - https://cally.finance\n/// @author out.eth\n/// @notice NFT & ERC20 covered call vaults\ncontract Cally is CallyNft, ReentrancyGuard, Ownable {\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address payable;\n\n    /// @notice Fires when a new vault has been created\n    /// @param vaultId The newly minted vault NFT\n    /// @param from The account that created the vault\n    /// @param token The token address of the underlying asset\n    event NewVault(uint256 indexed vaultId, address indexed from, address indexed token);\n\n    /// @notice Fires when an option has been bought from a vault\n    /// @param optionId The newly minted option NFT\n    /// @param from The account that bought the option\n    /// @param token The token address of the underlying asset\n    event BoughtOption(uint256 indexed optionId, address indexed from, address indexed token);\n\n    /// @notice Fires when an option is exercised\n    /// @param optionId The option NFT which is being exercised\n    /// @param from The account that exercised the option\n    event ExercisedOption(uint256 indexed optionId, address indexed from);\n\n    /// @notice Fires when someone harvests their ETH balance\n    /// @param from The account that is harvesting\n    /// @param amount The amount of ETH which was harvested\n    event Harvested(address indexed from, uint256 amount);\n\n    /// @notice Fires when someone initiates a withdrawal on their vault\n    /// @param vaultId The vault NFT which is being withdrawn\n    /// @param from The account that is initiating the withdrawal\n    event InitiatedWithdrawal(uint256 indexed vaultId, address indexed from);\n\n    /// @notice Fires when someone withdraws their vault\n    /// @param vaultId The vault NFT which is being withdrawn\n    /// @param from The account that is withdrawing\n    event Withdrawal(uint256 indexed vaultId, address indexed from);\n\n    enum TokenType {\n        ERC721,\n        ERC20\n    }\n\n    struct Vault {\n        uint256 tokenIdOrAmount;\n        address token;\n        uint8 premiumIndex; // indexes into `premiumOptions`\n        uint8 durationDays; // days\n        uint8 dutchAuctionStartingStrikeIndex; // indexes into `strikeOptions`\n        uint32 currentExpiration;\n        bool isExercised;\n        bool isWithdrawing;\n        TokenType tokenType;\n        uint256 currentStrike;\n        uint256 dutchAuctionReserveStrike;\n    }\n\n    uint32 public constant AUCTION_DURATION = 24 hours;\n\n    // prettier-ignore\n    uint256[] public premiumOptions = [0.01 ether, 0.025 ether, 0.05 ether, 0.075 ether, 0.1 ether, 0.25 ether, 0.5 ether, 0.75 ether, 1.0 ether, 2.5 ether, 5.0 ether, 7.5 ether, 10 ether, 25 ether, 50 ether, 75 ether, 100 ether];\n    // prettier-ignore\n    uint256[] public strikeOptions = [1 ether, 2 ether, 3 ether, 5 ether, 8 ether, 13 ether, 21 ether, 34 ether, 55 ether, 89 ether, 144 ether, 233 ether, 377 ether, 610 ether, 987 ether, 1597 ether, 2584 ether, 4181 ether, 6765 ether];\n\n    uint256 public feeRate = 0;\n    uint256 public protocolUnclaimedFees = 0;\n\n    /// @notice The current vault index. Used for determining which\n    ///         tokenId to use when minting a new vault. Increments by\n    ///         2 on each new mint.\n    uint256 public vaultIndex = 1;\n\n    /// @notice Mapping of vault tokenId -> vault information\n    mapping(uint256 => Vault) private _vaults;\n\n    /// @notice Mapping of vault tokenId -> vault beneficiary.\n    ///         Beneficiary is credited the premium when option is\n    ///         purchased or strike ETH when option is exercised.\n    mapping(uint256 => address) private _vaultBeneficiaries;\n\n    /// @notice The unharvested ethBalance of each account\n    mapping(address => uint256) public ethBalance;\n\n    /*********************\n        ADMIN FUNCTIONS\n    **********************/\n\n    /// @notice Sets the fee that is applied on exercise\n    /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18\n    function setFee(uint256 feeRate_) external onlyOwner {\n        feeRate = feeRate_;\n    }\n\n    /// @notice Withdraws the protocol fees and sends to current owner\n    function withdrawProtocolFees() external onlyOwner returns (uint256 amount) {\n        amount = protocolUnclaimedFees;\n        protocolUnclaimedFees = 0;\n        payable(msg.sender).safeTransferETH(amount);\n    }\n\n    /**************************\n        MAIN LOGIC FUNCTIONS\n    ***************************/\n\n    /*\n        standard lifecycle:\n            createVault\n            buyOption (repeats)\n            exercise\n            initiateWithdraw\n            withdraw\n\n        [*] setVaultBeneficiary\n        [*] harvest\n\n        [*] can be called anytime in lifecycle\n    */\n\n    /// @notice Creates a new vault that perpetually sells calls\n    ///         on the underlying assets until a call option is exercised\n    ///         or the owner initiates a withdrawal.\n    /// @param tokenIdOrAmount The tokenId (NFT) or amount (ERC20) to vault\n    /// @param token The address of the NFT or ERC20 contract to vault\n    /// @param premiumIndex The index into the premiumOptions of each call that is sold\n    /// @param durationDays The length/duration of each call that is sold in days\n    /// @param dutchAuctionStartingStrikeIndex The index into the strikeOptions for the starting strike for each dutch auction\n    /// @param dutchAuctionReserveStrike The reserve strike for each dutch auction\n    /// @param tokenType The type of the underlying asset (NFT or ERC20)\n    function createVault(\n        uint256 tokenIdOrAmount,\n        address token,\n        uint8 premiumIndex,\n        uint8 durationDays,\n        uint8 dutchAuctionStartingStrikeIndex,\n        uint256 dutchAuctionReserveStrike,\n        TokenType tokenType\n    ) external returns (uint256 vaultId) {\n        require(premiumIndex < premiumOptions.length, \"Invalid premium index\");\n        require(dutchAuctionStartingStrikeIndex < strikeOptions.length, \"Invalid strike index\");\n        require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");\n        require(durationDays > 0, \"durationDays too small\");\n        require(tokenType == TokenType.ERC721 || tokenType == TokenType.ERC20, \"Invalid token type\");\n\n        Vault memory vault = Vault({\n            tokenIdOrAmount: tokenIdOrAmount,\n            token: token,\n            premiumIndex: premiumIndex,\n            durationDays: durationDays,\n            dutchAuctionStartingStrikeIndex: dutchAuctionStartingStrikeIndex,\n            currentExpiration: uint32(block.timestamp),\n            isExercised: false,\n            isWithdrawing: false,\n            tokenType: tokenType,\n            currentStrike: 0,\n            dutchAuctionReserveStrike: dutchAuctionReserveStrike\n        });\n\n        // vault index should always be odd\n        vaultIndex += 2;\n        vaultId = vaultIndex;\n        _vaults[vaultId] = vault;\n\n        // give msg.sender vault token\n        _mint(msg.sender, vaultId);\n\n        emit NewVault(vaultId, msg.sender, token);\n\n        // transfer the NFTs or ERC20s to the contract\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n    }\n\n    /// @notice Buys an option from a vault at a fixed premium and variable strike\n    ///         which is dependent on the dutch auction. Premium is credited to\n    ///         vault beneficiary.\n    /// @param vaultId The tokenId of the vault to buy the option from\n    function buyOption(uint256 vaultId) external payable returns (uint256 optionId) {\n        Vault memory vault = _vaults[vaultId];\n\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check vault exists\n        require(ownerOf(vaultId) != address(0), \"Vault does not exist\");\n\n        // check that the vault still has the NFTs as collateral\n        require(vault.isExercised == false, \"Vault already exercised\");\n\n        // check that the vault is not in withdrawing state\n        require(vault.isWithdrawing == false, \"Vault is being withdrawn\");\n\n        // check enough eth was sent to cover premium\n        uint256 premium = getPremium(vaultId);\n        require(msg.value >= premium, \"Incorrect ETH amount sent\");\n\n        // check option associated with the vault has expired\n        uint32 auctionStartTimestamp = vault.currentExpiration;\n        require(block.timestamp >= auctionStartTimestamp, \"Auction not started\");\n\n        // set new currentStrike\n        vault.currentStrike = getDutchAuctionStrike(\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n            vault.currentExpiration + AUCTION_DURATION,\n            vault.dutchAuctionReserveStrike\n        );\n\n        // set new expiration\n        vault.currentExpiration = uint32(block.timestamp) + (vault.durationDays * 1 days);\n\n        // update the vault with the new option expiration and strike\n        _vaults[vaultId] = vault;\n\n        // force transfer the vault's associated option from old owner to new owner\n        // option id for a respective vault is always vaultId + 1\n        optionId = vaultId + 1;\n        _forceTransfer(msg.sender, optionId);\n\n        // increment vault beneficiary's unclaimed premiums\n        address beneficiary = getVaultBeneficiary(vaultId);\n        ethBalance[beneficiary] += msg.value;\n\n        emit BoughtOption(optionId, msg.sender, vault.token);\n    }\n\n    /// @notice Exercises a call option and sends the underlying assets to the\n    ///         exerciser and the strike ETH to the vault beneficiary.\n    /// @param optionId The tokenId of the option to exercise\n    function exercise(uint256 optionId) external payable {\n        // optionId should always be even\n        require(optionId % 2 == 0, \"Not option type\");\n\n        // check owner\n        require(msg.sender == ownerOf(optionId), \"You are not the owner\");\n\n        uint256 vaultId = optionId - 1;\n        Vault memory vault = _vaults[vaultId];\n\n        // check option hasn't expired\n        require(block.timestamp < vault.currentExpiration, \"Option has expired\");\n\n        // check correct ETH amount was sent to pay the strike\n        require(msg.value == vault.currentStrike, \"Incorrect ETH sent for strike\");\n\n        // burn the option token\n        _burn(optionId);\n\n        // mark the vault as exercised\n        vault.isExercised = true;\n        _vaults[vaultId] = vault;\n\n        // collect protocol fee\n        uint256 fee = 0;\n        if (feeRate > 0) {\n            fee = (msg.value * feeRate) / 1e18;\n            protocolUnclaimedFees += fee;\n        }\n\n        // increment vault beneficiary's ETH balance\n        ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;\n\n        emit ExercisedOption(optionId, msg.sender);\n\n        // transfer the NFTs or ERC20s to the exerciser\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n    /// @notice Initiates a withdrawal so that the vault will no longer sell\n    ///         another call once the currently active call option has expired.\n    /// @param vaultId The tokenId of the vault to initiate a withdrawal on\n    function initiateWithdraw(uint256 vaultId) external {\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check msg.sender owns the vault\n        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n        _vaults[vaultId].isWithdrawing = true;\n\n        emit InitiatedWithdrawal(vaultId, msg.sender);\n    }\n\n    /// @notice Sends the underlying assets back to the vault owner and claims any\n    ///         unharvested premiums for the owner. Vault and it's associated option\n    ///         NFT are burned.\n    /// @param vaultId The tokenId of the vault to withdraw\n    function withdraw(uint256 vaultId) external nonReentrant {\n        // vaultId should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n\n        // check owner\n        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n        Vault memory vault = _vaults[vaultId];\n\n        // check vault can be withdrawn\n        require(vault.isExercised == false, \"Vault already exercised\");\n        require(vault.isWithdrawing, \"Vault not in withdrawable state\");\n        require(block.timestamp > vault.currentExpiration, \"Option still active\");\n\n        // burn option and vault\n        uint256 optionId = vaultId + 1;\n        _burn(optionId);\n        _burn(vaultId);\n\n        emit Withdrawal(vaultId, msg.sender);\n\n        // claim any ETH still in the account\n        harvest();\n\n        // transfer the NFTs or ERC20s back to the owner\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n    /// @notice Sets the vault beneficiary that will receive premiums/strike ETH from the vault\n    /// @param vaultId The tokenId of the vault to update\n    /// @param beneficiary The new vault beneficiary\n    function setVaultBeneficiary(uint256 vaultId, address beneficiary) external {\n        // vaultId's should always be odd\n        require(vaultId % 2 != 0, \"Not vault type\");\n        require(msg.sender == ownerOf(vaultId), \"Not owner\");\n\n        _vaultBeneficiaries[vaultId] = beneficiary;\n    }\n\n    /// @notice Sends any unclaimed ETH (premiums/strike) to the msg.sender\n    function harvest() public returns (uint256 amount) {\n        // reset premiums\n        amount = ethBalance[msg.sender];\n        ethBalance[msg.sender] = 0;\n\n        emit Harvested(msg.sender, amount);\n\n        // transfer premiums to owner\n        payable(msg.sender).safeTransferETH(amount);\n    }\n\n    /**********************\n        GETTER FUNCTIONS\n    ***********************/\n\n    /// @notice Get the current beneficiary for a vault\n    /// @param vaultId The tokenId of the vault to fetch the beneficiary for\n    /// @return beneficiary The beneficiary for the vault\n    function getVaultBeneficiary(uint256 vaultId) public view returns (address beneficiary) {\n        address currentBeneficiary = _vaultBeneficiaries[vaultId];\n\n        // return the current owner if vault beneficiary is not set\n        return currentBeneficiary == address(0) ? ownerOf(vaultId) : currentBeneficiary;\n    }\n\n    /// @notice Get details for a vault\n    /// @param vaultId The tokenId of the vault to fetch the details for\n    function vaults(uint256 vaultId) external view returns (Vault memory) {\n        return _vaults[vaultId];\n    }\n\n    /// @notice Get the fixed option premium for a vault\n    /// @param vaultId The tokenId of the vault to fetch the premium for\n    /// @return premium The premium for the vault\n    function getPremium(uint256 vaultId) public view returns (uint256 premium) {\n        Vault memory vault = _vaults[vaultId];\n        return premiumOptions[vault.premiumIndex];\n    }\n\n    /// @notice Get the current dutch auction strike for a start value and end\n    ///         timestamp. Strike decreases exponentially to 0 over time starting\n    ///         at startingStrike. Minimum value returned is reserveStrike.\n    /// @param startingStrike The starting strike value\n    /// @param auctionEndTimestamp The unix timestamp when the auction ends\n    /// @param reserveStrike The minimum value for the strike\n    /// @return strike The strike\n    function getDutchAuctionStrike(\n        uint256 startingStrike,\n        uint32 auctionEndTimestamp,\n        uint256 reserveStrike\n    ) public view returns (uint256 strike) {\n        /*\n            delta = max(auctionEnd - currentTimestamp, 0)\n            progress = delta / auctionDuration\n            auctionStrike = progress^2 * startingStrike\n            strike = max(auctionStrike, reserveStrike)\n        */\n        uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;\n        uint256 progress = (1e18 * delta) / AUCTION_DURATION;\n        uint256 auctionStrike = (progress * progress * startingStrike) / (1e18 * 1e18);\n\n        // max(auctionStrike, reserveStrike)\n        strike = auctionStrike > reserveStrike ? auctionStrike : reserveStrike;\n    }\n\n    /*************************\n        OVVERIDES FUNCTIONS\n    **************************/\n\n    /// @dev Resets the beneficiary address when transferring vault NFTs.\n    ///      The new beneficiary will be the account receiving the vault NFT.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // reset the beneficiary\n        bool isVaultToken = id % 2 != 0;\n        if (isVaultToken) {\n            _vaultBeneficiaries[id] = address(0);\n        }\n\n        _ownerOf[id] = to;\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_ownerOf[tokenId] != address(0), \"URI query for NOT_MINTED token\");\n\n        bool isVaultToken = tokenId % 2 != 0;\n        Vault memory vault = _vaults[isVaultToken ? tokenId : tokenId - 1];\n\n        string memory jsonStr = renderJson(\n            vault.token,\n            vault.tokenIdOrAmount,\n            getPremium(vault.premiumIndex),\n            vault.durationDays,\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n            vault.currentExpiration,\n            vault.currentStrike,\n            vault.isExercised,\n            isVaultToken\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(jsonStr))));\n    }\n}\n\n\n",
        "CodeNames": [
            "Cally.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "createVault() function in Cally.sol",
                "Type": "ERC20 token draining",
                "Description": "Some ERC20 tokens don't throw but just return false when a transfer fails. This can be abused to trick the createVault() function to initialize the vault without providing any tokens. When such a vault is initialized, another user can both buy and exercise the option without ever receiving any funds. The creator of the vault does receive the buyer's Ether though. So it can cause a loss of funds.",
                "Repair": "Use safeTransferFrom() when the token is of type ERC721. Consider using OpenZeppelin's SafeERC20 instead of solmate's SafeTransferLib."
            },
            {
                "Location": "createVault() function in Cally.sol",
                "Type": "Token trap",
                "Description": "When creating a new vault, solmate's SafeTransferLib is used for pulling vault.token from the caller's account, this issue won't exist if OpenZeppelin's SafeERC20 is used instead. A sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the future users that deposits with such tokens.",
                "Repair": "Consider using OpenZeppelin's SafeERC20 instead of solmate's SafeTransferLib."
            },
            {
                "Location": "getDutchAuctionStrike() function in Cally.sol contract",
                "Type": "Inefficiency",
                "Description": "The Dutch Auction is inefficient due to lower duration, resulting in reduced available time for users to participate in the auction and potentially filling options at very bad prices for the creator of the vault.",
                "Repair": "Modify the getDutchAuctionStrike() function such that the price drops to the reserveStrike exactly at 24 hours from the start of the auction"
            },
            {
                "Location": "transferFrom() function in Cally.sol contract",
                "Type": "Use of unsafe function",
                "Description": "The use of transferFrom() instead of safeTransferFrom() for NFT transfers can result in the onERC721Received() function not being triggered for certain NFTs, potentially leading to unexpected behavior.",
                "Repair": "Call the safeTransferFrom() method instead of transferFrom() for NFT transfers and inherit the ERC721TokenReceiver contract in the CallyNft contract"
            }
        ]
    }
]