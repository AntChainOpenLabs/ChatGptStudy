[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "liquidateAccount() function",
                "Type": "Smart Contract Vulnerability",
                "Description": "A malicious user can escape liquidation by depositing a Uni v3 position with 0 liquidity.",
                "Repair": "Check if liquidity is 0 when removeLiquidity"
            },
            {
                "Location": "_supplyCreditUni() function",
                "Type": "Smart Contract Vulnerability",
                "Description": "Use of tokenB\u2019s price instead of tokenA in determining account health will lead to protocol mis-accounting and insolvency.",
                "Repair": "Change the last argument of _convertTokenValues() from _priceB to _priceA"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity 0.8.6;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IERC721.sol';\nimport './interfaces/ILPTokenMaster.sol';\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/ILendingController.sol';\nimport './interfaces/univ3/IUniswapV3Helper.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Address.sol';\nimport './external/Clones.sol';\nimport './external/ReentrancyGuard.sol';\nimport './external/ERC721Receivable.sol';\n\nimport './TransferHelper.sol';\n\ncontract LendingPair is ILendingPair, ReentrancyGuard, TransferHelper, ERC721Receivable {\n\n  IERC721 internal constant uniManager = IERC721(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n  uint    public   constant LIQ_MIN_HEALTH = 1e18;\n\n  using Address for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public override supplySharesOf;\n  mapping (address => mapping (address => uint)) public debtSharesOf;\n  mapping (address => uint) public pendingSystemFees;\n  mapping (address => uint) public lastBlockAccrued;\n  mapping (address => uint) public override totalSupplyShares;\n  mapping (address => uint) public totalSupplyAmount;\n  mapping (address => uint) public totalDebtShares;\n  mapping (address => uint) public totalDebtAmount;\n  mapping (address => uint) public uniPosition;\n  mapping (address => uint) private decimals;\n  mapping (address => address) public override lpToken;\n\n  IUniswapV3Helper   private uniV3Helper;\n  ILendingController public  lendingController;\n\n  address public feeRecipient;\n  address public override tokenA;\n  address public override tokenB;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed token, uint amount);\n  event Borrow(address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n  event CollectSystemFee(address indexed token, uint amount);\n  event DepositUniPosition(address indexed account, uint positionID);\n  event WithdrawUniPosition(uint positionID);\n\n  receive() external payable {}\n\n  modifier onlyLpToken() {\n    require(lpToken[tokenA] == msg.sender || lpToken[tokenB] == msg.sender, \"LendingController: caller must be LP token\");\n    _;\n  }\n\n  function initialize(\n    address _lpTokenMaster,\n    address _lendingController,\n    address _uniV3Helper,\n    address _feeRecipient,\n    address _tokenA,\n    address _tokenB\n  ) external {\n    require(tokenA == address(0), \"LendingPair: already initialized\");\n    require(_tokenA != address(0) && _tokenB != address(0), \"LendingPair: cannot be ZERO address\");\n\n    lendingController = ILendingController(_lendingController);\n    uniV3Helper       = IUniswapV3Helper(_uniV3Helper);\n    feeRecipient      = _feeRecipient;\n    tokenA = _tokenA;\n    tokenB = _tokenB;\n    lastBlockAccrued[tokenA] = block.number;\n    lastBlockAccrued[tokenB] = block.number;\n\n    decimals[tokenA] = IERC20(tokenA).decimals();\n    decimals[tokenB] = IERC20(tokenB).decimals();\n\n    require(decimals[tokenA] >= 6 && decimals[tokenB] >= 6, \"LendingPair: min 6 decimals\");\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster, tokenA);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster, tokenB);\n  }\n\n  // Deposit limits do not apply to Uniswap positions\n  function depositUniPosition(address _account, uint _positionID) external {\n    _checkDepositsEnabled();\n    _validateUniPosition(_positionID);\n    require(uniPosition[_account] == 0, \"LendingPair: one position per account\");\n\n    uniManager.safeTransferFrom(msg.sender, address(this), _positionID);\n    uniPosition[_account] = _positionID;\n\n    emit DepositUniPosition(_account, _positionID);\n  }\n\n  function withdrawUniPosition() external {\n    uint positionID = uniPosition[msg.sender];\n    uniManager.safeTransferFrom(address(this), msg.sender, positionID);\n\n    uniPosition[msg.sender] = 0;\n    checkAccountHealth(msg.sender);\n\n    emit WithdrawUniPosition(positionID);\n  }\n\n  // claim & mint supply from uniswap fees\n  function uniClaimDeposit() external {\n    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);\n    _mintSupplyAmount(tokenA, msg.sender, amountA);\n    _mintSupplyAmount(tokenB, msg.sender, amountB);\n  }\n\n  // claim & withdraw uniswap fees\n  function uniClaimWithdraw() external {\n    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);\n    _safeTransfer(tokenA, msg.sender, amountA);\n    _safeTransfer(tokenB, msg.sender, amountB);\n  }\n\n  function depositRepay(address _account, address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _depositRepay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function depositRepayETH(address _account) external payable nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    _depositRepay(_account, address(WETH), msg.value);\n    _depositWeth();\n  }\n\n  function deposit(address _account, address _token, uint _amount) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _deposit(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrow(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawBorrow(_token, _amount);\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrowETH(uint _amount) external nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    _withdrawBorrow(address(WETH), _amount);\n    _wethWithdrawTo(msg.sender, _amount);\n  }\n\n  function withdraw(address _token, uint _amount) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawShares(_token, _supplyToShares(_token, _amount));\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function withdrawAll(address _token) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint shares = supplySharesOf[_token][msg.sender];\n    _withdrawShares(_token, shares);\n    _safeTransfer(_token, msg.sender, _sharesToSupply(_token, shares));\n  }\n\n  function withdrawAllETH() external nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    uint shares = supplySharesOf[address(WETH)][msg.sender];\n    _withdrawShares(address(WETH), shares);\n    _wethWithdrawTo(msg.sender, _sharesToSupply(address(WETH), shares));\n  }\n\n  function borrow(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _borrow(_token, _amount);\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function repayAll(address _account, address _token, uint _maxAmount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint amount = _repayShares(_account, _token, debtSharesOf[_token][_account]);\n    require(amount <= _maxAmount, \"LendingPair: amount <= _maxAmount\");\n    _safeTransferFrom(_token, msg.sender, amount);\n  }\n\n  function repayAllETH(address _account, uint _maxAmount) external payable nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    uint amount = _repayShares(_account, address(WETH), debtSharesOf[address(WETH)][_account]);\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\n    require(amount <= _maxAmount, \"LendingPair: amount <= _maxAmount\");\n\n    _depositWeth();\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\n\n    if (refundAmount > 0) {\n      _wethWithdrawTo(msg.sender, refundAmount);\n    }\n  }\n\n  function repay(address _account, address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _repayShares(_account, _token, _debtToShares(_token, _amount));\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function accrue(address _token) public {\n    if (lastBlockAccrued[_token] < block.number) {\n      uint newDebt   = _accrueDebt(_token);\n      uint newSupply = newDebt * _lpRate(_token) / 100e18;\n      totalSupplyAmount[_token] += newSupply;\n      pendingSystemFees[_token] += (newDebt - newSupply);\n      lastBlockAccrued[_token]   = block.number;\n    }\n  }\n\n  function collectSystemFee(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    pendingSystemFees[_token] -= _amount;\n    _safeTransfer(_token, feeRecipient, _amount);\n    emit CollectSystemFee(_token, _amount);\n  }\n\n  function transferLp(address _token, address _from, address _to, uint _amount) external override onlyLpToken {\n    require(debtSharesOf[_token][_to] == 0, \"LendingPair: cannot deposit borrowed token\");\n    supplySharesOf[_token][_from] -= _amount;\n    supplySharesOf[_token][_to]   += _amount;\n    checkAccountHealth(_from);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to type(uint).max to repay all debt, inc. pending interest\n  function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external nonReentrant {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    accrue(supplyToken);\n    accrue(_repayToken);\n\n    uint health = accountHealth(_account);\n    require(health < LIQ_MIN_HEALTH, \"LendingPair: account health < LIQ_MIN_HEALTH\");\n\n    // Fully unwrap Uni position - withdraw & mint supply\n\n    _unwrapUniPosition(_account);\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, _debtOf(_repayToken, _account));\n    (uint repayPrice, uint supplyPrice) = lendingController.tokenPrices(_repayToken, supplyToken);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount, repayPrice, supplyPrice);\n    uint callerFee    = supplyDebt * lendingController.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * lendingController.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupplyShares(supplyToken, _account, _supplyToShares(supplyToken, supplyBurn));\n    pendingSystemFees[supplyToken] += systemFee;\n    _burnDebtShares(_repayToken, _account, _debtToShares(_repayToken, _repayAmount));\n\n    // Uni position unwrapping can mint supply of already borrowed tokens\n\n    _repayDebtFromSupply(_account, tokenA);\n    _repayDebtFromSupply(_account, tokenB);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _mintSupplyAmount(supplyToken, msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  function accountHealth(address _account) public view returns(uint) {\n\n    if (debtSharesOf[tokenA][_account] == 0 && debtSharesOf[tokenB][_account] == 0) {\n      return LIQ_MIN_HEALTH;\n    }\n\n    (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n    uint colFactorA = lendingController.colFactor(tokenA);\n    uint colFactorB = lendingController.colFactor(tokenB);\n\n    uint creditA   = _supplyBalanceConverted(_account, tokenA, tokenA, priceA, priceA) * colFactorA / 100e18;\n    uint creditB   = _supplyBalanceConverted(_account, tokenB, tokenA, priceB, priceA) * colFactorB / 100e18;\n    uint creditUni = _supplyCreditUni(_account, tokenA, priceA, priceB, colFactorA, colFactorB);\n\n    uint totalAccountSupply = creditA + creditB + creditUni;\n\n    uint totalAccountBorrow =\n      _borrowBalanceConverted(_account, tokenA, tokenA, priceA, priceA) +\n      _borrowBalanceConverted(_account, tokenB, tokenA, priceB, priceA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrow;\n  }\n\n  function debtOf(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _debtOf(_token, _account);\n  }\n\n  function supplyOf(address _token, address _account) external view override returns(uint) {\n    _validateToken(_token);\n    return _supplyOf(_token, _account);\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    (uint borrowPrice, uint returnPrice) = lendingController.tokenPrices(_borrowedToken, _returnToken);\n    return _borrowBalanceConverted(_account, _borrowedToken, _returnToken, borrowPrice, returnPrice);\n  }\n\n  function supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view override returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    (uint supplyPrice, uint returnPrice) = lendingController.tokenPrices(_suppliedToken, _returnToken);\n    return _supplyBalanceConverted(_account, _suppliedToken, _returnToken, supplyPrice, returnPrice);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _interestRatePerBlock(_token) * _lpRate(_token) / 100e18;\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _interestRatePerBlock(_token);\n  }\n\n  function checkAccountHealth(address _account) public view  {\n    uint health = accountHealth(_account);\n    require(health >= LIQ_MIN_HEALTH, \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    (uint fromPrice, uint toPrice) = lendingController.tokenPrices(_fromToken, _toToken);\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount, fromPrice, toPrice);\n  }\n\n  function _depositRepay(address _account, address _token, uint _amount) internal {\n\n    uint debt          = _debtOf(_token, _account);\n    uint repayAmount   = debt > _amount ? _amount : debt;\n    uint depositAmount = _amount - repayAmount;\n\n    if (repayAmount > 0) {\n      _repayShares(_account, _token, _debtToShares(_token, repayAmount));\n    }\n\n    if (depositAmount > 0) {\n      _deposit(_account, _token, depositAmount);\n    }\n  }\n\n  function _withdrawBorrow(address _token, uint _amount) internal {\n\n    uint supplyAmount   = _supplyOf(_token, msg.sender);\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\n    uint borrowAmount   = _amount - withdrawAmount;\n\n    if (withdrawAmount > 0) {\n      _withdrawShares(_token, _supplyToShares(_token, withdrawAmount));\n    }\n\n    if (borrowAmount > 0) {\n      _borrow(_token, borrowAmount);\n    }\n  }\n\n  // Uses TWAP to estimate min outputs to reduce MEV\n  // Liquidation might be temporarily unavailable due to this\n  function _unwrapUniPosition(address _account) internal {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n      (uint amount0, uint amount1) = uniV3Helper.positionAmounts(uniPosition[_account], priceA, priceB);\n      uint uniMinOutput = lendingController.uniMinOutputPct();\n\n      uniManager.approve(address(uniV3Helper), uniPosition[_account]);\n      (uint amountA, uint amountB) = uniV3Helper.removeLiquidity(\n        uniPosition[_account],\n        amount0 * uniMinOutput / 100e18,\n        amount1 * uniMinOutput / 100e18\n      );\n      uniPosition[_account] = 0;\n\n      _mintSupplyAmount(tokenA, _account, amountA);\n      _mintSupplyAmount(tokenB, _account, amountB);\n    }\n  }\n\n  // Ensure we never have borrow + supply balances of the same token on the same account\n  function _repayDebtFromSupply(address _account, address _token) internal {\n\n    uint burnAmount = Math.min(_debtOf(_token, _account), _supplyOf(_token, _account));\n\n    if (burnAmount > 0) {\n      _burnDebtShares(_token, _account, _debtToShares(_token, burnAmount));\n      _burnSupplyShares(_token, _account, _supplyToShares(_token, burnAmount));\n    }\n  }\n\n  function _uniCollectFees(address _account) internal returns(uint, uint) {\n    uniManager.approve(address(uniV3Helper), uniPosition[_account]);\n    return uniV3Helper.collectFees(uniPosition[_account]);\n  }\n\n  function _mintSupplyAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _supplyToShares(_token, _amount);\n      supplySharesOf[_token][_account] += shares;\n      totalSupplyShares[_token] += shares;\n      totalSupplyAmount[_token] += _amount;\n    }\n  }\n\n  function _burnSupplyShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      amount = _sharesToSupply(_token, _shares);\n      supplySharesOf[_token][_account] -= _shares;\n      totalSupplyShares[_token] -= _shares;\n      totalSupplyAmount[_token] -= amount;\n    }\n  }\n\n  function _mintDebtAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _debtToShares(_token, _amount);\n      debtSharesOf[_token][_account] += shares;\n      totalDebtShares[_token] += shares;\n      totalDebtAmount[_token] += _amount;\n    }\n  }\n\n  function _burnDebtShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      amount = _sharesToDebt(_token, _shares);\n      debtSharesOf[_token][_account] -= _shares;\n      totalDebtShares[_token] -= _shares;\n      totalDebtAmount[_token] -= amount;\n    }\n  }\n\n  function _accrueDebt(address _token) internal returns(uint newDebt) {\n    if (totalDebtAmount[_token] > 0) {\n      uint blocksElapsed = block.number - lastBlockAccrued[_token];\n      uint pendingInterestRate = _interestRatePerBlock(_token) * blocksElapsed;\n      newDebt = totalDebtAmount[_token] * pendingInterestRate / 100e18;\n      totalDebtAmount[_token] += newDebt;\n    }\n  }\n\n  function _withdrawShares(address _token, uint _shares) internal {\n    uint amount = _burnSupplyShares(_token, msg.sender, _shares);\n    checkAccountHealth(msg.sender);\n    emit Withdraw(_token, amount);\n  }\n\n  function _borrow(address _token, uint _amount) internal {\n\n    require(supplySharesOf[_token][msg.sender] == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _mintDebtAmount(_token, msg.sender, _amount);\n\n    _checkBorrowEnabled();\n    _checkBorrowLimits(_token, msg.sender);\n    checkAccountHealth(msg.sender);\n\n    emit Borrow(_token, _amount);\n  }\n\n  function _repayShares(address _account, address _token, uint _shares) internal returns(uint amount) {\n    amount = _burnDebtShares(_token, _account, _shares);\n    emit Repay(_account, _token, amount);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n\n    require(debtSharesOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _mintSupplyAmount(_token, _account, _amount);\n    _checkDepositsEnabled();\n    _checkDepositLimit(_token);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _createLpToken(address _lpTokenMaster, address _underlying) internal returns(address) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize(_underlying, address(lendingController));\n    return address(newLPToken);\n  }\n\n  function _amountToShares(uint _totalShares, uint _totalAmount, uint _inputSupply) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputSupply * _totalShares / _totalAmount;\n    } else {\n      return _inputSupply;\n    }\n  }\n\n  function _sharesToAmount(uint _totalShares, uint _totalAmount, uint _inputShares) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputShares * _totalAmount / _totalShares;\n    } else {\n      return _inputShares;\n    }\n  }\n\n  function _debtToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalDebtShares[_token], totalDebtAmount[_token], _amount);\n  }\n\n  function _sharesToDebt(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalDebtShares[_token], totalDebtAmount[_token], _shares);\n  }\n\n  function _supplyToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalSupplyShares[_token], totalSupplyAmount[_token], _amount);\n  }\n\n  function _sharesToSupply(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalSupplyShares[_token], totalSupplyAmount[_token], _shares);\n  }\n\n  function _debtOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToDebt(_token, debtSharesOf[_token][_account]);\n  }\n\n  function _supplyOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToSupply(_token, supplySharesOf[_token][_account]);\n  }\n\n  function _interestRatePerBlock(address _token) internal view returns(uint) {\n    return _interestRateModel().interestRatePerBlock(\n      address(this),\n      _token,\n      totalSupplyAmount[_token],\n      totalDebtAmount[_token]\n    );\n  }\n\n  function _interestRateModel() internal view returns(IInterestRateModel) {\n    return IInterestRateModel(lendingController.interestRateModel());\n  }\n\n  // Get borrow balance converted to the units of _returnToken\n  function _borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken,\n    uint    _borrowPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _borrowedToken,\n      _returnToken,\n      _debtOf(_borrowedToken, _account),\n      _borrowPrice,\n      _returnPrice\n    );\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken,\n    uint    _supplyPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _suppliedToken,\n      _returnToken,\n      _supplyOf(_suppliedToken, _account),\n      _supplyPrice,\n      _returnPrice\n    );\n  }\n\n  function _supplyCreditUni(\n    address _account,\n    address _returnToken,\n    uint    _priceA,\n    uint    _priceB,\n    uint    _colFactorA,\n    uint    _colFactorB\n  ) internal view returns(uint) {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint amountA, uint amountB) = uniV3Helper.positionAmounts(uniPosition[_account], _priceA, _priceB);\n\n      uint supplyA = _convertTokenValues(tokenA, _returnToken, amountA, _priceA, _priceB);\n      uint supplyB = _convertTokenValues(tokenB, _returnToken, amountB, _priceB, _priceB);\n\n      uint creditA = supplyA * _colFactorA / 100e18;\n      uint creditB = supplyB * _colFactorB / 100e18;\n\n      return (creditA + creditB);\n\n    } else {\n      return 0;\n    }\n  }\n\n  // Not calling priceOracle.convertTokenValues() to save gas by reusing already fetched prices\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount,\n    uint    _fromPrice,\n    uint    _toPrice\n  ) internal view returns(uint) {\n\n    uint priceFrom = _fromPrice * 1e18 / 10 ** decimals[_fromToken];\n    uint priceTo   = _toPrice   * 1e18 / 10 ** decimals[_toToken];\n\n    return _inputAmount * priceFrom / priceTo;\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _validateUniPosition(uint _positionID) internal view {\n    (address uniTokenA, address uniTokenB) = uniV3Helper.positionTokens(_positionID);\n    _validateToken(uniTokenA);\n    _validateToken(uniTokenB);\n  }\n\n  function _checkDepositLimit(address _token) internal view {\n    uint depositLimit = lendingController.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require(totalSupplyAmount[_token] <= depositLimit, \"LendingPair: deposit limit reached\");\n    }\n  }\n\n  function _checkDepositsEnabled() internal view {\n    require(lendingController.depositsEnabled(), \"LendingPair: deposits disabled\");\n  }\n\n  function _checkBorrowEnabled() internal view {\n    require(lendingController.borrowingEnabled(), \"LendingPair: borrowing disabled\");\n  }\n\n  function _checkBorrowLimits(address _token, address _account) internal view {\n    uint borrowLimit = lendingController.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebtAmount[_token] <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _lpRate(address _token) internal view returns(uint) {\n    return _interestRateModel().lpRate(address(this), _token);\n  }\n}\n\n\n",
        "CodeNames": [
            "LendingPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LendingPair.uniClaimDeposit function",
                "Type": "Smart Contract Vulnerability",
                "Description": "An attacker can steal most of the accrued lpRate in a single atomic transaction.",
                "Repair": "Disallow collecting the 'parked' liquidity in a token by immediately collecting them when the NFT is deposited in depositUniPosition"
            },
            {
                "Location": "LendingPair.withdrawUniPosition function",
                "Type": "Smart Contract Vulnerability",
                "Description": "LendingPair.withdrawUniPosition should accrue debt first.",
                "Repair": "Accrue the debt for both tokens first in LendingPair.withdrawUniPosition"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/uniV3/IUniswapV3Pool.sol';\nimport './interfaces/uniV3/IUniswapV3Factory.sol';\nimport './interfaces/ILinkOracle.sol';\nimport './interfaces/IPriceOracle.sol';\nimport './interfaces/IUniswapPriceConverter.sol';\nimport './external/Ownable.sol';\n\ncontract UniswapV3Oracle is IPriceOracle, Ownable {\n\n  IUniswapV3Factory public constant uniFactory    = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n  ILinkOracle       public constant wethOracle    = ILinkOracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n  address           public constant WETH          = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  uint24            public constant WETH_POOL_FEE = 3000;\n\n  struct Pool {\n    address pairToken;\n    uint24  poolFee;\n  }\n\n  uint32 public twapPeriod;\n  uint16 public minObservations;\n\n  IUniswapPriceConverter public uniPriceConverter;\n\n  mapping(address => Pool) public pools;\n\n  event PoolAdded(address indexed token);\n  event PoolRemoved(address indexed token);\n  event NewTwapPeriod(uint32 value);\n  event NewMinObservations(uint16 value);\n  event NewUniPriceConverter(IUniswapPriceConverter value);\n\n  constructor(\n    IUniswapPriceConverter _uniPriceConverter,\n    uint32 _twapPeriod,\n    uint16 _minObservations\n  ) {\n    uniPriceConverter = _uniPriceConverter;\n    twapPeriod        = _twapPeriod;\n    minObservations   = _minObservations;\n  }\n\n  function addPool(\n    address _token,\n    address _pairToken,\n    uint24  _poolFee\n  ) external onlyOwner {\n\n    _validatePool(_token, _pairToken, _poolFee);\n\n    pools[_token] = Pool({\n      pairToken: _pairToken,\n      poolFee: _poolFee\n    });\n\n    emit PoolAdded(_token);\n  }\n\n  function removePool(address _token) external onlyOwner {\n    pools[_token] = Pool(address(0), 0);\n    emit PoolRemoved(_token);\n  }\n\n  function setUniPriceConverter(IUniswapPriceConverter _value) external onlyOwner {\n    uniPriceConverter = _value;\n    emit NewUniPriceConverter(_value);\n  }\n\n  function setTwapPeriod(uint32 _value) external onlyOwner {\n    twapPeriod = _value;\n    emit NewTwapPeriod(_value);\n  }\n\n  function setMinObservations(uint16 _value) external onlyOwner {\n    minObservations = _value;\n    emit NewMinObservations(_value);\n  }\n\n  function tokenPrice(address _token) public view override returns(uint) {\n    require(pools[_token].pairToken != address(0), \"UniswapV3Oracle: token not supported\");\n    _validatePool(_token, pools[_token].pairToken, pools[_token].poolFee);\n\n    uint ethValue = uniPriceConverter.assetToAssetThruRoute(\n      _token,\n      10 ** IERC20(_token).decimals(),\n      WETH,\n      twapPeriod,\n      pools[_token].pairToken,\n      [pools[_token].poolFee, WETH_POOL_FEE]\n    );\n\n    return ethValue * ethPrice() / 1e18;\n  }\n\n  function ethPrice() public view returns(uint) {\n    uint latestAnswer = wethOracle.latestAnswer();\n    require(latestAnswer > 1, \"LinkPriceOracle: invalid oracle value\");\n    return latestAnswer * 1e10;\n  }\n\n  // Not used in any LendingPair to save gas. But useful for external usage.\n  function convertTokenValues(address _fromToken, address _toToken, uint _amount) external view override returns(uint) {\n    uint priceFrom = tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();\n    uint priceTo   = tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();\n    return _amount * priceFrom / priceTo;\n  }\n\n  function isPoolValid(address _token, address _pairToken, uint24 _poolFee) public view returns(bool) {\n    address poolAddress = uniFactory.getPool(_token, _pairToken, _poolFee);\n    if (poolAddress == address(0)) { return false; }\n\n    (, , , , uint16 observationSlots, ,) = IUniswapV3Pool(poolAddress).slot0();\n    return observationSlots >= minObservations;\n  }\n\n  function tokenSupported(address _token) external view override returns(bool) {\n    return pools[_token].pairToken != address(0);\n  }\n\n  function _validatePool(address _token, address _pairToken, uint24 _poolFee) internal view {\n    require(isPoolValid(_token, _pairToken, _poolFee), \"UniswapV3Oracle: invalid pool\");\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapV3Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniswapV3Oracle.sol contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "The contract uses Chainlink\u2019s deprecated API latestAnswer().",
                "Repair": "Remove dependence on Chainlink completely"
            }
        ]
    }
]